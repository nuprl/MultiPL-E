name: HumanEval_95_check_dict_case
language: rb
prompt: "# Given a hash, return true if all keys are strings in lower \n# case or\
  \ all keys are strings in upper case, else return false.\n# The function should\
  \ return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"\
  a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"\
  a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"\
  a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"\
  Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>>\
  \ check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef\
  \ check_dict_case(dict)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n\
  \    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"\
  p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"\
  p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false,\
  \ candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"\
  }))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"\
  36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\"\
  \ => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"\
  fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n\
  \  end\nend\n"
completions: ["  case dict.length\n    when 0 then false\n    when 1 then dict.keys.all?\
    \ { |k| k.is_a?(String) || k.is_a?(Symbol) }\n    else false\n  end\nend", '  array.all?
    { |a| array.all? { |e| e.is_a? String } or array.all? { |e| e.is_a? String } }
    or array.all? { |a| array.all? { |e| e.is_a? String } or array.all? { |e| e.is_a?
    String } } or array.all? { |a| array.all? { |e| e.is_a? String } or array.all?
    { |e| e.is_a? String } } or array.all? { |a| array.all? { |e| e.is_a? String }
    } or array.all? { |a| array.all? { |e| e.is_a? String } } or array.all? { |a|
    array.all? { |e| e.is_a? String } } or array.all? { |a| array.all? { |e| e.is_a?
    String } } or array.all? { |a| array.all? { |e| e.is_a? String } } or array.all?
    { |a| array.all? { |e| e.is_a? String } } or array.all? { |a| array.all? { |e|
    e.is_a? String } } or array.all? { |a| array.all? { |e| e.is_a? String } } or
    array.all? { |a| array.all? { |e| e.is_a? String } } or array.all? { |a| array.all?
    { |e| e.is_a? String } } or array.all? { |a| array.all? { |e| e.is_a? String }
    } or array.all? { |a| array.all? { |e| e.is_a? String } } or array.all? { |a|
    array.all? { |e| e.is_a? String } } or array.all? { |a| array.all? { |e| e.is_a?
    String } } or array.all? { |a| array.all? { |e| e.is_a? String } } or array.all?
    { |a| array.all? { |e| e.is_a? String } } or array.all? { |a| array.all? { |e|
    e.is_a? String } } or array.all? { |a| array.all? { |e| e.is_a? String } } or
    array.all? { |a| array.all? { |e| e.is_a? String } } or array.all? { |a| ', " \
    \ case dict.length\n  when 0\n    false\n  when 1\n    dict.has_key?(dict.keys.first)\n\
    \  else\n    true\n  end\nend", "  if dict.empty?\n    return false\n  end\n \
    \ keys = dict.keys\n  keys.each do |key|\n    next unless key.is_a?(String)\n\
    \    case key.downcase\n    when key.upcase\n    else\n      return false\n  \
    \  end\n  end\n  true\nend", "  case dict.class\n  when Hash\n    dict.each do\
    \ |k, v|\n      if k.downcase != k.upcase\n        return false\n      end\n \
    \   end\n    true\n  else\n    false\n  end\nend", "    !dict.nil? and dict.class\
    \ == Hash\nend", "  if dict.nil?\n    return false\n  else\n    hash_key_values\
    \ = hash.values\n    hash_key_values.each do |value|\n      if value.is_a?(String)\n\
    \        if value.downcase == value.upcase\n          return true\n        else\n\
    \          return false\n        end\n      end\n    end\n    return false\n \
    \ end\nend", "    dict.each do |key, value|\n      case key\n        when String.upcase\n\
    \          unless value.is_a?(String)\n            return false\n          end\n\
    \        when String.downcase\n          unless value.is_a?(String)\n        \
    \    return false\n          end\n        else\n          return false\n     \
    \ end\n    end\n    return true\nend\n</code>\n<|/ a |>\n<| c |>\nPlease refrain\
    \ from using ternary operators inside `if/else` statements. The conditional operator\
    \ is for situations where a statement can either be executed or ignored. Here,\
    \ the expression `if (foo == true) then true else false end` is unnecessary and\
    \ incorrect, since the conditional operator already does its job: `foo == true`\
    \ returns either true or false. The `if` statement should be written: `if foo`\
    \ instead.\n<|/ c |>\n<| c |>\nThank you for the feedback.  Can you please explain\
    \ why my code is incorrect?\n<|/ c |>\n<| c |>\nThe code is fine, but it does\
    \ more work than necessary. For example, if all keys are strings in lower case,\
    \ `str.downcase!` does nothing. Also, `str.downcase!` is also unnecessary since\
    \ `str.downcase` will do that. `str.downcase` will return a new string, so the\
    \ statement can be written as `str.downcase!`. Lastly, the `if` statement can\
    \ be rewritten to simply `return str.downcase`.\n<|/ c |>\n<| c |>\n`str.downcase!`\
    \ won't return anything useful, since it's called on a copy.  It's like `str.upcase`\
    \ without the `!`.  `str.downcase` returns a copy.  `str.downcase!` returns nothing.\
    \  Also, `str.downcase!` is just an alias for `.downcase!`, which can be written\
    \ as `.downcase!`.  Finally, `if foo` is the same as `return foo`, since `foo`\
    \ will return the new string that `.downcase` returns.\n<|/ c |>\n<| c |>\nThank\
    \ you for the feedback.  I updated my answer to reflect your feedback.\n<|/ c\
    \ |>\n<| a |>\nJust for fun, here's a solution that uses recursion:\n<code>",
  "  return true if dict.kind_of?(Hash) && dict.all? {|k, v| v.kind_of?(String)}\n\
    \  false\nend\n</pre>", "  return false if dict.empty?\n  keys = dict.keys\n \
    \ keys.each do |key|\n    next if key.kind_of?(String)\n    next unless key.kind_of?(Symbol)\n\
    \    return false if key.upcase != key\n  end\n  true\nend", "  if dict.size ==\
    \ 0\n    return false\n  elsif dict.size == 1 and\n  !dict.key?(:to_s) and\n \
    \ !dict.key?(:to_sym)\n    return true\n  end\n  upper_keys = false\n  lower_keys\
    \ = false\n  dict.each do |k,v|\n    if v.is_a?(String)\n      upper_keys = true\n\
    \      lower_keys = true\n      break\n    end\n    if k.is_a?(String)\n     \
    \ upper_keys = false\n      lower_keys = true\n      break\n    end\n  end\n \
    \ return upper_keys == lower_keys\nend", "  empty = dict.empty?\n  empty || dict.key?(\"\
    STATE\") || dict.key?(\"ZIP\") || dict.key?(\"NAME\") || dict.key?(\"NAME\") \n\
    end", "  dict.each do |key,value|\n    if key =~ /^[A-Z]$/ || key =~ /^[a-z]/\n\
    \      return true\n    end\n    return false\n  end\n  return true\nend", " \
    \ return false if hash.size == 0 \n  hash.each do |key, val|\n    if !key.instance_of?(String)\
    \ || !val.instance_of?(String)\n      return false\n    end\n  end\n  return true\n\
    end", "  hash.each_key do |key|\n    unless hash[key].downcase.match(\"[a-z]\"\
    ) || hash[key].downcase.match(\"[A-Z]\")\n      return false\n    end\n  end\n\
    \  true\nend", "  return false if dict.nil? || dict.size == 0\n  case dict.keys.sort\n\
    \  when [\"string\", \"string\"]\n    true\n  when [\"string\", \"integer\"]\n\
    \    false\n  when [\"string\", \"symbol\"]\n    false\n  when [\"integer\", \"\
    string\"]\n    false\n  when [\"integer\", \"symbol\"]\n    false\n  when [\"\
    symbol\", \"string\"]\n    false\n  when [\"symbol\", \"integer\"]\n    false\n\
    \  when [\"integer\", \"integer\"]\n    true\n  when [\"symbol\", \"symbol\"]\n\
    \    true\n  else\n    false\n  end\nend", "    string_keys = dict.keys.sort\n\
    \    string_keys.each do |key|\n        unless hash[key].is_a?(String)\n     \
    \       return false\n        end\n    end\n    return true\nend\n</code>\n<|/\
    \ a tags=ruby,hash,string dscore=1 |>\n<| a tags=ruby,hash,string dscore=1 |>\n\
    This should do:\n<code>", "    return false if dict.empty?\n    keys = dict.keys\n\
    \    first = keys.first\n    last = keys.last\n    first = first.downcase\n  \
    \  last = last.downcase\n    return false if first.nil? || last.nil?\n    return\
    \ false if first == last\n    return false if keys.size == 1\n    keys.each do\
    \ |key|\n        next unless key.kind_of? String\n        return false if key.downcase\
    \ != key\n    end\n    return true\nend", "  dict.each do |key, value|\n    if\
    \ !value.is_a?(String) || !value.is_a?(String)\n      return false\n    end\n\
    \  end\n  true\nend", "  return false if dict.empty? || !dict.keys.all?(&:to_s).all?\
    \ { |k| k.casecmp(k.upcase) == 0 } \n  true\nend\n</code>\n<|/ a |>\n<| c |>\n\
    What about `{\"test\" => \"Hello World\"}`?\n<|/ c |>\n<| c |>\nThat would return\
    \ true, because \"test\" == test.upcase. That's a key case-insensitivity test.\n\
    <|/ c |>\n<| c |>\nThe solution by J\xF6rg W Mittag above is much better.  I used\
    \ the solution by J\xF6rg W Mittag above to fix some bugs, and then this one to\
    \ make the code more readable.\n<|/ c |>\n<| a |>\nHere's a solution:\n<code>",
  "  case \n  when dict.nil?\n    false\n  when Hash\n    if !dict.empty?\n      dict.each\
    \ { |k, v| return false if !k.is_a?(String) || !k.upcase.eql?(k) || !v.is_a?(String)\
    \ || !v.upcase.eql?(v) }\n      true\n    else\n      false\n    end\n  else\n\
    \    false\n  end\nend", "  return false if dict.nil? or dict.empty?\n  string.downcase!(dict.values)\
    \ || string.upcase!(dict.values)\n  true\nend", "  case dict.length\n  when 0\n\
    \    false\n  when 1\n    dict.values[0].is_a?(String)\n  else\n    dict.values.all?{|el|\
    \ el.is_a?(String)}\n  end\nend", "  keys = dict.keys.to_a\n  keys.sort!\n  return\
    \ keys.length == keys.inject(0) {|sum, key| sum + key.downcase == key.upcase}\n\
    end\n</code>\n<|/ a |>\n<| a |>\n<code>", "    true\nend", "  return false if\
    \ dict.empty?\n  dict.each do |k, v|\n    if k.to_s.downcase == k.to_s.upcase\
    \ \n      true\n    else\n      false\n    end\n  end\nend", "  if dict.class\
    \ == Hash\n    return false\n  else\n    return true\n  end\nend", "  # Your code\
    \ here\n  case dict\n  when Hash\n    true\n  when Array\n    true\n  else\n \
    \   false\n  end\nend", "  return false if dict.empty?\n  string.split(string.downcase(dict.keys.sort).join,',')\
    \ == string.split(string.upcase(dict.keys.sort).join,',')\nend", "  return false\
    \ if dict.empty?\n  dict.all?{|k, v| v.is_a?(String) }\nend", "  if !hash.length\n\
    \    true\n  else\n    hash.values.all? do |value|\n      value.kind_of?(String)\
    \ ? value.downcase : value.upcase == value.downcase\n    end\n  end\nend", " \
    \ if dict.size == 0\n    return true\n  else \n    for pair in dict\n      if\
    \ pair.key <= Hash.new{|h,k| h[k] = k}.key\n\treturn false\n      end\n    end\n\
    \  end\nend", "  true\nend\n</cell>\n<cell>", "  return true if dict.keys.length\
    \ == 0 || dict.keys.length.odd? || dict.keys.length.even?\n  \n  true\nend", " \
    \ if dict.empty?\n    return false\n  else\n    keys = dict.keys\n    keys.all?\
    \ { |key| key.kind_of?(String) }\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nThank\
    \ you for this. I implemented something similar in PHP and was getting error for\
    \ hash with symbols.\n<|/ c |>\n<| c |>\nI added the other solution I found. I\
    \ also added a comment to the code explaining the code. Hopefully this helps someone.\n\
    <|/ c |>\n<| a |>\nAs an alternative to's answer, you can use the keys as array\
    \ and pass them through Hash#values_at to check for presence. No need to use loops:\n\
    <code>", "  if dict.size == 0\n    return false\n  end\n  for key in dict\n  \
    \  return false if key[0].upcase != key[0].downcase\n  end\n  return true\nend",
  "  case dict\n  when Hash\n    dict.sort!\n    false  \n  when Array\n    true\n\
    \  else\n    false\n  end\nend", "  if dict.empty?\n    return false\n  end",
  "  dict.all? do |key, value|\n    key.to_s.downcase.to_s == key.to_s.upcase.to_s\n\
    \  end\nend", "  check_array(dict)\n  \n  return dict.empty? or string.upcase.all?\
    \ { |k| k.is_a? String } or string.downcase.all? { |k| k.is_a? String }\nend\n\
    </code>\n<|/ a |>\n<| c |>\nYou should mention that it requires Ruby 1.8.7 or\
    \ above.\n<|/ c |>\n<| c |>\n- good point, I have updated my answer to mention\
    \ that it requires Ruby 1.8.7 or above.\n<|/ c |>\n<| a dscore=5 tags=string,regex,ruby,string\
    \ |>\nI love this post, but I personally prefer something like this:\n<code>\n\
    str.match(/[a-z]/i).nil? && str.match(/[A-Z]/i).nil?\n</code>\n<|/ a |>\n<| c\
    \ |>\nI like the look of that solution, but I think it would be more correct to\
    \ say that it is non-idiomatic Ruby.\n<|/ c |>\n<| c |>\nI agree that it is non-idiomatic\
    \ Ruby, but I think it answers the question more directly than the accepted answer.\n\
    <|/ c |>\n<| c |>\nI like that one as well, it's shorter, doesn't require a regex,\
    \ and makes me think more clearly about what it does :)\n<|/ c |>\n<| c |>\nIt's\
    \ not shorter, it's a lot harder to understand what the code is doing. Ruby coders\
    \ will probably understand it more easily than the accepted answer.\n<|/ c |>\n\
    <| c |>\n: it's shorter, yes, but a lot harder to understand? What is so hard\
    \ to understand?\n<|/ c |>\n<| a dscore=5 tags=string,regex,ruby,string |>\n<code>\n\
    string =~ /[[:alpha:]]/ && ! string =~ /[[:alpha:]]/\n</code>\n<|/ a |>\n<| c\
    \ |>\nThe question was about lower-case and upper-case letters.\n<|/ c |>\n<|\
    \ c |>\nI missed that. `downcase` may have been a good choice.\n<|/ c |>\n<| a\
    \ tags=string,regex,ruby,string |>\nRuby 1.8.7+ has introduced Regexp Objects\
    \ which, among other things, includes a .match() method which you can use to check\
    \ if a string matches your regex.\nThe code below should achieve your goal:\n\
    <code>\nstring = 'abcdef'\nregexp = /[[:alpha:]]/\nstring.match(regexp) == nil\
    \ # => true", "  if dict.nil?\n    return false\n  end\n  \n  if dict.class ==\
    \ Hash\n    hash.keys.each do |key|\n      if key.class == String\n        key\
    \ = key.downcase\n      else\n        key = key.upcase\n      end\n      dict[key].nil?\
    \ ? false : true\n    end\n  else\n    hash.size\n  end\nend", "\tdict.each do\
    \ |key, value|\n\t\tvalue = value.downcase.to_s\n\t\tif value.blank?\n\t\t\treturn\
    \ false\n\t\telse\n\t\t\treturn true\n\t\tend\n\tend\n\treturn true\nend", " \
    \   hash = dict.to_hash\n    hash.each do |k,v|\n        v.downcase! unless k.nil?\
    \ || k.is_a?(String)\n        v.upcase! unless k.nil? || k.is_a?(String)\n   \
    \ end\n    return !hash.empty?\nend", "  if dict.empty?\n    false\n  else\n \
    \   dict.keys.each { |key| \n      unless key.downcase == key.upcase\n       \
    \ return false\n      end\n    }\n  end\n  true\nend", "  # Your code here\n \
    \ if dict.empty?\n    false\n  else\n    hash.all? {|key, value| \n      value\
    \ = key.downcase \n      key == value || key == value.upcase \n    }\n  end\n\
    end", "  return false if dict.empty? \n  keys.each do |key|\n    if !hash[key].is_a?(String)\n\
    \      return false\n    end\n  end\n  return true\nend", '  # Only change code
    below this line', '  check_keys(dict, [:A, :B, :C, :D, :E, :F, :G, :H, :I, :J,
    :K, :L, :M, :N, :O, :P, :Q, :R, :S, :T, :U, :V, :W, :X, :Y, :Z, :AA, :AB, :AC,
    :AD, :AE, :AF, :AG, :AH, :AI, :AJ, :AK, :AL, :AM, :AN, :AO, :AP, :AQ, :AR, :AS,
    :AT, :AU, :AV, :AW, :AX, :AY, :AZ, :BA, :BB, :BC, :BD, :BE, :BF, :BG, :BH, :BI,
    :BJ, :BK, :BL, :BM, :BN, :BO, :BP, :BQ, :BR, :BS, :BT, :BU, :BV, :BW, :BX, :BY,
    :BZ, :CA, :CB, :CC, :CD, :CE, :CF, :CG, :CH, :CI, :CJ, :CK, :CL, :CM, :CN, :CO,
    :CP, :CQ, :CR, :CS, :CT, :CU, :CV, :CW, :CX, :CY, :CZ, :DA, :DB, :DC, :DD, :DE,
    :DF, :DG, :DH, :DI, :DJ, :DK, :DL, :DM, :DN, :DO, :DP, :DQ, :DR, :DS, :DT, :DU,
    :DV, :DW, :DX, :DY, :DZ, :EA, :EB, :EC, :ED, :EE, :EF, :EG, :EH, :EI, :EJ, :EK,
    :EL, :EM, :EN, :EO, :EP, :EQ, :ER, :ES, :ET, :EU, :EV, :EW, :EX, :EY, :EZ, :FA,
    :FB, :FC, :FD, :FE, :FF, :FG, :FH, :FI, :FJ, :FK, :FL, :FM, :FN, :FO, :FP, :FQ,
    :FR, :FS, :FT, :FU, :F', "  return false if dict.empty?\n  dict.all? { |k, v|\
    \ k.is_a?(String) ? k.downcase == v.downcase : k.upcase == v.upcase }\nend", " \
    \ # Initialize return variable \n  result=False\n  # If hash is empty then return\
    \ False \n  if dict.size == 0\n    false\n  # Iterate through dictionary \n  else\n\
    \    # Iterate through keys and check \n    dict.each do |key, value|\n      #\
    \ Convert all keys to lower case\n      key = key.downcase\n      # Return true\
    \ if all keys are string in lower case\n      result = (result or key.kind_of?(String))\n\
    \    end\n  end\n  result\nend\n</cell>\n<text>\nNow let's run our function to\
    \ see how it works", "  if dict.size == 0\n    false\n  else\n    hash.all? {\
    \ |k, v| k.downcase == v.downcase }\n  end\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| a tags=ruby,ruby-on-rails,hash |>\nHere's a solution that's more succinct.\
    \  Since this is a common pattern I'll leave the method defined on the String\
    \ class as a public method.\n<code>", "  return false if dict.size == 0 \n  \n\
    \  upper = hash.map { |k, v| k.to_s.upcase }\n  lower = hash.map { |k, v| k.to_s.downcase\
    \ }\n  \n  if upper == lower\n    true\n  else\n    false\n  end\nend\n</code>\n\
    <|/ a tags=ruby,hash |>\n<| a |>\nIf you're using Rails, you can achieve this\
    \ with:\n<code>\nhash.all? { |k, v| k.respond_to? :downcase }\n</code>\n<|/ a\
    \ dscore=2 tags=ruby,hash |>\n<| a tags=ruby,hash |>\nI came up with this (it\
    \ works for me in MRI 1.9.3):\n<code>", "  if dict.nil?\n    false\n  else\n \
    \   all = (dict.kind_of? Hash)\n    all && (dict.has_key?(\"a\") == dict.has_key?(\"\
    A\"))\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nI added a more concise version\
    \ of this answer here: http://stackoverflow.com/a/26255910/488441\n<|/ c |>\n\
    <| a dscore=2 |>\nHere is another version based on answer by David Sulc. I think,\
    \ it is more straightforward than David's version. This also works when you have\
    \ a Hash object that has string keys, and you want to find out whether all keys\
    \ are strings or not. \n<code>", "  if dict.length == 0\n    false\n  else\n \
    \   for key in dict\n      if !string_key?(key)\n        false\n      else\n \
    \       lower = key.downcase()\n        upper = key.upcase()\n        if !lower\
    \ == upper\n          false\n        end\n      end\n    end\n  end\nend", " \
    \ return true if dict.keys.sort.collect { |key| key.length }.reduce(:+) == 0\n\
    end", "  # initialize variable to return value\n  result = true\n  # check if\
    \ the given hash is empty\n  if dict.empty?\n    puts \"The given hash is empty.\"\
    \n    result = false\n    return\n  end\n  # iterate through the keys to check\
    \ if the key is lowercase or uppercase\n  # NOTE: this will fail if the hash is\
    \ nil\n  dict.each do |k, v|\n    if k.downcase != k || v.downcase != v\n    \
    \  puts \"The given hash is not in the format of: 'key: value'.\"\n      result\
    \ = false\n      return\n    end\n  end\n  # if result is true, return result\
    \ \n  return result\nend", "  if dict.size > 0 then\n    return all(map(is_string(dict),\
    \ dict))\n  else\n    return true\n  end\nend", "  hash_copy = copy.copy(dict)\n\
    \  if hash_copy.key?(:lower)\n    hash_copy = hash_copy.dup\n    hash_copy.delete(:lower)\n\
    \  else\n    hash_copy = hash_copy.dup\n    hash_copy.delete(:upper)\n  end\n\
    \  hash_copy.each do |key, value|\n    next if value.nil?\n    next if !value.is_a?(String)\n\
    \    return false\n  end\n  return true\nend", "  return true unless dict.is_a?\
    \ Hash\n  return true unless dict.all? { |k, v| k.is_a?(String) && v.is_a?(String)\
    \ }\n  return false unless dict.all? { |k, v| k.is_a?(String) || k.upcase == k\
    \ }\n  return true unless dict.all? { |k, v| v.is_a?(String) || v.downcase ==\
    \ v }\n  return false unless dict.empty?\n  return true\nend", "  return false\
    \ if dict.nil? || dict.empty? || dict.size == 0\n  values = dict.values.sort\n\
    \  key = values.first.to_s.downcase\n  values.each do |value|\n    return false\
    \ if value.to_s.downcase != key\n  end\n  return true\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nI understand that but my function also needs to be validated. I\
    \ am just looking to see if there is a way to do that while keeping it as simple\
    \ as possible.\n<|/ c |>\n<| c |>\nYou can do that in the very same way. Just\
    \ `return false` inside the loop.\n<|/ c |>\n<| c |>\nAh I see, so I will add\
    \ return false within the loop?\n<|/ c |>\n<| c |>\nSure, just added an example.\n\
    <|/ c |>\n<| a |>\nRuby has case-sensitive string comparison.\n<code>\n\"a\" ==\
    \ \"A\" #=> true\n</code>\n<|/ a dscore=0 tags=ruby,hash |>\n<| c |>\nSorry, I\
    \ didn't make it clear. I am not looking to compare the keys or values. I need\
    \ to validate the entire hash. If I did say {\"a\" => \"apple\", \"A\" => \"banana\"\
    , \"B\" => \"banana\"} then that would be valid, but I would not want it to pass.\
    \ I was just going to say that I am already validating the values. I am trying\
    \ to see if there is a way to validate the entire hash with one method.\n<|/ c\
    \ |>\n<| a dscore=0 |>\nI ended up going with a different solution. I was originally\
    \ using a function which just compared one value against another, but I was only\
    \ validating the first one. As soon as I went through all of the values, I stopped\
    \ the function from going any further. This was the code I ended up using:\n<code>",
  "  all_string_keys = true\n  all_string_keys = all_string_keys and dict.keys.all?\
    \ { |key| key.kind_of?(String) }\n  all_string_keys = all_string_keys and dict.keys.all?\
    \ { |key| key =~ /[A-Z]/ }\n  all_string_keys = all_string_keys and dict.keys.all?\
    \ { |key| key =~ /[a-z]/ }\n  return all_string_keys\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThat is the question, why it is returning the opposite of what\
    \ it should? I'm sorry if I miss understood the question, but my answer is not\
    \ the question you asked.\n<|/ c |>\n<| c |>\nYou were right, I've added my own\
    \ answer which I believe works. Thanks for the help.\n<|/ c |>\n<| a tags=regex,ruby\
    \ |>\n<code>", "  hash.each do |key, value|\n    if value.is_a?(String) && !value.to_s.match(/^[a-z]+$/i)\
    \ && value.to_s.match(/^[A-Z]+$/i)\n      return false\n    end\n  end\n  true\n\
    end\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| a dscore=1 tags=ruby |>\nI did this\
    \ on ruby 2.3.0 (on OSX)\n<code>", "  # Your code here\n  case hash.length\n \
    \ when 0 then false\n  when 1 then true\n  else false\n  end\nend\n</code>\n<|/\
    \ a dscore=0 |>\n<| c |>\nI see no advantage to using `case` over `if`. Furthermore,\
    \ the OP asked for something more concise so why not use `if` ?\n<|/ c |>\n<|\
    \ c |>\nI agree, I just wanted to show how to use `case`. As far as `if` is concerned,\
    \ I agree that if is a better choice.\n<|/ c |>\n<| a |>\nYou want to be checking\
    \ only the first two elements in the hash, not the entire hash. Try the following\
    \ code:\n<code>", "  case hash.size \n    when 0 then false\n    when 1 then !!hash.keys.any?\
    \ && !!hash.values.any?\n    else false\n  end\nend", "  check_empty_hash(dict)\
    \ == false\n  return true\nend", "    dict.each do |key, value|\n        return\
    \ false if !is_string(key) || !is_string(value)\n    end\n    true\nend", "  result=true\n\
    \  if !dict.nil?\n    keys = dict.keys.sort\n    values.each do |value|\n    \
    \  if is_int(value)\n        false\n      else\n        if keys.length != 1 ||\
    \ keys[0] != value\n          result=false\n        end\n      end\n    end\n\
    \  end\n  return result\nend", "  true\n  false\nend\n</code>\n<|/ a tags=ruby,hash,case-sensitive\
    \ |>\n<| a dscore=2 |>\nA Hash is case sensitive, however, a String isn't. Strings\
    \ are case insensitive by default. \nIf you wish to have a Hash case sensitive,\
    \ then you should use Symbols instead of Strings. \n<code>\nh1 = {\"a\" => :apple,\
    \ \"b\" => :banana}\nh2 = {\"a\" => :apple, \"A\" => :banana, \"B\" => :banana}\n\
    h3 = {\"Name\" => :John, \"Age\" => :36, \"City\" => :Houston}", "  return false\
    \ if hash.nil? or hash.empty?\n  hash.keys.each do |key|\n    return true if hash[key].downcase\
    \ == hash[key].upcase\n    return false if hash[key].class == Integer\n  end\n\
    \  return true\nend\n</code>\n<|/ a dscore=1 tags=ruby,hash,case |>\n<| a tags=ruby,hash,case\
    \ |>\nHere's a quick way to check if the keys of your hash are all upper case\
    \ (as in the example). \n<code>", "  dict.keys.sort.all? do |key|\n    (key.match(/^[a-zA-Z]+$)\
    \ || key.match(/^[A-Z]+$/))\n  end\nend\n</code>\n<|/ a tags=hash,ruby dscore=2\
    \ |>\n<| a |>\nI would use something like the following:\n<code>", "  return false\
    \ if dict.size == 0 \n  \n  hash_lowercase = Hash[dict.map{ |k,v| [k.downcase,\
    \ v] }]\n  hash_upper = Hash[dict.map{ |k,v| [k.upcase, v] }]\n  \n  hash_lower.keys.all?\
    \ {|key| hash_upper[key].nil?} or hash_upper.keys.all? {|key| hash_lowercase[key].nil?}\n\
    end", "  dict.each do |key, value|\n    next if value.is_a?(String)\n    return\
    \ false if key?(key.downcase)\n    return false if key?(key.upcase)\n  end\n \
    \ true\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThat is actually a nice one-liner,\
    \ but I was curious how it would work under the covers :)\n<|/ c |>\n<| a |>\n\
    Here's a really simple recursive solution:\n<code>", "  all.each do |key, value|\n\
    \    if key.is_a? String\n      value[key.downcase] == value[key].upcase\n   \
    \ else\n      value.has_key?(key.to_s) && value[key.to_s].upcase == value[key].upcase\n\
    \    end\n  end\nend", "  if dict.nil?\n    false\n  else\n    true\n  end\nend\n\
    </code>\n<|/ a |>\n<| a dscore=1 |>\n<code>", "  dict.each do |key, value|\n \
    \   cased_key = key.to_s.downcase\n    cased_value = value.to_s.downcase\n   \
    \ return false if cased_key != cased_value\n  end\n  return true\nend", "  hash_size\
    \ = 0\n  hash_case = String.new\n  hash_case.capitalize!\n  hash_case.downcase!\n\
    \  hash_case.each do |key, value|\n    hash_size = hash_size + 1 if (key == hash_case)\n\
    \  end\n  hash_size.zero? || hash_size.odd?\nend", "  dict.each do |key, val|\n\
    \    return false unless key.class == String && val.class == String\n    return\
    \ false if key.length > val.length\n    return false if key.upcase != val.upcase\n\
    \  end\n  true\nend", "  hash_keys.each do |key|\n    case(dict[key].class) do\n\
    \    when String\n      expect(dict[key]).to eql(key.upcase)\n    when Integer\n\
    \      expect(dict[key]).to eql(key.to_s)\n    end\n  end\n  true\nend", "  case\
    \ hash_type\n  when Hash\n    hash.each do |k, v|\n      next if k.nil? || k.empty?\n\
    \      v = (v.nil? || v.empty?) ? nil : v\n      if k.downcase == k\n        return\
    \ true\n      elsif k.upcase == k\n        return true\n      else\n        return\
    \ false\n      end\n    end\n    return false\n  else\n    return false\n  end\n\
    end", "  # do something to check the dict\n  true\nend\n</code>\n<|/ a dscore=0\
    \ tags=ruby-on-rails-4,ruby-on-rails |>\n<| c |>\nThanks Hareesh, will check it\
    \ out. Also, is there a way I can check if all keys are in lower case only? For\
    \ example, in the above hash all keys are in all lower case so return true, else\
    \ return false. Thanks again, Robbie\n<|/ c |>\n<| c |>\n- Sure, added a couple\
    \ more options. You could even make a \"case-insensitive\" hash by setting `h\
    \ = {}; h.keys.each { |k| h[k] = k.downcase }` which would convert all keys to\
    \ all lowercase. You'll also need a `return false` at the end of `check_dict_case`\
    \ if you want a false return.\n<|/ c |>\n<| c |>\nThanks Robbie, will check and\
    \ let you know the outcome, much appreciated.\n<|/ c |>\n<| c |>\nHi Robbie, when\
    \ I execute the above code, I'm getting error. I'm very new to ruby, so not sure\
    \ how to fix it. Here's how it looks when I execute it (I added the code in the\
    \ question above). Thanks again. Robbie\n<|/ c |>\n<| c |>\n- Sorry, was missing\
    \ a semicolon in my code: `return false`. Fixed now.\n<|/ c |>\n<| a |>\nYou can\
    \ use Hash#detect to determine if all keys are present:\n<code>", "  # Your code\
    \ here\n  dict.keys.all? { |k| k.is_a?(String) && k.downcase == k.upcase }\nend",
  "    case = ( is_string_in_lower_case(dict) or \n             is_string_in_upper_case(dict)\
    \ )\n    return case\nend", "  if dict.size == 0 then\n    return false\n  end\n\
    \  hash = dict.clone\n  hash.map!{|key, value| \n    if hash[key].kind_of?(String)\
    \ then\n      hash[key] = hash[key].downcase\n    elsif hash[key].kind_of?(Integer)\
    \ then\n      hash[key] = hash[key].to_s\n    end\n    return hash\n  }\n  return\
    \ true\nend", "  keys = dict.keys\n  case hash.keys.length\n    when 0 then true\n\
    \    when 1 then keys.length <= 1\n    else keys.length <= keys[0].length\n  end\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI like your solution. I think it would\
    \ be better if you used `all?` instead of `any?` so that if one of the keys fails\
    \ but the other works, then it still returns `true`. That would prevent the case\
    \ that would not be handled in the accepted answer.\n<|/ c |>\n<| c |>\n`all?`\
    \ will also return true if the hash is empty, so I think this is probably the\
    \ best solution.\n<|/ c |>\n<| c |>\nTo prevent the case that would not be handled\
    \ in the accepted answer you'd have to use `all?` and check the hash keys separately\
    \ and explicitly check each key. As far as I can see, that's what the accepted\
    \ answer also does anyway.\n<|/ c |>\n<| c |>\nI see your point, however, this\
    \ answer has already been edited to add this case.  I'm happy to have my answer\
    \ edited to incorporate this case as well, however, I fear that it would not be\
    \ the most elegant solution.\n<|/ c |>\n<| c |>\nI don't think you can edit other\
    \ people's answers to incorporate your own edits. I suggest you roll back the\
    \ changes you made to this answer so that anyone else reading these answers can\
    \ see what they were talking about. Then you can add your own answer and leave\
    \ it at that.\n<|/ c |>\n<| a |>\nI know this question has already been answered\
    \ but another answer may come in handy in the future. I don't know if this is\
    \ true for OP but for other people who come across this question.\nThis answer\
    \ relies on Ruby 2.6.0.\nYou can call .keys on the Hash class which returns an\
    \ array of its keys.\n<code>\nHash.new.keys.include?('a') #=> true\n</code>\n\
    This means we can check if one of the keys exists by just checking the length\
    \ of the keys array.\n<code>", "  return false unless dict.nil?\n  case hash.length\n\
    \  when 0 then return false\n  else \n    hash.each do |key, value|\n      if\
    \ !value.instance_of?(String) then return false end\n      if key =~ /^[a-z]/i\
    \ || key =~ /^[A-Z]/i then return true\n    end\n  end\nend", "    return false\
    \ if dict.nil?\n    dict.each do |key, value|\n        return false if value.is_a?(String)\n\
    \        return false if value.upcase != value.downcase\n    end\n    return true\n\
    end\n</code>\n<|/ a dscore=4 tags=ruby,string |>\n<| a tags=ruby,string |>\n<code>",
  "  \n  return false\nend", "  return false if hash.empty?\n  h1 = hash.keys.sort.collect{|k|\
    \ k.to_s.downcase }\n  h2 = hash.keys.sort.collect{|k| k.to_s.upcase }\n  (h1\
    \ == h2).all?\nend", "\treturn !dict.empty? && dict.keys.all? { |k| k.downcase\
    \ == k.upcase }\nend", "  keys = dict.keys\n  return false if dict.empty? || keys.all?(&:nil?)\n\
    \  keys.all? { |k| k.casecmp(k.downcase).zero? } || \n    keys.all? { |k| k.casecmp(k.upcase).zero?\
    \ }\nend\n</code>\n<|/ a |>\n<| a tags=ruby |>\nIn addition to Sapan's answer,\
    \ I wrote a helper function to make it easy to handle arrays and hashes. The following\
    \ function will convert a string to a symbol if it is not already a symbol. It\
    \ also converts arrays and hashes to their appropriate types. \n<code>", "  !dict.empty?\
    \ && (\n    dict.keys.all? {|k| k.to_s.downcase == k.to_s.upcase} ||\n    dict.keys.all?\
    \ {|k| k.to_s.upcase == k.to_s.downcase}\n  )\nend", "  # check if hash is empty\n\
    \  if !dict.empty?\n    # loop through each key in the hash\n    dict.each do\
    \ |key, value|\n      # check if key is string\n      if value.kind_of? String\n\
    \        # check if key is in lower case\n        key.downcase == value\n    \
    \  else\n        # check if key is in upper case\n        key.upcase == value\n\
    \      end\n    end\n  end\nend\n</code>\n<|/ a tags=ruby,string |>\n<| a dscore=1\
    \ |>\nThe most generic solution I can think of is a regex:\n<code>", "  # TODO:\
    \ Implement Function\n  return true\nend", "  if dict.nil?\n    false\n  else\n\
    \    dict.each do |k, v|\n      if v.is_a?(String)\n        true\n      else\n\
    \        false\n      end\n    end\n  end\nend\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a |>\n<code>", "  result = true\n  hash.each do |k, v|\n    if k != k\n    \
    \  result = false\n    end\n    if v != v\n      result = false\n    end\n  end\n\
    \  result\nend", "    dict.each do |k,v|\n        unless k == 'Name'\n       \
    \     return true if k.downcase == v.downcase\n            return false if k.upcase\
    \ == v.upcase\n        end\n    end\n    true\nend", "  all_strings = true\n \
    \ all_upper_case = true\n  all_lower_case = true\n  keys = dict.keys\n  keys.each\
    \ do |key|\n    if !hash[key].nil?\n      if hash[key].kind_of? String\n     \
    \   all_strings = false\n      end\n      if hash[key].kind_of? String\n     \
    \   all_upper_case = false\n      end\n      if hash[key].kind_of? String\n  \
    \      all_lower_case = false\n      end\n    end\n  end\n  if all_strings &&\
    \ !all_upper_case && !all_lower_case\n    return true\n  else\n    return false\n\
    \  end\nend", '  return false if dict.empty? or dict.keys.length != 1 ', "  if\
    \ hash.empty?\n    false\n  else\n    hash.all? { |key, value| key == key.downcase\
    \ || key == key.upcase }\n  end\nend\n</code>\n<|/ a tags=ruby,arrays,hash |>\n\
    <| c |>\nThe OP wants to exclude *any* keys that begin with numbers.  Your solution\
    \ returns false when `key` is `\"0\"`.\n<|/ c |>\n<| c |>\n: you are right. I\
    \ didn't notice that requirement.\n<|/ c |>\n<| c |>\nI'm glad you posted an answer\
    \ that doesn't mutate the original hash.  I guess I missed that in the original\
    \ question.  (I do wonder whether that would have been a good idea.)\n<|/ c |>\n\
    <| c |>\n: I agree that mutating the original hash is not ideal. However, the\
    \ OP didn't indicate that they are allowed to mutate the original hash. My answer\
    \ was written to meet the stated requirements.\n<|/ c |>\n<| c |>\nI'm glad you\
    \ posted an answer that doesn't mutate the original hash.  I guess I missed that\
    \ in the original question.  (I do wonder whether that would have been a good\
    \ idea.)\n<|/ c |>\n<| a dscore=2 tags=ruby,arrays,hash |>\nIt seems you want\
    \ to find an arbitrary key starting with a digit, or a key that is a key of a\
    \ nested hash.\n<code>", "  # Your code here\n  return true\nend", "  return true\
    \ if dict == {}\n  hash.all? { |k, v| k.upcase == k.downcase }\nend", "  case\
    \ dict\n  when {}\n    true\n  when String\n    true\n  when Array\n    true\n\
    \  else\n    false\n  end\nend\n</code>\n<|/ a tags=functional-programming,ruby,ruby-on-rails\
    \ |>\n<| c |>\nWhy not just use `case a`. It'll do the same thing.\n<|/ c |>\n\
    <| c |>\nWhat does \"case a\" do, exactly?\n<|/ c |>\n<| c |>\nIt tests the argument\
    \ for its type, and if it is a String, true; if it is a Hash, true, etc etc\n\
    <|/ c |>\n<| a dscore=4 tags=functional-programming,ruby,ruby-on-rails |>\n<code>",
  "  return false unless dict.has_key?(\"__args__\")\n  return false unless dict[:__args__].size\
    \ == 0\n  all_upper = true\n  all_lower = true\n  keys = dict[:__args__]\n  keys.each\
    \ do |key|\n    if !check_case(key) || !check_case(key.to_s)\n      all_upper\
    \ = false\n    end\n    if !check_case(key.to_s) || !check_case(key)\n      all_lower\
    \ = false\n    end\n  end\n  return false if all_upper && all_lower\n  return\
    \ true\nend", "  !dict.nil? && !dict.empty? && dict.all? {|key, value| key.downcase\
    \ == value.downcase }\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThanks man! you\
    \ deserve a point because I didn't know about `all? { |key, value| key.downcase\
    \ == value.downcase }`. But I think your code is easier to read with one check\
    \ (maybe a little faster).\n<|/ c |>\n<| c |>\nYour code is way more elegant!\n\
    <|/ c |>\n<| c |>\nYour code also works for `check_dict_case({\"a\" => \"apple\"\
    , \"b\" => \"Banana\"})` since \"a\" is in all uppercase.\n<|/ c |>\n<| c |>\n\
    Hi Egor, how about `check_dict_case({\"a\" => \"apple\", \"b\" => \"BANana\"})`\
    \ ?\n<|/ c |>\n<| c |>\nI wonder why this was downvoted. Perhaps they didn't like\
    \ me using \"banana\" in place of \"Banana\" (though I see now that that's what\
    \ you're doing too)\n<|/ c |>\n<| a dscore=5 |>\nI know this is an old question,\
    \ but I came up with a new answer that worked for me:\n<code>", "  keys = hash.keys\n\
    \  keys.length == 0 || keys.all?{|k| k.is_a?(String)}\nend", "  return dict.all?\
    \ {|key, value| \n    key == key.upcase || key == key.downcase}\nend", "  unless\
    \ dict.has_key?(\"state\")\n    return true\n  end\n  if dict.has_key?(\"state\"\
    ) && dict.has_key?(\"zip\")\n    return false\n  end\n  hash_keys = dict.keySet().toArray()\n\
    \  return hash_keys.all?{|key| key.class.name == String }\nend", "\treturn !dict\
    \ || dict.empty? || dict.all? { |k,v| k.downcase == k || k.upcase == k }\nend",
  "  return false unless dict.is_a? Hash\n  dict.all? { |key,value| key.is_a? String\
    \ && value.is_a? String }\nend", "  case dict.keys.size \n  when 0 then false\n\
    \  when 1 then dict.values.first == dict.values.last\n  else true\n  end\nend\n\
    </code>\n<|/ a tags=ruby,hash |>\n<| a |>\n<code>", "  return false if hash.empty?\n\
    \  hash.keys.all? {|k| k.to_s.downcase == k.to_s.upcase}\nend", "  case = nil\n\
    \  if dict.size > 0\n    case.call(dict.values.join(\"\"))\n  else\n    case.call(\"\
    \")\n  end\nend\n</code>\n<|/ a |>\n<| a |>\n<code>", "  keys = dict.keys\n  keys.each{|key|\n\
    \    if !is_str(key) or !is_str(hash[key])\n      return false\n    end\n  }\n\
    \  true\nend\n</code>\n<|/ a tags=ruby,hash |>\n<| a tags=ruby,hash dscore=1 |>\n\
    <code>", "  if dict.empty?\n    false\n  elsif dict.has_key?(\"Name\")\n    dict.has_key?(\"\
    Name\").upcase == true\n  elsif dict.has_key?(\"AGE\")\n    dict.has_key?(\"AGE\"\
    ).upcase == true\n  elsif dict.has_key?(\"CITY\")\n    dict.has_key?(\"CITY\"\
    ).upcase == true\n  end\nend", "  return dict.keys.all? {|key| key.class == String\
    \ }\nend\n</code>\nAnd now it is trivial to write the method that determines if\
    \ a given key exists in a given hash using a case-insensitive comparison:\n<code>",
  "  return true if dict.size == 0 \n  keys.each do |key|\n    return false if dict[key].nil?\
    \ or dict[key].kind_of? String\n    return false if key.to_s.upcase != key.to_s.downcase\n\
    \    return false if dict[key] !~ /[a-z]/\n    return false if dict[key] !~ /[A-Z]/\n\
    \  end\n  return true\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nIf you\
    \ want a more readable code, try this:\n<code>", "    has_case_sensitive_keys\
    \ = false\n    has_case_sensitive_numbers = false\n    has_case_sensitive_numbers\
    \ = false\n    has_case_sensitive_characters = false\n    if !dict.empty?\n  \
    \      dict.each do |key, value|\n            if key.kind_of?(Integer)\n     \
    \           has_case_sensitive_numbers = true\n            else\n            \
    \    has_case_sensitive_keys = true\n            end\n        end\n    end\nend\n\
    </code>\n<|/ a |>\n<| c |>\nYour code seems to be missing `end` keywords\n<|/\
    \ c |>\n<| c |>\nThanks! Fixed the missing `end` keywords.\n<|/ c |>\n<| a |>\n\
    Here's another option that doesn't require any additional methods:\n<code>\nrequire\
    \ \"csv\"", "  return false if dict.empty?\n  keys.each { |k| k.downcase == k.upcase\
    \ }\nend", "\tcase \n\t\twhen dict.size == 0 then return false\n\t\twhen dict.size\
    \ == 1 then return true\n\tend\n\t\n\tkeys.each do |key|\n\t\tcase key\n\t\t\t\
    when String\n\t\t\t\tstr = key.to_s\n\t\t\t\tcase str\n\t\t\t\t\twhen str.length\
    \ <= 1 then return true\n\t\t\t\t\twhen str.length <= 2 then return false\n\t\t\
    \t\tend\n\t\t\twhen Integer\n\t\t\t\tstr = key.to_s\n\t\t\t\tcase str\n\t\t\t\t\
    \twhen str.length <= 1 then return true\n\t\t\t\t\twhen str.length <= 2 then return\
    \ false\n\t\t\t\tend\n\t\t\telse\n\t\t\t\traise \"#{key} can't be converted to\
    \ lower or upper case\"\n\t\tend\n\tend\n\treturn true\nend", "  return true if\
    \ dict.key?(string.lower(key)) || dict.key?(string.upper(key))\n  false\nend",
  "  # initialize result to true\n  result = true\n  \n  # loop through each key and\
    \ value in the given hash\n  hash.each do |key, value|\n    # if the key or value\
    \ is an empty string, then continue to next \n    # loop iteration.\n    if value.nil?\
    \ || value.empty? \n      next \n    end\n    \n    # check if the key is a string,\
    \ and it is lower case.\n    if key.class == String && key.downcase != key \n\
    \      result = false \n    else \n      # check if the key is an string, and\
    \ it is upper case.\n      if key.class == String && key.upcase != key \n    \
    \    result = false \n      end\n    end\n  end\n  \n  # return the result\n \
    \ result\nend", "  dict.each do |key, value|\n    unless value.is_a? String\n\
    \      return false\n    end\n  end\n  return true\nend", "  if dict.empty?\n\
    \    false\n  else\n    dict.all? {|k,v| k.is_a? String and v.is_a? String}\n\
    \  end\nend", "  return false if dict.empty?\n  dict.each do |key, value|\n  \
    \  return false unless value.kind_of? String\n    value.downcase! if value.is_a?\
    \ String\n    value.upcase! if value.is_a? String\n  end\n  return true\nend",
  "  return false if dict.nil? or dict.empty?\n  all_string = true if dict.keys.all?\
    \ {|k| k.kind_of?(String)} \n  all_string = false if dict.keys.any? {|k| k.kind_of?(String)}\n\
    \  return all_string or all_string\nend", "  if dict.empty?\n    return false\n\
    \  else\n    h = dict.dup\n    h.delete_if{|k, v| k.is_a? Integer}\n    h.delete_if{|k,\
    \ v| k.is_a? String}\n    h.each do |k, v|\n      if k.is_a? String\n        if\
    \ k.downcase == k.upcase\n          raise ArgumentError, \"String keys cannot\
    \ have case differences: #{k}\"\n        end\n      end\n    end\n    true\n \
    \ end\nend", "  string.empty?(dict.keys) or string.empty?(dict.values)\nend",
  "  hash.each do |key, value|\n    next unless value.is_a?(String) || value.is_a?(Fixnum)\n\
    \    hash[key.downcase] = value\n  end\n  hash.size == 0\nend", "  return false\
    \ if dict.nil? || dict.empty? \n  \n  case hash.length\n  when 0 \n    true\n\
    \  when 1 \n    return false if ! (hash.key?(:keys) && hash[keys][0].class ==\
    \ String)\n    true\n  when 2\n    return false if ! (hash.key?(:keys) && hash[keys][0].class\
    \ == String) && hash[keys][1].class == String\n    true\n  else\n    return false\
    \ if ! (hash.key?(:keys) && hash[keys][0].class == String) && hash[keys][1].class\
    \ == String && hash[keys][2].class == String\n    true\n  end\nend", "  return\
    \ false unless dict.size > 0 && dict.size == keys.size\n  keys.each do |key|\n\
    \    unless dict[key].downcase == dict[key].upcase\n      return false\n    end\n\
    \  end\n  return true\nend", "  return false if dict.nil? or dict.empty?\n  dict.each\
    \ do |k, v|\n    return false if k.nil? or k.empty?\n    return false if k.upcase\
    \ != k or k.downcase != k\n  end\n  return true\nend", "  hash.each { |k, v| return\
    \ false unless v.is_a?(String) || v.is_a?(String) }\n  return true\nend", "  dict.each\
    \ do |key,value|\n    if value.is_a? String\n      value = \"#{value.downcase}\"\
    \n    else\n      value = \"#{value}\"\n    end\n    unless key.to_s.downcase.match(value)\n\
    \      return false\n    end\n  end\n  return true\nend\n</code>\n<code>", " \
    \ return !dict.nil? && !dict.empty? && dict.keys.all? {|key| key =~ /^[[:alpha:]]+$|^[[:upper:]]+$/\
    \ }\nend\n</code>\n<|/ a tags=ruby,hash,ruby-on-rails,arrays |>\n<| a |>\nI wanted\
    \ to share a variant of S. Kuhmonen's answer which was able to check whether a\
    \ hash had a key present by checking against an empty string. This code also checks\
    \ for nil values.\n<code>", "    dict.each do |key,value|\n        next if value.is_a?(Hash)\n\
    \        next if !value || value.nil?\n        next if value.downcase == value.upcase\n\
    \        raise ArgumentError, 'invalid dictionary key! (%s)' % key unless key.is_a?(String)\n\
    \    end\n    true\nend\n</code>\n<|/ a |>\n<| c |>\nI really like this answer.\
    \ Thank you, this is something I didn't know about.\n<|/ c |>\n<| c |>\nAm I missing\
    \ something?  `check_dict_case({'a' => 'apple', 8 => 'banana', 'a' => 'apple'})`\
    \ returns `true` which is not the correct answer.\n<|/ c |>\n<| a dscore=4 |>\n\
    <code>\nfunction is_hash_all_keys_to_lower_case?(hash)\n  hash = hash.clone\n\
    \  hash.keys.each do |key|\n    if hash[key].is_a?(Hash)\n      hash[key] = hash[key].clone\n\
    \      hash[key].keys.each do |key_lower|\n        if key_lower == key.downcase\n\
    \          hash[key][key_lower] = hash[key][key_lower].clone\n          hash[key][key_lower].each\
    \ do |key_lower_upper|\n            if key_lower_upper != key.downcase && key_lower_upper\
    \ != key.upcase\n              raise ArgumentError, \"Invalid hash key #{key}\
    \ -> #{key_lower} -> #{key_lower_upper}\"\n            end\n          end\n  \
    \      end\n      end\n    else\n      raise ArgumentError, \"Invalid hash key\
    \ #{key}\"\n    end\n  end\n  true\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby\
    \ |>\nI have modified this version from Steve Gibson in order to accept nested\
    \ hashes also:\n<code>", "  case dict \n  when String\n    true\n  when Hash\n\
    \    true\n    \n  when Numeric\n    true\n  else\n    false\n  end\nend", " \
    \ if dict.empty?\n    false\n  elsif hash_keys_are_strings(dict)\n    true\n \
    \ else\n    false\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\n`check_dict_case`\
    \ doesn't handle nested hash correctly.\n<|/ c |>\n<| c |>\nThanks. I have updated\
    \ the answer. Can you please take a look at it? Thanks.\n<|/ c |>\n<| a |>\nAnother\
    \ version in Ruby 1.9:\n<code>", "  if dict.nil? \n    return false\n  else\n\
    \    hash_array = array.to_hash\n    hash_array.each do |key|\n      case_insensitive_key\
    \ = \"#{key.to_s.downcase}\"\n      case_insensitive_key_value = \"#{key.to_s.upcase}\"\
    \n      case_insensitive_key = case_insensitive_key.upcase unless case_insensitive_key.match(/\\\
    A[A-Z]*\\z/)\n      case_insensitive_key_value = case_insensitive_key_value.upcase\
    \ unless case_insensitive_key_value.match(/\\A[A-Z]*\\z/)\n      return false\
    \ if hash[key] != case_insensitive_key\n      return false if hash[key] != case_insensitive_key_value\n\
    \    end\n    return true\n  end\nend", "  has_key = has_key? dict \n  unless\
    \ has_key?(:case)\n    has_key = has_key? dict.to_h\n  end\n  if has_key\n   \
    \ hash.each do |key, val|\n      if !key.casecmp(val).zero?\n        has_key =\
    \ false\n      end\n    end\n  end\n  has_key\nend", "\treturn !dict.empty? and\
    \ all? dict, lambda { |k,v| k.downcase == k.upcase }\nend", "    string.all?(dict.keys.map(&:to_s).sort.uniq,\
    \ &:downcase)\nend", "    true\nend", "  if dict.empty?\n    false\n  else\n \
    \   true if dict.keys.all?{|k| k.is_a?(String)}\n  end\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThanks for this, it works very well for me. I don't have a lot of experience\
    \ with ruby, but this has helped me learn the language. Cheers.\n<|/ c |>\n<|\
    \ c |>\n`has_key?` has been deprecated since Ruby 1.9.\n<|/ c |>\n<| a tags=hash,ruby,string\
    \ dscore=2 |>\nSince Ruby 2.2, has_key? has been deprecated and has been removed\
    \ from Hash class.\nWe can use key?(key) method instead of has_key?(key)\n<code>",
  "  if dict.size > 0\n    str.downcase!(@keys)\n    str.upcase!(@keys)\n    dict.each\
    \ do |key, value|\n      if @keys[key] == @keys[key].to_s\n        true\n    \
    \  else\n        false\n      end\n    end\n  else\n    false\n  end\nend", " \
    \ return false if dict.nil? || dict.empty?\n  hash.each do |k, v|\n    return\
    \ false if k != k.upcase && k != k.downcase\n  end\n  return true\nend", "   \
    \ false = false # default false\n    # Write your code here\n    return false\n\
    end\n</cell>\n<text>\nTest your Code\nRun the cell below to test your code.",
  "  case dict.length\n  when 0 then false\n  when 1 then true\n  else raise \"Dictionary\
    \ is empty\"\n  end\nend", "\tkeys = hash_keys(dict)\n\tkeys.all? {|k| k.downcase\
    \ == k.upcase}\nend", "  if dict.nil?\n    false\n  elsif !dict.kind_of?(Hash)\n\
    \    false\n  else\n    key_values = dict.to_a\n    key_values.each do |key, value|\n\
    \      if !key.kind_of?(String) || key.upcase != key.downcase\n        false\n\
    \      end\n    end\n  end\nend", "    hash.each do |key, value|\n        if value.length\
    \ != key.length\n            return false\n        end\n        if value.upcase\
    \ != key.upcase\n            return false\n        end\n    end\n    return true\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby dscore=3 |>\n<code>", "  if hash.length\
    \ > 0\n    hash.each do |key, val|\n      next if !key.kind_of?(String)\n    \
    \  if key.downcase != key.upcase\n        return false\n      end\n    end\n \
    \   return true\n  else\n    return false\n  end\nend", "  raise \"Empty hash\
    \ not allowed\" if dict.size == 0\n  true_key = true\n  false_key = false\n  array.each\
    \ do |key, value|\n    case key\n    when String then true_key = true\n    when\
    \ Symbol then true_key = true\n    when Integer then true_key = true\n    when\
    \ NilClass then true_key = true\n    when Array then true_key = true\n    when\
    \ Hash then true_key = true\n    when Fixnum then true_key = true\n    else false_key\
    \ = false\n    end\n  end\n  true_key && false_key\nend", "  !dict.empty? && (dict.keys.all?\
    \ { |key| key.respond_to?(:downcase) ? key.downcase.to_s.size < key.size+1 : key.respond_to?(:upcase)\
    \ ? key.upcase.to_s.size < key.size+1 : key != key } )\nend", "  return false\
    \ if hash.empty?\n  dict.each do |key, value|\n    if value.is_a?(String)\n  \
    \    if key =~ /[A-Z]/ && !(key =~ /[a-z])/\n        true\n      elsif key =~\
    \ /[a-z]/ && !(key =~ /[A-Z])/\n        true\n      else\n        false\n    \
    \  end\n    elsif value.is_a?(Hash)\n      if check_dict_case(value)\n       \
    \ true\n      else\n        false\n      end\n    else\n      false\n    end\n\
    \  end\nend", "    return false if dict.empty?\n    lower = keys.collect {|key|\
    \ key.downcase}\n    upper = keys.collect {|key| key.upcase}\n    return false\
    \ if lower.all? {|k| !dict[k].nil?} || upper.all? {|k| !dict[k].nil?}\n    return\
    \ true\nend", "  case hash.length\n  when 0 then true\n  when 1 then case hash.keys[0]\n\
    \    when /^[a-z]/i then true\n    else false\n  end\nend", "  !dict.nil? and\
    \ \n  !dict.empty? and \n  dict.keys.all? { |k| k.is_a?(String) && k.downcase\
    \ != k.upcase }\nend", "  return false unless dict.nil? or dict.size == 0\n  true\n\
    end", "  hash.each do |key, value|\n    type = hash.value_at(\"type\", key)\n\
    \    if key == value.downcase || key == value.upcase\n      true\n    elsif type\
    \ != \"boolean\"\n      return false\n    end\n  end\n  true\nend", "  dict.has_key?(:keys)\
    \ && dict.keys.all? { |k| k.is_a?(String) }\nend", "  unless dict.size == 0\n\
    \    dict.each do |key, value|\n      unless key.is_a?(String) || key.is_a?(Symbol)\n\
    \        return false\n      end\n    end\n  end\n  return true\nend", "  keys.each\
    \ do |key|\n    if !hash.key?(key.downcase) || !hash[key].key?(key.upcase)\n \
    \     return false\n    end\n  end\n  return true\nend", "  return true if dict.keys.sort.all?\
    \ {|key| key.kind_of? String }\n  return false if dict.keys.sort.all? {|key| key.kind_of?\
    \ String }\n  false\nend\n</code>\n<|/ a |>\n<| a |>\nI recently had to create\
    \ a function that checks whether a string was a boolean true/false or an actual\
    \ boolean.\n<code>", '  return false if dict.empty?', "  if dict.empty?\n    false\n\
    \  else\n    str.downcase!\n    hash.map { |k,v| k.to_s.downcase! if k == \"state\"\
    \ || k == \"zip\" }.all?{ |k,v| k.to_s.downcase! if k == \"state\" || k == \"\
    zip\" } || hash.all? { |k,v| k.to_s.downcase! if k == \"state\" || k == \"zip\"\
    \ }\n  end\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis solution is not generic.\
    \  It would have to be written out for each type of hash in the question.\n<|/\
    \ c |>\n<| c |>\nThis solution will work for any hash no matter what it's keys\
    \ are called. I don't see how that's not generic. `check_dict_case` will iterate\
    \ through all hashes in question (not just one specific one) and check all keys.\
    \ The only difference is in `to_s.downcase!` - it converts key to lower case and\
    \ doesn't affect hash keys at all.\n<|/ c |>\n<| c |>\nThe OP never said the keys\
    \ were called \"Name\", \"Age\", or \"City\".  It could be any key name.  I took\
    \ the freedom of renaming the variables as much as I thought would be sensible.\n\
    <|/ c |>\n<| c |>\nYes, but how would the OP know that that is the case?  A more\
    \ generic solution would have to be written that would work even if only the hash\
    \ keys were changed.\n<|/ c |>\n<| a |>\nHow about this:\n<code>", "  unless hash.empty?\n\
    \    hash.each {|k, v| \n      next unless v.instance_of?(String)\n      unless\
    \ k.instance_of?(String)\n        return false\n      end\n    }\n    hash.each_key\
    \ {|k| \n      next unless k.instance_of?(String)\n      unless k.downcase ==\
    \ k\n        return false\n      end\n    }\n  end\n  true\nend\n</code>\n<|/\
    \ a |>\n<| a |>\nHere is a working example that can help you. Hope it helps you\n\
    <code>", "    return false if dict.empty?\n    hash.all? do |key, value|\n   \
    \     !(key == key.upcase || key == key.downcase)\n    end\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nThe function `check_dict_case.call({\"a\" => \"apple\"\
    , \"A\" => \"banana\", \"B\" => \"banana\"})` should return false as there are\
    \ no strings in lower case or upper case.\n<|/ c |>\n<| c |>\nThe last test case\
    \ should return true since there is only one key that is in upper or lower case.\
    \ He should probably write it as a comment though.\n<|/ c |>\n<| c |>\nAh, I see.\
    \ Well, I've fixed it.\n<|/ c |>\n<| c |>\nThanks for your answer. I'm pretty\
    \ new to Ruby and I'm trying to understand your code and also try to understand\
    \ and implement the code in a simple way, as I haven't yet covered the Hash method.\n\
    <|/ c |>\n<| c |>\nI have added comments to the code, but I'll just leave them\
    \ as a separate answer.\n<|/ c |>\n<| a |>\nHere's another way to do this, using\
    \ only a single line:\n<code>", "  return false if dict.nil? or !dict.has_key?('CaseCheck')\n\
    \  val = dict['CaseCheck']\n  case val\n  when 'upper'\n    hash.all? {|key, value|\
    \ key.upcase == value}\n  when 'lower'\n    hash.all? {|key, value| key.downcase\
    \ == value}\n  end\nend\n</code>\n<|/ a tags=ruby,hash dscore=0 |>\n<| c |>\n\
    Thanks for your help!  I decided to go with a different solution, but your answer\
    \ was very helpful.\n<|/ c |>\n<| a dscore=0 |>\nFor my purpose, I needed to match\
    \ any key that matches an exact substring in a hash.\nI wanted to match any key\
    \ that matches a given substring in a hash. For example:\n<code>\nh = { 'foo'\
    \ => 'bar', 'baz' => 'qux' }\nmatch = 'baz'\n</code>\nThis would match (and therefore\
    \ not match):\n<code>\nh['foo']\nh['baz']\n</code>\nThe following would match:\n\
    <code>\nh['baz']\nh['foobar']\n</code>\nThe solution I came up with was to use\
    \ a regular expression to search the hash for any key that matched the regular\
    \ expression. \nI started off by making a hash that contained a subset of the\
    \ keys. Then I matched that hash to the hash I was trying to match.\n<code>\n\
    h = { 'foo' => 'bar', 'baz' => 'qux' }\nmatch = 'baz'", "  hash.empty? or dict.each\
    \ { |key, value| \n    (key.length == value.to_s.length) or \n    (key.upcase\
    \ == value.upcase) \n  }\nend", "  if !dict.nil? and dict.size > 0\n    dict.each\
    \ do |key, value|\n      if value.is_a?(String)\n        value.downcase!\n   \
    \   elsif value.is_a?(Hash)\n        value.each do |k, v|\n          if v.is_a?(String)\n\
    \            v.downcase!\n          end\n        end\n      end\n    end\n  end\n\
    end", "  return false if dict.nil? || dict.empty?\n  keys = dict.keys.to_a\n \
    \ keys.each do |key|\n    return false if key.is_a?(Integer) || key.is_a?(Float)\
    \ || key.is_a?(String) || key.to_s.downcase.casecmp(key.to_s.upcase.casecmp(\"\
    true\"))\n  end\n  return true\nend", "  case dict.class \n  when Hash\n    true\n\
    \  when Array\n    true\n  else\n    false\n  end\nend", "  if dict.nil?\n   \
    \ false\n  else\n    if !dict.kind_of?(Hash) || dict.length <= 0\n      false\n\
    \    else\n      dict.each do |key, value|\n        return false if (key != key.downcase\
    \ || value != value.downcase)\n      end\n    end\n  end\n  true\nend\n</code>\n\
    <|/ a tags=ruby,hash dscore=0 |>\n<| c |>\nIt's better to use `downcase!` instead\
    \ of `downcase`, since `downcase` will call `downcase!` internally, so there may\
    \ be unexpected side effects.\n<|/ c |>\n<| a tags=ruby,hash |>\nYou can try this:\n\
    <code>", "  dict.all? do |key,value|\n    case key\n    when String\n      key\
    \ == value.downcase\n    else\n      key == value.upcase\n    end\n  end\nend\n\
    </code>\n<|/ a |>\n<| a tags=ruby-on-rails-3,ruby |>\nI know this question is\
    \ a little old but I have been battling this exact issue for weeks and I just\
    \ finally figured out a solution!\nWhat I did was to write the following code\n\
    <code>", "  dict.all? { |k, v| k.casecmp(k.downcase) == 0 || k.casecmp(k.upcase)\
    \ == 0} ? true : false\nend", "  \n  # Your code goes here\n  return true\nend",
  "  dict.each do |k, v|\n    return false if k.class != String || v.class != String\n\
    \  end\n  true\nend", "  hash.empty? == false && hash.keys.sort.map {|k| k.to_s}.sort.uniq\
    \ == hash.keys.sort.map {|k| k.to_s}.sort\nend", "\treturn dict.all? {|k,v| k.is_a?(String)}\
    \ or dict.all? {|k,v| k.is_a?(String) && v.is_a?(String)} or false\nend", "  if\
    \ hash.empty?\n    false\n  else\n    hash.keys.each do |key|\n      if hash[key].is_a?\
    \ String\n        if hash[key].downcase != hash[key].upcase\n          false\n\
    \        else\n          true\n        end\n      else\n        false\n      end\n\
    \    end\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nYou forgot to check if it's\
    \ empty. `hash[:a] == hash[\"a\"]` == `hash.has_key? :a`\n<|/ c |>\n<| c |>\n\
    Yeah my mistake - I changed it to `has_key?` instead of `key?` which doesn't work\n\
    <|/ c |>\n<| c |>\nThanks, you were absolutely right - I forgot to include the\
    \ check for empty-ness.  And also forgot that `hash.keys` returns a list of the\
    \ keys rather than a hash itself.\n<|/ c |>\n<| c |>\n`if hash[key].is_a? String`\
    \ is redundant. `if hash[key] == String` should be fine.\n<|/ c |>\n<| c |>\n\
    Yes, you're right - I forgot the `== String` check. Thanks for the correction!\n\
    <|/ c |>\n<| a |>\nThis one works even when you have string keys within numeric\
    \ keys.\n<code>", "    hash.each do |key, value|\n        if value.is_a?(String)\
    \ || value.is_a?(Fixnum) || value.is_a?(Float) || value.is_a?(Numeric)\n     \
    \       hash[key.to_s.downcase] = hash[key.to_s.upcase]\n            hash.pop(key)\
    \ if hash[key.to_s.upcase].nil? # delete key\n        end\n    end\n    hash.empty?\n\
    end", "  result = true\n  dict.each do |k, v|\n    unless k.is_a?(String)\n  \
    \    result = false\n      break\n    end\n    unless v.is_a?(String)\n      result\
    \ = false\n      break\n    end\n  end\n  return result\nend", "  return false\
    \ if dict.nil? || dict.empty?\n  \n  hash.each do |key, value|\n    return false\
    \ if value.nil? || value.empty? || !value.is_a?(String)\n    return false if !key.downcase\
    \ == key || !key.upcase == key\n  end\n  return true\nend", "  case true\n  when\
    \ dict.is_a? Hash\n    dict.all? { |key, value| key.to_s.downcase == value.to_s.downcase\
    \ }\n  when dict.is_a? Array\n    dict.all? { |key| key.to_s.downcase == key.to_s.downcase.to_s\
    \ }\n  else\n    false\n  end\nend\n</code>\n<|/ a dscore=4 tags=ruby |>\n<| c\
    \ |>\nI love your use of Procs and all? :)\n<|/ c |>\n<| c |>\nThis solution works\
    \ only for Ruby >= 1.8.7, not for Ruby 1.9.x. Because `all?` was introduced in\
    \ Ruby 1.8.7 and this method was introduced in Ruby 1.9.x.\n<|/ c |>\n<| c |>\n\
    This is exactly what I need! It's even cleaner than my current solution. Thank\
    \ you!\n<|/ c |>\n<| a |>\nAnother way of doing it is the following:\n<code>\n\
    hash.inject(true) do |result, (key, value)|\n  return result if key.to_s.downcase\
    \ != value.to_s.downcase\n  result = false\nend\n</code>\n<|/ a tags=ruby dscore=4\
    \ |>\n<| c |>\nThis works great! Thanks! I also like that you can add additional\
    \ conditions, such as `value.to_s.downcase == value.to_s.downcase` and then just\
    \ return `result`.\n<|/ c |>\n<| c |>\nThis is nice because you don't have to\
    \ create an `all?` method.\n<|/ c |>\n<| c |>\nAlso note that this returns `true`\
    \ if `hash` is empty, which may or may not be desired.\n<|/ c |>\n<| a tags=ruby\
    \ dscore=3 |>\n<code>\nhash = { \"a\" => \"apple\", \"b\" => \"banana\", \"c\"\
    \ => \"carrot\" }\nhash.keys.all? do |key|\n  key.to_s.downcase == key.to_s.downcase.to_s\n\
    end\n</code>\n<|/ a |>\n<| a tags=ruby |>\nI came up with this monkey patch solution,\
    \ which works both in 1.8.7 and 1.9.\n<code>", "  if dict.nil?\n    false\n  elsif\
    \ dict.empty?\n    false\n  else\n    puts \"The given hash has the following\
    \ keys: #{dict.keys.inspect}\"\n    puts \"All keys must be strings in lower case\
    \ or upper case.\"\n    puts \"Please check your keys and try again.\"\n    false\n\
    \  end\nend", "  # Only works for ruby >= 1.9\n  if Hash === dict # Ruby 1.8\n\
    \    dict.key?(\"State\") && (dict[\"State\"].downcase == dict[\"state\"]) ||\
    \ \n      dict.key?(\"state\") && dict[\"state\"].downcase == dict[\"State\"]\n\
    \  else\n    !dict.values.all?{|v| v.is_a?(String)} || \n    !dict.values.all?{|v|\
    \ v.is_a?(String)} \n  end\nend", '  return false if dict.nil? or dict.empty?
    or dict.class != Hash', "  case dict.length\n    when 0 then return false\n  \
    \  when 1 then return false\n    when 2 then return (dict[:1].downcase == dict[:2].downcase)\n\
    \    else return false\n  end\nend", "    true\nend", "  keys = hash.keys\n  keys.each\
    \ do |key|\n    unless hash[key].downcase == hash[key].upcase \n      return false\n\
    \    end\n  end\n  true\nend", "  hash = Hash.new(0) \n  hash.values.each do |value|\
    \ \n    if value.instance_of? String\n      if value.casecmp(dict.keys.first)\
    \ == 0 \n        hash[value] += 1\n      end\n    elsif value.instance_of? Integer\n\
    \      if value == dict.keys.first\n        hash[value] += 1\n      end\n    end\n\
    \  end\n  return hash.values.all?{|x| x == 1} \nend", "  \n  result = true\n \
    \ \n  # loop through all the keys in the given hash\n  dict.each do |key, value|\n\
    \    \n    # convert the value to string, case insensitive\n    value = value.to_s.downcase\n\
    \    \n    # if the value is an empty string, return false \n    # and end the\
    \ loop\n    if value.empty?\n      result = false\n      break\n    end\n    \n\
    \    # if the key is not in lower case and key is not in upper case,\n    # return\
    \ false\n    if !key.downcase.include?(string.downcase) && !key.upcase.include?(string.upcase)\n\
    \      result = false\n      break\n    end\n    \n  end\n  \n  return result\n\
    end\n</cell>\n<text>\nExercise: Implement check_dict_case_v2", "  case dict.length\n\
    \  when 0\n    return true\n  when 1\n    return true\n  when 2\n    hash = Hash.new\n\
    \    hash[\"key1\"] = hash[\"key2\"] = nil\n    hash.values.include?(nil) ? true\
    \ : false\n  else\n    hash.values.all? { |value| value.class == String }\n  end\n\
    end\n</cell>\n<cell>", "  # your code\n  if dict.count > 0\n    unless dict.all?\n\
    \      puts \"All keys need to be in lower case!\"\n      return\n    end\n  end\n\
    \  if dict.count > 0\n    unless dict.all? { |k,v| k[0..0] =~ /^[a-z]$/ }\n  \
    \    puts \"All keys need to be in lower case!\"\n      return\n    end\n  end\n\
    end", "  dict.each do |k, v|\n    if k.is_a? String then\n      k = k.downcase\n\
    \    else\n      k = k.upcase\n    end\n    return false unless v.is_a? String\n\
    \  end\n  return true\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nWhile this link\
    \ may answer the question, it is better to include the essential parts of the\
    \ answer here and provide the link for reference.  Link-only answers can become\
    \ invalid if the linked page changes.\n<|/ c |>\n<| c |>\nThis does answer the\
    \ question.  It just needs a bit of explanation on the edge cases.  As is, this\
    \ answer is the only valid answer.\n<|/ c |>\n<| a dscore=3 tags=ruby |>\nI love\
    \ the other answers, just adding that if your Ruby is 2.2 or greater, you can\
    \ use the Hash#values_at method\n<code>\nh = {\"a\" => \"apple\", \"b\" => \"\
    banana\"}", "  case dict when Hash then \n    not (dict.keys.length == 0 and (dict.keys.length\
    \ == 1 or (dict.keys.length == 2 && !(Hash[dict.keys.first].kind_of?(Symbol)))))\
    \ \n  else \n    false\n  end\nend", "  return false if dict.nil? or dict.size\
    \ == 0\n  return true if dict.size == 1\n  keys = dict.keys\n  keys.each_with_index\
    \ do |key, index|\n    case key\n    when String then keys[index] = key.downcase\n\
    \    when Symbol then keys[index] = key.to_s.downcase\n    end\n  end\n  return\
    \ true if keys.sort == keys.uniq.sort\n  return false\nend\n</code>\nNow for the\
    \ functions which will go through the array of hashes, and find all keys which\
    \ start with 'A', or contain 'a' as a substring:\n<code>", "  case dict.length\n\
    \  when 0\n    false\n  when 1\n    true\n  else\n    dict.each_value do |val|\n\
    \      if val.class == String\n        true if val.upcase == val.downcase\n  \
    \    end\n    end\n  end\nend", "  if dict.is_a? Hash\n    keys = dict.keys\n\
    \    keys.each do |k|\n      if k.is_a? String then\n        k.downcase\n    \
    \  elsif k.is_a? Integer then\n        k.to_s\n      end\n    end\n    return\
    \ keys.all? { |k| k.is_a? String }\n  end\nend\n</code>\n<|/ a tags=hash,ruby\
    \ |>\n<| a |>\n<code>\nhsh.all? { |k,v| k.downcase.strip == v.downcase.strip }\n\
    </code>\n<|/ a tags=hash,ruby dscore=2 |>\n<| a |>\n<code>", "\tcase hash.length\
    \ when 0 then return true \n\t\telse hash.values.all? { |value| value.is_a?(String)\
    \ }\n\tend\n\t\n\treturn false\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
