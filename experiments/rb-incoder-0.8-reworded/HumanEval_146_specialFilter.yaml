name: HumanEval_146_specialFilter
language: rb
prompt: "# Write a function that takes an array of numbers as input and returns \n\
  # the number of elements in the array that are greater than 10 and both \n# first\
  \ and last digits of a number are odd (1, 3, 5, 7, 9).\n# For example:\n# >>> specialFilter.call([15,\
  \ -73, 14, -15])\n# 1\n# >>> specialFilter.call([33, -2, -3, 45, 21, 109])\n# 2\n\
  def specialFilter(nums)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_specialFilter\n\
  \    candidate = method(:specialFilter)\n    assert_equal(0, candidate.call([5,\
  \ -2, 1, -5]))\n    assert_equal(1, candidate.call([15, -73, 14, -15]))\n    assert_equal(2,\
  \ candidate.call([33, -2, -3, 45, 21, 109]))\n    assert_equal(4, candidate.call([43,\
  \ -12, 93, 125, 121, 109]))\n    assert_equal(3, candidate.call([71, -2, -33, 75,\
  \ 21, 19]))\n    assert_equal(0, candidate.call([1]))\n    assert_equal(0, candidate.call([]))\n\
  \  end\nend\n"
completions: ["  return length(filter(nums, ->(first(rest) > 10 && last(rest) % 2\
    \ == 1) && first % 2 == 1))\nend", "  return nums.count { |num| num > 10 &&\n\
    \    num.odd? &&\n    num.even? &&\n    ((int%(num.to_s)) % 2) == 0\n  }\nend",
  "    count = 0\n    nums.each do |n|\n        if n > 10 && n % 1 == 0 && n % 1 ==\
    \ 1\n            count += 1\n        end\n    end\n    return count\nend", " \
    \   answer = 0\n    i = 0\n    while i < nums.length\n        if nums[i] > 10\
    \ && nums[i][0] % 2 == 1 && nums[i][-1] % 2 == 1\n            answer = answer\
    \ + 1\n        i = i + 1\n    return answer\n</code>\n<|/ a dscore=1 tags=ruby,recursion\
    \ |>\n<| c |>\n`if nums[i][0].odd?` is an alternative to `nums[i][0] % 2 == 1`.\
    \ `nums[i][0].odd?` is true if and only if `nums[i][0]` is odd.\n<|/ c |>\n<|\
    \ c |>\nGood call! I knew there was a method on that object but I didn't know\
    \ its name. Thanks!\n<|/ c |>\n<| c |>\nNo problem. I just realized I had a typo.\
    \ `odd?` doesn't take parameters. It needs to be `nums[i][0].odd?`\n<|/ c |>\n\
    <| c |>\nGood catch, thanks. I fixed it.\n<|/ c |>\n<| a |>\nTo answer your question:\
    \ yes, you can do it. And yes, it's possible.\nYes, it can be done. Yes, you can.\n\
    No, you shouldn't.\nThe fact is that it's a fairly bad idea to write recursive\
    \ methods that use loops. Recursive methods tend to be unoptimized code, and they\
    \ can cause stack overflows.\n<|/ a tags=ruby,recursion dscore=1 |>\n<| c |>\n\
    I suspect the OP is really looking for an example of a recursive method.  I agree\
    \ with you that most recursive methods do tend to be unoptimized, but it's still\
    \ a very common technique.\n<|/ c |>\n<| c |>\nI think this is a case where a\
    \ recursive solution is useful, but I agree that it is an unusual technique and\
    \ should only be used if it is required by the problem being solved.\n<|/ c |>\n\
    <| a |>\nHere is another way to solve this problem without using recursion.\n\
    <code>", "  # Filter the list by the number function\n  nums.select { |n| n >\
    \ 10 && n.odd? && ( n % 1 == 0 || n % 2 == 1 ) }.length\nend", "    count = 0\n\
    \    \n    numbers.each do |number|\n        \n        firstOdd = number.first\
    \ % 10\n        \n        if firstOdd & 1 == 1 && number.last % 2 == 1\n     \
    \       count += 1\n        end\n    end", "    nums.each do |num|\n        if\
    \ num > 10 and num.odd? and num.odd_first? and num.odd_last?\n            puts\
    \ num\n        end\n    end\nend", "  # TODO: Your code here!\n  return 0\nend",
  "  count = 0\n  for i in nums\n    if i > 10 && i % 2 != 0 && i % 2 != 1\n     \
    \ count = count + 1\n    end\n  end\n  return count\nend", "  count = 0\n  for\
    \ i in nums\n    i += 1\n    if i > 10\n      i += 1\n      if i % 2 == 1\n  \
    \      count += 1\n  return count\n  ", "  count = 0\n  for x in nums\n    if\
    \ (x > 10) and (x % 2 == 0) and (x % 2 != 0)\n      count += 1\n    end\n  end\n\
    \  return count\nend", "  odd_count = 0\n  even_count = 0\n  \n  even_count =\
    \ 0\n  odd_count = 0\n  \n  num = nums[0]\n  \n  for i in 0...nums.length\n  \
    \  if num % 2 == 1\n      even_count += 1\n    end\n    \n    if num % 2 != 0\n\
    \      odd_count += 1\n    end\n    \n    num /= 10\n  end", "    nums.count {\
    \ |n| n.odd? && n.to_i >= 10 && n.to_i / 10 % 2 == 1 }\nend\n</cell>\n<cell>",
  "    i = 0\n    j = 0\n    oddSum = 0\n    evenSum = 0\n    numsSum = 0", "  count\
    \ = 0\n  i = 0\n  while i < nums.length\n    if nums[i] > 10\n      count = count\
    \ + 1\n      i = i + 1\n    else if nums[i] == 1\n      i = i + 1\n    else if\
    \ nums[i] == 5\n      i = i + 1\n    else if nums[i] == 9\n      i = i + 1\n \
    \   else\n      i = i + 1\n  end\n  count\nend", "    even = nums.select { |x|\
    \ (x % 2).zero? }\n    odd = nums.select { |x| (x % 2).zero? && !((x % 10).zero?)\
    \ }\n    even.length == 0 && odd.length == 1\nend\n</code>\n<|/ a tags=ruby,filter,arrays\
    \ |>\n<| a |>\n<code>", "  nums.sort\n  sum = 0\n  i = 0\n  while i < nums.length\
    \ - 1\n    if (nums[i] > 10 && nums[i+1] % 2 != 0)\n      sum += 1\n    i += 1\n\
    \  return sum\nend", "    count = 0\n    for x in nums\n        if x > 10 and\
    \ x % 2 == 1 and x % 3 == 1\n            count += 1\n    return count", "  count\
    \ = 0\n  for i in nums \n    if i > 10 \n      and nums[i-1] % 2 == 1 && nums[i-1]\
    \ % 2 == 0 \n      and nums[i+1] % 2 == 1 && nums[i+1] % 2 == 0\n      count +=\
    \ 1\n  return count\n</code>\n<|/ a |>\n<| c |>\nthank you so much for this! this\
    \ was very helpful\n<|/ c |>\n<| c |>\nNo problem! Please mark the answer as accepted\
    \ if it solved your problem.\n<|/ c |>\n<| a dscore=0 |>\nTo find the first odd\
    \ number, you should start at 1, not at 0\n<code>", "  count = 0\n  for i in nums\n\
    \    num = i\n    num.reverse!\n    if num.even? && num.odd?\n      count = count\
    \ + 1\n    elsif num.even? && !num.odd?\n      count = count + 1\n    elsif !num.even?\
    \ && num.odd?\n      count = count + 1\n    end\n  end\n  count\nend\n</cell>\n\
    <text>\nWrite a function that takes a string of digits and returns true if the\
    \ \nstring is an integer and is exactly 16 digits long. Return false if the \n\
    string is not an integer or has more or fewer than 16 digits. For example:\n>>>\
    \ specialFilter.call(\"12345\")\nTrue\n>>> specialFilter.call(\"1234567890\")\n\
    False\n>>> specialFilter.call(\"12345678901234567890\")\nFalse\n>>> specialFilter.call(\"\
    123456789012345678901234567890\")\nFalse\n>>> specialFilter.call(\"123456789012345678901234567890123456\"\
    )\nFalse\n>>> specialFilter.call(\"1234567890123456789012345678901234567\")\n\
    True\n>>> specialFilter.call(\"12345678901234567890123456789012345689\")\nTrue\n\
    >>> specialFilter.call(\"123456789012345678901234567890123456890\")\nFalse\n>>>\
    \ specialFilter.call(\"12345678901234567890123456789012345689012\")\nFalse\n>>>\
    \ specialFilter.call(\"1234567890123456789012345678901234568901234\")\nFalse\n\
    >>> specialFilter.call(\"123456789012345678901234567890123456890123445\")\nFalse\n\
    >>> specialFilter.call(\"12345678901234567890123456789012345689012345\")\nFalse\n\
    >>> specialFilter.call(\"1234567890123456789012345678901234568901234567\")\nFalse\n\
    >>> specialFilter.call(\"12345678901234567890123456789012345689012345678\")\n\
    False\n>>> specialFilter.call(\"1234567890123456789012345678901234568901234567890\"\
    )\nFalse\n>>> specialFilter.call(\"12345678901234567890123456789012345689012345678901\"\
    )\nFalse\n>>> specialFilter.call(\"123456789012345678901234567890123456890123456789012\"\
    )\nFalse\n>>> specialFilter.call(\"1234567890123456789012345678901234568901234567890123\"\
    )\nFalse\n>>> specialFilter.call(\"12345678901234567890123456789012345689012345678901234\"\
    )\nFalse\n>>> specialFilter.call(\"123456789012345678901234567890123456890123456789012345\"\
    )\nFalse\n>>> specialFilter.call(\"12345678901234567890123456789012345689012345678901234567\"\
    )\nFalse\n>>> specialFilter.call(\"123456789012345678901234567890123456890123456789012345678\"\
    )\nFalse\n>>> specialFilter.call(\"12345678901234567890123456789012345689012345678901234567890\"\
    )\nFalse\n>>> specialFilter.call(\"1234567890123456789012345678901234568901234567890123456789",
  "  nums.each {|x| return x if x > 10 && x.odd? && x.gcd%(10).odd? == 1}.length\n\
    end\n</cell>\n<cell>", "  return count(nums, (n) -> (\n    (n > 10) and (n % 2\
    \ == 1) and (n % 100 != 11)))\n</cell>\n<text>\n(3) Now that you have the function\
    \ specialFilter, write a function that takes as input a positive integer and returns\
    \ the sum of all the positive integers that also satisfy the condition of the\
    \ number being odd.", "  total = 0\n  for i in nums\n    if i > 10 and nums.first\
    \ % 2 == 1 and nums.last % 2 == 1\n      total += 1 \n    end\n  end\n  return\
    \ total\nend", "  nums.each do |n|\n    if n < 10\n      next\n    end\n    odd\
    \ = n % 10\n    if odd % 2 == 1 \n      next\n    end\n    odd = n / 10\n    if\
    \ odd % 2 == 1\n      next\n    end\n    odd = n / 10\n    if odd % 2 == 1\n \
    \     next\n    end\n    odd = n / 10\n    if odd % 2 == 1\n      next\n    end\n\
    \    return 1\n  end\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nIt's worth\
    \ noting that the OP's code is incorrect as it doesn't return anything (just prints\
    \ a number)\n<|/ c |>\n<| c |>\nThanks so much for the helpful feedback! This\
    \ was my first time using Ruby and I'm still struggling to grasp all of the concepts.\
    \ I'll be sure to remember that next time. Thanks again!\n<|/ c |>\n<| a tags=ruby,arrays\
    \ dscore=0 |>\nI believe that your issue is here:\n<code>", "  nums.each do |num|\n\
    \    if num > 10 && num.odd? && num.even? && num.to_s.first == num.to_s.last\n\
    \      return num\n    end\n  end\nend\n</cell>\n<cell>", "  count = 0\n  for\
    \ i in nums\n    if i>10 then\n      if i%2==1 then\n        if i%3==1 then\n\
    \          count += 1\n        end\n      end\n    end\n  end\n  return count\n\
    end", "  sum = 0 \n  sum1 = 0 \n  sum2 = 0 \n  sum3 = 0 \n  sum4 = 0 \n  sum5\
    \ = 0 \n  sum6 = 0 \n  sum7 = 0 \n  sum8 = 0 \n  sum9 = 0 \n  i = 0\n  while i\
    \ < nums.length\n    if nums[i] > 10 and (nums[i]%2 == 1 and (nums[i]%100 == 0\
    \ or nums[i]%100 == 1)) and (nums[i]%100 != 0) \n    then sum = sum + 1 \n   \
    \ if nums[i]%2 == 1 and (nums[i]%10 == 1 or nums[i]%10 == 2) and (nums[i]%100\
    \ != 0) \n    then sum1 = sum1 + 1 \n    if nums[i]%2 == 1 and (nums[i]%10 !=\
    \ 1 or nums[i]%10 == 2) and (nums[i]%100 != 0) \n    then sum2 = sum2 + 1 \n \
    \   if nums[i]%2 == 1 and (nums[i]%10 == 1 or nums[i]%10 == 2) and (nums[i]%100\
    \ == 0) \n    then sum3 = sum3 + 1 \n    if nums[i]%2 == 1 and (nums[i]%10 !=\
    \ 1 or nums[i]%10 == 2) and (nums[i]%100 == 0) \n    then sum4 = sum4 + 1 \n \
    \   if nums[i]%2 == 1 and (nums[i]%10 == 1 or nums[i]%10 == 2) and (nums[i]%100\
    \ != 0) \n    then sum5 = sum5 + 1 \n    if nums[i]%2 == 1 and (nums[i]%10 !=\
    \ 1 or nums[i]%10 == 2) and (nums[i]%100 != 0) \n    then sum6 = sum6 + 1 \n \
    \   if nums[i]%2 == 1 and (nums[i]%10 == 1 or nums[i]%10 == 2) and (nums[i]%100\
    \ == 0) \n    then sum7 = sum7 + 1 \n    if nums[i]%2 == 1 and (nums[i]%10 !=\
    \ 1 or nums[i]%10 == 2) and (nums[i]%100 == 0) \n    then sum8 = sum8 + 1 \n \
    \   if nums[i]%2 == 1 and (nums[i]%10 == 1 or nums[i]%10 == 2) and (nums[i]%100\
    \ != 0) \n    then sum9 = sum9 + 1 \n    i = i + 1 \n    end \n  end\n  return\
    \ sum\nend \n</cell>\n<text>\nProblem 7\nWrite a function that takes an array\
    \ of numbers as input and returns the sum of the digits in each number in the\
    \ array. For example, if an input array is [4, 10, 7, 3, 2], your function should\
    \ return [10, 7, 7, 8, 2].", "  # Write your code here\n  return nums.count{ |n|\
    \ n > 10 and n.to_s[1..-1].scan(/\\d/).all? { |n| n % 2 == 1 } }\nend\n</pre>\n\
    </div>", "    # Initialize your count variable\n    count = 0\n    \n    # Iterate\
    \ over all the numbers in nums\n    for num in nums\n        # Check if num is\
    \ greater than 10\n        if num > 10\n            # If so, check if the first\
    \ and last digits are odd\n            if num % 10 % 2 != 0\n                #\
    \ If so, increment count\n                count += 1\n            \n    # Return\
    \ the count variable\n    return count\n</cell>\n<cell>", "  count = 0\n  for\
    \ i in nums\n    if i > 10\n      count += 1\n      if i%2 == 0\n        if i%4\
    \ == 0\n          count += 1\n    end\n  end\n  count\nend\n</cell>\n<cell>",
  "    nums.inject(0) do |total, n|\n        total += 1 if n % 10 == 1 && n % 100\
    \ != 11\n        total += 1 if n % 10 == 3 && n % 100 != 13\n        total +=\
    \ 1 if n % 10 == 5 && n % 100 != 15\n        total += 1 if n % 10 == 7 && n %\
    \ 100 != 17\n        total += 1 if n % 10 == 9 && n % 100 != 19\n        total\n\
    \    end\nend", "\ti = 0\n\twhile i < nums.length\n\t\tif (nums[i] >= 10 and (nums[i]\
    \ & 1) != 0 and nums[i-1] % 2 != 0 and nums[i+1] % 2 != 0)\n\t\t\ti += 1\n\t\t\
    else\n\t\t\ti += 1\n\t\n\treturn i\n\t", "  n = nums.length\n  result = 0\n  for\
    \ i in 0...n\n  result = result + nums[i] if (nums[i] > 10 and nums[i] % 2 ==\
    \ 0 and nums[i] % 10 == 1)\n  result = result + 1\n  return result", "    nums.each\
    \ do |x|\n        if x >= 10\n            if x.modulo(2) == 1 && x.modulo(5) ==\
    \ 1\n                puts x\n            end\n        end\n    end\nend", "  \
    \  count = 0\n    for number in nums\n        if number > 10 and (number % 2 ==\
    \ 1 and number % 10 == 1)\n            count = count + 1\n    return count\n \
    \   \nprint(specialFilter(nums))\n</cell>\n<cell>", "  # Solution\n  count = 0\n\
    \  for i in nums\n    if i > 10\n      if i.first % 2 == 1 and i.last % 2 == 1\n\
    \        count += 1\n    end\n  end\n  return count\nend", "    # Solution code\
    \ here\n    return len(nums) - len(nums.filter{|x| x % 10 =~ /10/}) \nend\n</cell>\n\
    <cell>", "    count = 0\n    for num in nums\n        if num > 10 \n         \
    \   and (num.even? and num.odd?)\n            and (num.first and num.last)\n \
    \           then count = count + 1\n    return count\n</code>\n<|/ a |>\n<| c\
    \ |>\nThank you. I don't have the reputation to up vote. I appreciate your help.\n\
    <|/ c |>\n<| c |>\nThank you also. I don't have the reputation to up vote. I appreciate\
    \ your help.\n<|/ c |>\n<| a |>\n<code>", "  sum = 0\n  for i in nums\n    sum\
    \ += i\n  end\n  return 0 if sum < 10 && sum % 2 == 0 && sum % 2 == 1 then 1 else\
    \ 0\nend", "  count = 0\n  for i in nums do\n    if i > 10 and i[0] % 2 == 1 and\
    \ i[-1] % 2 == 1 then\n      count = count + 1\n    end\n  end\n  return count\n\
    end\n</cell>\n<code language=julia-0.6>", "  if nums.length < 2 \n    return 0\n\
    \  end\n  if nums[0] % 2 == 1 && nums[1] % 2 == 1\n    return nums.length\n  else\n\
    \    return 0\n  end\nend\n</cell>\n<text>\nTest Your Solution\nRun the cell below\
    \ to test your solution to the problem above.", "    # Write your filter here\n\
    \    count = 0\n    for i in nums\n        if i > 10\n            count += 1 if\
    \ i % 2 == 1 and (i//10)%2 == 1 \n        end\n    end\n    return count\nend",
  "  count = 0\n  for x in nums\n    if x > 10 and\n       x.modulo(2).zero? and\n\
    \       x.modulo(2).zero? and\n       x.modulo(2).odd?\n      count += 1\n  end\n\
    \  return count\nend", "    # Your code here\n    count = 0\n    for n in nums:\n\
    \        if n > 10 and n % 2 == 1 and n % 5 == 1:\n            count += 1\n  \
    \  return count\n    ", "  sum = 0\n  for i in nums do\n    if i > 10 then\n \
    \     sum = sum + 1\n      if i mod 2 > 1 then\n        if i mod 2 > i do\n  \
    \        sum = sum + 1\n        end\n      end\n    end\n  end\n  return sum\n\
    end\n  ", "  return sum((x > 10 and x % 2 and x % 4) for x in nums)\nend", " \
    \ i = 0\n  sum = 0\n  while (i < nums.length)\n  sum += 1\n    if (nums[i] > 10\
    \ and nums[i].odd? and nums[i].odd?)\n      i += 1\n      break\n    else\n  \
    \    i += 1\nend\n</code>\n<|/ a tags=ruby |>\n<| a |>\n<code>", "  count=0\n\
    \  for x in nums\n    if x % 2 != 0 && x % 1 != 0 && (x/10).to_i % 2 != 0\n  \
    \    count+=1\n    end\n  end\n  return count\nend", "    count = 0\n    odd_count\
    \ = 0\n    even_count = 0\n    for num in nums:\n        if num > 10 and  num\
    \ % 2 != 1 and num % 2 != 0 and  num % 2 != -1:\n            count += 1\n    \
    \        if num % 2 == 1:\n                even_count += 1\n            else:\n\
    \                odd_count += 1\n    return count", "    i = 0\n    count = 0\n\
    \    while (i < nums.length) do\n        if nums[i] >= 10 and (nums[i] % 2 ==\
    \ 1 and nums[i] % 10 == 1) then\n            count = count + 1\n        end\n\
    \        i = i + 1\n    end\n    return count\nend", "  return specialFilter.call(nums)\
    \ do num\n    odd? and odd? digit, odd? digit\n  end\nend", "    count = 0\n \
    \   nums.each do |num|\n        if num.to_s.include?(\"10\")\n            if num.to_s.include?(\"\
    10\"+\"1\")\n                count+=1\n            end\n            if num.to_s.include?(\"\
    10\"+\"3\")\n                count+=1\n            end\n            if num.to_s.include?(\"\
    10\"+\"5\")\n                count+=1\n            end\n            if num.to_s.include?(\"\
    10\"+\"7\")\n                count+=1\n            end\n            if num.to_s.include?(\"\
    10\"+\"9\")\n                count+=1\n            end\n        end\n    end\n\
    \    return count\nend", "    sum = 0\n    for i in nums\n        if i > 10\n\
    \            sum += 0\n        else\n            sum += 1 if i%2 != 0 else 0\n\
    \    return sum\n</code>\n<|/ a |>\n<| c |>\nThanks for this, it helped me a lot!\
    \ I added a filter to just return the number of even numbers between 0 and 100\
    \ that I needed to solve\n<|/ c |>\n<| a dscore=1 tags=python |>\n<code>", " \
    \   nums.reduce!\n    nums.each {|n| n > 10 && n % 2 == 1 && n % 1 == 1}\n   \
    \ nums.length\nend\n</cell>\n<cell>", "  count = 0\n  nums.each do |num|\n   \
    \ if (num % 10) > 10 || (num % 100) > 10 || (num % 1000) > 10\n      count +=\
    \ 1\n    end\n  end\n  count\nend", "  count = 0\n  for i in nums\n    if i >\
    \ 10 and i[0] == i[2] and i[-1] % 2 == 1\n      count += 1\n    end\n  end\n \
    \ count\nend", "  sum = nums.reduce(0, :+)\n  odd_digit = nums.reduce {|sum, v|\
    \ sum + v % 2 }\n  odd_digit.odd? && nums.first().odd? && nums.last.odd?\nend",
  "    nums = nums.sort_by(&:abs)\n    nums.each do |x|\n        if x > 10\n     \
    \       firstAndLast = x.to_s.split(\"\").map(&:to_i)\n            if firstAndLast.first\
    \ % 2 == 1 && firstAndLast.last % 2 == 1\n                return x.to_s.size\n\
    \            end\n        end\n    end\nend", "  # The answer to the problem\n\
    \  count = 0\n  # Iterate through the numbers\n  for i in nums\n    # If the number\
    \ is greater than 10\n    if i > 10\n      # If the first and last digits of the\
    \ number are odd\n      if i % 2 == 1\n        # Increment the count\n       \
    \ count += 1\n  # Return the count (number of elements > 10)\n  return count",
  "  nums.count{|x| x > 10} \n  nums.count{|x| x > 10 and nums[nums.index(x)+1] %\
    \ 2 == 1} \n  nums.count{|x| x > 10 and nums[nums.index(x)-1] % 2 == 1} \nend\n\
    </cell>\n<text>\nThe rubric of algorithmic problem solving is always about finding\
    \ a pattern that can be used to solve a problem. Knowing what kind of problem\
    \ to solve is part of the problem solving process. We call this a problem pattern.\
    \ Programming language syntaxes and libraries provide functionality to deal with\
    \ different types of problem patterns. The following cell provides some syntactic\
    \ sugar for the most common types of problem patterns. However, this is not a\
    \ complete list. There are many more types of problem patterns.", "  nums.count{\
    \ |num| num > 10 && num.to_i.even? }.\n          count{ |num| num.to_i.odd? &&\
    \ num.to_s.chars.first(2).odd? }\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n\
    Why not use `count` instead of `length`?\n<|/ c |>\n<| a dscore=3 |>\nHow about:\n\
    <code>\nnums = [33, -1, 0, 4, 21, 109]", "    num = nums[0]\n    i = 0\n    while\
    \ i < nums.length do\n        if nums[i] > 10 && nums[i] % 2 === 1 && nums[i-1]\
    \ % 2 === 1 then\n            numsCount = nums[i-1] + nums[i] + nums[i+1]\n  \
    \          return numsCount\n        end\n        i += 1\n    end\nend", "  total\
    \ = 0\n  for n in nums\n    total += 1 if n < 10 and n%2 == 1 and n%3 == 1 else\
    \ 0\n  end\n  return total\nend", "  # Write your solution here\n  return nums.count{\
    \ |x| (x > 10 && x[0] % 2 == 1 && x[1] % 2 == 1) }\nend\n</cell>\n<cell>", " \
    \ count = 0\n  for num in nums\n    if num > 10\n      count += 1\n    if num\
    \ > 10\n      count += 1\n    if num > 10\n      count += 1\n    if num > 10\n\
    \      count += 1\n    if num > 10\n      count += 1\n    if num > 10\n      count\
    \ += 1\n    if num > 10\n      count += 1\n    if num > 10\n      count += 1\n\
    \    if num > 10\n      count += 1\n    if num > 10\n      count += 1\n  end\n\
    \  count\nend", "  nums.length.times do |i|\n    if nums[i] >= 10 and (nums[i].odd?\
    \ or nums[i].even? and nums[i-1].odd? or nums[i-1].even?)\n      nums.delete_at(i)\n\
    \    end\n  end\n  nums.length\nend", "  nums.each do |num|\n    return 1 if num\
    \ % 2 != 0\n    evenDigits, oddDigits = num.to_s.split('').reverse.split('').reverse\n\
    \    evenDigits.each_char.map { |c| c.to_i }.inject(0) { |s, i| s + i }\n    oddDigits.each_char.map\
    \ { |c| c.to_i }.inject(0) { |s, i| s + i }\n  end\n  return 0\nend\n</cell>\n\
    <text>\nIn the above cell, we've defined a function that counts the number of\
    \ elements in the array that are greater than 10 and both first and last digits\
    \ of a number are odd (1, 3, 5, 7, 9). Now let's see how to use it.", "    # Write\
    \ your code here\n    count = 0\n    for i in nums:\n        if i > 10 and i%2\
    \ == 1:\n            count += 1\n        if i > 10 and i%2 != 0:\n           \
    \ count += 1\n    return count\nprint specialFilter([15, -73, 14, -15])\nprint\
    \ specialFilter([33, -2, -3, 45, 21, 109])\n</cell>\n<text>\nQuestion 3\nWrite\
    \ a function that takes a string as input and returns the number of words in that\
    \ string. \nFor example, \n>>> stringToWords('this is    a string')\n2\n>>> stringToWords('is\
    \    another string')\n1\n>>> stringToWords('')\n0\n>>> stringToWords('  ')\n\
    0\n>>> stringToWords('hello world')\n2\n>>> stringToWords('Hello World')\n0\n\
    >>> stringToWords('Hello World!')\n1\n>>> stringToWords('Hello World! This is\
    \ my home')\n1\n>>> stringToWords('This sentence has multiple words    ')\n2\n\
    >>> stringToWords('sentence with only words')\n0\n>>> stringToWords('Sentence\
    \ with only words')\n1", "  return [num for num in nums if num > 10 and num %\
    \ 2 == 0 and nums.first % 2 == 0].size\nend", "  result = 0\n  for i in nums\n\
    \    if (i > 10) \n      result += (i.to_s.chars.to_a.map { |x| x.to_i }).count(10)\
    \ >= 2\n    if (i.to_s.chars.to_a.map { |x| x.to_i }).count(10) % 2 != 1\n   \
    \   result += i.to_s.chars.to_a.map { |x| x.to_i }.count(10) >= 3\n  end\n  result\n\
    end", "  sum = nil\n  nums.each do |num|\n    sum += 1 if num > 10 and num % 1\
    \ > 0\n  end\n  sum\nend", "  return nums.length.times.with_object(0) do |counter,obj|\n\
    \    nums[counter] > 10 && nums[counter].odd? == true && nums[counter].even? ==\
    \ true && nums[counter-1].odd? == true && nums[counter-1].even? == true \n   \
    \ obj += 1\n  end\nend", "    count = 0\n    nums.each do |n|\n        if n %\
    \ 10 == 0 && n % 100 != 0 && (n % 1000 == 0 || n % 100 == 0 && n % 10000 == 0)\n\
    \            count += 1\n        end\n    end\n    return count\nend", "    nums.each_index\
    \ { |index|\n        next unless nums[index] > 10\n        next  if nums[index]\
    \ > 10 && nums[index-1] % 2 == 1 && nums[index+1] % 2 == 1\n    }\nend\n</code>\n\
    <|/ a |>\n<| a |>\nTry this one:\n<code>", "  return countElements(nums, isOdd(nums))\
    \ \nend", "  nums.inject(0) do |sum, num|\n    sum = sum + 1 if num > 10 && num.odd?\n\
    \    sum = sum + 1 if num > 10 && num.odd? && num.odd?\n    sum\n  end\nend",
  "  # Your code here\n  count=0\n  for i in nums\n    if i>10\n      if ((i%2)==1)&&(i!=(i-1))\n\
    \        count+=1\n  return count\n</cell>\n<text>\nSolution\nSolutions are also\
    \ called algorithms or solutions to problems. Let's see how they work!", "  return\
    \ nums.count { |x| (x > 10) && (x[0] % 2 == 1 && x[1] % 2 == 1) }\nend\n</cell>\n\
    <cell>\nspecialFilter.call([15, -73, 14, -15])\n</cell>\n<cell>\nspecialFilter.call([33,\
    \ -2, -3, 45, 21, 109])\n</cell>\n<text>\nExercise\nDefine a function that takes\
    \ a sequence of numbers and returns the elements of the sequence that are all\
    \ even numbers.\nHint: you may need to use the methods defined in Array.\nExamples:",
  "  return nums.count(nums.select(lambda num: num > 10 and num.first % 2 == 1 and\
    \ num.last % 2 == 1))\n</cell>\n<cell>\nspecialFilter(nums)\n</cell>\n<cell>",
  "  nums.each do |num|\n    if num > 10 && num.to_s.slice(-2).to_i.odd? && num.to_s.slice(-3).to_i.odd?\n\
    \      puts num\n    end\n  end\nend\nspecialFilter([-7, -15, -12, -24, 2, -5,\
    \ -29, -52, 12])", "  nums.inject(0) { |sum, v| sum + (v > 10 && v % 2 && v.to_s.split('')[1,\
    \ 2].to_i % 2 == 1) }\nend", "  sum = 0\n  for i in nums do\n    sum = sum + i\n\
    \  end", "  nums.find {|x| x > 10 && x.odd? && x.first % 2 != 0 && x.last % 2\
    \ != 0}\nend\n</code>\n<|/ a tags=ruby,arrays,methods,algorithm |>\n<| c |>\n\
    You can shorten it even more by just `nums.find { |x| x > 10 && x.odd? && x.first\
    \ % 2 != 0 && x.last % 2 != 0 }`.\n<|/ c |>\n<| c |>\nThanks. I was in the process\
    \ of writing that. :)\n<|/ c |>\n<| a |>\nHere is a nice purely functional way\
    \ of doing this:\n<code>", "  count = 0\n  for n in nums \n    if n > 10 && n\
    \ % 2 == 1 && n % 3 == 1\n      count += 1\n    end\n  end\n  count\nend\n</cell>\n\
    <cell>", "    # Your code here\n    nums.each do |num|\n        if num > 10 &&\
    \ num.even? && num.odd?\n            return 1\n        end\n    end\n    return\
    \ 0\nend", "  count = 0\n  while nums.length > 0\n    first = nums.shift()\n \
    \   if first > 10 and first % 2 == 1 \n      nums.shift\n    end\n    last = nums.shift\n\
    \    if last > 10 and last % 2 == 1 \n      nums.shift\n    end\n    count +=\
    \ 1\n  end\n  return count\nend", "  nums.each do |num|\n    if num > 10 and num\
    \ % 2 == 1 and num % 3 != 1 and num % 5 != 1\n      count\n    else\n      nil\n\
    \    end\n  end\nend\n</cell>\n<cell>", "  nums.each do |num|\n    return 0 if\
    \ num > 10\n    return 1 if num % 1 == 0\n    return 2 if num % 3 == 0\n    return\
    \ 1 if num % 5 == 0\n    return 2 if num % 7 == 0\n    return 3 if num % 9 ==\
    \ 0\n    return 4\n  end\nend", "  count = 0\n  lastDigit = nums.last\n  firstDigit\
    \ = nums.first\n  lastOne = lastDigit % 1\n  firstOne = firstDigit % 1\n  \n \
    \ nums.each do |num|\n    num = num.to_i\n    lastDigit = num % 10\n    firstDigit\
    \ = num % 100\n    lastOne = lastDigit % 1\n    firstOne = firstDigit % 1\n  \
    \  \n    if lastDigit == 1 && firstOne == 1\n      count += 1\n    end\n  end\n\
    \  \n  return count\nend\n</cell>\n<cell>", "  count = 0\n  \n  nums.each do |num|\n\
    \    if num > 10 && num > num.first % 2 != 0 && num.last % 2 == 1\n      count\
    \ += 1\n    end\n  end\n  \n  return count\nend", "  num = nums\n  evenNum = 0\n\
    \  oddNum = 0", "  i = 0\n  n = nums.length", "  # Your code here!\nend", "  \
    \  # Write your code here\n    nums.each_index do |index|\n        if(nums[index]\
    \ > 10 and nums[index].odd? == true and nums[index].odd? == true) \n         \
    \   count = count + 1\n        end\n    end\n    return count\nend", "    count\
    \ = 0\n    for i in nums\n        if i >10\n            if i.first % 2 != 0 and\
    \ i.last % 2 != 0\n                count = count + 1\n    end\n    return count\n\
    end", "    count = 0\n    nums.each do |x|\n        if ((x % 10).odd?) && (x.to_s[0,\
    \ 1] % 2).odd?\n            count += 1\n        end\n    end\n    return count\n\
    end", "  nums.each {|i| return i} unless nums.empty?\n  nums.each {|i| return\
    \ 0 unless i > 10 and i.odd? and (i[0].odd? and i[nums.length-1].odd?)}\n  nums.length\n\
    end", "  nums.each do |n|\n    return 1 if n % 10 > 10\n    return 1 if n % 10\
    \ > 10 && n % 100 % 10 > 10\n    return 1 if n % 10 > 10 && n % 100 % 10 > 10\
    \ && n % 100 % 100 > 10\n  end\n  return 0\nend", "    sum = 0\n    odd = 1\n\
    \    for i in nums\n        if i > 10\n            sum += odd\n            odd\
    \ *= i % 2\n    return sum", "    nums.map! { |x| x % 2 == 1 ? x + 1 : x }\n \
    \   return nums.count { |x| x > 10 && x % 2 == 1 && x.to_s.rjust(2, '0').gsub(/[02468]$/,\
    \ '').to_i(2) }\nend\n</cell>\n<code language=julia-1.0>", "  nums.inject(0) {\
    \ |acc, element| \n    (element > 10 && element.to_i.odd? && element.to_i%2 ==\
    \ 1) ? acc + 1 : acc\n  }\nend", "    count = 0\n    \n    for num in nums\n \
    \       \n        if num > 10\n            count += 1\n            \n        if\
    \ num > 10 and\n            \n            n % 2 == 1\n            \n        end\n\
    \    end\n    \n    count\nend\n</cell>\n<text>\nExercise (2 min)\nWrite a function\
    \ that takes a string as input and returns the number of \ncharacters in the string\
    \ that are greater than 10.", "  result = 0\n  for i in nums\n    if i > 10 &&\
    \ i % 2 == 1 && i / 10 == 1 && i / 100 !=1 \n      result += 1\n    end\n  end\n\
    \  return result\nend", "    i = 0\n    while i < nums.length\n        if nums[i]\
    \ > 10 and nums[i].modulo(2) && nums[i].modulo(2) == 1 && nums[i].modulo(1) ==\
    \ 0\n            i += 1\n        else\n            i += 1\n        end\n    end\n\
    \    nums.length - i\nend\n</cell>\n<cell>", "  # Write your code here.\n  return\
    \ 0", "    nums.select { |x| x > 10 && x.to_s.chars.first.odd? && x.to_s.chars.last.odd?\
    \ }.length\nend\n</cell>\n<code language=julia-0.6>", "  count = 0\n  for i in\
    \ nums\n    if i > 10 && i&1 != 0 && i&2 != 0\n      count = count + 1\n    end\n\
    \  end\n  count\nend\n</cell>\n<cell>", "  nums.each { |num| \n    if num >= 10\
    \ && num.odd? && num.odd? && num.odd?\n      return 1\n    end\n  }\n  0\nend\n\
    </cell>\n<cell>\nputs specialFilter.call([15, -73, 14, -15])\n</cell>\n<cell>\n\
    puts specialFilter.call([33, -2, -3, 45, 21, 109])\n</cell>\n<text>\nRuby is a\
    \ language that uses curly braces for blocks of code.", "  count = 0\n  for n\
    \ in nums\n    if n > 10 and nums.odd? and nums.odd?\n      count += 1\n    end\n\
    \  end\n  count\nend", "    nums.each do |num|\n        if num >= 10 && num %\
    \ 2 == 1 && num % 2 == 0 \n            counter = counter + 1\n        end\n  \
    \  end\nend", "  count = 0\n  i = 0\n  while (i < nums.length)\n    if (nums[i]\
    \ > 10 and (isOdd(nums[i]) or isOdd(nums[i - 1])))\n      count += 1\n    i +=\
    \ 1\n  return count\n</cell>\n<cell>", "  nums.inject(0) {|acc, i| acc += 1 if\
    \ i > 10 && i % 2 != 0}\nend\n</code>\nThis works by accumulating a boolean value\
    \ for each element in the array (via the block) and incrementing acc each time\
    \ the block is run.  Thus acc starts at 0, and is incremented whenever the block\
    \ is run.  In the example, the first time the block is run, acc is set to 0 and\
    \ is incremented when the condition is met.  This is done for each element in\
    \ the array.  Thus acc starts at 0, is incremented for elements 1, 3, 5, 7, and\
    \ 9.  Once we reach an element greater than 10, no more numbers are greater than\
    \ 10, so acc is set to 0 again.  Since the first condition failed, the second\
    \ condition will never be true, so acc is not incremented.  Therefore, at any\
    \ point in the array, the block is run once.\nThe call to inject creates a new\
    \ variable, which is the total accumulated value returned by the block.  Note\
    \ that I changed the name of the variable from nums to acc.  I then add 1 to the\
    \ accumulator, and only increment acc if the condition evaluates to true.  That\
    \ is why I added == 0 to the block.  inject returns an accumulator, which is the\
    \ value returned by the block.  In our example, the first time the block is run,\
    \ the accumulator is 0, and the value returned by the block is 1.  Thus acc ==\
    \ 1, and acc is incremented.  At the end of the array, the block is run once,\
    \ accumulator is 0, and the value returned by the block is 0.  Thus acc == 0 and\
    \ acc is not incremented.  Therefore, at any point in the array, the block is\
    \ run twice.\n<|/ a tags=ruby dscore=2 |>\n<| c |>\nThis is also a great way to\
    \ approach this problem. Very concise and clear.\n<|/ c |>\n<| a |>\nSince nobody\
    \ has posted it yet, I thought I'd post a more concise answer:\n<code>", "   \
    \ nums = nums.sort\n    nums.each do |num|\n        if num.to_s.first.to_i.odd?\
    \ && num.to_s.last.to_i.odd? \n            puts num\n        end\n    end\n  \
    \  puts \"#{nums.size} elements are greater than 10 and both first and last digits\
    \ of a number are odd.\"\nend", "  \n  # Initialize count\n  count = 0", "  i\
    \ = 0\n  while i < nums.length\n    if (nums[i] > 10) && (nums[i] == nums[i].modulo(10))\
    \ && ((nums[i].first % 2) == (nums[i].last % 2))\n      i += 1\n    else \n  \
    \    i += 1\n  end\n  return i\nend\n</cell>\n<code language=julia-1.0>\nspecialFilter.call([15,\
    \ -73, 14, -15])\n</cell>\n<code language=julia-1.0>\nfunction specialFilter2(nums)\n\
    \  nums = nums[:]\n  i = 1\n  while i < length(nums)\n    if (nums[i] > 10) &&\
    \ (nums[i] == nums[i].modulo(10)) && ((nums[i].first % 2) == (nums[i].last % 2))\n\
    \      i += 1\n    else \n      i += 1\n      nums[i] = nums[i] + 5\n    end\n\
    \  end\n  return i\nend\n</cell>\n<code language=julia-1.0>\nspecialFilter2.call([15,\
    \ -73, 14, -15])\n</cell>\n<code language=julia-1.0>\nfunction oddEvenFilter(nums)\n\
    \  i = 0\n  while i < length(nums)\n    if ((nums[i] > 10) && (nums[i] == nums[i].modulo(10))\
    \ && ((nums[i].first % 2) == (nums[i].last % 2)))\n      i += 1\n    else \n \
    \     i += 1\n    end\n  end\n  return i\nend\n</cell>\n<code language=julia-1.0>\n\
    oddEvenFilter.call([15, -73, 14, -15])\n</cell>\n<text>\nRevisit The Filter, Dont\
    \ do it!\nThe filter I made seems inefficient.  Let's revisit it.  We know that\
    \ \n    f(A) \u2208 A \u21D2 A \u2208 \u03A6 \u21D2 A \u2208 \u03A6 \u21D2 \u03A6\
    \ \u2208 \u03A6\nso let's prove that\n    \u03A6 = \u03BB \u21D2 \u03BB \u2208\
    \ \u03BB \u21D2 \u03BB \u2208 \u03BB \u21D2 \u03BB \u2208 \u03BB \u21D2 \u03BB\
    \ \u2208 \u03BB \u21D2 \u03BB \u2208 \u03BB \u21D2 \u03BB \u2208 \u03BB\n    \u03A6\
    \ \u2208 \u03A6 \u21D2 \u03A6 \u2208 \u03A6 \u21D2 \u03A6 \u2208 \u03A6 \u21D2\
    \ \u03A6 \u2208 \u03A6 \u21D2 \u03A6 \u2208 \u03A6", "  nums.count {|e| e > 10\
    \ && (e % 2).zero? && e.odd? && e.first % 2 == 1 && e.last % 2 == 1}\nend", " \
    \ sum = 0\n  for i in nums\n    sum = (sum + i) if sum < 10 && i mod 2 != 0 &&\
    \ i mod 5 != 0\n  end\n  return sum\nend", "  return sum(nums.filter{|x| x > 10\
    \ and x.modulo(2).zero? and x.modulo(2).odd? })\nend", "    count = 0\n    odd_count\
    \ = 0\n    odd_odd_count = 0\n    \n    \n    nums.each do \n        \n      \
    \  if num > 10\n            count += 1\n            odd_count += 1\n         \
    \   \n            if num % 2 == 1 && num % 2 == 0\n                odd_odd_count\
    \ += 1\n            \n            \n        end\n    end\n    \n    \n    \n \
    \   \n    return count\n    \nend", "  nums.each do |n|\n    nums.include? n if\
    \ n > 10\n    nums.include? n if n % 100 == 0 and n % 100 != 10\n  end\nend\n\
    </code>\n<|/ q |>\n<| c |>\nJust to be clear, you want to write a function that\
    \ returns a count of all the elements in the array that meet the criteria you\
    \ described, but only those elements that meet the criteria?\n<|/ c |>\n<| c |>\n\
    : It would help if you gave some actual code examples of your input and the desired\
    \ output.\n<|/ c |>\n<| c |>\nPlease check my edit and code below\n<|/ c |>\n\
    <| c |>\nThis looks like a homework question... what have you tried so far?\n\
    <|/ c |>\n<| c |>\n: Yes.  It's a question from a past exam paper.\n<|/ c |>\n\
    <| a dscore=3 |>\n<code>", '  return nums.count(nums.select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(&:odd).select(',
  "    count = 0\n    firstOdd = nums.find {|n| n % 2 == 1}\n    nums.each_index {|i|\n\
    \        if ((i + 1) % 2 == 0) then\n            count += 1\n            if (firstOdd\
    \ == nums[i]) then\n                if ((nums[i + 1] % 2) == 1) then\n       \
    \             count += 1\n                end\n            end\n        end\n\
    \    }\n    return count\nend", "    # Your code goes here\n    sum=0\n    for\
    \ i in nums:\n        if i>10 and i%2!=0:\n            sum+=1 \n    if sum>=1\
    \ and nums[0]%2!=0 and nums[-1]%2!=0:\n        return sum\n    else:\n       \
    \ return 0\nprint specialFilter(nums)\n</cell>\n<text>\nUsing map() to apply a\
    \ function to every element in a list\nThe map() function in Python is very useful\
    \ because you can apply it to every element in a list!", "  return countElements(nums)\
    \ if (nums.length != 0) else 0\nend", "  result=0\n  for i in nums\n    if i>10\
    \ and (i mod 2 != 0 and i mod 5 == 0)\n      result = result + 1\n    end\n  end\n\
    \  return result\nend\n</cell>\n<cell>", "  count = 0\n  for i in nums\n    if\
    \ i > 10 and (i%2 == 1 and (i%10 == 1 or i%10 == 9))\n      count += 1\n    end\n\
    \  end\n  count\nend", "    nums.count {|n| n > 10 && n % 1 == 0 && n % 2 == 1}\n\
    end", "  total = 0\n  for i in nums\n    if i > 10 and nums.all? {|x| x.odd? &&\
    \ x.first_odd? && x.last_odd? }\n      total += 1\n    end\n  end\n  total\nend",
  "\tnums.each do |num|\n\t\tif num >= 10 and (num > 10 % 2 and num % 2 != 0)\n\t\t\
    \treturn 1\n\t\telsif num >= 10 and (num < 10 % 2 and num % 2 == 0)\n\t\t\treturn\
    \ -1\n\t\tend\n\tend\n\treturn 0\nend", "  count = 0\n  \n  nums.each do |n|\n\
    \    if (n > 10 && nums.find { |m| m > 10 }) \n      count += 1 if nums.find {\
    \ |m| m % 2 == 0 } && nums.find { |m| m % 2 == 1 }\n    end\n  end", "  arr =\
    \ []\n  n = 0\n  nums.each { |x| arr << x if x > 10 }\n  arr.each { |x| n += 1\
    \ if x % 2 == 1 && x % 3 == 1 && x % 5 == 1 }\n  return n\nend", "  nums.find\
    \ { |x| x > 10 && x.odd? && x.odd? && x.first.odd? && x.last.odd? } || 0\nend",
  "  nums.count{|x| x > 10 && x.odd? && x.even? && x.first_digit&1 <=> x.last_digit&1\
    \ == 1}\nend\n</cell>\n<cell>", "    nums.count{ |num| num > 10 and (num.odd?\
    \ or num.even? or num.first&.odd? or num.last&.odd?) }\nend", "    nums.count{|num|\
    \ num > 10}\n    nums.count{|num| num > 10 && num.odd?}\n    nums.count{|num|\
    \ num > 10 && num.odd? && num.odd?}\nend", "    return nums.inject(0) do |sum,\
    \ n|\n        sum + 1 if nums.any? { |x| x > n } && nums.any? { |x| x.odd? } \n\
    \    end\nend\n</cell>\n<text>\nPart 4: Using Ruby's reduce\nThe reduce method\
    \ is a higher-order function that is very useful in Ruby. As we saw previously,\
    \ we can use it to transform a collection of objects into a single value.", " \
    \ nums.count { |n| n.odd? && n.odd? && n.odd? && n.odd? }.to_i\nend\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nIt should be `odd.odd?` rather than `odd.even?` :)\n\
    <|/ c |>\n<| c |>\n, thanks, I fixed it. I copied the code from the question and\
    \ didn't notice that `odd` was an array. :P\n<|/ c |>\n<| c |>\n, no worries,\
    \ you can always edit the answer to make any improvements you like :)\n<|/ c |>\n\
    <| c |>\nThat is true but I also noticed that my first version was wrong. It should\
    \ be `nums.count { |n| n.odd? && n.odd? && n.odd? && n.odd? }`.\n<|/ c |>\n<|\
    \ c |>\nThe return value is not as expected. While this answer works it returns\
    \ a count of the number of elements that match not the number of odd numbers.\
    \ I did find a solution here http://stackoverflow.com/questions/13590180/array-count-on-multiple-conditions\n\
    <|/ c |>\n<| a dscore=2 |>\nThe reason why your code isn't working is because\
    \ of the precedence of the && operator. You need to use the logical AND operator\
    \ instead of the bitwise AND operator ||\n<code>", "    count = 0\n    nums.each\
    \ do |num|\n        if num > 10\n            count += 1 if num.to_s.slice!(-1)\
    \ % 2 == 1 and num.to_s.slice!(-1) % 2 == 0\n        end\n    end\n    return\
    \ count\nend", "  count = 0\n  for i in nums\n    if i > 10 \n      && i.first\
    \ % 2 != 0 && i.last % 2 != 0\n      count++\n  end\n  return count\nend", " \
    \ count = 0\n  for i in nums\n    number = convert(i)\n    if number > 10 and\
    \ (number % 2 == 1 and number % 2 != 0)\n      count += 1\n    end\n  end\n  count\n\
    end", "  nums.each do |num|\n    if num > 10 and num.odd? and num > 10 and num.odd?\n\
    \      count+=1\n    end \n  end\n  count\nend\nspecialFilter([15, -73, 14, -15]) ",
  "    nums.each do |n|\n        if n>10 && n%2==1 && n%3==1 && n%5==1\n         \
    \   puts n\n        end\n    end\nend", "  count = 0\n  for i in nums\n    if\
    \ (i >= 10 && i%2 == 1 && i%2 != 0) \n      count += 1\n    end\n  end\n  return\
    \ count\nend\n</cell>\n<cell>", "    nums.count { |num| num > 10 && num % 1 ==\
    \ 0 && num.odd? && num.first % 2 == 1 && num.last % 2 == 1 }\nend\n</code>\n<|/\
    \ a dscore=0 |>\n<| c |>\nthank you for that very informative answer. I still\
    \ haven't quite figured out how to do it, but at least I have a starting point.\
    \ Thank you!\n<|/ c |>\n<| c |>\nI tried to add an answer but it doesn't seem\
    \ to be letting me. Does anyone know how I can do that?\n<|/ c |>\n<| c |>\nI\
    \ still haven't figured out how to do it either. I did a search and found some\
    \ code on here that was supposed to do it but for some reason it isn't working.\
    \ Could you take a look and see what might be going wrong? I added my code to\
    \ the original question. Thank you!\n<|/ c |>\n<| c |>\n`nums.count { |num| num\
    \ > 10 && num % 1 == 0 && num.odd? && num.first % 2 == 1 && num.last % 2 == 1\
    \ }` - this should return what you want.\n<|/ c |>\n<| a dscore=0 |>\nHere's a\
    \ solution that works on two arrays, one containing the numbers to filter and\
    \ the other containing numbers to exclude. This will work with any set of numbers,\
    \ not just two.\n<code>", "    count = 0\n    odd_first = odd nums[0]\n    odd_last\
    \ = odd nums[-1]\n    odd_nums = nums[1..nums.length]\n    nums = nums[0..-2]\n\
    \    for n in nums\n        if odd_first and odd_last\n            count += 1\n\
    \        if odd_first\n            count += 1\n        if odd_last\n         \
    \   count += 1\n        if odd_nums\n            count += 1\n    end\n    return\
    \ count\nend", "  nums.count{|n| n > 10 and n % 2 != 0 and nums.first % 2 == 1\
    \ and nums.last % 2 == 1}\nend", "  # Write your filter here.\nend", "  \n  #\
    \ Hint: use the filter function\n  return nums.filter { |num| num > 10 }.length\
    \ == nums.length\nend", "    # Your code here\n    # To check if the first and\
    \ last elements are odd\n    odd = nums[0]%2 == 0 and nums[0]%2 == 0\n    # To\
    \ check if the first and last elements are even\n    even = nums[0]%2 == 0 and\
    \ nums[0]%2 != 0\n    # To check if the element in the middle is greater than\
    \ 10\n    greater = nums[-1] > 10\n    return 0 if odd and even and greater else\
    \ 1", "  count = 0\n  for i in nums\n    count += 1 if i > 10 && i.rem(10).odd\
    \ && i.rem(10).even\n  end\n  count\nend\n</cell>\n<code language=julia-1.0>\n\
    specialFilter.call([15, -73, 14, -15])\n</cell>\n<text>\nExercise 2: Filtering\
    \ a Set\nWe've already seen filtering a collection (an Array or Set) with a predicate.\
    \ Now write a function that filters a Set using a predicate that accepts a single\
    \ element from the Set and returns true or false depending on whether or not the\
    \ element should be included in the filtered collection.  Recall the Set data\
    \ type from the previous lessons. You will also need to define a new data type\
    \ that holds a boolean value for whether or not the element should be included\
    \ in the filtered collection.", "    count = 0\n    odd_count = 0\n    for n in\
    \ nums\n        if n % 10 > 0 and n % 10 < 11 and (n % 100 % 10 == 1 or n % 100\
    \ % 10 == 7)\n            count += 1\n            odd_count += 1\n    return count\
    \ and odd_count\n    ", "  sum = nums.reduce(0, :+)\n  odd = sum.to_s.chars.grep(/[0-9]*/).to_a.map\
    \ { |s| s.to_i}.select { |s| s % 2 }.select { |s| s % 2 == 1 && s.last.to_i%2\
    \ == 1 }.count\n  odd_first = sum.to_s.chars.grep(/[0-9]*/).to_a.map { |s| s.to_i}.select\
    \ { |s| s % 2 == 1 && s.first.to_i%2 == 1 }.count\n  odd_last = sum.to_s.chars.grep(/[0-9]*/).to_a.map\
    \ { |s| s.to_i}.select { |s| s % 2 == 1 && s.last.to_i%2 == 1 }.count\n  odd_first\
    \ = odd_first == nums.count if odd_first == nil\n  odd_last = odd_last == nums.count\
    \ if odd_last == nil\n  return odd_first + odd_last + odd\nend", "    count =\
    \ 0\n    for num in nums\n        if num > 10 and (num mod 2 != 0 and (num mod\
    \ 10 == 0 or num <> 9))\n            count = count + 1\n    end\n    return count\n\
    end", "    count = 0\n    for n in nums\n        if n < 10 and n % 2 == 0 and\
    \ n % 1 == 1\n            count += 1\n    return count", "  return sum(nums[0..-1].map\
    \ { |num|\n    oddDigit(num) and oddFirst(num) and oddLast(num) }) > 0\nend",
  "  odd = Array.new\n  even = Array.new", "  count = 0\n  for x in nums\n    if x\
    \ > 10\n      count += 1\n      \n    if x.even? and x.odd?\n      count += 1\n\
    \      \n    if x.odd?\n      count += 1\n      \n    if x.even?\n      count\
    \ += 1\n      \n  return count\nend", "  # Your code here\n  nums.count{|n| n\
    \ > 10 and n % 1 == 0 and n % 2 == 1 }\nend\n</cell>\n<text>\nQuestion 9\nWe have\
    \ a function we call specialFilter() above that we also want to test. Let's call\
    \ this function filter(). Write a function called filter() that takes a single\
    \ argument (a list) and returns true if and only if the list satisfies the condition\
    \ above. For example:", "    count = 0\n    i = 0\n    while i < nums.length\n\
    \        if nums[i] > 10 and nums[i].to_s.length == nums[i].to_s.to_s.length and\
    \ nums[i].to_s[0] % 2 == 1 \n            && nums[i].to_s[nums[i].to_s.length-1]\
    \ % 2 == 1\n            then count+=1\n            i += 1\n        else i+=1\n\
    \    end\n    count\nend\n</cell>\n<cell>", '  numbers = [num for num in nums
    if num > 0]', "  if nums.nil? or nums.empty? \n    return 0\n  end", "    count\
    \ = 0\n    nums.each do |n|\n      count += 1 if n.to_s.chars.to_a[-2,-1].odd?\n\
    \    end\n    count\nend\n</code>\n<|/ a |>\n<| a dscore=2 tags=ruby,algorithm\
    \ |>\nA solution in Javascript:", "    # Your code here\n    count = 0\n    for\
    \ n in nums\n        if n > 10 and n % 2 and n % 4\n            count += 1\n \
    \       end\n    end\n    return count\nend", "  return nums.count { |num| num\
    \ > 10 &&\n    (((num % 10).even? && (num % 10).odd? && ((num.to_s.to_i ** 2).to_f\
    \ % 10).odd?))\n  }\nend", "  count = nums.inject(0) {|sum, num| sum += num if\
    \ num > 10 and num % 2 == 1 and num % 2 == 1 }\n  count = nums.length if nums.is_a?(Array)\n\
    \  count\nend", "  nums.count{|n| n % 2 == 0 && n % 10 == 0 && n % 11 == 0 }\n\
    end\n</cell>\n<cell>", "  nums.count.reduce(0) { |acc, value| \n    if value >\
    \ 10 and nums[value-1].to_i.odd? and nums[value].to_i.odd?\n      acc + 1 \n \
    \   end \n  }\nend", "    nums.count {|n| n.is_a? Integer and\n          n % 10\
    \ == 0 and\n          n % 100 != 0 and\n          n % 100 % 10 == 1}\nend\n</cell>\n\
    <cell>", "  # Your code here\n  pass", "  nums.find { |num| num > 10 }\n  nums.sum\
    \ { |num| num % 2 != 0 }\nend\n</code>\n<|/ a tags=ruby,filter,arrays |>\n<| c\
    \ |>\nOk I got this to work (at least on paper) but I don't quite understand your\
    \ code. Would you mind explaining what's happening there?\n<|/ c |>\n<| c |>\n\
    I added some comments to the code. `nums.find` will iterate through every element\
    \ in `nums` and perform an action on each element. In this case it returns the\
    \ first element of `nums` which is greater than 10 (i.e. `15`), which means we\
    \ stop the iteration. `nums.sum` then iterates through every element in `nums`\
    \ and adds the elements to a sum. `nums.find { |num| num > 10 }` finds the first\
    \ element that is greater than 10 and returns it. `nums.sum { |num| num % 2 !=\
    \ 0 }` then adds up every element that is odd (`1`, `3`, `5`, `7`, `9`). It would\
    \ return 2 since `15` and `-73` would be included in the sum.\n<|/ c |>\n<| c\
    \ |>\nOh ok that makes sense. Thanks so much for the help :)\n<|/ c |>\n<| c |>\n\
    Just to say I wouldn't use this solution as it uses iterative processes. I would\
    \ go with a method that uses `map` and `inject` instead.\n<|/ c |>\n<| c |>\n\
    Oh I agree, I think the method I added would be a more appropriate solution for\
    \ this problem (although I did use a `map` and `inject` solution before).\n<|/\
    \ c |>\n<| a dscore=1 |>\nThe other answers are great, but I just want to add\
    \ something that might be helpful.\nThe method Enumerable#partition is pretty\
    \ handy for this.  I use this often when creating sub-groups of an array.\nFor\
    \ example, say you have a method that groups numbers into odd and even numbers.\
    \ You could do this without using an intermediate variable:\n<code>", "    count\
    \ = 0\n    nums.each do |num|\n        if (num > 10 && num.first % 2 == 1 && num.last\
    \ % 2 == 1)\n            count += 1\n        end\n    end\n    return count\n\
    end", "  count = 0\n  nums.each do |n|\n    if n.is_a?(Integer)\n      n >= 10\
    \ && n.odd? && n != 1 && n != 3\n      count += 1\n    elsif n.is_a?(String)\n\
    \      n =~ /\\d/\n      n >= 10 && n.odd? && n != 1 && n != 3\n      count +=\
    \ 1\n    end\n  end\n  count\nend\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| a\
    \ dscore=0 |>\n<code>", "  count = 0\n  \n  for i in nums\n    if i > 10 and (i[0].odd?\
    \ and i[1].odd?)\n      count += 1\n      \n  return count\n</cell>\n<cell>",
  "  count = 0\n  \n  for i in 0 .. nums.length - 1 do\n    if nums[i]>10 then\n \
    \     if nums[i] > 100 then\n        if nums[i] > 1000 then\n          if nums[i]\
    \ > 10000 then\n            if nums[i] > 100000 then\n              if nums[i]\
    \ > 1000000 then\n                if nums[i] > 10000000 then\n               \
    \   if nums[i] > 100000000 then\n                    if nums[i] > 1000000000 then\n\
    \                      if nums[i] > 10000000000 then\n                       \
    \ count = count + 1\n                    end\n                  end\n        \
    \        end\n              end\n            end\n          end\n        end\n\
    \      end\n    end\n  end\n  \n  return count\nend", "  nums.each do |num|\n\
    \    if (num > 10 and (num%2 != 0 or num.to_s[0..0].to_i%2 != 0))\n      puts\
    \ num\n    end\n  end\nend", "  count = 0\n  \n  while nums.length > 0\n    if\
    \ nums[0] > 10\n      count = count + 1\n      \n      if nums[0] % 2 == 1 \n\
    \        count = count - 1\n      \n      if nums[-1] % 2 == 1\n        count\
    \ = count - 1\n      \n      nums.shift\n    else\n      nums.shift\n    end\n\
    \  end\n  \n  count\nend", "    nums.each do |num|\n        if num > 10 and (num\
    \ % 2 == 0 or num % 2 == 1)\n            puts num\n        end\n    end\nend",
  "  count = 0\n  for i in nums\n    if i > 10 and (i + nums[nums.length - 1]) % 2\
    \ == 1\n      count += 1\n    end\n  end\n  count\nend\n</cell>\n<cell>", "  sum\
    \ = 0\n  sum1 = sum2 = 0\n  for num in nums\n    if num > 10 and (num1 % 2 ==\
    \ 1 or num % 2 == 1)\n      sum += num\n    end\n    sum1 += num % 10\n    sum2\
    \ += num % 100\n  end\n  return sum\nend\n</code>\n<|/ a |>\n<| c |>\nThanks for\
    \ this! Can you explain me how this works? I understand that we are taking the\
    \ sum of the first digit of every number that is above 10, but what is sum1? Why\
    \ do we add sum1 % 10? Can you also explain why we multiply num with 10 and then\
    \ add 100 to num?\n<|/ c |>\n<| c |>\nThe reason we add sum1 % 10 is that sum1\
    \ is what we get from taking the modulo of the first digit of num.  So if we take\
    \ 15 as a num, and take the modulo of its first digit, we get 1 (since it is the\
    \ first digit), which we then add to sum1. This gives us 15 % 10.  So we add 10\
    \ to sum1 so sum1 becomes 15 + 1.  So we add 1 to sum1 and get the 2nd digit,\
    \ which we then add to sum2. We then multiply num with 10 and add 100 to num to\
    \ get our final result.\n<|/ c |>\n<| a tags=ruby |>\nHere's a simpler one:\n\
    <code>", "  return nums.find { |x| (x > 10) && (x % 2 == 1) && (x % 3 == 1) }.to_i\n\
    end\n</cell>\n<cell>", "  result = nums.select{ |n| n > 10 }\n  return result.count(true)\
    \ if result\n  result = nums.select{ |n| n < 10 }\n  return result.count(true)\
    \ if result\nend", "  # Initialize count and sum variables\n  count = 0\n  sum\
    \ = 0", "    nums.count{|n| n % 2 == 0 && n % 1 % 2 == 0}\nend\n</cell>\n<cell>",
  "  count = 0\n  \n  # Loop through the array and count the number of odd numbers\n\
    \  # that are both first and last digits in the numbers\n  for i in (0..(nums.size-1))\n\
    \    if nums[i] == 0\n      next\n    if nums[i] > 10\n      next\n    if nums[i]\
    \ % 2 != 0\n      next\n    if nums[i] == 2 && (nums[i+1]%2 != 0)\n      count+=1\n\
    \      next\n  end\n  \n  return count\nend", "  count = 0\n  numbers.each do\
    \ |n|\n    if n > 10 and (n % 10).odd? and n.digits.first(2).odd?\n      count\
    \ += 1\n    end\n  end\n  count\nend", "\tcount = 0\n\tn = nums.length\n\tfor\
    \ x in nums\n\t\tif x > 10\n\t\t\tif x % 2 == 1\n\t\t\t\tif x % 3 == 0\n\t\t\t\
    \t\tif x % 5 == 0\n\t\t\t\t\t\tcount += 1\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\
    end\n\treturn count\nend", "  count = 0\n  for i in nums\n    if i.to_s == nil\n\
    \      count += 1\n    elsif i.to_i > 10\n      count += 1\n    elsif i.to_i.odd?\
    \ and i.to_s !~ /[1-9]/\n      count += 1\n    elsif i.to_i.odd? and i.to_s[0..-2].odd?\n\
    \      count += 1\n  end\n  count\nend", "  count = 0\n  i = 0\n  while i < nums.length\n\
    \    if nums[i] > 10\n      count += 1\n    i += 1\n    \n    if nums[i].odd?\
    \ && nums[i-1].odd?\n      count += 1\n    i += 1\n  end\n  \n  return count\n\
    end", "    nums.each do |num|\n        if num > 10 and num.to_s.first(2).to_i(2)%2\
    \ == 1 and num.to_s.last(2).to_i(2)%2 == 1\n            puts num\n        end\n\
    \    end\nend", "  nums.each do |num|\n    if (num > 10 and (num.odd? == true\
    \ or num.odd? == false))\n      return nums.size\n    end\n  end\nend", "  nums.sort\n\
    \  sum = 0\n  i = 0\n  while i < nums.length\n    sum = sum + nums[i]\n    if\
    \ sum > 10 && nums[i] > 1 && nums[i] % 2 == 1\n      i += 1\n    else\n      i\
    \ += 1\n    end\n  end\n  i\nend", "    count = 0\n    for num in nums\n     \
    \   if num > 10 and num % 2 == 1 and (num > 10 and num % 2 == 0 or num > -10 and\
    \ num % 2 == 1)\n            count = count + 1\n    end\n    return count\nend",
  "    nums.count{|n| n > 10 and n % 1 == 0 and n % 2 == 1}\nend", "  nums.reduce(0)\
    \ { |count, element| \n    if element > 10 && element.modulo(10).odd? && \n  \
    \      element.modulo(10).even? && element.modulo(10).odd? \n      count + 1\n\
    \    end\n  }\nend\n</cell>\n<cell>", "  count = 0\n  for i in nums\n    if i\
    \ > 10\n      count += 1 if (nums[-1] % 2 == 1) & (nums[0] % 2 == 1) \n    end\n\
    \  end\n  count\nend", "  nums.inject(0) {|total, n| total += 1 if (n % 2 == 1\
    \ && n % 10 == 1 && n % 100 != 11) }\nend", "    count = 0\n    even = False\n\
    \    first = False\n    last = False\n    digits = nums.to_s\n    digits = digits.chars\n\
    \    digits.reverse\n    for i in digits\n        number = i.to_i\n        if\
    \ number > 10\n            if even and first and last\n                count +=\
    \ 1\n            even = False\n            first = False\n            last = False\n\
    \            \n        elsif number > 0 and number <= 9 and (number & 1 == 0 or\
    \ number & 1 == 1)\n            if even\n                count += 1\n        \
    \    even = True\n            if first == true\n                first = false\n\
    \            if last == true\n                last = false\n        elsif number\
    \ > 9\n            last = True\n        elsif number < 0 and number >= -9 and\
    \ (number & 1 == 1 or number & 1 == 0)\n            if even\n                count\
    \ += 1\n            even = False\n            last = true\n        elsif number\
    \ < -9\n            first = true\n        end # if\n    end # for\n    count\n\
    end # specialFilter", "  \n  # Initialize the number of elements greater than\
    \ 10 and first and last \n  # digits of a number are odd as 0\n  count=0\n  \n\
    \  # Loop over each number in the array\n  nums.each do |num|\n  \n    # If the\
    \ number is greater than 10, increase the counter\n    if num>10\n      count+=1\n\
    \  \n    # If the first or last digit of the number is odd\n    if num[0]%2==1\
    \ && num[-1]%2==1\n      count+=1\n    end\n  end\n  \n  return count\nend", " \
    \   nums.each do |num|\n        if num > 10 && num % 2 != 0 && num.first % 2 !=\
    \ 0 && num.last % 2 != 0\n            return 1\n        else\n            return\
    \ 0\n        end\n    end\nend", "  count = 0\n  for x in nums\n    if x > 10\n\
    \      count += 1\n      if x.to_s[0..-2][1..-1].to_i.odd?\n        count = 2\n\
    \    end\n  end\n  count\nend\n</code>\nAs you can see this function is much more\
    \ readable than your original code. \nApart from that I would recommend you to\
    \ use a ruby version such as Ruby 2.0.0 instead of Ruby 1.9.3. You can install\
    \ it using the command:\n<code>\ngem install rubygems-update\n</code>\nor\n<code>\n\
    sudo apt-get install rubygems-bundler\n</code>\n<|/ a |>\n<| c |>\nThank you for\
    \ the answer. I tried your code. I get an error, `SyntaxError: unexpected keyword_end,\
    \ expecting $end\n...\n...\n...\n(irb):12:in `<main>'\n`\n<|/ c |>\n<| c |>\n\
    I made a mistake in the last line. It should be `end` and not `end1` :)\n<|/ c\
    \ |>\n<| c |>\nThank you. I will check this solution as soon as I get to my computer\
    \ and mark it as an answer if it works. I did not know about the version 2.0 though.\
    \ Is it a better version of Ruby?\n<|/ c |>\n<| c |>\nI suggest you to use Ruby\
    \ 2.0 instead Ruby 1.9.3 because it is the latest stable version of Ruby on Rails\
    \ (at least for Rails 3 projects). More info about the version 2.0 can be found\
    \ [here](http://rubygems.org/gems/rubygems-update/versions/2.0.3)\n<|/ c |>\n\
    <| c |>\nThank you for all the help. This helped a lot.\n<|/ c |>\n<| a |>\nRuby\
    \ 1.9.3 doesn't have a .to_i method, so you should be getting a NoMethodError\
    \ here. The reason you're not seeing this error is because you're trying to convert\
    \ an integer to a string before asking it to see if it's odd?. This works on ruby\
    \ 2.0 (I believe)\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
