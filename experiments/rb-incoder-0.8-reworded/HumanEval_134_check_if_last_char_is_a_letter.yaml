name: HumanEval_134_check_if_last_char_is_a_letter
language: rb
prompt: "# Create a function that returns true if the last character\n# of a given\
  \ string is an alphabetical character and is not\n# a part of a word, and false\
  \ otherwise.\n# Note: \"word\" is a group of characters separated by space.\n# Examples:\n\
  # >>> check_if_last_char_is_a_letter.call(\"apple pie\")\n# false\n# >>> check_if_last_char_is_a_letter.call(\"\
  apple pi e\")\n# true\n# >>> check_if_last_char_is_a_letter.call(\"apple pi e \"\
  )\n# false\n# >>> check_if_last_char_is_a_letter.call(\"\")\n# false\ndef check_if_last_char_is_a_letter(txt)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_if_last_char_is_a_letter\n\
  \    candidate = method(:check_if_last_char_is_a_letter)\n    assert_equal(false,\
  \ candidate.call(\"apple\"))\n    assert_equal(true, candidate.call(\"apple pi e\"\
  ))\n    assert_equal(false, candidate.call(\"eeeee\"))\n    assert_equal(true, candidate.call(\"\
  A\"))\n    assert_equal(false, candidate.call(\"Pumpkin pie \"))\n    assert_equal(false,\
  \ candidate.call(\"Pumpkin pie 1\"))\n    assert_equal(false, candidate.call(\"\"\
  ))\n    assert_equal(false, candidate.call(\"eeeee e \"))\n    assert_equal(false,\
  \ candidate.call(\"apple pie\"))\n    assert_equal(false, candidate.call(\"apple\
  \ pi e \"))\n  end\nend\n"
completions: ["  txt = txt.downcase\n  return !(txt.nil? || txt.empty?)\nend", " \
    \ txt =~ /[a-z]$/\n  return not $&\nend", "    txt.slice!(txt.rindex, 1).chars.all?\
    \ do |char|\n        ALPHA_LETTERS.include?(char)\n    end\nend", "    return\
    \ txt[-1..-1].all? { |char| char.ascii_letter? && !char.ascii_letter?[/[a-zA-Z]/]\
    \ }\nend\n</code>\n<|/ a |>\n<| a tags=ruby,string |>\nNot particularly idiomatic,\
    \ but works (and faster) without using regular expressions.\n<code>\n def contains_nonalpha?\
    \ string\n    string.chars.reject do |c|\n      c.ascii_only?\n    end.empty?\n\
    \ end\n</code>\n<|/ a dscore=4 |>\n<| c |>\nI ran into some problems testing this,\
    \ but I guessed there was something I missed.  It works.  Thanks!\n<|/ c |>\n\
    <| c |>\nThe performance test was in ruby 1.8.7. Apparently `chars` on 1.9 takes\
    \ significantly longer. http://stackoverflow.com/questions/812570/whats-the-fastest-way-to-remove-non-ascii-characters-from-a-ruby-string\n\
    <|/ c |>\n<| a dscore=4 |>\nYou can use the String#match method:\n<code>\nif string\
    \ =~ /^[a-zA-Z]+$/\n</code>\nor\n<code>\nif string =~ /[a-zA-Z]+/\n</code>\nor\n\
    <code>\nif string =~ /\\A[a-zA-Z]+\\Z/\n</code>\nor as pointed out by Chris, you\
    \ can do the same using String#scan:\n<code>\nif string =~ /[a-zA-Z]+/\n</code>\n\
    <|/ a tags=ruby,string |>\n<| c |>\nI would also add `/^[a-zA-Z]+$/` to the list.\n\
    <|/ c |>\n<| c |>\nAlso `/\\A[a-zA-Z]+\\Z/`\n<|/ c |>\n<| c |>\n- I wouldn't add\
    \ `\\A` at the beginning if the string doesn't start with the pattern.\n<|/ c\
    \ |>\n<| c |>\n- I agree that `/\\A[a-zA-Z]+\\Z/` is better, but I think it doesn't\
    \ really add much to the answer - it just gives a little more information on the\
    \ regexp than the others.\n<|/ c |>\n<| a tags=ruby,string |>\n<code>\ns = \"\
    HelloWorld\"", "  !!txt.empty? || txt.chars.last.match(/[a-z]/i).nil?\nend", " \
    \ txt.downcase!\n  txt.strip!\n  txt.length.positive?\n  txt.last.match?(/[a-z]+/).nil?\n\
    end", "  if txt.empty?\n    false\n  elsif txt.chars.last.match(/[a-zA-Z]$/)\n\
    \    true\n  else\n    false\n  end\nend", "  txt = txt.downcase\n  txt.slice!(txt.length-1)\n\
    \  txt.split(\" \").each do |word|\n    if word.length > 0 &&\n      word.slice!(word.length-1)\
    \ &&\n      word.start_with?(word[0,word.length-1])\n      return true\n    end\n\
    \  end\n  return false\nend", "    return txt[-1,1].isalpha()\nend", "    letters\
    \ = txt.split(\" \")\n    if letters.last.include?(\" \") || !letters.last.include?(\"\
    a\")\n        return false\n    end\n    return true\nend", "  txt = txt.strip\n\
    \  txt[-1].isalpha?\nend", "  if txt.size != 0 then\n    if txt.last == nil then\n\
    \      return false\n    else\n      if txt.last:gsub!(/[^A-Za-z]/,\"\") then\n\
    \        return false\n      end\n    end\n  end\n  return true\nend", "  txt.chars.last.upcase.match?(/[a-zA-Z]/)\n\
    end", "  !(txt[txt.length-1] == \" \" && /^[a-z]+$/.match(txt))\nend", "    lastChar\
    \ = txt.last\n    word = \"a-zA-Z0-9_ \"\n    return word.include?(lastChar)\n\
    end", "  return txt[txt.length-1].match(/[a-z]/) == nil\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nI think you meant \"return false\" instead of \"return true\".\
    \ I don't think you need the 'not nil' part.\n<|/ c |>\n<| c |>\nI prefer not\
    \ to use regexp. Thanks for sharing your solution.\n<|/ c |>\n<| a dscore=2 |>\n\
    One way would be to count the number of spaces in the string, and use that to\
    \ determine whether it is a word. \n<code>\nstr = \"hello world\"\nwords = \"\
    helloworld\".scan(/\\w+/) # [\"hello\", \"world\"]", "  return ((txt and txt.last\
    \ && txt.last.length >= 1) \n    && /^[a-zA-Z]+$/ =~ txt.last)\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails |>\n<| a tags=ruby,ruby-on-rails |>\nI would do\
    \ something like this:\n<code>", "  return txt[txt.length - 1].isalpha() and not\
    \ txt[txt.length - 2].isalpha()\nend", "  txt.split(\" \").each do |word|\n  \
    \  return false unless word.last.match(/\\A[a-z]\\Z/)\n  end\n  true\nend", " \
    \   txt = txt.split(\" \")\n    txt = txt[-1]\n    return not(txt.isalpha() and\
    \ len(txt) == 1)\nend", "    return not txt[-1].match(/\\S/)\nend", "  # Your\
    \ code here!\n  if txt.length <= 0\n    return false\n  words = txt.split(\" \"\
    )\n  last_char = txt.last\n  word_in_string = \"_\".join(words[0..-2])\n  if last_char\
    \ == word_in_string[-1]\n    return true\n  else\n    return false\nend", "  txt.split(\"\
    \ \").each do |word|\n    word.split(\"\").each do |char|\n      if char == word[word.size-1]\n\
    \        return false\n      end\n    end\n  end\n  return true\nend", "  if txt.length\
    \ > 0\n    txt = txt.slice(-1)\n    \n    if txt.match(/^[a-zA-Z]/) != nil\n \
    \     return true\n    end\n  end\n  return false\nend", "    txt.scan(/./)\n\
    \    return txt[txt.size -1].upcase !~ /[a-z]/\nend", "  return txt.length >=\
    \ 1 and txt.chars.last.upcase && ! txt.chars.last.match?(/\\w/)\nend", "  return\
    \ txt[-1..-1].chars.any? { |char| char =~ /\\w/ }\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nThanks for your answer! But I see that this code doesn't work if\
    \ the last letter is a space or a punctuation mark. I think the function should\
    \ also check for those cases.\n<|/ c |>\n<| c |>\nI made an edit to fix it so\
    \ that it works for spaces and punctuation marks.\n<|/ c |>\n<| c |>\nI think\
    \ you also need some more code to handle an input of `\"apple pi e \"`\n<|/ c\
    \ |>\n<| c |>\nGood catch. I added a check for that case to the answer. I also\
    \ added a link to RubyDoc.\n<|/ c |>\n<| c |>\nWhat about `\"apple pi e \".succ`?\n\
    <|/ c |>\n<| a dscore=1 tags=ruby |>\n<code>\n'apple pi e '.split", "  return\
    \ txt.chars.last.upcase && !txt.chars.any? { |c| c.is_word }\nend", "    if txt.empty?\n\
    \        return false\n    txt[txt.size-1].downcase!\n    txt.chars.all? do |char|\n\
    \        char.upcase != char\n    end\nend\n</code>\n<|/ a |>\n<| c |>\nWhat if\
    \ the string is empty? The `txt.empty?` check would be wrong.\n<|/ c |>\n<| c\
    \ |>\n: I have updated the answer with that check. Thanks\n<|/ c |>\n<| c |>\n\
    I thought the OP wanted the last letter of his string to be a letter instead of\
    \ an _alphabetic character_, but that's probably just me misunderstanding the\
    \ question.\n<|/ c |>\n<| a dscore=3 tags=ruby,ruby-on-rails,regex |>\nI wrote\
    \ this to find out if a string contains a letter:\n<code>", "  re = /\\W$/\n \
    \ return re(txt) == nil\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,string,regex\
    \ |>\nHow about this?\n<code>\nputs \"Enter a string\"\nstr=gets.chomp", "  return\
    \ !!(txt.length > 0 && txt[txt.length-1] =~ /^[a-zA-Z]$/)\nend", "    txt = txt.downcase.strip\n\
    \    if txt == \"\"\n        false\n    end\n    return txt[-1].is_a?(String)\
    \ and txt[-1] =~ /\\w/\nend\n</code>\n<|/ a tags=ruby,arrays,string |>\n<| c |>\n\
    I appreciate the feedback! I've edited my OP to reflect what you've suggested,\
    \ but I'm still getting an error.\n<|/ c |>\n<| a tags=ruby,arrays,string |>\n\
    You could use String#scan:\n<code>\na = \"apple pie apple pie\"\na.scan(/\\w/)\n\
    \  #=> [\"a\", \"p\", \"e\", \"a\", \"p\", \"e\"]\n</code>\nSee String#scan.\n\
    <|/ a dscore=1 |>\n<| c |>\nI appreciate the feedback! I've edited my OP to reflect\
    \ what you've suggested, but I'm still getting an error.\n<|/ c |>\n<| c |>\n\
    , did you copy and paste my code exactly as shown? I've just tested it, and it\
    \ works.\n<|/ c |>\n<| c |>\nYes, I did copy and paste exactly as shown and it\
    \ didn't work. Perhaps it's my end? Do you happen to know why it's failing?\n\
    <|/ c |>\n<| c |>\n, I edited the answer. There were several syntax errors in\
    \ your code. I hope this helps.\n<|/ c |>\n<| c |>\nThanks, it didn't work, but\
    \ I think you've pointed me in the right direction. I've edited my OP to reflect\
    \ the error I'm getting now.\n<|/ c |>\n<| a tags=ruby,arrays,string dscore=1\
    \ |>\n<code>\n'apple pie apple pie'.scan(/\\w/)\n</code>\n<|/ a |>\n<| c |>\n\
    I appreciate the feedback! I've edited my OP to reflect what you've suggested,\
    \ but I'm still getting an error.\n<|/ c |>\n<| a |>\nTry this \n<code>\nputs\
    \ a.scan(/\\w/).join(\" \")\n</code>\n<|/ a dscore=0 tags=ruby,arrays,string |>\n\
    <| c |>\nI appreciate the feedback! I've edited my OP to reflect what you've suggested,\
    \ but I'm still getting an error.\n<|/ c |>\n<| a dscore=0 |>\n<code>\na = \"\
    apple pie apple pie\"\na.split(' ') \n</code>\nwill give you a array [\"apple",
  "  if txt.length == 0\n    false\n  else\n    word = \"\"\n    lastChar = txt.last_char\n\
    \    if lastChar != nil\n      word = txt.upcase\n      word.slice!(lastChar)\n\
    \    end\n    if word != \"\"\n      word.include?(\" \")\n    end\n  end\nend",
  "    word = txt.split(\" \")\n    txt = word[-1]\n    if txt[-1].isalpha() and txt\
    \ not in \"aeiouAEIOU\":\n        return True\n    return False", "  return txt.last()\
    \ =~ /^[a-z]+$/i\nend", "  last_char = txt[txt.length-1]\n  return last_char =~\
    \ /^[a-z]/\nend", "    txt.slice!(-1)\n    (word? txt.slice!(-1)) ? true : false\n\
    end", "  return txt.chars.last.match?(/[A-z]/)\nend", "  txt = txt.downcase\n\
    \  txt_len = txt.length\n  return txt_len > 0 && txt.chars.last.match?(/[[:alpha:]]/)\n\
    end", "  txt = txt.downcase\n  txt = txt.strip unless txt =~ /^\\s*$/\n  txt =\
    \ txt.split if txt =~ /^\\s*$/\n  txt.last.match?(/[[:alpha:]]/)\nend\n</code>\n\
    <|/ a dscore=1 tags=ruby |>\n<| c |>\nThat's a good idea. Now you can get rid\
    \ of the `if txt =~ /^\\s*$/` and use `txt.strip unless txt =~ /^\\s*$/`.\n<|/\
    \ c |>\n<| c |>\n: It depends on your definition of \"space\". For instance, if\
    \ you want to exclude spaces at the end of line, then you have to account for\
    \ that in your test. If you want \"a character that is a letter or a digit\" then\
    \ it's not a big deal to check `/[[:alpha:]]/` anyway.\n<|/ c |>\n<| c |>\n: Yes,\
    \ that's a good point. I'll update my answer to account for this.\n<|/ c |>\n\
    <| a tags=ruby |>\n<code>", "  return !!(txt.length && txt.match(/[a-z]$/i) &&\
    \ !txt.match(/[a-z]\\S*$/i))\nend", "  txt.split.each_with_index.map { |e,i|\n\
    \    e = e.strip\n    if e[e.length - 1] == \" \" || (e[e.length - 1] != \" \"\
    \ && e[e.length - 1] != \" .\")\n      true\n    else\n      false\n    end\n\
    \  }.all? { |b| b == true }\nend\n</code>\n<|/ a tags=ruby,string,regex |>\n<|\
    \ c |>\nNice.  It took me a second to figure out what your method does.\n<|/ c\
    \ |>\n<| c |>\nI agree, this is so much better. But if OP wants to know whether\
    \ last character is a letter, your code is more readable. Also, if OP wants to\
    \ know whether last character is not a letter, he should use `^[a-zA-Z]*$`\n<|/\
    \ c |>\n<| c |>\nThat said, I still think this would have a better complexity\
    \ than using split and strip. I think regex is the right tool for the job.\n<|/\
    \ c |>\n<| c |>\n: I disagree. The complexity of that is O(n\xB2), whereas the\
    \ one I propose is O(n).\n<|/ c |>\n<| c |>\nI see what you mean. Still my suggestion\
    \ is better. :)\n<|/ c |>\n<| a dscore=1 |>\nYou can try this:\n<code>", "   \
    \ txt.strip!\n    letters = txt.split(\" \").map(&:downcase)\n    letters.each\
    \ { |letter| return false if letter.empty? }\n    letters.last.downcase != txt[-1]\n\
    end", "  return txt.downcase.last(1).match?(/[A-Za-z]/) != nil\nend", "  !check_if_last_char_is_a_letter.last_char_of_word_in_string(txt)\
    \ && txt[-1] =~ /\\w/\nend", "  return txt[-1,1] =~ /^[a-zA-Z]$/\nend", "\tword\
    \ = txt.split(\" \")[-1]\n\tletter = txt[-1]\n\treturn (letter == \" \" or letter\
    \ == \"\\n\" or letter == \"\\t\" or letter == \"\\r\" or letter == \"\\a\")\n\
    end", "    \n    # Check if the string length is equal to zero\n    # or if the\
    \ string contains only white spaces\n    if txt.length == 0 || txt =~ /^\\s*$/\n\
    \        return false\n    end", "  # Your code here\n  if txt.empty?\n    false\n\
    \  elsif txt.chars.last != \" \" \n    false\n  else\n    txt.chars.drop(1).all?{|c|\
    \ c.upcase == c}\n  end\nend", "  return false if txt.empty? or txt.size < 2\n\
    \  txt.slice!(-1)\n  txt.gsub!(/([a-z])/, '')\n  txt.downcase!\n  txt.match?(/[a-z]/)\n\
    end", "  if txt.empty?\n    return false\n  txt[txt.size-1].upcase!\n  txt.split.each\
    \ do |word|\n    word.upcase!\n    return true if word.size > 1 && word.slice!(-1)\
    \ == ' '\n  end\n  false\nend", "  txt.upcase!\n  txt.slice!(0,-1)\n  txt.downcase!\n\
    \  if txt !~ /[[:alpha:]]/\n    return false\n  end\n  txt.slice!(-1,0)\n  return\
    \ true\nend", "  if txt.empty?\n    false\n  else\n    chars = txt.upcase.split('\
    \ ')\n    lastchar = chars.last\n    if lastchar.blank?\n      false\n    else\n\
    \      lastchar.downcase != lastchar\n    end\n  end\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nThis returns `false` for two adjacent words whose last character\
    \ is a letter, e.g. \"banana pea\". Also, note the OP wrote \"string\" rather\
    \ than \"text\", which suggests a method might not need to involve word boundaries\
    \ at all.\n<|/ c |>\n<| c |>\nThank you so much for your response and for putting\
    \ in the effort to make your answer. One quick follow up question: why does adding\
    \ `txt.strip` before the `lastchar.downcase != lastchar` make a difference?\n\
    <|/ c |>\n<| c |>\n, `strip` removes all leading and trailing whitespace and newlines.\
    \ If the last character is `'\\n'`, then the final string isn't a word.\n<|/ c\
    \ |>\n<| a tags=ruby |>\nMy contribution to the answers above. I hope it helps\
    \ someone.\n<code>", "    txt.each_char do |char|\n      char = char.downcase\n\
    \      if char.match(/[a-z]/)\n        false\n      else\n        true\n     \
    \ end\n    end\nend\n</code>\nThe second function will determine if a given string\
    \ is a valid word. Valid words are sequences composed of only letters and/or digits.\
    \ Spaces are allowed but are not considered \"letters\" and are not considered\
    \ \"digits\". Here are some examples of valid words:\n<code>", "  txt.chomp!\n\
    \  return txt.length.modulo(10).zero? and not /\\W/ =~ txt\nend\n</code>\n<|/\
    \ a dscore=1 tags=ruby,algorithm,regex |>\n<| c |>\nThanks for the help with the\
    \ code. I don't understand why you added `txt.chomp!`. It doesn't affect the `length`\
    \ attribute of the string object. `txt.chomp!` removes the line break/line feed\
    \ character from the end of the string, so why would it affect the `length` attribute\
    \ of the string? Also, what is `?` in `?\\w?`? Thanks!\n<|/ c |>\n<| c |>\n`txt.chomp!`\
    \ will modify the string object. `txt.length` will return the length of the string\
    \ object. `?\\w?` means match a single non-word character (same as `\\w`). In\
    \ Ruby, strings are immutable, thus `txt.chomp!` will change the string object\
    \ into a new string.\n<|/ c |>\n<| c |>\nThat makes sense. I think I will use\
    \ `/^\\W$/` instead of `/\\W$/` to make it more flexible. I appreciate the help\
    \ and explanation. Thank you!\n<|/ c |>\n<| a tags=ruby,algorithm,regex |>\nHere's\
    \ one more way, using regular expressions:\n<code>", "    char = txt[-1]\n   \
    \ words = txt.split(\" \")\n    for word in words:\n        if not word[-1].isalpha()\
    \ and not word[-1].isdigit():\n            return word[-1].isalpha()\n    return\
    \ True", "  return txt[-1].isalpha() and txt.split(\" \").length>1\nend", "  return\
    \ txt[-1].isalpha() and txt.split(\" \").length != 1\nend", "  txt ? txt[-1] =~\
    \ /^[A-Za-z]$/ && txt.split.last =~ /^[A-Za-z]$/ : false\nend", "  txt.slice!(-1,1)\n\
    \  check_if_last_char_is_a_letter = txt.match(/\\A[a-zA-Z]+\\z/)\n  check_if_last_char_is_a_letter\n\
    end", "    if txt == \"\"\n        return False\n    txt.scan(/./)\n    txt.each_index\
    \ do |i|\n        if txt[i] == \" \" \n            return False\n        end\n\
    \    end\n    if txt.last == \" \" or txt.last == \"\\n\"\n        return False\n\
    \    end\n    txt.last.downcase!\n    return true\nend", "    txt = txt.strip.downcase\n\
    \    txt = txt.chars.last\n    letters = ('A'..'Z').to_a\n    letters << ' '\n\
    \    letters.reverse_each do |letter|\n        if txt =~ /[#{letter}]/\n     \
    \       return false\n        end\n    end\n    return true\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nI did not understand your answer at all. I would like you to\
    \ explain how it works.\n<|/ c |>\n<| c |>\nPlease see my new answer. Your function\
    \ checks the last character of each word is `letter` or not. Now to check all\
    \ words are letter, I have done it by using `map` method on `split` method.\n\
    <|/ c |>\n<| c |>\nNice, thanks for this! I have been trying to do regex for hours,\
    \ can't believe I didn't think of this way! Works perfectly!\n<|/ c |>\n<| c |>\n\
    This is a great solution but I don't think it answers the OP's question. He is\
    \ asking about finding a letter in a string of words (not individual characters).\
    \ Your code seems to just check for the last character in each word which is a\
    \ character (not a word).\n<|/ c |>\n<| a tags=ruby dscore=0 |>\nThe simplest\
    \ way to do this is to test each word in the string one at a time.\n<code>", " \
    \  if txt == \"\"\n      puts \"The input was empty!\"\n   end\n   # Split the\
    \ input into a single array\n   arr = txt.split(\" \").collect\n   # Return true\
    \ if the last element is an alphabetical character and\n   # not a part of a word\n\
    \   return (arr.last =~ /[a-z]$/i).nil?\nend", "    txt.slice!(-1..-1) # remove\
    \ last char\n    txt.slice!(0..-2) # remove last two char\n    txt.slice!(0..-2).downcase\
    \ # convert to lowercase\n    return false if txt.chars.any? { |c| !c.ascii_only?\
    \ } # returns true if any character in txt is not an ascii character\n    return\
    \ true unless txt.slice!(-1..-2) # return false if txt ends with space\n    return\
    \ false if txt.slice!(0..-2).downcase.empty?\n    txt.slice!(0..-2).downcase.include?(\"\
    \ \") # returns true if last char is space or has space\nend\n</cell>\n<code language=julia-1.3>",
  "  if txt != ''\n    txt.scan(/\\w/) do |word|\n      word.empty?\n    end\n  end\n\
    end", "    str = txt.downcase\n    return str[-1,1] != \" \" && str[-1] != \"\
    \ \"\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis is not working. Says that\
    \ `downcase` does not exist for strings. Also, `str[-1,1]` gives an error because\
    \ `str[-1]` does not exist.\n<|/ c |>\n<| c |>\n`downcase` is a method on the\
    \ class String, so you must have written `@text.downcase` instead of `@text.downcase`.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "  return !(txt.scan(/[^a-z]/i).empty?)\n\
    end", "  txt.upcase!\n  if txt.length == 0\n    return false\n  else\n    return\
    \ txt[txt.length-1].match?(/[a-zA-Z]/)\n  end\nend\n</code>\n<|/ a dscore=1 tags=ruby\
    \ |>\n<| a dscore=1 |>\n<code>", "  if txt.empty?\n    false\n  elsif txt.start_with?(\"\
    \ \")\n    false\n  else\n    lastcharidx = txt.rindex(\" \")\n    return txt[-1]\
    \ != \" \" && (txt[lastcharidx - 1] >= 'a' && txt[lastcharidx - 1] <= 'z')\n \
    \ end\nend", "  last_char = txt.slice(-1) # last character of a string\n  words\
    \ = get_words(txt) # words that are separated by space from a sentence\n  return\
    \ words[-1] == last_char and last_char !~ /\\w/\nend\n</code>\n<|/ a |>\n<| c\
    \ |>\nThank you for the response! I really appreciate it. I understand it a bit\
    \ better now, but I cannot for the life of me get it to work. I tried putting\
    \ it all together. Perhaps you can help me understand why?", "  # Set up the variables\n\
    \  # Set \"last_char\" to false if txt is null\n  # Set \"is_a_letter\" to true\
    \ if txt is null\n  # Set \"word_part\" to empty string if txt is null\n  # If\
    \ txt is empty return \"false\"\n  # Set \"word_part\" to first character of txt\
    \ (txt[0])\n  # Set \"is_a_letter\" to true if txt is not empty\n  # If txt is\
    \ not empty and first character is alphabetical\n  # return \"true\"\n  # Else\
    \ if txt is not empty and first character is NOT alphabetical\n  # return \"false\"\
    \n  # Else if txt is not empty but first character is NOT alphabetical\n  # AND\
    \ last character is a letter return \"false\"\n  # Else return \"true\"\n  # Return\
    \ false\n  if txt == nil or txt.empty?\n    return false\n  elsif txt[0] == nil\
    \ or txt[0].empty?\n    return true\n  else\n    word_part = txt[0]\n    is_a_letter\
    \ = word_part.upcase? # if word part is all uppercase or all lowercase\n    is_a_letter\
    \ = true if word_part.length == 1 and word_part.chars.all?(&:alpha?) # If word\
    \ part only has one character and that character is alphabetical\n    is_a_letter\
    \ = true if word_part.length == 1 and word_part.chars.all?(&:upcase?) # If word\
    \ part only has one character and that character is NOT alphabetical\n    is_a_letter\
    \ = true if word_part.length == 1 and word_part.chars.all?(&:downcase?) # If word\
    \ part only has one character and that character is NOT alphabetical\n    is_a_letter\
    \ = true if word_part.length == 1 and word_part.chars.all?(&:capitalized?) # If\
    \ word part only has one character and that character is NOT alphabetical\n  \
    \  is_a_letter = true if word_part.length == 1 and word_part.chars.all?(&:isalpha?)\
    \ # If word part only has one character and that character is alphabetical\n \
    \   is_a_letter = true if word_part.length == 1 and word_part.chars.all?(&:isupper?)\
    \ # If word part only has one character and that character is NOT alphabetical\n\
    \    is_a_letter = true if word_part.length == 1 and word_part.chars.all?(&:islower?)\
    \ # If word part only has one character and that character is NOT alphabetical\n\
    \    is_a_letter = true if word_part.length == 1 and word_part.chars.all?(&:isprint?)\
    \ # If word part only has one character and that character ", "  return txt &&\
    \ txt.length ? txt[txt.length-1].match(/\\W/) === null : false\nend", "  # Write\
    \ your code here.\nend", "  lastchar=txt[txt.length-1]\n  return lastchar.isalpha\
    \ and not (lastchar.isspace or lastchar==\"_\")\nend", "    lastchar = txt[-1]\n\
    \    return lastchar in letters and not check_if_word_start_or_end_of_word(lastchar)",
  "  txt = txt.strip.downcase\n  return true if txt.length > 0 and txt[-1] != \" \"\
    \ and txt[-1] != \"-\"\nend", "  return txt[txt.length-1] =~ /\\w/\nend", "  if\
    \ txt != ''\n    txt = txt.strip\n    txt = txt.strip!\n    txt = txt.downcase\n\
    \    txt = txt.split(' ')\n    txt = txt.last\n    if txt !~ /[a-z]/i\n      return\
    \ false\n    end\n  end\n  return true\nend", "  # Add your code here\n  return\
    \ txt.empty? or txt[-1] =~ /[a-zA-Z]/\nend\n</code>\nIn Ruby, the empty string\
    \ is nil, and nil doesn't have a last character. We need an alternative to nil\
    \ here.\n<code>", "  return txt.to_s.rindex(txt.to_s[-2..-1].upcase) != -1\nend",
  "  last_char = \"\"\n  txt_array = []\n  word_array = txt.split(\" \")\n  for i\
    \ in word_array\n    txt_array.push(i)\n  end\n  for i in txt_array\n    last_char\
    \ = i.last\n  end\n  if last_char.match(/[a-z]/i) && last_char.match(/[^a-z0-9]/)\n\
    \    return false\n  else\n    return true\n  end\nend", "  txt = txt.downcase\n\
    \  if txt.length == 0\n    return false\n  txt.slice!(-1)\n  match = txt.match(/[A-Za-z]+$/)\n\
    \  txt.length.times do\n    txt.slice!(-1)\n    match = txt.match(/[A-Za-z]+$/)\n\
    \    return match != nil\n  end\n  return match != nil\nend", "  last_char = txt[-1]\n\
    \  last_char = last_char.downcase\n  return !last_char.match?(/[[:alpha:]]/)\n\
    end", "  txt.scan(/[a-z]+$/i)\n  \n  return txt.empty?\nend", "  return txt.downcase.chars.last.nil?\
    \ && txt.split.empty?\nend", "  txt = txt.downcase\n  if txt.chars.last.upcase\
    \ != \" \"\n    false\n  else\n    true\n  end\nend", "  txt = txt.strip\n  result\
    \ = txt.chars.last.match?(/[a-z]/i) && !txt.chars.all?{|x| x.match?(/[a-z]/i)}\n\
    \  p result\n  result && p.blank?(txt)\nend", "  txt.chars.last.nil? ? false :\
    \ txt.chars.last.chars.last.downcase =~ /[a-z]/i ? false : true\nend", "  if txt.length\
    \ > 0 && txt[-1] =~ /[[:alpha:]]/ && txt !~ /[[:space:]]/ #&& txt !~ /[[:blank:]]/\n\
    \    puts \"last character is alphabetic and is not part of a word\"\n  else\n\
    \    puts \"last character is alphabetic and is not a part of a word\"\n  end\n\
    end", "  txt.match(/\\S/) == nil ? false : true\nend", "  # Create a variable\
    \ named last_char.\n  last_char = txt[-1]\n  \n  # Return a Boolean value.\n \
    \ return last_char.match /[A-Za-z]$/\nend", "  if txt.length > 0\n    chars =\
    \ txt.to_s.split\n    if chars[0..chars.length-1].to_s.include?(\" \") && chars.last.to_s.include?(\"\
    \ \")\n      return true\n    else\n      return false\n    end\n  end\nend",
  "    if txt.empty?\n      true\n    else\n      char = txt.chars[-1]\n      (char\
    \ =~ /[a-z]/i) != 0 && char != \" \"\n    end\nend", "  txt = txt.downcase\n \
    \ last  = txt.chars.last\n  word  = txt.split(\" \").last\n  return last != nil\
    \ and last.upcase != nil and word.start_with?(last)\nend", "    words = txt.split(\"\
    \ \")\n    letter = words[words.length-1]\n    return letter.length != 1 && letter\
    \ !~ /\\w/\nend", "  # Your code here\n  return true\nend", "  return txt.slice!(-1,\
    \ 1).match?(/[^a-z]/i)\nend", "  txt.downcase!\n  txt.sub!( /\\w$/, \"\" )\n \
    \ txt.empty? ? false : true\nend", "  return txt.last && txt.last.char? && txt.last.chars.last.match?(/[A-Za-z]/)\n\
    end", "  txt.split(\" \").last.chars.all?{ |char| ALPHABETICS.include?(char) }\n\
    end", "    txt = txt.strip\n    return txt[-1].isalpha() and \\\n        (not\
    \ txt.split(\" \").some(lambda t: t[-1].isalpha()))\nend", "  txt.slice!(-1) if\
    \ txt.empty?\n  txt.slice!(-1) if txt.slice!(-1) == \" \" # remove space\n  txt.slice!(-1)\
    \ if txt.slice!(-1) == \"\\n\" # remove newline\n  txt.slice!(-1) if txt.slice!(-1)\
    \ == \"\\r\" # remove newline\n  txt.slice!(-1) if txt.slice!(-1) == \"\\t\" #\
    \ remove tab\n  txt.slice!(-1) if txt.slice!(-1) == \"\\v\" # remove vertical\
    \ tab\n  txt.slice!(-1) if txt.slice!(-1) == \"/\" # remove slash\n  txt.slice!(-1)\
    \ if txt.slice!(-1) == \":\"\n  txt.slice!(-1) if txt.slice!(-1) == \"[\" or txt.slice!(-1)\
    \ == \"]\"\n  txt.slice!(-1) if txt.slice!(-1) == \"'\"\n  txt.slice!(-1) if txt.slice!(-1)\
    \ == \"\\\"\"\n  txt.slice!(-1) if txt.slice!(-1) == \".\"\n  txt.slice!(-1) if\
    \ txt.slice!(-1) == \",\"\n  txt.slice!(-1) if txt.slice!(-1) == \"-\"\n  txt.slice!(-1)\
    \ if txt.slice!(-1) == \":\"\n  txt.slice!(-1) if txt.slice!(-1) == \";\"\n  txt.slice!(-1)\
    \ if txt.slice!(-1) == \"!\"\n  txt.slice!(-1) if txt.slice!(-1) == \"?\"\n  txt.slice!(-1)\
    \ if txt.slice!(-1) == \":\"\n  txt.slice!(-1) if txt.slice!(-1) == \"#\"\n  txt.slice!(-1)\
    \ if txt.slice!(-1) == \"&\"\n  txt.slice!(-1) if txt.slice!(-1) == \"*\"\n  txt.slice!(-1)\
    \ if txt.slice!(-1) == \"^\"\n  txt.slice!(-1) if txt.slice!(-1) == \"#\"\n  txt.slice!(-1)\
    \ if txt.slice!(-1) == \"[\" or txt.slice!(-1) == \"]\"\n  txt.slice!(-1) if txt.slice!(-1)\
    \ == \"'\"\n  txt.slice!(-1) if txt.slice!(-1) == \"\\\"\"\n  txt.slice!(-1) if\
    \ txt.slice!(-1) == \".\"\n  txt.slice!(-1) if txt.slice!(-1) == \",\"\n  txt.slice!(-1)\
    \ if txt.slice!(-1) == \"-\"\n  txt.slice!(-1) if txt.slice!(-1) == \":\"", " \
    \ return txt && txt != ' ' && !(/^[^A-Z]$/).exec(txt)\nend", "  if txt.length\
    \ == 0\n    false\n  elsif txt.last == txt.chars.last\n    true\n  else\n    false\n\
    \  end\nend", "  # Define the local variable\n  last_char = txt.last", "  txt.strip!\n\
    \  txt.sub!(/ $/,\"\") if txt.empty?\n  txt.chars.last.downcase.end_with?(txt.chars.last)\n\
    end", "  txt.each_char {|c| return false unless c.is_a?(String) and c.ends_with?(\"\
    \ \")}\n  true\nend", "    i = txt.rindex(\" \")\n    if i != -1\n        txt\
    \ = txt[0...i]\n    txt.delete!(\" \").upcase!\n    return txt.length != 0\nend",
  "  return txt[txt.length-1].is_a?(String) and !txt[txt.length-1].match?(/\\w+/)\n\
    end", "  word = txt.split\n  if word.length == 0\n    return false\n  lastChar\
    \ = word[word.length - 1]\n  letter = lastChar.downcase\n  word = word.split\n\
    \  word.delete(word.length - 1) unless word.include? letter\n  return lastChar.include?\
    \ letter && !word.include? letter\nend", "  \n  if txt.empty?\n    false\n  else\n\
    \    txt.slice(-1)[0].upcase !~ /\\w$/\n  end\nend\n</code>\nNext, we just need\
    \ to add this method to our helper module. As it stands, your app would now look\
    \ like this:\n<code>", "  return ((txt.chars.last.upcase? && txt !~ /[^[:alpha:]]/)\
    \ \n          || (txt.chars.last.downcase? && txt !~ /[^[:alpha:]]/))\nend\n</code>\n\
    <|/ a dscore=4 |>\n<| a |>\nJust to give another solution: you could use the .end_with?\
    \ method to determine if your string ends with an alphanumeric character:\n<code>\n\
    str = \"applePie\"\nstr.end_with?('a')\n=> true\n</code>\n<|/ a tags=ruby dscore=3\
    \ |>\n<| c |>\nThis is the simplest and most elegant solution, IMHO.\n<|/ c |>\n\
    <| c |>\nThis is the simplest and most elegant solution, IMHO. :)\n<|/ c |>\n\
    <| a |>\nHere's another solution that works in Rails (2.3 or later):\n<code>\n\
    'apple pi e'.match(/\\w+$/)\n</code>\nIt returns nil if the match is not found,\
    \ but returns the MatchData object otherwise.\n<|/ a dscore=3 tags=ruby |>\n<|\
    \ c |>\nAnd if you want it as a boolean value, just use !! on the return value\
    \ of this method, like so:\n!!'apple pi e'.match(/\\w+$/)\n<|/ c |>\n<| c |>\n\
    The downside of this solution is that it only works with strings that end with\
    \ a word character. So, for example, \"applePie\" will return nil.\n<|/ c |>\n\
    <| c |>\nThis solution is still quite nice, as it also works with strings that\
    \ don't end with a word character, or that end with a word character followed\
    \ by a non-word character. +1\n<|/ c |>\n<| c |>\nJust for future readers, this\
    \ regex solution does only work if you have the `/.../` delimiters in your regex.\
    \ `/\\w+$/` works just fine.\n<|/ c |>\n<| a dscore=2 |>\nYou can use the scan\
    \ method of the string\n<code>\nstring.scan(/\\w+$/)\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nI believe the '$' will match at the end of a string.  I believe\
    \ this will match if the string ends with \"apple pie\", but not if it ends with\
    \ \"apple piez\".\n<|/ c |>\n<| c |>\nThe $ anchors the match to the end of the\
    \ string.\n<|/ c |>\n<| a dscore=2 tags=ruby |>\nHere's another solution", " \
    \ txt = txt.to_s.gsub(/\\s+/, \" \").downcase\n  return(txt.length > 0 and\n \
    \        txt[txt.length-1].match /\\A[a-z]/ and\n         !txt.split(\" \").any?{\
    \ |x| x[-1] =~ /\\A[a-z]/ })\nend", "  txt = txt.upcase\n  txt = txt.split", " \
    \ !txt.scan(/[^a-zA-Z]$/).empty?\nend", "    return txt.rscan(/[\\w']+$/) != nil\n\
    end", "  if txt != \"\"\n    if txt[-1] >= \"a\" and txt[-1] <= \"z\"\n      return\
    \ false\n    end\n  end\n  return true\nend", "  if txt.length == 0 || txt ==\
    \ \"\\n\"\n    return false\n  end\n  char = txt.last\n  if char.upcase == \"\
    Z\"\n    return true\n  end\n  return false\nend\n</code>\n<code>", "\tword =\
    \ txt.split(\" \")\n\tlast_char = word[word.length-1]\n\tif last_char.length ==\
    \ 1\n\t\treturn true\n\telse\n\t\treturn false if last_char.include?(\" \") ||\
    \ last_char.include?(\",\")\n\tend\nend", "  txt = txt.chomp\n  txt = txt.downcase\n\
    \  txt = txt.gsub(' ','')\n  letter = txt.last\n  return letter.match(/[A-z]$/)\n\
    end", "  !txt.empty? and txt.chars.last =~ /[A-Za-z]/ and txt.chars.last.empty?\n\
    end", "    txt = txt.downcase\n    return txt && txt.last && txt.match(/[^a-z]+$/)\n\
    end\n</code>\nAnd then just change your has_last_char_is_a_letter test to:\n<code>\n\
    has_last_char_is_a_letter ? check_if_last_char_is_a_letter(txt) : false\n</code>\n\
    <|/ a dscore=1 |>\n<| a |>\nHere is an example using Regexp's =~ operator, matching\
    \ the entire string and assigning the result to either true or false (using an\
    \ inline ternary operator)\n<code>", "  return txt[-1] =~ /[a-zA-Z]/ && txt.split(\"\
    \ \").last !~ /[a-zA-Z]/\nend", "  if txt.empty?\n    false\n  elsif txt.match(/[\\\
    p{L}\\p{N}]+$/)\n    true\n  else\n    false\n  end\nend", "  return txt.empty?\
    \ || txt.chars.last.downcase == A\nend", "  txt.last(1).is_a?(String) && txt.last(1).downcase.split(\"\
    \ \").empty?\nend\n</code>\n<|/ a |>\n<| a dscore=1 tags=ruby |>\n<code>", " \
    \ txt.chars.last.upcase!\n  txt.chars.last.match(/(\\S)$/)\nend", "\ttxt = txt.strip\n\
    \tlast = txt.last\n\tif last == nil or last.size < 1\n\t\treturn false\n\tend\n\
    \treturn last.chars[last.size - 1].downcase =~ /[a-z]/i\nend", "  return txt[-1].isalpha()\
    \ and not txt.rpartition(' ')[0][-1].isalpha()\nend", "    if txt.empty?\n   \
    \     return false\n    txt = txt.downcase\n    txt.slice(txt.length - 1).chars.all?\
    \ { |char| ALPHABETIC_CHARS.include?(char)}\nend", "  if txt.length < 1\n    return\
    \ false\n  else\n    return true\nend\n</code>\n<|/ a tags=ruby,if-statement |>\n\
    <| a tags=ruby,if-statement |>\nAs Ruby is a functional language you can do that\
    \ very simply by using Ruby's regular expressions:\n<code>", "  return txt &&\
    \ txt !~ /\\b[a-z]\\b/\nend", "    txt.include?(txt[txt.size - 1]) && txt.include?(\"\
    \ \") ? true : false\nend", "  return txt.slice(-1).match(/[a-z]/) == nil\nend",
  "  return true if txt[txt.length-1].match(/[a-z]/) == nil else false\nend", "  return\
    \ txt[-1].isalpha && ! txt.split(\" \").any? {|word| word.last.downcase == txt.last.downcase\
    \ }\nend\n</code>\n<|/ a |>\n<| a |>\nFor Ruby 1.8.7, you can also use the built-in\
    \ String#scan method (as of 1.8.7).\n<code>", "  # Write your code here.\n  last_char\
    \ = txt[txt.length-1]\n  word = txt.split(\" \")\n  return ((last_char.match(\"\
    [a-zA-Z]\") != nil) && word.include?(last_char) == nil)\nend\nputs check_if_last_char_is_a_letter.call(\"\
    apple pie\")\nputs check_if_last_char_is_a_letter.call(\"apple pi e\")\nputs check_if_last_char_is_a_letter.call(\"\
    apple pi e \")\nputs check_if_last_char_is_a_letter.call(\"\")", "  return txt\
    \ != '' && txt.last.match?(/[a-z]+/)\nend\n</code>\n<|/ a |>\n<| c |>\nThis is\
    \ good but \"apple pi e\" returns false but \"apple pie \" returns true. Also\
    \ it fails on empty strings. Maybe \"apple pie\" should return false but it returns\
    \ true.\n<|/ c |>\n<| c |>\nYes, I should have mentioned that. Thanks for the\
    \ heads up. I've updated the answer accordingly.\n<|/ c |>\n<| c |>\nThanks for\
    \ the help, but this seems to only work with an actual alphabet. The example you\
    \ provided for \"apple pie\" returns false but returns true for \"apple pi e\"\
    .  Also, \"apple pie\" returns false for empty strings and \"apple pie\" returns\
    \ true for single letters.\n<|/ c |>\n<| a dscore=0 |>\nHere is a quick solution\
    \ I wrote based on answer I gave before. It can handle words with any number of\
    \ whitespaces as well as any number of non-whitespace characters:\n<code>", " \
    \ txt.strip!\n  txt = txt.strip.downcase\n  if txt.empty?\n    false\n  elsif\
    \ txt.slice(-1) != \"z\" && txt.slice(-1) != \"z\" && txt.slice(-1) != \"z\"\n\
    \    true\n  else\n    false\n  end\nend", "  txt = txt.downcase\n  # Get all\
    \ possible characters of the string\n  all_chars = txt.chars.to_a\n  all_chars.delete_if\
    \ {|x| x == ' '}\n  # Get the last character in the string\n  last_char = txt[-1]\n\
    \  # If the last character is a letter\n  return false unless last_char.match?(/[a-z]/i)\n\
    \  all_chars.any? {|x| x == last_char}\nend\n</code>\n<|/ a dscore=1 |>\n<| a\
    \ tags=string,ruby,regex |>\n<code>", "    letters = txt.split(\" \").last\n \
    \   letters.each do |letter|\n        letter = letter.tr(\"a-z\", \"A-Z\")\n \
    \       if letter.empty?\n            return false\n        end\n    end\n   \
    \ return true\nend\n</code>\n<|/ a dscore=1 tags=ruby-on-rails,ruby |>\n<| a tags=ruby-on-rails,ruby\
    \ |>\nIf you have just one word and want to get the last character, this solution\
    \ works:\n<code>", "    if txt.length == 0\n        return false\n    char_at_end\
    \ = txt.last\n    char_at_end_is_a_letter = (char_at_end >= \"a\" && char_at_end\
    \ <= \"z\") || (char_at_end >= \"A\" && char_at_end <= \"Z\") || (char_at_end\
    \ >= \"0\" && char_at_end <= \"9\")\n    string_is_word_ending = (char_at_end_is_a_letter\
    \ && txt.length > 0) || (txt.length == 1 && txt.first == \" \" && txt.length >\
    \ 0)\n    return string_is_word_ending\nend\n</cell>\n<text>\nWe will now create\
    \ the function that uses the above functions to split the input text into sentences\
    \ and then filter out sentences that end with punctuation.", "  return txt.slice!(-1,1).blank?\
    \ and txt.slice!(-1).match? /\\w/\nend", "  txt.slice!(-1) # ignore last character\
    \ in txt\n  last_char = txt.slice(-1)\n  return last_char.upcase && ! is_part_of_a_word(last_char)\n\
    end", "  last_char_index = txt.length - 1\n  return txt.chars[last_char_index].downcase\
    \ != '\\W'\nend", "  txt.gsub(/[^a-zA-Z ]$/, '')\n  txt.size > 0 and txt.last\
    \ and txt.last.match(\"[a-zA-Z]\")\nend", "  txt.slice!(txt.length-1)\n  txt.slice!(0,txt.length-1)\n\
    \  txt.slice!(0,txt.length-1).downcase!\n  txt.slice!(0..-2) if txt.length < 4\n\
    \  txt.slice!(0..-2).downcase!\n  txt.slice!(0..-1) if txt.length < 4\n  true\n\
    end", "  txt = txt.split.join\n  txt[-1] = txt[-1][-1]\n  return txt.split =~\
    \ /\\w/\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis is actually pretty good,\
    \ but there's a bug - the regex `/\\w/` will match all Unicode word characters\
    \ (the [official spec](http://www.unicode.org/reports/tr44/tr44-6.html#General_Category_Values)\
    \ says \"Letter, Mark, Number, Punct\"), so this won't be perfect.\n<|/ c |>\n\
    <| c |>\n: thanks. I didn't realize that it was important that unicode characters\
    \ be represented as `\\w`.\n<|/ c |>\n<| a |>\nI recently came up with a solution\
    \ that utilizes the fact that regular expressions allow for an optional non-capturing\
    \ group and a negative look-ahead assertion to avoid a match if a non-alphanumeric\
    \ character follows our match.\n<code>", '    return txt[-1].isalpha() and txt[-1]
    not in "aeiou"', "  check_last_char_is_a_letter.call(txt, \"\")\nend", "  txt\
    \ =~ /^[a-zA-Z]+$/\nend\n</code>\n<|/ a |>\n<| a dscore=2 |>\nHere is a nice ruby\
    \ solution:\n<code>", "  !txt.empty? and txt[txt.length-1] =~ /^[a-zA-Z]+$/\n\
    end\n</code>\n<|/ a dscore=0 tags=ruby-on-rails-3.2,ruby-on-rails-3,ruby,ruby-on-rails\
    \ |>\n<| a dscore=0 tags=ruby-on-rails-3.2,ruby-on-rails-3,ruby,ruby-on-rails\
    \ |>\nAs you know there is a way to implement that using Rails ActiveSupport methods.\n\
    <code>", "    txt = txt.strip\n    if txt.length > 0\n        txt = txt[-1]\n\
    \        return ALPHABET[txt]\n    else\n        return false\n    end\nend",
  "  if txt.empty?\n    false\n  elsif txt[-1] =~ /\\w$/\n    false\n  else\n    true\n\
    \  end\nend", "  txt.split(\" \").last.match(/[A-Za-z]$/)\nend", "  !txt.include?(\"\
    \ \") && txt.include?(\" .-\") ? false : true\nend", "  txt = txt.downcase\n \
    \ txt = txt.delete(\"\\n\")\n  txt = txt.gsub(/\\s+/, \" \")\n  txt = txt.gsub(/[a-z]$/,\
    \ \"\")\n  return txt != \"\"\nend", "  word = txt.split(\" \")\n  last_char =\
    \ word[word.length-1]\n  if last_char.length != 1 then\n    return false\n  end\n\
    \  last_char = last_char.charAt(0)\n  if last_char !~ /^[a-zA-Z]$/ then\n    return\
    \ false\n  end\n  return true\nend", "    i = txt.length - 1\n    while i >= 0\n\
    \        char = txt[i]\n        if char.upcase == false && char.downcase == false\n\
    \            return false\n        i -= 1\n    return true\nend", "  return txt[-1]\
    \ == \" \" && txt.split(\" \").last.match(/\\W/)\nend", "  txt.empty? ? false\
    \ : txt.last.match(/[a-z]/) != nil\nend\n</code>\n<|/ a |>\n<| a |>\nI did a function\
    \ that works for me\n<code>", "    return txt[-1].isalpha() and txt[-len(txt):].isspace()\n\
    end", "  return txt.slice(-1 .. -1).match(\"[a-zA-Z]+\").nil? ? false : true\n\
    end", "    return txt[-1].isalpha() and not txt[-1].isspace()\nend", "  return\
    \ txt.slice!(-1, 1).match(/\\A[a-zA-Z]$/) == nil\nend\n</code>\nNow you can use\
    \ it in your method:\n<code>", "  if txt.empty?\n    return false\n  txt.slice!(-1)\n\
    \  chars = txt.downcase.split(//).map(&:downcase)\n  chars.each do |char|\n  \
    \  if char =~ /[a-zA-Z]$/\n      return false\n    end\n  end\n  true\nend", " \
    \ if txt.length == 0\n    return false\n  word_array = txt.split(\" \").last()\n\
    \  return word_array.ends_with?(txt.chars.last) && word_array.count?(:letter)\n\
    end", "  str1 = txt.split\n  if str1.length == 0 \n    return false\n  last_char\
    \ = str1.last\n  str2 = last_char.split\n  if str2.length == 0 \n    return false\n\
    \  last_char = str2.last\n  str3 = last_char.split\n  if str3.length == 0 \n \
    \   return false\n  return true\nend\n</cell>\n<code language=julia-0.5>\ncheck_if_last_char_is_a_letter.call(\"\
    apple pie\")\n</cell>\n<text>\n4.5 Write a function that returns a boolean value\
    \ indicating if the last character of a given string is a numeric character (0\
    \ through 9).\nExample: \n>>> is_last_char_is_a_number.call(\"apple pie\")\nfalse\n\
    >>> is_last_char_is_a_number.call(\"apple pi e\")\ntrue\n>>> is_last_char_is_a_number.call(\"\
    apple pi e \")\nfalse\n>>> is_last_char_is_a_number.call(\"\")\nfalse\n</text>\n\
    <code language=julia-0.5>\nis_last_char_is_a_number = function(txt)\n  str1 =\
    \ txt.split\n  if str1.length == 0 \n    return false\n  last_char = str1.last\n\
    \  str2 = last_char.split\n  if str2.length == 0 \n    return false\n  last_char\
    \ = str2.last\n  str3 = last_char.split\n  if str3.length == 0 \n    return false\n\
    \  str4 = last_char.split\n  if str4.length == 0 \n    return false\n  return\
    \ true\nend\n</cell>\n<code language=julia-0.5>\nis_last_char_is_a_number.call(\"\
    apple pie\")\n</cell>\n<text>\n4.6 Write a function that takes a string as input\
    \ and returns a string with the last character removed if that last character\
    \ is a vowel (A, E, I, O, U), and a substring containing the first letter of each\
    \ non-vowel followed by a vowel (B, C, D, F, G, H, J, K, L, M, N, P, Q, R, S,\
    \ T, V, W, X, Y, Z) otherwise.\nNote: \"vowel\" is a group of characters separated\
    \ by space.\nExamples:\n>>> vowel_last_char(\"apple pie\")\n\"aple ie\"\n>>> vowel_last_char(\"\
    apple pi e \")\n\"apple ie \"\n>>> vowel_last_char(\"apple pi e \")\n\"apple ie\
    \ \"\n>>> vowel_last_char(\"apple pi\")\n\"apple p\"\n>>> vowel_last_char(\"apple\"\
    )\n\"aer\"\n>>> vowel_last_char(\"apple pie\")\n\"aple ie", "    if !txt\n   \
    \     return false\n    word_array=txt.split(\" \")\n    word_array.pop.each {|w|\
    \ return true if w.match(/^[A-Za-z]+$/)}\n    return false\nend", "  return !txt\
    \ ||\n    txt.length == 0 || \n    txt.slice(-1,1).upcase =~ /\\w/ \nend", " \
    \ txt.downcase!\n  txt = txt.split(\" \").last\n  if txt.blank?\n    false\n \
    \ else\n    !is_letter(txt.last) && !is_number(txt.last)\n  end\nend\n</code>\n\
    This test is now complete, however some cases are still missing from it (such\
    \ as \"applepie e\" and the empty string).\nAs you noticed, I am not very proud\
    \ of how this code looks :-) The last part that deals with empty string and multiple\
    \ words is not very elegant and probably there are some edge cases that I am missing\
    \ (like what happens if I do check_if_last_char_is_a_letter.call(\"apple pie e\
    \ p\").\nOne way to solve this would be to add a method is_word_end that would\
    \ return true if my last letter was a word boundary and false otherwise. Something\
    \ like this:\n<code>", "  # Write your code here\n  if txt.length == 0 \n    return\
    \ false\n  letter = txt[txt.length - 1]\n  return !letter.isalpha?\nend", "  txt.include?\
    \ txt[-1] && txt[-1] =~ /\\W/\nend", "    txt = txt.strip\n    last_char = txt.chars.last\n\
    \    return last_char =~ /^[a-z]$/ and not last_char.match(/[ ]/)\nend", "  if\
    \ txt[-1] == \" \" and txt[-1] != \" \" and txt[-1] != \"\"\n    false\n  end\n\
    end", "    txt.blank?\n    if txt.length > 0 and txt[txt.length-1].upcase == \"\
    A\"\n        return true\n    else\n        return false\n    end\nend\n</code>\n\
    <code>", "  txt.chars.last && txt.chars.last.upcase && !txt.chars.last.match?(/\\\
    w/)\nend", "  return !(txt.empty? || !txt.chars.last || txt.chars.last.downcase\
    \ =~ /[[:alpha:]]/)\nend\n</code>\n<|/ a |>\n<| c |>\nNice solution! Just to clarify:\
    \ the regex checks if the last character is a letter (`[[:alpha:]]`), not if the\
    \ last character is a word (`[[:alpha:]]` includes `[:alnum:]`), and the `!` negates\
    \ the return value (which is `nil` if the last character is not a letter, and\
    \ `!nil` evaluates to `true`).\n<|/ c |>\n<| c |>\nThank you, this is much cleaner\
    \ and clearer than the accepted answer.\n<|/ c |>\n<| a tags=string,ruby dscore=3\
    \ |>\nI'd go with:\n<code>\n\"apple pie\".scan(/\\b\\w+/).last # => \"pie\"\n\"\
    apple pi e\".scan(/\\b\\w+/).last # => \"pi\"\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ is neater than my solution; I didn't realize that `scan` returned a collection\
    \ of the last matches in a string. +1.\n<|/ c |>\n<| c |>\n- You might want to\
    \ mention that the \\b makes the word boundary match on the space characters.\
    \ Otherwise, `\"Apple pie\".scan(/\\b\\w+/)` will return an array with one element\
    \ (\"Apple\"). While this could be a problem for other situations, for \"Apple\
    \ pie\" it won't be a problem.\n<|/ c |>\n<| c |>\nI think that's a good point,\
    \ and I agree that `\"Apple pie\".scan(/\\b\\w+/).last` would return `\"apple\"\
    `. I suppose it depends on what OP wants. OP didn't specify if `\"Apple pie\"\
    ` should return `\"pie\"`, `\"pie\"` in the string, or `nil`. It might also be\
    \ a good idea to use `\\w+` instead of `\\S+` to prevent from matching the space\
    \ character. Though I think in this case `\"Apple pie\".scan(/\\b\\w+/).last`\
    \ would be better since it returns `\"pie\"` as requested.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>", "    txt = txt.split(\" \")\n    txt.each do |word|\n        if\
    \ word[-1] != word[0..-1].chars.last\n            return false\n        end\n\
    \    end\n    return true\nend", "  txt = txt.strip\n  txt.strip!\n  return txt[-1]\
    \ == \" \"\nend", "  # Complete this function\n  return true\nend", "    # Your\
    \ code here\n    return txt[-1].isalpha() and txt[-1] not in [' ', '\\n']\n</cell>\n\
    <text>\n3.3 Exercise 3\nNow implement the function check_if_last_char_is_a_word,\
    \ which returns True if we see a word with trailing whitespace.", "    txt.each\
    \ do |char|\n        return false if char.upcase == char\n    end\n    return\
    \ true\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby |>\nAnother solution\
    \ is to use look-behind for checking the last character of a string.\n<code>",
  "  if txt.empty?\n    false\n  elsif txt[-1] =~ /[a-zA-Z]/ && !txt.match(/[a-z A-Z]/)\n\
    \    true\n  else\n    false\n  end\nend", "  return txt.chars.last && txt.chars.last.upcase\
    \ && !txt.chars.last.downcase && txt.chars.last != ' '\nend", "    txt !~ /^[[:alpha:]]+$/\n\
    end", "  if txt.empty?\n    false\n  else\n    txt[-1].isalnum?\n  end\nend\n\
    </code>\n<|/ a |>\n<| c |>\n`txt[-1].isalnum?`\n<|/ c |>\n<| a tags=ruby dscore=0\
    \ |>\nIf you like one-liners, you can do this:\n<code>\n'apple pie' =~ /^[a-z]+$/\n\
    </code>\n<|/ a |>\n<| a tags=ruby dscore=0 |>\nThis is my take on the problem:\n\
    <code>", "  if txt[-1] == \" \"\n  then false\n  else true\n  end\nend", "  !txt.empty?\
    \ and txt.chars.last.match?(/[a-z]/i) and\n        !txt.chars.last.match?(/\\\
    w$/i)\nend\n  ", "    if txt.length > 0\n        txt = txt.downcase\n        if\
    \ txt.length > 0\n            if txt.last == \"a\" || txt.last == \"e\" || txt.last\
    \ == \"i\" || txt.last == \"o\" || txt.last == \"u\"\n                true\n \
    \           else\n                false\n            end\n        else\n     \
    \       false\n        end\n    else\n        false\n    end\nend", "   if txt.empty?\n\
    \      return false\n   end", "  txt = txt.downcase\n  txt_last_char = txt.slice(-1)\
    \ #last char\n  txt_last_char_is_a_letter = (txt_last_char.match(/[a-z]/i) !=\
    \ nil)\n  if txt_last_char_is_a_letter \n    false\n  else\n    true\n  end\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 tags=ruby,string |>\nRuby string\
    \ split method accepts regex as a parameter so\n<code>\ns = \"Hello and welcome\
    \ to Stackoverflow\"\ns.split( /[a-z]/ ) # => [\"Hello\", \"and\", \"welcome\"\
    , \"to\", \"Stackoverflow\"]\n</code>\n<|/ a |>\n<| c |>\nI like this but this\
    \ doesn't take into account punctuation\n<|/ c |>\n<| c |>\nI know, I was just\
    \ answering OPs question. `s.split( /[a-z,.-]/ )`\n<|/ c |>\n<| c |>\nI see. But\
    \ wouldn't that include punctuation? I'm just thinking out loud here :)\n<|/ c\
    \ |>\n<| c |>\nWell it doesnt take into account punctuation but `s.split( /[a-z,.-]/\
    \ )` will separate all characters. You can add punctuation inside the brackets\
    \ `[]`\n<|/ c |>\n<| c |>\nIt would be `/[a-z,.-]/`.  Note the regex delimiters\
    \ are `/`.\n<|/ c |>\n<| a |>\nHow about this?\n<code>", "  return false if txt.empty?\
    \ || txt.empty? || (txt.last =~ /[^A-Za-z]/ && !txt.include?(\" \")) || txt.include?(\"\
    \ \") || txt.empty? || txt.empty?\n  true\nend\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a tags=ruby-on-rails,validation,activerecord |>\nI used a combination of the\
    \ two answers above. My validation looked something like this:\n<code>\nvalidates\
    \ :title, :presence => true, :length => {:maximum => 250, :message => \"Maximum\
    \ length is 250 characters.\"} unless allow_nil\nvalidates :title, uniqueness:\
    \ true unless allow_nil\nvalidates :title, presence: true unless allow_nil\nvalidates\
    \ :title, length: { maximum: 250 } unless allow_nil\n</code>\nThen I made a custom\
    \ method called allow_nil, which returned true or false depending on whether or\
    \ not I wanted nil to be allowed (or not)\n<code>", "  txt.slice!(-1) if txt.length\
    \ == 0\n  txt.length >= 1 ? txt.slice!(-1) == ' ' : false\nend", "  txt.rstrip.downcase!\n\
    \  word = (txt.split.last).split.join\n  case word\n  when 'a', 'b', 'c', 'd',\
    \ 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n        'n', 'o', 'p', 'q', 'r',\
    \ 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'\n  then false\n  else true\n  end\nend\n\
    </code>\n<|/ a tags=ruby dscore=1 |>\n<| a tags=ruby |>\nHere is a solution that\
    \ is very similar to one's, however it uses Enumerable#any?:\n<code>", "  !(txt.length\
    \ == 0 && txt.chars.last.is_a?(String))\nend", "  txt.empty? || (txt.chars.last\
    \ !~ /[a-zA-Z]$/)\nend", "  # If txt is an empty string, return False\n  return\
    \ false if txt.empty? or txt.count == 0\n  # Initialize last_char to an empty\
    \ string\n  last_char = String.new\n  txt += \" \"\n  # If the last character\
    \ is a letter or number, return True\n  # Otherwise, return False\n  txt[txt.length-1].downcase!\n\
    \  txt[txt.length-1].upcase!\n  return(true unless last_char.include?(txt[txt.length-1]))\n\
    end", "  lastchar = txt.charAt(txt.length - 1)\n  if lastchar.matches(\"[a-zA-Z]\"\
    )\n  then\n    false\n  else\n    true\n  end\nend", "  txt.upcase.scan(/\\w$/).empty?\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
