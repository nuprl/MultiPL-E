name: HumanEval_19_sort_numbers
language: rb
prompt: "# Input is a space-delimited string of numberals from 'zero' to 'nine'.\n\
  # Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven',\
  \ 'eight' and 'nine'.\n# Return the string with numbers sorted from smallest to\
  \ largest\n# >>> sort_numbers.call(\"three one five\")\n# \"one three five\"\ndef\
  \ sort_numbers(numbers)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_numbers\n\
  \    candidate = method(:sort_numbers)\n    assert_equal(\"\", candidate.call(\"\
  \"))\n    assert_equal(\"three\", candidate.call(\"three\"))\n    assert_equal(\"\
  three five nine\", candidate.call(\"three five nine\"))\n    assert_equal(\"zero\
  \ four five seven eight nine\", candidate.call(\"five zero four seven nine eight\"\
  ))\n    assert_equal(\"zero one two three four five six\", candidate.call(\"six\
  \ five four three two one zero\"))\n  end\nend\n"
completions: ["  nums.each do |num|\n    num = num.to_s.split(' ').sort\n    num.each\
    \ do |num|\n      puts \"#{num} \"\n    end\n  end\nend\n</code>\n<|/ q tags=ruby,recursion\
    \ dscore=0 |>\n<| c |>\nCan you show what your code is currently doing? I feel\
    \ like it would help illustrate what you are trying to do.\n<|/ c |>\n<| c |>\n\
    What is `nums` ?\n<|/ c |>\n<| c |>\nIf this is homework, please add the homework\
    \ tag.\n<|/ c |>\n<| c |>\nsorry about that. I added my code in the description\
    \ and a little explanation. Thanks again!\n<|/ c |>\n<| c |>\nNo no no. I wasn't\
    \ trying to get you to add `homework`. I was trying to figure out what you were\
    \ doing in your code. I've added an answer below to hopefully explain it better.\n\
    <|/ c |>\n<| a dscore=1 |>\nThis is more of a logic question than a Ruby question.\
    \ You're looking for a way to use recursion and pass parameters to your method\
    \ in the manner you described. Here's a pseudo-code of what you could do to help\
    \ you understand.\n<code>", "  numbers = numbers.split(' ') #Split input numbers\
    \ into an array\n  numbers = numbers.map { |x| x.to_i } #Convert each number into\
    \ an integer\n  numbers = numbers.sort_by { |n| n } #Sort the numbers based on\
    \ the integers\n  numbers.join(' ') #Join the sorted numbers back into a string\n\
    end\n</code>\n<|/ a dscore=0 tags=arrays,ruby,sorting |>\n<| a dscore=0 tags=arrays,ruby,sorting\
    \ |>\n<code>", "  numbers_array = numbers.split(' ')\n  numbers_array.sort!\n\
    \  return numbers_array.join(' ')\nend", "  numbers.to_s.split\n  numbers.sort.join\n\
    end", "  sorted_numbers = numbers.split(' ')\n  sorted_numbers.sort!\n  sorted_numbers.join('\
    \ ')\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby |>\nA little more compact:\
    \ \n<code>", "  numbers.split(' ').sort_by { |x| x.to_i }.join(\" \")\nend", " \
    \ numbers.split(\" \").sort.join(\" \")\nend\n</code>\n<|/ a tags=ruby |>\n<|\
    \ c |>\nIn some cases, such as \"four two five six seven\" this method fails to\
    \ give \"six seven four two five\"\n<|/ c |>\n<| a tags=ruby |>\nUsing \"String#split\"\
    \ and reverse sort:\n<code>", "  numbers.split(\" \").reverse.sort.join\nend",
  "    words = numbers.strip.split(' ')\n    words = words.map{|word| word.to_i}\n\
    \    words.sort!{|a,b| a <=> b}\n    words.join(' ')\nend", "  numbers.split.sort.join\
    \ ' '\nend", "  numbers = numbers.split(' ')\n  numbers.each { |n| numbers.delete(n)\
    \ if n =~ /^\\d+$/ }\n  numbers.sort!\n  numbers.join(' ')\nend", "  if numbers\
    \ == nil\n    return nil\n  elsif numbers.strip.empty?\n    return nil\n  end",
  "  numbers.split(\" \").map{|i| i[0]}.sort.join(\" \")\nend", "  numbers = numbers.split(\"\
    \ \")\n  numbers.sort!\n  return numbers.join(\" \")\nend", "  numbers = numbers.split\
    \ \" \"\n  numbers = numbers.map {|number| number.to_i}\n  numbers.sort.join \"\
    \ \"\nend", "  numbers.split(\" \").sort.join(\" \")\nend\n</code>\n<|/ a |>\n\
    <| a dscore=0 |>\n<code>", "  numbers = numbers.to_s.split\n  numbers = numbers.select\
    \ do |number|\n    number.to_i == 0 ||\n      number.to_i == 1 ||\n      number.to_i\
    \ == 2 ||\n      number.to_i == 3 ||\n      number.to_i == 4 ||\n      number.to_i\
    \ == 5 ||\n      number.to_i == 6 ||\n      number.to_i == 7 ||\n      number.to_i\
    \ == 8 ||\n      number.to_i == 9\n  end\n  numbers.join(\" \")\nend\n</code>\n\
    <|/ a |>\n<| a tags=string,ruby dscore=1 |>\nHere's a solution that sorts numbers\
    \ using a sort function. It assumes all the numbers are single-digit. \n<code>\n\
    sort_numbers =\n  lambda do |str|\n    str.split(' ').sort_by{|i| i.to_i}.join(\"\
    \ \")\n  end", "  # Split string into array on space\n  numbers_array = numbers.split('\
    \ ')\n  # Sort the array (default sort is alphabetical order)\n  numbers_array.sort\n\
    \  # Join array back into a string\n  numbers.join(\" \")\nend", "  sorted_numbers\
    \ = \"\"\n  numbers = numbers.split(\" \")\n  numbers.each do |n|\n    n = n.to_i\n\
    \    if n > 0\n      sorted_numbers = sorted_numbers + \" \" + n.to_s\n    end\n\
    \  end\n  sorted_numbers = sorted_numbers[0, numbers.size - 1]\n  return sorted_numbers\n\
    end", "  number_string = ''\n  numbers.split(\" \").each do |num|\n    unless\
    \ num.match /^(zero|one|two|three|four|five|six|seven|eight|nine)/\n      raise\
    \ ArgumentError, \"invalid number, #{num}, please use a series of numbers or a\
    \ string of numbers beginning with 'zero', 'one', 'two', 'three', 'four', 'five',\
    \ 'six', 'seven', 'eight' or 'nine'.\"\n    end\n    number_string << num\n  end\n\
    \  number_string.sort!\n  number_string.join(' ')\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| a tags=ruby |>\n<code>\nnumbers = \"two nine three four five six seven\
    \ eight nine\".split\nnumbers.reject{|n| n.match? /[nse]$/ }.join(\" \").split\n\
    </code>\nThis should work for any string containing only digits and nine-digit\
    \ strings.\n<|/ a dscore=0 |>\n<| c |>\n`join` will remove all characters that\
    \ do not match any of the supplied regular expressions. `split` will split on\
    \ any string that matches the regular expression. It doesn't matter that they\
    \ have different meanings because both match the same thing.\n<|/ c |>\n<| c |>\n\
    Yes, but `split` will also split on strings that match the regexp, whereas `join`\
    \ will only remove non-matching items. So in any case, the resulting array will\
    \ end up with the same elements. Also, `match?` is a method that will return true\
    \ if a string matches the supplied regexp, whereas `=~` will return -1 if there\
    \ is no match (which would have to be tested for `nil` before being able to use\
    \ `split`). See http://www.ruby-doc.org/core-1.9.3/String.html#method-i-match-3F\n\
    <|/ c |>\n<| c |>\n`=~` is the same as `match?`. `split` will always split on\
    \ strings that match the regexp.\n<|/ c |>\n<| c |>\nAh, that's good to know.\
    \ I've edited my answer to remove the use of match? since =~ does the same thing.\n\
    <|/ c |>\n<| a dscore=0 |>\nI like Ben's answer but if you were doing this as\
    \ a learning exercise (I highly doubt it) you could also do this:\n<code>", " \
    \ numbers = numbers.split(\" \")\n  numbers.sort!\n  numbers.join(\", \")\nend\n\
    </code>\nThis takes any string as input, splits it into an array and sorts it,\
    \ then joins it back together again.\nAs such, I can't see a reason for this function\
    \ to return nil. Perhaps there is another function inside of it that is returning\
    \ nil or perhaps there is another piece of code inside of it that returns a nil\
    \ value that is then being passed back. \nYou can put a debugger statement in\
    \ there to find out exactly what line it is failing on\n<|/ a |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\nA function should return some value if it is not void. Your function should\
    \ look like:\n<code>", "  return numbers[0...(numbers.count(' '))].join(' ')\n\
    end\n</cell>\n<cell>", "  numbers = numbers.split(' ')", "  numbers = numbers.split(\"\
    \ \")\n  numbers.sort!\n  return numbers.join(\", \")\nend", "  numbers.split('\
    \ ').sort_by { |a| a.to_i }.join(' ')\nend", "  numbers = numbers.gsub(/[^0-9]/,\
    \ \"\").split(\" \").sort\n  numbers = numbers.join(\" \")\nend", "  if numbers\
    \ == ''\n    ''\n  else\n    numbers.scan(/[0-9]/).sort!\n    numbers.to_s\n \
    \ end\nend", "    numbers = numbers.to_s.split\n    numbers.sort!", "  numbers.split(\"\
    \ \").sort.join(\" \")\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\n`split` returns\
    \ an array and `sort` returns an array, but they have nothing in common.\n<|/\
    \ c |>\n<| c |>\nThis doesn't work for strings that aren't all numbers. `sort_numbers(\"\
    two six two\")` returns `\"two six two\"`.\n<|/ c |>\n<| c |>\nIt will also return\
    \ `nil` if passed an empty string.\n<|/ c |>\n<| c |>\nIt doesn't work for strings\
    \ that aren't all numbers. Try `sort_numbers(\"one two three\")` :)\n<|/ c |>\n\
    <| c |>\nThe first two comments were all correct, but since I posted this answer\
    \ I realized that \"numbers\" is not defined in the function. That means it could\
    \ either be passed in as a param or hard coded in the function. Which is what\
    \ I meant by my comment about \"numbers\" not being a \"number\". It's just a\
    \ string of \"numbers\", not \"number\" type. This makes the algorithm completely\
    \ valid for all sorts of strings. And it solves the problem I was trying to solve\
    \ for me that I had in the first place.\n<|/ c |>\n<| a dscore=4 |>\nHere is a\
    \ ruby version which works for any number of digits separated by spaces:\n<code>",
  "  numbers = numbers.split(' ')\n  numbers.map { |number| number.to_i }\n  numbers.sort_by!(&:to_i)\n\
    \  numbers.map(&:to_s).join(\" \")\nend\n</code>\nThe code above works, but I\
    \ do not think it is very elegant. I also doubt that it scales well. There must\
    \ be a better way, and I hope that someone with more experience will show me how.\
    \ Thanks!\n<|/ q |>\n<| c |>\nI don\u2019t understand. Is your input a string,\
    \ or a list? Your example is passing in a string, but your function doesn\u2019\
    t expect that to be the case.\n<|/ c |>\n<| c |>\nThe input is a string, but I\
    \ want to convert each element in the string to an integer, sort it, and then\
    \ output it back out as a string.\n<|/ c |>\n<| a dscore=2 tags=ruby,sorting,string\
    \ |>\nThe way I see it, you have two options. First, you could pass in a regular\
    \ expression pattern that matches the numbers you want to sort into sort_numbers:\n\
    <code>", "  numbers.split(\" \").sort.join(\" \")\nend\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nJust a quick heads up, it appears that Ruby has a version of sort()\
    \ that is \"stable\", meaning that it returns the same order each time it is called.",
  "  # split the list into strings\n  numbers_array = numbers.split(\" \")\n  # convert\
    \ the string list to an array\n  numbers_array = getArray(numbers_array)\n  #\
    \ sort the array\n  numbers_array.sort", "  numbers.split(\".\").sort_by do |number|\n\
    \    number.to_i\n  end.join('.')\nend\n</code>\n<|/ a tags=ruby,function |>\n\
    <| a dscore=2 |>\n<code>", "  numbers.to_s.split.sort_by {|n| n.to_i }.reverse.join\n\
    end", "  \n  choices = %w{ zero one two three four five six seven eight nine }\n\
    \  numbers.gsub!(/[^#{choices}]/, '')\n  numbers = numbers.split(' ').sort_by{|n|\
    \ choices.index(n.to_s.downcase)}\n  numbers.join(' ')\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nI like it. Just change `sort_by` to `sort_by!` and it can be done\
    \ even faster\n<|/ c |>\n<| c |>\n, you're right. I didn't think to add `!` after\
    \ the `sort_by`. I'll update my answer.\n<|/ c |>\n<| c |>\n, thanks for the explanation.\
    \ I thought that `sort_by` was sorting, not changing it. But it seems that it\
    \ is.\n<|/ c |>\n<| c |>\n, ah, yeah. That makes sense. You have to think about\
    \ how `sort_by` and `sort` work. `sort_by` returns a new array, and `sort` changes\
    \ the array in place by sorting.\n<|/ c |>\n<| c |>\n, I've added an explanation\
    \ in my answer. I hope that helps.\n<|/ c |>\n<| a tags=ruby |>\nHere's another\
    \ solution, if you don't care about keeping track of the original order:\n<code>",
  "    numbers = numbers.to_s\n    numbers.split(' ').sort!\n    return numbers\n\
    end", "  numbers.split(\" \").map{|n| n.to_i }.sort\nend\n</code>\n<|/ a dscore=1\
    \ tags=string,ruby |>\n<| a tags=string,ruby |>\nA more generic solution:\n<code>",
  "  numbers = numbers.split(' ')\n  numbers.sort!\n  numbers = numbers.join(' ')\n\
    \  return numbers\nend", "\tnumbers.downcase!\n\tnumbers.split(\" \").sort!\n\t\
    numbers.reverse!\n\tnumbers.join(\" \")\nend\n</code>\n<|/ a dscore=5 |>\n<| c\
    \ |>\nYou might want to add a `.reverse` at the end because this will leave the\
    \ original array intact and just reorder the array with the new order.\n<|/ c\
    \ |>\n<| c |>\nYou can just use `sort_numbers!`, no need for the `call` method.\
    \ Also, `sort_numbers` is just an alias for `sort_numbers!`.\n<|/ c |>\n<| c |>\n\
    , good point about sort_numbers!. I'll update the answer.\n<|/ c |>\n<| c |>\n\
    \"The 'call' method is actually part of the ActiveSupport module\" <-- What do\
    \ you mean by that? Can you provide an example of how to use it?\n<|/ c |>\n<|\
    \ c |>\nSorry, I meant \"the 'call' method is a method of the String class in\
    \ ruby\". So it's in the String class in Ruby. Maybe I should say that the 'call'\
    \ method is part of the String class because you're calling it on the String class?\n\
    <|/ c |>\n<| a tags=arrays,ruby |>\nRuby 2.0 introduces sort!, which is equivalent\
    \ to the following code:\n<code>\n arr = ['one', 'two', 'three']\n arr.sort! {|x,\
    \ y| x.to_i <=> y.to_i}\n</code>\nSee http://blog.grayproductions.net/articles/ruby_sorting\n\
    <|/ a dscore=5 |>\n<| c |>\nThis is the best answer.\n<|/ c |>\n<| c |>\n`sort!`\
    \ does not guarantee stable sorting.\n<|/ c |>\n<| c |>\nNote that `sort!` doesn't\
    \ work on symbols so this won't work unless you convert them to strings first.\n\
    <|/ c |>\n<| c |>\n`sort_by { |s| s.to_i }` would also work.\n<|/ c |>\n<| c |>\n\
    Sorting by strings doesn't sort by the characters of the string. It sorts by lexicographic\
    \ order.\n<|/ c |>\n<| a |>\nYou could just use Ruby's sort function, like this\n\
    <code>\narr = [\"three\", \"one\", \"five\"]\narr.sort.join(\" \")\n</code>\n\
    That will give you the desired output\n<code>\n\"one three five\"\n</code>\n<|/\
    \ a dscore=5 tags=arrays,ruby |>\n<| c |>\nThe OP specifically asked for a solution\
    \ that doesn't require to sort the ", "  numbers.split(\" \").sort.join(\" \"\
    )\nend", "    numbers.split(\" \").sort!\n    numbers.to_s\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nThanks for pointing that out to me (was a mistake)! I'm new to\
    \ Ruby and wasn't aware of the .split method but now I see how it works!\n<|/\
    \ c |>\n<| a dscore=1 tags=ruby,sorting,arrays |>\nA simple way is to use the\
    \ Array#sort method:\n<code>", "  numbers_array = numbers.split(\" \")\n  sorted_numbers_array\
    \ = numbers_array.sort\n  sorted_numbers = sorted_numbers_array.join(' ')\nend",
  "  numbers.split.sort.join\nend", "  return numbers[1..numbers.length].join(' ')\n\
    end", "  return numbers.split(' ').sort.join(' ')\nend", "    numbers = numbers.split('\
    \ ') #Split input into words\n    numbers.sort!  #Sort the numbers alphabetically\n\
    \    numbers = numbers.join(' ') #Join all words back into string\n    return\
    \ numbers\nend", "  numbers.split(\" \").sort.join(\" \")\nend", "  numbers =\
    \ numbers.strip.split(\" \")\n  numbers.sort!\n  return numbers.join(\" \")\n\
    end\n</code>\nThe above will work for integers less than 10. For larger integers,\
    \ you'll have to do some extra work, but this can be done by simply splitting\
    \ the string into an array of characters, sorting, and then joining it back up\
    \ again:\n<code>", "  numbers.split(\" \").sort.join(\" \")\nend", "  return numbers[1..-1].sort.join('\
    \ ')\nend", "  numbers.split(' ').sort!.join(' ').gsub(/(\\d)(?=(\\d\\d)+(?!\\\
    d))/g,\"\\\\1\\\\2\")\nend", "  numbers.split(\" \").sort.join(\" \")\nend", " \
    \ numbers.split.each {|n| n.split(' ').sort.join(' ')}\nend", "  numbers.split.sort\n\
    end", "  numbers_sorted = \"\"\n  numbers.split(\" \").each do |n|\n    numbers_sorted\
    \ += n\n  end\n  numbers_sorted.split(\" \").sort.join(\" \")\nend", "  numbers.split('\
    \ ').sort!\n  numbers.strip!\n  numbers.reverse!\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a |>\nA simple solution:\n<code>", "  numbers.split(\" \").sort_by {\
    \ |s| s.to_i }.join(' ')\nend\n</code>\nAnd here's what it looks like:\n<code>\n\
    > sort_numbers.call(\"three one five\")\n=> \"one three five\"\n</code>\nEDIT:\
    \ As points out, you can do all this with a single call to sort_by:\n<code>",
  "  nums = []\n  numbers.split().each do |i|\n    unless i.downcase.to_i(10) <= 9\n\
    \      nums.push i\n    end\n  end\n  nums.sort!\n  nums.join\nend", "    numbers.split.each\
    \ do |number|\n        number.to_s.split(' ').sort.join(' ')\n    end\nend", " \
    \ numbers = numbers.split(//)\n  numbers.each {|n| n.to_i.sort!}\n  numbers.join(\"\
    \ \")\nend", "  if numbers.empty?\n    numbers\n  elsif numbers.include? \"nine\"\
    \n    numbers[9]\n  elsif numbers.include? \"zero\"\n    numbers[8]\n  elsif numbers.include?\
    \ \"four\"\n    numbers[7]\n  elsif numbers.include? \"three\"\n    numbers[6]\n\
    \  elsif numbers.include? \"two\"\n    numbers[5]\n  elsif numbers.include? \"\
    one\"\n    numbers[4]\n  else\n    numbers[7]\n  end\nend", "  numbers.split(\"\
    \ \").sort.join(\" \")\nend\n</pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n\
    </div>\n<div id=\"footer\">\n<div id=\"footer-text\">\nLast updated 2021-04-21\
    \ 13:45:39 +0000\n</div>\n</div>\n</body>\n</html>\n</code>\n<|/ q |>\n<| c |>\n\
    I'm confused on how you are calling your `sort_numbers` method? I don't see it\
    \ being called in `main()`.\n<|/ c |>\n<| c |>\nThe call to the sort_numbers method\
    \ is inside of the `def main()` method\n<|/ c |>\n<| c |>\nOh right! Yes, I missed\
    \ that. You need to call it somewhere. Where are you calling it?\n<|/ c |>\n<|\
    \ c |>\nThe call to the sort_numbers method is inside of the `def main()` method\n\
    <|/ c |>\n<| c |>\nOkay, I see it now. Let me see if I can figure it out in a\
    \ sec\n<|/ c |>\n<| a dscore=0 |>\nSince you are calling it in main, you need\
    \ to call it in a new method. I've created a new method called main that you can\
    \ call if you want, or you can also just call it inside main.\n<code>\nrequire\
    \ 'rubygems'\nrequire 'sinatra'", "  numbers = numbers.to_s\n  numbers.gsub!(/[^a-z\
    \ ]/i, '')\n  numbers.split(' ').sort_by { |x| x.to_i }.join(' ')\nend\n</code>\n\
    <|/ a tags=ruby,string dscore=3 |>\n<| c |>\nI'm curious, what are the disadvantages\
    \ of this approach?\n<|/ c |>\n<| c |>\nThe disadvantage is that it is inefficient\
    \ in that it runs through all the numbers twice. Using a `Hash` would be more\
    \ efficient (and shorter) but would require more code.\n<|/ c |>\n<| c |>\nIt\
    \ doesn't look like OP is interested in sorting. OP is simply looking to sort\
    \ a delimited string containing numbers within a range of numbers. Your approach\
    \ won't work with numbers greater than 9.\n<|/ c |>\n<| c |>\nOP did say that\
    \ they are \"numbers\". He said \"numbers are only in small letters a-z\". Which\
    \ implies that they are only numbers. In that case, I believe my solution will\
    \ work. Thinking about it now, I think I may have misread that bit.\n<|/ c |>\n\
    <| c |>\nI added a solution that will handle numbers > 9. I am curious, what was\
    \ wrong with my other solution?\n<|/ c |>\n<| a dscore=3 |>\nThis one handles\
    \ numbers greater than 9 as well.\n<code>", "  numbers.split(\" \").sort!\nend",
  "  numbers.split.sort!\n  numbers.join(' ')\nend", "  numbers.split(\" \").sort.join(\"\
    \ \")\nend", "  \n  numbers = numbers.split(\" \").sort\n  \n  numbers = numbers.join(\"\
    \ \")\n  \n  return numbers\nend", "  sorted_numbers = \"\"\n  numbers.each_line\
    \ do |number|\n    sorted_numbers << number[/^(\\d*)([a-z]*)/, 2] if number\n\
    \  end\n  sorted_numbers.reverse!\n  sorted_numbers.each_line do |number|\n  \
    \  number = \"#{number[/\\d+/, 1]}#{number[/[a-z]+/, 1]}\" if number\n    sorted_numbers\
    \ += number\n  end\n  sorted_numbers\nend\n</code>\n<|/ a |>\n<| a |>\nA Perl\
    \ version of's solution:\n<code>", "  numbers = numbers.split(\" \")\n  numbers\
    \ = numbers.sort\n  return numbers[1..-1].join(\" \")\nend\n</cell>\n<cell>",
  "  numbers = numbers.to_s.split\n  numbers.each do |n|\n    if n.to_i < 10\n   \
    \   digits = n.to_i.to_s\n      digits = digits.reverse\n      digits.each do\
    \ |digit|\n        n << digit\n      end\n    end\n  end\n  numbers.join\nend\n\
    </code>\n<|/ a tags=ruby-on-rails,ruby,ruby-on-rails-3 |>\n<| c |>\nThanks for\
    \ this.  I added an explanation to the question to explain that I'm looking for\
    \ a method to sort the numbers not just by adding them one by one.\n<|/ c |>\n\
    <| c |>\nI've added a more simple solution that works well for me.\n<|/ c |>\n\
    <| a tags=ruby-on-rails,ruby,ruby-on-rails-3 |>\nThis worked for me\n<code>",
  "  numbers.split(\" \").sort.join(\" \")\nend", "  numbers.split(' ').reverse.map!\
    \ do |number|\n    number =~ /\\A[+-]?\\d+\\Z/\n    if number.to_i < 10\n    \
    \  number.to_i\n    elsif number.to_i >= 10 && number.to_i < 100\n      \"#{number}0\"\
    \n    else\n      \"#{number}\"\n    end\n  end.join(' ')\nend\n</code>\n<|/ a\
    \ dscore=5 |>\n<| c |>\nThank you for taking the time to write this! The code\
    \ is very clear and concise, and it works great with Ruby 2.0.\n<|/ c |>\n<| c\
    \ |>\nThank you for taking the time to write this! The code is very clear and\
    \ concise, and it works great with Ruby 2.0.\n<|/ c |>\n<| c |>\nThank you for\
    \ taking the time to write this! The code is very clear and concise, and it works\
    \ great with Ruby 2.0.\n<|/ c |>\n<| c |>\nThank you for taking the time to write\
    \ this! The code is very clear and concise, and it works great with Ruby 2.0.\n\
    <|/ c |>\n<| c |>\nThank you for taking the time to write this! The code is very\
    \ clear and concise, and it works great with Ruby 2.0.\n<|/ c |>\n<| a dscore=5\
    \ |>\nAs you wished, this is my solution:\n<code>", "  numbers = numbers.split\
    \ \" \"\n  numbers.sort\n  return \"#{numbers[0]} #{numbers[1]} #{numbers[2]}\"\
    \nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThat works great for small numbers.\
    \ I'm wondering how to extend this for large numbers if there are too many digits\
    \ to fit in a regular `Fixnum`.\n<|/ c |>\n<| c |>\nIf you're using Ruby 2.2+,\
    \ you could consider using [Integer#to_s](https://ruby-doc.org/core-2.2.0/Integer.html#method-i-to_s)\
    \ for this.\n<|/ c |>\n<| c |>\nI realize this is an old thread, but I wanted\
    \ to say that if you're using Ruby 2.2+, `to_s` works like this: `to_s(:dec)`.\
    \  See [here](https://ruby-doc.org/core-2.2.0/Integer.html#method-i-to_s) for\
    \ details on all of the formatting options.\n<|/ c |>\n<| a tags=ruby,string,sorting\
    \ |>\nI like solution that uses regular expressions. To make it more robust, I\
    \ added a couple of options to the regexp. \n<code>", "  numbers.gsub!('  ', '\
    \ ')\n  numbers = numbers.split\n  numbers.sort!\n  numbers.join(\"  \")\nend",
  "  numbers = numbers.split(\" \")\n  numbers.sort!\n  numbers = numbers.join(\"\
    , \")\n  numbers = numbers.gsub(/[\\s,]+/, \" \").strip\n  numbers = numbers.gsub(\"\
    ,\", \".\")\n  numbers.gsub!(\".0\", \"\")\n  numbers = numbers.gsub(\"0.\", \"\
    \")\n  numbers.gsub!(\".0\", \".\")\n  return numbers\nend", "    numbers.split.sort!\n\
    \    numbers.join \" \"\nend\n</code>\n<|/ a dscore=0 tags=ruby,functional-programming,sorting\
    \ |>\n<| c |>\nThe point of this exercise is not to use any `if` statements or\
    \ loops. Just `sort!`\n<|/ c |>\n<| c |>\nWhy is the answer accepted if it's not\
    \ the best possible answer? The question clearly states \"do not use `sort_by`\
    \ method\" which is an extremely common way to solve this problem.\n<|/ c |>\n\
    <| c |>\nThe question doesn't state \"do not use sort_by\", it states \"no built-in\
    \ methods for sorting\". Also, it is clear from the question that they don't want\
    \ to use loops.\n<|/ c |>\n<| c |>\n\"no built-in methods for sorting\" \u2014\
    \ You might be talking about the built-in `sort` method? It is not an explicit\
    \ part of the question.\n<|/ c |>\n<| c |>\nYes, my bad, I mean the Ruby standard\
    \ library\n<|/ c |>\n<| a tags=ruby,functional-programming,sorting dscore=0 |>\n\
    Here's a recursive approach:\n<code>", "  numbers.split(\"  \").sort_by { |x|\
    \ x.to_i }.reverse.join\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nThis\
    \ assumes you can do `sort_by`.\n<|/ c |>\n<| c |>\nIt doesn't assume that. `sort_by`\
    \ is a new method in ruby 1.8.7 and newer. I don't really see how this could possibly\
    \ conflict with something that already exists.\n<|/ c |>\n<| a tags=ruby,string\
    \ |>\nIf you're using Rails, you could do \n<code>\n\"three one five\".split().sort_by(&:to_i)",
  "  numbers.split.map(&:to_i).sort\nend", "  # Split string into array of numbers\n\
    \  numbers = numbers.to_s.split", "    numbers.split(' ')\n    numbers = numbers.sort\n\
    \    numbers.join(' ')\nend\n</code>\n<|/ a tags=ruby dscore=1 |>\n<| c |>\nI\
    \ think it's more idiomatic to iterate over the array with `each`, rather than\
    \ using `map`.\n<|/ c |>\n<| c |>\n`each` returns nothing, while `map` returns\
    \ an array. Using `each` is just more idiomatic and probably more efficient, since\
    \ the latter returns a `Array` which `join` accepts. But I agree, `map` could\
    \ definitely be used here.\n<|/ c |>\n<| a tags=ruby |>\n<code>\n'one two three\
    \ four five'.scan(/\\d/).sort", "  numbers = numbers.split(' ') \n  numbers.sort!\
    \ \n  numbers.join \nend\n</pre>\n<h4 id=\"sorting-all-the-files-in-a-directory-using-the-find-command\"\
    >Sorting all the files in a directory using the 'find' command</h4>\n<pre class=\"\
    prettyprint linenums\">", "  sorted_numbers = numbers.split(\" \")\n  sorted_numbers.reverse!\n\
    \  sorted_numbers.map {|num| num.to_i}\n  sorted_numbers.join(\",\")\nend\n</code>\n\
    <|/ a dscore=1 tags=ruby,ruby-on-rails,activerecord,ruby-on-rails-4 |>\n<| c |>\n\
    Yes, but this is only useful if you want to rewrite your entire codebase with\
    \ your new method\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,activerecord,ruby-on-rails-4\
    \ |>\n<code>\nnumbers = sort_numbers.call(\"three one five\")\n</code>\nwill produce\
    \ an error if sort_numbers.call returns anything but nil, which is what your method\
    \ does.\nYou could do something like:\n<code>\nnumbers = sort_numbers.call(numbers)\
    \ if numbers\n</code>\nwhich will return numbers if they exist or nil if no numbers\
    \ are provided.\n<|/ a dscore=0 |>\n<| c |>\n`sort_numbers.call(\"three one five\"\
    )` will also return `nil`.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,activerecord,ruby-on-rails-4\
    \ |>\nYou are calling your method as sort_numbers.call(\"three one five\") but\
    \ it is returning nil so it will raise an error because you are trying to call\
    \ nil.to_i which will return an ArgumentError.\nYou could do:\n<code>\nnumbers\
    \ = sort_numbers.call(\"three one five\")\nnumbers = numbers && numbers.split(\"\
    \ \") && numbers.map.with_index.to_a.sort\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    This is actually the right answer, but it was posted in before you edited the\
    \ OP.\n<|/ c |>\n<| c |>\nyeah, I saw that and I went ahead and updated it to\
    \ fix the OP's error. I guess it took me a while to see that they had actually\
    \ changed their answer to an `ArgumentError`.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n\
    numbers = sort_numbers.call(\"three one five\")\n</code>\nwill raise an error\
    \ if sort_numbers.call returns anything but nil, which is what your method does.\
    \ You could do something like:\n<code>\nnumbers = sort_numbers.call(numbers) if\
    \ numbers\n</code>\nwhich will return numbers if they exist or nil if no numbers\
    \ are provided.\n<|/ a tags=ruby,ruby-on-rails,activerecord,ruby-on-rails-4 |>\n\
    <| a |>\n<code>", "  numbers.scan(/^\\s*([\\da-z]+)\\s*$/) do |number|\n    numbers.shift\n\
    \    numbers.map! do |number|\n      number.to_i\n    end\n    numbers.sort!\n\
    \  end\n  return numbers\nend", "  numbers.split(' ').map { |n| n.to_i }.sort\n\
    end", "  return numbers.to_s.split(\" \").sort_by { |x| x.to_i }.join(\" \")\n\
    end\n</code>\n<|/ a tags=ruby,sorting |>\n<| a dscore=0 tags=ruby,sorting |>\n\
    <code>\nsort_numbers.call(\"four nine one\")\n => \"one four nine\"\n</code>\n\
    <|/ a |>\n<| c |>\nYou should add an explanation as to why this works.\n<|/ c\
    \ |>\n<| c |>\nThis is a correct answer. Just be careful with your wording; `sort_numbers`\
    \ isn't the correct term, it just does its job for `sort_numbers(\"four nine one\"\
    )`.\n<|/ c |>\n<| c |>\nThis is why I love ruby.  It's as much fun as programming\
    \ in any other language.  Am I the only idiot who likes ruby syntax?  What language\
    \ will you live in if you don't take my advice?  :)\n<|/ c |>\n<| c |>\nI hope\
    \ you enjoy Ruby once you get past the basics.  I've had to go back and forth\
    \ between Java and Ruby in the past, and I think I enjoy it.  But I'm really starting\
    \ to regret it.  :)\n<|/ c |>\n<| a |>\nFor anyone that wants a more generic solution:\n\
    <code>", "  numbers = numbers.split.map { |n| n =~ /^[1-9][0-9]+$/ ? n : \"#{n}0\"\
    .to_i }\n  numbers = numbers.sort.join(\" \")\nend", "  numbers = numbers.to_s\n\
    \  numbers.gsub!(/[^0-9]/,\"\")\n  numbers.split(\" \").sort.join(\", \")\nend",
  "  sorted_numbers = \"\"\n  numbers.split(\" \").each do |number|\n    if number.to_i\
    \ < 10\n      sorted_numbers += \"zero \"\n    elsif number.to_i < 20\n      sorted_numbers\
    \ += \"one \"\n    elsif number.to_i < 30\n      sorted_numbers += \"two \"\n\
    \    elsif number.to_i < 40\n      sorted_numbers += \"three \"\n    elsif number.to_i\
    \ < 50\n      sorted_numbers += \"four \"\n    elsif number.to_i < 60\n      sorted_numbers\
    \ += \"five \"\n    elsif number.to_i < 70\n      sorted_numbers += \"six \"\n\
    \    elsif number.to_i < 80\n      sorted_numbers += \"seven \"\n    elsif number.to_i\
    \ < 90\n      sorted_numbers += \"eight \"\n    elsif number.to_i < 100\n    \
    \  sorted_numbers += \"nine \"\n    end\n  end\n  sorted_numbers\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nYou don't need `&:to_i`. `to_i` will do it.\n<|/\
    \ c |>\n<| a dscore=0 |>\nThis question was asked before in Ruby sorting method\n\
    <code>", "  result = \"\"\n  numbers.split(\" \").reverse.each do |n|\n    if\
    \ n == \"zero\"\n      result += \"0\"\n    elsif n == \"one\"\n      result +=\
    \ \"1\"\n    elsif n == \"two\"\n      result += \"2\"\n    elsif n == \"three\"\
    \n      result += \"3\"\n    elsif n == \"four\"\n      result += \"4\"\n    elsif\
    \ n == \"five\"\n      result += \"5\"\n    elsif n == \"six\"\n      result +=\
    \ \"6\"\n    elsif n == \"seven\"\n      result += \"7\"\n    elsif n == \"eight\"\
    \n      result += \"8\"\n    elsif n == \"nine\"\n      result += \"9\"\n    else\n\
    \      result += \"#{n}\"\n    end\n  end\n  result\nend", "  numbers.split(\"\
    \ \").sort.join(\" \")\nend", "  numbers.split(' ').sort_by{ |num| num.to_i }.reverse.join('\
    \ ')\nend\n</code>\nThe first time sort_numbers runs, it converts the numbers\
    \ to integers, and sorts them from smallest to largest. Then, it converts the\
    \ integers back to strings and joins them back together with spaces between them.\n\
    <|/ a tags=ruby |>\n<| c |>\n`sort_by` and `reverse` both take a `block` and return\
    \ the sorted array itself. So you can actually just do: `numbers.split(' ').sort.join('\
    \ ')`\n<|/ c |>\n<| a dscore=2 |>\nThis is my solution:\n<code>", "  numbers.split.sort.join\n\
    end\n</code>\n<|/ a dscore=3 tags=ruby,sorting |>\n<| a tags=ruby,sorting |>\n\
    Here's another answer that's based on a hash that sorts the digits using String#<=>\
    \ which is basically just sorting the string as numbers:\n<code>", "  numbers.gsub(/\\\
    s+/, ' ').split.sort.join(' ')\nend\n</code>\n<|/ a dscore=4 tags=ruby,sorting,arrays,string\
    \ |>\n<| a dscore=4 |>\nUsing Ruby on Rails\n<code>\na = \"one three two five\
    \ seven eight nine\"\np a.split(' ').sort", "  numbers.split(\" \").sort { |a,\
    \ b| a.to_i <=> b.to_i }.join(\" \")\nend", "    numbers_arr = numbers.split('\
    \ ')\n    numbers_arr.sort!\n    numbers.gsub!(/ +/, '') # Remove spaces\n   \
    \ numbers.gsub!(/[^a-zA-Z]/,'') # Remove non-letters\n    numbers.gsub!(/[^0-9]/,'')\
    \ # Remove non-numbers\n    numbers.gsub!(/[0-9]/, '') # Remove numbers\n    numbers.gsub!(/([a-zA-Z])/,\
    \ '\\1') # Replace all letters with their lowercase\n    numbers.gsub!(/([a-z])/,\
    \ '\\1') # Replace all lowercases with their uppercase\n    numbers.gsub!(/(.)\\\
    1([a-zA-Z])/, '\\1\\3') # Replace all letters with their lowercase and remove\
    \ all lowercases with their uppercase so \"ThO\" becomes just \"T\"\n    numbers.gsub!(/(.)\\\
    1([A-Z])/, '\\1\\3') # Replace all letters with their lowercase and remove all\
    \ uppercases with their uppercase so \"ThO\" becomes just \"T\"\n    return numbers.join('\
    \ ')\nend", "  numbers = numbers.split(\" \")\n  numbers.each do |number|\n  \
    \  number = number.to_i\n    numbers.delete(number)\n    numbers.sort.each do\
    \ |num|\n      number = number.to_s\n      number = \"0\" + num + number\n   \
    \ end\n    numbers.delete(number)\n  end\n  numbers.join(\", \")\nend\n</code>\n\
    <|/ a dscore=3 tags=ruby,algorithm |>\n<| c |>\n`sort_numbers` is very slow when\
    \ there are more than a hundred numbers. It's very fast to implement this using\
    \ bubble sort.\n<|/ c |>\n<| c |>\nIt's not slow, it's just inefficient, and it's\
    \ easy to fix it.  I wrote a version that doesn't use `sort_numbers` and is faster\
    \ than `sort_numbers`, but I wanted to show OP the right tool for the job.\n<|/\
    \ c |>\n<| c |>\nNice answer, but it's kind of like `sort_numbers.call(\"three\
    \ one five\")` but more efficient. Also, when calling `sort_numbers.call(numbers)`\
    \ I believe Ruby will automatically convert the parameter to an array, so you\
    \ don't need to do that. Maybe it's better to leave it out of the answer, though?\n\
    <|/ c |>\n<| c |>\nI think you have a bug: `sort_numbers.call(\"three one five\"\
    )` returns `[\"one\", \"three\", \"five\"]`\n<|/ c |>\n<| a |>\nThis is my variant\
    \ of solution based on my ideas.\n<code>", "  numbers.split(\" \").sort!\n  numbers.strip!\n\
    \  numbers\nend", "  sorted_numbers = numbers.split(\" \")\n  sorted_numbers.sort!\
    \ { |x,y| y <=> x }\n  sorted_numbers = sorted_numbers.join(\" \")\nend\n</code>\n\
    <|/ a |>\n<| c |>\nIf anyone is trying to understand the above solution. Be aware\
    \ of some issues while trying to use the sort_numbers method in production code. ",
  "  words = numbers.split()\n  sorted_numbers = \"\"\n  numbers.to_s.split(\"\").each\
    \ do |number|\n    number = number.to_i\n    unless sorted_numbers.empty?\n  \
    \    sorted_numbers << \" #{number} \"\n    else\n      sorted_numbers << number\n\
    \    end\n  end\n  sorted_numbers.split(\" \").join(\" \")\nend\n</code>\n<|/\
    \ a dscore=0 |>\n<| c |>\nThank you for the answer! I am a beginner at Ruby and\
    \ I like your solution.\n<|/ c |>\n<| c |>\nNo problem, I like that you're interested\
    \ in solving it with Ruby. It could be more efficient than my solution in Ruby\
    \ but it's also clearer than my solution in JavaScript as you only have to look\
    \ at the code once instead of four times. If you don't understand what I'm doing\
    \ then I'd recommend looking up some Ruby tutorials, specifically \"Ruby Programming:\
    \ The Pragmatic Programmer Guide by Matz\".\n<|/ c |>\n<| c |>\nIt's a great book\
    \ that I haven't read. Thanks for the recommendation!\n<|/ c |>\n<| c |>\nYou're\
    \ welcome. I've also been trying to learn Ruby from Codecademy, but they're pretty\
    \ bad at teaching it. I thought it would help if I just picked up an old book\
    \ I found online a few years ago that taught it a little.\n<|/ c |>\n<| a tags=arrays,javascript,algorithm,ruby\
    \ |>\nA simple way to do it with ruby:\n<code>", "  numbers.split.sort.join('\
    \ ')\nend", "  numbers = numbers.strip.split(' ')\n  numbers.map! { |n| n.to_i\
    \ }\n  numbers.sort!\n  numbers.join(' ')\nend", "  # Split up the input string\
    \ by spaces.\n  numbers = numbers.split(\" \")\n  # Use Ruby's inject method to\
    \ perform the sort.\n  numbers.inject(0) do |sum, number|\n    # Convert the string\
    \ to an integer and add it to the accumulator.\n    sum += number.to_i\n  end\n\
    \  # Re-join the numbers to get the sorted string\n  numbers.join(\" \")\nend\n\
    </code>\n<|/ a |>\n<| a |>\nI wrote a short python code for this problem. Hope\
    \ this helps.\n<code>", "  numbers = numbers.to_s.split(' ')\n  numbers.sort!\n\
    \  numbers.join(' ')\nend", "  sorted_numbers = numbers.split\n  sorted_numbers.sort!\n\
    \  sorted_numbers.join(' ')\nend\n</cell>\n<cell>\nsort_numbers.call(\"three one\
    \ five\")\n</cell>\n<text>\nProblem 5\nDefine a function is_palindrome that takes\
    \ a string as input and determines whether or not it is a palindrome. Palindromes\
    \ are strings that read the same backwards. An example would be \"abba\", which\
    \ reads \"ba\" (backward twice). The input will always be valid and will contain\
    \ only lowercase letters.", "  sorted_numbers = numbers[1..-1].sort.join(\" \"\
    )\n  sorted_numbers = sorted_numbers.split(\" \").map.with_index do |number, index|\n\
    \    numbers[index] = \"#{number}#{'.' * (index + 1)}\"\n  end.join(\" \")\n \
    \ sorted_numbers\nend", "\tnumbers = numbers.gsub(/\\W+/, \"\").downcase\n\tnumbers\
    \ = numbers.split(\" \").sort_by { |n| n < 9 ? \"zero\".to_i : \"nine\".to_i }.reverse.join(\"\
    , \")\nend", "  numbers.split(' ').sort.join(' ')\nend", "  numbers.split(\" \"\
    ).sort!\n  numbers = numbers.join(\" \")\nend\n</code>\nAnd here are the unit\
    \ tests for the above functions:\n<code>", "  numbers.gsub!( /(\\D*)/ ) do |word|\n\
    \    if word.empty?\n      word\n    elsif word.slice!(0..-1) == ?-\n      word.slice!(0..-1)\n\
    \      word.slice!(0..-1)\n      word.slice!(0..-1)\n      word.slice!(0..-1)\n\
    \      word.slice!(0..-1)\n      word.slice!(0..-1)\n      word.slice!(0..-1)\n\
    \      word.slice!(0..-1)\n      word.slice!(0..-1)\n      word.slice!(0..-1)\n\
    \      word.slice!(0..-1)\n      word.slice!(0..-1)\n      word.slice!(0..-1)\n\
    \      word.slice!(0..-1)\n      word.slice!(0..-1)\n      word.slice!(0..-1)\n\
    \      word.slice!(0..-1)\n      word.slice!(0..-1)\n      word.slice!(0..-1)\n\
    \      word.slice!(0..-1)\n      word.slice!(0..-1)\n      word.slice!(0..-1)\n\
    \      word.slice!(0..-1)\n      word.slice!(0..-1)\n      word.slice!(0..-1)\n\
    \      word.slice!(0..-1)\n      word.slice!(0..-1)\n      word.slice!(0..-1)\n\
    \      word.slice!(0..-1)\n      word.slice!(0..-1)\n      word.slice!(0..-1)\n\
    \      word.slice!(0..-1)\n      word.slice!(0..-1)\n      word.slice!(0..-1)\n\
    \      word.slice!(0..-1)\n      word.slice!(0..-1)\n      word.slice!(0..-1)\n\
    \      word.slice!(0..-1)\n      word.slice!(0..-1)\n      word.slice!(0..-1)\n\
    \      word.slice!(0..-1)\n      word.slice!(0..-1)\n      word.slice!(0..-1)\n\
    \      word.slice!(0..-1)\n      word.slice!(0..-1)\n      word.slice!(0..-1)\n\
    \      word.slice!(0..-1)\n      word.slice!(0..-1)\n      word.slice!(0..-1)\n\
    \      word.slice!(0..-1)\n      word.slice!(0..-1)\n      word.slice!(0..-1)\n\
    \      word.slice!(0..-1)\n      word.slice!(0..-1)\n      word.slice!(0..-1)\n\
    \      word.slice!(0..-1)\n      word.slice!(0..-1)\n      word.slice!(0..-1)\n\
    \      word.slice!(0..-1)\n      word.", "    numbers.split(\" \").sort_by { |n|\
    \ n.to_i }.reverse.join\nend\n</code>\nI used .sort_by because this produces a\
    \ sorted array rather than a hash.  If the output was a hash, you wouldn't need\
    \ .reverse.\n<|/ a dscore=1 tags=ruby,ruby-on-rails |>\n<| a dscore=0 |>\nI would\
    \ recommend you have a look at ActiveSupport#number_to_currency. You'll find an\
    \ example in their documentation.\n<|/ a tags=ruby,ruby-on-rails |>\n<| a tags=ruby,ruby-on-rails\
    \ dscore=0 |>\nTo convert number into currency format\n<code>\nnumber_to_currency",
  "  sorted_numbers = numbers.split(\" \")\n  sorted_numbers.sort!", "  numbers.split('\
    \ ').sort_by { |n| n[/^(\\d)/, 1] }.join(' ')\nend", "\tsorted_numbers = numbers[1..-1].sort\n\
    \tsorted_numbers.to_s\nend", "  numbers.split.each {|i| i.split('').sort.join('')}.join(\"\
    \ \")\nend", "  numbers_string = \"\"\n  i = 0\n  while i < numbers.length\n \
    \   number = numbers[i]\n    if number == 'zero'\n      numbers_string += 'zero\
    \ '\n      i += 1\n      continue\n    if number == 'one'\n      numbers_string\
    \ += 'one '\n      i += 1\n      continue\n    if number == 'two'\n      numbers_string\
    \ += 'two '\n      i += 1\n      continue\n    if number == 'three'\n      numbers_string\
    \ += 'three '\n      i += 1\n      continue\n    if number == 'four'\n      numbers_string\
    \ += 'four '\n      i += 1\n      continue\n    if number == 'five'\n      numbers_string\
    \ += 'five '\n      i += 1\n      continue\n    if number == 'six'\n      numbers_string\
    \ += 'six '\n      i += 1\n      continue\n    if number == 'seven'\n      numbers_string\
    \ += 'seven '\n      i += 1\n      continue\n    if number == 'eight'\n      numbers_string\
    \ += 'eight '\n      i += 1\n      continue\n    if number == 'nine'\n      numbers_string\
    \ += 'nine '\n      i += 1\n      continue\n  end\n  return numbers_string.chomp\n\
    end", "  return words.sort { |a,b| a.to_i <=> b.to_i }.join(\" \")\nend\n</code>\n\
    And here's an example of using it, with a few more examples of how it's used:\n\
    <code>\n>> sort_numbers.call(\"four zero six seven nine\")\n\"zero six four seven\
    \ nine\"\n>> sort_numbers.call(\"seven four zero six nine\")\n\"four seven six\
    \ zero nine\"\n>> sort_numbers.call(\"five nine\")\n\"five nine\"\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nGood answer! I thought about using it, but it doesn't\
    \ work exactly as i want it to do, because the program should receive a sentence\
    \ as a parameter, and it has to return it with the numbers sorted, for example: ",
  "    numbers.split(/\\s+/).sort.join(\" \")\nend\n</cell>\n<text>\nExercise\nModify\
    \ the sort_numbers function below so that it takes in a string and outputs the\
    \ string with words sorted from smallest to largest, ignoring any punctuation\
    \ and spaces. The words should still be in alphabetical order (i.e. \"elephant\"\
    \ is before \"tiger\"). Make sure you handle edge cases (like empty strings).",
  "    numbers = numbers.to_s.split ' '\n    numbers.sort\n    numbers.join\nend",
  "  # TODO: sort numbers here\n  numbers.split(\" \").sort_by { |n| n[0, 1] }.join(\"\
    \ \")\nend\n</code>\n<|/ a tags=ruby,arrays,ruby-on-rails |>\n<| c |>\nWhy do\
    \ you need to sort it in Ruby? You can do that in Ruby too. `numbers = \"three\
    \ one five\".split(\" \").sort_by(&:first).join(\" \")` will output `\"one three\
    \ five\"` .\n<|/ c |>\n<| c |>\n- Yes, that's a better way, I always forget that\
    \ you can use `&:first` as a block in `sort_by`. Nice!\n<|/ c |>\n<| c |>\nStill\
    \ a Ruby question tho. Can you please explain it a bit more to me? I understand\
    \ the sort part, but what does &:first do?\n<|/ c |>\n<| c |>\n`&:first` calls\
    \ the method `first` on the argument `&:first`, passing in the block `&:first`\
    \ so you can do `sort_by { |n| n[0, 1] }` which is pretty much the same thing\
    \ as `sort_by { |n| n[0] }`. `&:first` calls the method `first` on the argument\
    \ `&:first` which is `first` method on the string object `\"one two three\"`.\
    \ So, `sort_by { |n| n[0, 1] }` would call `sort_by { |n| n[0] }` on `\"one two\
    \ three\"`.\n<|/ c |>\n<| a dscore=2 |>\nJust to add to others' answers, you can\
    \ also do this:\n<code>\n\"three one five\".split.sort.join(\" \")\n</code>\n\
    This avoids creating a temporary string and uses more Ruby idioms to achieve the\
    \ same thing. The difference being that this also sorts the array in place, whereas\
    \ my original answer creates a new temporary array, and uses map to create a new\
    \ array of just the sorted numbers, which is then converted to a single string\
    \ with join.\n<|/ a tags=ruby,arrays,ruby-on-rails |>\n<| a dscore=2 tags=ruby,arrays,ruby-on-rails\
    \ |>\nYou can use the sort_by method from the Enumerable module:\n<code>\n\"three\
    \ one five\".split(\" \").sort_by(&:first).join(\" \")\n</code>\n<|/ a |>\n<|\
    \ c |>\n`sort_by` is an inplace operation. `sort_by { |n| n[0] }` would be better.\n\
    <|/ c |>\n<| a |>\n<code>", "  if numbers.nil? or numbers.empty?\n    return nil\n\
    \  end\n  numbers.split(\"  \").sort_by(&:to_i).map(&:to_s)\nend\n</code>\n<|/\
    \ a tags=string,ruby,methods dscore=5 |>\n<| c |>\nWhat if you wanted to use the\
    \ same sort method for multiple strings? i.e. sort_numbers(\"three one five\"\
    , \"two four seven\")\n<|/ c |>\n<| c |>\n: then you just need to use different\
    \ delimiters, as I explained in my answer: \"The default delimiter is a space\"\
    \n<|/ c |>\n<| c |>\nThat was my first thought but I tried it... doesn't seem\
    \ to be working.\n<|/ c |>\n<| c |>\n: I tested it, and it works just fine. Make\
    \ sure you copy and paste the code exactly as I wrote it. I think perhaps you\
    \ forgot to put a space at the end of a line, or a carriage return character.\n\
    <|/ c |>\n<| c |>\n: I edited my answer to include the code that works for me.\
    \ Make sure you paste it exactly as it is. I tested it just now and it works.\
    \ Please try it again and let me know if it doesn't work for you.\n<|/ c |>\n\
    <| a |>\n<code>", "  numbers.split(\" \").reduce(:+)\nend", "  numbers.gsub!(/\\\
    s+/, \"\")\n  numbers = numbers.split(\"\\n\")\n  numbers.map! {|num| num.strip.to_i}\n\
    \  numbers.sort! {|a, b| b - a}\n  numbers.join(\"\\n\")\nend\n</code>\n<|/ a\
    \ dscore=3 |>\n<| a |>\nA variation on the answer by that doesn't use #sort, but\
    \ instead just counts the occurrences of each number and prints them out in ascending\
    \ order. Here's the code:\n<code>", "    numbers.gsub!(/[^a-z]/i, '') # replace\
    \ everything that's not a letter or number with an empty string\n    numbers_array\
    \ = numbers.split(' ')\n    numbers_array.sort!", "  numbers.split(\" \").sort!\n\
    \  numbers.gsub!(/[^0-9]/, '')\n  numbers.gsub!(/([a-z])/) do |x|\n    if x.downcase\
    \ == 'zero'\n      '0'\n    elsif x.downcase == 'one'\n      '1'\n    elsif x.downcase\
    \ == 'two'\n      '2'\n    elsif x.downcase == 'three'\n      '3'\n    elsif x.downcase\
    \ == 'four'\n      '4'\n    elsif x.downcase == 'five'\n      '5'\n    elsif x.downcase\
    \ == 'six'\n      '6'\n    elsif x.downcase == 'seven'\n      '7'\n    elsif x.downcase\
    \ == 'eight'\n      '8'\n    elsif x.downcase == 'nine'\n      '9'\n    else\n\
    \      '?'\n    end\n  end\n  numbers.gsub!(/(^|\\s)(\\d)/, \"\\\\2 \\\\1\")\n\
    \  numbers.gsub!(/(^|\\s)(\\d{2})(\\d)/, \"\\\\1 \\\\3 \\\\2\")\n  numbers.gsub!(/(^|\\\
    s)(\\d{3})(\\d)/, \"\\\\1 \\\\2 \\\\3\")\n  numbers.gsub!(/(^|\\s)(\\d{4})(\\\
    d)/, \"\\\\1 \\\\2 \\\\3\")\n  numbers.gsub!(/(^|\\s)(\\d{4})(\\d{2})/, \"\\\\\
    1 \\\\2 \\\\3\")\n  numbers.gsub!(/(^|\\s)(\\d{4})(\\d{2})(\\d{2})/, \"\\\\1 \\\
    \\2 \\\\3 \\\\4\")\n  numbers.gsub!(/(^|\\s)(\\d{4})(\\d{2})(\\d{2})(\\d{2})/,\
    \ \"\\\\1 \\\\2 \\\\3 \\\\4 \\\\5\")\n  numbers.gsub!(/(^|\\s)(\\d{4})(\\d{2})(\\\
    d{2})(\\d{2})(\\d{2})/, \"\\\\1 \\\\2 \\\\3 \\\\4 \\\\5 \\\\6\")\n  numbers.gsub!(/(^|\\\
    s)(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/, \"\\\\1 \\\\2 \\\\3 \\\\\
    4 \\\\5 \\\\6 \\\\7\")\n  numbers.gsub!(/(^|\\s)(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\\
    d{2})(\\d{2})(\\d{2})/, \"\\\\1 \\\\2 \\\\3 \\\\4 \\\\5 \\\\6 \\\\7 \\\\8\")\n\
    \  numbers.gsub!(/(^|\\s)(\\d{4})", "  return numbers[0...numbers.index('nine')].sort.join\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nJust use sort_by :\n<code>\n\
    numbers = %w( zero one two three four five six seven eight nine )\nnumbers.sort_by{|n|\
    \ n}", "  numbers\n    .split\n    .map{|number| number.to_i}\n    .sort\n   \
    \ .join(' ')\nend\n</code>\nThe sort_numbers method can be called from the main\
    \ method as follows:\n<code>\nsort_numbers.call(\"three one five\")\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails-4,ruby-on-rails |>\n<| a dscore=1 |>\nHere's a recursive\
    \ solution to sort a string, if that's what you need:\n<code>", "  # Your code\
    \ here\n  numbers = numbers.split(\" \")\n  numbers = numbers.sort { |a,b| b <=>\
    \ a }\n  numbers.join(\" \")\nend\n</code>\nTo make things interesting you can\
    \ test it out with a variety of test cases:\n<code>\nputs sort_numbers(\"one two\
    \ three four five\") # => one two three four five\nputs sort_numbers(\"one two\"\
    ) # => one two\nputs sort_numbers(\"nine three seven five nine\") # => nine three\
    \ seven five nine\nputs sort_numbers(\"six eight three seven\") # => six eight\
    \ three seven\nputs sort_numbers(\"six eight\") # => six eight\nputs sort_numbers(\"\
    three\") # => three\nputs sort_numbers(\"three one\") # => one three\nputs sort_numbers(\"\
    two three four\") # => two three four\nputs sort_numbers(\"nine two three four\"\
    ) # => nine two three four\nputs sort_numbers(\"zero one two three\") # => zero\
    \ one two three\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>", "  numbers.gsub!(/[^0-9]+/,\
    \ \"\")\n  numbers = numbers.split(\" \").sort_by{|number| number.to_i}.join(\"\
    \ \")\n  numbers = \"zero\" if numbers == \"0\"\n  numbers = \"nine\" if numbers\
    \ == \"9\"\n  numbers\nend", '  numbers = numbers.strip', "    numbers.split.map\
    \ { |n| n.to_i }.sort\nend\n</code>\n<|/ a dscore=2 |>\n<| a |>\n<code>", "  \
    \  numbers.each_with_index do |n, i|\n        n.gsub!(/[^a-z]/, '').to_i\n   \
    \ end\n    numbers.sort!", "  numbers = numbers.split\n  numbers = numbers.map!\
    \ do |n| n.to_i\n  numbers.sort!\n  numbers.join\nend\n</code>\n<|/ a |>\n<| a\
    \ tags=ruby,functional-programming |>\nRuby 2.2+ (and Ruby 2.3+)\n<code>\nnumbers\
    \ = \"3 1 5\"\nnumbers.split(\" \").map(&:to_i).sort.join", "    numbers.split(\"\
    \ \").sort.join(\" \")\nend", "  numbers.split(\" \").sort!\n  numbers.join(\"\
    \ \")\nend\n</code>\n<|/ a |>\n<| c |>\nThe OP has requested the string to be\
    \ sorted in ascending order which is why the example uses `sort_by` rather than\
    \ `sort!`.\n<|/ c |>\n<| a dscore=5 |>\nI came here with a different question\
    \ than OP, but after seeing the top two answers I went ahead and tried a few different\
    \ ways to do it.\nHere's what I came up with:\n<code>", "  numbers.each do |number|\n\
    \    if number.to_i < 10 then\n      numbers[number] = number.to_i.downcase\n\
    \    else\n      numbers[number] = number.to_i.upcase\n    end\n  end\n  numbers.sort!\n\
    \  numbers.join(' ')\nend\n</code>\n<|/ a |>\n<| a dscore=1 tags=ruby,arrays,string\
    \ |>\nYou didn't specify what the actual rules are for sorting the numbers, but\
    \ the key idea is that you need an array of the digits.  Then you can sort that\
    \ array.  For example:\n<code>", "  sorted_numbers = numbers.split(\" \")\n  sorted_numbers.sort!\n\
    \  return sorted_numbers.join(\" \")\nend", "  numbers.split(\" \").map{|x| x.to_i}.sort{|a,b|\
    \ a <=> b}.map{|x| x.to_s}.join(\" \")\nend", "  numbers.split(\" \").sort_by\
    \ { |n| n.to_i }.join(\" \")\nend", "  numbers_as_array = numbers.split(\" \"\
    )\n  numbers_as_array.sort!\n  numbers = numbers_as_array.to_s\nend", "  # Split\
    \ up the numbers and sort them in ascending order\n  sorted_numbers = numbers.split.sort\
    \ {|x,y| x.to_i < y.to_i }.join(\" \")\nend\n</code>\n<|/ a tags=ruby |>\n<| a\
    \ dscore=1 tags=ruby |>\n<code>", "  sorted_numbers = \"\"\n  sorted_numbers =\
    \ numbers.split(\" \").reverse.map { |n| sort_number(n) }.flatten.join(\" \")\n\
    \  sorted_numbers\nend", "  numbers.split.sort.join(' ')\nend", "    numbers =\
    \ numbers.strip.split(\" \")\n    numbers = numbers.map(&:to_i)\n    numbers.sort!",
  "  numbers.gsub!(\" \", \"\")\n  numbers.gsub!(\"\\n\", \"\").gsub!(\"\\r\", \"\"\
    )\n  numbers.gsub!(\"\\t\", \"\")\n  numbers.gsub!(\"  \", \"\")\n  numbers.gsub!(\"\
    \  \", \" \").gsub!(\"  \", \"  \")\n  numbers.gsub!(\"  \", \"  \")\n  numbers.gsub!(\"\
    \  \", \"  \")\n  numbers.gsub!(\"  \", \"  \")\n  numbers.gsub!(\"  \", \"  \"\
    )\n  numbers.gsub!(\"  \", \"  \")\n  numbers.gsub!(\"  \", \"  \")\n  numbers.gsub!(\"\
    \  \", \"  \")\n  numbers.gsub!(\"  \", \"  \")\n  numbers.gsub!(\"  \", \"  \"\
    )\n  numbers.gsub!(\"  \", \"  \")\n  numbers.gsub!(\"  \", \"  \")\n  numbers.gsub!(\"\
    \  \", \"  \")\n  numbers.gsub!(\"  \", \"  \")\n  numbers.gsub!(\"  \", \"  \"\
    )\n  numbers.gsub!(\"  \", \"  \")\n  numbers.gsub!(\"  \", \"  \")\n  numbers.gsub!(\"\
    \  \", \"  \")\n  numbers.gsub!(\"  \", \"  \")\n  numbers.gsub!(\"  \", \"  \"\
    )\n  numbers.gsub!(\"  \", \"  \")\n  numbers.gsub!(\"  \", \"  \")\n  numbers.gsub!(\"\
    \  \", \"  \")\n  numbers.gsub!(\"  \", \"  \")\n  numbers.gsub!(\"  \", \"  \"\
    )\n  numbers.gsub!(\"  \", \"  \")\n  numbers.gsub!(\"  \", \"  \")\n  numbers.gsub!(\"\
    \  \", \"  \")\n  numbers.gsub!(\"  \", \"  \")\n  numbers.gsub!(\"  \", \"  \"\
    )\n  numbers.gsub!(\"  \", \"  \")\n  numbers.gsub!(\"  \", \"  \")\n  numbers.gsub!(\"\
    \  \", \"  \")\n  numbers.gsub!(\"  \", \"  \")\n  numbers.gsub!(\"  \", \"  \"\
    )\n  numbers.gsub!(\"  \", \"  \")\n  numbers.gsub!(\"  \", \"  \")\n  numbers.gsub!(\"\
    \  \", \"  \")\n  numbers.gsub!(\"  \", \"  \")\n  numbers.gsub!(\"  \", \"  \"\
    )\n  numbers.gsub!(\"  \", \"  \")\n  numbers.gsub!(\"  \", \"  \")\n", "  numbers_array\
    \ = numbers.split(' ')\n  numbers_array.sort!\n  numbers_array.join(' ')\nend",
  "  numbers.split(' ').sort!.reverse.join(' ')\nend", "  numbers.gsub!(/[^0-9]+/,\
    \ \"\") # strip out all non-numbers\n  numbers.gsub!(/zero/, '') #remove \"zero\"\
    \ \n  numbers.gsub!(/one/, '1') #remove \"one\"\n  numbers.gsub!(/two/, '2') #remove\
    \ \"two\"\n  numbers.gsub!(/three/, '3') #remove \"three\"\n  numbers.gsub!(/four/,\
    \ '4') #remove \"four\"\n  numbers.gsub!(/five/, '5') #remove \"five\"\n  numbers.gsub!(/six/,\
    \ '6') #remove \"six\"\n  numbers.gsub!(/seven/, '7') #remove \"seven\"\n  numbers.gsub!(/eight/,\
    \ '8') #remove \"eight\"\n  numbers.gsub!(/nine/, '9') #remove \"nine\"\n  numbers.gsub!(/(one|two|three|four|five|six|seven|eight|nine)/,\
    \ '\\1') #replace 'one','two','three','four','five','six','seven','eight','nine'\
    \ with '\\1'\n  numbers.gsub!(/(zero|one|two|three|four|five|six|seven|eight|nine)/,\
    \ '\\1') #replace 'zero','one','two','three','four','five','six','seven','eight','nine'\
    \ with '\\1'\n  numbers.gsub!(/(one|two|three|four|five|six|seven|eight|nine)/,\
    \ '\\1') #replace 'one','two','three','four','five','six','seven','eight','nine'\
    \ with '\\1'\n  numbers.gsub!(/(zero|one|two|three|four|five|six|seven|eight|nine)/,\
    \ '\\1') #replace 'zero','one','two','three','four','five','six','seven','eight','nine'\
    \ with '\\1'\n  numbers.gsub!(/(one|two|three|four|five|six|seven|eight|nine)/,\
    \ '\\1') #replace 'one','two','three','four','five','six','seven','eight','nine'\
    \ with '\\1'", "  numbers.split(\" \").sort.join\nend\n</code>\n<|/ a tags=ruby,sorting,string\
    \ |>\n<| c |>\nThat's actually more code than the one in the question.\n<|/ c\
    \ |>\n<| c |>\nI love the one-liner that uses `sort_by`. However, for my use case\
    \ I'm going to have to go with Nikki's solution because my actual input string\
    \ will have leading spaces in it.\n<|/ c |>\n<| c |>\nI like this answer and like\
    \ it because it uses methods that are part of the language. But, I am also very\
    \ interested in knowing if there is a way to do this without using sort_by or\
    \ sort_by! In other words, why does Ruby have these methods even though they are\
    \ not really part of the language?\n<|/ c |>\n<| a |>\n<code>\nstring = \"one\
    \ three four\"\nstring.split(\" \").sort.join\n=> \"one three four\"\n</code>\n\
    <|/ a dscore=5 tags=ruby,sorting,string |>\n<| a dscore=5 tags=ruby,sorting,string\
    \ |>\nHere's another way (with spaces included):\n<code>\n>> \"one two three\"\
    .split().sort_by{|s| s.to_i}.join\n=> \"one two three\"\n</code>\n<|/ a |>\n<|\
    \ c |>\n+1 This is definitely the best way to sort, and I use it a lot.  But I\
    \ like the solution with `sort_by!`, which makes the code a little more verbose.\n\
    <|/ c |>\n<| c |>\n`sort_by!` is pretty damn neat.\n<|/ c |>\n<| a dscore=4 tags=ruby,sorting,string\
    \ |>\n<code>\nstring = \"one two three\"\nstring.split(\" \").sort.join(\" \"\
    )\n</code>\n<|/ a |>\n<| c |>\nThis is what I was looking for. Thanks!\n<|/ c\
    \ |>\n<| a dscore=4 tags=ruby,sorting,string |>\n<code>\nnumber = \"one two three\"\
    \nnumber.split(\" \").sort.join(\" \")\n</code>\n<|/ a |>\n<| a tags=ruby,sorting,string\
    \ |>\nOne more way:\n<code>\nstring = \"one two three\"\nstring.split.sort.join(\"\
    \ \")\n</code>\n<|/ a dscore=4 |>\n<| a tags=ruby,sorting,string |>\nHow about\
    \ this:\n<code>\n\"one two three\".split.sort.join\n</code>\n<|/ a dscore=4 |>\n\
    <| a |>", "  numbers = numbers.to_s.split.sort\n  numbers.join\nend", "    numbers.to_s.split('\
    \ ').sort{|a,b| a <=> b}.join(' ')\nend", "  numbers.split(\" \").sort.join(\"\
    \ \")\nend", "  if numbers.blank?\n    numbers\n  elsif numbers.include?(' ')\n\
    \    numbers = numbers[0...numbers.index(' ')]\n    numbers = numbers.join(' ')\n\
    \  else\n    numbers = numbers.split(' ')\n  end\n  numbers = numbers.sort { |a,b|\
    \ a.to_i <=> b.to_i }\n  numbers.join(' ')\nend\n</code>\n<|/ a |>\n<| c |>\n\
    For what it's worth, it looks like someone else asked the same thing for Ruby\
    \ before I made my edit. http://stackoverflow.com/questions/2732358/how-can-i-sort-a-ruby-array\n\
    <|/ c |>\n<| c |>\nIt would be more Ruby-like to pass the block to sort_by rather\
    \ than to sort.\n<|/ c |>\n<| c |>\n: That depends. `sort_by` returns a new array\
    \ (which is what `sort` does), whereas `sort_by!` modifies in-place the original\
    \ array. `sort_by!` is useful if you want to modify the array in place.\n<|/ c\
    \ |>\n<| c |>\nActually, sort_by returns an array of arrays, not an array of hashes.\
    \ It seems like you meant `numbers = numbers.sort_by{|x| x.to_i}`. Also, this\
    \ method will require extra space for the extra spaces in the string.\n<|/ c |>\n\
    <| c |>\n: yeah, I meant `sort_by`; sorry for the typo (but it's too late at night\
    \ for me to fix a typo I thought was right; that's why I posted my comment as\
    \ a question)\n<|/ c |>\n<| a tags=arrays,sorting,ruby dscore=1 |>\nA few others\
    \ already pointed out that you can sort an array using the sort_by method. However,\
    \ I'd like to point out that this has the potential to introduce bugs. If you\
    \ pass an array as a parameter to sort_by, then your parameter will be passed\
    \ by reference. That means that if you modify the array from within your sort\
    \ block, you'll be modifying it outside of that block. For example:\n<code>\n\
    >> array = [1, 2, 3, 4]\n>> array.sort_by{|x| x}\n=> [1, 2, 3, 4]\n>> array\n\
    => [1, 2, 3, 4]\n</code>\nNotice how the array is unchanged after sort_by, even\
    \ though the block modifies it. \nOne way to solve this would be to use sort_by\
    \ with a block:\n<code>\n>> array = [1, 2, 3, 4]\n>> array.sort_by{|x| array.index(x)}\n\
    => [1, 2, 3, 4]\n>> array\n=> [1, 3, 2, 4]\n</code>\n", "  if numbers.nil?\n \
    \   nil\n  else\n    split_num = numbers.split(' ') \n    sorted_num = []\n  \
    \  sorted_num.push(split_num.sort.reverse.first)\n    sorted_num.push(split_num.sort.reverse.last)\n\
    \    sorted_num.join(' ')\n  end\nend", "  numbers.split.sort.join(\" \")\nend\n\
    </code>\n<|/ a tags=ruby,lambda,functional-programming,ruby-on-rails |>\n<| a\
    \ |>\nHere is another way you can solve this problem. I would prefer this solution\
    \ if you are new to Ruby programming.\n<code>", "  numbers.split(\" \").sort!\n\
    \  numbers.join(\" \")\nend", "  return numbers.split(' ').sort.join\nend", " \
    \ numbers.split(' ').sort_by { |s| s.to_i }.reverse.join(' ')\nend", "  numbers\
    \ = numbers.split.sort\n  numbers.join \" \"\nend", "    numbers = numbers.split(\"\
    \ \")\n    numbers.each do |number|\n        number = number.to_i\n        unless\
    \ [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\"\
    , \"eight\", \"nine\"].include? number\n            puts \"Invalid input!\"\n\
    \        end\n    end\n    numbers.sort\n    return numbers.join\nend", "  numbers.split.sort.join\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis is actually the best solution for\
    \ my case. Thank you very much!\n<|/ c |>\n<| a dscore=1 |>\nHere's an approach\
    \ that uses a custom sort to sort the array:\n<code>", "  numbers.split(\" \"\
    ).sort{|a, b| a.to_i <=> b.to_i}.join(\" \")\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\n`sort_numbers` isn't a method of `String`, it's a method of `Array`.\n\
    <|/ c |>\n<| a tags=ruby,ruby-on-rails |>\n<code>", "  numbers = numbers.strip.split(\"\
    \ \").sort\n  numbers.each {|n| return n }\nend\n</code>\n<|/ a dscore=0 tags=string,ruby\
    \ |>\n<| a dscore=0 |>\nThe best solution is to use the split method. Split each\
    \ word into an array and then sort the array based on the first value.\nHere are\
    \ the steps:", "    numbers.split(\" \").sort.join(\" \")\nend\n</code>\n<|/ a\
    \ dscore=5 tags=ruby,ruby-on-rails |>\n<| a tags=ruby,ruby-on-rails |>\nThis solution\
    \ works for all cases:\n<code>", "  numbers.split(\" \").sort_by { |num| num.to_i\
    \ }.join(\" \")\nend\n</code>\n<|/ a tags=ruby,sorting,string,algorithm |>\n<|\
    \ a tags=ruby,sorting,string,algorithm dscore=1 |>\n<code>", "  sorted = []\n\
    \  numbers = numbers.split(\" \")\n  numbers.each do |number|\n    if number ==\
    \ 'zero'\n      sorted << 0\n    elsif number == 'one'\n      sorted << 1\n  \
    \  elsif number == 'two'\n      sorted << 2\n    elsif number == 'three'\n   \
    \   sorted << 3\n    elsif number == 'four'\n      sorted << 4\n    elsif number\
    \ == 'five'\n      sorted << 5\n    elsif number == 'six'\n      sorted << 6\n\
    \    elsif number == 'seven'\n      sorted << 7\n    elsif number == 'eight'\n\
    \      sorted << 8\n    elsif number == 'nine'\n      sorted << 9\n    end\n \
    \ end\n  sorted.join(' ')\nend\n</code>\n<|/ a |>\n<| a |>\nThe other answers\
    \ seem to be mostly focused on how to write an algorithm, rather than how to do\
    \ it 'right'. I don't think you were looking for an algorithm, but rather an implementation\
    \ that works.\nFirst thing to do is decide how you're going to store your numbers.\
    \ In your example, you have an array of integers, where each integer is an index\
    \ into a table of digits. This is easy to implement: create an array (say called\
    \ digits[]) containing the digits 0 to 9. Then, to store a number, you just use\
    \ digits[num] to store the number.\nFor your example, you'd have:\n<code>\ndigits[3]\
    \ = 'three'\ndigits[2] = 'two'\ndigits[1] = 'one'\n</code>\nThen to store your\
    \ number \"one three five\", you just do:\n<code>\ndigits[num] = num\n</code>\n\
    This will give you a large table where digits[num] contains the number for that\
    \ digit. If you start out with 'zero' in your array, digits[3] will contain the\
    \ string 'three' because digits[2] is 'two'.\nTo convert it back, you can do this:\n\
    <code>\nnum = 3\nputs digits[num]\n</code>\nAnd that would give you \"three\"\
    .\nTo convert a number from one base to another, you just do this:\n<code>\nnum\
    \ = num.to_i\ndigits[num] = '#{\"0\" * (num % base) + \"#{(num / base) + 1}\"\
    [num % base]}' # num % base is how long the number is when base is 2.\n</code>\n\
    For example, 12 in base 2 is \"10\". The first section of the expression is \"\
    10#{\"00\" * (12 % 2)}#{(12 / 2) + 1}\" which looks like \"0010#{\"1\" * (", " \
    \ # Your code here\n  # return \"zero one two three four five six seven eight\
    \ nine\"\n  nine = numbers[8]\n  twelve = numbers[12]\n  ten = numbers[10]\n \
    \ nineteen = numbers[15]\n  eleven = numbers[11]\n  one = numbers[1]\n  two =\
    \ numbers[2]\n  three = numbers[3]\n  four = numbers[4]\n  five = numbers[5]\n\
    \  six = numbers[6]\n  seven = numbers[7]\n  eight = numbers[8]\n  zero = numbers[0]\n\
    \  sorted_numbers = \"\"\n  sorted_numbers = sorted_numbers.concat(zero)\n  sorted_numbers\
    \ = sorted_numbers.concat(one)\n  sorted_numbers = sorted_numbers.concat(two)\n\
    \  sorted_numbers = sorted_numbers.concat(three)\n  sorted_numbers = sorted_numbers.concat(four)\n\
    \  sorted_numbers = sorted_numbers.concat(five)\n  sorted_numbers = sorted_numbers.concat(six)\n\
    \  sorted_numbers = sorted_numbers.concat(seven)\n  sorted_numbers = sorted_numbers.concat(eight)\n\
    \  sorted_numbers = sorted_numbers.concat(nine)\n  sorted_numbers = sorted_numbers.concat(eleven)\n\
    \  sorted_numbers = sorted_numbers.concat(nineteen)\n  sorted_numbers = sorted_numbers.concat(ten)\n\
    \  sorted_numbers = sorted_numbers.concat(twelve)\n  sorted_numbers = sorted_numbers.concat(nine)\n\
    \  return sorted_numbers\nend", "  numbers.split(\" \").sort_by {|s| s[/\\d+/].to_i}.join\n\
    end", "  numbers = numbers.split(' ') # Split into words\n  numbers = numbers.map(&:to_i)\
    \ # Convert each word to an integer.\n  numbers = numbers.sort { |a, b| a <=>\
    \ b } # Sort from smallest to largest\n  numbers = numbers.join(' ') # Put back\
    \ into string\nend", "  numbers.split(\", \").sort_by(&:to_i).join(\", \")\nend\n\
    </code>\n<|/ a tags=ruby,methods |>\n<| a dscore=0 tags=ruby,methods |>\nIf you\
    \ just want to print the numbers, you can just do:\n<code>\nputs \"The numbers\
    \ are: #{numbers}\".split().sort.join(' ')\n</code>\n<|/ a |>\n<| c |>\n`puts`\
    \ automatically adds a newline (if the current file ends in `*.rb`)\n<|/ c |>\n\
    <| c |>\n- I thought the `puts` is just an example to show how to use the methods.\
    \ In most cases, one should not print in the command line. And if the OP wants\
    \ to do this, then it's best to give a complete example (with newline) instead\
    \ of only an example.\n<|/ c |>\n<| c |>\nThe question specifically asks for a\
    \ method that only prints the numbers. I assume that OP knows how to sort a string,\
    \ but doesn't know how to use the `puts` method.\n<|/ c |>\n<| c |>\n: That's\
    \ not a question, it is a statement. Perhaps you should ask the OP to clarify.\n\
    <|/ c |>\n<| c |>\n: Well, it is an example to show the usage of a method. I would\
    \ not use it in a real program. Of course it would be best to show how to call\
    \ the method, but I just wanted to illustrate that it is not needed here.\n<|/\
    \ c |>\n<| a dscore=0 |>\nIn Ruby we have the sort method that does exactly this.\
    \ Here is how you can sort your strings with it:\n<code>", "    numbers.split('\
    \ ').map do |number|\n        number.to_i\n    end.sort!\n    numbers = numbers.join('\
    \ ')\n    numbers.gsub!('zero', '0')\n    numbers.gsub!('one', '1')\n    numbers.gsub!('two',\
    \ '2')\n    numbers.gsub!('three', '3')\n    numbers.gsub!('four', '4')\n    numbers.gsub!('five',\
    \ '5')\n    numbers.gsub!('six', '6')\n    numbers.gsub!('seven', '7')\n    numbers.gsub!('eight',\
    \ '8')\n    numbers.gsub!('nine', '9')\n    numbers\nend", "  numbers = numbers.split('\
    \ ')\n  numbers.sort!\n  return numbers.join(' ')\nend", "  sorted_numbers = \"\
    \"\n  numbers.split(\" \").each do |n|\n    sorted_numbers += \" \" + n.to_i\n\
    \  end\n  sorted_numbers.chop!\n  sorted_numbers.gsub!(\" \", \"\\n\")\n  sorted_numbers.gsub!(\"\
    \\n\", \" \")\n  sorted_numbers\nend\n</code>\nThis code converts everything to\
    \ integers and sorts them from smallest to largest. After sorting we convert them\
    \ back to strings because Ruby cannot sort them directly from a string, but we\
    \ can use a gsub to fix the \\n and space characters to a new line, and back to\
    \ a space to remove the sorting that was performed.\n<|/ a dscore=1 tags=ruby\
    \ |>\n<| c |>\nThis code has multiple problems. For example `sort_numbers.call(\"\
    three one five\")` returns `\"one three five\"`, which is not the case as the\
    \ OP requires.\n<|/ c |>\n<| c |>\nThanks, I missed that part because I misread\
    \ the question. The code could be reworked so that it works, but it's a simple\
    \ and straightforward solution.\n<|/ c |>\n<| c |>\nThanks, I appreciate your\
    \ answer and will make some changes to my original question.\n<|/ c |>\n<| a tags=ruby\
    \ dscore=0 |>\n<code>\nstring = \"one two three four five six seven eight nine\
    \ ten eleven twelve\"", "  numbers = numbers.strip\n  numbers = numbers.split\n\
    \  numbers = numbers.map{|n| n.to_i}\n  numbers.sort!\n  numbers.join\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThank you! I used this in another program and it works perfectly.\
    \ Very helpful!\n<|/ c |>\n<| a tags=sorting,ruby,arrays |>\nJust use sort_by\
    \ method:\n<code>\nnums = [\"two\", \"nine\", \"five\", \"four\", \"eight\", \"\
    one\", \"three\", \"six\", \"seven\", \"zero\"]\nnums.sort_by{|n| n.to_i}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nIt's `sort_by` not `sortBy`, it seems. And `to_i`\
    \ not `to_int`.\n<|/ c |>\n<| a dscore=0 |>\nA method like that should look like\
    \ this.\n<code>", "    numbers.split(\" \").map! {|n| n.to_i}\n    numbers.sort!\n\
    \    return numbers.join(\" \")\nend\n</code>\n<|/ a |>\n<| c |>\nYou will probably\
    \ want to use `sort_by` instead of `sort` - as `sort` will call `sort!` on every\
    \ iteration and return a new array. `sort_by` will return the array sorted as\
    \ it goes, so you only need to call `sort!` once.\n<|/ c |>\n<| c |>\nThanks Ryan,\
    \ I'll change that to `sort_by`. Still new to Ruby, coming from a mostly functional\
    \ background.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  numbers = numbers.split('\
    \ ')\n  numbers.each { |n| n.to_i = n.to_i if n.to_i }\n  numbers.sort!\n  numbers.join('\
    \ ')\nend\n</code>\n<|/ a dscore=0 tags=ruby-on-rails |>\n<| a |>\nYou might want\
    \ to look at https://stackoverflow.com/a/45595885/497418\nTo shorten this answer\
    \ a little:\n<code>", "  numbers.split.each do |n|\n    next if n.empty?\n   \
    \ if n == \"zero\"\n      n = \"0\"\n    elsif n == \"one\"\n      n = \"1\"\n\
    \    elsif n == \"two\"\n      n = \"2\"\n    elsif n == \"three\"\n      n =\
    \ \"3\"\n    elsif n == \"four\"\n      n = \"4\"\n    elsif n == \"five\"\n \
    \     n = \"5\"\n    elsif n == \"six\"\n      n = \"6\"\n    elsif n == \"seven\"\
    \n      n = \"7\"\n    elsif n == \"eight\"\n      n = \"8\"\n    elsif n == \"\
    nine\"\n      n = \"9\"\n    end\n  end\n  numbers\nend", "  sorted_numbers =\
    \ \"\"\n  numbers.split(' ').each do |number|\n    if number == \"nine\"\n   \
    \   sorted_numbers << number\n      sorted_numbers << \" nine\"\n    else\n  \
    \    sorted_numbers << number << \" \" if sorted_numbers.include? number\n   \
    \ end\n  end\n  return sorted_numbers\nend", "  numbers.split(\" \").map { |n|\
    \ case n\n    when /^zero$/   then \"0\"\n    when /^one$/    then \"1\"\n   \
    \ when /^two$/    then \"2\"\n    when /^three$/  then \"3\"\n    when /^four$/\
    \   then \"4\"\n    when /^five$/   then \"5\"\n    when /^six$/    then \"6\"\
    \n    when /^seven$/  then \"7\"\n    when /^eight$/  then \"8\"\n    when /^nine$/\
    \   then \"9\"\n    else n\n  end\n  }.join.downcase\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis is very useful. I am still learning Ruby, so I appreciate\
    \ the help :)\n<|/ c |>\n<| c |>\nIt's a bit of a pain to read, but you get better\
    \ understanding of the Ruby syntax this way. Keep going - it's a very handy language\
    \ to learn.\n<|/ c |>\n<| a tags=ruby,string dscore=0 |>\nI needed this in a project\
    \ and found that I was going to do it in two steps.  This example is based on\
    \ Andrew Williams' answer, but adds the ability to change the separator between\
    \ numbers.  It doesn't sort, but you can change to sort with sort_by!\n<code>",
  "  sorted_numbers = \"\"\n  numbers.each do |number|\n    number = number.to_i\n\
    \    if number >= 0 and number <= 9\n      sorted_numbers << number\n    end\n\
    \  end\n  sorted_numbers.join(\" \")\nend", "  return numbers.split(\" \").sort.join\n\
    end", "  numbers.split.sort.join(' ')\nend", "    numbers = numbers.downcase\n\
    \    numbers = numbers.gsub(' ', '').split\n    numbers.sort!\n    numbers.join\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\n`sort_numbers` is very inefficient.\
    \ It creates a new array on every call and uses `each` instead of `each_with_object`.\n\
    <|/ c |>\n<| c |>\n- good catch. Edited to add `each_with_object`.\n<|/ c |>\n\
    <| a dscore=0 tags=ruby-on-rails,ruby |>\nI liked the other answers so I added\
    \ my own. I also added some code to improve the sorting by counting the digits\
    \ so I can tell the number 5 from 55 because one digit is more important than\
    \ two, three and four.\n<code>", "  numbers.to_s.split(/ +/).sort.join(' ')\n\
    end", "  numbers.split(/\\s+/).sort.join(\" \")\nend", "    numbers.split(\" \"\
    ).sort!\n    numbers.strip!\n    numbers.gsub!(/[0-9]+/) {|s| s.to_i}\n    numbers.gsub!(/0+$/)\
    \ {|s| s.to_i}\n    numbers.gsub!(/-+$/) {|s| s.to_i}\n    numbers\nend", "  numbers.split(\"\
    \ \").sort.join(\",\")\nend", "  sorted_numbers = numbers.split(\" \").map {|n|\
    \ n.to_i}\n  sorted_numbers.sort!\n  sorted_numbers.join(\" \")\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| a dscore=0 tags=ruby |>\nHere is one that uses inject:\n\
    <code>", "  sorted = numbers.split(\" \").sort\n  numbers.delete(\"\")\n  numbers.join(\"\
    ,\")\nend\n</code>\n<|/ a tags=arrays,ruby dscore=4 |>\n<| a tags=arrays,ruby\
    \ |>\n<code>\nnumbers = ['three', 'two', 'four', 'one', 'five', 'six']\nsorted\
    \ = numbers.sort", "  numbers = numbers.to_s.split(' ')\n  numbers.map! { |n|\
    \ n.to_i }\n  numbers.sort!\n  numbers.join(' ')\nend", "  numbers.split(\" \"\
    ).sort.join \" \"\nend", "  numbers = numbers.split(\" \").sort\n  numbers = numbers.join(\"\
    \ \")\n  numbers.gsub!(/^0/, 'nine')\n  numbers.gsub!(/^1/, 'eleven')\n  numbers.gsub!(/^2/,\
    \ 'twelve')\n  numbers.gsub!(/^3/, 'thirteen')\n  numbers.gsub!(/^4/, 'fourteen')\n\
    \  numbers.gsub!(/^5/, 'fifteen')\n  numbers.gsub!(/^6/, 'sixteen')\n  numbers.gsub!(/^7/,\
    \ 'seventeen')\n  numbers.gsub!(/^8/, 'eighteen')\n  numbers.gsub!(/^9/, 'nineteen')\n\
    \  numbers.gsub!(/^t/, 'ten')\n  numbers.gsub!(/^n/, 'nine')\n  numbers.gsub!(/^e/,\
    \ 'eight')\n  numbers.gsub!(/^y/, 'ninety')\n  numbers.gsub!(/^p/, 'one')\n  numbers.gsub!(/^g/,\
    \ 'two')\n  numbers.gsub!(/^b/, 'three')\n  numbers.gsub!(/^f/, 'four')\n  numbers.gsub!(/^s/,\
    \ 'five')\n  numbers.gsub!(/^o/, 'six')\n  numbers.gsub!(/^o/, 'seven')\n  numbers.gsub!(/^o/,\
    \ 'eight')\n  numbers.gsub!(/^o/, 'nine')\n  numbers\nend\n</pre>\n<h3 id=\"ruby-version\"\
    >Ruby version</h3>\n<pre class=\"ruby\">", "  numbers = numbers.split(/\\s+/)\n\
    \  numbers = numbers.map(&:to_i)\n  numbers.sort!\n  numbers.map { |n| \"%02d\"\
    \ % n }.join(\" \")\nend", "  return numbers.split(\" \").sort_by(&:to_i).join(\"\
    \ \")\nend", "  numbers = numbers.split(\" \").map { |n| n =~ /^\\d$/ ? n.to_i\
    \ : n }\n  numbers.sort!\n  numbers.reverse!\n  numbers.join(\" \")\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails,sorting,algorithm |>\n<| c |>\nThis one is pretty\
    \ cool. I was thinking of doing it in Ruby without using any loops, but this one\
    \ is awesome. Thanks! But I do have to say I do prefer the other Ruby answers.\
    \ Thanks again :) It does make my code more readable, which I like.\n<|/ c |>\n\
    <| a |>\nThis is a perfect candidate for inject (thanks to for pointing it out!).\
    \ Here's my solution in pure Ruby:\n<code>", "  number_arr = numbers.split(\"\
    \ \")\n  number_arr = number_arr.map {|x| x.to_i}\n  number_arr.sort!\n  number_arr.join\n\
    end\n</pre>\n</div>", "  # Your code goes here\n  numbers\nend\n</cell>\n<cell>",
  "  numbers.gsub!(' ', '').gsub!(',', '').to_s.split\n  numbers.sort!\n  numbers.join\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis was a great solution, thank you\
    \ so much.", "  sorted_numbers = numbers[0].split(\" \").sort.join(\" \")\n  sorted_numbers\
    \ += \" \" if sorted_numbers.index(\"  \") == -1 else \" \"\n  sorted_numbers\
    \ += numbers[1].split(\" \").sort.join(\" \")\n  return sorted_numbers\nend",
  "  numbers.split(\" \").reverse.sort.join(\" \")\nend\n</code>\n<|/ a tags=ruby\
    \ dscore=2 |>\n<| a tags=ruby dscore=0 |>\n<code>", "  numbers.split(' ').sort!\n\
    \  numbers.join(' ')\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
