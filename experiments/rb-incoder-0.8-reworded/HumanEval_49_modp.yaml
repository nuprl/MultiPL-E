name: HumanEval_49_modp
language: rb
prompt: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp.call(3, 5)\n# 3\n\
  # >>> modp.call(1101, 101)\n# 2\n# >>> modp.call(0, 101)\n# 1\n# >>> modp.call(3,\
  \ 11)\n# 8\n# >>> modp.call(100, 101)\n# 1\ndef modp(n, p)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
  \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2,\
  \ candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8,\
  \ candidate.call(3, 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4,\
  \ candidate.call(30, 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
completions: ["\treturn n^(-n)*p\nend", "  return n.modulo(p)\nend", "\twhile n !=\
    \ 0\n\t\tn = (n+1)%p\n\treturn n\nend\n\t", "  return 2**(n - p) % p\nend", " \
    \ return n ** n % p\nend", "  x % p\nend", "  n = n.to_i\n  p = p.to_i\n  while\
    \ n > p\n    n = n % p\n  end\n  n\nend", "\treturn ((pow(n, p, p) + pow(n, p-3,\
    \ p)) * p) % p", "  x =  n\n  while x != 0\n    x %= p\n  end\n  x\nend", "  n\
    \ = n.to_i\n  p = p.to_i\n  res = n.divmod(p)[0]\n  res *= -1 if n < 0 && !n.zero?\
    \ && p < 0 && !p.zero? # negative, negative modulo\n  res\nend", "  return ((n\
    \ // p) ^ (n % p))\nend", "  return pow(n, p % 2, p)\nend", '  return ((n // p)
    * p) % p', '  return ((n % p + p) % p) if p != 0 else n', "  m =  (n & (p-1))\
    \ \n  m1 = n ^ (m|1)\n  n1 = n ^ (m|2)\n  n2 = n ^ (m|4)\n  n3 = n ^ (m|8)\n \
    \ n4 = n ^ (m|16)\n  n5 = n ^ (m|32)\n  n6 = n ^ (m|64)\n  n7 = n ^ (m|128)\n\
    \  return m << n | m1 | n1 | n2 | n3 | n4 | n5 | n6 | n7\nend", "  return 2**((n%p)*(p-1))\
    \ unless p == 0\n  return n%p\nend", "  m == 0 ? (p == 1 and n > 0 and n == 1)\
    \ or n == 0 : (n != 0 and (n and n or n) == 0 and 1 or n % p)\nend\n</code>\n\
    <|/ a tags=ruby,modulo,math,algorithm |>\n<| c |>\nThis is essentially a duplicate\
    \ of [this question](http://stackoverflow.com/questions/3719885/modulus-remainder-calculation).\
    \ See [my answer](http://stackoverflow.com/a/33545439/1258801) there for more\
    \ details.\n<|/ c |>\n<| c |>\nI don't think you got the point of the question.\
    \ The question you refer to doesn't have anything to do with calculating modulus\
    \ after you get a division.\n<|/ c |>\n<| c |>\nOkay I'm still not getting it.\
    \ I need to get `5 % 4 = 3`, `4 % 3 = 1`, `3 % 2 = 1`, `5 % 3 = 2`, `4 % 2 = 2`,\
    \ `3 % 2 = 2`, etc. until I get `1`. That's all I need :) But I think I'm going\
    \ to go with that approach because it's simpler and faster. And my problem would\
    \ be solved by that.\n<|/ c |>\n<| c |>\nIf it's that simple, just use the solution\
    \ from my answer.\n<|/ c |>\n<| c |>\nThat answer doesn't work for me. As I said,\
    \ I need to do `5 % 4 = 3`, `4 % 3 = 1`, `3 % 2 = 1`, `5 % 3 = 2`, `4 % 2 = 2`,\
    \ `3 % 2 = 2`, etc. until I get `1`. So I need to do that for different numbers.\
    \ Maybe I should clarify that in my question. I'll edit my question right now.\n\
    <|/ c |>\n<| a |>\nThis is what you need to do,\n<code>", "  # Python 3 has __pow__,\
    \ Python 2 has pow().\n  # Use __pow__ if available, otherwise use pow().\n  if\
    \ p >= 2\n    return pow(n, p)\n  else\n    return n.__pow__(p)\n  end\nend",
  "  if n == 0: return 0\n  x = n\n  residual = x\n  while x % p != 0\n    x = x //\
    \ p\n    residual = (residual * p + x) % p\n  return residual\nend\n@test modp(3,\
    \ 10) == 3\n@test modp(1101, 101) == 2\n@test modp(0, 101) == 1\n@test modp(3,\
    \ 11) == 8\n@test modp(100, 101) == 1", '  return ((n%p) + p) % p', "  (p ** n)\
    \ % p\nend", "  # From http://graphics.stanford.edu/~seander/bithacks.html#ModPow\n\
    \  x = 0\n  while n > 0, (x <<= 1, n), n >>= 1\n  x -= n & 1\n  x %= p\n  return\
    \ x", "  if n < 0\n    n += p\n  a = p\n  while n > 0\n    a, n = a % n, n-1\n\
    \  end\n  return a\nend", "  if n < 0:\n    return 0\n  result = 0\n  while n\
    \ != 0:\n    if p > n:\n      result += 1\n      n -= p\n    p -= n\n    n //=\
    \ p\n  return result\nend", "  m = 1\n  while n and p > 1\n    if n < p\n    \
    \  m <<= 1\n      n -= 1\n    else\n      m >>= 1\n      p >>= 1\n  end\n  m\n\
    end", "    if p <= 0 then\n        raise ModularInteger(\"modp: \"+p+\" is <=\
    \ 0\")\n    return 1\nend", '  return ((n * p + 1) // p) % p', "  (n, remainder)\
    \ = divmod(n, p)\n  (remainder, quotient) = divmod(remainder, p)\n  (quotient,\
    \ modulus) = divmod(quotient, p)\n  if modulus == 0\n    quotient\n  else\n  \
    \  modulus\n  end\nend", "  return ((n%p)+p) % p\nend", "  return ((n % p) + p)\
    \ % p\nend", "  x = n * p\n  x = x % p\n  if x > n\n    x = (x - p) % p\n  end\n\
    \  x\nend", '  return ((p-1)*n%p)', '  return n & (-p) == 0 and n or -n & p',
  "  x = 0\n  while n < 0\n    x += 1\n    n += p # this might overflow if n is large\n\
    \  x = n / p\n  x %= p\n  if x == 0\n    x == 1\n  else \n    x\n  end\nend",
  "  if n < 0\n    n = -n\n    return modp(1 + n, p)\n  result = 1\n  while n > p\n\
    \    n -= p\n    result += 1\n  end\n  return result\nend", "\tr = 1\n\twhile\
    \ n > p do\n\t\tr = r * 2\n\t\tn = n / p\n\tend\n\treturn r\nend", "  ((n % p)\
    \ + p) % p\nend", "  r = 1\n  while n > 0\n    r = r * n % p\n    n = n / p\n\
    \  r\nend", "  n = (n + p) % p\n  if n < 0\n    n = p + n\n  end\n  n\nend", '  return
    ((n % p) + p) % p', '  return ((n % p) + p) % p', "\tx = 1\n\twhile n > p do\n\
    \t\tx = (x * 3) % p\n\t\tn = n >> 1\n\tend\n\treturn x\nend", "  return p == 0\
    \ ? n : ((n - (n % p)) % p)\nend", "  return n ** p % p\nend\n</cell>\n<code language=julia-1.3>",
  "  raise 'Not implemented'", "  return ((n >> p) ^ n) & -p\nend", "  # The algorithm:\
    \ return the greatest number that is a multiple of\n  # p that is less than or\
    \ equal to n.\n  # e.g. mod(5, 3) = 1 (mod 3)\n  #      mod(7, 4) = 3 (mod 4)\n\
    \  #      mod(11, 4) = 1 (mod 4)\n  #      mod(11, 8) = 4 (mod 8)\n  # The algorithm:\
    \ we compute the greatest number that is a multiple\n  # of p that is less than\
    \ or equal to n. For example, if p is 4\n  # we always get 4 back, even if n was\
    \ 6.\n  # From the paper:\n  # \"Given a positive integer n, consider the number\
    \ to be a multiple\n  # of p if there exists a number q greater than n such that\
    \ p divides\n  # q. For example, if q is 4, then a multiple of 4 could be 12,\
    \ since\n  # 12 > 4. Thus 4 can be written as the sum of the digits in the decimal\n\
    \  # representation of n, excluding the rightmost digit. If p is 100,\n  # then\
    \ 100 is such a number, and since 12 is the largest possible\n  # multiple of\
    \ 100,\n  # a multiple of 4 must exist.\n  # Let us consider a sample number which\
    \ is multiple of 3.\n  # It can be written as the sum of digits of n (without\
    \ the\n  # rightmost digit, i.e. the number without its rightmost digit\n  # is\
    \ 3).\n  # The largest multiple of 3 which can be written as the sum\n  # of digits\
    \ of n is also the largest multiple of 3 which can be\n  # written as the sum\
    \ of the digits of the number without any of\n  # its rightmost digits, which\
    \ is 3. The congruence of the\n  # properties of modular arithmetic tells us that\
    \ any such number\n  # will be a multiple of 3.\n  if n == 0\n    0\n  elsif n\
    \ == 1\n    1\n  elsif p == 0\n    n\n  elsif p == 1\n    (n * 3)\n  elsif p ==\
    \ 100\n    (n / 100)\n  elsif p == 1000\n    (n / 1000)\n  elsif p == 10000\n\
    \    (n / 10000)\n  elsif p == 100000\n    (n / 100000)\n  elsif p == 1000000\n\
    \    (n / 1000000)\n  else\n    raise \"Don't know how to compute modular power\
    \ with prime and modulus prime\"\n  end\nend", "  n = n.to_i\n  p = p.to_i\n \
    \ n %= p\n  if n < 0\n    n = (p + n) % p\n  end\n  n\nend", "  if p == 0 then\
    \ raise ZeroDivisionError\n  if n == 0 then return 1\n  if p < 0 then return 0\n\
    \  if n >= p-1 then return 1\n  if n % p != 0 then return 0\n  return modp(n div\
    \ p, p)\nend", '  return ((n % p) + p) % p', "  if n%p == 0 or n%p==1:\n    return\
    \ n\n  k = p\n  i = 1\n  while (n//i*i & 1) == 0: k = k*i\n  return (k//p) * p",
  "  n = n.abs\n  return ((p-1)/n).floor.abs if n != 0 else\n    (n/n).floor.abs if\
    \ n > 0 else\n      n.ceil.abs", "  n = n.abs % p\n  n = (n < 0) ? n + p : n\n\
    \  n = (n > p) ? n - p : n\n  n\nend", "  n = (n or 0) % p\n  return n and n *\
    \ p + (n and n-1) * p\nend", "  p -= 1\n  r =\n    while n > 0\n      r *= n\n\
    \      n -= 1\n      p += 1\n      r %= p\n  end\n  r\nend", "    return ((n %\
    \ p) + p) % p\nend", "  return n%(2**(p*-1))\nend", "  n = (n.abs << p).mod(p)\n\
    \  (n = n + (2 * p) - 1) & p\n  return n\nend", '  return ((n % p) + p) % p',
  "\tnr, nc, nm, np = n, n, n, p\n\tr0, c0, nr, nc, np = p, n, nm, np\n\tr1, c1, r2,\
    \ c2, np = p, p, nr, nc, np\n\tr3, c3, r4, c4, np = p, p, nr, nc, np\n\tr5, c5,\
    \ r6, c6, np = p, p, nr, nc, np\n\tr7, c7, r8, c8, np = p, p, nr, nc, np\n\tr9,\
    \ c9, r10, c10, np = p, p, nr, nc, np\n\tr11, c11, r12, c12, np = p, p, nr, nc,\
    \ np\n\tr13, c13, r14, c14, np = p, p, nr, nc, np\n\tr15, c15, nr, nc, np = p,\
    \ p, nm, np\n\tr16, c16, r17, c17, np = p, p, nm, np\n\tr18, c18, r19, c19, np\
    \ = p, p, nm, np\n\tr20, c20, r21, c21, np = p, p, nm, np\n\tr22, c22, r23, c23,\
    \ np = p, p, nm, np\n\tr24, c24, r25, c25, np = p, p, nm, np\n\tr26, c26, r27,\
    \ c27, np = p, p, nm, np\n\tr28, c28, r29, c29, np = p, p, nm, np\n\tr30, c30,\
    \ r31, c31, np = p, p, nm, np\n\tr32, c32, r33, c33, np = p, p, nm, np\n\tr34,\
    \ c34, r35, c35, np = p, p, nm, np\n\tr36, c36, r37, c37, np = p, p, nm, np\n\t\
    r38, c38, r39, c39, np = p, p, nm, np\n\tr40, c40, r41, c41, np = p, p, nm, np\n\
    \tr42, c42, r43, c43, np = p, p, nm, np\n\tr44, c44, r45, c45, np = p, p, nm,\
    \ np\n\tr46, c46, r47, c47, np = p, p, nm, np\n\tr48, c48, r49, c49, np = p, p,\
    \ nm, np\n\tr50, c50, r51, c51, np = p, p, nm, np\n\tr52, c52, r53, c53, np =\
    \ p, p, nm, np\n\tr54, c54, r55", "  return ((n-1)//p + 1) & (p-1)\nend", "  n.to_s.each_byte.inject(0)\
    \ do |res, byte|\n    byte.zero? ? res : (res << 1) | (byte & 1)\n  end.remainder(p).to_i\n\
    end", "  if ((n < 0) or ((n % p) == 0))\n    return 0\n  m = n - (n >> 1) // p\n\
    \  res = m * (m << 1) + 1\n  if ((n % p) == 0)\n    return res\n  else:\n    return\
    \ res", "  if n < 0 or n % p == 0 or n % p == -p\n    return 0\n  k =\nend\n</code>\n\
    <|/ a |>\n<| c |>\nYeah, I forgot that bitwise operations on integers don't have\
    \ a `mod` method. I was trying to come up with a way to calculate it myself (just\
    \ like how I calculate exponents for decimal numbers in school). But I guess it\
    \ would be better to rethink the problem and use some other approach. Thanks for\
    \ the great answer.\n<|/ c |>\n<| c |>\nThe problem is actually quite simple to\
    \ solve: it's just a matter of computing the greatest common divisor.\n<|/ c |>\n\
    <| c |>\nThe first and second test cases don't do what you think. They test the\
    \ same thing twice each. Be careful if you're trying to debug this.\n<|/ c |>\n\
    <| c |>\nSorry, I was wrong about the test cases. They should return \"1\" for\
    \ both calls, but they don't. The second test case should return \"1\" and the\
    \ third should return \"5\". I'll edit the answer to fix this (I missed the second\
    \ call in the second test case). Thanks for the notice, I didn't catch it before.\n\
    <|/ c |>\n<| c |>\nI fixed the second and third test cases, and the first one\
    \ still does not work (but I don't have time to debug it right now).\n<|/ c |>\n\
    <| a tags=math,ruby,algorithm |>\nYour second method should be as follow:\n<code>",
  "  remainder = n % p\n  newMod = n - (remainder * p / p)\n  if newMod > 0\n    nextNewMod\
    \ = modp(newMod, p)\n  else\n    nextNewMod = newMod\n  end\n  return nextNewMod\n\
    end", '  return p ** n % p', "  # If n is negative or 0 return 0.\n  if n <= 0\
    \ then\n    return 0\n  # If n is positive, return n^p % p.\n  elseif n >= p then\n\
    \    return n\n  # The last bit of n is 1. Let the result of (n^p % p) be n.\n\
    \  # The result should be even.\n  else\n    return modp(n xor 1, p) + n and n\
    \ and 0\n  end\nend", "  n = n % p\n  p %= p\n  if n < 0\n    n = -p + n\n  end\n\
    \  n %= p\n  if n == 0\n    n = 1\n  end\n  return n\nend", '  return ((n % p)
    + p) % p', "  if n < 0 or n >= p\n    raise TypeError, \"not positive integer\"\
    \n  x = 1\n  while n > 1\n    x, y = y, x % p\n    n /= p\n  end\n  return x\n\
    end", "  n = n.to_i\n  p = p.to_i\n  while n > p do\n    n -= p\n    p += 1\n\
    \  end\n  n\nend", "  return ((n & 0xffffffff) % (p + 1)) if (n < p) else\n  \
    \  ((n >> 32) + (n - 1)) & (p - 1)", "\treturn ((p % n == 0) and n or 0) ^ ((n\
    \ & -p) == p & -n)\nend", "  return ((p-1)*n+p) % p\nend", '  return n - (n %
    p) / p', "  n = 2 ** n % (p-1)\n  return n\nend", "  return n & (-p) if ((n <\
    \ 0) or (n & p) != n) else n\nend", "  n0 = n & -p\n  n1 = ((n >> 32) & -p) -\
    \ p\n  n2 = ((n >> 64) & -p) - p\n  n3 = ((n >> 128) & -p) - p\n  n4 = ((n >>\
    \ 256) & -p) - p\n  n5 = ((n >> 512) & -p) - p\n  n6 = ((n >> 1024) & -p) - p\n\
    \  n7 = ((n >> 2048) & -p) - p\n  n8 = ((n >> 4096) & -p) - p\n  n9 = ((n >> 8192)\
    \ & -p) - p\n  n10 = ((n >> 16384) & -p) - p\n  n11 = ((n >> 32768) & -p) - p\n\
    \  n12 = ((n >> 65536) & -p) - p\n  n13 = ((n >> 131072) & -p) - p\n  n14 = ((n\
    \ >> 262144) & -p) - p\n  n15 = ((n >> 524288) & -p) - p\n  n16 = ((n >> 1048576)\
    \ & -p) - p\n  n17 = ((n >> 2097152) & -p) - p\n  n18 = ((n >> 4194304) & -p)\
    \ - p\n  n19 = ((n >> 8388608) & -p) - p\n  n20 = ((n >> 16777216) & -p) - p\n\
    \  n21 = ((n >> 33554432) & -p) - p\n  n22 = ((n >> 67108864) & -p) - p\n  n23\
    \ = ((n >> 134217728) & -p) - p\n  n24 = ((n >> 268435456) & -p) - p\n  n25 =\
    \ ((n >> 536870912) & -p) - p\n  n26 = ((n >> 1073741824) & -p) - p\n  n27 = ((n\
    \ >> 2147483648) & -p) - p\n  n28 = ((n >> 4294967296) & -p) - p\n  n29 = ((n\
    \ >> 8589934592) & -p) - p\n  n30 = ((n >> 17179869184) & -p) - p\n  n31 = ((n\
    \ >> 3584511888) & -p) - p\n  n32 = ((n >> 7670082160) & -p) - p\n  n33 = ((n\
    \ >> 14073748832) & -p) - p\n  n34 = ((n >> 281474976768) & -p) - p\n  n35 = ((n\
    \ >> 562949953472) & -p) - p\n  n36 = ((n >> ", "  n = n.to_i\n  p = p.to_i",
  "  n, p = abs(n), abs(p)\n  while n >= p\n    n -= p\n  end\n  return n\nend\nfunction\
    \ div(n,d)\n  d = int(d)\n  n = int(n)\n  if d == 0\n    return 0\n  elsif d ==\
    \ 1\n    return n\n  end\n  while n > 0\n    r = n % d\n    n -= r\n    d /= d\n\
    \  end\n  return d\nend", "  return pow(n, p % p + 1, p)\nend", "\treturn ((n%p)\
    \ + p) % p\nend", '  return ((n % p) + p) % p', "  n = n.abs\n  p = p.abs\n  rem\
    \ = n % p\n  if rem == 0\n    return n\n  else\n    return n+(p - rem).div(p)\n\
    end", "  if p == 0: return 1\n  if n == 0: return 0\n  if n < 0: n = -p\n  k =\
    \ n\n  while k > p / 2\n    k = k - 1\n  return k", "  n = (n.floor * p) % p\n\
    \  n += 0 if n < p else p - n\n  n\nend", "  r1, r2 = n % p, p % n\n  n -= r1\n\
    \  p -= r2\n  return n if n < 0 else r2 if r2 < 0 else r1\nend\n</code>\n<|/ a\
    \ dscore=4 |>\n<| c |>\nI suspect this doesn't work when `p` is negative.  At\
    \ the least it isn't obvious how to generalize this for any `p`.\n<|/ c |>\n<|\
    \ c |>\nI agree. `modp.call(10, 10)` should return 0 instead of 10.\n<|/ c |>\n\
    <| c |>\nI updated my answer to fix this issue.  I tested my code above with the\
    \ correct result for positive values of `p`.\n<|/ c |>\n<| c |>\nThis answer was\
    \ edited to fix a typo in the calculation of `p` modulo `n`.  It now returns the\
    \ correct results for positive values of `p`, as well as for negative values of\
    \ `n`.\n<|/ c |>\n<| c |>\nThe `mod` function can be simplified to: `function\
    \ mod(n, p)\n  r1, r2 = n % p, p % n\n  n -= r1\n  p -= r2\n  return n if n <\
    \ 0 else r2 if r2 < 0 else r1\nend`. Note the use of \"else\" where you wrote\
    \ \"elsif\".\n<|/ c |>\n<| a tags=number-theory,modulo,ruby,math,ruby-on-rails\
    \ |>\n<code>", "  r = (n % p) + p\n  r % p\nend", "  n = n.abs()\n  return p -\
    \ (p.abs % n)\nend", "  return ((p % n) + n) % p\nend", "    return n & (p-1)\n\
    end", "  n %= p\n  if n < 0 then\n    n + p\n  else\n    n\n  end\nend", "\treturn\
    \ ((n%p)+p) % p", "  ni, nr = n.divmod(p)\n  r = ni >> 1\n  if ni == 0 or nr ==\
    \ 0: return r\n  if r < 0: return modp(nr, p)\n  return r", '  return ((n & -p)
    + p) % p', "  n, p = nativeInt(n), nativeInt(p)\n  if p == 0\n    return 0\n \
    \ if p == 1 or n == 0\n    return 1\n  if n <= -p\n    return 0\n  # Fatal error\n\
    \  raise TypeError, \"modp() only accepts positive integers smaller than \" +\
    \ \\\n    \"-\" + (-p-1) + \"; \" + n + \" is not a positive integer.\"", '  return
    ((n-1)%p + p) % p', "  if n < 0\n    return n - (n >> 1) + 1\n  m = 1\n  while\
    \ n > p\n    n //= p\n    m += 1\n  return m > 1 or m == 1 and n or n", "  return\
    \ ((n) % (p + 1))\nend\nfunction modp_int(n, p)\n  return modp(n, p).round\nend",
  '  return ((n >> p) + 1) & -p', "  return ((n % p) + p) % p\nend", "  r =(n)%p\n\
    \  if r<0\n    (r+=p) while (r>0)\n    r=(p-(r+p))%p\n  end\n  return r\nend",
  "  power = 1\n  while n >= p\n    n -= p\n    power *= p\n  end\n  power\nend",
  "  n, rem = divmod(n, p)\n  if rem == 0, n = p\n  else, n, rem = divmod(n, p)\n\
    \  if rem == 0, n = p\n  else, n, rem = divmod(n, p)\n  if rem == 0, n = p\n \
    \ else, n, rem = divmod(n, p)\n  if rem == 0, n = p\n  else, n, rem = divmod(n,\
    \ p)\n  if rem == 0, n = p\n  else, n, rem = divmod(n, p)\n  if rem == 0, n =\
    \ p\n  else, n, rem = divmod(n, p)\n  if rem == 0, n = p\n  else, n, rem = divmod(n,\
    \ p)\n  if rem == 0, n = p\n  else, n, rem = divmod(n, p)\n  if rem == 0, n =\
    \ p\n  else, n, rem = divmod(n, p)\n  if rem == 0, n = p\n  else, n, rem = divmod(n,\
    \ p)\n  if rem == 0, n = p\n  else, n, rem = divmod(n, p)\n  if rem == 0, n =\
    \ p\n  else, n, rem = divmod(n, p)\n  if rem == 0, n = p\n  else, n, rem = divmod(n,\
    \ p)\n  if rem == 0, n = p\n  else, n, rem = divmod(n, p)\n  if rem == 0, n =\
    \ p\n  else, n, rem = divmod(n, p)\n  if rem == 0, n = p\n  else, n, rem = divmod(n,\
    \ p)\n  if rem == 0, n = p\n  else, n, rem = divmod(n, p)\n  if rem == 0, n =\
    \ p\n  else, n, rem = divmod(n, p)\n  if rem == 0, n = p\n  else, n, rem = divmod(n,\
    \ p)\n  if rem == 0, n = p\n  else, n, rem = divmod(n, p)\n  if rem == 0, n =\
    \ p\n  else, n, rem = divmod(n, p)\n  if rem == 0, n = p\n  else, n, rem = divmod(n,\
    \ p)\n  if rem == 0, n = p\n  else, n, rem = divmod(n, p)\n  if rem == 0, n =\
    \ p\n  else, n, rem = divmod(n, p)\n  if rem == 0, n = p\n  else, n, rem = divmod(n,\
    \ p)\n  if rem == 0, n = p\n  else, n, rem = divmod(n, p)\n  if rem == 0, n =\
    \ p\n  else, n, rem = divmod(n, p)\n  if rem == 0, n = p\n  else, n, rem = divmod(n,\
    \ p)\n  if rem == 0, n = p\n  else, n, rem = divmod(n, p)\n  if rem == 0, n =\
    \ p\n  else, n, rem = divmod(n, p)\n  if rem == 0, n = p\n  else, n, rem = divmod(n,\
    \ p)\n  if rem == 0, n = p\n  ", "  return pow(n, p % 2, p)\nend", "  return ((n\
    \ % p) + p) % p\nend", "  if n <= 0\n    throw ZeroDivisionError, \"division by\
    \ zero\"\n  elsif n <= p\n    n\n  else\n    (n - 1) % p + 1\n  end\nend", " \
    \ return ((n % p + p) % p) % p\nend", "  return ((p * pow(2, n))%p)\nend", " \
    \ return ((n % p) + p) % p\nend", "  if n < 0\n    p -= 1\n    n, p = n*p, p\n\
    \  end\n  while p > 0\n    n, p = n%p, p-1\n  end\n  return n\nend", "  return\
    \ p if n.zero?\n  ((n.bit_length + (n>>1).bit_length) % p.bit_length + p.bit_length)\
    \ % p\nend", "  n & (p - 1)\nend", "  raise \"This is not the correct implementation\"\
    \nend", '    return n & (p-1)', '  return ((n % p) + p) % p', "  n%p ? r = 0\n\
    \  while n%p != 0\n    r = n + (r*2)%p\n    n /= p\n  end\n  r\nend", "  return\
    \ ((p % n) + n) % n\nend", "  n = n.abs # coerce n to integer\n  p = p.abs # coerce\
    \ p to integer\n  while n > p\n    n -= p\n    n %= p\n  return n\nend\n</code>\n\
    You can see the output here:\n<code>\nrequire 'set'", "  r = 1\n  while n > 0\n\
    \    r = (r*n) % p\n    n -= 1\n  end\n  r\nend", "  return n % p\nend", "  n\
    \ = (n.to_i if n.kind_of? Integer\n        then n else Bignum(n))\n  p = Bignum(p)\n\
    \  return 2 ^ n.modulo(p)\nend", "  return pow(n, (p - 1) // p, p)\nend", "  r\
    \ = 1\n  while ((n >> 1) > 0)\n    r <<= 1, n >>= 1\n  while ((p >> 1) > 0)\n\
    \    p >>= 1, r >>= 1\n  if ((n & 1) == 0)\n    r = p if (r == 1)\n  r\nend",
  "  n = n.abs()\n  p = p.abs()\n  while n > p\n    n = n / p\n    p = p / p\n  end\n\
    \  return n\nend", "  return n & (p-1)\nend", '  return ((n % p) + p) % p', " \
    \ return ((n & -p) | ((n | -p) & ((n | p) | (n & p)))).to_i\nend", "  n %= p\n\
    \  if n < 0 then\n    n += p\n  end\n  return n\nend", "  return n % p\nend",
  '  return n.bit_length >= (p - 1).bit_length ? n % p + p : n % p', "  n0 = n & (-p\
    \ + 1)\n  n1 = (n >> 1) & (-p + 1)\n  if n0 == 0 == n1\n    n, p = 0, 0\n  else\n\
    \    n |= -p\n    n1 = (n1 << 1) & -p\n  end\n  n = (n + n1) & -p\n  if p == 0\n\
    \    return n\n  end\n  n1, p = p >> 1, p\n  n1, n = (n1 << 1) & -p, n\n  n1,\
    \ n = n >> 1, n\n  n1 = (n1 >> 1) & -p, n1\n  n1, n = n >> 1, n\n  n1 = (n1 >>\
    \ 1) & -p, n1\n  n1, n = n >> 1, n\n  n1 = (n1 >> 1) & -p, n1\n  n1, n = n >>\
    \ 1, n\n  n = (n + n1) & -p\n  return n\nend", "  return n.bit_length % p == 0\n\
    end", "  n = n.to_i\n  p = p.to_i\n  return ((1 << (n.bit_length()-1)) + n).modulo(p)\n\
    end", '  return ((n & (p-1)) ^ n)', '  return ((n % p) + p) % p', "  r = (n >>\
    \ p) & 1\n  s = n ^ (n >> p)\n  return (((r * s) + 1) ^ (((r * s) + p) - 1))\n\
    end", "  r = 1\n  while n != 0\n    r = r * p % n\n    n = n >> 1\n  end\n  return\
    \ r\nend", "  mod =\n    if n % p == 0\n      n\n    else\n      modp.call(n,\
    \ p - 1)\n  end\n  mod\nend", "  if n == 0: return p\n  return modp(n // p, p\
    \ * p) % p", "  r =  n % p\n  if r == 0\n    r = p\n  end\n  r\nend", '    return
    ((n << p) & n) if n != 0 else 0', '  return ((n % p) + p) % p', "  m = n\n  p\
    \ -= 1\n  while p >= 1\n    m = (m * n) % p\n    p -= 1\n  end\n  m\nend", " \
    \ if p == 0\n    return 0\n  n = n - p\n  n = (n / p) % p\n  n += 1 if n % 2 else\
    \ 0\n  return n\nend", '  return 2**(n%p) if n and p else 1', '  return ((n &
    -p) + 1) & -p', '  return n if n < p else mod((n - p) % p + p, p)', '  return
    ((n ** p) % p) if (n and p) else 0', "  while n > p\n    n -= p\n    p %= n\n\
    \  n\nend", '  return ((n % p) + p) % p', "\tp |= 1\n\treturn ((n & 0xFF)^((n\
    \ & 0xFF)<<8)^((n & 0xFF)>>8^((n&0xFF)<<24^((n&0xFF)<<32^((n&0xFF)<<40^(n&0xFF)<<48^(n&0xFF)<<56)))\
    \ ^ p)\nend", "  return rshift(shift(n), p)\nend", "\tn = n.to_i\n\tp = p.to_i\n\
    \tif n < 0 \n\t\tn = -n\n\t\tp = -p\n\t\n\tr = n.divmod(p)\n\tr = r[1] if r[0]\
    \ >= 0 else r[0], r[0] % p\n\t\n\treturn r[0].to_s(10)\nend", "  ret = p % n\n\
    \  return 0 if n < 0 else ret\nend", "  if n == 0 then\n    return 1\n  end\n\
    \  return mod((n % p) + 1, p) * p\nend", "  r = 1\n  while n != 0\n    r, n =\
    \ r * p % n, n\n  r\nend", "  return ((n&-p) | ((n^(p-1))&-p)) % p\nend", "  return\
    \ n & (-p).to_s(2)\nend", "\treturn ((n // p) ^ p) % p", "  return ((n & (p-1))\
    \ ^ n) if (p < 4) else ((n & (p-2)) ^ (n & (p-1)))\nend", "  n = n.to_i\n  p =\
    \ p.to_i\n  return n == 0 ? 1 : n % p\nend\nend", "  m = 1\n  while n > 0 and\
    \ m <= p\n    m = 2 * m\n    n /= p\n  m\nend", "  return pow(2, n % p) & p\n\
    end", "  ((n % p) + p) % p\nend", '  return n - ((n % (p + 1))) if n >= 0 else
    ((n % (p)) + (n % (p + 1))) ', "  if n == 0: return 0\n  if n == 1: return 1\n\
    \  if n < 0: n = -n\n  if p < 0: p = -p\n  if n < 1: return ((-p) ** n) / p\n\
    \  if n > 1: return ((p ** n) % (p ** n)) / p\n  return p", "  r = n.modulo(p)\n\
    \  if r != 0\n  else\n    r = p.modulo(n)\n  r = r.to_i\nend", "  # http://codegolf.stackexchange.com/questions/122/the-most-elegant-way-to-exponentiate-a-number-into-its-square-root\n\
    \  return ((n ** 0.5) * p) % p\nend", "  return ((n % p) + p) % p\nend\n</code>\n\
    <|/ a |>\n<| c |>\nWhy are you using the `%` operator? It seems like a pretty\
    \ inefficient way to do `% p`, especially since you're doing it twice - once in\
    \ `mod` and `n%p`, once in `modp`.\n<|/ c |>\n<| c |>\n: It's faster than the\
    \ `%` operator. Because of the way `%` works, it can be faster than `+` too. Also,\
    \ the first `mod` avoids an error if the second operand is 0. Also, it avoids\
    \ having to cast to a `BigInt` (`BigInt(n)` would be faster than `Int(n)` too).\n\
    <|/ c |>\n<| c |>\n: Because `%` requires two multiplications, two divisions and\
    \ one addition. `%` can be faster than `+` because it doesn't have to do any of\
    \ that.\n<|/ c |>\n<| c |>\n: Also, `BigInt` isn't that fast, but `Bignum` is.\n\
    <|/ c |>\n<| c |>\n: I agree that `BigInt` is faster. But in this case it isn't\
    \ necessary because the OP won't be doing any calculations with it anyway. Big\
    \ numbers aren't necessary either, but they make things easier in the case where\
    \ they do have to do any calculations.\n<|/ c |>\n<| a dscore=2 tags=ruby |>\n\
    I recently asked a question that essentially boils down to: \"How can I find the\
    \ factorial of a large number in ruby?\" and I think I'm going to answer it. \
    \ \nThe most fastest way to calculate the factorial in a Ruby program is to use\
    \ recursion:\n<code>", "  return n ** p.bit_length % p\nend", "  n %= p\n  if\
    \ n < 0 then return p else return n\nend", "  r = 1\n  while n != 0\n    r = r\
    \ * p % n\n    n /= 10\n  end\n  r\nend\n</code>\nAnd then we can define our modulus\
    \ function like this:\n<code>", '  return ((n&p)+1)|p', "  r = 1\n  while n >\
    \ 0 and n & (n - 1) == 0 and n > p\n    r <<= 1\n    n >>= 1\n  r %= p\n  r ==\
    \ 0 and 1 == 0 and raise \"modp() too small\"\n  r\nend", '  return 2**n % p',
  "  rem = n\n  mod_shift = 1\n  while (not (rem & p)) do\n    rem >>= mod_shift\n\
    \    mod_shift *= 2\n  end\n  return rem\nend", "  if n < 0\n    n += p\n    p\
    \ = -p\n  end\n  n = (n + p) % p\n  return n\nend", "\treturn mod(pow(2, n, p),\
    \ p)\nend", '  return ((n % p) + p) % p', '  return ((n % p) + p) % p', '  return
    ((n % p) + p) % p', '  return ((n % p) + p) % p', "  m = (n >> p) & 1\n  r = (n\
    \ % p) & m\n  if r == m\n    r, = n.to_s(16).rpartition(/(\\d*)/).to_a\n    r\
    \ << p\n  else\n    r << p\n  end\nend", "  return n % p\nend", "  t = mod(n,\
    \ p)\n  t >= p\nend\n@test modp(3, 11) == 1", "  (n,p) = n.to_i, p.to_i\n  if\
    \ 0 == n\n    return 0\n  if n == 0\n    return 0\n  if p == 0 or p == -1 or p\
    \ == 1\n    return n\n  result = 1\n  while n > p\n    result *= n\n    n /= p\n\
    \  end\n  while n > 0\n    result *= n\n    n /= p\n  end\n  return result\nend",
  "  r1 = n.to_s(2)\n  r2 = p.to_s(2)\n  n1 = (r1.scan(/^-?([1-9][0-9]*)$/).to_i).to_s(2)\n\
    \  n2 = (r2.scan(/^-?([1-9][0-9]*)$/).to_i).to_s(2)\n  r1n = ((n1.to_i + 1) *\
    \ 10).to_s(2)\n  r2n = ((n2.to_i + 1) * 10).to_s(2)\n  r1n2 = ((r1n + n2) * 10).to_s(2)\n\
    \  r = r1n2.scan(/^-?([1-9][0-9]*)$/).to_i\n  if(r == 0)\n    r\n  else\n    r\n\
    \  end\nend", "  r = n % p\n  r ? r + p : r\nend", '  return 1 if (n and p and
    p) or n == 0 or n % p else 0', '  return 2**n % p', "  if n < 0\n    return ((n\
    \ - 1) // p + 1) * p\n  end\n  return n % p\nend", "  return ((n%p) + (n%(p-1))%p)\
    \ % p\nend", "  return n ^ (n >> p) & p\nend", "  x = 0\n  while n > 0 do\n  \
    \  x := ((x << 1) | x & -p) % p\n    n := n >> 1\n  end\n  return x\nend", " \
    \ return n**p % p\nend", "  if p < 0 or n < 0:\n    return 0\n  if n == 0:\n \
    \   return 1\n  if n and p:\n    n %= p\n  elif n or p:\n    raise ValueError(\"\
    modp received n==0 and p!=0 for 0<p<2**64\")\n  return n", "  if n % p == 0 then\
    \ return n\n  else return n % p\nend", "  if n < 0 or n >= p\n    return 0\n \
    \ if n == 0\n    return 1\n  m = (n % p + p) % p\n  return m", "  ((p > 0)? p%n\
    \ : ((p < 0)? p%-n: p)) % n\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
