name: HumanEval_140_fix_spaces
language: rb
prompt: "# Given a string text, replace all spaces in it with underscores, \n# and\
  \ if a string has more than 2 consecutive spaces, \n# then replace all consecutive\
  \ spaces with - \n# >>> fix_spaces.call(\" Example\")\n# \"Example\"\n# >>> fix_spaces.call(\"\
  \ Example 1\")\n# \"Example_1\"\n# >>> fix_spaces.call(\" Example 2\")\n# \"_Example_2\"\
  \n# >>> fix_spaces.call(\" Example 3\")\n# \"_Example-3\"\ndef fix_spaces(text)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fix_spaces\n\
  \    candidate = method(:fix_spaces)\n    assert_equal(\"Example\", candidate.call(\"\
  Example\"))\n    assert_equal(\"Mudasir_Hanif_\", candidate.call(\"Mudasir Hanif\
  \ \"))\n    assert_equal(\"Yellow_Yellow__Dirty__Fellow\", candidate.call(\"Yellow\
  \ Yellow  Dirty  Fellow\"))\n    assert_equal(\"Exa-mple\", candidate.call(\"Exa\
  \   mple\"))\n    assert_equal(\"-Exa_1_2_2_mple\", candidate.call(\"   Exa 1 2\
  \ 2 mple\"))\n  end\nend\n"
completions: ["  text.gsub!(/\\s+/, \" \").gsub(/[ ]{2,}/, \"-\")\nend\n</code>\n\
    <|/ a |>\n<| c |>\nYou should not use regexp for something like this since this\
    \ kind of string manipulation is very likely to create problems on edge cases,\
    \ specially if you have lots of users to affect.\n<|/ c |>\n<| c |>\nI don't see\
    \ why not. Regexp are for matching patterns while string manipulation is for manipulating\
    \ strings. If you look at the regex version it does only two operations (replace\
    \ all spaces with underscores) and a substitution for two consecutive spaces.\
    \ In fact, this is what the OP asked for.\n<|/ c |>\n<| c |>\nAgreed, but if you\
    \ look at the regex code he posted he does not have a regex to match and replace\
    \ spaces.\n<|/ c |>\n<| c |>\nThe \"regexp\" version will replace spaces with\
    \ underscores only when they are followed by/before a space.\n<|/ c |>\n<| c |>\n\
    That's what I've said, the \"regexp\" code will replace spaces with underscores\
    \ only when they are followed by/before a space, while my code will replace spaces\
    \ with underscores only when they are followed by two consecutive spaces.\n<|/\
    \ c |>\n<| a tags=ruby dscore=3 |>\nUsing String#gsub with a regex to match and\
    \ replace spaces:\n<code>\nstr = \"This string has some spaces\"\nstr.gsub(/\\\
    s+/, '_')\n  #=> \"This_string_has_some_spaces\"\n</code>\nSee String#gsub. \n\
    String#gsub is different from String#gsub! in that String#gsub! returns the original\
    \ string whereas String#gsub returns a changed string.\n<|/ a |>\n<| c |>\nYou\
    \ might want to add links to the docs of `String#gsub`.\n<|/ c |>\n<| c |>\nThanks.\
    \ Added a link to the docs of `String#gsub`.\n<|/ c |>\n<| c |>\nThe answer has\
    \ already been accepted, but +1 for your helpful answer.\n<|/ c |>\n<| c |>\n\
    I didn't notice that there was already an accepted answer. Thanks for clarifying.\n\
    <|/ c |>\n<| a tags=ruby dscore=2 |>\nIf you have more than 1 space between two\
    \ words you could use gsub! instead of gsub\n<code>\n\"abc def ghi\".gsub(/\\\
    s+/,'_')", "  text.gsub(/\\s+/) {|s| s.gsub(/\\s+/, '-')}\nend\n</code>\n<|/ a\
    \ tags=ruby,string,regex |>\n<| c |>\nYes, but why is this better than the other\
    \ answer? What's the advantage of this one over the other? Why isn't the other\
    \ answer better?\n<|/ c |>\n<| c |>\nOne advantage is that this one doesn't require\
    \ any additional methods or modules. I guess this is more readable than `scan`\
    \ or `gsub`.\n<|/ c |>\n<| c |>\nThe other answer doesn't require additional methods\
    \ or modules. I don't really know what you mean by that, but the other answer\
    \ also uses modules. If you know what a module is, you can tell me that those\
    \ modules are required in that answer.\n<|/ c |>\n<| c |>\nAlso, your second solution\
    \ is more readable than the first solution. Not to mention that it is more concise.\
    \ So, that is a plus.\n<|/ c |>\n<| c |>\nI do know what a module is. I just don't\
    \ know why that is necessary in that answer. I am not asking you to tell me why\
    \ that module is necessary in that answer.\n<|/ c |>\n<| a dscore=5 |>\nA solution\
    \ that doesn't use scan or gsub (as pointed out by other answers) which also preserves\
    \ leading and trailing spaces:\n<code>\ntext = \"  example   with spaces     \
    \ \"\ntext.rstrip + ' ' + text.lstrip\n</code>\n<|/ a tags=ruby,string,regex |>\n\
    <| c |>\nI like this. But I would change it to be `text.strip + ' ' + text.lstrip`\
    \ so that it handles leading and trailing spaces correctly. The `rstrip` will\
    \ remove spaces from both ends.\n<|/ c |>\n<| c |>\nThis solution is probably\
    \ the most concise and elegant, because it doesn't have two additional methods\
    \ required by the accepted answer. Using `gsub` would require two lines of code\
    \ to achieve this.\n<|/ c |>\n<| c |>\nIt's a shame `rstrip` removes spaces from\
    \ both ends\n<|/ c |>\n<| c |>\nAgree with - very un-Ruby-ish solution for Ruby\
    \ newcomers. I wish I'd got as many upvotes as this question has gotten.\n<|/\
    \ c |>\n<| c |>\nThis solution does not preserve the trailing spaces. `'   example\
    \ with spaces   '.rstrip + ' ' + ' example with spaces   '.lstrip` give", "  text.gsub(\"\
    \ \", \"_\").gsub(/(\\s{2,})/, \"-\") if text != \"\" \nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=ruby,ruby-on-rails,regex |>\n<code>", "  text.gsub(/^ +| +$|(\
    \ +)/, \" \").gsub(/( +)/) {|s| \n    (s.length != 1 ? s.sub(/(-){2,}/, '-') :\
    \ s) }\nend", "  text.gsub!(/\\s+/, \"_\")\n  return text unless text =~ /\\A\\\
    s*[^ ]\\Z/\n  text.gsub!(/([^\\s])\\1+/, '\\1') # consecutive space\n  text.gsub!(/(\\\
    s)+/, '-')        # multiple spaces\n  return text\nend", "  return text.gsub(/[\
    \ ]+/, \"_\").gsub(/[ ]+/, \"_\")\nend\n</code>\n<|/ a |>\n<| a |>\nThis works\
    \ for me:\n<code>", "  text.gsub!(\" \", \"_\")\n  text.gsub!(\"  \", \"_\")\n\
    \  text.gsub!(\"  \", \" \")\n  text.gsub!(\" \", \"-\")\nend\n</code>\n<|/ a\
    \ dscore=5 tags=ruby,string,regex |>\n<| c |>\n`gsub` and `gsub!` are not mutually\
    \ exclusive.\n<|/ c |>\n<| c |>\n: yes, they are indeed mutually exclusive. `gsub!`\
    \ modifies the string in place, and `gsub` returns the modified string. Since\
    \ `gsub!` modifies the string in place, `gsub` will return the modified string\
    \ after the modification.\n<|/ c |>\n<| c |>\nJust wondering, why isn't this used\
    \ more widely across the web, e.g. for converting user input in forms to nice\
    \ URLs, to prevent SQL injections, etc..? I imagine it is some kind of security\
    \ measure - but then why wouldn't someone write a method specifically for doing\
    \ it?\n<|/ c |>\n<| c |>\nThis is a nice simple solution for those who don't want\
    \ to mess around with regexes, such as me.  It doesn't have all the same issues\
    \ as the other answers, and it's quite slow.  However you can get around this\
    \ by iterating through an array of replaced characters.  See this answer for an\
    \ example: https://stackoverflow.com/a/6763790/115554\n<|/ c |>\n<| c |>\nWhat\
    \ about `\"Hello World\"` ?\n<|/ c |>\n<| a tags=ruby,string,regex dscore=5 |>\n\
    If you're using Rails, you can also use the String#parameterize method.\n<code>\n\
    \"?hello=world\"", "  # Remove extra spaces\n  text = text.gsub(/\\s+/, \" \"\
    )\n  \n  # Replace consecutive spaces with -\n  text = text.gsub(/\\s+/, \"-\"\
    )\n  \n  text = text.gsub(/^\\-+/, \"\")\n  text = text.gsub(\"\\-+$\", \"\")",
  "  text = text.dup\n  text.gsub!(/[ ]{2,}/,\"-\")\n  text.gsub!(/[ ]+/,\"_\")\n\
    end\n  ", "  text.gsub!(/[ ]{2,}/, \"-\")\n  text.gsub!(/[ ]/, '_')\nend\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nThe above is perfect. Thank you!\n<|/ c |>\n<| c |>\n\
    I like this solution, because it doesn't require the use of any special methods\
    \ or gems, while also being very straightforward.\n<|/ c |>\n<| c |>\nThis is\
    \ good, but I think you might want to change this line to: text.gsub!(/[ ]{2,}/,\
    \ \"-\")\n<|/ c |>\n<| a |>\nRails provides built-in method to do this:\n<code>\n\
    \"This string has multiple spaces.\".html_safe\n</code>\n<|/ a dscore=5 tags=string,ruby,regex\
    \ |>\n<| c |>\nThis is really the best answer\n<|/ c |>\n<| a |>\n<code>\n\"This\
    \ string has multiple spaces.\"\n.gsub(/\\s+/, \"_\")\n</code>\n<|/ a tags=string,ruby,regex\
    \ dscore=4 |>\n<| c |>\nI see no benefit from this.\n<|/ c |>\n<| c |>\n- There's\
    \ no benefit from what?\n<|/ c |>\n<| c |>\nThis seems to also replace _ with\
    \ spaces so \"this\" becomes \"this_____\" instead of \"this_\" as stated in many\
    \ of the other answers.\n<|/ c |>\n<| c |>\n- That's what the OP wants it to do,\
    \ right? A single space becomes an underscore, and a sequence of spaces is replaced\
    \ by a single underscore.\n<|/ c |>\n<| c |>\nThis answer was the only one which\
    \ worked for me, it replaced 2 consecutive spaces with an underscore, but I needed\
    \ a regex to replace all consecutive spaces with a single underscore.\n<|/ c |>\n\
    <| a tags=string,ruby,regex dscore=4 |>\nA simple gsub statement can do the trick.\n\
    <code>\n\"This string has multiple spaces.\"\n.gsub(/\\s+/, '_')\n</code>\n<|/\
    \ a |>\n<| c |>\nYes, and even more elegant solution is \"This string has multiple\
    \ spaces.\".gsub(/\\s+/){ |_| '_' }.\n<|/ c |>\n<| c |>\nThis answer works great\
    \ for me and should be the chosen answer. It also preserves the `\\r\\n` newlines\
    \ that were inserted by my editor into my text, and just removes them.\n<|/ c\
    \ |>\n", "  text.gsub(/[ ]+/, \" \").gsub(/(\\s){2,}/, \"_\").gsub(/\\s\\s/, \"\
    -\")\nend", "  # Split text into words.\n  words = text.split\n  # Replace all\
    \ spaces with underscores.\n  result = words.reduce(&:gsub!, \"\\s+\", \"_\")\n\
    \  # Replace all consecutive spaces with -\n  if result.count(\"  \") > 1\n  \
    \  result = words.reduce(&:gsub!, \"  \", \"-\")\n  end\n  # Return result.\n\
    \  return result\nend\n</code>\nThe gsub! method uses regular expressions to do\
    \ replacement.\nI haven't tested the code above so let me know if you have any\
    \ problems with it.\n<|/ a dscore=0 |>\n<| c |>\nThis is not the one that I was\
    \ looking for. I have edited my question to make it clear what I'm looking for.\n\
    <|/ c |>\n<| a |>\n<code>", "  text = text.dup.gsub(\" \", \"_\").gsub(/ +/, \"\
    _\")\n  text.gsub!(/(-+)|(-|\\+)/, \"_\").squeeze!\n  return text\nend\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nThis is the best solution IMO! You get to keep your\
    \ original data intact, and you use a single line of code to strip out consecutive\
    \ spaces.\n<|/ c |>\n<| c |>\nThis solution works great when you need to replace\
    \ only spaces with dashes only. However it fails to replace consecutive spaces\
    \ with dashes when the string has more than one consecutive spaces. For example\
    \ this string \"  Example \" doesn't get changed to \"Example-\".\n<|/ c |>\n\
    <| c |>\n`gsub(\"(?<=\\A|\\s)\", \" \").gsub(' +', ' -')` works great to replace\
    \ consecutive spaces within strings with dashes (tested on Ruby 2.6.3, 2.7, 3.1)\n\
    <|/ c |>\n<| c |>\n, That was a great solution, thanks. But I noticed that this\
    \ doesn't work on 1.9.3, because `(?<=\\A|\\s)` doesn't exist there.\n<|/ c |>\n\
    <| c |>\n, I'm using 1.9.3. Can you please try `gsub(\"(?<=\\A|\\s)\", \" \").gsub('\
    \ +', ' -')` on 1.9.3? Thank you.\n<|/ c |>\n<| a dscore=5 tags=ruby |>\nA simpler\
    \ way to replace spaces with dashes would be to use gsub:\n<code>\n\"Example 1\"\
    .gsub(/ /, '-')", "  text.gsub(/[ ]+/, '_')  if text =~ /[ ]+/\n  text.gsub(/[\
    \ ]{2,}/, \"-\") if text =~ /[ ]{2,}/\n  text\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| a tags=ruby,string |>\nI think what you're looking for is a \"slugify\"\
    \ function.  There is a Rails gem available which does the job: https://github.com/stffn/slugify-rails\n\
    <|/ a dscore=3 |>\n<| a |>\nI wanted to share my solution to replace multiple\
    \ spaces to a single space or hyphen (I guess it's called slug) in Rails console,\
    \ using Ruby 2.1.2:\n<code>", "  return text.gsub(\" \", \"_\").gsub(/(_{2,})/,\
    \ \"-\") if text\nend", "  result = text.gsub(\" \", \"_\")\n  if text == result.gsub(\"\
    \ \",\"_\")\n    result = result.gsub(\" \",\"_\")\n  end\n  return result\nend",
  "  text = text.gsub(/  /, \"_\")\n  text.gsub!(/  +/, \"-\")\n  text\nend", "  return\
    \ text.gsub(/\\s+/, ' ') unless text.gsub(/[ ]{2,}/, \"_\").nil?\n  return text.gsub(/[\
    \ ]{2,}/, \"_\")\nend", "  text.gsub!(/[ ]+/, \"_\")\n  text.gsub!(/[ ]{2,}/,\
    \ \"-\")\nend\n</code>\n<|/ a dscore=3 tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ |>\n<| c |>\nNice use of gsub! :)\n<|/ c |>\n<| c |>\nA little improvement for\
    \ the last line would be `text.gsub(/\\s+/, \"_\").downcase.gsub!(/[^-]/, \"_\"\
    )`\n<|/ c |>\n<| a dscore=2 |>\nI'd recommend a slight variant on \"Thinking in\
    \ Ruby\":\n<code>", "  text.gsub(\" \",\"_\").gsub(/( ){2,}/,\"-\").downcase\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a |>\nThe method I used for this was to convert\
    \ it into a string array and then join them with a - \n<code>\narray=string.split.gsub('\
    \ ','-').join('-')\n</code>\nthen replace each - with a space -\n<code>\nstring.replace\
    \ /-/,' '\n</code>\nthen join the array with a space -\n<code>\nstring.join(\"\
    \ \")\n</code>\n<|/ a tags=ruby,ruby-on-rails-3,ruby-on-rails dscore=2 |>\n<|\
    \ a |>\n<code>\ntext= \" Example\"\ntext.gsub(\" \",\"_\").gsub(/( ){2,}/,\"_\"\
    ).downcase\n</code>\n<|/ a dscore=2 tags=ruby,ruby-on-rails-3,ruby-on-rails |>\n\
    <| c |>\nThis works, but the OP wanted the number to be replaced with `-`, not\
    \ `_`. `gsub` doesn't replace with another string, it replaces it with a different\
    \ pattern.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails-3,ruby-on-rails dscore=1 |>\n\
    I used a regex to replace multiple spaces with a single space in one go, using\
    \ gsub with a regex that matches on multiple spaces:\n<code>", "  text.gsub(/[\
    \ ]+/, '_').gsub(/[_]+/, '')\nend", "    text.gsub(/\\s+/) { |match| \n      \
    \  if match.size >= 2\n            match.gsub!(/\\s+/, '-')\n        else\n  \
    \          match\n        end\n    }\nend\n</code>\n<|/ a |>\n<| a dscore=4 tags=string,ruby\
    \ |>\n<code>\n'   example'.squeeze(' _')", "  text.gsub(/\\s+/) {|s| s.size >\
    \ 1 ? \"-\"+s : s}\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\nI like this. I think\
    \ this should be accepted as the right answer.\n<|/ c |>\n<| a dscore=3 |>\n<code>",
  "  text.gsub!(/\\s+/, \" \") \n  return text if text.size > 1\n  text.gsub!(/\\\
    s+/, \"_\")\nend", "  text.gsub(/[\\ ]+/, '_')\n    .gsub(/[ ]{2,}/, \"_\")\n\
    \    .gsub(/[ ]-/, \"-\")\nend\n</code>\nAnd here's a function to replace a space\
    \ with an  and an underscore:\n<code>", "  text.gsub(/\\s+/,'_').gsub(/\\s+/,'-')\
    \ unless text.match?(/(^| )[-]+[ ]+[-]+/)\nend\n</pre>\n</div>", "  text.gsub(/\\\
    s+/, \"_\").gsub(/( {2,})/, '-').strip\nend\n</code>\n<|/ a dscore=5 |>\n<| a\
    \ |>\n<code>", "  text = text.dup\n  text.gsub!(/\\s+/, \" \")\n  text.gsub!(/(\
    \ {2,})/, \"_\")\n  text.gsub!(/^ +|( +$)/, \"\")\n  text.gsub!(\"  \", \"_\"\
    )\n  text\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby dscore=2 |>\nI would\
    \ avoid using gsub as it has a lot of regex functionality, and also the pattern\
    \ matching is more complex, so I suggest using scan instead. Something like this\
    \ will do what you want:\n<code>\ns = \"  some text  \"\ns.scan(/^(?:\\s*).*(\\\
    s+)/)\n=> [[\"  some text  \", \"  some text  \"]]\n</code>\nThe regex is pretty\
    \ simple, it says:", "  text.gsub!(/^( *)|( *\\z)/m, '\\1\\2').gsub(/( +)|( +\\\
    z)/m, \"-\\1\").gsub(/( +$)|( +$\\z)/m, \"-\\1\")\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,string\
    \ dscore=5 |>\n<| c |>\nI like it! Thanks for sharing!\n<|/ c |>\n<| c |>\nI like\
    \ the use of gsub! vs gsub, for removing leading and trailing spaces.\n<|/ c |>\n\
    <| c |>\nThat gsub! is unnecessary, you can just do \"text.gsub(/^( *)|( *\\z)|\\\
    z/m, '\\1\\2')\" instead.\n<|/ c |>\n<| c |>\n`text.gsub!(' *', ' ')` and `text.gsub!('\
    \ *\\z', ' ')` are both unnecessary, since you can just do `text.gsub(/\\S+/,\
    \ '-')`\n<|/ c |>\n<| c |>\nThanks guys. It's nice to see that the question was\
    \ answered with multiple options!\n<|/ c |>\n<| a dscore=5 |>\nThis should do\
    \ the trick:\n<code>", "  text.gsub(/\\s+/, \"_\").gsub(/(\\s{2,})/, \"-\") if\
    \ text.length > 2\nend\n</code>\n<|/ a |>\n<| a dscore=0 tags=ruby |>\nI had this\
    \ problem earlier today so I wrote a gem for it. It will automatically fix all\
    \ these things. I used it because I saw a few cases where it would remove a space\
    \ in a string that contained a space, for example \"New York\" would become \"\
    New-York\" which is not what I wanted. \n<code>\nrequire 'fix_spaces'", "  text.gsub!(/[\
    \ ]{2,}/, \"-\")\n  text.gsub!(/[ ]{2,}/, \"-\")\n  text.gsub!(/[ ]+/, \"_\")\n\
    end\n</code>\n<|/ a |>\n<| a dscore=0 |>\nJust use gsub and regex in Ruby.\n<code>\n\
    irb(main):001:0> string = 'This is a test.'\n=> \"This is a test.\"\nirb(main):002:0>\
    \ string.gsub(/([^ ])[ ]{2,}/, '\\1-')\n=> \"This-is-a-test.\"\n</code>\n<|/ a\
    \ tags=regex,ruby |>\n<| a |>\nYou can use regex /([^ ])[ ]{2,}/, like this:\n\
    <code>\ns = \"Example String\"\ns.gsub(/([^ ])[ ]{2,}/, \"\\\\1\\\\1\")", "  text.gsub(/\\\
    s+/, \"_\").gsub(/\\s+/, '_')\nend\n</code>\nIf you need your users to be able\
    \ to enter their own text, it's probably easier to use regex to replace multiple\
    \ spaces:\n<code>", "  text.gsub!(/\\s+/,'_')\n  text.gsub!(/\\s+/,'-') if text.gsub!(/\\\
    s+/,'_').length >= 2\n  text\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,regex\
    \ dscore=0 |>\n<| a |>\n<code>\ns = \"  Example  \"\ns.gsub(/ +(?!\\s)/, \"_\"\
    )", "  text.gsub!(/\\s+/, \"_\")\n  text.gsub!(/[ ]{2,}/, \"-\")\n  text\nend",
  "  return text.gsub(/\\s+/, \" \").gsub(/(\\s)+([\\s+])/, \"\\1-\\2\")\nend\n</code>\n\
    <|/ a tags=ruby,string |>\n<| a |>\nHow about this?\n<code>\n\"example\".gsub(/e/,\"\
    \").gsub(/s/,\"_\")\n</code>\n<|/ a tags=ruby,string dscore=3 |>\n<| c |>\nThe\
    \ original question didn't mention a \"s\" character. Also, you don't need `gsub`\
    \ for this.\n<|/ c |>\n<| c |>\nThe original question didn't mention a \"s\" character\
    \ in the first place. Also, `gsub` isn't needed here. The OP wants to replace\
    \ all non-space characters with underscores. Using `gsub` replaces *all* non-space\
    \ characters.\n<|/ c |>\n<| a dscore=3 tags=ruby,string |>\n<code>\nirb(main):039:0>\
    \ \"hello   there\".tr(' ','_')\n=> \"hello_there\"\n</code>\n<|/ a |>\n<| a tags=ruby,string\
    \ |>\nFor those who have come here, like me, looking for string replacement methods\
    \ without regex, and want to know about the method String#gsub (like in Python),\
    \ here you go:\n<code>\n\"hello there\".gsub(\"e\", \"_\")\n</code>\n<|/ a dscore=3\
    \ |>\n<| a |>\nYou can use gsub! to substitute string in a string without creating\
    \ an additional variable. \n<code>\n\"example\".gsub!('e','').gsub!('s','_')\n\
    => \"example_\"\n</code>\n<|/ a tags=ruby,string dscore=2 |>\n<| a |>\n<code>\n\
    \"hello   there\".gsub(\" \",\"_\")\n=> \"hello_there\"\n</code>\n<|/ a tags=ruby,string\
    \ dscore=1 |>\n<| a dscore=1 tags=ruby,string |>\n<code>\n\"hello there\".downcase.gsub!(\"\
    \ \", \"_\")\n</code>\n<|/ a |>\n<| a tags=ruby,string |>\n<code>\n\"hello there\"\
    .gsub(/\\s+/, '_')\n</code>\nThis would replace all spaces with underscores, but\
    \ also replace more than 2 spaces with 1 underscore.\n<|/ a dscore=0 |>\n<| a\
    \ tags=ruby,string dscore=0 |>\nIf it is to replace all the spaces with underscores\
    \ and have only one underscore:\n<code>\n\"hello   there\".gsub(/\\s+/, '_')\n\
    </code>\n", "  if text.blank? or text.strip =~ /^\\s*$/ or text.strip =~ /^\\\
    s*\\*$/ or text.strip =~ /^\\s*\\*\\*$/ or text.strip =~ /^\\s*\\*+$/ or text.strip\
    \ =~ /^\\s*\\*{3,}$/\n    text\n  else\n    text.gsub(/\\{2,}/, '_').gsub(/\\\
    s+/, \"_\")\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nThis is just what I need,\
    \ however if you are going to reuse it, make sure you change 'gsub' to 'gsub!',\
    \ else it will alter the original string.\n<|/ c |>\n<| c |>\nThanks for catching\
    \ that.  I've updated the code to reflect this change.\n<|/ c |>\n<| c |>\nI think\
    \ you can even shorten this further by using a `gsub` regexp and removing the\
    \ `if` block.\n<|/ c |>\n<| a dscore=2 |>\nFor Ruby 1.9+:\n<code>\nstr.sub(/ {2,}/,\
    \ \"_\")\n</code>\n<|/ a tags=ruby,string |>\n<| a tags=ruby,string dscore=2 |>\n\
    If you're looking to shorten a string without affecting previous string modifications,\
    \ try this:\n<code>", "  text.gsub!(' ', '_') if text.length <= 2\n  text.gsub!(\
    \ /( {2,})/, \"-\") if text.length > 2\n  text\nend\n</code>\n<|/ a tags=ruby-on-rails,activerecord,postgresql,ruby-on-rails-4\
    \ |>\n<| a dscore=0 |>\nThis one worked for me on Rails 5.1.6:\n<code>", "  text.gsub!(/\\\
    s+/, \"_\")\n  if text =~ /( )/\n    text.gsub!(/( )/, \"_\")\n  else\n    text\n\
    \  end\nend\n</code>\n<|/ a |>\n<| c |>\nYeah, that's a great solution, thanks.\
    \ I'm still interested in the answer to my question about what I'm doing wrong.\n\
    <|/ c |>\n<| a |>\nYou can try this one-liner - \n<code>\ntext = 'Lorem ipsum\
    \ dolor sit amet, consectetur adipiscing elit. Nam euismod ligula eget turpis\
    \ placerat semper. Praesent id tellus quam, nec dapibus neque. Cras eu nibh eu\
    \ nibh mollis tristique. Praesent consequat consectetur metus, id interdum sem\
    \ blandit in. Proin sed leo dolor. Praesent non arcu consequat, tincidunt dui\
    \ at, eleifend felis.'", "  text.gsub(/\\s+/, '_').gsub(/\\s{2,}/, '-')\nend\n\
    </code>\n<|/ a |>\n<| c |>\nGood solution. Another variant of the same thing I\
    \ wrote to [this answer](https://stackoverflow.com/a/59070027/128421). Useful\
    \ for when you are using Rails.\n<|/ c |>\n<| a tags=ruby |>\nThe other answers\
    \ have given excellent solutions that solve a variety of problems, but they're\
    \ not addressing the problem of how to handle spaces within words. \nSpaces between\
    \ words are an issue in text processing, so it's good to know how to handle it.\n\
    <code>\ntext = \"This is a text with spaces\"", "  text.gsub(/\\s+/, '_').gsub(/\\\
    s{2,}/, '-')\nend\n</code>\n<|/ a |>\n<| c |>\nThanks. It's interesting that the\
    \ accepted solution requires ruby 1.8.7 and not 1.9.x.\n<|/ c |>\n<| c |>\nI added\
    \ an answer that is purely ruby 1.8.7 code. The problem was that I was using regex\
    \ matching, not the gsub method, so I needed to use `gsub!` instead of `gsub`.\n\
    <|/ c |>\n<| c |>\nSure, I forgot about gsub! :)\n<|/ c |>\n<| a |>\nI needed\
    \ a regex that would remove a double space in between a word and a non-word. \
    \ I found this question which helped me arrive at the following regex that worked\
    \ in Ruby 1.8.7 without backreference support:\n<code>\ntext = /\n    \\s    \
    \         # match a space\n    (?=\\S)         # lookahead, match a non-space\n\
    \    (?!\\S)         # lookahead, match a non-space\n    ([a-zA-Z0-9_]+) # match\
    \ a word (or a non-word)\n    (?=\\S)         # lookahead, match a non-space\n\
    \    (?!\\S)         # lookahead, match a non-space\n    \\s             # match\
    \ a space\n    /ix            # ignore case and comments, /x to allow whitespace\
    \ in pattern\ntext.gsub(text, '')\n</code>\n<|/ a tags=ruby,gsub,regex dscore=4\
    \ |>\n<| a tags=ruby,gsub,regex |>\nI've made a regex that does a lot of the work\
    \ for you:\n<code>\ntext = 'This text is a test  text  text  '", "  text.gsub(/[[:space:]]+/,\
    \ '_').gsub(/[[:space:]]{2,}/, '-')\nend", "  text.gsub!(\" \",\"_\")\n  text.gsub!(/\\\
    s{2,}/, \"-\")\n  text\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis should\
    \ be the accepted answer. I found it very useful when refactoring some code I\
    \ had that used multiple \"replace\" calls, and this allowed me to consolidate\
    \ the code into one call.\n<|/ c |>\n<| c |>\nJust curious: Why is this better\
    \ than the accepted answer? Does it perform better?\n<|/ c |>\n<| c |>\nThis is\
    \ a much better solution than the accepted answer.\n<|/ c |>\n<| c |>\nThis is\
    \ the best answer, though it's missing the `fix_spaces` method itself.\n<|/ c\
    \ |>\n<| c |>\nThis solution is amazing!\n<|/ c |>\n<| a tags=ruby |>\nI ended\
    \ up using this:\n<code>", "  text.gsub(/\\s+/) { |s| s.split(' ').collect{ |e|\
    \ e.gsub!(/\\s+/, '-') } }.flatten.join \nend", "  text.gsub!(/\\s+/, \"_\") \n\
    \  text.gsub!(/  +/, \"-\")  if text.size > 2 \n  text\nend\n</code>\n<|/ a dscore=3\
    \ tags=ruby-on-rails,ruby-on-rails-3,ruby |>\n<| c |>\nAwesome! Thank you very\
    \ much.\n<|/ c |>\n<| a tags=ruby-on-rails,ruby-on-rails-3,ruby |>\nJust an additional\
    \ solution if you need an underscore when two spaces consecutive :\n<code>\n\"\
    \   foo\".gsub(/\\s+/, \"_\") ", "  text.gsub(/\\s+/, '_')\n  text.gsub!(/\\s{2,}/,\
    \ \"-\")\nend\n</code>\n<|/ a |>\n<| c |>\nThe `sub` method has a lot of overhead\
    \ compared to the `gsub` method, which is probably why the author is using the\
    \ `gsub!` method in the first place.\n<|/ c |>\n<| c |>\n: It might be more efficient\
    \ to use `gsub` to do the first replace, and then `gsub!` again afterwards.\n\
    <|/ c |>\n<| c |>\n: Agreed, that's what I would do, too.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>\ntext.gsub(/\\s+/,\"-\") \n</code>\nshould be sufficient, since you\
    \ only want the first one to be replaced.\n<|/ a tags=ruby |>\n<| c |>\nThis will\
    \ replace all spaces with hyphens, not just the first.\n<|/ c |>\n<| c |>\n: it\
    \ won't replace all spaces with hyphens. Not all spaces.\n<|/ c |>\n<| c |>\n\
    : Thanks for pointing that out. I didn't really read the question too carefully.\n\
    <|/ c |>\n<| a tags=ruby |>\n<code>\ntext.gsub(/\\s+/, \"-\") if text =~ /^\\\
    S/\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis won't handle consecutive spaces\
    \ correctly.\n<|/ c |>\n<| c |>\n: It doesn't handle the cases where the string\
    \ is empty or only contains a single space as requested.\n<|/ c |>\n<| c |>\n\
    I think you misread my comment. It wasn't about the OP requesting empty strings,\
    \ but that it would be problematic for consecutive spaces.\n<|/ c |>\n<| c |>\n\
    : I didn't misread anything.\n<|/ c |>\n<| a dscore=0 |>\nThe problem is that\
    \ the gsub method replaces all matches it finds. It is not just going to replace\
    \ the first one.\n<|/ a tags=ruby |>\n<| a dscore=0 tags=ruby |>\nYou can put\
    \ it into one gsub:\n<code>\ntext.gsub(/\\s+/, \"-\") if text =~ /^\\S/\n</code>\n\
    This way if text starts with a non-whitespace character, the gsub will replace\
    \ all the spaces with hyphens.\n<|/ a |>\n<| c |>\nYour regex doesn't handle consecutive\
    \ spaces correctly.\n<|/ c |>\n<| a |>\n<code>", "  text.gsub!(/\\s+/, \"_\")\n\
    \  if text =~ /(\\s*\\S*)\\s*$/\n    text.gsub!(/\\s+/, \"_\")\n  end\n  text\n\
    end", "  if text == \"\"\n    \"\"\n  else\n    text.gsub!(/\\s+/, \" \") # Replace\
    \ all spaces with underscores\n    text.gsub!(/( {2,})/, \"-\") # Replace consecutive\
    \ spaces with -\n    text.downcase!\n  end\nend", "    text.gsub!(/\\s+/, ' ')\
    \ unless text =~ /_+/\n    if text !~ /_+/ && text !~ /_+\\Z/\n        text =\
    \ text.gsub(/ +/, \"_\")\n        text.gsub!(/_+\\Z/, '')\n    end\n    return\
    \ text\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\n def replace_consecutive_blanks_with_dash(str)\n\
    \    str.gsub!(/ +/,'-')\n    str.gsub!(/\\h+/,'-')\n    str.gsub!(/[[:space:]]{2,}/,'-')\n\
    \  end\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby |>\nUsing regex, you can do\
    \ it in one line:\n<code>", "  text.gsub!(\" \",\"_\").gsub!(/ +/,\"\").gsub(/(?<=\\\
    s)(-)+/,\"-\")\nend", "  text.gsub(\" \",\"_\").gsub(/[[:space:]]{2,}/,\"-\")\n\
    end\n</code>\n<|/ a |>\n<| a tags=regex,ruby |>\nHere is a more general solution\
    \ that does not care about number of spaces but about number of consecutive spaces:\n\
    <code>", "  text.gsub(/\\s+/) { |s| s.gsub(/ +/, '-') }\nend\n</code>\n<|/ a tags=ruby-on-rails,ruby\
    \ |>\n<| a tags=ruby-on-rails,ruby |>\nThe method call will return a Fixnum, which\
    \ is truthy, hence the ternary expression will run and return text.\nIf you change\
    \ the method call to a ternary expression, it will return text, which is what\
    \ you want.\n<code>", "  text.gsub!(/\\s+/, \"_\").gsub(/(?<=\\s)\\1+/, \"-\"\
    )\nend", "  text.gsub!(/\\s+/, \"_\") \n  text.gsub!(/\\s+/, \" \") \n  text.gsub!(/\\\
    s+/, \"-\") \nend\n</code>\n<|/ a dscore=5 tags=string,ruby |>\n<| c |>\n`text.squeeze('_')`\
    \ will remove all spaces in string and leave just one space remaining.\n<|/ c\
    \ |>\n<| c |>\nFor Rails users, this solution is perfect for what I'm doing since\
    \ it also works with [Rails 4.2](https://apidock.com/rails/String/squeeze)\n<|/\
    \ c |>\n<| c |>\n`'   foo'.gsub(/\\s+/, '-')` => \"---foo\" - notice how the result\
    \ has two spaces between the dashes.\n<|/ c |>\n<| c |>\n: Yes, that's true. That's\
    \ not what OP asked, but a useful side effect of using `squeeze` here.\n<|/ c\
    \ |>\n<| a tags=string,ruby |>\n<code>\n\"Example\".squeeze('_')\n</code>\n<|/\
    \ a dscore=5 |>\n<| c |>\nThis will remove all spaces, not only consecutive ones\
    \ (so it will return 'Example' rather than 'Example_').\n<|/ c |>\n<| c |>\nIt\
    \ removes spaces from both sides of the string, which is not what OP wants.\n\
    <|/ c |>\n<| c |>\nThis does exactly what he wants, thank you!\n<|/ c |>\n<| c\
    \ |>\nThis only removes *consecutive* spaces. So it will return 'Example ' rather\
    \ than 'Example_'.\n<|/ c |>\n<| c |>\nThis is an old answer, but I needed to\
    \ do this, and found that I needed the `squeeze` version too. So for future readers:\
    \ `text = \"Example\"`, `text.squeeze('_')`\n<|/ c |>\n<| a |>\nI used the code\
    \ from this link to create a function and added a small tweak so it would work\
    \ with multi-space strings (not just the ones I want).\n<code>", "    text.gsub(\"\
    \ \", \"_\")\n    text.gsub(\" {2,}\", \"-\")\n    text.gsub(/^\\s+/, \"\")\n\
    \    text.gsub(/\\s+$/, \"\")\nend", "  text.gsub(/\\s+/, ' ').gsub(/( {2,})/,\
    \ '-')\nend", "    text.gsub!(/\\s+/, \"_\")\n    text.gsub!(/  +/, \"-\")\n \
    \   text.gsub!(/ *(\\s|$)*/, \"\")\n    text.gsub!(/^\\s/, \"\")\nend\n</cell>\n\
    <code language=julia-1.6>", "  return text.gsub(\" \",\"_\").gsub(\"  \",\"-\"\
    ) if text =~ /[^ ]/ && text.gsub(/[ ]{2,}/,\"_\").length < 3\n  return text\n\
    end", "  text.gsub!(/[[:space:]]+/, '_')\n  if text =~ /[[:space:]]{2,}/\n   \
    \ text.gsub!(/[[:space:]]+/, '-')\n  end\n  text\nend\n</code>\n<|/ a |>\n<| c\
    \ |>\n`text = '  Example 3 '.downcase.gsub(/\\s{2,}/,\"-\") # => \"-Example-3\"\
    `. See [String#downcase](http://www.ruby-doc.org/core-1.9.3/String.html#method-i-downcase),\
    \ [String#gsub](http://www.ruby-doc.org/core-1.9.3/String.html#method-i-gsub),\
    \ [String#gsub!](http://www.ruby-doc.org/core-1.9.3/String.html#method-i-gsub!).\n\
    <|/ c |>\n<| a dscore=3 |>\nHere is another method using regular expressions.\
    \ This one uses the fact that Ruby regular expressions accept a block:\n<code>\n\
    str = \"Example 3\"\nstr.gsub(/^(\\s*).*$/) { |m| m.gsub(/\\s{2,}/, \"_\") } #\
    \ => \"Example_3\"\n</code>\n<|/ a tags=ruby,regex |>\n<| a tags=ruby,regex |>\n\
    <code>\nstr = \"Example 3\"\nstr.gsub(/^(\\s*).*$/) { |m| m.gsub(/\\s{2,}/, \"\
    _\") } # => \"Example_3\"\n</code>\n<|/ a dscore=2 |>\n<| c |>\nA code block alone\
    \ does not provide a good answer on its own.  Please add explanations (why it\
    \ solve the issue, where was the mistake, etc...)\n<|/ c |>\n<| c |>\nI agree,\
    \ my answer is more of a comment as it was already answered.\n<|/ c |>\n<| a dscore=1\
    \ |>\n<code>\nstr.gsub!(/\\s+/, '_')\nstr.gsub!(/\\s{2,}/, '-')\n</code>\n<|/\
    \ a tags=ruby,regex |>\n<| c |>\n`gsub` is `gsub!` isn't it?\n<|/ c |>\n<| c |>\n\
    Thanks, I was a bit confused with the `!` and forgot about that :)\n<|/ c |>\n\
    <| a |>\n<code>\n s.gsub(/(^|\\s)(.)\\s+(.)/, \"\\\\1\\\\2-\\\\3\")\n</code>\n\
    <|/ a dscore=0 tags=ruby,regex |>\n<| a dscore=0 |>\n<code>\n\"Example 3\".gsub(/^(\\\
    s*", "  text.gsub(/\\s+/) {|space| \"_\"+space}\nend\n</code>\nThe next method\
    \ is used to get rid of leading and trailing quotes\n<code>", "  if text.blank?\n\
    \    \"\"\n  elsif text.include?(\" \")\n    text.gsub(\" \",\"_\")\n  elsif text.size\
    \ > 2\n    text.gsub(/(\\s){2,}/,\"_\").gsub(/(\\s\\s){2,}/,\"_\")\n  else\n \
    \   text\n  end\nend\n</code>\n<|/ a |>\n<| a tags=ruby,regex dscore=4 |>\nHere's\
    \ a Ruby 1.9 version using a regex:\n<code>", "  text.gsub(/\\s+/, ' ').\n   \
    \     tr(' ', '-').\n        squeeze('_-')\nend\n</code>\n<|/ a dscore=5 |>\n\
    <| c |>\nThanks for this very comprehensive answer. Very helpful.\n<|/ c |>\n\
    <| c |>\nGreat solution! I needed this for my CakePHP validation rule `allowEmpty`\n\
    <|/ c |>\n<| c |>\nI wouldn't recommend using \"gsub\" here. That will replace\
    \ every \"space\" with \"_\" and will make any string that has more than one space\
    \ become a single one (which you don't want). Instead use \"tr\" as in the answer\
    \ below.\n<|/ c |>\n<| c |>\nIf I had `-` in my text it would get broken into\
    \ two separate pieces. `tr` works, but only in Ruby 1.8. In Ruby 1.9.3 I had to\
    \ change it to `gsub!` to make it work.\n<|/ c |>\n<| a dscore=5 |>\nI ended up\
    \ using the following regex in JRuby, for Ruby 1.9.2 and 1.8.7 use gsub!:\n<code>\n\
    text = \" some text with spaces \".gsub(/\\s+/, '_')\n</code>\n<|/ a tags=ruby,whitespace,string\
    \ |>\n<| a dscore=5 |>\nHere's a solution that's a little cleaner:\n<code>\ntext\
    \ = \" some text with spaces \".gsub(/\\s+/, '_')\n</code>\n<|/ a tags=ruby,whitespace,string\
    \ |>\n<| c |>\nFor a more generic regex for replacing non-alphanumeric characters\
    \ with an underscore:", "  text.gsub(/\\s+/) { |s| s == \"\" ? s : s.gsub(/\\\
    s+/, \"_\") }\nend\n</code>\n<|/ a |>\n<| a tags=ruby,regex |>\nFor a more concise\
    \ (more rubyesque looking) solution you can use the gsub method on String:\n<code>\n\
    \" Example 1\".gsub(/\\s{2,}/, \"-\")\n=> \"Example-1\"\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThank you - this is very helpful information that I didn't know\
    \ about before.\n<|/ c |>\n<| a |>\n<code>", "  text.downcase! \n  text.gsub!\
    \ /[ ]+/, \"_\"\n  text.gsub! /[ ]+/, \"-\"\n  text.gsub! /([ ]{2,})/, \"_$1\"\
    \n  text\nend\n</code>\n<|/ a |>\n<| c |>\nThis is what I would use. Just one\
    \ correction: You need to add \"end\" to the end of the fix_spaces method.\n<|/\
    \ c |>\n<| c |>\nActually, you don't need to add \"end\" to the end of the method.\
    \ You only need to add it once at the end of the file. Since when you're done\
    \ with Ruby code you need to close the method with `end`.\n<|/ c |>\n<| c |>\n\
    Yeah, I realized that after I made my comment. I just meant that the end keyword\
    \ is optional. :)\n<|/ c |>\n<| a tags=ruby |>\nRuby's regular expressions use\
    \ a special metacharacter for grouping: \"(...)\".\nThis means that you can have\
    \ \"any number of spaces here\" with one regular expression call. \n<code>\n\"\
    Example 1\".gsub(/\\s+/, '_')\n=> \"Example_1\"\n</code>\n<|/ a dscore=5 |>\n\
    <| a |>\nI wrote this helper method in my Rails application to replace multiple\
    \ spaces with a single space:\n<code>", "  # replace single spaces with underscores\n\
    \  text = text.gsub(/\\s+/, '_')", "  return text\nend", "  text.gsub!(/\\s+/,\
    \ \"_\") if text && text.size > 2\n  text.gsub!(/([_]+)(.+)/, \"\\1\\3\")\nend",
  "  text.gsub!(/[ ]+/, \"_\")\n  text.gsub!(/[ ]+/, \"-\")\n  text\nend", "  text.gsub!(/\\\
    s+/, ' ')\n  if text.include?(' ') then \n    text.gsub!(/( +)/, '-') \n  end\
    \ \n  text\nend", "  text.gsub(\" \", \"_\")\n  text.gsub!(/( {2,})/, \"-\")\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis seems to work, but I'm still seeing\
    \ a leading space in the first few lines. When I print the string, there's a leading\
    \ space. How do I get rid of that?\n<|/ c |>\n<| c |>\nUpdated my answer to fix\
    \ the leading spaces.\n<|/ c |>\n<| a tags=ruby,string |>\nI've come up with a\
    \ very simple solution to remove the spaces (in front and at the end of the strings)\
    \ :\n<code>\ntext = \"This is a space at the beginning\"\ntext = text.gsub(\"\
    \ \", \"\")\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThe OP has asked for a solution\
    \ that works on strings that contain multiple spaces consecutively.\n<|/ c |>\n\
    <| a |>\nI prefer using gsub with a block to deal with more complex cases, like\
    \ dealing with multiple spaces and other cases.\n<code>\ns = \"  this is a  test\
    \ string\"\ns.gsub(/[\\s]+/){|s| s.tr('  ', '-')}", "  text.gsub(/\\s+/, ' ').gsub(/\\\
    s{2,}/, '-')\nend\n</code>\n<|/ a |>\n<| a |>\nThis is another method - using\
    \ regular expression substitution with the gsub method of strings:\n<code>\n\"\
    \     Example\".gsub(/\\s+/, '_')\n</code>\n<|/ a tags=ruby,string,ruby-on-rails,regex\
    \ dscore=2 |>\n<| a |>\n<code>\nstring = '  Example '\nstring.gsub(/\\W+|_/, '-')\n\
    </code>\n<|/ a dscore=2 tags=ruby,string,ruby-on-rails,regex |>\n<| a dscore=2\
    \ |>\nHere is a different approach that has worked for me in different situations.\n\
    <code>\nstring.gsub(/\\s|_/, ' ')\n</code>\n<|/ a tags=ruby,string,ruby-on-rails,regex\
    \ |>\n<| a tags=ruby,string,ruby-on-rails,regex dscore=1 |>\nFor string\n<code>\n\
    string = \"     Example\"\n</code>\nUse this regex\n<code>\nstring.gsub(/\\W|_/,\
    \ ' ').squeeze(' ').capitalize\n</code>\nThis will remove any non-word characters\
    \ and replace them with a space then capitalize it.\n<|/ a |>\n<| a dscore=0 |>\n\
    <code>", "  text.gsub(/\\s+/).gsub(/\\s\\+/, \"_\")\nend\n</code>\n<|/ a tags=ruby-on-rails,ruby,ruby-on-rails-4\
    \ |>\n<| a tags=ruby-on-rails,ruby,ruby-on-rails-4 dscore=1 |>\nUse a regexp with\
    \ a look-behind:\n<code>", "  text.gsub!(/\\s+/, \"_\") \n  if text =~ /( )+/\
    \ \n    text.gsub!(/( )+/, '-')\n  end\n  return text\nend\n</code>\n<|/ a tags=ruby\
    \ dscore=3 |>\n<| a dscore=2 |>\nHere's a solution that uses gsub and gsub!, which\
    \ are very powerful tools in Ruby.\n<code>", "  text = text.gsub(/\\s+/, '_')\n\
    \  text = text.gsub(/\\s{2,}/, \"-\")\n  text\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| a dscore=3 |>\n<code>", "\ttext.gsub!( \" \", \"_\" )\n\ttext.gsub!(\
    \ / *\\n/, \"_\" )\n\ttext.gsub!( / *\\r/, \"_\" )\n\ttext.gsub!( /^ */, \"_\"\
    \ )\n\ttext.gsub!( / *$/, \"_\" )\n\ttext.gsub!( /\\n/, \"_\" )\n\ttext.gsub!(\
    \ / *\\n/, \"_\" )\n\treturn text\nend\n\t", "  text.gsub!(/\\s+/, \" \").gsub(/\\\
    s{2,}/, \"-\")\nend", "  text.gsub!(/^ +$/, '')\n  text.gsub!(/( +)/, \"-\")\n\
    \  text.gsub!(/ +$/, '')\n  return text\nend\n</code>\nThen the other method that\
    \ is using the above method:\n<code>", "  text.gsub(/^ +| +$|( +)/, '-')\nend",
  "  text.gsub(\" \", \"_\")\nend\n</code>\n<|/ a tags=ruby-on-rails-3,ruby |>\n<|\
    \ c |>\nI believe this answer to be a better approach\n<|/ c |>\n<| c |>\nThis\
    \ should be the accepted answer as this is the most efficient way of doing it\n\
    <|/ c |>\n<| a tags=ruby-on-rails-3,ruby |>\nThe shortest solution I found (without\
    \ using regex) was this:\n<code>", "\ttext = text.gsub(/ +/, '_')\n\ttext.gsub!(/(_+){2,}/,\
    \ \"_\")\n\treturn text\nend", "  text.gsub(/\\s+/, \"_\").gsub(/\\s{2,}/, \"\
    -\")\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\nI had to add the line `require\
    \ 'rubygems'` before `require 'string'` to get this to work.\n<|/ c |>\n<| c |>\n\
    Thank you! This works like a charm. Didn't think about using gsub with negative\
    \ matches.\n<|/ c |>\n<| c |>\nThis is such a useful utility that I decided to\
    \ add it to the `ruby-core` gem. You can find it [here](https://github.com/rails/ruby-core/blob/master/lib/ruby_core_ext/string/multibyte.rb).\n\
    <|/ c |>\n<| c |>\nA link to the original source of the code: https://github.com/bbatsov/ruby-core/blob/master/lib/ruby_core_ext/string/multibyte.rb\n\
    <|/ c |>\n<| a |>\nTry this:\n<code>\n\"Example string\"\n.gsub(/(^\\s*)|(\\s*$)/,'')\n\
    </code>\n<|/ a dscore=4 tags=string,ruby,regex |>\n<| a |>\nI like to do it this\
    \ way:\n<code>", "  text\n    .gsub(/\\s+/, \"_\")\n    .gsub(/(_){2,}/, \"-\"\
    )\nend", "  text.gsub!(/\\s+/, \" \").gsub!(/(\\s){2,}/, \"-\")\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThis doesn't work.  \"   Example 2   \" becomes \"-Example-2\"\
    \n<|/ c |>\n<| c |>\nYou are correct. Thanks for catching that. Updated my solution.\n\
    <|/ c |>\n<| c |>\nThe OP didn't specify what to do if there are three or more\
    \ consecutive spaces. This is what he wanted: \"_Example-3\" -- an underscore\
    \ followed by a single dash and two dashes.\n<|/ c |>\n<| c |>\nI agree that this\
    \ solution is better, but I do think that the question was phrased incorrectly.\
    \  It was the title, \"Replacing spaces with dashes\" that threw me off, and since\
    \ no one else has done it, I have decided to go with my original answer.\n<|/\
    \ c |>\n<| a tags=ruby,regex |>\nYou could write it as a regexp with a group to\
    \ capture everything before and after the spaces\n<code>\n> \"Example 3\" =~ /([^\
    \ ]+) (.+)/", "  text.gsub!(/\\s+/, \"_\")\n  text.gsub!(/\\s{2,}/, \"-\")\nend\n\
    </code>\n<|/ a |>\n<| c |>\nThis doesn't solve the problem, though.  It just replaces\
    \ them with \"_\"\n<|/ c |>\n<| c |>\nit does. It replaces all whitespaces with\
    \ \"_\". It doesn't care what whitespaces there is in between the words.\n<|/\
    \ c |>\n<| c |>\nActually, I made a mistake.  When I tried this in a Rails console,\
    \ I got the error \"private method `gsub' called for #<String:0x00000000055a4978>\"\
    \n<|/ c |>\n<| c |>\nThis doesn't work if there are two consecutive spaces.  E.g.,\
    \ \" Hello  World\", should return \"Hello-World\", but it returns \"HelloWorld\"\
    \n<|/ c |>\n<| c |>\nThanks for the tips, I updated my answer to include some\
    \ more examples\n<|/ c |>\n<| a dscore=3 |>\nThis may be overkill but this regex\
    \ will do the job (tested with rubular.com):\n<code>\n(^[^\\s])\\s(.*)\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails,ruby-on-rails-4 |>\n<| c |>\nThis won't catch multiple\
    \ spaces though, would need `\\s+` to match multiple spaces.\n<|/ c |>\n<| c |>\n\
    Good catch! Fixed the regex to account for multiple spaces.\n<|/ c |>\n<| a dscore=3\
    \ |>\nHere's an alternative, using the fact that Ruby Strings are arrays of characters:\n\
    <code>\n\"hello     world   !\".gsub(/\\s+/, '_').gsub!(/[^_]_+/, '_')\n=> \"\
    hello_world_!\" \n</code>\nIt uses the fact that the String#[] method can take\
    \ a range of characters as a parameter.  So we can just do:\n<code>\n\"hello \
    \    world   !\".gsub(/\\s+/, '_').gsub!(/[^_]_+/, '_')\n</code>\nThe first gsub!\
    \ call is just converting the spaces into underscores.  Then we have the second\
    \ gsub! call, which replaces any number of underscores followed by another underscore\
    \ with just a single underscore.\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-4\
    \ |>\n<| a dscore=3 |>\nHere's how I would do it:\n<code>\n'hello_world !'.gsub(",
  "  return text.gsub(/[[:space:]]+/, '_')\nend", "  result = \"\"\n  text.scan(/(\
    \ )+/) do |space|\n    result << \"_\"\n  end\n  text.scan(/( )+/) do |space|\n\
    \    result << \"-\"\n  end\n  return result\nend", "  text.gsub!(/\\s+/, \"_\"\
    )\n  if text.gsub!(/(_){2,}/, \"-\")\n  end\n  text\nend\n</code>\n<|/ a tags=ruby-on-rails,ruby,ruby-on-rails-4\
    \ dscore=1 |>\n<| a dscore=1 |>\nThe easiest way would be to define your model\
    \ field as:\n<code>\n your_field: ->(val) { val.gsub!(/\\s+/, '_') }\n</code>\n\
    This creates a new method called your_field and assigns it the value of the given\
    \ lambda expression that modifies the given value of your_field.\n<|/ a tags=ruby-on-rails,ruby,ruby-on-rails-4\
    \ |>\n<| a tags=ruby-on-rails,ruby,ruby-on-rails-4 dscore=0 |>\nI created a simple\
    \ regex to match multiple spaces, and replace them with single space in case of\
    \ multiple consecutive spaces.\n<code>\n/\\s+/\n</code>\nIt worked fine for me\n\
    <code>\nstring.gsub(/\\s+/, '-').gsub!(/\\s+/, ' ')\n</code>\n<|/ a |>\n<| a tags=ruby-on-rails,ruby,ruby-on-rails-4\
    \ |>\nYou can use gsub! to modify the string:\n<code>\nstring = \"Example Example\
    \ Example Example Example\"\nstring.gsub!( /\\s+/, '_' )\nputs string", "  text.gsub(/\\\
    s+/, '_').gsub(/  /, '-').tr(' ', '-')\nend\n</code>\n<|/ a dscore=1 |>\n<| c\
    \ |>\nHow would you rewrite this so that it works on multiple line strings?\n\
    <|/ c |>\n<| c |>\njust put it in a for loop :)\n<|/ c |>\n<| c |>\nSorry, I'm\
    \ very new to ruby programming. Could you give me an example of the for loop?\n\
    <|/ c |>\n<| c |>\n`text.gsub(/\\s+/, '_').gsub(/  /, '-').tr(' ', '-')` this\
    \ line is a block of code, just put this in a loop like `for i in 0...text.length\
    \ do text << block.call end `\n<|/ c |>\n<| a |>\n<code>", "  return text.gsub(/\\\
    s+/, \" \").gsub(/( {2,})/, \"-\").strip\nend", "  text.gsub!(/^\\s+/, \"\") \n\
    \  text.gsub!(/\\s+$/, \"\") \n  text.gsub!(/  /, \"_\") \n  if text.gsub(/\\\
    s{2,}/, \"_\").length >= 2 \n    text.gsub!(/\\s+/, \"-\") \n  end \n  text \n\
    end \n</code>\n<|/ a dscore=4 |>\n<| a tags=ruby,ruby-on-rails |>\n<code>", " \
    \ # Remove trailing whitespace\n  text = text.rstrip\n  \n  # Replace multiple\
    \ spaces with one space\n  text = text.gsub(/\\s+/, ' ')\n  \n  # Replace single\
    \ spaces with dashes\n  text = text.gsub(/ /, '-')\n  \n  return text\nend", " \
    \ text.gsub(/\\s+/, \"_\")\n  text.gsub!(/( )+/, \"-\")\n  return text\nend\n\
    </code>\n<|/ a dscore=3 tags=ruby |>\n<| c |>\nIf you're going to use the [gsub](http://www.ruby-doc.org/core-2.1.2/String.html#method-i-gsub)\
    \ method anyway, you don't need to write your own method.\n<|/ c |>\n<| c |>\n\
    The method I originally posted was for fixing the spacing, not for generating\
    \ random numbers. The second part was for the random number, which I wanted to\
    \ be able to re-use in other projects.\n<|/ c |>\n<| c |>\n`rand` returns a number,\
    \ so `rand.to_s.gsub(/\\s+/,'_')` would do the same.\n<|/ c |>\n<| a tags=ruby\
    \ dscore=3 |>\nAs the other answer says, the problem is that your string isn't\
    \ in fact random. It contains some random characters, and some spaces.\nTo get\
    \ a random number that is random, you need to create a random number between 1\
    \ and 26, and then subtract that many spaces from the random number:\n<code>",
  "  text.gsub(/\\s+/, \"_\").gsub(/(?<=_)\\s+/, \"-\")\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=ruby,ruby-on-rails |>\nI made some minor changes to the answer\
    \ of as my use case is slightly different. I needed to add hyphens between the\
    \ last two words of the sentence, while keeping the words untouched (and in place).\
    \ I have made the change so that you can also change the number of spaces. I also\
    \ changed the variable names accordingly. Here's the code that worked:\n<code>",
  "  return text.gsub(/\\s+/, \"_\").gsub(/\\s+/, '-')[0..-3]\nend", "  text.gsub!(/[\
    \ ]{2,}/, \"-\")\n  text.gsub!(/[ ]+/, \" \")\n  return text\nend\n</code>\n<|/\
    \ a tags=ruby,regex,string,ruby-on-rails,ruby-on-rails-4 |>\n<| c |>\nThis code\
    \ will remove multiple spaces and replace it with single space whereas OP asked\
    \ for multiple space and `-` sign.\n<|/ c |>\n<| c |>\nThis won't work on words\
    \ with more than two or more spaces.\n<|/ c |>\n<| c |>\n, you are right I didn't\
    \ read well the question ... and it's strange that nobody said about word with\
    \ more than two spaces ! I'll edit\n<|/ c |>\n<| c |>\n, I've added a second answer\
    \ for your problem with words containing more than 2 spaces\n<|/ c |>\n<| a tags=ruby,regex,string,ruby-on-rails,ruby-on-rails-4\
    \ |>\nThis will work for any number of spaces, including none:\n<code>", "  text.gsub!(\"\
    \ \",\"_\")\n  text.gsub!(/[ ]{2,}/,\"_\")\n  text.gsub!(/[ ]+/,\"_\")\nend\n\
    </code>\n<|/ a dscore=5 tags=ruby,ruby-on-rails,ruby-on-rails-3.2,ruby-on-rails-3\
    \ |>\n<| c |>\nYeah, this is much cleaner than the other solutions. Thanks for\
    \ your help.\n<|/ c |>\n<| c |>\nThis works great, but can you please let me know\
    \ how you came up with the `2` for the regex to match 2 spaces? I've been trying\
    \ to find the documentation but no luck so far.\n<|/ c |>\n<| c |>\nIt seems that\
    \ `[ ]{2,}` matches any character between 2 and unlimited times. So if I put `[\
    \ ]{2,}` at the end of my regex, it will match 2 spaces and 2 other characters.\
    \ Therefore, I used `{2,}` to match 2 spaces.\n<|/ c |>\n<| c |>\nI didn't think\
    \ about this case before, thanks for the explanation.\n<|/ c |>\n<| c |>\nThe\
    \ `[ ]{2,}` means match any consecutive sequence of two spaces OR two other characters.\
    \ So you can have one space or two spaces or one space with two other characters.\
    \ You can have a lot of other characters as well, like a comma, a period, a dash,\
    \ a slash, etc...\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3.2,ruby-on-rails-3\
    \ |>\nThis is an old question, but it's still a relevant one as I was just struggling\
    \ with it myself. What I have found is that while Rails makes it fairly easy to\
    \ create simple before_save or before_create or whatever callbacks based on model\
    \ validations, it can be difficult to handle any other model functionality (callbacks,\
    \ validators, callbacks, etc) without using some kind of meta-programming.\nHere's\
    \ what I've come up with:\n<code>\nmodule ActiveRecord::Callbacks\n  module Validations\n\
    \    module ClassMethods\n      def with_validate_callbacks(&block)\n        validates_with(*callback_names,\
    \ &block)\n      end", "  text = text.to_s.gsub(\" \",\"_\")\n  text = [text]\
    \ if (text =~ /\\w{2,}/) \n  text.each {|word| word = word.gsub!(/(-){2,}/,\"\
    -\") }\n  text.join(\" \")\nend", "  text.gsub(/\\s+/, \"_\").gsub(/( \\1)+/,\
    \ \"_\\1\")\nend", "  text.gsub(/\\s+/, '_').gsub(/\\s{2,}/, '-')\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThis would be a better answer if you explained how\
    \ the code you provided answers the question.\n<|/ c |>\n<| c |>\nI updated my\
    \ answer with a more detailed description and an example of how to use the code.\n\
    <|/ c |>\n<| a tags=ruby |>\nI prefer this way (without regex):\n<code>\ntext\
    \ = \" abc def ghi \"\ntext.gsub(/\\s+/, '_')", "  return text.gsub(/\\s+/, '\
    \ ').gsub(/  +/, '-')\nend\n</code>\n<|/ a |>\n<| a tags=ruby-on-rails,ruby-on-rails-3,ruby\
    \ |>\nHere's an alternative that uses regular expressions to find and replace\
    \ more than one space in a string. \n<code>", "  return text.gsub(/[ ]+/, '_').gsub(/[\
    \ -]+/, '_')\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby |>\n<code>", " \
    \ text.gsub(\" \", \"_\")\n    \n  # Get all text after the first space, \n  #\
    \ if the text has a space after the first space, then \n  # add an underscore\n\
    \  text = text.gsub(/ *([^ ]+) /, \"\\\\1\")\n  text.gsub(/( [^ ]+) +/, \"_\\\\\
    1\")\nend\n</code>\n<|/ a tags=ruby,string,regex |>\n<| a |>\nI wrote this function\
    \ a while ago, which allows you to replace one or more spaces with underscores\
    \ based on what word is on either side of the space:\n<code>", "\ttext = text.gsub(/\\\
    s+/, \"_\").gsub(/\\s+/, '-')\n\ttext.gsub!(/^[-_]+/,'')\n\ttext.gsub!(_+$/, '')\n\
    \treturn text\nend\nend\n</code>\n<|/ a |>\n<| a dscore=0 tags=string,ruby |>\n\
    <code>", "  text.gsub!(/ +/, '_')\n  if text.include?(\"  \")\n    text.gsub!(\"\
    \  \", '-')\n  end\n  return text\nend", "  text.gsub!(\" \", \"_\")\n  text.gsub!(/\
    \ +/, \"_\")\n  text.gsub!(/(\\s)\\1+/, \"_$1\")\n  text\nend\n</code>\n<|/ a\
    \ |>\n<| a |>\nYou can try this ruby code :\n<code>", "  return text.gsub(/[ ]{2,}/,\
    \ '_').gsub(/[ ]{2,}/, '-')\nend\n</code>\nThe only difference is that the example\
    \ 3 won't get replaced because there are 3 spaces. To handle that, we can use\
    \ the first regex to match any number of spaces, and then another regex to match\
    \ either two or three spaces, and replace the two or three spaces with an underscore.\n\
    <|/ a tags=ruby,regex |>\n<| c |>\nThe third one doesn't get replaced.\n<|/ c\
    \ |>\n<| c |>\n: No, it does get replaced: http://rubular.com/r/dT8EUZ2JYV\n<|/\
    \ c |>\n<| c |>\n: I must be missing something, because your solution doesn't\
    \ work in Ruby 1.8. http://rubular.com/r/XMNKWfO8vT\n<|/ c |>\n<| c |>\n: Actually,\
    \ that does work in Ruby 1.8.7. http://rubular.com/r/1ZuZB9xVmM\n<|/ c |>\n<|\
    \ c |>\n: I added a better example and explanation\n<|/ c |>\n<| a tags=ruby,regex\
    \ |>\nIf you just want a regex that matches any number of spaces, you could use\
    \ this:\n<code>\n[ ]{2,}\n</code>\nFor example:\n<code>\n\"Example   example\"\
    [/[ ]{2,}/]", "  if text == \"\"\n    return \"\"\n  text = text.to_s\n  text.gsub!(/\\\
    s{1,}/, \"_\")\n  text.gsub!(/\\s{2,}/, \"-\")\n  return text\nend", "  # We can't\
    \ replace all spaces with underscores, \n  # because this can lead to problems\
    \ \n  # if there are multiple consecutive underscores\n  return text.gsub(/( _)+/,\
    \ \"-\")\nend", "  text.gsub!(/\\s+/, '_')\n  text.gsub!(/([^_])(\\s+)([^_])/,\
    \ '\\1_\\2_\\3')\n  text.gsub!(/([^_])(\\s+)(\\1)/, '\\1_\\2_\\3')\n  text.gsub!(/([^_])(\\\
    s+)(\\1)/, '\\1_\\2_\\3')\n  text.gsub!(/([^_])(\\s+)(\\1)/, '\\1_\\2_\\3')\n\
    \  text.gsub!(/([^_])(\\s+)(\\1)/, '\\1_\\2_\\3')\n  text.gsub!(/([^_])(\\s+)(\\\
    1)/, '\\1_\\2_\\3')\n  text.gsub!(/([^_])(\\s+)(\\1)/, '\\1_\\2_\\3')\n  text.gsub!(/([^_])(\\\
    s+)(\\1)/, '\\1_\\2_\\3')\n  text.gsub!(/([^_])(\\s+)(\\1)/, '\\1_\\2_\\3')\n\
    \  text.gsub!(/([^_])(\\s+)(\\1)/, '\\1_\\2_\\3')\n  text.gsub!(/([^_])(\\s+)(\\\
    1)/, '\\1_\\2_\\3')\n  text.gsub!(/([^_])(\\s+)(\\1)/, '\\1_\\2_\\3')\n  text.gsub!(/([^_])(\\\
    s+)(\\1)/, '\\1_\\2_\\3')\n  text.gsub!(/([^_])(\\s+)(\\1)/, '\\1_\\2_\\3')\n\
    \  text.gsub!(/([^_])(\\s+)(\\1)/, '\\1_\\2_\\3')\n  text.gsub!(/([^_])(\\s+)(\\\
    1)/, '\\1_\\2_\\3')\n  text.gsub!(/([^_])(\\s+)(\\1)/, '\\1_\\2_\\3')\n  text.gsub!(/([^_])(\\\
    s+)(\\1)/, '\\1_\\2_\\3')\n  text.gsub!(/([^_])(\\s+)(\\1)/, '\\1_\\2_\\3')\n\
    \  text.gsub!(/([^_])(\\s+)(\\1)/, '\\1_\\2_\\3')\n  text.gsub!(/([^_])(\\s+)(\\\
    1)/, '\\1_\\2_\\3')\n  text.gsub!(/([^_])(\\s+)(\\1)/, '\\", "    text.gsub!(/\\\
    s+/, \"_\")\n    if text.index(\" \") >= 2\n        text.gsub!(/([^ ])( {1,2})/,\
    \ \"\\1_\\2\")\n    end\n    text\nend", "  text.gsub!(/[ ]+/, '_')\n  text.gsub!(/(?<=\\\
    s)[ ]+/, '-')\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\n`text.gsub!(/[ ]+/, '_')`\
    \ replace two or more spaces with a single `_`. `text.gsub!(/(?<=\\s)[ ]+/, '-')`\
    \ replaces one space with two consecutive `-` symbols.\n<|/ c |>\n<| a tags=ruby,string,replace\
    \ |>\n<code>", "  text.gsub(\" \", \"_\").gsub(/\\s{2,}/, \"-\")\nend\n</cell>\n\
    <cell>", "  text.gsub!(/  /, \"_\") if text.size > 2\n  text.gsub!(/  /, \"-\"\
    )\nend", "  text.gsub!(\" \",\"_\")\n  text.gsub!(/( {2,})/,\"_\\\\1\")\n  text.gsub!(/(\
    \ {2,})/,\"_\\\\1\")\nend\n</code>\n<|/ a dscore=3 |>\n<| a tags=ruby |>\n<code>",
  "  result = \"\"\n  text.split(\" \").each do |word|\n    result += \"_\" + word.tr(\"\
    \ \",\"_\") + \"-\"\n  end\n  result\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby\
    \ |>\nI realise this is an old question - but for anyone looking to do this in\
    \ Rails, you can do:\n<code>\n\"Test   test   test\".humanize\n</code>\nThis will\
    \ give you:\n<code>\n\"Test test test\"\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    This is great for strings that already contain spaces. Thanks!\n<|/ c |>\n<| c\
    \ |>\nThis does not work with `CamelCaseNames` which has three consecutive spaces.\
    \ `CamelCaseNames -> Camel-Case-Names`.\n<|/ c |>\n<| a |>\n<code>", "  text.gsub!(/\\\
    s+/, \" \").gsub(/( {2,})/, '-')\n  text\nend", "  text.gsub!(/\\s+/, ' ') \n\
    \  if text.size > 2\n    text.gsub!(/( )+/, '-') \n  end\n  return text\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=ruby,string,regex |>\nI like the other answers\
    \ here, but I wanted to add another one that uses negative lookahead and lookbehind\
    \ to prevent two consecutive spaces from splitting the string up.  \n<code>\n\"\
    Example 1\".gsub(/(?<! )(?! )(?!\\s)/, \"_\") #=> \"Example_1\"\n</code>\nThe\
    \ reason I like this is that it is very readable, and it also works on any number\
    \ of spaces.\n<|/ a dscore=1 |>\n<| a |>\nHere's another way that uses String#split:\n\
    <code>\n\"Example 1\".split(\" \").join(\"-\") #=> \"Example-1\"\n</code>\n<|/\
    \ a tags=ruby,string,regex dscore=0 |>\n<| a |>\n<code>", "  text.gsub!(\" \"\
    , \"_\")\n  text.gsub!(/\\s+/, \"-\")\n  text.gsub!(/ +(?=[^\\s])/, \"_\")\nend\n\
    </code>\n<|/ a dscore=5 |>\n<| c |>\nThis should be the selected answer because\
    \ it avoids adding any additional gem dependency to rails.\n<|/ c |>\n<| a |>\n\
    <code>", "  text.gsub(/\\s+/) {|s| s.gsub(/\\s+/, '-')}\nend", "    text.gsub!(/\\\
    s+/, \" \").gsub!(/\\s{2,}/, \"-\")\nend", "  text.gsub!(\" \",\"_\")\n  text.gsub!(/\\\
    s+/,\"_\")\n  return text\nend", "  text = text.gsub(\" \", \"_\")\n  text.gsub!(/\
    \  /, \"-\")\n  text\nend\n</code>\n<|/ a tags=ruby,regex |>\n<| a tags=ruby,regex\
    \ |>\nI came up with something like this:\n<code>", "  text.gsub(\" \", \"_\"\
    ).gsub(\"  \", \"_\")\nend", "  return text.gsub(/ +/, '_').gsub(/[^_]+(?=_{2,})/,\
    \ '-')\nend", "  if text.blank?\n    \"\"\n  elsif text.blank? && text.length\
    \ <= 2\n    text.to_s\n  else\n    text.to_s.gsub(/\\s+/, \"_\").gsub(/(\\s)+/,\
    \ \"_\")\n  end\nend\n</code>\n<|/ a |>\n<| a dscore=2 tags=ruby,ruby-on-rails,ruby-on-rails-3,ruby-on-rails-3.2\
    \ |>\nI used this snippet to fix whitespace:\n<code>", "    text.gsub!(/\\s+/,\
    \ \"_\") unless text.gsub(/^_+/, \"\").empty? && text.gsub(/_+$/, \"\").empty?\n\
    \    text.gsub!(/\\s+/, \"-\") unless text.gsub(/^-+/, \"\").empty? && text.gsub(/-+$/,\
    \ \"\").empty?\n    text\nend", "  text.gsub!(/\\s+/, \"_\")\n  if text.gsub!(/(\
    \ )+/, \"-\") && text.gsub!(/( )+/, \"\") \n    text.gsub!(/-+/, \"_\")\n  end\n\
    \  text\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,string |>\n<| c |>\nThanks\
    \ Steve! This helped me immensely.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,string\
    \ |>\nHere is an extension to the accepted answer. Although Steve's answer works,\
    \ this extension is more straightforward and more intuitive to me. \n<code>",
  "  text.gsub(\" \", \"_\").gsub(\"  \", \"_\").gsub(\"  \", \" \")\nend\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nGood idea, but unfortunately this doesn't work for\
    \ the general case (e.g., in the question \"Example 1 2 3\")\n<|/ c |>\n<| c |>\n\
    I believe I figured out the general case, and updated my answer accordingly.\n\
    <|/ c |>\n<| a dscore=3 |>\nI ended up writing a custom method on my Rails app\
    \ that does just this.\n<code>", "  text.gsub!(/\\s+/, \" \")\n  if text.size\
    \ > 2\n    text.gsub!(/\\s+/, \"-\")\n  end\n  text\nend\n</code>\n<|/ a tags=ruby,regex\
    \ |>\n<| c |>\nThis is great! Thanks! And thank you all for your comments! I really\
    \ appreciate the time taken to share some of these ideas!\n<|/ c |>\n<| a |>\n\
    This is my take on a solution which converts multiple spaces to a single dash\
    \ and removes leading and trailing dashes:\n<code>", "  return text.gsub(/\\s+/,\
    \ '_').gsub(/\\s{2,}/, '-')\nend", "  return text.gsub(/\\s+/, \"_\").gsub(/\\\
    s+(?=(?=\\S))/, \"-\")\nend", "  text.gsub(/\\s+/, \" \").gsub(/(\\s)\\1+/, \"\
    _\") \nend", "  text.gsub(/\\s+/, '_')\n  text.gsub(/\\s{2,}/, '-')\nend", " \
    \ return text.gsub(/\\s+/, '_') unless text.blank?\n  (text.gsub(/(\\s{2,})/,\
    \ '-') until text.index(' ')).join('_')\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| c |>\nI came up with the answer myself after looking at your answer -\
    \ you might want to include that in your answer.\n<|/ c |>\n<| a dscore=4 tags=ruby,string\
    \ |>\n<code>", "  text.gsub!(/\\s+/, \"_\")\n  text.gsub!(/( {2,})/, \"-\")\n\
    end", "  text.gsub(/\\s+/, '_')\n  text.gsub(/(?<=\\s)\\s(?=\\s)/, '-')\nend\n\
    </code>\nIt works by replacing any sequence of one or more whitespace characters\
    \ with a single underscore.  We then replace any sequence of two or more whitespace\
    \ characters with a hyphen only if they are separated by another space character.\
    \  This ensures that adjacent spaces are replaced with one hyphen.\n<|/ a tags=ruby,ruby-on-rails\
    \ dscore=0 |>\n<| c |>\nThank you for your suggestion, I have updated my question.\n\
    <|/ c |>\n<| c |>\nThanks for the update.  I still think my solution works well\
    \ and I recommend that you stick with it.\n<|/ c |>\n<| c |>\nThanks. I got confused\
    \ because I thought that gsub is used to replace text by another text. It works\
    \ great now.\n<|/ c |>\n<| c |>\nPlease don't add `<br>` to your answers. Edit\
    \ your answer and put it in there. Markdown will take care of it for you.\n<|/\
    \ c |>\n<| c |>\nIt was my first time posting a question and I didn't know about\
    \ that.  Thank you for pointing that out.  I edited my answer accordingly.\n<|/\
    \ c |>\n<| a |>\nI'm guessing you're trying to get a string with two spaces instead\
    \ of one? If so, this should do it:\n<code>\n> \"foo   bar\".gsub(/(\\s)\\1+/,\
    \ \"\\1\")\n=> \"foo bar\"\n</code>\n<|/ a dscore=0 tags=ruby,ruby-on-rails |>\n\
    <| c |>\nThank you for your suggestion, I have updated my question.\n<|/ c |>\n\
    <| a tags=ruby,ruby-on-rails |>\nI did this recently and ended up with something\
    \ like this:\n<code>", "  text.gsub!(/^ +$/, \"_\")\n  text.gsub!(/ {2,}/, \"\
    _\")\n  text.gsub!(/ +/, \"-\")\n  text.gsub!(/^(-|_)(.*)/){$2.blank? ? \"-\"\
    \ : \"_\"}\n  text\nend\n</code>\n<|/ a |>\n<| a |>\nHere's a solution that doesn't\
    \ use regular expressions, but rather a regex:\n<code>", "  if text.nil? or text.empty?\n\
    \    return nil\n  end\n  text = text.gsub(/\\s+/, \" \").gsub(/( {2,})/, \"_$1\"\
    )\n  return text unless text.index(\"_\")\n  while text.index(\"_\")\n    text\
    \ = text.gsub(/_+/, \"_\")\n  end\n  return text\nend", "    text.gsub!(\" \"\
    ,\"_\")\n    text.gsub!(/\\s{2,}/,\"_\")\n    text.gsub!(/\\s\\s/,\"-\")\n   \
    \ text.strip!\nend\n</code>\n<|/ a tags=ruby,regex,ruby-on-rails |>\n<| c |>\n\
    Your answer was awesome, but a couple of things were not clear from your answer.\
    \ First, you used `gsub!` instead of `sub!` because you wanted to modify the string\
    \ in-place; however, you used `gsub` because you wanted the result of the substitution\
    \ to be returned. Also, when you said \"a regex like `/\\s{2,}/` would be an alternative\"\
    , you said \"an alternative to a regex\", but you didn't explain why it was an\
    \ alternative. Finally, why did you include the space in your regex inside the\
    \ curly braces of the first sub?\n<|/ c |>\n<| c |>\n`gsub!` makes it *all* changes\
    \ in the string, including whitespace around the first character of the string.\
    \ `sub!` does the same thing only with the first character. Since you were wanting\
    \ to only make changes to whitespace at the beginning of the string, I chose `gsub!`\
    \ because that's the first thing that pops up in most guides. `sub!` would have\
    \ made changes to white space in the middle of the string and could have made\
    \ the first character lowercase if it wasn't already.\n<|/ c |>\n<| c |>\nAs for\
    \ your other question, I'm not entirely sure I understand what you're asking.\
    \ I'm not entirely sure how a regex like `/\\s{2,}/` would be an alternative to\
    \ a regex, but I suppose it's possible that someone with more experience with\
    \ regex could provide an explanation. On another note, I was also surprised to\
    \ see you used `sub!` instead of `gsub!` on the `text` variable, as `gsub!` is\
    \ more commonly used with regular expressions. Since I'm pretty new to ruby, I\
    \ thought that `sub!` was the same as `gsub`, but it turns out they're different.\n\
    <|/ c |>\n<| a tags=ruby,regex,ruby-on-rails dscore=1 |>\n<code>\ns = %q{\n  Hello\n\
    \  My name is \n  Mr. Jones\n  Hello my name is \n  Mr. Jones \n  and I'm \n \
    \ Mr.Jones \n}", "  return text.gsub(/\\s+/, \"_\") if text.size > 2 ? text.gsub(/\\\
    s+/, \"_\").gsub(/\\s+/, \"-\") : text\nend\n</code>\n<|/ a dscore=2 |>\n<| a\
    \ |>\nThis should work for you:\n<code>", "  text.gsub!('\\ ', '\\_ ')\n  text.gsub!('\\\
    s', '\\- ') if text.index(' ').odd?\n  text\nend\n</code>\n<|/ a dscore=5 |>\n\
    <| c |>\nThis one was helpful for me. \nHowever, I needed a more complete answer\
    \ so I created my own based on it: \n \n```\nmodule Replacements\n  def replace_spaces(text)\n\
    \    text.gsub('\\ ', '\\_ ')\n    text.gsub('\\s', '\\- ') if text.index(' ').odd?\n\
    \  end", "  text.gsub(/\\s+/) {|m| m.size == 2 ? \"-\" : m.downcase}\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=ruby,string |>\nI like doing this the hard way:\n\
    <code>", "  text = text.gsub(/\\s+/, \"_\").gsub(/\\s{2,}/, \"-\")\nend\n</code>\n\
    Then, in your view file, you can use:\n<code>\n<% if %>\n  <%= fix_spaces %>\n\
    <% else %>\n  <%= \"\" %>\n<% end %>\n</code>\n<|/ a |>\n<| a dscore=4 |>\nRails\
    \ provides an easy way to generate slugs. You can use to_param to generate the\
    \ slugs.\n<code>", "  text.gsub(/ +/, '_').gsub(/( {2,})/, \"-\").downcase\nend\n\
    </cell>\n<text>\nIn Ruby, gsub! does not modify the original string, it creates\
    \ a new string. It would be more idiomatic in Ruby to return the altered text\
    \ and assign that result to a variable:", "  text = text.to_s\n  text.gsub!(/[\
    \ ]/, \"_\")\n  if text.gsub(/[ ]+/, \"_\").length > 2\n    text.gsub!(/[ ]+/,\
    \ \"-\")\n  end\n  text\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n<code>", "  return text.gsub(/\\\
    s+/, \" \").gsub(/[  ]+/, \"-\")\nend", "    text.gsub!(/\\s+/, \"_\")\n    text.gsub!(/([^\
    \ ]{2,}){2,}/,\"_\\\\1\")\n    text.gsub!(/(\\s){2,}/,\"-\")\n    text.strip!\n\
    end\n</code>\n<|/ a |>\n<| a dscore=0 tags=ruby,gsub,regex,ruby-on-rails |>\n\
    <code>\nirb(main):002:0> text = \"Example Example Example\"\n=> \"Example Example\
    \ Example\"\nirb(main):003:0> text.gsub!(/(\\s)/,\"_\\\\1\").gsub(/(\\s){2,}/,\"\
    -\")\n=> \"Example_Example_Example\"\n</code>\n<|/ a |>\n<| c |>\nThis is not\
    \ an answer to the question, just an alternative solution. Besides, there is no\
    \ need to escape a single quote.\n<|/ c |>\n<| a |>\nI believe your question can\
    \ be rephrased as: \"How do I replace all spaces with underscores?\"  If this\
    \ is true then you just need to replace the spaces with underscores.  The gsub\
    \ method is just what you need. \n<code>\n\"Example Example Example\".gsub(/\\\
    s+/, '_')\n</code>\nThis will return \"Example_Example_Example\"\n<|/ a dscore=0\
    \ tags=ruby,gsub,regex,ruby-on-rails |>\n<| c |>\nThis is not an answer to the\
    \ question, just an alternative solution. Besides, there is no need to escape\
    \ a single quote.\n<|/ c |>\n<| c |>\nI assumed the OP wanted to preserve spaces\
    \ in the string.\n<|/ c |>\n<| c |>\nThis answer is simply wrong.\n<|/ c |>\n\
    <| a dscore=0 |>\nYou don't need a regex for this. Just use String#gsub:\n<code>\n\
    \"Example Example Example\".gsub(/\\s+/, '_')\n</code>\n<|/ a tags=ruby,gsub,regex,ruby-on-rails\
    \ |>\n<| c |>\nThis is not an answer to the question, just an alternative solution.\
    \ Besides, there is no need to escape a single quote.\n<|/ c |>\n<| c |>\nThis\
    \ answer is simply wrong.\n<|/ c |>\n<| a tags=ruby,gsub,regex,ruby-on-rails |>\n\
    There are 2 ways:", "  return text.gsub(/\\s+/,'_').gsub(/\\s{2,}/,'-')\nend\n\
    </code>\n<|/ a tags=ruby,regex |>\n<| c |>\nThanks for your answer. It works in\
    \ my Ruby 2.1.3 REPL, but when I put it in a script, it gives the error `undefined\
    \ method gsub for \"Example 1\":String`\n<|/ c |>\n<| c |>\nIt works in irb but\
    \ fails in script when a string is passed as a parameter. Is there a way to make\
    \ it work in scripts?\n<|/ c |>\n<| c |>\nSorry I missed `call` call in code example.\
    \ Updated my answer, it should work now.\n<|/ c |>\n<| a tags=ruby,regex |>\n\
    My answer is more like a variant of the answer by Rudi. The only difference is\
    \ that I use the method gsubn and I pass a block to it. That way, I do not need\
    \ to worry about the number of spaces between the words.\nThe code:\n<code>",
  "  text = text.gsub(/[[:space:]]/, '_')\n  text = text.gsub(/(?<!\\s)_{2,}/, '-')\n\
    \  text\nend\n</code>\n<|/ a dscore=2 tags=ruby |>\n<| a |>\nI like using gsub\
    \ with a regex to make sure there is only one space.\n<code>", "  text.gsub(\"\
    \ \", \"_\")\n  if text.include?(\"  \")\n    text.gsub!(/  /, \"-\")\n  end\n\
    \  return text\nend", "    text.gsub(\" \", \"_\")\n    text.gsub(\"  \", \"_\"\
    )\n    if text.size > 1\n        text.gsub(\"  \", \"_\")\n    end\nend", "  text.gsub(/\\\
    s+/, '_')\n         .gsub(/(?:\\A|\\s+)\\s+/, '_')\n         .gsub(/\\s+/, '-')\n\
    end", "  text.gsub!(/\\s+/, \"_\")\n  return text if text.scan(/\\s{2,}/).empty?\n\
    \  text.gsub!(/\\s+/, \"-\")\nend\n</code>\nIf you're doing this kind of thing\
    \ often, you could write a function that takes a string and another function that\
    \ processes each character in the string, and returns the modified string.  Then\
    \ you could write something like this:\n<code>", "  # Replace any leading spaces\
    \ with _\n  text.gsub!(/^\\s+/, \"_\") \n  # Replace any consecutive spaces with\
    \ -\n  text.gsub!(/[ ]+/, \"-\")\n  # Replace any trailing spaces with -\n  text.gsub!(/\\\
    s+$/, \"-\")\n  return text\nend", "  text.gsub(/^ +| +$/, '').gsub(/(?<= )(\\\
    s)(?=\\s)/, '-')\nend\n</code>\n<|/ a |>\n<| c |>\nThat works fine for the example,\
    \ but fails for text containing punctuation like `\"Example.?!\"`. Should `\"\
    \ Example ?!\"` become `\"Example-?\"` or `\"Example-_?\"`?\n<|/ c |>\n<| c |>\n\
    Good point. I think I'll keep it simple and do something like `\"(?<=\\s)(\\p{P})(?=\\\
    s)\"`. Perhaps `gsub` with `Regexp::UNICODE_LETTER_NAMES` will work better. I'm\
    \ just not sure how to use that feature to identify the punctuation characters\
    \ without being too hacky.\n<|/ c |>\n<| c |>\nNice answer! I upvoted it but just\
    \ wanted to point out that you don't need the `(?<!\\S)` and you can just use\
    \ `\\p{P}`. I'm also adding an answer with my own approach using Perl's unicode\
    \ character classes which doesn't use `\\p{P}`\n<|/ c |>\n<| a tags=ruby,regex\
    \ |>\nOne option would be to match and replace all non-whitespace chars followed\
    \ with whitespace chars and capture the trailing whitespace char. Then, in the\
    \ replacement, replace the leading whitespace chars with an underscore. \n<code>\n\
    s = \"Example text\"\ns.gsub(/[^\\s]+\\s+/) { |m| m.sub(/^\\s+/, '_') }", "  return\
    \ text.gsub(/\\s+/, '-').gsub(/\\s+/, '-').gsub('  ', ' ')\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nThe OP wants underscores when the string is 3 or more consecutive\
    \ spaces.\n<|/ c |>\n<| c |>\n: I actually have no idea why the OP wants anything\
    \ like this. It seems like a pointless thing to do, as I understand it.\n<|/ c\
    \ |>\n<| c |>\nMy reading is that he wants underscores *when the string is 3 or\
    \ more consecutive spaces*.  It's not pointless, it's useful to know that :)\n\
    <|/ c |>\n<| a dscore=4 |>\nMy solution:\n<code>", "  text = text.strip.gsub(/\\\
    s+/, ' ').gsub(/([-]{2,})/, '\\1')\n  return text\nend\n</code>\n<|/ a |>\n<|\
    \ a tags=ruby,string,replace |>\nAnother way without using regexp\n<code>", " \
    \ text.gsub(\" \", \"_\")\n  text.gsub!(/ *\\s/, \"_\")\n  text.gsub!(/ +/, \"\
    _\")\n  text.gsub!(/ -+/, \"-\")\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2\
    \ tags=ruby,string |>\nThis simple method will strip consecutive spaces down to\
    \ a single space:\n<code>", "  text.gsub!(/\\s+/, ' ')\n  text.gsub!(/[ ]{2,}/,\
    \ '_')\n  text.gsub!(/[ ]{2,}-/, '-')\n  text\nend\n</code>\n<|/ a |>\n<| c |>\n\
    You don't need the last two gsubs, gsub can replace multiple times per string.\n\
    <|/ c |>\n<| c |>\nThe last two gsubs are not needed if you use a single gsub\
    \ call.  It just keeps the code clean by not repeating things.\n<|/ c |>\n<| c\
    \ |>\n, no, gsub can replace multiple times per string. http://ruby-doc.org/core-2.1.3/String.html#method-i-gsub\n\
    <|/ c |>\n<| c |>\n, I don't see how multiple gsubs replace multiple times per\
    \ string if I'm understanding you correctly.  What you're saying is that gsub!\
    \ is equivalent to gsub(/(...)/, \"\\1\\1\").  That isn't true, multiple gsubs\
    \ can *replace multiple times per string*.  I guess I'm just not understanding\
    \ what you're saying.\n<|/ c |>\n<| c |>\nYes, you're right. My mistake.\n<|/\
    \ c |>\n<| a dscore=5 tags=ruby |>\n<code>\nstring.gsub(/\\s+/, ' ').gsub(/\\\
    s*--\\s*/, '-')\n</code>\n<|/ a |>\n<| c |>\nThis was the only one that worked\
    \ to replace consecutive spaces/tabs with underscores while removing all spaces.\
    \ All other answers replace with single underscore.\n<|/ c |>\n<| c |>\nThe first\
    \ gsub replace all spaces with one space, the second gsub replace all double spaces\
    \ with single spaces and the third gsub replace all double dashes with single\
    \ dashes.\n<|/ c |>\n<| a dscore=5 |>\n<code>\ns.gsub(/\\s+/, ' ').gsub(/--+/,\
    \ '-')\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis would replace consecutive dashes\
    \ with one dash instead, which is not what the OP asked for\n<|/ c |>\n<| a tags=ruby\
    \ dscore=5 |>\n<code>\ns.gsub!(/[\\s]+/, ' ').gsub!(/--+/, '-')\n</code>\n<|/\
    \ a |>\n<| c |>\nI find this one the cleanest.  I like how one could replace the\
    \ spaces first and then the dashes.  Also this one avoids having to ", "  text.gsub(\"\
    \ \",\"_\")\n  text.gsub(\" \",\"_\").gsub(/(\\s)\\1+/,'-') # if consecutive spaces\
    \ then replace\nend", "  text.gsub!(/\\s+/, \"_\")\n  text.gsub!(/[[:space:]]{2,}/,\
    \ \"-\")\nend\n</code>\n<|/ a tags=ruby,string dscore=4 |>\n<| a |>\n<code>",
  "  text.gsub!(/\\s+/, \"_\")\n  text.gsub!(/\\s{2,}/, \"-\")\n  text\nend", "  text.gsub!(/\\\
    s+/, \"_\")\n  text.gsub!(/\\s+(?=(.{$|.{2,}})\\s)/, \"-\")\n  return text\nend",
  "  text.gsub(/\\s+/, \" \").gsub(/\\s{2,}/, \"-\")\nend", "  if text == ''\n   \
    \ \n  else\n    text.gsub!(/\\s+/, ' ')\n    text.gsub!(/( {2,})/, '-')\n  end\n\
    end\n</code>\n<|/ a tags=ruby,regex |>\n<| c |>\nNice use of the `gsub` method,\
    \ however this solution would fail for long strings with more than 2 spaces. A\
    \ more robust solution is to use `gsub!` on the replacement.\n<|/ c |>\n<| a tags=ruby,regex\
    \ dscore=1 |>\nYou could use a negative lookbehind to avoid the problematic match:\n\
    <code>\ntext.gsub(/(?<! ){2,}/, '-')\n</code>\n<|/ a |>\n<| a dscore=1 |>\nThis\
    \ doesn't actually answer the question but it may be useful for someone searching\
    \ for this problem in future.\nI needed to replace the space in between a word\
    \ or phrase. This would not work for single space like in this example but it\
    \ works in general to replace the space in between a word or phrase:\n<code>\n\
    sentence = \"Hello Mr. Doe, how are you today\"\nsentence.gsub!(/\\s(?= )/, '\
    \ ')\nputs sentence\n</code>\n<|/ a tags=ruby,regex |>\n<| a |>\n<code>\n  class\
    \ String\n    def replace2spaces \n      gsub(/( {2,})/, '-') \n    end\n  end\
    \ \n</code>\n<|/ a dscore=0 tags=ruby,regex |>\n<| c |>\nPlease edit your answer\
    \ to explain how this answer solves the problem.\n<|/ c |>\n<| c |>\nI like this\
    \ solution, but `gsub` doesn't support a block. You'd have to write a method,\
    \ or just use `gsub!`, which would also work, but is slower. See [this blog post](http://blog.steveklabnik.com/posts/2011-01-05-string-replace-faster-than-regex)\
    \ for the different performance results.\n<|/ c |>\n<| a dscore=0 |>\nTry this\
    \ one\n<code>\nstring = \"hello my name is john smith\"\nstring.gsub(/( {2,})/,\
    \ \"-\")", "  return text.gsub(/  +/, '_')\nend\n</code>\n<|/ a |>\n<| a dscore=3\
    \ tags=ruby,regex,string |>\nHere's how I would do it:\n<code>", "  text.gsub!(/\\\
    s+/, \" \").gsub(/( {2,})/, '-\\1')\nend", "  text.gsub(\" \", \"_\").gsub(/(\\\
    s)+/g, '_').gsub(\"-\", \"_\")\nend", "  text.gsub(/[ ]+/, '_').gsub(/[ ]+/, '_')\n\
    end\n</code>\n<|/ a |>\n<| c |>\nI edited the question a little bit. Would you\
    \ also know how to deal with the multiple spaces? Thanks.\n<|/ c |>\n<| c |>\n\
    : I updated my answer - does that help?\n<|/ c |>\n<| c |>\nThanks! I'll mark\
    \ it as answered. Just a question about the `gsub` calls in the `if` and `else`\
    \ blocks. Why does it have to be two separate `gsub`'s?\n<|/ c |>\n<| c |>\n:\
    \ Because in each case, you have something different than the thing you wanted\
    \ to change it to. So, you're doing two gsubs on different things.\n<|/ c |>\n\
    <| c |>\nOh wait, I think I understand. I was thinking that it would only change\
    \ spaces in between the two `gsub`'s, and not spaces surrounding the whole word\
    \ (like `example` in the first sentence). I guess I was thinking too much. Sorry.\n\
    <|/ c |>\n<| a dscore=2 |>\nI think this would do the trick:\n<code>", "  text.gsub!(/\\\
    s{2,}/, \"_\")\n  if text =~ /([- ])+/\n    text.gsub!(/([- ])+/, \"_$1\")\n \
    \ end\n  return text\nend", "  return text.gsub(/\\s+/, '_') unless text.index(\"\
    \ \") < 2\n  text.gsub(/  +/, '-').gsub(/(?<=\\d)\\s/, \"_\")\nend", "  if text.length\
    \ > 1\n    text = text.gsub(/\\s+/, '_')\n    text.gsub!(/__+/, '-')\n  end\n\
    \  text\nend\n</code>\n<|/ a |>\n<| a tags=ruby dscore=0 |>\n<code>\nrequire 'uri'",
  "  text.gsub!(/ +/, \"_\") # Replace all spaces with underscores\n  text.gsub!(/([^_]{2,2})(\
    \ {2,2})([^_]{2,2})/, \"\\\\1_\\\\2\\\\3\") # Replace consecutive spaces with\
    \ \"-\" if there are more than two spaces\n  return text\nend\n</code>\n<|/ a\
    \ tags=ruby |>\n<| a |>\n<code>", "  text = text.gsub(/ /, '_')\n  text.gsub!(/(\\\
    s)\\1+/, '-\\1')\n  return text\nend", "  text.gsub!(\" \", \"_\") # Replace all\
    \ spaces with underscores\n  text.gsub!(/( {2,})/) { |s| s.gsub!(\" \", \"-\"\
    ) } # Replace 2+ spaces with -\n  text\nend\n</code>\n<|/ a |>\n<| c |>\nI like\
    \ your answer, but I'd like to add that it would be better if you added some explanation\
    \ as to what your code is doing.\n<|/ c |>\n<| c |>\nI added some comments in\
    \ code, hope that helps.\n<|/ c |>\n<| a |>\n<code>", "  text.gsub(\" \", \"_\"\
    )\n    .gsub(/(-){2,}/, \"-\")\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,string\
    \ |>\n<| a tags=ruby,ruby-on-rails,string |>\nFor rails 5\n<code>\n'My string\
    \ to be replaced'.gsub!(/\\s/, '_')\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThanks.\
    \ Works perfectly.\n<|/ c |>\n<| c |>\nThis should be the accepted answer\n<|/\
    \ c |>\n<| c |>\nThis doesn't work for me. gsub! doesn't actually change the string\
    \ itself\n<|/ c |>\n<| c |>\n, try this: `'My string to be replaced'.gsub!(/\\\
    s/, '_')` it should work if you're using rails 5\n<|/ c |>\n<| c |>\n, if you\
    \ need more information: https://stackoverflow.com/questions/5971554/difference-between-gsub-and-gsub!\n\
    <|/ c |>\n<| a dscore=5 |>\nIf all you want to do is replace all spaces with underscores,\
    \ here's another option:\n<code>\nstr.replace(/ /, '_')\n</code>\nIt replaces\
    \ all spaces with an underscore. It works for both Ruby 1.9 and Ruby 1.8.\n<|/\
    \ a tags=ruby,ruby-on-rails,string |>\n<| c |>\nNice! But what if I want to replace\
    \ multiple spaces with just one?\n<|/ c |>\n<| c |>\n`str.replace(/ +/, '_')`\n\
    <|/ c |>\n<| c |>\nThanks. I love these simple solutions but it's nice to have\
    \ something that doesn't require `gsub!`, because I might need to do other stuff\
    \ with that string.\n<|/ c |>\n<| c |>\nI like this simple solution but would\
    \ like to know why this works in ruby 1.8 and not ruby 1.9. I know it works in\
    \ ruby 1.8 but I can't find documentation on it.\n<|/ c |>\n<| c |>\nRuby 1.8\
    \ does not support the shorthand notation for regular expressions. http://stackoverflow.com/questions/701737/whats-the-difference-between-gsub-and-sub\n\
    <|/ c |>\n<| a dscore=5 |>\nIn Rails 5 you can use:\n<code>\nyour_string.gsub(/\\\
    s/, '_')\n</code>\n<|/ a tags=ruby,ruby-on-rails,string |>\n<| a tags=ruby,ruby-on-rails,string\
    \ |>\nIn Rails 3:\n", "  text.gsub!( /[ ]+/, \"_\" )\n  if text.include?(\"  \"\
    )\n    text.gsub!( /[ ]+/, \"-\" )\n  end\n  text\nend\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nIf you have this many methods with such a long name, it might be\
    \ worth extracting the method to another module like suggested: http://stackoverflow.com/questions/2967007/how-can-i-shorten-a-method-name\n\
    <|/ c |>\n<| a dscore=2 tags=methods,ruby,ruby-on-rails,rename |>\nAs I said in\
    \ the comment, I would probably go with something like this:\n<code>\nmodule FixSpaces\n\
    \  module ClassMethods\n    def fix_spaces(*words)\n      words.each do |word|\n\
    \        define_method(word) do |*args|\n          self.send(word, *args)\n  \
    \      end\n      end\n    end\n  end\nend\n</code>\nThen use it this way:\n<code>",
  "  text.gsub!(\" \", \"_\")\n  text.gsub!(/ *\\+/, \"-\")\n  text\nend", "  text.gsub(/[\\\
    t\\s]+/, '_')\n    .gsub(/[\\s\\t]+/, '-')\n    .gsub(/^_/, '')\n    .gsub(/_$/,\
    \ '')\nend\n</code>\n<|/ a tags=ruby,regex,string dscore=1 |>\n<| a |>\nThis doesn't\
    \ use regular expressions nor does it require you to know about word boundaries\
    \ inside words.\n<code>", "  text.gsub!(/[[:space:]]/, '_')\n  text.gsub!(/[ ]{2,}/,\
    \ '_')\n  text.gsub!(/[ ]{2,}/, '-')\n  return text\nend\n</code>\n<|/ a |>\n\
    <| a tags=ruby |>\n<code>\nstr = \"   This   is a test   for   string   manipulation\"\
    \nstr.gsub(/[[:space:]]+/, \"_\")\n  #=> \"_____________this_is_a_test_for_string_manipulation\"\
    \n</code>\nor \n<code>\nstr = \"   This   is a test   for   string   manipulation\"\
    \nstr.gsub(/[\\s]+/, \"_\")\n  #=> \"_____________this_is_a_test_for_string_manipulation\"\
    \n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby |>\n<code>", "  text.gsub!(\" \"\
    ,\"_\")\n  text.gsub!(/ *\\K /, \"_\")\n  text.gsub!(/ *\\K /, \"_\")\n  text\n\
    end\n</code>\n<|/ a |>\n<| c |>\n+1 for `gsub`, although I might use `gsub(/\\\
    s+/, \"_\", text)` instead of `gsub!(/\\s+/, \"_\")` since it seems like `gsub!`\
    \ might perform better here.\n<|/ c |>\n<| c |>\nAgreed. `gsub` is likely faster\
    \ in this case.\n<|/ c |>\n<| a |>\n<code>", "  text.gsub!(' ','_')  if text.size\
    \ > 2\n  text.gsub!(' ','-')  if text.size > 1\nend\n</code>\n<|/ a tags=ruby\
    \ dscore=4 |>\n<| c |>\nYou don't need `gsub!` because `gsub` returns `nil`. Also,\
    \ `gsub` modifies `text` in-place and returns the modified string, it doesn't\
    \ return the changed string so you don't need `return text`. Also, your second\
    \ `gsub!` doesn't need to call `gsub`, since it returns `nil`. You don't need\
    \ to return the result of `gsub!` either, because `gsub` returns `nil` by default.\n\
    <|/ c |>\n<| c |>\n: You're right. I was thinking of `String#replace`, which has\
    \ similar behavior as `String#gsub`.\n<|/ c |>\n<| a tags=ruby dscore=4 |>\nI\
    \ liked this version more: \n<code>", "  text.gsub!(/(^| )( )([^ ]|$)/ ) { $1\
    \ + '_' + $3 }\n  text.gsub!(/( )+/ ) { |m| m.size.to_s == '1' ? '_' : '-' }\n\
    \  text\nend\n</code>\n<|/ a |>\n<| a |>\nI realize this has been answered, but\
    \ I'd like to expand on the solution a bit and explain what it does.\n<code>",
  "  return text.gsub(/\\s+/, \"_\") if text =~ /_+/ && text !~ /_+_/ && text !~ /_+/\
    \ ? \"_\" + text : text\nend\n</code>\nThe above is also inspired by Ruby's pluralize\
    \ method, but I couldn't find a Ruby method to do the same.\n<|/ a dscore=4 tags=ruby,internationalization\
    \ |>\n<| c |>\nIf you want your method to do any kind of formatting, then you're\
    \ going to want to use `String#lstrip` and `String#rstrip`. For example, if \"\
    Example\" is passed in, the result will be \"Example\". If \"Example \" is passed\
    \ in, the result will be \"Example_\".\n<|/ c |>\n<| a dscore=4 |>\nHere's how\
    \ I'd do it:\n<code>", "  text.gsub!(/\\s+/, \" \").gsub(/(\\s){2,}/, \"-\")\n\
    end\n</code>\n<|/ a |>\n<| a |>\nI like my answer, but it could use some improvements.\n\
    <code>", "  text.gsub!(/\\s+/, ' ') \n  text.gsub!(/( ){2,}/, '-')\n  text\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\n`text.gsub(/\\s+/, ' ').gsub(/( ){2,}/,\
    \ '-')` this doesn't work\n<|/ c |>\n<| c |>\n`text.gsub(/\\s+/, ' ').gsub(/(?<=\\\
    s)\\s/, '-').gsub(/( ){2,}/, '-')`\n<|/ c |>\n<| c |>\nThe second `.gsub(/(?<=\\\
    s)\\s/, '-')` won't work, since `(?<=\\s)` only matches if the preceding character\
    \ (in this case `\\s`) is a whitespace. But the first `.gsub(/\\s+/, ' ')` will\
    \ replace all whitespace with `_`s. So `'Example 1'` will be transformed to `'Example_'`\n\
    <|/ c |>\n<| c |>\nYes, you are right. I forgot about it.\n<|/ c |>\n<| a dscore=2\
    \ |>\nI believe I may be overthinking this one and have come up with a solution\
    \ that is more readable but which does the same thing. \n<code>\n def fix_spaces(text)\n\
    \    text.gsub(/\\s+/, ' ').gsub(/(?:\\s)(\\s)/, '-').gsub(/(?:\\s)(\\s)/, ' ')\n\
    \ end\n</code>\nThe (?:\\s) is to match any character that's not a whitespace.\
    \ The second gsub is to replace the second whitespace with a single space which\
    \ may or may not be a desired result.\n<|/ a tags=ruby |>\n<| c |>\nYeah, that's\
    \ what I'm thinking too. Perhaps I was thinking of it wrong.\n<|/ c |>\n<| c |>\n\
    Actually you can simplify it a bit more: `text.gsub(/\\s+/, ' ').gsub(/(?<=\\\
    s)\\s/, '-')`\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  text.gsub(/\\s+/) { |m|\
    \ m.tr('\\s', '_') }\n  text.gsub(/\\s{2,}/) { |m| m.tr('\\s', '_') }\n  text.gsub(/\\\
    s\\+/, '_')\nend", "  text.gsub!(/\\s+/) do\n    $&.split(\" \").map { |word|\
    \ fix_spaces(word) }.join(\"-\")\n  end\nend", "  text.gsub!(/\\s+/,\"_\")\n \
    \ text.gsub!(/([ ]{2,})/,\"_\\\\1\")\n  text.gsub!(/(\\s)+/,\"_\\\\2\")\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\nThis is good, but if I have a string like\
    \ \"Example 3\" I want to get \"_Example-3\" but your solution gives me \"Example3_\"\
    .\n<|/ c |>\n<| a dscore=3 |>\nUsing Regexp you can do it like this: \n<code>",
  "  text.gsub!(/\\s+/,\"_\")\n  text.gsub!(/[ ]{2,}/,\"-\")\nend\n</cell>\n<code\
    \ language=julia-0.6>", "  text.downcase!\n  text.gsub!(/\\s+/, \"_\")\n  if text.scan(/\\\
    s\\s/).length > 2\n    text.gsub!(/( )+/, \" -\")\n  end\n  text\nend", "  return\
    \ text.gsub(/\\s+/, \"_\") if text.size > 2 \n  text.gsub!(/\\s+/, \"-\")\n  return\
    \ text\nend", "  text.gsub!(/\\s+/, \"_\") if text && text.length > 1\n  text.gsub!(/(\\\
    s+)+/, \"_&\")\n  text.gsub!(/^_/, '') if text && text.length > 1\nend", "  text.gsub!(\
    \ /\\s+/, \"_\" )\n  text.gsub!( /\\s+\\z/, \"_\" )\n  text\nend\n</code>\n<|/\
    \ a |>\n<| a tags=ruby,ruby-on-rails-3,ruby-on-rails,string |>\n<code>\n\"Example\
    \ string\".tr(' ', '_')\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis is wrong. `tr`\
    \ can take an Array of characters and replace each character in the string with\
    \ one in the array, so this doesn't work as you expect it to.  `tr!` replaces\
    \ each of the characters in the string, which works the way you want.\n<|/ c |>\n\
    <| c |>\n`tr` also replaces all occurrences of the character with the single character\
    \ given in the array.\n<|/ c |>\n<| a |>\n<code>\n\"Example string\".reverse.gsub(\"\
    \ \",\"_\").reverse\n</code>\n<|/ a dscore=4 tags=ruby,ruby-on-rails-3,ruby-on-rails,string\
    \ |>\n<| c |>\nThis worked for me. The other solutions did not work for me.\n\
    <|/ c |>\n<| c |>\nYeah, this was my solution but had to reverse the string twice\
    \ due to other edge cases it came up with.\n<|/ c |>\n<| a |>\nThis should work\
    \ fine.\n<code>\n\"Example string\".gsub(\" \",\"_\")\n</code>\n<|/ a tags=ruby,ruby-on-rails-3,ruby-on-rails,string\
    \ dscore=3 |>\n<| c |>\nYes it works, it is the simplest solution, but doesn't\
    \ answer the question - which asks about replacing all consecutive spaces with\
    \ a single \"-\".\n<|/ c |>\n<| c |>\nThis is the best answer to me!\n<|/ c |>\n\
    <| a dscore=3 |>\n<code>\n\"Example string\".gsub(/ +/, \"-\")\n</code>\n<|/ a\
    \ tags=ruby,ruby-on-rails-3,ruby-on-rails,string |>\n<| c |>\nThis doesn't work.\
    \ This will replace all spaces with \"_\" but won't replace consecutive spaces\
    \ with a single dash.\n<|/ c |>\n<| a dscore=3 tags=ruby,ruby-on-rails-3,ruby-on-rails,string\
    \ |>\n<code>\n\"Example string\".gsub(/ +/, \"-\")\n</code>\n<|/ a |>\n<| c |>\n\
    This doesn't work. This will replace all spaces with \"_\" but won't replace consecutive\
    \ spaces with a single dash.", "  return text.gsub(/[\\s]+/, '_')\nend", "  return\
    \ text.gsub(\" \", \"_\")\nend\n</code></pre>\n<h3>How to use it?</h3>\n<p>You\
    \ have to include the file to your project.\n<br>\n<code>require \"fix_spaces\"\
    </code> at the top of your file\n<br>\n<code>fix_spaces(\"Example\")</code> to\
    \ replace all spaces\n<br>\n<code>fix_spaces(\"Example 1\")</code> to replace\
    \ all consecutive spaces with <code>_</code>\n<br>\n<code>fix_spaces(\"Example\
    \ 2\")</code> to replace all consecutive spaces with <code>_</code>\n<br>\n<code>fix_spaces(\"\
    Example 3\")</code> to replace all consecutive spaces with <code>_</code>\n<br>\n\
    <code>fix_spaces(\"Example 4\")</code> to replace all consecutive spaces with\
    \ <code>_</code>\n<br>\n<code>fix_spaces(\"Example 5\")</code> to replace all\
    \ consecutive spaces with <code>_</code>\n<br>\n<code>fix_spaces(\"Example 6\"\
    )</code> to replace all consecutive spaces with <code>_</code>\n<br>\n<code>fix_spaces(\"\
    Example 7\")</code> to replace all consecutive spaces with <code>_</code>\n<br>\n\
    <code>fix_spaces(\"Example 8\")</code> to replace all consecutive spaces with\
    \ <code>_</code>\n<br>\n<code>fix_spaces(\"Example 9\")</code> to replace all\
    \ consecutive spaces with <code>_</code>\n<br>\n<code>fix_spaces(\"Example 10\"\
    )</code> to replace all consecutive spaces with <code>_</code>\n<br>\n<code>fix_spaces(\"\
    Example 11\")</code> to replace all consecutive spaces with <code>_</code>\n<br>\n\
    <code>fix_spaces(\"Example 12\")</code> to replace all consecutive spaces with\
    \ <code>_</code>\n<br>\n<code>fix_spaces(\"Example 13\")</code> to replace all\
    \ consecutive spaces with <code>_</code>\n<br>\n<code>fix_spaces(\"Example 14\"\
    )</code> to replace all consecutive spaces with <code>_</code>\n<br>\n<code>fix_spaces(\"\
    Example 15\")</code> to replace all consecutive spaces with <code>_</code>\n<br>\n\
    <code>fix_spaces(\"Example 16\")</code> to replace all consecutive spaces with\
    \ <code>_</code>\n<br>\n<code>fix_spaces(\"Example 17\")</code> to replace all\
    \ consecutive spaces with <code>_</code>\n<br>\n<code>fix_spaces(\"Example 18\"\
    )</code> to replace all consecutive spaces with <code>_</code>\n<br>\n<code>fix_spaces(\"\
    Example 19\")</code> to replace all consecutive spaces with <code>_</code>\n<br>\n\
    <code>fix_spaces(\"Example 20\")</code> to replace all consecutive spaces with\
    \ <code>_</code>\n<br>\n<code>fix_spaces(\"Example 21\")</code> to replace all\
    \ consecutive spaces with <code>_</code>\n<br>\n<code>fix_spaces(\"Example 22\"\
    )</code> to replace all consecutive spaces with <code>_</code>\n<br>", "  if text.blank?\n\
    \    text\n  else\n    # Split text by every single space\n    text = text.split('\
    \ ').collect(&:strip).join('_')", "  return text.gsub(/  /, '_').gsub(/  +/, '-')\n\
    end", "  text.gsub(%r{\\s+}, \"_\")\n         .gsub(%r{(\\s+)\\1+}, \"-\")\nend\n\
    </code>\n<|/ a tags=ruby,string,regex |>\n<| a |>\nI like the answer from Frederick\
    \ Cheung, but I prefer to do this a little differently (assuming you use Ruby\
    \ 1.8+). It's a little clearer to me, and I think it's easier to understand what's\
    \ going on. Also, the code looks much cleaner!\n<code>", "  text.gsub!(\" \",\
    \ \"_\")\n  text.gsub!(\" {2,}\", \"_\") if text.index(\" \")\n  return text\n\
    end\n</code>\n<|/ a dscore=5 tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n<| c\
    \ |>\nI like this. It's easy to understand. The only issue I've had is that it\
    \ modifies the input string if the second call to `gsub!` returns false.  It's\
    \ not hard to work around it, and I'm sure you might have thought of it ;-)\n\
    <|/ c |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\nYou can use the underscore\
    \ gem to convert a word to an underscore.\n<code>\nrequire 'underscore'\nword.to_underscore.gsub(/[\\\
    W_]+/, '-')\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThanks, this is more elegant\
    \ than the accepted answer\n<|/ c |>\n<| c |>\nI agree, this is definitely a lot\
    \ simpler and works well with Rails.\n<|/ c |>\n<| c |>\nNice solution, but what\
    \ if you want to convert a camel case string to an underscore-separated string?\
    \ How would you do that?\n<|/ c |>\n<| c |>\nI think the accepted solution is\
    \ better because it's more general.\n<|/ c |>\n<| c |>\nI believe this could also\
    \ work:", "  text.gsub(/[[:space:]]+/, \"_\").gsub(/[[:space:]]{2,}/, \"-\")\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis does not really answer the question,\
    \ since it deals only with `fixing` spaces, rather than `replacing-spaces`. You\
    \ can't really use that method here\n<|/ c |>\n<| a |>\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
