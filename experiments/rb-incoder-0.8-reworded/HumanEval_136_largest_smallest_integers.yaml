name: HumanEval_136_largest_smallest_integers
language: rb
prompt: "# Create a function that returns an array (a, b), where 'a' is\n# the largest\
  \ of negative integers, and 'b' is the smallest\n# of positive integers in an array.\n\
  # If there is no negative or positive integers, return them as nil.\n# Examples:\n\
  # >>> largest_smallest_integers.call([2, 4, 1, 3, 5, 7])\n# [nil, 1]\n# >>> largest_smallest_integers.call([])\n\
  # [nil, nil]\n# >>> largest_smallest_integers.call([0])\n# [nil, nil]\ndef largest_smallest_integers(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_largest_smallest_integers\n\
  \    candidate = method(:largest_smallest_integers)\n    assert_equal([nil, 1],\
  \ candidate.call([2, 4, 1, 3, 5, 7]))\n    assert_equal([nil, 1], candidate.call([2,\
  \ 4, 1, 3, 5, 7, 0]))\n    assert_equal([-2, 1], candidate.call([1, 3, 2, 4, 5,\
  \ 6, -2]))\n    assert_equal([-7, 2], candidate.call([4, 5, 3, 6, 2, 7, -7]))\n\
  \    assert_equal([-9, 2], candidate.call([7, 3, 8, 4, 9, 2, 5, -9]))\n    assert_equal([nil,\
  \ nil], candidate.call([]))\n    assert_equal([nil, nil], candidate.call([0]))\n\
  \    assert_equal([-1, nil], candidate.call([-1, -3, -5, -6]))\n    assert_equal([-1,\
  \ nil], candidate.call([-1, -3, -5, -6, 0]))\n    assert_equal([-3, 1], candidate.call([-6,\
  \ -4, -4, -3, 1]))\n    assert_equal([-3, 1], candidate.call([-6, -4, -4, -3, -100,\
  \ 1]))\n  end\nend\n"
completions: ["  arr.sort_by { |x| [-x, x] }.last\nend", "  smallest_integer = nil\n\
    \  largest_integer = nil\n  \n  lst.each do |value|\n    if value < 0\n      smallest_integer\
    \ = value\n    else\n      largest_integer = value\n    end\n  end\n  \n  if smallest_integer\
    \ == nil\n    return nil\n  elsif largest_integer == nil\n    return [smallest_integer,\
    \ nil]\n  else\n    return [largest_integer, smallest_integer]\n  end\nend", " \
    \ return [largest_positive_integer(lst), smallest_negative_integer(lst)]\nend",
  "  if lst.empty?\n    [nil, nil]\n  else\n    first = lst.first\n    if first.negative?\n\
    \      largest_smallest_integers.call(lst.drop(1))\n    elsif first.positive?\n\
    \      largest_smallest_integers.call(lst)\n    else\n      [first, nil]\n   \
    \ end\n  end\nend", "  if lst.empty?\n    [nil, nil]\n  else\n    [lst.max, lst.min]\n\
    \  end\nend", '  return nil if lst.empty?', "  lst.sort.reverse\n  case lst\n\
    \  when [nil]\n    [nil, nil]\n  when [Int]\n    [lst[0], lst[0]] \n  else\n \
    \   a = lst[0]\n    b = lst[0]\n    \n    1.upto(lst.size - 1) do |i|\n      a\
    \ = a if lst[i] < a\n      b = b if lst[i] > b\n    end\n    [a, b]\n  end\nend",
  "  if lst.empty?\n    [nil, nil]\n  else\n    smallest = lst.min\n    largest_index\
    \ = lst.index(smallest)\n    largest_value = lst[largest_index]\n    [largest_index,\
    \ largest_value]\n  end\nend", "    integer = nil\n    positive = nil\n    negative\
    \ = nil\n    array = lst.sort", "  arr = []\n  arr[0] = lst[0]\n  arr.each_index\
    \ { |i| arr[i] = lst.max[i] - lst.min[i] }\n  return arr\nend", "    largest_integer\
    \ = nil\n    smallest_integer = nil\n    return lst.each do |num|\n      if num\
    \ > largest_integer\n        largest_integer = num\n      end\n      if num <\
    \ smallest_integer\n        smallest_integer = num\n      end\n    end\n    if\
    \ !largest_integer.nil? && !smallest_integer.nil?\n      return [largest_integer,\
    \ smallest_integer]\n    else\n      return [nil, nil]\n    end\nend", '  return
    nil if lst.empty?', "  lst.each_with_index do |number, index|\n    next if number.nil?\n\
    \    if number > -number\n      [number, index]\n    elsif number < number\n \
    \     [-lnumber, index+1]\n    else\n      [number, index]\n    end\n  end\nend\n\
    </code>\n<|/ a tags=ruby,ruby-on-rails,arrays,ruby-on-rails-3,ruby-on-rails-3.1\
    \ dscore=1 |>\n<| c |>\n`@numbers` contains negative numbers as well, so this\
    \ won't work.\n<|/ c |>\n<| c |>\n, no, it doesn't. That's how I understood the\
    \ question, though. He gave the examples of `[-4, 1, 3, 5, 7]` which includes\
    \ `-4`, which is why I used `-number` to compare against. Also see [the docs](http://ruby-doc.org/core-2.2.3/Enumerable.html#method-i-each_with_index).\n\
    <|/ c |>\n<| c |>\nI think I understand it now. +1\n<|/ c |>\n<| a dscore=1 |>\n\
    The question is ambiguous, but I assumed that you're trying to get the first array\
    \ that contains the max or min of an array. That is, if I have [-4, 1, 3, 5, 7],\
    \ I would return [1, 5] since 4 is both max and min of [-4, 1, 3, 5, 7]. In that\
    \ case, I think this would do what you want:\n<code>", "  smallest_integer = nil\n\
    \  largest_integer = nil\n  lst.each do |item|\n    if item < smallest_integer\n\
    \      smallest_integer = item\n    elsif item > largest_integer\n      largest_integer\
    \ = item\n    end\n  end\n  return [smallest_integer, largest_integer]\nend",
  "  result = []\n  smallest, largest = nil, -1", "  smaller_count = 0\n  bigger_count\
    \ = 0\n  small_array = nil\n  big_array = nil\n  \n  lst.each_with_index do |element,\
    \ index|\n    if element < 0\n      smaller_count += 1\n    elsif element > 0\n\
    \      bigger_count += 1\n    else\n      small_array = index if index == 0\n\
    \      bigger_count += 1\n      break\n    end\n  end\n  \n  if smaller_count\
    \ > bigger_count\n    small_array = nil\n  end\n  \n  if smaller_count < bigger_count\n\
    \    small_array = nil\n  end\n  \n  return [big_array, small_array]\nend", " \
    \ lst.each_with_index { |e, i| break if e.to_i < 0 }\n  lst.each_with_index {\
    \ |e, i| break if e.to_i < 0 || e.to_i > 9999 }\n  lst.each_with_index { |e, i|\
    \ break if e.to_i > 0 }\n  lst.each_with_index { |e, i| break if e.to_i < 0 ||\
    \ e.to_i > 9999 }\nend", "  return [arr.max,arr.min].compact if arr.any?\n  nil\n\
    end", "  largest_positive_integer = nil\n  largest_negative_integer = nil\n  lst.each_with_index\
    \ do |element, index|\n    if element > largest_positive_integer\n      largest_positive_integer\
    \ = element\n    end\n    if element < largest_negative_integer\n      largest_negative_integer\
    \ = element\n    end\n  end\n  if largest_positive_integer == nil\n    return\
    \ largest_negative_integer, nil\n  else\n    return largest_positive_integer,\
    \ largest_negative_integer\n  end\nend", "  return nil if lst.length == 0\n  max_val\
    \ = lst[0]\n  min_val = lst[0]\n  arr.each do |i|\n    if i > 0\n      max_val\
    \ = i if i > max_val\n    elsif i < 0\n      min_val = -i if i < min_val\n   \
    \ end\n  end\n  [min_val, max_val]\nend", "  if lst.empty?\n    [nil, nil]\n \
    \ else\n    smallest = nil\n    largest = nil\n    largest_integer = nil\n   \
    \ smallest_integer = nil\n    largest_integer_value = nil\n    smallest_integer_value\
    \ = nil", "  largest_negative_inside = nil\n  smallest_positive_inside = nil\n\
    \  positive_integer_count = 0\n  negative_integer_count = 0\n  lst.each do |number|\n\
    \    if number < 0\n      negative_integer_count += 1\n      largest_negative_inside\
    \ = number\n    elsif number > 0\n      positive_integer_count += 1\n      smallest_positive_inside\
    \ = number\n    end\n  end\n  if negative_integer_count > positive_integer_count\n\
    \    largest_negative_inside = nil\n    smallest_positive_inside = nil\n  else\n\
    \    largest_negative_inside = nil\n    smallest_positive_inside = nil\n  end\n\
    \  return [largest_negative_inside, smallest_positive_inside]\nend", "  biggest\
    \ = nil\n  smallest = nil\n  lst.each do |number|\n    if number > biggest\n \
    \     biggest = number\n    elsif number < smallest\n      smallest = number\n\
    \    end\n  end\n  return [biggest, smallest]\nend", '  sorted = lst.sort', " \
    \ smallest, largest = lst.minmax\n  if smallest.is_a?(Fixnum)\n    [smallest,\
    \ largest]\n  else\n    smallest = [smallest, nil].max\n    largest = [nil, largest].min\n\
    \    [smallest, largest]\n  end\nend\n</code>\nThis one is a bit more elegant.\
    \  It avoids all the unnecessary checks, and returns the smallest and largest\
    \ values in a single array rather than returning a pair of arrays.\n<code>", " \
    \ int_list = [x for x in lst if x.is_a?(Integer)]\n  return int_list.first if\
    \ int_list.any?\n  nil\nend\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| c |>\nThis\
    \ does not return the largest and smallest number for input like `[6,7,5,4,3,2,1]`\n\
    <|/ c |>\n<| c |>\nI actually tried that in the console and it works as intended.\
    \ I just added an edit to my answer to account for that.\n<|/ c |>\n<| c |>\n\
    The question says *largest and smallest number*. Your function returns *the two\
    \ numbers in a list*. That's what it *does*, and it does so by accident. See my\
    \ answer.\n<|/ c |>\n<| c |>\nYou're right, I misunderstood the question. It was\
    \ a little confusing to me because I didn't see the second line of code in the\
    \ OP's code. I've updated my answer now, hopefully this is closer to what OP is\
    \ looking for.\n<|/ c |>\n<| a dscore=1 |>\nHere's one way to do it using Enumerable#sort_by:\n\
    <code>\nnumbers = [10, 15, -3, -2, 5, -6, -15, 2, 12, -23, -5, -4, 1]", "  largest_integer\
    \ = nil\n  smallest_integer = nil\n  lst.each do |item|\n    if item.to_i < 0\n\
    \      largest_integer = nil\n    elsif item.to_i == 0\n      largest_integer\
    \ = nil\n    elsif item.to_i > smallest_integer\n      largest_integer = item\n\
    \    elsif item.to_i < smallest_integer\n      smallest_integer = item\n    end\n\
    \  end\n  return [largest_integer, smallest_integer]\nend", "  if lst.size <=\
    \ 1\n    [nil, nil]\n  else\n    [\n      biggest_negative_integer(lst, :first),\n\
    \      smallest_positive_integer(lst, :last)\n    ]\n  end\nend", "  integers.each\
    \ do |int|\n    (integers[int[0]], integers[int[1]])\n  end\n  nil\nend\n</code>\n\
    <|/ a tags=ruby,arrays,algorithm,ruby-on-rails |>\n<| c |>\nThe array `integers`\
    \ has been initialized.\n<|/ c |>\n<| a tags=ruby,arrays,algorithm,ruby-on-rails\
    \ |>\nThis problem is much easier if you use Array#sort.\n<code>\nnumbers = [7,-1,2,4,0,-3,5]",
  "  lst.each do |x|\n    if x >= 0 && x <= lst.max_by { |x| x }\n      return [x,\
    \ lst.min_by { |x| x }]\n    end\n  end\n  nil\nend", "  arr.each do |i|\n   \
    \ if i < 0\n      smallest = nil\n      smallest_pos = i\n    elsif i > 0\n  \
    \    smallest = i\n      smallest_pos = nil\n    end\n  end\n  return [smallest,\
    \ smallest_pos] if smallest_pos && smallest_pos.nil?\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=0 |>\n<code>", "  largest_int = nil\n  smallest_int = nil",
  "  smallest = nil\n  largest = nil\n  \n  lst.each do |item|\n    if smallest.nil?\
    \ || smallest.to_i > item.to_i\n      smallest = item\n    end\n    if largest.nil?\
    \ || largest.to_i < item.to_i\n      largest = item\n    end\n  end\n  \n  [smallest,\
    \ largest]\nend", "  lst.each do |i|\n    if i < 0\n      nil\n    elsif i ==\
    \ 0\n      nil\n    elsif i > 0 && i < lst.last\n      i\n    elsif i > lst.last\n\
    \      lst.last\n    end\n  end\nend", "  lst.sort!\n  \n  if lst.empty?\n   \
    \ [nil, nil]\n  else\n    last = lst.pop\n    \n    [ last, lst.pop ]\n  end\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI got it to work using the code you\
    \ provided, but I'm not sure why your code works but not mine. Could you explain\
    \ how the code works? Am I using the pop method correctly?\n<|/ c |>\n<| c |>\n\
    You don't need to use recursion for this. I agree with the others that you are\
    \ overcomplicating your solution. Just use simple sorting.\n<|/ c |>\n<| c |>\n\
    You don't need to use recursion for this solution.  It could be solved with a\
    \ single `each` call.  But the point of recursion is that you can solve any problem\
    \ recursively, not just this one.\n<|/ c |>\n<| c |>\n, that doesn't make much\
    \ sense. The point of recursion isn't to solve any problem recursively; rather,\
    \ it's to solve any problem iteratively. One would never write a recursive solution\
    \ iteratively, and one would never write a iterative solution recursively, for\
    \ that matter. Recursion itself can be implemented either iteratively or recursively,\
    \ but it's not an either-or, it's a solution that can be used either way.\n<|/\
    \ c |>\n<| c |>\n, I agree, but I do think that this is overcomplicating it. It's\
    \ not that simple. As I mentioned in my comment to Chris Heald, I do think my\
    \ solution is overcomplicating the problem. That said, I think your solution is\
    \ far better than what I was trying to do. As I said to Chris, I'm new to Ruby\
    \ so I'm not entirely sure how to use the sort method.\n<|/ c |>\n<| a tags=ruby\
    \ dscore=2 |>\nMy solution is similar to Martin's. I thought it might make sense\
    \ to post anyway, since my solution doesn't use recursion.\n<code>", "  return\
    \ (lst.max {|i| (lst.min {|j| j < i}) == nil } == nil ? [nil, nil] : lst.max {|i|\
    \ (lst.min {|j| j < i}) == nil })\nend", "  min  = nil\n  max  = nil\n  lst.each\
    \ do |num|\n    if num < min\n      min = num\n    elsif num > max\n      max\
    \ = num\n    end\n  end\n  [min, max]\nend", "  return nil unless lst.is_a?(Array)\n\
    \  integers = lst.select { |e| e.is_a?(Fixnum) }\n  return integers unless integers.empty?",
  "  return [largest_integer(lst), smallest_integer(lst)] unless lst.empty?\n  nil\n\
    end\n</code>\n<|/ a |>\n<| c |>\nI didn't think of the possibility of multiple\
    \ numbers.  I suppose you could also change the first method to `return [max(lst),\
    \ min(lst)]`\n<|/ c |>\n<| c |>\nGood idea. Updated. Thanks.\n<|/ c |>\n<| a dscore=0\
    \ |>\nYou can implement it this way:\n<code>", "  return [nil, *lst].sort.last.nil?\
    \ ? [nil, nil] : \nend", "  if lst.empty?\n    [nil, nil]\n  else\n    first,\
    \ second = largest_and_smallest_integer(lst)\n    [first, second]\n  end\nend",
  "  lst.sort { |a,b| a <=> b }\n  lst.max_by { |x| x <=> 0 }\nend", "  return [nil,\
    \ nil] if lst.empty? || lst.size < 2\n  [max(lst.min), min(lst.max)]\nend\n</code>\n\
    <|/ a tags=ruby,max,arrays dscore=2 |>\n<| c |>\nI used your code for my solution\
    \ which I will post in a second.\n<|/ c |>\n<| c |>\nThanks. I updated my answer\
    \ with a few other improvements.\n<|/ c |>\n<| c |>\nThanks, I think my answer\
    \ is more succinct and clean, and I think mine uses less memory.\n<|/ c |>\n<|\
    \ a dscore=2 |>\nI wrote a custom method which I believe is more efficient. I\
    \ used the built-in method minmax() which returns the min and max of a collection.\
    \ But I made it so that it returns nil if the collection is empty. \n<code>",
  "  return nil if lst.empty?\n  min = nil\n  max = nil\n  lst.each do |num|\n   \
    \ if num < min\n      min = num\n    end\n    if num > max\n      max = num\n\
    \    end\n  end\n  [nil, max] if (min == nil && max == nil)\n  [nil, min]\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| a dscore=0 |>\nThe first thing I notice is the\
    \ method definition doesn't match the def in the class. Ruby doesn't like this\
    \ - I suspect it's because you're defining your method as a class method rather\
    \ than an instance method. Try using the class keyword:\n<code>", "  return nil\
    \ if lst.empty?\n  a, b = nil, nil\n  for i in lst\n    a, b = i if i.negative?\
    \ < b.negative? or b.negative? < i.negative?\n  end\n  a, b = i if i.positive?\
    \ > b.positive? or b.positive? > i.positive?\n  [a, b]\nend", "  lst.each_with_index.reduce([])\
    \ do |memo, item|\n    next memo if item < 0\n    memo << item\n    memo\n  end\n\
    end", "  max_number = nil\n  min_number = nil", "  largest_positive_value = nil\n\
    \  largest_negative_value = nil\n  smallest_positive_value = nil\n  smallest_negative_value\
    \ = nil\n  \n  if lst.nil? || lst.empty?\n    largest_positive_value, largest_negative_value\
    \ = nil, nil\n    smallest_positive_value, smallest_negative_value = nil, nil\n\
    \  else\n    largest_positive_value, largest_negative_value = lst[0], lst[0]\n\
    \    smallest_positive_value, smallest_negative_value = lst[0], lst[0]\n    \n\
    \    lst.each do |num|\n      if num < 0\n        largest_negative_value = num\n\
    \      elsif num > 0\n        largest_positive_value =num\n      end\n      \n\
    \      if num < 0\n        smallest_negative_value = num\n      elsif num > 0\n\
    \        smallest_positive_value =num\n      end\n    end\n  end\n  return [largest_positive_value,\
    \ largest_negative_value], [smallest_positive_value, smallest_negative_value]\n\
    end", "  if lst.empty?\n    [nil, nil]\n  else\n    sorted = lst.sort\n    positive\
    \ = sorted.select { |i| i > 0 }\n    negative = sorted.select { |i| i < 0 }\n\
    \    [negative, positive].max\n  end\nend", "  lst.group_by do |x|\n    if x.negative?\n\
    \      x.to_i\n    else\n      x.to_i\n    end\n  end.reduce(:<=>).tap do |a|\n\
    \    a.each { |k, v| a[k] = v == 0 ? nil : v }\n  end\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\n`largest_smallest_integers.call([0]) #=> [nil, nil]` should be\
    \ `largest_smallest_integers.call([0]) #=> [0]`.\n<|/ c |>\n<| a tags=ruby dscore=1\
    \ |>\nFor a more generic solution that can handle any comparator (e.g. <, >, <=,\
    \ >=, !=, ===, !==), you can use Enumerable#group_by:\n<code>", "  # Write your\
    \ Ruby code here\n  lst.reject { |e| e < 0 }\nend", "  max_value = lst.max\n \
    \ min_value = lst.min\n  return max_value == min_value ? nil : [max_value, min_value]\n\
    end", "  # Write your code here.\n  min = nil\n  max = nil\n  arr.each do |i|\n\
    \    if i < 0\n      min = i\n    elsif i > max\n      max = i\n    end\n  end\n\
    \  return [max, min]\nend", "    smallest = nil\n    largest = nil\n    integers\
    \ = []", "  lst.map {|x| x < 0 ? nil : x }.\n  compact.\n  map {|x| x < 0 ? x\
    \ : nil }.\n  max\nend\n</code>\n<|/ a tags=ruby dscore=1 |>\n<| a dscore=1 |>\n\
    <code>", "  return lst.max { |x| lst.find { |y| y >= x } || lst.find { |y| y <\
    \ x } || nil } if lst.any?\nend\n</code>\n<|/ a |>\n<| c |>\nNice one. Just FYI\
    \ the question is tagged with Ruby, but your solution is probably Python.\n<|/\
    \ c |>\n<| c |>\nI assumed the OP tagged the question with ruby, since Ruby is\
    \ one of the languages the OP was interested in. Thanks for pointing out though.\
    \ I'll leave this answer as is in case someone finds it useful.\n<|/ c |>\n<|\
    \ a dscore=2 tags=ruby |>\nI suppose you wish to find the maximum integer among\
    \ positive and negative integers. This is my solution using Math.max method:\n\
    <code>\nmax_integer = (0..100).sort.max_by { |n| [n < 0, -(n+1)].max}\n</code>\n\
    <|/ a |>\n<| c |>\nThat doesn't seem to work. It gives me `NoMethodError: undefined\
    \ method 'max' for nil:NilClass`\n<|/ c |>\n<| c |>\nYes, I tested it and it worked.\
    \ I suppose that you don't have any negative integers. You can replace `0..100`\
    \ by any other range you want to check. `(0..100).to_a` should do the job.\n<|/\
    \ c |>\n<| a tags=ruby |>\nYou can use a ternary operator.\n<code>\n[2,5,8,3,1].reduce{|a,b|\
    \ a < b ? a : b}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nA ternary operator would\
    \ be great but this doesn't work because `[].min => nil` and `[].max => nil`\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>", "  smallest, largest = nil, nil\n  lst.each_index\
    \ do |i|\n    if smallest.nil? || (i < smallest && i < largest)\n      smallest\
    \ = i\n    elsif i > largest && smallest.nil?\n      largest = i\n    end\n  end\n\
    \  [smallest, largest]\nend", "  integers.each do |i|\n    smallest_negative =\
    \ i\n    smallest_positive = i\n    lst.each do |e|\n      if e < 0\n        smallest_negative\
    \ = e\n      elsif e > 0\n        smallest_positive = e\n      end\n    end\n\
    \    if smallest_negative < smallest_positive\n      return [smallest_negative,\
    \ smallest_positive]\n    end\n  end\n  nil\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a dscore=1 |>\nA little different from the other answers (and my original answer).\
    \ I've modified my original answer to return a tuple rather than a list:\n<code>",
  "  big = nil\n  small = nil\n  lst.each do |i|\n    if i < 0\n      big = i\n  \
    \  else\n      small = i\n    end\n  end\n  return [big, small]\nend", "  lst.max_by(&:abs).min_by(&:abs)\
    \ if lst.any?\nend\n</code>\n<|/ a |>\n<| a tags=ruby,arrays,multidimensional-array,loops,find\
    \ dscore=2 |>\nThis question is a bit older, but I wanted to offer an answer using\
    \ Enumerable#min_by:\n<code>\nlst.min_by(&:abs)\n</code>\n<|/ a |>\n<| a tags=ruby,arrays,multidimensional-array,loops,find\
    \ |>\nUsing Enumerable#min\n<code>\nrequire 'pp'", "  if lst.size == 0\n    [nil,\
    \ nil]\n  else\n    first = lst.first\n    last = lst.last\n    smallest_integer\
    \ = nil\n    smallest_number = first\n    largest_integer = nil\n    largest_number\
    \ = first\n    if first > last\n      smallest_number = last\n      largest_integer\
    \ = last\n    else\n      smallest_number = first\n      largest_integer = first\n\
    \    end\n    loop do\n      smallest_integer = nil\n      smallest_number = first\n\
    \      largest_integer = nil\n      largest_number = first\n      if first > last\n\
    \        smallest_number = last\n        largest_integer = last\n      else\n\
    \        smallest_number = first\n        largest_integer = first\n      end\n\
    \      if smallest_number < largest_integer\n        smallest_integer = smallest_number\n\
    \        smallest_number += 1\n      else\n        largest_integer = largest_number\n\
    \        largest_number -= 1\n      end\n      break if smallest_number == last\
    \ or largest_number == first\n    end\n    [smallest_integer, largest_integer]\n\
    \  end\nend", "  largest_negative = nil\n  smallest_positive = nil\n  largest_negative\
    \ == nil ? smallest_positive = large : smallest_positive == nil ? largest_negative\
    \ = small : smallest < negative ? smallest_positive = small : smallest > positive\
    \ ? largest_negative = large : smallest_negative == nil ? largest_negative = small\
    \ : smallest < negative ? largest_negative = large : smallest > positive ? smallest_positive\
    \ = small : nil\nend\n</code>\n<|/ a tags=ruby,math,algorithm |>\n<| a dscore=2\
    \ tags=ruby,math,algorithm |>\nYou could do the following, using a hash table\
    \ and two enumerators to get the elements and then sort them:\n<code>", "  if\
    \ lst.empty?\n    [nil, nil]\n  else\n    lst.map{|e| [e, -e.abs].max}\n  end\n\
    end", "  largest_integer = nil\n  smallest_integer = nil\n  largest_positive_integer\
    \ = nil\n  smallest_negative_integer = nil", "  return [largest_positive_integer(lst),\
    \ smallest_negative_integer(lst)] if lst.is_a? Array else nil\nend", "  lst.sort.reverse\n\
    \  if lst.empty?\n    return [nil, nil]\n  end\n  [Integer(lst[0]), Integer(lst[-1])].max\n\
    end", '    min = max = nil', "  lst.map { |i| [i.abs, i.abs] }.max\nend", "  smallest\
    \ = nil\n  largest = nil\n  \n  # Remove all nil values\n  lst.delete_if { |e|\
    \ e == nil }\n  \n  # Sort the remaining values\n  lst.sort.each do |x| \n   \
    \ if x.to_i <= 0\n      smallest = x\n    else\n      largest = x\n    end\n \
    \ end\n  \n  [largest, smallest]\nend", "  largest_negative = []\n  smallest_positive\
    \ = []", "  return largest_smallest_integers.__ge?(lst) ? largest_smallest_integers.__ge(lst)\
    \ : smallst_largest_integers.__ge?(lst) ? smallst_largest_integers.__ge(lst) :\
    \ nil\nend", "  smallest_integer = nil\n  largest_integer = nil\n  largest_integer_position\
    \ = nil\n  for i in 0...lst.length\n    smallest_integer = lst[i]\n    if smallest_integer\
    \ > 0 then\n      largest_integer_position = i\n      largest_integer = smallest_integer\n\
    \    elsif smallest_integer < 0 then\n      smallest_integer_position = i\n  \
    \  end\n  end\n  [largest_integer, smallest_integer]\nend", "  largest_number\
    \ = nil\n  smallest_number = nil\n  \n  if lst.empty?\n    return [nil, nil]\n\
    \  else\n    smallest_number = lst[0]\n    \n    largest_number = lst[0]\n   \
    \ \n    lst.each_index do |i|\n      if lst[i] < smallest_number\n        smallest_number\
    \ = lst[i]\n      end\n      if lst[i] > largest_number\n        largest_number\
    \ = lst[i]\n      end\n    end\n    \n    return [largest_number, smallest_number]\n\
    \  end\nend\n    ", "  return [\n    biggest_positive_integer(lst),\n    smallest_negative_integer(lst)\n\
    \  ]\nend", "  lst.sort!\n  [-lst.last, lst.first] if lst\nend", "  return [largest_smallest_integer(lst),\
    \ smallest_integer(lst)] if lst\nend", "  result = [nil, nil]\n  lst.each do |num|\n\
    \    num = num.to_i\n    if num < 0\n      result[0] = nil\n    else\n      result[1]\
    \ = num\n    end\n  end\n  result\nend", "  return ([nil, *largest_smallest_integers_helper(lst)]).flatten.compact\n\
    end", "  positive_integers = lst.select { |x| x >= 0 }\n  negative_integers =\
    \ lst.select { |x| x < 0 }\n  positive_integers.empty? || negative_integers.empty?\
    \ ? nil : [negative_integers.min, positive_integers.max]\nend", "  return nil\
    \ if lst.empty?\n  smallest = lst.min\n  largest = lst.max\n  [smallest, largest]\
    \ if smallest < largest \n  else\n    [largest, smallest]\n  end\nend", "  return\
    \ nil if lst.size == 0\n  a = lst.min\n  b = lst.max\n  [b, a] if a<b || a ==\
    \ nil || b == nil\nend", "  if lst.empty?\n    [nil, nil]\n  else\n    positive,\
    \ negative = [], []\n    lst.each_with_index do |num, i|\n      if num > 0\n \
    \       positive << i\n      elsif num < 0\n        negative << i\n      end\n\
    \    end", "  if lst.empty?\n    nil\n  else\n    smallest_integer = lst.min\n\
    \    largest_integer = lst.max\n    lst.each do |elem|\n      if elem.< smallest_integer\n\
    \        smallest_integer = elem\n      elsif elem.> largest_integer\n       \
    \ largest_integer = elem\n      end\n    end\n    [largest_integer, smallest_integer]\n\
    \  end\nend", "  return lst.max_by(&:abs) || [nil, nil]\nend", "  smallest = []\n\
    \  largest = []\n  arr.each do |x|\n    if x.is_a? Integer\n      smallest.push(x)\n\
    \    else\n      largest.push(x)\n    end\n  end", "  return [nil, *lst.group_by(&:abs).max_by(&:abs).values.flatten]\n\
    end", '  lst.sort!', '  return nil if lst.length <= 0', "  if lst.empty?\n   \
    \ [nil, nil]\n  else\n    first = lst.first\n    second = lst.drop(1).reduce(:<)\n\
    \    if first == second\n      [first, second]\n    elsif first > second\n   \
    \   [first, second]\n    else\n      largest_smallest_integers(second)\n    end\n\
    \  end\nend\n</code>\n<|/ a |>\n<| c |>\nThank you for that explanation! It's\
    \ helpful. I would have accepted this answer, but I have decided to go with my\
    \ own solution. Yours is very similar to the one I used and it took the most time.\
    \ Cheers!\n<|/ c |>\n<| a dscore=1 tags=ruby,algorithm |>\nI went for a solution\
    \ that uses recursion. \n<code>", "  largest_value = nil\n  smallest_value = nil\n\
    \  largest_value.nil? or smallest_value.nil?\n  if lst.empty?\n    [nil, nil]\n\
    \  else\n    lst.each_with_index do |number, index|\n      number.nil? or index\
    \ < 0\n      largest_value = number if number > largest_value\n      smallest_value\
    \ = number if number < smallest_value\n    end\n    [largest_value, smallest_value]\n\
    \  end\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>", "  return\
    \ [max(lst), min(lst)] if lst.is_a? Array && lst.size <= 2 else nil\nend", " \
    \ return [\n    largest_integer(lst),\n    smallest_integer(lst)\n  ] if lst.is_a?(Array)\
    \ else\n  [\n    largest_integer(lst.map(&:to_i)),\n    smallest_integer(lst.map(&:to_i))\n\
    \  ]\nend", "  lst.sort_by(&:abs).last.nil? ? [nil, nil] : lst.sort_by(&:abs).last\n\
    end", "  largest_positive = largest_negative = nil\n  \n  lst.each do |x|\n  \
    \  if x.is_a? Integer\n      if x > 0 && x < 100\n        largest_positive = x\n\
    \      elsif x > -1\n        largest_negative = x\n      end\n    elsif x.is_a?\
    \ Float\n      if x > 0 && x < 100\n        largest_positive = x\n      elsif\
    \ x > -1\n        largest_negative = x\n      end\n    end\n  end\n  \n  [largest_positive,\
    \ largest_negative]\nend", "  if lst.empty?\n    [nil, nil]\n  else\n    arr =\
    \ [lst.min]\n    arr << lst.min.downto(lst.min.succ).\n           inject(:<<).max\n\
    \  end\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI love the `inject` method\
    \ - I didn't know it existed.  Thanks.\n<|/ c |>\n<| c |>\nThanks. I love it.\
    \  It makes the code more concise and readable.\n<|/ c |>\n<| c |>\nThe `inject`\
    \ method is a neat little thing and I love it more than it is. I guess it comes\
    \ down to the style of the code you are looking for. There are a number of ways\
    \ to write it. I found my answer more readable to me but that's just me.\n<|/\
    \ c |>\n<| c |>\nAgreed. It's good to have more ways to write the code. I'm just\
    \ trying to get my head around Ruby better, and your solution is pretty cool.\
    \ I think I can learn a lot from it.\n<|/ c |>\n<| c |>\nThe downside of the `inject`\
    \ method is that it is only available from Ruby 1.8.7\n<|/ c |>\n<| a |>\nHere's\
    \ another way to do it, but it's a little messier than the one I posted earlier.\
    \  I realized that I could easily modify this to handle negatives, positives,\
    \ zeros, etc.\n<code>", "  result = nil\n  lst.each do |i|\n    if i.negative?\n\
    \      result = i\n      break\n    end\n  end", "  return nil if lst.empty?\n\
    \  a = []\n  b = []\n  lst.each do |e|\n    return nil if e.negative?\n    a <<\
    \ e\n  end\n  lst.each do |e|\n    return nil if e.positive?\n    b << e\n  end\n\
    \  a = [a] if a.size == 1\n  b = [b] if b.size == 1\n  [a, b].min_by { |e| e[:negative]\
    \ ? -e[:val] : e[:val] }\nend", "  lst.sort {|a,b| b.to_f <=> a.to_f }\n  [lst[-1],\
    \ lst[0]] if lst.size > 0\nend", "  return [nil, nil] if lst.empty? || lst.size\
    \ < 2\n  first, last = lst.min, lst.max\n  ([first] + largest_smallest_integers(lst.drop(first))).max\
    \ > last ? [first] : largest_smallest_integers(lst.drop(first))\nend", "  min\
    \ = []\n  max = []\n  lst.each do |x|\n    if x > max\n      max << x\n    elsif\
    \ x < min\n      min << x\n    elsif x == max\n      max << x\n    elsif x ==\
    \ min\n      min << x\n    end\n  end\n  [min, max]\nend", "  smallest, largest\
    \ = 0, 0\n  arr.each { |e| smallest = e if e < smallest && e != nil ? e : smallest\
    \ }\n  arr.each { |e| largest = e if e > largest && e != nil ? e : largest }\n\
    \  [largest, smallest]\nend", "  if lst.nil?\n    [nil, nil]\n  else\n    positive,\
    \ negative = [], []\n    lst.each do |item|\n      negative << item if item <\
    \ 0\n      positive << item if item > 0\n    end\n    [negative.max, positive.min]\n\
    \  end\nend", "  lst.sort!\n  smallest = nil\n  largest = nil\n  \n  lst.each\
    \ do |num|\n    if num < 0\n      return [smallest, num]\n    end\n    return\
    \ num if num >= 0\n  end\n  [largest, smallest]\nend\n</code>\nThe biggest difference\
    \ between this and the previous solutions is, I believe, that they do not create\
    \ and destroy an array with each iteration.  The previous methods did this, and\
    \ so they were more memory efficient and thus also more efficient.  As we move\
    \ through the array we only have to store the smallest and largest values we've\
    \ looked at.\nThe only time that I would recommend this method is if you know\
    \ for sure that your array will be positive, as if you ever encounter a negative\
    \ number this method will fail, and you will have to resort to using other methods.\n\
    <|/ a tags=sorting,ruby |>\n<| a dscore=1 |>\n<code>", "  lst.inject do |m, item|\n\
    \    m == nil ? nil : (m > item ? m : item) if m != nil && item != nil\n  end\n\
    end", "  a = []\n  b = []\n  nil = nil\n  for i in lst\n    if i.is_a?(Integer)\n\
    \      if i < 0\n        if !a.include?(i)\n          a << i\n        end\n  \
    \    else\n        if !b.include?(i)\n          b << i\n        end\n      end\n\
    \    else\n      a << nil\n      b << nil\n    end\n  end\n  if a.include?(nil)\n\
    \    a = nil\n  end\n  if b.include?(nil)\n    b = nil\n  end\n  return [a, b]\n\
    end", "  lst.map! { |x| x >= 0 ? x : nil }\n  lst.map! { |x| x <= 0 ? x : nil\
    \ }\n  lst.compact.sort_by!(&:abs)\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ tags=arrays,ruby |>\n<code>", '    largest, smallest = nil, nil', "  if lst.empty?\n\
    \    [nil, nil]\n  else\n    max  = -lst.min\n    min = -lst.max\n    [max, min]\n\
    \  end\nend\n</code>\n<|/ a dscore=1 tags=ruby,arrays |>\n<| c |>\nHe is specifically\
    \ asking for Ruby :)\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  lst.sort.map { |x|\
    \ [x, -x.abs] }\nend", "  lst = lst.dup\n  lst.sort!\n  if lst.empty?\n    nil\n\
    \  else\n    [lst[lst.size - 1], lst[0]].max\n  end\nend", "  lst.each_with_index\
    \ do |el, i|\n    break if el < 0\n    break if el > 0\n    return el if i ==\
    \ lst.size - 1\n  end\n  return nil if lst.size == 0\nend", "  lst.each do |num|\n\
    \    return num if num < 0\n    return num if num > 0\n  end\n  return nil\nend",
  "  lst.each do |element|\n    next if element < 0 || element > 1\n    return [nil,\
    \ element] if element == 0\n    [element, element] if element < 0\n  end\n  [nil,\
    \ nil]\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,arrays |>\nI came up with\
    \ this, which is shorter but slower. \n<code>", "  smallest = nil\n  largest =\
    \ nil\n  lst.each do |x|\n    if x.negative?\n      if smallest == nil\n     \
    \   smallest = x\n      elsif x < smallest\n        smallest = x\n      end\n\
    \    else\n      if largest == nil\n        largest = x\n      elsif x > largest\n\
    \        largest = x\n      end\n    end\n  end\n  return [smallest, largest]\n\
    end\n</code>\n<|/ a |>\n<| c |>\nGood job with the code.  I was going to post\
    \ an answer using `max_by`, but this is much more elegant.\n<|/ c |>\n<| c |>\n\
    The code does not return nil if the array is empty. I assume this is meant to\
    \ return [nil, nil] if the array is empty.\n<|/ c |>\n<| c |>\nYeah, I suppose\
    \ `nil` is the only thing that makes sense in this case.\n<|/ c |>\n<| a |>\n\
    The code you posted works well for two numbers, but it breaks for more than two\
    \ numbers. \nHere is why:\n<code>", "  raise ArgumentError, \"cannot call without\
    \ at least one argument\" if lst.empty?\n  lst.sort_by { |i| i.to_i }\n  a, b\
    \ = nil, nil\n  lst.each do |i|\n    next if i.to_i < 0 || i.to_i > Math.sqrt(i.to_i)\n\
    \    a, b = i, i if i.to_i <= b\n  end\n  a\nend", "  lst.sort.reverse\n  result\
    \ = nil\n  smallest_negative_integer = nil\n  largest = nil\n  lst.each do |element|\n\
    \    return result if smallest_negative_integer == nil\n    return smallest_negative_integer\
    \ if element < smallest_negative_integer\n    if element > largest\n      largest\
    \ = element\n    end\n  end\n  smallest_negative_integer = largest\n  return result\
    \ if smallest_negative_integer == nil\n  [result, smallest_negative_integer]\n\
    end", "  lst.sort!\n  first_integer = lst[0]\n  if first_integer == nil or first_integer\
    \ == 0\n    smallest, largest = nil, nil\n  elsif first_integer < 0\n    smallest,\
    \ largest = first_integer, nil\n  else\n    largest = first_integer\n  end", " \
    \ largest_integer = nil\n  smallest_integer = nil\n  \n  # Check if all numbers\
    \ are negative.\n  all_negative = false\n  lst.each do |x|\n    if x <=> 0\n \
    \     all_negative = true\n    end\n  end\n  \n  if all_negative == false\n  \
    \  largest_integer = largest_integer || 0\n    lst.each do |x|\n      if x <=>\
    \ 0\n        largest_integer = x if x > largest_integer\n      end\n    end\n\
    \  end\n  \n  # Check if all numbers are positive.\n  all_positive = false\n \
    \ lst.each do |x|\n    if x <=> 0\n      all_positive = true\n    end\n  end\n\
    \  \n  if all_positive == false\n    smallest_integer = smallest_integer || 0\n\
    \    lst.each do |x|\n      if x <=> 0\n        smallest_integer = x if x < smallest_integer\n\
    \      end\n    end\n  end\n  \n  return largest_integer, smallest_integer\nend",
  "  lst.sort.each do |i|\n    return nil if i.zero?\n    return i if i > 0 \n   \
    \ return nil if i < 0 \n  end\n  [lst.max, lst.min]\nend", "  if lst.size == 0\n\
    \    [nil, nil]\n  else\n    smallest, largest = lst.minmax\n    if smallest <\
    \ 0\n      [nil, largest]\n    elsif largest < 0\n      [smallest, nil]\n    else\n\
    \      [smallest, largest]\n    end\n  end\nend", "  if lst.empty?\n    [nil,\
    \ nil]\n  elsif lst.all?\n    smallest_negative + smallest_positive\n  else\n\
    \    lst.min_by { |x| x > 0 } + lst.max_by { |x| x < 0 }\n  end\nend\n</code>\n\
    This code uses a combination of Array#empty?, Array#all?, and Enumerable#min_by\
    \ and Enumerable#max_by.\n<|/ a tags=ruby |>\n<| c |>\nThank you for putting a\
    \ lot of effort into your answer. While I up-voted it (because I like the code)\
    \ it doesn't fully answer my question. I'd like to keep the code as concise as\
    \ possible. Thank you for your answer.\n<|/ c |>\n<| c |>\n: I understand. You\
    \ could add that to your question. I'll see if I can come up with a better answer.\
    \ I'm sure some Ruby guru will be along shortly. :-)\n<|/ c |>\n<| c |>\n, my\
    \ updated answer should do what you want. :)\n<|/ c |>\n<| a dscore=0 tags=ruby\
    \ |>\nAnother approach is to use Array#map and Array#sort, e.g.:\n<code>\n> l\
    \ = [4,5,6,-3,-2,0,3]\n=> [4, 5, 6, -3, -2, 0, 1, 3]\n> l.sort { |a,b| a<=>b }.map{|x|\
    \ x.nil? ? nil : x.to_i}\n=> [nil, -3, 0, 1, 2, nil, 5, 6]\n</code>\n<|/ a |>\n\
    <| c |>\nThanks for your answer. Can you please explain what the `<=>` mean? Also,\
    \ it should be noted that this answer uses Rails syntax which is not available\
    \ to me.\n<|/ c |>\n<| c |>\n`<=>` is a shorthand for `a.<=>(b)` which returns\
    \ `-1` if `a` is less than `b`, `0` if they are equal, and `1` if `a` is greater\
    \ than `b`. So, in `sort { |a,b| a<=>b }`, if a is less than b then `a<=>b` will\
    \ be -1 (-1 is less than 0) otherwise it will be 0 (zero). In Ruby `<=>` returns\
    \ an integer representing a sort order. `a.<=>(b)` is then evaluated in sort order\
    \ and `nil` is returned for elements that compare equal. See the documentation\
    \ [here](http://ruby-doc.org/core-2.3.1/Array.html#method-i-3C-3D-3E)\n<|/ c |>\n\
    <| c |>", "  max = -999999999999999999\n  min = 999999999999999999\n  min_index\
    \ = nil\n  max_index = nil\n  lst.each do |item|\n    if item < min\n      min\
    \ = item\n      min_index = item\n    end\n    if item > max\n      max = item\n\
    \      max_index = item\n    end\n  end", "  raise \"Not enough arguments\" if\
    \ lst.nil?\n  smallest, largest = lst.minmax_by { |x| -x }\n  [smallest, largest]\n\
    end", "  \n  # Initialize the maximum negative integer to minus_inf\n  # and minimum\
    \ positive integer to plus_inf\n  max_integer = -Float::INFINITY\n  min_integer\
    \ = Float::INFINITY", "  if lst.empty?\n    [nil, nil]\n  else\n    smallest_integer\
    \ = lst.min\n    largest_integer = lst.max\n    [largest_integer, smallest_integer]\n\
    \  end\nend", "  smallest = nil\n  largest = nil\n  if lst.length == 0\n    [smallest,\
    \ largest] = [nil, nil]\n    return\n  end\n  lst.each_with_index do |value, index|\n\
    \    if value < smallest\n      smallest = value\n    end\n    if value > largest\n\
    \      largest = value\n    end\n  end\n  [smallest, largest]\nend", "  lst.each_with_index\
    \ do |e, i|\n    [e, lst.size - i] if e.negative?\n  end\nend", "  lst.sort.each_with_index\
    \ do |n, index|\n    if n.negative?\n      smallest_negative = index\n    else\n\
    \      smallest_positive = index\n    end\n  end", "  arr = lst.map{|x| x == -1\
    \ ? nil : x}\n  min_int = arr[0]\n  max_int = arr[0]\n  arr.each do |x|\n    if\
    \ x.to_i <= max_int.to_i\n      max_int = x.to_i\n    elsif x.to_i < min_int.to_i\n\
    \      min_int = x.to_i\n    end\n  end\n  [max_int, min_int]\nend", "  lst.each\
    \ do |x|\n    next nil if x.is_a? Numeric\n    a, b = x, nil\n    next a if a\
    \ > b\n    next b if b > a\n    next nil unless a\n    next nil unless b\n   \
    \ a, b = b, a\n    next a if a > b\n    next b if b > a\n    next nil unless a\n\
    \    next nil unless b\n  end\n  nil\nend", "    smallest = nil\n    largest =\
    \ nil", "  return [find_max_negative_integer(lst), find_min_positive_integer(lst)]\
    \ if lst != nil \n  else\n    [nil, nil]\n  end\nend", '  small, large = nil,
    nil', "  arr.each do |i|\n    if i > 0\n      return [0, i]\n    end\n  end\n\
    \  arr.each do |i|\n    if i < 0\n      return [0, i]\n    end\n  end\n  nil\n\
    end\n</code>\n<|/ a dscore=1 tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n<| a\
    \ tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\nTo find the largest and smallest\
    \ numbers in a list you can use the Enumerable min_by and max_by methods. In this\
    \ case you can write\n<code>\n[1,2,3,4,5,6,7,8,9,10].min_by(&:abs).max_by(&:abs)\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\n`[1,2,3,4,5,6,7,8,9,10].min_by(&:abs).max_by(&:abs)`\
    \ is also a solution in one line.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ |>\nFor people who are still looking for a solution in ruby 2.\n<code>", " \
    \ smaller = []\n  larger = []", "  return lst.sort.last if lst.size > 0 && (lst.any?\
    \ || lst.all? {|x| x <= 0})\n  [nil, nil]\nend", "  return lst.sort { |a, b| (a\
    \ < b ? -1 : a > b ? 1 : 0) }.last || [nil, nil]\nend", "  lst.each do |x|\n \
    \   a, b = nil, nil\n    x.to_i.downto(0) do |i|\n      a = i if a.nil? || a >\
    \ i\n      b = i if a == i\n    end\n    yield a, b\n  end\nend", "  smallest_integer\
    \ = nil\n  largest_integer = nil\n  if lst.length > 0\n    smallest_integer =\
    \ lst.min\n    largest_integer = lst.max\n  end\n  return [largest_integer, smallest_integer]\n\
    end", "  result = nil\n  lst.each do |number|\n    if number > result\n      result\
    \ = number\n    elsif number < result\n      result = nil\n    end\n  end\n  return\
    \ [result, result]\nend", "  largest_integer = nil\n  smallest_integer = nil\n\
    \  integer = nil", "  result = [nil, nil]\n  arr.each { |i| result = [i, i] if\
    \ i > result[1].to_i else result = [i,nil] }\n  return result\nend", "  return\
    \ [\n    lst[lst.index(lst.min) || lst.index(lst.max)].nil? ? nil : [\n      lst.index(lst.min)\
    \ || lst.index(lst.max), lst.min, lst.max\n    ]\n  ].compact.sort_by(&:first).map(&:last)\n\
    end", "  lst.sort.each_with_index do |n, i|\n    return nil if i.zero? || n <\
    \ 0\n    return n if n == i.zero? || n >= i\n  end\n  nil\nend", "  arr.group_by\
    \ do |x|\n    x < 0 ? nil : x\n  end.map { |x, y| arr.min(x) }.compact.last\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 tags=ruby,algorithm |>\nI realize\
    \ that this question is quite old... but I have been trying to come up with a\
    \ solution for the same problem and I believe I have found a way. \n<code>", " \
    \ smallest = nil\n  largest = nil", "  return nil if lst.empty?\n  max_ = min_int\
    \ lst\n  max_.upcase if max_ > 0\n  min_ = max_.downcase if max_ > 0\n  [max_,\
    \ min_]\nend", "  smallest_integer = nil\n  largest_integer = nil\n  lst.each\
    \ do |x|\n    if x > 0 && x < smallest_integer\n      smallest_integer = x\n \
    \   end\n    if x <= 0 && x >= largest_integer\n      largest_integer = x\n  \
    \  end\n  end\n  if smallest_integer == nil\n    smallest_integer = nil\n  end\n\
    \  if largest_integer == nil\n    largest_integer = nil\n  end\n  return [smallest_integer,\
    \ largest_integer]\nend", "  if lst.empty?\n    [nil, nil]\n  else\n    smallest\
    \ = lst.min\n    largest = lst.max\n    [smallest, largest]\n  end\nend", "  \
    \  smallest = nil\n    largest = nil\n    integers.each do |i|\n        if i.nil?\
    \ || i < 0\n            smallest = nil\n            largest = nil\n          \
    \  break\n        else\n            if smallest == nil || i.to_i < smallest.to_i\n\
    \                smallest = i\n            end\n            if largest == nil\
    \ || i.to_i > largest.to_i\n                largest = i\n            end\n   \
    \     end\n    end\n    return smallest, largest\nend", "  largest_integer = nil\n\
    \  smallest_integer = nil\n  if lst.length > 0\n    largest_integer = max_element(lst,\
    \ &:abs)\n    smallest_integer = min_element(lst, &:abs)\n  end\n  largest_integer,\
    \ smallest_integer\nend", "  largest_integer = nil\n  smallest_integer = nil\n\
    \  lst.each do |value|\n    if value < 0\n      largest_integer = value\n    elsif\
    \ value > 0 and smallest_integer == nil\n      smallest_integer = value\n    end\n\
    \  end\n  if smallest_integer == nil\n    smallest_integer = nil\n  end\n  return\
    \ [largest_integer, smallest_integer]\nend\n</code>\n<|/ a tags=ruby |>\n<| c\
    \ |>\nI like the solution, but I feel it could be improved. The first solution\
    \ I proposed was \"clever\", but it's an O(n^2) solution. My solution below is\
    \ O(n).\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  if lst.nil?\n    return [nil,\
    \ nil]\n  end\n  min_val = lst.shift\n  max_val = nil\n  lst.each do |element|\n\
    \    if element.negative? && max_val.nil?\n      max_val = element\n    elsif\
    \ element.positive? && min_val.nil?\n      min_val = element\n    end\n  end\n\
    \  return [max_val, min_val] if max_val && min_val\n  nil\nend", "  max = nil\n\
    \  min = nil", "    sorted = lst.sort_by(&:to_i) # Get smallest to largest\n \
    \   sorted = sorted.reverse      # Reverse the sorted array", "  negatives = []\n\
    \  positives = []", "  lst.each_with_index do |e, i|\n    next if (e < 0 && -e\
    \ < 0)\n    return e if (e > 0 && -e > 0)\n  end\n  [nil, 0]\nend", "  if lst.empty?\n\
    \    [nil]\n  else\n    largest_positive_value = largest_integer(lst.select(&:positive?))\n\
    \    smallest_negative_value = smallest_integer(lst.select(&:negative?))\n   \
    \ [largest_positive_value, smallest_negative_value]\n  end\nend", "  return [\n\
    \    biggest_num(lst) if lst.min_by(&:abs) != lst \n  ], lst.min_by(&:abs)\nend\n\
    </code>\n<|/ a |>\n<| a dscore=0 |>\nHere's an elegant solution that should work\
    \ for you:\n<code>", "  lst.sort.uniq.each do |num|\n    smallest = num.abs\n\
    \    next if smallest == num\n    largest = smallest\n  end\n  [smallest, largest]\n\
    end", "    smallest_integer = nil\n    largest_integer = nil\n    \n    largest_integer\
    \ = nil if lst.empty?\n    smallest_integer = nil if largest_integer == nil\n\
    \    \n    largest_integer = lst.max { |a, b| b if a < b }\n    smallest_integer\
    \ = lst.min { |a, b| b if a > b }\n    \n    return [smallest_integer, largest_integer]\n\
    end", "  return [biggest_integer(lst), smallest_integer(lst)]\nend", "  lst.sort\
    \ do |x, y|\n    if x < 0\n      x\n    elsif y < 0\n      y\n    elsif x == 0\n\
    \      y\n    else\n      x\n    end\n  end\nend", "  lst.sort_by(&:abs)\n  return\
    \ nil if lst.empty?\n  lst.each_with_index { |x, idx| return idx if x < 0 }\n\
    end\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\n`lst.sort_by(&:abs)` is better\
    \ than `lst.sort { |a, b| a.abs <=> b.abs }` because your version is O(n\xB2),\
    \ while your version has O(n) (and no temporary array).\n<|/ c |>\n<| a dscore=4\
    \ |>\nFor those like me who have never seen Ruby before and want to learn how\
    \ to do things:\nThis code should do the trick:\n<code>", "  return [bigger_than_zero(lst).max,\n\
    \          smaller_than_zero(lst).min] if lst &&\n  lst.map {|x| x.is_a?(Integer)\
    \ ? x : nil}.compact\nend", "  if lst.empty?\n    return [nil, nil]\n  m = lst.max_by(&:abs)\n\
    \  [m, lst.min_by(&:abs)]\nend", "  lst.sort_by { |x| x.to_i }.reverse\n  max_int\
    \ = lst[0]\n  min_int = lst[0]\n  lst.each do |x|\n    next if x.to_i < 0\n  \
    \  max_int = x if max_int < x\n    min_int = x if min_int > x\n  end\n  [max_int,\
    \ min_int]\nend", "  lst.sort.select { |x| x.kind_of?(Integer) }\n  if lst.empty?\
    \ || lst.size == 1\n    lst.first\n  else\n    last = lst.last\n    lst.drop(1).max(-last).min\n\
    \  end\nend", "  largest_integer = nil\n  smallest_integer = nil\n  lst.each do\
    \ |i|\n    unless i.zero?\n      if i.is_a?(Integer)\n        if largest_integer.nil?\n\
    \          largest_integer = i\n        elsif smallest_integer.nil?\n        \
    \  smallest_integer = i\n        elsif i <  largest_integer\n          largest_integer\
    \ = i\n        elsif i >  smallest_integer\n          smallest_integer = i\n \
    \       end\n      end\n    end\n  end\n  [largest_integer, smallest_integer]\n\
    end", "  largest_integer = nil\n  smallest_integer = nil\n  integers.each do |integer|\n\
    \    if integer > largest_integer\n      largest_integer = integer\n    elsif\
    \ integer < smallest_integer\n      smallest_integer = integer\n    else\n   \
    \   break\n    end\n  end\n  [largest_integer, smallest_integer]\nend", "  return\
    \ [nil, lst.min] if lst.min(-i..lst.max) == nil else\n    [lst.max(-i..lst.min),\
    \ lst.min(-i..lst.max)]\nend", "  a = []\n  a.concat((lst.find { |x| x < 0 } ||\
    \ nil),\n           lst.find { |x| x >= 0 } || nil)\nend\n</code>\n<|/ a tags=arrays,ruby,conditional,ruby-on-rails\
    \ dscore=3 |>\n<| a tags=arrays,ruby,conditional,ruby-on-rails |>\nHow about this:\n\
    <code>", '  return nil if lst.empty?', "  lst.sort.map { |x| ((x.abs<0) ? nil\
    \ : x) }\nend", "  if lst.empty?\n    []\n  elsif lst.one?\n    [nil]\n  elsif\
    \ lst.last < 0\n    largest_smallest_integers(lst.take_while { |x| x < 0 })\n\
    \  else\n    largest_smallest_integers(lst.take_while { |x| x > 0 })\n  end\n\
    end", "  smallest, largest = nil, nil\n  lst.each do |item|\n    next unless item\
    \ >= 0 and not smallest or item < 0 and not largest\n    smallest = item if item\
    \ < smallest\n    largest = item if item > largest\n  end\n  [smallest, largest]\n\
    end", "  lst.sort.reverse_each.map do |e|\n    e == nil || e == 0 ? nil : [e,\
    \ e - 1]\n  end.reduce do |a, b|\n    a || b\n  end\nend", "  lst.each_with_index\
    \ do |integer, index|\n    return nil unless integer && integer <= 0 && integer\
    \ >= 0\n    [integer, (index+1)]\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ is a very interesting solution since it takes advantage of the fact that Ruby\
    \ compares negative integers to 0, to find the largest and smallest integers.\
    \ In addition it takes in an array of integers and outputs an array of arrays,\
    \ each array containing the two elements. Thank you so much!\n<|/ c |>\n<| c |>\n\
    This isn't really a great solution for large lists. (Even for small lists it doesn't\
    \ scale very well.) A more reasonable solution is to sort the list into ascending\
    \ order and then just look at the first and last values.\n<|/ c |>\n<| c |>\n\
    You are right, this is a very basic solution for learning and understanding recursion.\
    \ It will indeed not work for large lists. However, as your comment says, the\
    \ array is supposed to contain only positive integers, therefore, I thought that\
    \ the solution could be a good starting point for finding the two integers within\
    \ the array whose largest and smallest values are within the limits of the array.\n\
    <|/ c |>\n<| c |>\nI think you're right but I'd like to see the answer expanded\
    \ to handle negative numbers. You probably don't have to do anything special to\
    \ handle them, just use your recursive function as is, but add some code after\
    \ `return nil unless integer && integer <= 0 && integer >= 0` that handles negative\
    \ numbers. I'll try to update my answer when I get home.\n<|/ c |>\n<| c |>\n\
    The example that I have put up in the question doesn't work properly because of\
    \ the way it is designed. Please see my comment above; I actually posted a solution\
    \ that does work.\n<|/ c |>\n<| a dscore=3 tags=ruby,arrays,recursion |>\nI would\
    \ go about this by making a recursive function that will find the minimum integer\
    \ in the array and then find the largest integer in that array. \nThen I would\
    \ recursively call the function on the rest of the array. I would return the arrays\
    \ with two values instead of an array of arrays. \nI wouldn't do it using each_with_index\
    \ because it would be O(n^2) instead of O(n).\n<|/ a |>\n<| c |>\nThis is essentially\
    \ what I am doing. I would like to return the two values as an array: [smallest_number,\
    \ largest_number].\n<|/ c |>\n<| a dscore=2 |>\nHere's a slightly different way\
    \ of doing it.\n<code>", "  lst.sort do |a, b|\n    a <=> b\n  end\n  largest_integer\
    \ = nil\n  smallest_integer = nil\n  lst.each do |x|\n    if x > 0\n      smallest_integer\
    \ = x if smallest_integer.nil? || smallest_integer > x\n    else\n      largest_integer\
    \ = x if largest_integer.nil? || largest_integer < x\n    end\n  end\n  [largest_integer,\
    \ smallest_integer]\nend", "  integers.reduce(:<<).reduce(:<<)\nend", "  lst.sort.last(2).first(1)\n\
    end", "  arr = lst.sort\n  [arr[-1,1], arr[0,-1]]\nend", "  return nil if lst.empty?\
    \ or lst.all? {|x| x.nil? }\n  max_int = lst.max\n  min_int = lst.min\n  ([nil,\
    \ max_int], [min_int, nil])\nend", "  lst.sort.reverse.collect do |x|\n    if\
    \ x.odd?\n      x\n    else\n      x.ceil\n    end\n  end\nend", "  lst.inject(nil)\
    \ do |a,x|\n    [ x, x if x > a ]\n  end\nend", "  smallest = nil\n  largest =\
    \ nil\n  lst.each do |i|\n    if i.is_a? Integer\n      if i < 0 then\n      \
    \  largest = i\n      else\n        smallest = i\n      end\n    end\n  end\n\
    \  [largest, smallest]\nend\nputs largest_smallest_integers([2, 4, 1, 3, 5, 7])",
  "  smallest, largest = nil, nil\n  lst.each do |x|\n    if x < largest\n      largest\
    \ = x\n    elsif x > smallest\n      smallest = x\n    end\n  end\n  [smallest,\
    \ largest]\nend", "  lst.each do |x|\n    if x > 0\n      max = x\n    else\n\
    \      min = x\n    end\n  end", "  case lst.size\n  when 0 then nil\n  when 1\
    \ then lst.first\n  else lst.find { |x| x < 0 }.min.nil? ? nil : lst.find { |x|\
    \ x > 0 }.max\n  end\nend\n</code>\nThis can be written shorter, maybe even more\
    \ efficient by using the array minmax method.\n<|/ a tags=arrays,ruby dscore=3\
    \ |>\n<| a |>\nHere is yet another approach:\n<code>", "  lst.each do |x|\n  \
    \  next if x.is_a? Integer", "  smallest, largest = 0, nil\n  lst.each do |num|\n\
    \    break if smallest.nil?\n    largest = num if num > largest\n    smallest\
    \ = num if num < smallest\n  end\n  [smallest, largest]\nend", "  lst.inject([])\
    \ do |a, n|\n    big = a[0]\n    small = a[0]\n    if n < big\n      small = n\n\
    \    elsif n > big\n      big = n\n    end\n    [big, small]\n  end\nend", '    smallest,
    largest = nil, nil', "    largest_integer = nil\n    smallest_integer = nil\n\
    \    integers.each do |int|\n        if int > largest_integer\n            largest_integer\
    \ = int\n        end\n        if int < smallest_integer\n            smallest_integer\
    \ = int\n        end\n    end\n    if largest_integer.nil? || smallest_integer.nil?\n\
    \        largest_smallest_integers.call(nil)\n    else\n        return [largest_integer,\
    \ smallest_integer]\n    end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,arrays\
    \ |>\n<| a tags=ruby,ruby-on-rails,arrays dscore=2 |>\nHere's one way in ruby:\n\
    <code>", "  smallest_integer, largest_integer = nil, nil\n  smaller_array = lst.sort.map\
    \ { |x| x }.reverse\n  smaller_array.each { |x| smallest_integer = x if smallest_integer.nil?\
    \ || smallest_integer > x }\n  smaller_array.each { |x| largest_integer = x if\
    \ largest_integer.nil? || largest_integer < x }\n  smallest_integer, largest_integer\n\
    end", "  # Return the largest and smallest integers in an array.\n  # If the list\
    \ is empty return nils.\n  smallest = -(2**31) # or whatever\n  largest = +((2**31)\
    \ - 1) # or whatever\n  smallest_value = nil\n  largest_value = nil\n  lst.each\
    \ do |value|\n    if value < smallest and !smallest_value.nil?\n      smallest_value\
    \ = value\n    elsif value > largest and !largest_value.nil?\n      largest_value\
    \ = value\n    end\n  end\n  return [smallest_value, largest_value]\nend\n</cell>\n\
    <cell>", "  largest = nil\n  smallest = nil\n  lst.each do |i|\n    if i < 0\n\
    \      largest ||= i\n    else\n      smallest ||= i\n    end\n  end\n  [largest,\
    \ smallest]\nend", "  smallest = nil\n  largest = nil\n  lst.each do |i|\n   \
    \ if i.is_a?(Integer)\n      if smallest.nil? or i < smallest\n        smallest\
    \ = i\n      end\n      if largest.nil? or i > largest\n        largest = i\n\
    \      end\n    end\n  end\n  [smallest, largest]\nend", "  # O(n)\n  lst = lst.sort.to_a",
  "  max_num = nil\n  min_num = nil\n  lst.each do |num|\n    if num > max_num\n \
    \     max_num = num\n    elsif num < min_num\n      min_num = num\n    end\n \
    \ end\n  [max_num, min_num]\nend\n</cell>\n<cell>\nlargest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7])\n</cell>\n<text>\nUsing ranges in Ruby\nWe can make an array\
    \ from 0 to 100, using 'range':"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
