name: HumanEval_24_largest_divisor
language: rb
prompt: "# For a given number n, find the largest number that divides n evenly, smaller\
  \ than n\n# >>> largest_divisor.call(15)\n# 5\ndef largest_divisor(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_largest_divisor\n\
  \    candidate = method(:largest_divisor)\n    assert_equal(1, candidate.call(3))\n\
  \    assert_equal(1, candidate.call(7))\n    assert_equal(5, candidate.call(10))\n\
  \    assert_equal(50, candidate.call(100))\n    assert_equal(7, candidate.call(49))\n\
  \  end\nend\n"
completions: ["  largest_divisor = 0\n  \n  n.downto(0) { |n| break if n % 2 == 0\
    \ }\n  \n  n.upto(0) { |n| break unless n % 2 == 0 && largest_divisor < n }\n\
    \  \n  largest_divisor\nend\n</cell>\n<text>\nWe can see that this method is the\
    \ same as the following one:", "  n.downto(1) { |x| break x if n % x == 0 }\n\
    end", "  return largest_divisor_in(n)\nend", "  largest_divisor = 1\n  for i in\
    \ 1..n\n    if (n % i == 0)\n      break\n    else\n      largest_divisor = i\n\
    \  end\n  return largest_divisor\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1\
    \ |>\nMy ruby implementation using prime numbers and recursion\n<code>", "  largest_divisor_val\
    \ = nil\n  largest_divisor_num = 2\n  while largest_divisor_num < n\n    largest_divisor_val\
    \ = (largest_divisor_num * largest_divisor_num) + n\n    largest_divisor_num +=\
    \ 1\n  end\n  return largest_divisor_val\nend\n</cell>\n<text>\nThe method largest_divisor\
    \ takes a number n and returns the largest number that divides n evenly, smaller\
    \ than n. A number n is called a large divisor if it is a divisor of n.", "  return\
    \ nif n % 2 == 0, Math.sqrt(n), n\nend", "  largest_divisor_cache[n] || largest_divisor_cache[n]\
    \ = n / largest_divisor_cache[n] \nend\n</code>\n<|/ a |>\n<| c |>\nThanks Daniel,\
    \ this is helpful. Does this run in O(n)?\n<|/ c |>\n<| c |>\nYes, and O(n) is\
    \ the best you can do, since the range of the number is always bounded by O(log\
    \ n)\n<|/ c |>\n<| a tags=algorithm,ruby |>\nHere's an O(n) solution in Ruby:\n\
    <code>", "  largest_divisor = divisor(n)\n  loop do\n    largest_divisor += divisor(largest_divisor)\n\
    \  end\nend", "  return largest_divisor_recursive(n)\nend", "  n.to_s.split.map(&:to_i).sort.last\n\
    end", "  largest_divisor_num\n  largest_divisor_num = 0\n  (1..n).each do |i|\n\
    \    if n % i == 0\n      largest_divisor_num = i\n      break\n    end\n  end\n\
    \  return largest_divisor_num\nend", "  smallest_divisor = n.to_i\n  largest_divisor\
    \ = 1\n  until smallest_divisor > largest_divisor\n    largest_divisor = smallest_divisor\
    \ + 1\n    smallest_divisor > largest_divisor ? smallest_divisor -= 1\n  end\n\
    \  largest_divisor\nend\n</cell>\n<cell>", "  i = 2\n  while i <= n\n    break\
    \ if n % i == 0\n    i += 1\n  i\nend\n</cell>\n<code language=conda-env-py35-py>",
  "  largest_divisor_number = nil\n  n.to_i.times do |i|\n    break if i % 2 != 0\n\
    \    largest_divisor_number = i if i % largest_divisor_number == 0\n  end\n  largest_divisor_number\n\
    end", "    divisors = Array.new(divisors_of(n))\n    divisors.max_by { |d| div(n,\
    \ d) }\nend", "  n.divmod(0).max\nend", "    largest_divisor = 1\n    i = 2\n\
    \    while i <= n do\n        if n % i == 0 then\n            largest_divisor\
    \ = i\n        end\n        i = i + 1\n    end\n    largest_divisor\nend\n</cell>\n\
    <cell>", "  largest_divisor = 0\n  for number in (1..n).to_a\n    next unless\
    \ number % 2 == 0\n    largest_divisor = number if largest_divisor.zero? || number\
    \ > largest_divisor\n  end\n  largest_divisor\nend", "  largest_divisor = 0\n\
    \  for i in 0..n\n    if n % i == 0\n      largest_divisor = i\n      break\n\
    \  end\n  largest_divisor\nend\n</code>\nIn ruby you can do the same thing with\
    \ one line (which is actually the most concise) :\n<code>", "  return biggest_divisor_of_number(n)\n\
    end\n</cell>\n<text>\nGreat! Now, let's try it out!", "  largest = divisor(n -\
    \ 1)\n  largest = divisor(largest)\n  largest = divisor(largest)\n  largest =\
    \ divisor(largest)\n  largest = divisor(largest)\n  largest = divisor(largest)\n\
    \  largest = divisor(largest)\n  return largest\nend", "  n.downto(1).inject(1)\
    \ do |sum, divisor|\n    (sum + divisor) % n == 0\n  end\nend", "  return largest_divisor_helper(n)\n\
    end\n</cell>\n<code language=julia-1.4>", "  return largest_divisor(n, 100)\n\
    end", "  largest_divisor = find_largest_divisor n\nend", "  ndiv = 0\n  while\
    \ n > 0 do\n    div = n % ndiv\n    if div > 0 then\n      n = div\n    else\n\
    \      ndiv = ndiv + 1\n    end\n  end\n  ndiv\nend\n</cell>\n<code language=julia-1.5>",
  "  largest_divisor_n = 0\n  largest_divisor_n_square = 0\n  for divisor in divisors(n)\n\
    \    if n % divisor == 0\n      largest_divisor_n = divisor\n      largest_divisor_n_square\
    \ = divisor**2 # Could this be done more efficiently?\n      break\n  return largest_divisor_n\
    \ if largest_divisor_n_square == n and largest_divisor_n > 0 else None\nend\n\
    </cell>\n<text>\nExercise 2: What is this function?\nWrite a function which takes\
    \ a number as an argument and returns the number of digits in that number. That\
    \ number must be a positive integer. Test your function on 10, 100, 1000, 10000,\
    \ 100000, 1000000, 10000000, 100000000 and 1000000000; don't try with floating\
    \ point numbers.", "  n.to_s.split(//).max\nend", "  return Math.sqrt(n).ceil.to_i\n\
    end\n</code>\n<|/ a |>\n<| c |>\nWhy not simply `Math.sqrt(n).ceil.to_i` ?\n<|/\
    \ c |>\n<| c |>\nWhy bother? `ceil` uses `floor + 1.\n<|/ c |>\n<| c |>\n`Math.sqrt(n).ceil.to_i`\
    \ works fine for me. Thanks.\n<|/ c |>\n<| a dscore=1 |>\nThe simplest way to\
    \ find the largest number that divides n evenly, is to find the ceiling of the\
    \ square root of n, and subtract 1 from it:\n<code>", "  return n.divmod( n.to_i\
    \ / 2 ).max\nend", "  return largest_divisor_impl(n)\nend", "    n.downto(1).find{\
    \ |i| n%i==0 && n%i <n }.max\nend", "  if n == 0\n    n = 1\n  else\n    n = n-1\n\
    \  end\n  \n  return n if n % 2 == 0\n  \n  max_divisor = 1\n  \n  while max_divisor\
    \ < n\n    max_divisor *= 2\n  end\n  \n  while max_divisor > n\n    max_divisor\
    \ /= 2\n  end\n  \n  max_divisor\nend", "  if n == 1 then\n    1\n  else \n  \
    \  largest_divisor.call(n - 1) + 1\n  end if\nend ", "  return n.divmod(n).last\n\
    end\n</pre>", "  largest_divisor = 1\n  number_to_check = 1\n  while number_to_check\
    \ <= n\n    if number_to_check % 2 == 0\n      number_to_check /= 2\n    else\n\
    \      number_to_check = (2 * number_to_check) + 1\n    end\n    if number_to_check\
    \ > largest_divisor\n      largest_divisor = number_to_check\n    end\n  end\n\
    \  largest_divisor\nend\n</cell>\n<text>\nNow let's find out the time it takes\
    \ to process 100 numbers:", "  if n == 0 then\n    throw ZeroDivisionError\n \
    \ else\n    if n % 2 == 0 then\n      throw ArgumentError\n      largest_divisor(n\
    \ / 2)\n    else\n      largest_divisor(3 * n - 1)\n    end\n  end\nend\n</cell>\n\
    <code language=julia-1.4>", "  divisors = 1\n  while divisors < n do\n    divisors\
    \ = divisors + 1\n  end\n  return divisors\nend\n</cell>\n<cell>\nlargest_divisor(15)\n\
    </cell>\n<cell>\nlargest_divisor(10)\n</cell>\n<cell>\nlargest_divisor(20)\n</cell>\n\
    <cell>\nlargest_divisor(100)\n</cell>\n<cell>\nlargest_divisor(500)\n</cell>\n\
    <cell>\nlargest_divisor(1000)\n</cell>\n<cell>\nlargest_divisor(3000)\n</cell>\n\
    <cell>\nlargest_divisor(100000)\n</cell>\n<cell>\nlargest_divisor(1000000)\n</cell>\n\
    <cell>\nlargest_divisor(10000000)\n</cell>\n<cell>\nlargest_divisor(100000000)\n\
    </cell>\n<cell>\nlargest_divisor(1000000000)\n</cell>\n<cell>\nlargest_divisor(10000000000)\n\
    </cell>\n<cell>\nlargest_divisor(100000000000)\n</cell>\n<cell>\nlargest_divisor(1000000000000)\n\
    </cell>\n<text>\nQ. Write a recursive function max_factors(n) which accepts a\
    \ positive integer n and returns, as a list of pairs, a list of all possible factors\
    \ of n from 1 to n, along with their count. Factors are considered different when\
    \ they are adjacent in n, and also when they share the same divisors. For example,\
    \ 5 is a factor of 3, but 1 and 3 are factors of 5 and they both share 2 divisors.",
  "  largest_divisor = 0\n  (1...n).each do |i|\n    if n % i == 0\n      largest_divisor\
    \ = i\n      break\n    end\n  end\n  largest_divisor\nend", "    divisors = divisor(n)\n\
    \    return divisors.max { |num| num < n }\nend", "  n -= 1\n  i = 1\n  while\
    \ i < (n-1)\n    i += (n % i)\n    n /= i\n  end\n  return n\nend\n</cell>\n<cell>\n\
    largest_divisor.call(15)\n</cell>\n<text>\nPart 5 - Putting it all together\n\
    Now that you have learned how to write basic functions (i.e. the simplest functions\
    \ can be written without a problem), you are ready to write a function that calculates\
    \ the number of even numbers between two numbers.", "  return @max_by do |e|\n\
    \    (n/e >= n / e) ? e : (n/e)\n  end\nend", "  largest_divisor = 1\n  1.upto(n.to_i/2,\
    \ :step => n/2, :each => :down) do |i|\n    next if i == 0\n    next if n % i\
    \ == 0\n    largest_divisor = i if largest_divisor < i\n  end\n  largest_divisor\n\
    end", "  n.to_s.each_char.each_with_object(1) { |c, n| n += 1 if n % c == 0 }.max\n\
    end", "  largest_divisor_num = -1\n  largest_divisor_num = n if n % 2 == 0\n \
    \ until largest_divisor_num >= n\n  largest_divisor_num = (n / 2)\n  until largest_divisor_num\
    \ == n and largest_divisor_num != 0\n  return largest_divisor_num\nend", "  #\
    \ return largest number divisible by n evenly\n  largest_divisor = 0\n  n.times\
    \ do |i|\n    while n % i == 0\n      largest_divisor = i\n      n /= i\n    end\n\
    \  end\n  n\nend", "  n.to_s % 2 == 0 && n.to_s/2\nend", "  largest_divisor =\
    \ nil\n  n.times do\n    current_divisor = n\n    n.times do\n      current_divisor\
    \ = current_divisor / 2\n    end\n    largest_divisor = current_divisor if current_divisor\
    \ > largest_divisor\n  end\n  largest_divisor\nend\n</code>\nFor a large n it\
    \ might take longer to run than the brute-force method. But at least it's easy\
    \ to understand.\n<|/ a tags=ruby |>\n<| c |>\nIt's a good idea to define `largest_divisor`\
    \ as a constant before the loops to improve efficiency: `largest_divisor = Bignum::ONE`\
    \ (or even better, `Bignum.new(1)`) then `current_divisor / 2`.\n<|/ c |>\n<|\
    \ c |>\nI wouldn't. `Bignum.new(1)` is better than `Bignum::ONE`. `Bignum::ONE`\
    \ will be shared amongst all `Bignum` objects and might be shared across multiple\
    \ threads, so you're sharing it across multiple threads, too.\n<|/ c |>\n<| c\
    \ |>\nIf `largest_divisor` is defined as a constant, the value of `largest_divisor`\
    \ won't change between iterations of the loop.\n<|/ c |>\n<| c |>\n, that's true,\
    \ thanks. I updated the answer.\n<|/ c |>\n<| a dscore=1 |>\nThe way I approached\
    \ this problem was with a recursive method. Since this is such a trivial problem,\
    \ I decided to write a method without having to write a whole lot of code. I chose\
    \ a method name that makes it obvious that it's doing a similar operation repeatedly.\n\
    <code>", "  max_divisor = -1\n  largest_div = nil\n  n.times {\n    div = n /\
    \ 2\n    if div > max_divisor\n      max_divisor = div\n      largest_div = div\n\
    \    end\n  }\n  largest_div\nend\nputs largest_divisor.call(15)", "  return largest_divisor_iterative(n)\n\
    end", "  return n.to_s.reverse.gsub!(/\\d+/){|i| i.to_i}\nend", "  return largest\
    \ {\n    n-i | i > 1 && div(n,i) == n\n  }\nend", "  return n.divmod(n).to_a[0].last\n\
    end\n</cell>\n<code language=julia-1.5>\nlargest_divisor(25)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function, is_palindromic that returns true if the given number\
    \ is a palindromic and false otherwise.", "    n.times do |i|\n      break if\
    \ n % i == 0\n    end\n    i\nend\n</code>\n<|/ a tags=ruby,function,for-loop\
    \ |>\n<| a tags=ruby,function,for-loop |>\nThe first answer to your question was\
    \ already given by John Koenig. As far as the second part of the question goes,\
    \ I'm going to be honest. I think I've been tackling this problem for the better\
    \ part of a day and am still not very good at Ruby. I think this is a very simple\
    \ problem that can benefit from just learning the basics of Ruby, and as such,\
    \ I think this problem would be better suited for a different stack exchange site\
    \ than Stack Overflow. I'm not saying that this problem is as difficult as it\
    \ seemed to me, I'm just saying that I don't think the answer can be provided\
    \ without the help of other people. \nI think the answer is a bit of trial and\
    \ error. As someone who has spent the last year working on this problem I spent\
    \ most of one evening researching it. It looks like the only thing one needs is\
    \ an understanding of the basic syntax of Ruby, which is covered in this excellent\
    \ article. The author provides a few simple examples of how one can use loops\
    \ to solve these kinds of problems. The author then goes on to explain how one\
    \ can solve problems with more complex conditional structures. And I did a quick\
    \ search and found this article which explains other ways one can use Ruby to\
    \ solve these kinds of problems. \nA quick search also turns up this site which\
    \ contains some good resources covering these sorts of problems.\n<|/ a dscore=0\
    \ |>\n<| a |>\n<code>", "    return div_mod?(n, n)[1]\nend", "  largest_divisor\
    \ = 1\n  for i in (1..n)\n    if n % i == 0\n      largest_divisor = i\n    end\n\
    \  end\n  largest_divisor\nend\n</code>\n<|/ a dscore=2 tags=ruby,python |>\n\
    <| c |>\nI do not understand why you are using `#call`, why not just use `largest_divisor(15)`?\n\
    <|/ c |>\n<| c |>\nI like that approach better since it doesn't require an if/else\
    \ construct. Nice.\n<|/ c |>\n<| a tags=ruby,python |>\nHere's a solution in Ruby,\
    \ with a small change to meet the OP's requirements:\n<code>", "  1.upto(n) do\
    \ |divisor|\n    break if divisor*divisor > n\n  end\n  divisor\nend\n</cell>\n\
    <code language=julia-1.5>\nlargest_divisor(123)\n</cell>\n<code language=julia-1.5>\n\
    largest_divisor(54)\n</cell>\n<code language=julia-1.5>\nlargest_divisor(23)\n\
    </cell>\n<code language=julia-1.5>", "  largest_divisor = 1\n  div = 2\n  while\
    \ div <= n\n    if n % div == 0\n      largest_divisor = div\n    div += 1\n \
    \ end\n  largest_divisor\nend\n</cell>\n<code language=julia-0.5>\nlargest_divisor.call(15)\n\
    </cell>\n<text>\nExercise: Use the largest_divisor function to solve the problem\
    \ of finding out the largest number that is a power of 2.\nHint: Remember how\
    \ to find the largest number that is a power of 2 from the Python code for the\
    \ largest number that is a power of 2. Do the same in Julia.", "  n = n.to_i\n\
    \  return n.even? ? 1 : n.downto(1).inject(0, :+).to_i\nend", "  if n % 2 == 0\n\
    \    largest_divisor_for_even = n\n  else\n    largest_divisor_for_odd = n\n \
    \   while n > largest_divisor_for_odd\n      largest_divisor_for_odd += 1\n  \
    \  end\n  end\nend", "  return Divide(n, largest_divisor_number(n))\nend", " \
    \ largest_divisor = largest_divisor_with_factorial(n)\n  if n >= largest_divisor\n\
    \    largest_divisor\n  else\n    largest_divisor_with_factorial(n-1)\n  end\n\
    end", "  divisor(Math.sqrt(n),1).max\nend", "    return largest_divisor_inner(n)\n\
    end", "  1.upto(n) do |i|\n    if n % i == 0\n      break\n    end\n    \n   \
    \ if i % 2 != 0\n      i\n    end\n  end\nend", "  largest_divisor = 0\n  n.times\
    \ do |i|\n    if n % i == 0\n      largest_divisor = i\n      break\n    end\n\
    \  end\n  largest_divisor\nend", "  largest_divisor_counter\n  divisor_counter\
    \ = 0", "  largest_divisor = nil\n  divisor = nil\n  n.times do |i|\n    if n\
    \ % i == 0\n      divisor = i\n      break\n    end\n  end\n  largest_divisor\
    \ = divisor\n  divisor = nil\n  n.times do |i|\n    if i % divisor == 0\n    \
    \  largest_divisor = i\n      break\n    end\n  end\n  largest_divisor\nend\n\
    </cell>\n<cell>", "  n = n.to_i\n  divisor = 1\n  while n % divisor == 0\n   \
    \ divisor += 1\n  divisor\nend\n</cell>\n<code language=julia-1.5>\nlargest_divisor(100)\n\
    </cell>\n<code language=julia-1.5>\nlargest_divisor(50)\n</cell>\n<code language=julia-1.5>\n\
    largest_divisor(150)\n</cell>\n<code language=julia-1.5>\nlargest_divisor(100)\n\
    </cell>\n<code language=julia-1.5>", "  return largest_divisor_with_recursion(n)\n\
    end", "  largest_divisor = 0\n  for i in 1..n\n    divisor = n/i\n    if divisor\
    \ > largest_divisor\n      largest_divisor = divisor\n    end\n  end\n  return\
    \ largest_divisor\nend", "  largest_divisor = nil\n  divisor = 1\n  while divisor\
    \ < n\n    if n % divisor\n      break divisor\n    end\n    divisor += 1\n  end\n\
    \  largest_divisor = divisor\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis isn't\
    \ what the OP asked for.\n<|/ c |>\n<| c |>\nThe original question stated \"I'm\
    \ looking for the largest number that divides n evenly (i.e. n%2==0), smaller\
    \ than n.\" This code finds any number that divides n evenly. Plus, I made it\
    \ work for any number by changing the while condition to while n < divisor\n<|/\
    \ c |>\n<| c |>\nThe code states that the OP wants to find the largest number\
    \ that divides n evenly, not any number that divides n evenly.\n<|/ c |>\n<| a\
    \ dscore=0 |>\nIf you only want to get the largest number that divides n evenly\
    \ and smaller than n you can use the following algorithm:\n<code>\nfunction largest_divisor(n)\n\
    \  largest_divisor = nil\n  divisor = 1\n  while divisor < n\n    if n % divisor\n\
    \      break divisor\n    end\n    divisor += 1\n  end\n  largest_divisor = divisor\n\
    end\n</code>\nThis code will return the largest number that divides n evenly and\
    \ smaller than n. The code above was tested in ruby on rails console.\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| a |>\nMy approach is:", "    div(n.to_s)\nend\n</cell>\n<code language=julia-1.0>",
  "  return n.ceil / n.floor\nend", "  return Math.max(Math.ceil(Math.sqrt(n) / Math.sqrt(2)),\
    \ 1)\nend", "  highest_divisor = divisor(n)\n  while true\n    highest_divisor\
    \ += 1\n    return highest_divisor if n % highest_divisor == 0\n  end\nend", " \
    \ largest_divisor = 0\n  divisor = n\n  while divisor > 1\n    divisor = divisor\
    \ / 2\n    largest_divisor = divisor if divisor > largest_divisor else largest_divisor\n\
    \  end\n  largest_divisor\nend", "  largest_divisor = BigInteger.new(-1)\n  divisor\
    \ = BigInteger.new(-1)\n  divisor.set(BigInteger.new(n))\n  divisor.each_bit do\
    \ |i|\n    while divisor.compared_to(BigInteger.new(n)) < 0\n      divisor.sub(1)\n\
    \    end\n    divisor.divide_by(i)\n    largest_divisor = divisor if divisor.is_a?(BigInteger)\n\
    \  end\n  largest_divisor\nend\n</code>\n<|/ a tags=biginteger,ruby |>\n<| c |>\n\
    I guess I should also mention that I used a recursive method because the problem\
    \ was fairly simple, and this doesn't require a lot of looping. You can actually\
    \ see a little bit more \"Ruby-esq\" by looking at it, but I think it's cleaner\
    \ and easier to follow the logic. I also found that I had to subtract one from\
    \ n to get the correct answer even though n isn't the number I'm looking for...\n\
    <|/ c |>\n<| c |>\nI did have to subtract one from n to get the correct answer,\
    \ because the number has to be smaller than n. I changed n to 10 to verify that\
    \ my method worked correctly. The number I was looking for was 3, so I did n-10+1\
    \ (n-1 is the largest number with only one digit, and n+1 is greater than n).\n\
    <|/ c |>\n<| c |>\nI guess I misunderstood your example. Is n really n-1? Or do\
    \ you want n to divide the n+1 number?\n<|/ c |>\n<| c |>\nSorry, n is actually\
    \ n-1, I edited my question to clarify. Thanks for the help btw!\n<|/ c |>\n<|\
    \ c |>\nI edited my answer again to solve the case where n is less than 1.\n<|/\
    \ c |>\n<| a tags=biginteger,ruby |>\nThe accepted answer is fine, but I think\
    \ it can be optimized. Here is another approach:\n<code>", "  n.times.reduce do\
    \ |max, i|\n    max if i % max != 0\n  end\nend", "    largest_divisor = 0\n \
    \   \n    divisors = divisors_upto(n)\n    \n    largest_divisor = 0\n    \n \
    \   divisors.each do |divisor|\n        if n % divisor == 0\n            largest_divisor\
    \ = divisor\n        end\n    end\n    \n    return largest_divisor\nend", " \
    \ largest_divisor = 1\n  i = 2\n  while i <= n\n    break if n % i == 0\n    largest_divisor\
    \ = i\n    i += 1\n  return largest_divisor\nend", "  largest_divisor = n / 2.0\n\
    \  num_divisors = 0\n  while n % largest_divisor == 0\n    largest_divisor +=\
    \ 1\n    num_divisors += 1\n    \n  return largest_divisor, num_divisors\nend",
  "\tlargest_divisor = nil\n\tn.to_i.downto(1).each do |x|\n\t\tbreak if x.to_i /\
    \ n == n\n\t\tlargest_divisor = x\n\tend\n\tlargest_divisor.to_i\nend", "  return\
    \ n.times.reduce('|'.method(:div)).to_i\nend", "  if n < 2\n    puts \"2 is smallest\
    \ divisor of #{n}\"\n  else\n    large_divisor = 1\n    smallest_divisor = n /\
    \ 2\n    until smallest_divisor == large_divisor\n      large_divisor *= 2\n \
    \     smallest_divisor = large_divisor / 2\n    end\n    puts large_divisor\n\
    \  end\nend\nputs \"The largest number that divides #{n} evenly is #{largest_divisor(n).to_s}.\"\
    \n</code>\nI do not claim to be an expert in Ruby, but this seems to solve the\
    \ problem. Hope it helps.\n<|/ a dscore=1 |>\n<| c |>\nThanks for your answer.\
    \ I was actually trying to solve this using recursion. I just tried your solution\
    \ in RubyMine's console and I got the following error:\n`method_missing': undefined\
    \ method `[]' for nil:NilClass (NoMethodError)\n<|/ c |>\n<| c |>\nThat happens\
    \ because I did not have your method defined. I will add it in a second...\n<|/\
    \ c |>\n<| c |>\nYou might want to try `large_divisor = n / 2` instead of `large_divisor\
    \ = 1` and `smallest_divisor = large_divisor / 2` instead of `smallest_divisor\
    \ = 1`. Also try `large_divisor *= 2` and `large_divisor = large_divisor / 2`.\n\
    <|/ c |>\n<| c |>\nYeah I edited my answer to reflect that change. I think that\
    \ should solve your issue, sorry I forgot to mention that.\n<|/ c |>\n<| a |>\n\
    Here is another solution using recursion. No looping, and no arrays:\n<code>",
  "  largest_divisor = -1\n  n = n.to_i\n  1.upto(n) do |i|\n    if n % i == 0\n \
    \     largest_divisor = i\n      break\n    end\n  end\n  return largest_divisor\n\
    end", "  largest_divisor = 1\n  i = 1\n  while i <= n\n    if n % i == 0\n   \
    \   largest_divisor = i\n      break\n    i += 1\n  end\n  largest_divisor\nend\n\
    </cell>\n<cell>\nlargest_divisor.call(15)\n</cell>\n<cell>", "  n.downto(1).max\n\
    end", "  largest_divisor_count = 0\n  largest_divisor_divisor = 0\n  for i in\
    \ 2..n\n    if n % i == 0\n      largest_divisor_count = largest_divisor_count\
    \ + 1\n      largest_divisor_divisor = i\n    end\n  end\n  return largest_divisor_divisor\n\
    end", "  divisors = []\n  i = 1\n  while i <= n do\n    divisors << i\n    i *=\
    \ 2\n  end\n  divisors.sort.last\nend", "  n.to_s.split('').sort.last\nend", " \
    \ factors = []\n  factors.push(2)\n  factors.push(2)\n  factors.push(2)", "  if\
    \ n <= 0\n    0\n  else\n    (1..n).reduce\n      (|) do |largest|\n        (1..n).reduce\n\
    \          (|) do |smaller|\n            if n % smaller == 0\n              n\
    \ / smaller\n            else\n              largest\n            end\n      \
    \    end\n      end\n  end\nend", "  largest_divisor_num = 1\n  largest_divisor_denom\
    \ = 1\n  largest_divisor_reached = 0", "    n.times.reduce(0) { |n,i| n % i ==\
    \ 0 && n / i > n }\nend", "  largest_divisor = 1\n  while n % 2\n    largest_divisor\
    \ = 2 if largest_divisor == n && n % 4 != 0 else largest_divisor\n    n /= 2\n\
    \  end\n  return n\nend", "  largest_divisor = n / 2.0\n  i = 2\n  while i <=\
    \ n do\n    if n % i == 0 then\n      largest_divisor = i\n    end\n    i += 1\n\
    \  end\n  return largest_divisor\nend\n</cell>\n<code language=julia-1.5>\nlargest_divisor(15)\n\
    </cell>\n<text>\nThe LCM of two integers is a number that divides both n and m,\
    \ but also divides m*n without leaving a remainder. Thus, we can find the LCM\
    \ of two numbers by finding the LCM of the two largest numbers divided by n.",
  "  return largest(divisors(n))\nend", "  largest_divisor = nil\n  n.times do |i|\n\
    \    if n % i == 0\n      largest_divisor = i\n    end\n  end\n  largest_divisor\n\
    end", "  largest_divisor = nil\n  n.times do |i|\n    if n % i == 0\n      largest_divisor\
    \ = i\n      break\n    end\n  end\n  largest_divisor\nend", "  n\n  n.downto(1)\
    \ { |d| return d if d.even? }\nend\n</code>\n<|/ a tags=ruby dscore=3 |>\n<| c\
    \ |>\n`if n % d.even?` -> `if n % d.even? == 0`\n<|/ c |>\n<| c |>\n.FarhanMemon\
    \ yes you're right. Thanks.\n<|/ c |>\n<| a dscore=1 |>\nIn Ruby, you can test\
    \ whether a number is divisible by another number as follows:\n<code>\nif (n %\
    \ d == 0)\n  puts n\nend\n</code>\nIf n % d == 0, then n can be divided by d.\n\
    <|/ a tags=ruby |>\n<| a tags=ruby |>\nFor your first question, all you need to\
    \ do is check if a number is divisible by another number (using modulo). So for\
    \ example you want the program to tell you if a number is divisible by 3:\n<code>\n\
    number = 5\nif number % 3 == 2\n  puts 'yes'\nelse\n  puts 'no'\nend\n</code>\n\
    For the second question, all you need to do is find the largest number divisible\
    \ by another number. So for example you want the program to tell you the largest\
    \ number divisible by 3:\n<code>\nlargest_number = 2\nother_number = 5\nif other_number\
    \ < largest_number\n  largest_number = other_number\nend\nwhile other_number >=\
    \ largest_number\n  largest_number = other_number if other_number % largest_number\
    \ == 0\nend\nputs largest_number\n</code>\n<|/ a dscore=1 |>\n<| a |>\nYou can\
    \ do it like this:\n<code>", "  largest_divisor = 0\n  divisor = 1\n  while divisor\
    \ < n\n    if n % divisor == 0\n      largest_divisor = divisor\n      divisor\
    \ = divisor + 1\n    end\n  end\n  largest_divisor\nend", "  n = (n**0.5).round\n\
    \  smallest_divisor_val = n\n  largest_divisor_val = nil\n  (0..n).each do |i|\n\
    \    if n % i == 0\n      smallest_divisor_val = n\n      largest_divisor_val\
    \ = i\n    end\n  end\n  return largest_divisor_val\nend", "  largest_divisor_count\
    \ = 0\n  for i in 2..n/2\n    largest_divisor_count += i\n    if largest_divisor_count\
    \ > n\n      break\n  largest_divisor_count\nend", "    largest_divisor_result\
    \ = 0\n    (1..n).each do |i|\n        largest_divisor_result = i if i % largest_divisor_result\
    \ == 0\n    end\n    return largest_divisor_result\nend\nputs largest_divisor.call(15)",
  "    n, i = n, 0\n    while i < n\n        i += 1\n        if n % i == 0\n     \
    \       n = n / i\n            i = i + 1\n        end\n    end\n    return n\n\
    end", "  n, r = n.divmod(1)\n  loop do\n    if r == 0 then return n else r = n.divmod(r)\n\
    \  end\nend", "  if n % 2 == 0\n    puts \"n is even\"\n    puts n\n    return\
    \ n\n  puts n\n  m = n\n  while m % 2 == 0\n    m /= 2\n  puts m\n  while m %\
    \ 3 == 0\n    m /= 3\n  puts m\n  while m % 5 == 0\n    m /= 5\n  puts m\n  while\
    \ m % 7 == 0\n    m /= 7\n  puts m\n  while m % 11 == 0\n    m /= 11\n  puts m\n\
    \  while m % 13 == 0\n    m /= 13\n  puts m\n  while m % 17 == 0\n    m /= 17\n\
    \  puts m\n  while m % 19 == 0\n    m /= 19\n  puts m\n  while m % 23 == 0\n \
    \   m /= 23\n  puts m\n  while m % 29 == 0\n    m /= 29\n  puts m\n  while m %\
    \ 37 == 0\n    m /= 37\n  puts m\n  while m % 41 == 0\n    m /= 41\n  puts m\n\
    \  while m % 43 == 0\n    m /= 43\n  puts m\n  while m % 47 == 0\n    m /= 47\n\
    \  puts m\n  while m % 53 == 0\n    m /= 53\n  puts m\n  while m % 59 == 0\n \
    \   m /= 59\n  puts m\n  while m % 67 == 0\n    m /= 67\n  puts m\n  while m %\
    \ 73 == 0\n    m /= 73\n  puts m\n  while m % 79 == 0\n    m /= 79\n  puts m\n\
    \  while m % 83 == 0\n    m /= 83\n  puts m\n  while m % 89 == 0\n    m /= 89\n\
    \  puts m\n  while m % 97 == 0\n    m /= 97\n  puts m\n  while m % 103 == 0\n\
    \    m /= 103\n  puts m\n  while m % 109 == 0\n    m /= 109\n  puts m\n  while\
    \ m % 115 == 0\n    m /= 115\n  puts m\n  while m % 121 == 0\n    m /= 121\n \
    \ puts m\n  while m % 127 == 0\n    m /= 127\n  puts m\n  while m % 133 == 0\n\
    \    m /= 133\n  puts m\n  while m ", "  largest_divisor = nil\n  n.times do\n\
    \    i = 2\n    while i*i <= n do\n      if n % i == 0\n        largest_divisor\
    \ = i\n        break\n      end\n      i += 1\n    end\n  end\n  largest_divisor\n\
    end", "  return n.times.reduce(:**)\nend", "  loop do\n    break unless n.even?\n\
    \    n /= 2\n  end\n  n\nend", "    largest_divisor_ = nil\n    for divisor in\
    \ [3,5,7,11,13,17,19,23,29]\n        if n % divisor == 0\n            if largest_divisor\
    \ == nil\n                largest_divisor_ = divisor\n            elsif largest_divisor\
    \ > divisor\n                largest_divisor_ = divisor\n            end\n   \
    \     end\n    end\n    return largest_divisor_\nend", "  largest_divisor = 1\n\
    \  i = 1\n  while i*i <= n\n    largest_divisor = i\n    i += 1\n  return largest_divisor",
  "    largest_divisor = n\n    divisor = n\n    while n != 0\n        if n % divisor\n\
    \            largest_divisor = divisor\n        divisor = divisor + 1\n    end\n\
    \    return largest_divisor\nend", "  divisor = nil\n  divisor ||= 0\n  divisor\
    \ = 1\n  while n >= divisor\n    divisor += 1\n  end\n  divisor\nend", "  largest_divisor\
    \ = nil\n  n.times do |i|\n    next\n    if n % i == 0 \n      largest_divisor\
    \ = i\n      break\n    end\n  end\n  largest_divisor\nend", "  largest_divisor\
    \ = 1\n  largest_divisor_found = 0\n  divisors = []", "  return max_call do |n|\n\
    \    n.to_i.to_s % n == 0\n  end\nend", "  return largest_divisor_of_a_number(n)\n\
    end", "  return largest_divisor_without_recurrence(n)\nend", "  div_arr = factors_of(n)\n\
    \  max_div = div_arr.max_by { |div| div[1] }[1]\n  return max_div\nend", "   \
    \ largest_divisor = 2\n    largest_divisor_indicies = 0", '  return max_divisor(n)',
  "  largest_divisor = nil\n  # For each of the numbers from 1 to n, check if they\
    \ divide evenly into it\n  1.upto(n) do |num|\n    if num % 2 == 0 && num < largest_divisor\n\
    \      largest_divisor = num\n    end\n  end\n  return largest_divisor\nend",
  "    return largest_divisors(n)[1]\nend", "  n.to_s.split(//).reverse.find { |a|\
    \ a % 2 == 0 }\nend", "\tlargest_divisor = 1\n\ti = 1\n\twhile i <= n do\n\t\t\
    if n % i == 0 then\n\t\t\tlargest_divisor = i\n\t\tend\n\t\ti = i + 1\n\tend\n\
    \treturn largest_divisor\nend", "  return n.divmod(n).last\nend", "  largest_divisor\
    \ = Bignum.new(0);\n  n = Bignum.new(n);\n  max_n = n.abs;\n  n.zero;\n  max_n.times(2);\n\
    \  (1..n-1).each do |x|\n    (x.to_i/2-1).times do |y|\n      if(y.to_i.even?\
    \ == true)\n        max_n.times(2)\n      else\n        largest_divisor = max_n;\n\
    \      end\n    end\n  end\n  return largest_divisor;\nend", "  return n.times.reduce(:&).reduce(:&).reduce(:&).reduce(:&).reduce(:&).reduce(:&).reduce(:&).reduce(:&).reduce(:&)\n\
    end\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nJust to be clear, this\
    \ doesn't return the largest number that divides n. It returns the greatest integer\
    \ less than n that divides n. e.g. if n = 15 this would return 10, but the number\
    \ 10 is also a divisor of 15.\n<|/ c |>\n<| c |>\nyou're right, I didn't realize\
    \ it wasn't the largest number. I just added a recursive method that returns the\
    \ greatest divisor less than n.\n<|/ c |>\n<| c |>\nThanks Patrick, I think I\
    \ got it now.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails |>\nAnother Ruby way to\
    \ do this, though more verbose than I would prefer. \n<code>\nn = 15\nn.to_s.split(//).\n\
    \  select { |c| n%c==0 }.\n  max { |a,b| (a.to_i+1)*(b/a.to_i+1)==b ? a.to_i :\
    \ b }.\n  to_s.\n  to_i\n</code>\n<|/ a dscore=2 |>\n<| c |>\nNice solution. I'll\
    \ be interested to see how it compares with the other solutions.\n<|/ c |>\n<|\
    \ a dscore=2 |>\n<code>", "  largest_divisor = 1\n  largest_divisor_reminder =\
    \ 1", "    largest_divisor = 1\n    for i in 2..n\n        largest_divisor = i\
    \ if n % i == 0\n    end\n    largest_divisor\nend", "  n.divmod(0).max\nend",
  "  largest_divisor = 0\n  largest_divisor = 0\n  for i in (0..n-1)\n    break if\
    \ i % 2 == 0\n    largest_divisor = i if i > largest_divisor else largest_divisor\n\
    \  end\n  largest_divisor\nend", "  if n % 2 == 0\n    return n\n  else\n    return\
    \ largest_divisor(n / 2)\nend", "  n.to_s.split(//).sort.last || n\nend", "  largest_divisor\
    \ = nil\n  n.times do\n    break if n % 2 == 0\n    largest_divisor = n if n >\
    \ largest_divisor\n    n /= 2\n  end\n  largest_divisor\nend", "  # Set up the\
    \ array and set n = 1 to get a good starting point\n  n = 1\n  # The array for\
    \ divisors\n  divisors = []\n  # Iterate over all numbers up to n\n  while n <=\
    \ n\n    # Add the current number to the array\n    divisors << n\n    # Iterate\
    \ over all the numbers in the array and subtract each one from n\n    divisors.each\
    \ { |d| n -= d }\n  end\n  # Return the last element of the array\n  divisors.last\n\
    end\n</code>\nNow for finding all divisors, we could iterate through the entire\
    \ list of divisors we created and test all numbers in that list to see which ones\
    \ divide evenly, but this would take a long time for large numbers and is probably\
    \ not necessary for this problem. This is an improvement, but still far from optimal.\n\
    The only way to improve this is to not store all the divisors in a list but to\
    \ store only the last number that was added. You can do this by using a stack.\
    \ Let's make a stack of integers and then push each new number to it and then\
    \ pop the number out of the stack as it is used. Here's how that would look:\n\
    <code>", "  largest_divisor = n / 0\n  max_divisor = 0\n  n.times do |x|\n   \
    \ if n % x == 0\n      max_divisor = x if x > max_divisor\n    end\n  end\n  max_divisor\n\
    end\n</code>\n<|/ a tags=algorithm,ruby,big-o,ruby-on-rails |>\n<| c |>\nWhile\
    \ this link may answer the question, it is better to include the essential parts\
    \ of the answer here and provide the link for reference.  Link-only answers can\
    \ become invalid if the linked page changes.\n<|/ c |>\n<| c |>\nThanks for the\
    \ pointer, I've edited the post to include the essential parts of the answer from\
    \ the link and provided the link for reference.\n<|/ c |>\n<| c |>\nthanks for\
    \ providing the code snippet and explanation. This makes a lot of sense. ", " \
    \ n1 = 1\n  n2 = n\n  while n2 > 0\n    n1, n2 = n2, n1 % n2\n  end\n  return\
    \ n1\nend\n</cell>\n<code language=julia-1.0>\nlargest_divisor(15)\n</cell>\n\
    <text>\nGreat! Now it's time to define an inversion function (we'll see why we\
    \ usually don't want inversion). The following function will do an inversion of\
    \ a number using recursion:", '  largest_divisor_num = n', "  n.downto(0).each\
    \ {|x|\n    return x if x % n == 0\n  }\n  n\nend\n</cell>\n<cell>\nlargest_divisor.call(15)\n\
    </cell>\n<cell>\nlargest_divisor.call(6)\n</cell>\n<text>\nThe power of Ruby methods\n\
    Ruby has many built-in methods. These are simply methods which Ruby will invoke\
    \ when they encounter a method call in a program, or when they refer to a method\
    \ name. The method calls are represented by blocks, or in Ruby, by the block.\
    \ Blocks are the primary way to organize code in Ruby, and are how Ruby methods\
    \ can refer to other methods. Blocks can be thought of as code blocks in other\
    \ languages. Ruby methods can refer to other methods by using method references,\
    \ just like in other languages. Ruby methods can also refer to blocks using the\
    \ yield keyword, which can be thought of as passing the method a block to execute.",
  "  largest_divisor_n = 0\n  divisor = 1", "  largest_divisor = nil\n  (1..n).each\
    \ do |i|\n    if n % i == 0\n      if largest_divisor\n        largest_divisor\n\
    \      else\n        largest_divisor = i\n      end\n    end\n  end\n  largest_divisor\n\
    end", "  # Write your code here\n  divisors = Array.new\n  divisors.push(0)\n\
    \  for i in 0...n\n  \tdivisors.push divisors.last * 2 if i % 2 == 0\n  end\n\
    \  return divisors.last\nend\nlargest_divisor(15)", "  largest_divisor = 0\n \
    \ while n % 2 == 0\n    largest_divisor = n if largest_divisor == 0 or n % largest_divisor\
    \ != 0\n    n /= 2\n  end\n  largest_divisor\nend", "  largest_divisor = 0\n \
    \ \n  divisors.each do |divisor|\n    if n % divisor == 0\n      if divisor >\
    \ largest_divisor\n        largest_divisor = divisor\n      end\n    end\n  end",
  "  largest_divisor = 1\n  while n % 2 == 0\n    largest_divisor = largest_divisor\
    \ + 1\n    n = n / 2\n  return largest_divisor\nend", "  return max_by { |d| n\
    \ % d == 0 }\nend", "  return Math.sqrt(n).ceil\nend\n</code>\n<|/ a |>\n<| c\
    \ |>\nThis was my first idea, but it's too slow.\n<|/ c |>\n<| c |>\nThanks for\
    \ the help, that's exactly what I ended up with. I just figured out my mistake\
    \ in my code (I used the wrong operator in my loop). I was using / instead of\
    \ /=. I'll update my original question with my corrected version.\n<|/ c |>\n\
    <| a tags=ruby,ruby-on-rails |>\nI assume you were looking for the answer as stated\
    \ but to improve the performance. Below is my solution. It uses memoization to\
    \ save multiple calls to the function which reduces the runtime significantly\n\
    <code>", "    divisor = nil\n    while divisor < n\n        divisor = divisor\
    \ * 2\n    end", "  largest_divisor = 0\n  n = n.to_f\n  while true\n    begin\n\
    \      break if n % 2 == 0\n      n /= 2\n    end until n >= 2\n    largest_divisor\
    \ = n if n % 2 == 0 else n + 1\n  end\n  largest_divisor\nend\n</cell>\n<code\
    \ language=julia-1.0>\nlargest_divisor(15)\n</cell>\n<text>\nNow, let's say that\
    \ you were given the average salary for three candidates, Candidate A, Candidate\
    \ B and Candidate C, and you wanted to figure out the median salary and the number\
    \ of employees who earn the median salary. Of course, for this question we'll\
    \ stick with the average.", "    largest_divisor = Bignum.new(0)\n    return largest_divisor",
  "  largest_divisor_number = nil\n  largest_divisor_number_prime = nil\n  largest_divisor_number\
    \ = 1\n  largest_divisor_number_prime = 1\n  for i in 2..n\n    if n % i == 0\n\
    \      large_divisor_number = i\n      break\n    end\n  end\n  for i in 2..n\n\
    \    if n % i == 0\n      large_divisor_number_prime = i\n      break\n    end\n\
    \  end\n  if largest_divisor_number == nil\n    largest_divisor_number = n\n \
    \ end\n  if largest_divisor_number_prime == nil\n    largest_divisor_number_prime\
    \ = n\n  end\n  if largest_divisor_number_prime < largest_divisor_number\n   \
    \ largest_divisor_number = largest_divisor_number_prime\n  end\n  return largest_divisor_number\n\
    end\n</code>\nHope this helps someone!\n<|/ a tags=ruby,algorithm |>\n<| c |>\n\
    I like it. I am pretty sure you can also optimize this to avoid the loop and return\
    \ when `i==n`, which would give you `largest_divisor_number(n)=n+1`.\n<|/ c |>\n\
    <| a |>\nHere's my version of it, which seems to work for small numbers and up\
    \ to around 2000:\n<code>", '  return largest_divisor_naive(n) if n <= 10 else
    largest_divisor_best(n) end', "    largest_divisor = n.to_f\n    n.times do |i|\n\
    \        break i if (n % i == 0)\n        largest_divisor = i\n    end\n    return\
    \ largest_divisor\nend", "  largest_divisor = 0\n  div = []\n  for i in 1..n\n\
    \    if n%i==0\n      div << i\n      if i > largest_divisor\n        largest_divisor\
    \ = i\n  end\n  largest_divisor\nend\n</code>\n<|/ a |>\n<| c |>\n+1 For mentioning\
    \ memoization. I never thought of that.\n<|/ c |>\n<| c |>\nThe first one didn't\
    \ work for me but the last one did. Thanks!\n<|/ c |>\n<| a tags=arrays,ruby,algorithm\
    \ |>\nThis is probably not what the author was looking for, but here goes:\n<code>",
  "  largest = 1\n  n.downto(1) do |i|\n    return largest if i % i == 0\n    largest\
    \ = i if i > largest\n  end\n  largest\nend", "  largest_divisor = nil\n  # loop\
    \ through all numbers less than n\n  n.times do |i|\n    # check to see if i divides\
    \ n\n    if i % n == 0\n      # set largest divisor to i if i is a divisor\n \
    \     if i.is_a? Fixnum\n        largest_divisor = i if largest_divisor.nil? ||\
    \ largest_divisor > i \n      end\n    end\n  end\n  largest_divisor\nend\n</cell>\n\
    <cell>\nlargest_divisor(15)\n</cell>\n<text>\nNow lets write out a recursive factorial\
    \ function", "  largest_divisor = nil\n  largest_divisor_found = false\n  divisors\
    \ = divisors(n)\n  divisors.each do |divisor|\n    if n % divisor == 0\n     \
    \ largest_divisor = divisor\n      largest_divisor_found = true\n    end\n  end\n\
    \  return largest_divisor if largest_divisor_found\n  return n if n <= 0\n  raise\
    \ ArgumentError, \"#{n} is less than zero\" if n < 0\n  raise ArgumentError, \"\
    #{n} is zero\" if n == 0\n  raise ArgumentError, \"#{n} is greater than the largest\
    \ divisor #{largest_divisor}\" if n > largest_divisor\nend", "  largest_divisor\
    \ = nil\n  n.times do |i|\n    candidate = n / i\n    next unless candidate %\
    \ 2 == 0\n    largest_divisor = candidate if candidate > largest_divisor\n  end\n\
    \  largest_divisor\nend\n</code>\n<|/ a tags=ruby,loops |>\n<| c |>\nOh yeah,\
    \ I actually didn't see the `largest_divisor` part in the requirement. That's\
    \ my mistake. Fixed now.\n<|/ c |>\n<| c |>\nI think you meant `n % i == 0` instead\
    \ of `n / i == 0` when checking if the divisor is even.\n<|/ c |>\n<| c |>\n:\
    \ Indeed I did. Thanks for pointing it out. I'll fix it right away.\n<|/ c |>\n\
    <| c |>\nI think this is the most efficient solution for big numbers because it's\
    \ iterating once over the numbers, rather than N times (where N = numbers.length).\n\
    <|/ c |>\n<| a |>\n<code>", "  divs = n.to_s.split(//).map(&:to_i)\n  divs.each\
    \ do |div|\n    return div if div % 2 == 0\n  end\n  nil\nend", "  n.downto(0).inject(:+).max\
    \ / 2\nend\n</code>\nIt's not as fast as the Ruby solution as it requires more\
    \ looping, but it's still fast enough for most uses.\n<|/ a tags=ruby,algorithm\
    \ |>\n<| c |>\nThis is a very elegant solution, however I do not believe it is\
    \ correct. I ran the following test:", "  return large_divisor(n).call(n).to_i\n\
    end", "  result = 0\n  factors = 1\n  while n > 1\n    if n % 2 == 0\n      factors\
    \ += 1\n    n /= 2\n  result = n\n  while result > 0\n    if result % 2 == 0\n\
    \      factors += 1\n    result /= 2\n  while factors > 0\n    factors -= 1\n\
    \    result /= 2\n  return result\nend\n</cell>\n<text>\nThe question was to write\
    \ a function that returns the number of digits of the largest number that divides\
    \ n evenly, smaller than n. One way to do that is to find all factors of the number,\
    \ then find the number of digits of the largest factor.", "  return n if n % 2\
    \ == 0 && (n % 4 == 0 || n % 6 == 0)\n  return largest_divisor(n / 2) + 1\nend",
  "  return n.times.reduce(:&) do |max_divisor, i|\n    if n % i == 0\n      max_divisor\
    \ = i\n    end\n    max_divisor\n  end\nend", "    factors = []\n    i = 2\n \
    \   while i <= n\n        factors += Array.new\n        if n % i == 0\n      \
    \      i += 1\n        end\n    end\n    factors.sort!", "  n.to_f.max.reduce(:/\
    \ ) * 2 if n != 1\nend", "  n.downto(0).select do |i|\n    i.even?\n  end[0]\n\
    end", "  largest_divisor_so_far = n\n  divisors = []\n  for i in [1..n]\n    if\
    \ n % i == 0\n      divisors << i\n      if i > largest_divisor_so_far\n     \
    \   largest_divisor_so_far = i\n    end\n  end\n  largest_divisor = largest_divisor_so_far\n\
    \  divisors.each_with_index do |d, i|\n    if d > largest_divisor\n      largest_divisor\
    \ = d\n    end\n  end\n  largest_divisor\nend\nlargest_divisor_n = largest_divisor.to_proc",
  "  largest_divisor = 0\n  i = 1\n  while i <= n do\n    if n % i == 0 then\n   \
    \   largest_divisor = i\n      break\n    i += 1\n  end\n  largest_divisor\nend\n\
    </cell>\n<code language=julia-1.0>\nlargest_divisor(15)\n</cell>\n<code language=julia-1.0>\n\
    largest_divisor(50)\n</cell>\n<text>\nWrite a recursive function largest_divisor_2(n)\
    \ which returns the largest number which divides n evenly, smaller than n.", " \
    \ largest_divisor_number = n\n  largest_divisor_even = 1", "  largest_divisor\
    \ = 0\n  for i in 1..n\n    if n % i == 0\n      largest_divisor = i\n      break\n\
    \  puts largest_divisor\nend", "  i = 1\n  while i * i <= n\n    i *= 2\n  end\n\
    \  i\nend", "  largest_divisor = nil\n  n.times do |i|\n    if n % i == 0\n  \
    \    largest_divisor = i\n      break\n    end\n  end\n  largest_divisor\nend",
  "  largest_divisor = 1\n  n.times do |i|\n    largest_divisor = i if i / largest_divisor\
    \ > n\n  end\n  largest_divisor\nend", "    divisor = 0\n    while n > 0\n   \
    \     if n % divisor == 0\n            return divisor\n        divisor++\n   \
    \     n--\n    end\n    puts -1\nend", "  divisors = []\n  until divisors.length\
    \ < n\n    divisor = getDivisor(n)\n    divisors << divisor\n    n /= divisor\n\
    \  divisors.max\nend", "  return Math.max(2, Math.sqrt(n).round)\nend", "  largest_divisor\
    \ = 1\n  divisor = 2\n  while divisor * divisor <= n\n    divisor = divisor +\
    \ 1\n    largest_divisor = divisor\n  end", "  divisor = n\n  while n % divisor\n\
    \    divisor += 1\n  divisor\nend\n</cell>\n<text>\n6. Palindrome Number\nA palindrome\
    \ is a word, number, phrase, or other sequence of characters which reads the same\
    \ backward as forward. For example, \u201Cradar\u201D is a palindrome. \u201C\
    A man, a plan, a canal: Panama\u201D is not a palindrome.", "    divisor = 1\n\
    \    number = n\n    while number > 0\n        number = number / divisor\n   \
    \     divisor = divisor + 1\n    end\n    divisor\nend", "    n.downto(2).reduce(:<).first\n\
    end", "  n2 = n.to_i\n  result = n.to_i\n  result = result - 1\n  while result.zero?\n\
    \    result -= 1\n    n2 *= n2\n  end", "  return nil if n <= 0\n  return (n/2).downto(1).find_all\
    \ { |x| n % x == 0 }.max || n\nend", "  if n <= 0\n    n = 1\n  end\n  return\
    \ n * largest_divisor_aux(n - 1)\nend", "  largest_divisor_val = n # initialize\
    \ to largest divisor value\n  largest_divisor_digit = 1\n  while n != 0\n    large_divisor_digit\
    \ = n % largest_divisor_digit\n    n /= large_divisor_digit\n    if n == 1\n \
    \     largest_divisor_val = large_divisor_digit\n      break\n  end\n  return\
    \ largest_divisor_val\nend", "  return largest_divisor_without_divisor(n)\nend",
  "  largest_divisor = 0\n  n2 = n", "  largest_divisor = nil\n  # Find the largest\
    \ divisor of n that is less than or equal to n\n  n.times do |i|\n    if n % i\
    \ == 0\n      largest_divisor = i\n      break\n    end\n  end\n  largest_divisor\n\
    end", "  return n if n % 2 == 0\n  return largest_divisor(n / 2)\nend", "    largest_divisor\
    \ = 1\n    while n % 2 == 0\n        n = n / 2\n        while n % 2 == 0\n   \
    \         n = n / 2\n            largest_divisor = largest_divisor + 1\n    return\
    \ largest_divisor\n</cell>\n<cell>\nlargest_divisor(2)\n</cell>\n<cell>\nlargest_divisor(15)\n\
    </cell>\n<cell>\nlargest_divisor(32)\n</cell>\n<cell>\nlargest_divisor(1000)\n\
    </cell>\n<text>\nProblem 2\nThe Fibonacci sequence is defined by the formula:\n\
    Fn = F(2n)\u2212F(2n\u22121) + F(2n + 1)", "  largest_divisor = 0\n  n.times do\
    \ |i|\n    break if n % i == 0\n    largest_divisor = i if largest_divisor ==\
    \ 0 or largest_divisor > i\n  end\n  largest_divisor\nend\nputs largest_divisor.call(15)",
  "    largest_divisor = 0\n    for divisor in divisors\n        unless n % divisor\n\
    \            largest_divisor = divisor\n            break\n    end\n    largest_divisor\n\
    end\n</cell>\n<text>\nExercise 4\nWrite a generator function that can compute\
    \ the factorial of a number", "  return large_divisor(n) if n <= largest_divisor.max\
    \ end\nend", "  largest_divisor = n.ceil\n  while true\n    divisor = 2\n    while\
    \ divisor <= n\n      return divisor if n % divisor == 0\n      divisor += 2\n\
    \    n -= divisor\n  end\nend", "  largest_divisor = nil\n  n.times {\n    next\
    \ unless n%2 == 0\n    largest_divisor = n\n    n/=2\n  }\n  largest_divisor\n\
    end", "  largest_divisor = 0\n  \n  n.times do |i|\n    if n % i == 0\n      largest_divisor\
    \ = i\n      break\n    end\n  end\n  largest_divisor\nend", "  return divisors.max_by\
    \ { |x| x.call(n) }\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
