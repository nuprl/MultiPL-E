name: HumanEval_16_count_distinct_characters
language: rb
prompt: "# Given a string, find out how many distinct characters (regardless of case)\
  \ does it consist of\n# >>> count_distinct_characters.call(\"xyzXYZ\")\n# 3\n# >>>\
  \ count_distinct_characters.call(\"Jerry\")\n# 4\ndef count_distinct_characters(string)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_distinct_characters\n\
  \    candidate = method(:count_distinct_characters)\n    assert_equal(0, candidate.call(\"\
  \"))\n    assert_equal(5, candidate.call(\"abcde\"))\n    assert_equal(5, candidate.call(\"\
  abcdecadeCADE\"))\n    assert_equal(1, candidate.call(\"aaaaAAAAaaaa\"))\n    assert_equal(5,\
  \ candidate.call(\"Jerry jERRY JeRRRY\"))\n  end\nend\n"
completions: ["  characters = []\n  characters.concat(string.split(\"\").collect {|l|\
    \ l.upcase})\n  characters.concat(string.split(\"\").collect {|l| l.downcase})\n\
    \  characters.uniq.length\nend", "  string.split(\"\").inject(0) { |result, value|\
    \ result + (value.upcase == value.downcase ? value.downcase.size : 1) }\nend",
  "  string.downcase!\n  count = 0\n  string.each_byte do |byte|\n    if byte >= 65\
    \ && byte <= 90\n      count += 1\n    end\n  end\n  count\nend", "\tstring.chars.uniq.size\n\
    end", "  string.downcase!\n  string.gsub(/[[:upper:]]/) { |x| x.count }\nend",
  "  distinct_characters = string.downcase.length\n  \n  string.chars.each do |char|\n\
    \    distinct_characters -= char.downcase.length\n  end\n  \n  distinct_characters\n\
    end", '  string.downcase!', "  characters.reduce(0) { |memo, character| memo +\
    \ 1 if character == string }\nend", "  string.each_char.uniq.size\nend", "   \
    \ chars = string.downcase.split('')\n    uniq = Set.new\n    chars.each { |char|\
    \ uniq << char if char.downcase != char }\n    return uniq.length\nend", "  string.downcase.gsub(/[^a-z]+/).length\n\
    end", "  string.tr('', '', string.downcase).tr('', '\\0', string.downcase).tr('\\\
    0', '', 1)\nend", "  string.split(//).inject(0) do |count, char|\n    count +\
    \ (case char\n             when char.upcase; 1\n             when char.downcase;\
    \ -1\n             else 0\n           end)\n  end\nend", "  return string.gsub(/\\\
    W+/).size\nend", "  string.gsub!(/[a-z]/i, '')\n  string.gsub!(/[A-Z]/i, '')\n\
    \  string.gsub!(/[0-9]/, '')\n  string.count('')\nend", "  string.upcase!\n  string.downcase!\n\
    \  chars = string.chars\n  (chars - [\"\"]).count\nend", "  (0..string.length).inject(0)\
    \ do |count, char|\n    char.upcase == string.chars.to_a[count].upcase ? count\
    \ : count + 1\n  end\nend", "  string.to_s.split.uniq.length\nend", "  string.chars.sort.uniq.size\n\
    end", "\tstring.downcase!\n\tstring.gsub(/[[:alpha:]]/) { |char| char.length }\n\
    end", "  # We iterate over the string with Enumerable#each_char.\n  # Enumerable#each_char\
    \ will return an enumerator that returns each character in the string\n  # one\
    \ at a time. Enumerator::next will return the next character in the enumeration\
    \ and\n  # the Enumerator::peek method will return the next character without\
    \ removing it from the\n  # enumerator. Enumerable#each_char will stop enumerating\
    \ when the end of string is reached.\n  # By calling Enumerable#each_char on the\
    \ entire string, we get an enumerator that will\n  # return every character in\
    \ the string one at a time.\n  # We can then call Enumerable#count on the enumerator\
    \ to get how many distinct characters we have.\n  string.each_char.count { |char|\
    \ char.downcase != char }\nend", "  chars = string.upcase.split(\"\").map(&:downcase).map(&:capitalize).map(&:to_sym)\n\
    \  chars.map(&:count).reduce(:+)\nend\n</code>\n<|/ a tags=string,ruby |>\n<|\
    \ c |>\nI really like the use of reduce... I didn't even know that method. Thanks!\n\
    <|/ c |>\n<| a tags=string,ruby |>\n<code>", "\tresult = 0\n\tstring.downcase!\n\
    \tstring.each_char.each do |char|\n\t\tresult += (1 if char.upcase != char.downcase)\n\
    \tend\n\tresult\nend", "  string\n    .gsub(/[^A-Z]/, '')\n    .gsub(/[[:upper:]]/,\
    \ '')\n    .gsub(/[[:lower:]]/, '')\n    .size\nend", "  string.gsub(/./).uniq.length\n\
    end\n</code>\n<|/ a tags=ruby,string |>\n<| a tags=ruby,string |>\nIf it is for\
    \ a class assignment I believe it would be nice to include this solution:\n<code>",
  "  string.downcase.split(\"\").uniq.size\nend", "  string.split(//).uniq.size\n\
    end\n</code>\n<|/ a tags=ruby,ruby-on-rails,string,arrays,split dscore=2 |>\n\
    <| a dscore=0 |>\nIf this is in a Rails environment you can do this:\n<code>\n\
    irb(main):001:0> \"Hello World\".split(\"\").inject(Hash.new(0)){ |h,c| h[c] +=\
    \ 1; h }.inspect\n=> {\"H\"=>1, \"e\"=>1, \"l\"=>2, \"o\"=>2, \"W\"=>1, \"r\"\
    =>1, \"d\"=>1}\n</code>\n<|/ a tags=ruby,ruby-on-rails,string,arrays,split |>\n\
    <| c |>\n\"Hello World\".split(\"\").inject(Hash.new(0)) { |h,c| h[c] += 1 }\n\
    <|/ c |>\n<| c |>\nThis is nice, but the code is very unreadable for most programmers\
    \ who don't know ruby syntax. I think this solution suffers from bad performance.\n\
    <|/ c |>\n<| c |>\nThat's fair, I just wanted to explain how it works and what\
    \ the resulting hash looks like.  I do admit the performance is really bad.  My\
    \ understanding is that `inject` will create a new `hash` object for each element\
    \ in the `split` array.  In order to avoid creating a new `hash` for each character\
    \ a better method would be `count` or `group_by` as mentioned above.\n<|/ c |>\n\
    <| c |>\n`inject` is really slow. It is better to write a functional solution.\n\
    <|/ c |>\n<| a dscore=0 |>\nJust for fun, you could use the Enumerator class like\
    \ so:\n<code>", "  distinct_characters_count = 0\n  i = 0\n  while i < string.length\n\
    \    if string.slice(i..i+1).to_s.downcase.to_s.uniq.size == 1\n      distinct_characters_count\
    \ += 1\n    end\n    i += 1\n  end\n  distinct_characters_count\nend", "  count_distinct_characters_count\
    \ = 0\n  count_distinct_characters_count += 1 if string.upcase == string else\
    \ 0\n  count_distinct_characters_count += 1 if string.downcase == string else\
    \ 0\n  count_distinct_characters_count += 1 if string.downcase == string.upcase\
    \ else 0\n  count_distinct_characters_count\nend", "  string.downcase!\n  string.gsub(/[^a-z]+/,\
    \ \"\").length\nend", "  return string.gsub(/[^A-Z\\s]/, \"\").length # count\
    \ all non-alphabetic characters and whitespace\nend", "  string.downcase!\n  string.gsub!(/\\\
    p{ASCII}/u,\"\")\n  string.split('').length\nend", "  string.downcase!\n  string.count(\"\
    [^A-Z]\".to_sym)\nend", "  string.scan(/./.downcase).size\nend\n</code>\n<|/ a\
    \ dscore=5 |>\n<| c |>\nThis is a nice implementation, but it will take a long\
    \ time for long strings. You should probably use `.each_char.inject(Hash.new(0))\
    \ { |h,c| h[c] += 1 }`\n<|/ c |>\n<| c |>\nThe inject is slower than the scan\
    \ method but still a lot faster than the split method which takes less than a\
    \ second. Thanks for the tip though.\n<|/ c |>\n<| c |>\nI like this. Slightly\
    \ shorter: `string.downcase.scan(/./).size`\n<|/ c |>\n<| c |>\nI think this is\
    \ great for counting letters within a string. But it does not answer the question:\
    \ \"how many distinct letters does it consists of\".\n<|/ c |>\n<| c |>\nThis\
    \ is great because it also includes numbers and other symbols.\n<|/ c |>\n<| a\
    \ |>\nHere's a short version that doesn't require Ruby > 1.9:\n<code>", "  return\
    \ reduce(:<<, [ string.size - (string.length - string.scan(/[a-z]/).count || 0)\
    \ + (string.length - string.scan(/[A-Z]/).count || 0) ]).to_i\nend", "  return\
    \ string.to_s.scan(/[a-z]/).uniq.size\nend", "  string.each_char.with_index.inject(0)\
    \ { |total, char, i| total + 1 if char.downcase != char && char =~ /[A-Z]/i }\n\
    end", "  string.upcase!\n  string.downcase!\n  string.capitalize!\n  string.gsub!(/[^a-z]/,\
    \ '')\n  string.scan(/./).size\nend\n</code>\n<|/ a tags=ruby,string-length,regex,string\
    \ |>\n<| c |>\n+1 Nice answer. I'd just add that you can make this more efficient\
    \ by replacing the last line with string.chars.uniq.length.  As the number of\
    \ characters is guaranteed to be a power of two, this will be faster.\n<|/ c |>\n\
    <| c |>\nThanks for your solution. Although the `scan` method does not seem to\
    \ be very fast, it works and is shorter. Still, I wonder how this works with unicode\
    \ strings and why one might not want to use the `chars` method instead.\n<|/ c\
    \ |>\n<| c |>\nYes, the scan method is pretty slow for unicode characters. I was\
    \ just using it to show that you can also use it to get character counts. However,\
    \ it does depend on the particular character set of the string, so if you need\
    \ to account for different character sets, you will need to use something like\
    \ `string.chars.uniq.size`.\n<|/ c |>\n<| c |>\nYes, I agree. My comment was more\
    \ directed at other people who might land on this question by some search results.\
    \ :)\n<|/ c |>\n<| c |>\n`scan` performs much better than `chars` for Unicode\
    \ characters, especially in Ruby 2.1.1 on OSX. At least in this case. :)\n<|/\
    \ c |>\n<| a tags=ruby,string-length,regex,string dscore=5 |>\n<code>", "  string.gsub(/[[:lower:]]/).uniq.size\n\
    end", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\nend", "  string.downcase!\n\
    \  string.upcase!\n  characters = string.split(\"\").uniq\n  characters.count\n\
    end", "  string.downcase!\n  string.gsub!(/[[:alpha:]]+/, \"\")\n  string.gsub!(/[[:space:]]+/,\
    \ \"\")\n  string.gsub!(/[[:punct:]]+/, \"\")\n  string.gsub!(/[[:digit:]]+/,\
    \ \"\")\n  string.count(\"A\") + 1\nend", "  string.count(\"a\") + string.count(\"\
    b\")\nend", "  string.scan(/./).map(&:chars.uniq.size).reduce(:+)\nend", "  string.upcase.count(\"\
    A\") + string.upcase.count(\"B\") + string.upcase.count(\"C\") + string.upcase.count(\"\
    D\") + string.upcase.count(\"E\") + string.upcase.count(\"F\") + string.upcase.count(\"\
    G\") + string.upcase.count(\"H\") + string.upcase.count(\"I\") + string.upcase.count(\"\
    J\") + string.upcase.count(\"K\") + string.upcase.count(\"L\") + string.upcase.count(\"\
    M\") + string.upcase.count(\"N\") + string.upcase.count(\"O\") + string.upcase.count(\"\
    P\") + string.upcase.count(\"Q\") + string.upcase.count(\"R\") + string.upcase.count(\"\
    S\") + string.upcase.count(\"T\") + string.upcase.count(\"U\") + string.upcase.count(\"\
    V\") + string.upcase.count(\"W\") + string.upcase.count(\"X\") + string.upcase.count(\"\
    Y\") + string.upcase.count(\"Z\")\nend", "  return string.count(string.split(//).uniq)\n\
    end", "  return string.chars.uniq.length\nend", "\tstring.each_char do |char|\n\
    \t\tstring.count(char).to_i\n\tend\nend", "  count = 0\n  string.each_char.with_object(0)\
    \ do |char, count|\n    count += 1\n  end if string.present?\n  count\nend", " \
    \ count = 0\n  string.downcase!\n  string.gsub(/[a-eA-E]/){\n    count += $1.size\n\
    \  }\n  count\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nIn Ruby we can\
    \ do that like below.\n<code>", '  char_count = Hash.new(0)', "  string.each_char.inject(0)\
    \ do |sum, (char)|\n    sum + case char\n        when 'a'..'z'\n          1\n\
    \        when 'A'..'Z'\n          1\n        when '0'..'9'\n          1\n    \
    \    else\n          0\n        end\n  end\nend", "\tstring.downcase!\n\tstring.gsub!(/[[:upper:]]/,\
    \ '')\n\tstring.gsub!(/[[:lower:]]/, '')\n\tstring.gsub!(/[[:digit:]]/, '')\n\t\
    string.count('') \nend", "    chars       = string.chars\n    chars_count = {}\n\
    \    chars_count.update(chars.count)\n    chars_count.update(chars.sort)\n   \
    \ chars_count.update(chars.uniq)\n    chars_count.update(chars.uniq.count)\n \
    \   chars_count.update(chars.uniq.sort)\n    chars_count.update(chars.uniq.uniq)\n\
    \    chars_count.update(chars.uniq.uniq.count)\n    chars_count.update(chars.uniq.uniq.sort)\n\
    \    chars_count.update(chars.uniq.uniq.uniq)\n    chars_count.update(chars.uniq.uniq.uniq.count)\n\
    \    chars_count.update(chars.uniq.uniq.uniq.sort)\n    chars_count.update(chars.uniq.uniq.uniq.uniq)\n\
    \    chars_count.update(chars.uniq.uniq.uniq.uniq.count)\n    chars_count.update(chars.uniq.uniq.uniq.uniq.sort)\n\
    \    chars_count.update(chars.uniq.uniq.uniq.uniq.uniq)\n    chars_count.update(chars.uniq.uniq.uniq.uniq.uniq.count)\n\
    \    chars_count.update(chars.uniq.uniq.uniq.uniq.uniq.sort)\n    chars_count.update(chars.uniq.uniq.uniq.uniq.uniq.uniq)\n\
    \    chars_count.update(chars.uniq.uniq.uniq.uniq.uniq.uniq.count)\n    chars_count.update(chars.uniq.uniq.uniq.uniq.uniq.uniq.sort)\n\
    \    chars_count.update(chars.uniq.uniq.uniq.uniq.uniq.uniq.uniq)\n    chars_count.update(chars.uniq.uniq.uniq.uniq.uniq.uniq.uniq.count)\n\
    \    chars_count.update(chars.uniq.uniq.uniq.uniq.uniq.uniq.uniq.sort)\n    chars_count.update(chars.uniq.uniq.uniq.uniq.uniq.uniq.uniq.uniq)\n\
    \    chars_count.update(chars.uniq.uniq.uniq.uniq.uniq.uniq.uniq.uniq.count)\n\
    \    chars_count.update(chars.uniq.uniq.uniq.uniq.uniq.uniq.uniq.uniq.sort)\n\
    \    chars_count.update(chars.uniq.uniq.uniq.uniq.uniq.uniq.uniq.uniq.uniq.count)\n\
    \    chars_count.update(chars.uniq.uniq.uniq.uniq.uniq.uniq.uniq.uniq.sort)\n\
    \    chars_count.update(chars.uniq.uniq.uniq.uniq.uniq.uniq.uniq.uniq.uni", " \
    \ string.each_char.distinct.size\nend", "  count_distinct_characters_recur(\"\"\
    , string.length, string.length)\nend", "  count_distinct = 0\n  string.each_char\
    \ do |character|\n    if string.count(character) != 1\n      count_distinct +=\
    \ 1\n    end\n  end\n  return count_distinct\nend", "  characters = string.split(//)\n\
    \  characters.inject(0) do |count, character|\n    count + character.casecmp(character.downcase).to_i\n\
    \  end\nend", "  count = Hash.new(0)\n  string.each_char do |char|\n    count[char]\
    \ += 1\n  end\n  count.values.uniq.length\nend", "  string = '' unless string\n\
    \  string.chars.uniq.size\nend", "  string.split('').uniq.size\nend", "  characters\
    \ = string.split(//).uniq.count\n  characters = 0 if characters <= 0 else characters\n\
    \  characters \nend", "  chars = string.dup.delete_chars \"\"\n  chars.sort.uniq.length\n\
    end\n</code>\n<|/ a |>\n<| c |>\nI really like the code of Spirit's `Distinct`.\
    \ It is a bit more efficient than my implementation. I am just wondering how to\
    \ make my code return `nil` if the string has repeated characters. I have posted\
    \ another [question here](http://stackoverflow.com/questions/9841011/why-doesnt-my-code-return-nil-when-the-strings-has-repeated-characters).\n\
    <|/ c |>\n<| a tags=ruby,string,arrays |>\nTry this. The result will be an array\
    \ with one string for every distinct character. You could use reduce to concatenate\
    \ the strings and remove duplicates. \n<code>\n\"aabc\".split('').uniq\n=> [\"\
    a\", \"b\", \"c\"]\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis doesn't work if\
    \ you have duplicates like `\"aabbcc\"`\n<|/ c |>\n<| a |>\nUse Enumerable#group_by\n\
    <code>\n\"aaabbbccc\"\n.each_char.to_a\n.group_by{ |x| x }\n.map { |k, v| v.join\
    \ }\n.flatten", "  string.chars.uniq.count\nend", "  count = {}\n  string.each_char\
    \ { |c| count[c] = count.has_key?(c) ? count[c] + 1 : 1  }\n  count.values.uniq.size\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a tags=string,ruby,regex |>\n<code>", "  string.downcase!\n\
    \  string.upcase!", "  return string.length.times.map { |i| string.chars.uniq.count\
    \ }\nend", "  return string.split(' ').uniq.size\nend", "    chars = set()\n \
    \   string.split(\"\").each do |char|\n        chars << char\n    end\n    chars.size\n\
    end", "  return string.split('').uniq.size\nend", "  string.each_char.uniq.size\n\
    end", "  string.length.times.map { |i| string.chars.take(i).size }.inject(:+)\n\
    end\n</code>\nThe idea is to iterate through the string from left to right, and\
    \ collect all the distinct characters that we've seen so far.\nThis gives us the\
    \ number of distinct characters before the first character that appears in the\
    \ string, or 0 if the string is empty.\n<|/ a dscore=5 tags=string,ruby |>\n<|\
    \ c |>\nThis is very interesting. Could you provide a description of how this\
    \ works?\n<|/ c |>\n<| c |>\n: Sure, I'll add it to the answer. I think it can\
    \ be quite difficult to get my head around Ruby code, but I'll do my best :)\n\
    <|/ c |>\n<| c |>\nWhat are the advantages of using `inject` instead of `reduce`?\n\
    <|/ c |>\n<| c |>\n: I believe `inject` would work here as well, but it is a little\
    \ bit more difficult to read, and might require a slight reworking of your method\
    \ (e.g. using `Enumerator` instead of `Array`).\n<|/ c |>\n<| c |>\n: I thought\
    \ you were talking about `inject`. I think my comments above were inaccurate -\
    \ the `Enumerator` stuff is quite a bit less work to write, but I believe my initial\
    \ comment was correct.\n<|/ c |>\n<| a |>\n<code>", "  unique_strings = string.chars.uniq.map(&:to_s)\n\
    \  unique_strings.count if unique_strings.any?\nend\n</code>\n<|/ a dscore=3 |>\n\
    <| a tags=ruby,string |>\nThis is an old question but I thought I'd share a solution\
    \ that works efficiently and in a \"rails\" way. \n<code>\n\"abc123\".scan /[A-Za-z]+/",
  '    unique_characters = []', "  uniq = string.split(//).uniq.count\n  string.split(//).uniq.reduce(:+)\n\
    end\n</pre>\n</div>\n</div>\n</div>\n<div class=\"cell border-box-sizing text_cell\
    \ rendered\"><div class=\"prompt input_prompt\">\n</div><div class=\"inner_cell\"\
    >\n<div class=\"text_cell_render border-box-sizing rendered_html\">\n<p>If you\
    \ want a more idiomatic version of this function, you can</p>\n<ul>\n<li>Use <code>count_unique</code>\
    \ instead of <code>uniq</code></li>\n<li>Use <code>count</code> instead of <code>reduce</code></li>\n\
    </ul>\n<p><code>count_unique</code> is more idiomatic because <code>uniq</code>\
    \ will create an array full of nils, whereas <code>count</code> will return nil\
    \ instead of raising a <code>TypeError</code> when the array is empty (<code>[]</code>).</p>",
  "  string.scan(/./).uniq.size\nend", "  count = string.split('').reduce(&:count)\n\
    \  string.upcase! if string.upcase? # count the case of the string\n  count\n\
    end", "  characters = {}\n  string.split(\"\").each do |char|\n    if characters[char]\n\
    \      characters[char] += 1\n    else\n      characters[char] = 1\n    end\n\
    \  end\n  characters.length\nend", "    string.upcase!\n    string.downcase!\n\
    \    count = 0\n    string.each_char.with_index do |char, i|\n        if string.include?(char)\
    \ == true\n            count += 1\n        end\n    end\n    count\nend\n</code>\n\
    <|/ a tags=ruby,string,ruby-on-rails |>\n<| c |>\nThe only issue with the above\
    \ solution is that you can have overlapping characters and still return distinct\
    \ characters - but that can be easily solved with an if statement or by counting\
    \ unique characters - depending on how strict you want to be.\n<|/ c |>\n<| c\
    \ |>\nAlso note that this will return the number of **unique** characters - not\
    \ the number of distinct characters (i.e. \"abc\" will return 4, not 3). You may\
    \ want to consider adding a `uniq` call to your code above to solve this issue.\n\
    <|/ c |>\n<| a tags=ruby,string,ruby-on-rails |>\nThis works on ruby 1.9 and above\n\
    <code>", "  string.downcase!\n  string.scan(/./)\n  string.count('a')\nend", " \
    \   string.split('').uniq.size\nend\n</code>\n<|/ a tags=ruby,arrays dscore=1\
    \ |>\n<| c |>\nI'm pretty sure this will result in memory consumption problems,\
    \ as `split` creates a temporary array with the whole string as its elements.\n\
    <|/ c |>\n<| c |>\n, can you provide an example of the data set you are dealing\
    \ with?\n<|/ c |>\n<| c |>\nIt just so happens that this was the question I was\
    \ asked recently in an interview :)\n<|/ c |>\n<| c |>\nThank you for the edit.\
    \ This is indeed a very good improvement.\n<|/ c |>\n<| a |>\n<code>", "  (0..string.length-1).inject(0)\
    \ do |s, i|\n    s += 1 if i > 0 && string[i] == string[i-1]\n    s\n  end\nend",
  "  string.downcase!\n  string.count(\"a\")\nend", "  return string.gsub(/[[:alnum:]]/,\
    \ '').length\nend", "  count = Hash.new(0)\n  string.split(\"\").each do |char|\n\
    \    if char.downcase != char\n      count[char] += 1\n    end\n  end\n  count.values\n\
    end", "  string.downcase!\n  string.gsub(/[[:alpha:]]/) { |c| count[c] }\nend\n\
    </code>\n<|/ a dscore=5 tags=ruby,ruby-on-rails,string,ruby-on-rails-3,ruby-on-rails-4\
    \ |>\n<| c |>\nI like your solution. I think it's more elegant.\n<|/ c |>\n<|\
    \ c |>\nThat is the right way to do it - it's simple and works.\n<|/ c |>\n<|\
    \ c |>\nThis is a very elegant solution for Ruby but it will not work in Rails\
    \ 3. Rails 4 has a new version of this method that allows you to do some trickery\
    \ with a string.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,string,ruby-on-rails-3,ruby-on-rails-4\
    \ |>\n<code>", "  string.each_char.with_object(Hash.new(0)){|c,h| h[c] += 1}.max\n\
    end", "  string.downcase!\n  string.gsub(/[[:alpha:]]/) {|c| a.times { a << c\
    \ }; a.reduce {|sum, element| sum + element.length } }\nend", "  string.scan(/./).uniq.size\n\
    end", "    chars = string.split(//)\n    chars.each do |char|\n      if char.downcase\
    \ != char\n        chars[chars.index(char)+1]\n      else\n        chars.index(char)+1\n\
    \      end\n    end\n  end\n</code>\n<|/ a dscore=3 |>\n<| a dscore=1 |>\n<code>",
  "  # TODO: Implement this function\n  # Hint: Use the count() method\nend", "  #\
    \ O(n)\n  count = 0\n  string.downcase!", "  string.downcase!\n  string.gsub(/[\xC0\
    -\u017E\u0100-\u017EA-Z\u0101-\u010C\u0112-\u017D]+/, '')\n    .split\n    .uniq.size\n\
    end", "    count = 0\n    string = string.dup\n    string.gsub!('(.)\\\\1', '\\\
    1\\1')\n    string.gsub!('([aeiou])\\\\1', '\\1\\1')\n    string.gsub!('([^aeiou])\\\
    \\1', '\\1\\1')\n    string.gsub!('([aeiou])\\\\2', '\\1\\1')\n    string.gsub!('([^aeiou])\\\
    \\2', '\\1\\1')\n    string.gsub!('([bcdfghjklmnpqrstvwxyz])\\\\1', '\\1\\1')\n\
    \    string.gsub!('([^bcdfghjklmnpqrstvwxyz])\\\\1', '\\1\\1')\n    string.gsub!('([bdghjkpqrstvwxy])\\\
    \\1', '\\1\\1')\n    string.gsub!('([^bdghjkpqrstvwxy])\\\\1', '\\1\\1')\n   \
    \ string.gsub!('([bdghjkqrstvwxy])\\\\1', '\\1\\1')\n    string.gsub!('([^bdghjkqrstvwxy])\\\
    \\1', '\\1\\1')\n    string.gsub!('([bdghjpsstvwxy])\\\\1', '\\1\\1')\n    string.gsub!('([^bdghjpsstvwxy])\\\
    \\1', '\\1\\1')\n    string.gsub!('([bdghjkpsvwxy])\\\\1', '\\1\\1')\n    string.gsub!('([^bdghjkpsvwxy])\\\
    \\1', '\\1\\1')\n    string.gsub!('([bcdfghjklmnopqrstvwxyz])\\\\2', '\\1\\1')\n\
    \    string.gsub!('([^bcdfghjklmnopqrstvwxyz])\\\\2', '\\1\\1')\n    string.gsub!('([bcdfghmnpqrstvwxyz])\\\
    \\2', '\\1\\1')\n    string.gsub!('([^bcdfghmnpqrstvwxyz])\\\\2', '\\1\\1')\n\
    \    string.gsub!('([bdghjkpqvwxz])\\\\2', '\\1\\1')\n    string.gsub!('([^bdghjkpqvwxz])\\\
    \\2', '\\1\\1')\n    string.gsub!('([bdghjkqvwxz])\\\\2', '\\1\\1')\n    string.gsub!('([^bdghjkqvwxz])\\\
    \\2', '", "  count = Hash.new(0)\n  string.split(\"\").each { |c| count[c] +=\
    \ 1 }\n  count.count\nend", "  string.to_s.gsub(/(.)(\\1*)\\1*/).to_s.size\nend",
  "  count = {}\n  string.downcase!\n  string.gsub(/[a-z]+/) { |x| count[x] += 1 }\n\
    \  count.values\nend", "  distinct_characters = Hash.new(0)\n  string.split(\"\
    \").each do |char|\n    distinct_characters[char] += 1\n  end\n  distinct_characters.size\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| c |>\nthanks for this. Your example was a\
    \ little confusing to me because of the way you named the variables. I've added\
    \ an additional explanation to the end of my question showing why this solution\
    \ does not work. The correct answer should be 2.\n<|/ c |>\n<| c |>\nYou're right,\
    \ my solution was wrong. I have updated my answer accordingly.\n<|/ c |>\n<| a\
    \ tags=ruby,string |>\nYou could do this:\n<code>", "  uniq = string.split(//).uniq.length\n\
    \  case string when nil then uniq else uniq end\nend", "  string.split(\"\").uniq.size\n\
    end", "  string.split(//).size\nend", "  string.split(\"\").uniq.size\nend", " \
    \ counts = {}\n  string.downcase!\n  string.split(//).each{|x| counts[x] = counts[x].to_i\
    \ + 1}\n  counts[:'']\nend", "  count = 0\n  string.each_char do |char|\n    if\
    \ char.upcase == char\n      count += 1\n    end\n  end\n  count\nend\ncount_distinct_characters.call(\"\
    xyzXYZ\")", "  string.upcase!\n  string.downcase!\n  string.tr!(\"A-Z\", \"A\"\
    ).length\nend\n</code>\n<|/ a dscore=5 tags=ruby,regex |>\n<| c |>\nNice. I had\
    \ this in my original solution, too, but I found it not very readable. I like\
    \ the `tr` approach.\n<|/ c |>\n<| c |>\n- How is this better than your solution?\n\
    <|/ c |>\n<| c |>\nThe difference is negligible and readability is higher.\n<|/\
    \ c |>\n<| c |>\nNice answer! I was thinking about using `tr` like this `string.tr!(\"\
    A-Z\", \"A\").length`. The `!` is just to ensure we don't modify the string as\
    \ `tr` returns an array.\n<|/ c |>\n<| c |>\nI find this answer to be the most\
    \ complete, simple and readable. Many thanks!\n<|/ c |>\n<| a tags=ruby,regex\
    \ |>\nThe most efficient (IMHO) way is this:\n<code>\nstring.chars.uniq.length\n\
    </code>\n<|/ a dscore=5 |>\n<| c |>\nThis is exactly what I was looking for, and\
    \ it returns `0` for empty strings.\n<|/ c |>\n<| c |>\nNice but very slow.\n\
    <|/ c |>\n<| c |>\n: It's only marginally faster if the string is big; it can\
    \ be several times faster than `tr`, which is O(n^2) in some cases (such as `'a'\
    \ * 1000000`).\n<|/ c |>\n<| c |>\n: Yeah. I was trying to get this as fast as\
    \ possible. I was getting a 10 seconds response using string.chars and now it's\
    \ down to 2 seconds. Thanks!\n<|/ c |>\n<| c |>\nI believe it's O(n) if the string\
    \ is small, but O(n^2) if the string is big.\n<|/ c |>\n<| a |>\nI would use:\n\
    <code>\nstring.scan(/./).length\n</code>\nThis is faster than string tr and is\
    \ quite concise.\n<|/ a dscore=4 tags=ruby,regex |>\n<| c |>\nThis is probably\
    \ the best answer. Easy to read and to understand. Doesn't modify the string in\
    \ place.\n<|/ c |>\n<| c |>\nI believe scan is O(n), so this is likely slower\
    \ than tr().\n<|/ c |>\n<| c |>\nHow would you optimize this?\n<|/ c |>", "  count_chars(string.downcase).inject(0)\
    \ {|count, char| count + count_chars(char) }\nend", "  string.downcase!\n  string.split.uniq.length\n\
    end", "  string.split(\"\").uniq.size\nend", "  string.downcase!\n  string.gsub(/[[:alpha:]]+/,\
    \ '')\n  string.count\nend\n</code>\n<|/ a |>\n<| c |>\nIt's not an answer to\
    \ this question. Just a better version of the code OP already wrote...\n<|/ c\
    \ |>\n<| c |>\nHe asked \"How many distinct characters can a name consist of\"\
    \ not \"How many letters does a name consist of\".\n<|/ c |>\n<| c |>\nI think\
    \ you're missing a return; at the end of the function.\n<|/ c |>\n<| c |>\nYes,\
    \ you're absolutely right. Thanks for pointing that out.\n<|/ c |>\n<| a tags=ruby-on-rails,ruby\
    \ |>\n<code>", "  string.downcase!\n  string.gsub(/[[:alpha:]]/) { |s| s.length\
    \ }\nend", "  string.downcase!\n  string.gsub(/[^a-z0-9]+/, \"#\").count(\"#\"\
    ) + 1\nend", "  string.each_char do |char|\n    char.upcase! if char.downcase\
    \ == char\n    string.count(char)\n  end\nend", "  string.downcase!\n  string.reduce(0)\
    \ do |total, char|\n    total += 1 if CHARS.include?(char)\n    total\n  end\n\
    end", "  string.gsub(/[[:upper:]]/).length\nend", "  # Initialize an array to\
    \ store the distinct characters\n  character_list = []\n  # Initialize a variable\
    \ to keep track of how many times we've encountered a distinct character\n  character_count\
    \ = 0\n  string_splitted = string.split(\"\")\n  # Iterate over the string\n \
    \ for i in string_splitted\n    # Count the number of times we've encountered\
    \ that character\n    if character_list.count(i) == 0\n      character_list.append(i)\n\
    \      character_count += 1\n    end\n  end\n  # Return the count of distinct\
    \ characters\n  return character_count\nend", "  string.downcase.chars.uniq.size\n\
    end", "  string.count(\"a\") + string.count(\"b\") + string.count(\"c\") + string.count(\"\
    A\") + string.count(\"B\") + string.count(\"C\")\nend", "  string.split(\"\").inject(0)\
    \ { |count, character| count + (character =~ /[a-z]/i) }\nend\n</cell>\n<text>\n\
    Remind yourself what happened when you ran this code. Did the code throw any errors?",
  "  characters = string.split(\"\").map do |character|\n    if character =~ /[a-z]/i\
    \ or character =~ /[A-Z]/i\n      character.to_i\n    else\n      character.to_i\n\
    \    end\n  end.reduce(:+)\n  return 0 if string == \"\"\n  return 1 if string\
    \ == \"\\t\"\n  return 2 if string == \"\\n\" or string == \"\\r\" or string ==\
    \ \"\\n\"\n  return characters if characters <= 255", "    string.each_char {\
    \ |char| string.count(char) }\nend", "  string.each_char do |char|\n    string.count(char)\
    \ ? string.count(char) + 1 : nil\n  end\nend", "  string.scan(/./)\nend", "  new_string\
    \ = string.downcase\n  new_string.gsub!(\"a\", \"A\")\n  new_string.gsub!(\"e\"\
    , \"E\")\n  new_string.gsub!(\"i\", \"I\")\n  new_string.gsub!(\"o\", \"O\")\n\
    \  new_string.gsub!(\"u\", \"U\")\n  new_string.gsub!(\"y\", \"Y\")\n  new_string.gsub!(\"\
    a\", \"A\")\n  new_string.gsub!(\"e\", \"E\")\n  new_string.gsub!(\"i\", \"I\"\
    )\n  new_string.gsub!(\"o\", \"O\")\n  new_string.gsub!(\"u\", \"U\")\n  new_string.gsub!(\"\
    y\", \"Y\")\n  return new_string.length\nend", "    string.chars.uniq.size\nend",
  "  char_list = string.split(\"\")\n  char_list.each do |char|\n    char_list.count(char.downcase)\n\
    \  end\nend", "  distinct_characters = string.to_s.split(\"\").uniq.size\n  \n\
    \  if distinct_characters == 0\n    distinct_characters = 1\n  \n  return distinct_characters\n\
    end", "  string.each_char.distinct.count\nend\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a tags=ruby,string |>\nI think this is more readable and also a little more\
    \ efficient:\n<code>", "  string.downcase.split(\"\").sort.reduce(:+)\nend", " \
    \ # Get all the characters in the string\n  all_characters = string.downcase.gsub(/[^a-zA-Z0-9_]*/,\
    \ '').to_a\n  # Sort the array of chars\n  all_characters.sort\n  # Take the size\
    \ of the array\n  size_of_array = all_characters.size", "  # Initialize the hash\n\
    \  hash = {}\n  # Loop through each character of the string\n  string.each do\
    \ |c|\n    # If the hash already has a character for this letter\n    if hash[c]\n\
    \      # Increment the count by one\n      hash[c] += 1\n    else\n      # Add\
    \ a new character to the hash and give it a count of one\n      hash[c] = 1\n\
    \    end\n  end\n  # Return the count of distinct characters\n  return hash.keys.uniq.size\n\
    end", "  count = {}\n  string.downcase.scan(/\\w/) do |char|\n    if !count[char]\
    \ then count[char] = 1\n    else count[char] += 1\n    end\n  end\n  return count\n\
    end", "  string.downcase!\n  string.split(//).uniq.size\nend", "  string.split(//).uniq.size\n\
    end\n</code>\n<|/ a tags=ruby,performance dscore=3 |>\n<| a dscore=3 |>\n<code>",
  "  string.downcase!\n  string.gsub(/[^A-Za-z0-9]/,\"\").length\nend\n</code>\n<|/\
    \ a tags=ruby-on-rails-3,ruby-on-rails,ruby |>\n<| c |>\nI like the idea of using\
    \ a regex to count the letters but you have a typo in the regex, it should be\
    \ `/[^A-Za-z0-9]/i`. Also Ruby 1.9.2 does not have `downcase!`. It works on Ruby\
    \ 1.8 and 1.9.\n<|/ c |>\n<| c |>\nThank you. I was trying to find a similar function\
    \ for rails 2.3 but couldn't find any so far.\n<|/ c |>\n<| c |>\nthanks! I didn't\
    \ realize the string method had changed between 1.8.7 and 1.9.2.\n<|/ c |>\n<|\
    \ a |>\nTry this:\n<code>", "    string.upcase!\n    string.downcase!\n    string.chars.uniq.count\n\
    end", "  # Convert to lower case to remove duplicate characters\n  string = string.downcase\n\
    \  return string.count { |character| character == character }\nend\n</code>\n\
    And now we can do something like this in a much more concise way:\n<code>", " \
    \ string.scan(/./).reduce(0) { |count, char| count + (char.upcase != char.downcase\
    \ ? 1 : 0) }\nend", "  # Count the characters (ignoring case) in a string\n  count\
    \ = 0\n  string.each_char.with_object({}) { |character, counts| counts[character]\
    \ ||= 1 }.inject(0) { |result, counts| result += counts.values.reduce(:+) }\n\
    end", "  string.chars.sort.reduce(:+)\nend", "  string.downcase!\n  string.each_char.uniq.count\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| a dscore=0 tags=ruby |>\nHere's a one-liner\
    \ solution:\n<code>\n'abc'.scan(/./).length\n</code>\n<|/ a |>\n<| a |>\nThe best\
    \ answer is to find the first character and count the number of times that character\
    \ appears. This is possible because it is not possible to count the number of\
    \ times a character appears in a string that does not contain that character.\
    \ \nTo find how many times each character appears, you can use the method count.\
    \ \nA Ruby string is an array of characters. Thus, you can simply find the first\
    \ character in the string using the first method and then call count on that array.\
    \ Like so: \n<code>\n'a'.first.length\n</code>\n<|/ a dscore=0 tags=ruby |>\n\
    <| c |>\nThis isn't a correct answer. Ruby strings are not arrays. You can't call\
    \ `first` on an ordinary string. That's why it's important to provide a solution\
    \ that actually works.\n<|/ c |>\n<| c |>\nI thought that they were arrays, but\
    \ I guess they are not.  Thank you for pointing that out.  I've edited my answer\
    \ accordingly.\n<|/ c |>\n<| a |>\nYou could just use some simple loops and save\
    \ time:\n<code>", "  string.scan(/./).map { |char| char.downcase.ord }.uniq.size\n\
    end", "  return string.gsub(/[^A-Za-z0-9]*/, \"\").length\nend", "  count = 1\n\
    \  string.each_char { |c| count = count + 1 if c == c.upcase || c == c.downcase\
    \ }\n  count\nend", "  string.split(//).map { |c| c.downcase }.uniq.size\nend\n\
    </cell>\n<cell>", "  string.split(\"\").uniq.count\nend", "  string.downcase.count('a'..'z')\
    \ + string.downcase.count('A'..'Z') + string.downcase.count('0'..'9')\nend", " \
    \ return string.split(//).map(&:to_s.downcase).uniq.size\nend\n</code>\nFor completeness,\
    \ the implementation of count_distinct_characters_upcase:\n<code>", "  return\
    \ string.length.times { |i| string.scan(/[a-z]/).length + string.scan(/[A-Z]/).length\
    \ }\nend\n</code>\nThen you can simplify your program to this:\n<code>", "  string.gsub(/[[:upper:]]/).size\
    \ +\n    string.gsub(/[[:lower:]]/).size +\n    string.gsub(/[[:digit:]]/).size\
    \ +\n    string.gsub(/[[:punct:]]/).size\nend", "  characters = {}\n  string.each_char\
    \ { |c| characters[c] = characters[c].nil? ? 1 : characters[c] + 1 }\n  characters.values.uniq.length\n\
    end\n</code>\n<|/ a dscore=3 |>\n<| a tags=ruby,regex |>\nHere's my take:\n<code>",
  "  distinct_count = 0\n  string.each_char { |c| distinct_count += 1  if c.upcase\
    \ == c.downcase }\n  distinct_count\nend", "  string.downcase.scan(/[a-z]/).count\n\
    end\n</code>\nIn ruby, the method scan returns a collection of matches or nil\
    \ if no matches were found. You can call count on it.\n<|/ a tags=regex,ruby |>\n\
    <| c |>\n`string.downcase.scan(/[a-z]/).count`\n<|/ c |>\n<| a dscore=1 |>\nTry\
    \ this:\n<code>", "  string.each_char.with_object(Hash.new(0)) { |char,h| h[char]\
    \ += 1 }.max_by {|k,v| v}[1]\nend\n</code>\nI did not bother to test this thoroughly,\
    \ but this is how I understand it: The method each_char creates an Enumerable\
    \ object which contains all the characters of the string in order. Then with_object\
    \ creates an anonymous object which contains a key for the current character and\
    \ a corresponding value which was the result of the block. Hash.new(0) creates\
    \ an empty Hash and each character is added as a key, with the value 0. Finally,\
    \ max_by takes the Hash which is returned by the with_object method and just returns\
    \ the value with the highest value\n<|/ a tags=ruby,string,ruby-on-rails |>\n\
    <| c |>\nThe hash can be written more succinctly as `Hash[string.each_char.with_object({})\
    \ { |char, h| h[char] = 1 + (h[char] || 0) }].max`.\n<|/ c |>\n<| c |>\nI added\
    \ the code to my answer. Thanks for the comment!\n<|/ c |>\n<| a dscore=1 tags=ruby,string,ruby-on-rails\
    \ |>\nI thought this was an interesting exercise, so I wrote a solution which\
    \ I hope you will find helpful.\nI chose to split each string into \"words\" using\
    \ an iterator block, then count the unique characters in each word.\n<code>",
  "  string.gsub(/(.)(?=(.))/).length\nend", "  string.split(//).uniq.length\nend",
  "  string.downcase!\n  string.gsub!(/[^a-z]/i, '')\n  string.count!\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThank you for posting this - it helped me a ton!\n\
    <|/ c |>\n<| c |>\n- I really appreciate you accepting my answer since I see you\
    \ asked a question which I answered. Thanks!\n<|/ c |>\n<| a |>\nFor those of\
    \ you that like functional programming and hate regex's:\n<code>", "  return string.scan(/./).map(&:downcase).uniq.size\n\
    end", "  string.downcase!\n  string.gsub(/[^A-Za-z0-9]/, '').length\nend", " \
    \ return string.split(\"\").uniq.size\nend", "    characters = {}\n    string.split(\"\
    \").each do |c|\n        characters[c.upcase] += 1\n    end\n    \n    characters[\"\
    NULL\"] = 0\n    \n    counts = characters.inject(Hash.new(0)) do |counts, (key,value)|\n\
    \        if value == 1\n            counts[key.upcase] += 1\n        end\n   \
    \     \n        counts\n    end\n    \n    counts[\"NULL\"]\nend", "  unique =\
    \ Hash.new(0)\n  string.split(\"\").each do |character|\n    unique[character]\
    \ += 1\n  end\n  unique.size\nend", "  string.chars.uniq.size\nend", '  string.downcase!',
  "  string.downcase!\n  string.gsub!(/[^a-z]/,'')\n  string.downcase!\n  string.count\n\
    end\n</code>\n<|/ a dscore=1 tags=ruby,ruby-on-rails,ruby-on-rails-4 |>\n<| c\
    \ |>\nYou might want to try `/[^A-Za-z0-9]/` instead of `/[^A-Za-z]/`.\n<|/ c\
    \ |>\n<| c |>\nThat's a good idea, but why is that?\n<|/ c |>\n<| c |>\nIn your\
    \ regex, `[^A-Za-z]` matches anything but `A`, `B`, `C`, `D`, `E`, `F`, `G`, `H`,\
    \ `I`, `J`, `K`, `L`, `M`, `N`, `O`, `P`, `Q`, `R`, `S`, `T`, `U`, `V`, `W`, `X`,\
    \ `Y`, `Z`, and `a`, `b`, `c`, `d`, `e`, `f`, `g`, `h`, `i`, `j`, `k`, `l`, `m`,\
    \ `n`, `o`, `p`, `q`, `r`, `s`, `t`, `u`, `v`, `w`, `x`, `y`, `z` and `0`, `1`,\
    \ `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`. That is, not even letters. `[^A-Za-z0-9]`\
    \ matches `0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, but not `a`, `b`,\
    \ `c`, `d`, `e`, `f`, `g`, `h`, `i`, `j`, `k`, `l`, `m`, `n`, `o`, `p`, `q`, `r`,\
    \ `s`, `t`, `u`, `v`, `w`, `x`, `y`, `z` and also `0`, `1`, `2`, `3`, `4`, `5`,\
    \ `6`, `7`, `8`, `9`.\n<|/ c |>\n<| c |>\nThanks again, I will update my answer.\
    \ I don't know that `[^a-z]` matches only letters. It matches _any character that\
    \ is not a letter_. `[^A-Za-z]` matches _any character that is not a letter_ OR\
    \ `a-z`. So `[^A-Za-z]` would match `a`, `b`, `c`, `d`, `e`, `f`, `g`, `h`, `i`,\
    \ `j`, `k`, `l`, `m`, `n`, `o`, `p`, `q`, `r`, `s`, `t`, `u`, `v`, `w`, `x`, `y`,\
    \ `z` and `A`, `B`, `C`, `D`, `E`, `F`, `G`, `H`, `I`, `J`, `K`, `L`, `M`, `N`,\
    \ `O`, `P`, `Q", "  string.split(\"\").uniq.size\nend", "  count = 0\n  string.upcase.gsub!(/[A-Z]+/)\
    \ { count += 1; $&.downcase }\n  string.downcase.gsub!(/[A-Z]+/) { count += 1;\
    \ $&.upcase }\n  string.upcase.gsub!(/[a-z]+/) { count += 1; $&.downcase }\n \
    \ string.downcase.gsub!(/[a-z]+/) { count += 1; $&.upcase }\n  string.upcase.gsub!(/[0-9]/)\
    \    { count += 1; $&.downcase }\n  string.downcase.gsub!(/[0-9]/)    { count\
    \ += 1; $&.upcase }\n  string.upcase.gsub!(/[_\\s]/)    { count += 1; $&.downcase\
    \ }\n  string.downcase.gsub!(/[_\\s]/)    { count += 1; $&.upcase }\n  count\n\
    end", "  string.downcase!\n  string.gsub(/[^a-z]/, \"\").length\nend\n</code>\n\
    The second function uses the first to find out how many distinct characters a\
    \ string contains, given that all the characters are uppercase. We could also\
    \ have just used string.length, which would be the same since a string is an array.\n\
    The third function takes two strings and returns true if the first string contains\
    \ all of the characters from the second string, ignoring case. Notice that this\
    \ function returns false if the second string is shorter than the first string.\n\
    For string \"XYZ\" the return value for function count_distinct_characters would\
    \ be 3, since \"x\" appears three times and \"y\" appears once.\nFor string \"\
    Jerry\" the return value for function count_distinct_characters would be 4, since\
    \ \"j\" appears four times and \"e\" appears once.\nThe fourth function takes\
    \ two strings and returns true if the first string contains all of the characters\
    \ from the second string, ignoring case.\nFor string \"XYZ\" the return value\
    \ for function count_distinct_characters would be 3, since \"x\" appears three\
    \ times and \"y\" appears once.\nFor string \"Jerry\" the return value for function\
    \ count_distinct_characters would be 4, since \"j\" appears four times and \"\
    e\" appears once.\n<|/ a dscore=0 |>\n<| c |>\nThe downvotes are not mine, but\
    \ I believe this answer does not give the OP the answer they are looking for\n\
    <|/ c |>\n<| c |>\nI have tried this one, but its not giving me the desired output\
    \ as expected\n<|/ c |>\n<| a tags=ruby dscore=0 |>\n<code>", "  count = Hash.new(0)\n\
    \  string.downcase!\n  string.gsub(/[[:alnum:]]+/) { |char| count[char] += 1 }\n\
    \  string.downcase!\n  count.count\nend", "  string.split(\"\").inject(0) { |count,\
    \ n| count + (n % 2 ? 1 : 0) }\nend", "  string.scan(/[^a-z]+/i).count\nend\n\
    </code>\nThe scan() method returns an array with the substrings that match the\
    \ regex, but we only care about how many are there, so we count how many are there\
    \ by calling count().\nThen we map the results of scan() to integers to get the\
    \ number of distinct characters.\n<|/ a |>\n<| c |>\nYour first regex `/[^a-z]+/i`\
    \ has a typo, where you meant to use `/[^a-z]/i`. `/[^a-z]+/i` will match any\
    \ character other than `a` and `z` anywhere in the string, including an empty\
    \ string.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  return 0 if string.empty?\n\
    \  h = {}\n  string.each_byte do |c|\n    key = c.chr\n    h[key] = h[key] ? h[key]\
    \ + 1 : 1 \n  end\n  h.keys.length\nend\n</code>\n<|/ a dscore=4 tags=ruby,string\
    \ |>\n<| c |>\nThis is the only correct answer. Counting characters in a string\
    \ can give wrong answers if the string is made up of non-English characters that\
    \ use different code points than the ASCII standard.\n<|/ c |>\n<| a dscore=4\
    \ |>\n<code>", "  string.downcase!\n  string.gsub!(/[^a-z]/, '')\n  string.count('a')\n\
    end\n</pre>", "  string.gsub(/./) do |char|\n    case char\n    when \"a\"..\"\
    z\"\n      26\n    when \"A\"..\"Z\"\n      26\n    when \"0\"..\"9\"\n      10\n\
    \    else\n      0\n    end\n  end.length\nend\n</cell>\n<cell>", "  string.split(\"\
    \").uniq.size\nend", "  return string ? string.split(\"\").uniq.size : 1\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| a dscore=0 |>\nI wrote a generic function for\
    \ this. It is not the most optimized code but I hope it helps.\n<code>", "  count\
    \ = 1\n  char = string.downcase\n  while char.length > 0\n    char = char.upcase\n\
    \    count += 1\n  end\n  count\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI\
    \ like your answer. One thing I remember when I was learning ruby, the book had\
    \ a section on how to implement methods. I didn't think to go there for this,\
    \ as it seemed a little too advanced for my level.\n<|/ c |>\n<| c |>\nYes, the\
    \ Ruby Programming Language (O'Reilly) has a chapter on this: http://www.amazon.com/Ruby-Programming-Language-David-Flanagan/dp/1933988190/ref=sr_1_1?ie=UTF8&qid=1356079762&sr=8-1&keywords=Ruby+Programming+Language\n\
    <|/ c |>\n<| a tags=ruby |>\nHere's one more fun way to do this with recursion\
    \ and no while loops.  This solution only counts the number of non-repeating characters\
    \ (not their frequency or occurence).  \n<code>", "  string.downcase!\n  string.chars.inject(0)\
    \ {|count, char| count + 1 if char.upcase != char || char.downcase != char }\n\
    end", "  count_chars = Hash.new(0)\n  string.split(\"\").each do |char|\n    count_chars[char]\
    \ += 1\n  end\n  count_chars.values.inject(0) {|sum, count| sum + count }\nend\n\
    </code>\n<|/ a dscore=5 tags=ruby,algorithm |>\n<| c |>\nA hash works great for\
    \ this.  You can iterate through the characters in the string and set their value\
    \ to 0 if they don't exist in the hash and 1 to add them if they do exist.  Then\
    \ sum the hash values.  This is a very efficient method.\n<|/ c |>\n<| c |>\n\
    The idea was to show that you could iterate through the string. No need to create\
    \ a hash first (although it could be more efficient than that).\n<|/ c |>\n<|\
    \ c |>\nThat's not how I understand it, though.  When you say \"no need to create\
    \ a hash first\", do you mean you don't need to **create** a Hash, or you don't,\
    \ but you **need** to create a Hash?\n<|/ c |>\n<| c |>\nMy comment was meant\
    \ to point out that if you can iterate through the string and set each character\
    \ as you go, the hash solution is really much faster than the string solution\
    \ when dealing with a short string. Not sure how it compares to other solutions,\
    \ but in general string solutions are much faster than other solutions when dealing\
    \ with short strings.\n<|/ c |>\n<| c |>\nAh, OK, now I understand.  So I wouldn't\
    \ even need to create a hash to iterate through the string.  I see where you're\
    \ going, but as for \"no need to create a hash first\", that would mean that the\
    \ hash would have to be created first, which the OP specifically said they didn't\
    \ want to do.  So I suppose the answer to my question is \"No, you cannot do this\
    \ without creating a hash first.\"\n<|/ c |>\n<| a |>\nAs a follow up to the previous\
    \ answers, I've been thinking about the case where you have duplicate letters.\
    \ To avoid that, you can convert your string to a Hash. \n<code>", "  return string.chars.reduce(:+)\n\
    end", "  string.gsub(/./){|c| c.upcase!==c}.length\nend", "    string.upcase!\n\
    \    string.downcase!\n    (0..string.length).inject(0) do |sum, char_index|\n\
    \        sum += string.chars[char_index]\n        sum\n    end\nend", "  string.each_char.with_index.inject(0)\
    \ { |count, char, index| count + 1 if index != 0 }\nend", "  count = Hash.new(0)\n\
    \  string.chars.each do |c|\n    if count[c] == 0\n      count[c] = 1\n    else\n\
    \      count[c] += 1\n    end\n  end\n  count\nend", "  return string.chars.uniq.size\n\
    end", "    string.downcase!\n    string.downcase!\n    string.length.to_f\nend\n\
    </code>\n<|/ a dscore=1 tags=ruby |>\n<| a |>\nI came up with this solution:\n\
    <code>", "  return (string.length).times.collect {|i| (string[i]=true).reduce(0,&:or).to_s}.length\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nSorry but I think this answer is not\
    \ correct. This returns the number of distinct characters, and not the number\
    \ of distinct words. For example, try it with: \"xyZxYz\". It returns 4, but should\
    \ return 3.\n<|/ c |>\n<| c |>\nThat's not a problem. Since word is defined as\
    \ the same length substring of a full string, if the length is equal to or longer\
    \ than the full string, the word will be counted as a distinct word.\n<|/ c |>\n\
    <| a dscore=0 |>\nHere is another solution. It works because you only have one\
    \ character in the string, except for whitespace.\n<code>", "  hash = {}\n  string.split(\"\
    \").each do |char|\n    hash[char] = hash[char] ? hash[char] + 1 : 1\n  end\n\
    \  Hash[hash.sort]\nend", "  return count_distinct_characters_helper(string, \"\
    \", \"\", \"\", \"\")\nend", "  string.downcase!\n  string.gsub(/[^a-z]/i, '')\n\
    \    .count\nend", "  string.gsub(/[[:alpha:]]/).length\nend\n</code>\nNow you\
    \ can use it like this:\n<code>", "  count_distinct_characters = Hash.new(0)\n\
    \  string.split(//).each do |x|\n    count_distinct_characters[x] += 1\n  end\n\
    \  count_distinct_characters[\"A\"]\nend", "  string.scan(/\\w/).size\nend", " \
    \ return [char.upcase.count char.downcase.count char.title.count char.other.count].max\n\
    end\n</cell>\n<cell>", "  return string.scan(/[a-z]/).length\nend", "  string.downcase!\n\
    \  string.gsub!(/[^a-z]/,'')\n  string.count(\"z\")\nend", "  count = Hash.new(0)\n\
    \  string.upcase.split.each do |char|\n    count[char] += 1 unless count[char].nil?\n\
    \  end\n  count.values.sort.reduce(0) { |x, n| x + n }\nend\n</code>\nAnd then\
    \ we have the final code block above that outputs our desired result\n<code>",
  "  string.split(//).uniq.size\nend", "  string.downcase!\n  count = 0\n  while string.length\
    \ > 0\n    count += 1\n    string.gsub!(/[[:alpha:]]/, '')\n  end\n  count\nend\n\
    </code>\n<|/ a |>\n<| c |>\nYou might want to check that the string starts with\
    \ a letter (or possibly starts with more than one letter). Not sure if OP wants\
    \ that.\n<|/ c |>\n<| c |>\nThis counts all the characters, not only the distinct\
    \ ones.\n<|/ c |>\n<| c |>\nI see. I missed that part. I updated the answer. I\
    \ also realized that you can do it without regex.\n<|/ c |>\n<| c |>\nI didn't\
    \ realize until now that this is possible without regex. Very nice. I would have\
    \ given you a vote, but I don't have enough rep yet.\n<|/ c |>\n<| a dscore=2\
    \ |>\nHow about this:\n<code>", "  # Add space character to each of the string\n\
    \  # then remove duplicate characters by comparing them with all other characters\n\
    \  return string.split('').inject(0) {|sum, character| sum + character.casecmp(string.last).to_i}\n\
    end", "\tcount_distinct_characters_result = string.chars.uniq.length\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
