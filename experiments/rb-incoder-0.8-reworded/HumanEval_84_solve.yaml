name: HumanEval_84_solve
language: rb
prompt: "# Given a positive integer N, return the total sum of its digits in binary.\n\
  # Example\n# >>> solve.call(1000)\n# \"1\"\n# >>> solve.call(150)\n# \"110\"\n#\
  \ >>> solve.call(147)\n# \"1100\"\n# Variables:\n# @N integer\n# Constraints: 0\
  \ \u2264 N \u2264 10000.\n# Output:\n# a string of binary number\ndef solve(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solve\n\
  \    candidate = method(:solve)\n    assert_equal(\"1\", candidate.call(1000))\n\
  \    assert_equal(\"110\", candidate.call(150))\n    assert_equal(\"1100\", candidate.call(147))\n\
  \    assert_equal(\"1001\", candidate.call(333))\n    assert_equal(\"10010\", candidate.call(963))\n\
  \  end\nend\n"
completions: ["    puts \"\"\n    puts \"Answer:\"\n    puts \"0#{n.to_s(2)}\"\n \
    \   puts \"\"\nend", "    sum = \"\"\n    digit = n.to_s(2)\n    while digit.length\
    \ != 0\n        sum += digit.slice!(0,1)\n        digit = digit.slice!(0,2)\n\
    \    end\n    sum\nend", "  ret = \"\"\n  while n > 0 do\n    ret += n%2\n   \
    \ n /= 2\n  end\n  ret\nend", "  str = n.to_s\n  str = str.reverse\n  for i in\
    \ 1..str.size\n    str = str[1..-1] * i\n  end\n  str\nend", "  # TODO: implement\
    \ this function\n  return\nend", "  n.zero?\n  n.odd? ? solve_odd(n) : solve_even(n)\n\
    end", "  sum = 0\n  while n > 0\n    s = n.to_s(2)\n    sum += s.chars.reduce(:+)\n\
    \    n -= s.to_i(2).abs\n  end\n  sum.to_s(2).reverse.gsub(/(.)(.)/, '\\1\\2').reverse\n\
    end", "  n.to_s(2).reverse.gsub(/(.)(?=(\\d{1})+(?!\\d))/, '0\\\\1').reverse\n\
    end\n</cell>\n<code language=julia-1.6>\n@time solve.call(300);\n</cell>\n<code\
    \ language=julia-1.6>", "    n.to_s(2).reverse.gsub(/(.{8})(....)(..)/, '\\1\\\
    2\\3')\nend", "  a = n.to_s(2)\n  b = a.split(\"0\").map{|n| n.reverse.to_i(2).to_s(2)}.reverse\n\
    \  puts b.inject(:+)\nend\n</code>\n<|/ a tags=ruby |>\n<| a |>\n<code>", "  if\
    \ n < 0\n    n = 0\n  else\n    n = n.to_i\n  end\n  i = 2\n  total = \"\"\n \
    \ while i * i <= n\n    total += (n / i).to_s\n    i += 1\n  end\n  total\nend",
  "  result = ''\n  n.to_s.split(//).each_with_index do |digit, i|\n    result <<\
    \ digit if i && i % 2 == 0\n  end\n  result\nend", "    binary = n.to_s(2)\n \
    \   tot = 0\n    digits = binary.split(//)\n    digits.each do |d|\n        tot\
    \ += (d.to_i(2).to_s(2).split('').reverse.to_i) * Math.pow(2,digits.length - 1)\n\
    \    end\n    tot = tot-tot%10\n    return tot.to_s(2)\nend", "  result = ''\n\
    \  digit = 0\n  while n > 0 do\n    digit += 1\n    n /= 2\n  end\n  result <<\
    \ digit.to_s\n  while n > 0 do\n    result << digit.to_s\n    n -= 1\n    digit\
    \ += 1\n  end\n  return result.upcase\nend", "  \n  # Your code here\n  num =\
    \ 1\n  \n  while n > num\n    num = num * 2\n  end\n  \n  while num > 0\n    s\
    \ = (num % 2)\n    num = num / 2\n    puts s\n  end\n  \n  puts \"0\"\n  \nend",
  "  s = ''\n  while n > 0 do\n    s, n = s.divmod(n)\n    s << 1\n  end\n  s.to_s\n\
    end", "  return \"1\" + solve.call(-n) if n >= 0 else \"0\"\nend", "    return\
    \ n.to_s(2).reverse.chars.inject('') { |s, i| s << ('1' + i).to_s(2) }\nend",
  "  ns = n.to_s(2).split('')\n  ns = ns.map {|n| n.reverse.chars.map {|x| x == '1'\
    \ ? 1 : 0}}\n  ns = ns.reduce([]) {|sum, a| sum + a}\n  ns.reverse.each {|b| puts\
    \ b}\nend", "    if n == 0\n        \"0\"\n    else\n        result = 0\n    \
    \    n.times { result += n % 2 == 0 ? 1 : 0 }\n        solve.call(n / 2, result)\n\
    \    end\nend", "  i = 2\n  sum = \"\"\n  while i <= n\n    digits = n.to_s.split(//).map(&:to_i)\n\
    \    digits += [0] * (i - digits.length)\n    sum = sum + digits.reduce(:+)\n\
    \    i += 1\n  end\n  sum\nend", "  (0..n).to_a.inject { |sum, number| sum.to_s\
    \ + number.to_s(2) }\nend\n</cell>\n<cell>", "  \n  result = ''", "  str = n.to_s(2)\n\
    \  str.gsub!(/..?/, '')\n  str.gsub!(/[0 1]/, '0')\n  str\nend", "  # Your code\
    \ here\n  arr = [0, 1]\n  n.times do |i|\n    arr << (n % (2**i)).to_s\n    n\
    \ /= 2**i\n  end\n  return arr.join('')\nend", "  puts n.to_s(2).reverse.gsub(/(..)(..)/,'\\\
    1\\1').reverse\nend\n</code>\n<|/ a dscore=0 tags=ruby |>\n<| a dscore=0 |>\n\
    Just an alternative approach that doesn't use Regex:\n<code>", "  return \"#{n.to_s(2).count(\"\
    1\").times.map {|x| x.to_s(2)}.join}\"\nend", "  s = \"\"\n  x = 1\n  while n\
    \ > 0\n    z = n % 10\n    s += \"#{z}\"\n    n /= 10\n  end\n  return s\nend",
  "  # your code here\n  return n.to_s.split(//).inject(:+)\nend", "    return n.to_s(2).reverse.scan(/../).map\
    \ { |i| i.to_i }.reduce(:+)\nend\n</cell>\n<cell>\n%qupy solve\n</cell>\n<cell>\n\
    %qupy solve.call(1000)\n</cell>\n<cell>\n%qupy solve.call(150)\n</cell>\n<cell>\n\
    %qupy solve.call(147)\n</cell>\n<cell>\n%qupy solve.call(149)\n</cell>\n<text>\n\
    Bonus Problem - Write a function to return the number of times a particular digit\
    \ appears in a number, while ignoring leading zeroes.", "  s = ''\n  while n !=\
    \ 0\n    s = (n.to_s(2) << 1 ) + s.to_s(2)\n    n /= 2\n  end\n  s\nend", "  result\
    \ = ''\n  bin = n.to_s(2)\n  while bin.length <= 4\n    bin = '0' * (4 - bin.length)\
    \ + bin\n  end\n  i = 0\n  while i < bin.length\n    if (bin[i] == '1')\n    \
    \  result = result + \"1\"\n    else\n      result = result + \"0\"\n    end\n\
    \    i = i + 1\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,algorithm,ruby-on-rails,ruby-on-rails-4,math\
    \ |>\n<| a |>\nA simple solution using recursion:\n<code>", "  result = \"\"\n\
    \  if n < 1\n    return \"0\"\n  while n > 0\n    digit = n % 10\n    digit =\
    \ digit.to_i\n    result += (\"1\" * digit)\n    n /= 10\n  end\n  result\nend",
  "    binary = \"\"\n    num = n\n    while num > 0\n        binary = num.to_s(2).rjust(8,\
    \ \"0\") + binary\n        num /= 10\n    return binary\nend", "    binary = n.to_s(2)\n\
    \    result = ''\n    (0...binary.length).each { |i| result += binary[i..-1] }\n\
    \    return result\nend", "  return n.to_s(2).scan(/.(..)/).inject(:+)\nend\n\
    </cell>\n<text>\nTesting the solver on examples\nIn the next cells we are going\
    \ to test our solver on some example inputs, so we can see if it returns the correct\
    \ solutions.", "    digits = n.to_s(2).split(//)\n    digits.each_index {|i| digits[i]\
    \ = digits[i].to_i(2).to_s(2)}\n    digits.reverse!\n    digits.join('')\nend",
  "  @n ||= 0\n  return n.to_s(2).reverse.\n    each_char.\n    map{|i| i.to_i(2)\
    \ * (\"0\".i + (i.to_s(2) != \"0\")))}.\n    join.\n    chars.\n    map {|c| c.to_i(2).to_s(2)}.\n\
    \    join\nend\n</cell>\n<code language=julia-1.5>\nsolve.call(1000)\n</cell>\n\
    <code language=julia-1.5>\nsolve.call(1030)\n</cell>\n<text>\nProblem 9: Determine\
    \ if a given string is a palindrome", "  # write your code here\n  s = n.to_s(2)\n\
    \  s.reverse!\n  n = 0\n  s.split(//).each_with_index do |l, i|\n    n += 1 if\
    \ l == '1'\n  end\n  s.reverse!\n  s = n.to_s(2)\n  s.reverse!\n  return s\nend",
  "\tsol = n.to_s(2)\n\twhile sol.length < 7\n\t\tsol = \"0\" + sol\n\tsol = sol[0..-3]\n\
    \tsol\nend", "  # initialize a list to store binary sum.\n  sum = []\n  # get\
    \ the remainder modulo 10, i.e. the place where the decimal resides.\n  rem =\
    \ n % 10\n  # get all the digits.\n  digits = n.to_s.split(//).map(&:to_i)\n \
    \ # add digit to sum\n  sum << digits.pop(0) unless digits.empty?\n  # loop over\
    \ remaining digits\n  digits.each do |d|\n    # get the remainder mod 10, i.e.\
    \ place where the decimal is located.\n    rem = rem % 10\n    # add digit to\
    \ sum\n    sum += digits.pop(0)\n    # add a zero to the end if there is no remainder\n\
    \    sum << 0 unless rem\n  end\n  # return the binary sum\n  return \"0#{sum.to_s(2).rjust(8,\
    \ \"0\")}\"\nend", "  case n <= 0\n  when true\n    '0'\n  when false\n    solve(n\
    \ / 2)\n  end\n  \n  return\nend", "    return n.to_s.reverse.gsub(/(.)\\1*$/,\
    \ '\\1' * n.to_s.length).reverse\nend", "  str = []\n  while n > 0\n    str =\
    \ str + [n % 2]\n    n = n / 2\n  end\n  str.reverse\n  str.join\nend", "  if\
    \ n == 0\n    return \"0\"\n  i = n.to_s(2).length\n  sum = \"1\"\n  while i >\
    \ 0\n    sum = sum * \"0\"\n    i -= 1\n    sum = (sum * \"1\" + n.to_s(2))[0...i]\n\
    \  end\n  return sum\nend\nputs solve.call(2147483647)\nputs solve.call(2147483648)\n\
    puts solve.call(2147483649)\nputs solve.call(2147483650)\nputs solve.call(2147483651)\n\
    puts solve.call(2147483652)\nputs solve.call(2147483653)\nputs solve.call(2147483654)\n\
    puts solve.call(2147483655)\nputs solve.call(2147483656)\nputs solve.call(2147483657)\n\
    puts solve.call(2147483658)\nputs solve.call(2147483659)\nputs solve.call(2147483660)\n\
    puts solve.call(2147483661)\nputs solve.call(2147483662)\nputs solve.call(2147483663)\n\
    puts solve.call(2147483664)\nputs solve.call(2147483665)\nputs solve.call(2147483666)\n\
    puts solve.call(2147483667)\nputs solve.call(2147483668)\nputs solve.call(2147483669)\n\
    puts solve.call(2147483670)\nputs solve.call(2147483671)\nputs solve.call(2147483672)\n\
    puts solve.call(2147483673)\nputs solve.call(2147483674)\nputs solve.call(2147483675)\n\
    puts solve.call(2147483676)\nputs solve.call(2147483677)\nputs solve.call(2147483678)\n\
    puts solve.call(2147483679)\nputs solve.call(2147483680)\nputs solve.call(2147483681)\n\
    puts solve.call(2147483682)\nputs solve.call(2147483683)\nputs solve.call(2147483684)\n\
    puts solve.call(2147483685)\nputs solve.call(2147483686)\nputs solve.call(2147483687)\n\
    puts solve.call(2147483688)\nputs solve.call(2147483689)\nputs solve.call(2147483690)\n\
    puts solve.call(2147483691)\nputs solve.call(2147483692)\nput", "  s = ''\n  while\
    \ n > 0\n    s, n = n.divmod(2)\n    s += '1'\n  end\n  return s\nend", "  return\
    \ n.to_s(2)\nend", "  return n.to_s(2).reverse.split(\"\").inject(\"\", :<<).reverse.join(\"\
    \").to_s(2)\nend", "  if n >= 1000000000 then\n    begin\n      s = '';\n    \
    \  for i in 1..n do\n        s << i;\n      end\n      result = 0;\n      for\
    \ i in s.chars.reverse do\n        result <<= 1;\n        result |= i;\n     \
    \ end\n    end\n    return result\n  end\n  result = ''\n  for i in 1..n do\n\
    \    result << i\n  end\n  result.reverse\nend", "  if n == 0\n    return 1\n\
    \  else\n    sum = nil\n    while n > 0\n      sum << (n & 1)\n      n >>= 1\n\
    \    end\n    sum.to_s\n  end\nend\n</code>\n<|/ a dscore=1 |>\n<| a |>\nHere\
    \ is my solution for Ruby 1.8.7:\n<code>", "    total = 0\n    while n > 0 do\n\
    \        total = total + n % 2\n        n = n / 2\n    end\n    return total\n\
    end\n</cell>\n<code language=julia-0.5>\n@time solve.(10^8)\n</cell>\n<text>\n\
    Problem 1", "    if n <= 1\n        return \"0\"\n    return \"#{solve(n/2)}#{solve(n/2)}\"\
    \ if n > 0\nend", "  return n.to_s(2).reverse.gsub(/(.).(?=(.))*/,'\\1').\n  \
    \          gsub(/(0*1?0*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10*",
  "  # Your code here\nend", "  digits = n.to_s.reverse.to_a\n  sum = 0\n  for i in\
    \ 0...digits.length\n    sum += digits[i].to_i\n    puts sum.to_s(2).to_i(2)\n\
    \  end\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=algorithm,ruby |>\nThis was\
    \ fun:\n<code>", "    s=[]\n    i=0\n    while n>0\n        while n>0 and i<8\n\
    \            s=(\"1\"+s).to_i(2)\n            i+=1\n            n=n//10\n    \
    \    s=(\"0\"+s).to_i(2)\n        i+=1\n        n=n%10\n    return s.to_s(2)\n\
    end", "  digit = n.to_s.split(//).map(&:to_i)\n  m = 1\n  result = \"\"\n  digits.each\
    \ do |digit|\n    result << (digit * m).to_s(2).rjust(digit.size, \"0\")\n   \
    \ m <<= 1\n  end\n  result\nend\n</code>\n<|/ a |>\n<| a tags=algorithm |>\nThis\
    \ question is inspired by LeetCode Problem #35. The solution I came up with is\
    \ just in Ruby, but the logic should be pretty much the same. My solution is pretty\
    \ much a variation of what Anton said, but with a few small differences. I am\
    \ not going to post the whole code, because I don't think it is necessary and\
    \ it is long.\nI took the code from here and added some methods to make it more\
    \ readable. And my code has some unused lines of code I removed because I didn't\
    \ get that from what Anton said.\n<code>", "  s = ''\n  while n > 0\n    s = n.to_s\
    \ + s\n    n, r = n.divmod(10)\n  end\n  s\nend", "    total = 0\n    (1..n).each\
    \ do |i|\n        num = n.to_s(2)\n        total += num.index(1) == 0 ? 1 : 0\n\
    \    end\n    num = (n.to_s(2)*(2..n)).gsub(/1/, '0')\n    return \"0#{num}\"\n\
    end", "  num = []\n  num = (n.to_s(2)).split('')\n  num.each_index do |i|\n  \
    \  if num[i] == '0'\n      num[i] = '1'\n    else\n      num[i] = '0'\n    end\n\
    \  end\n  num.join.to_i\nend", "  binary = \"\"\n  while n > 0\n    binary = n.to_s(2)\
    \ + \"0\" * (8 - n.to_s(2).length) + binary\n    n -= n % 10\n  end\n  return\
    \ binary\nend\n</cell>\n<code language=julia-1.2>\nsolve(100)\n</cell>\n<code\
    \ language=julia-1.2>", "  sum = \"\"\n  i = 0\n  while n > 0\n    sum += n.to_s(2).reverse.to_i(2)\n\
    \    i += 1\n    n /= 10\n  end\n  sum\nend\nprint(solve(1234))\nprint(solve(1236))\n\
    print(solve(1235))\nprint(solve(1212))\nprint(solve(1215))\nprint(solve(1214))\n\
    print(solve(1213))\nprint(solve(1213))\nprint(solve(1213))\nprint(solve(1213))\n\
    print(solve(1213))\nprint(solve(1213))\nprint(solve(1213))\nprint(solve(1213))\n\
    print(solve(1213))\nprint(solve(1213))\nprint(solve(1213))\nprint(solve(1213))\n\
    print(solve(1213))\nprint(solve(1213))\nprint(solve(1213))\nprint(solve(1213))\n\
    print(solve(1213))\nprint(solve(1213))\nprint(solve(1213))\nprint(solve(1213))\n\
    print(solve(1213))\nprint(solve(1213))\nprint(solve(1213))\nprint(solve(1213))\n\
    print(solve(1213))\nprint(solve(1213))\nprint(solve(1213))\nprint(solve(1213))\n\
    print(solve(1213))\nprint(solve(1213))\nprint(solve(1213))\nprint(solve(1213))\n\
    print(solve(1213))\nprint(solve(1213))\nprint(solve(1213))\nprint(solve(1213))\n\
    print(solve(1213))\nprint(solve(1213))\nprint(solve(1213))\nprint(solve(1213))\n\
    print(solve(1213))\nprint(solve(1213))\nprint(solve(1213))\nprint(solve(1213))\n\
    print(solve(1213))\nprint(solve(1213))\nprint(solve(1213))\nprint(solve(1213))\n\
    print(solve(1213))\nprint(solve(1213))\nprint(solve(1213))\nprint(solve(1213))\n\
    print(solve(1213))\nprint(solve(1213))\nprint(solve(1213))\nprint(solve(1213))\n\
    print(solve(1213))\nprint(solve(1213))\nprint(solve(1213))\nprint(solve(1213))\n\
    print(solve(1213))\nprint(solve(1213))\nprint(solve(1213))\nprint(solve(1213))\n\
    print(solve(1213))\nprint(solve(1213))\nprint(solve(1213))\nprint(solve(1213))\n\
    print(solve(1213))\nprint(solve(1213))\nprint(solve(1213))\nprint(solve(1213))\n\
    print(solve(1213))\nprint(solve(", "  return \"0\" * (n.to_s(2).length / 2 - n.to_s(2).reverse.length)\
    \ + n.to_s(2)\nend\n</cell>\n<text>\nQuestions", "  n = (n.to_s << '1').to_i\n\
    \  n1 = n.to_s.reverse.split(//).map(&:to_i).inject(0, :+)\n  puts n1.to_s(2).reverse.split(//).join('')\n\
    end", "  digits = n.to_s(2).split(//).map(&:to_i)\n  n = (0..digits.count-1).inject(0)\
    \ {|sum, pos| sum + (digits[pos] * (2**pos))}\n  nbin = n.to_s(2).split(//).join\n\
    \  return nbin\nend", "  n.to_s.reverse!\n  sum = \"\"\n  n.times do |i|\n   \
    \ sum << i\n  end\n  return sum\nend", "    binary = []\n    sum_1 = 0\n    sum_2\
    \ = 0", "  n = \"%010d\" % n\n  return n\nend", "    if n < 0\n        return\
    \ \"0\" + \"1\" * abs(n).to_s.length\n    n, x = 0, 1\n    while n <= n\n    \
    \    n, x = n ** 2 + n, x\n    return \"0\" * x + \"1\" + n\nend", "    s = \"\
    1\"\n    for i in 2..n\n        s = (s*(n.to_s(2).reverse)).to_i\n    end\n  \
    \  return s\nend\n</cell>\n<text>\nExercise 2\nThe sum of digits of the binary\
    \ representation of 7 is 3 + 2 + 7 + 3 = 22.\nThe sum of digits of the binary\
    \ representation of 8 is 3 + 2 + 8 + 3 = 27.\nThe sum of digits of the binary\
    \ representation of 9 is 3 + 2 + 9 + 3 = 22.\nFind the sum of digits of the binary\
    \ representation of 31 - 1.", "    string = \"\"\n    # Your code here\n    while\
    \ n > 0\n       string = string + \"0\"\n       n = n.modulo(10)\n    end", " \
    \   \n    return n\n    ", "  sum = 0\n  while n > 0\n    sum = 0\n    n.times\
    \ { sum += n % 2 }\n    n /= 2\n  end\n  return sum.to_s\nend", "  if n == 0 then\n\
    \    \"0\"\n  elsif n == 1 then\n    \"1\"\n  else\n    binary_sum = n.to_s(2).split('').map\
    \ {|i| i.to_i(2).to_s(2).split(//).reduce(:+)}.reverse.join\n    binary_sum.insert(0,\
    \ '0')\n    return binary_sum\n  end\nend", "  return \"\".tap do |res|\n    n.to_s.reverse.split(\"\
    \").each do |digit|\n      res << digit.to_s.rjust(2)\n    end\n  end\nend\n</code>\n\
    <|/ a tags=ruby,string |>\n<| a dscore=1 tags=ruby,string |>\n<code>\nrequire\
    \ 'pp'", "  raise \"not implemented yet\"\nend", "  return \"#{\"0\"*(n/2) + n.to_s(2).rjust(10,\"\
    0\").split(//).reverse.join.to_s(2)}\"\nend", "  if n <= 0\n    return \"0\"\n\
    \  while n > 0\n    str = (\"00000000\" + \"1\" * (n%2)).slice(-n%4)\n    str\
    \ = str.scan(/(.)(\\d)/).inject(\"$1+$2\",0)\n    str = \"0\" + str if str ==\
    \ \"0\" else str\n    n = (n-n%8)/8\n  end\n  return \"1\" * (n%8) + \"0\" * (8-n%8)\n\
    end\n</code>\n<|/ a tags=ruby,math,algorithm |>\n<| a dscore=0 |>\nHere is my\
    \ solution:\n<code>", "  return n.to_s(2).reverse.gsub(/(.)\\1*/, '\\1').to_i(2)\n\
    end", "  arr = n.to_s(2).reverse.chars\n  sum = nil\n  arr.each do |n|\n    sum\
    \ = (sum.to_i(2) + n.to_i(2)).to_s(2).reverse\n  end\n  return sum\nend", "  nstr\
    \ = \"\"\n  while n > 0\n    nstr = nstr + \"1\" + n%2\n    n = n/2\n  end\n \
    \ return nstr\nend", "    return n.to_s(2).to_i(2)\nend", "  result = \"\"\n \
    \ while n > 0\n    result += (n % 2).to_s\n    n /= 2\n  end\n  result\nend",
  "    return n.to_s.reverse.scan(/..?/).sum \nend\n</cell>\n<text>\nProblem 9: Counting\
    \ Palindromes\nThe numbers between 1 and N inclusive are written out in binary,\
    \ each preceded by the number of its digits in decimal. For example, with N=22,\
    \ the decimal number 22 is written out in binary, as: 101010. The sum of these\
    \ numbers is 23. Because N = 22 and therefore the decimal number 22 is two times\
    \ larger than the number 10, the sum must be 23. If we then add up all the numbers\
    \ between 2 and N, the result is the sum of all numbers between 2 and N which\
    \ are palindromic. For example, with N=22, the decimal number 23 is written out\
    \ in binary: 101101, which when added yields 2 + 3 + 10 = 14.", "  result = \"\
    \"\n  while n > 0 do\n    n -= 1\n    result += \"1\"\n  end\n  result = result.reverse\
    \ # reverse string for easier calculation\n  result = result.to_i # convert to\
    \ int\n  result *= 2 # multiply result by two\n  result -= 1 # subtract 1 for\
    \ 0\n  result = ( result.to_s # convert to string\n    .split(\"\") # split string\
    \ into individual characters\n    .map { |c| c.to_i(2) } # convert each character\
    \ to base 2\n    .sum ) # add all the digits together\n  return result\nend",
  "  return \"1\" if n == 0 \n  while n > 0\n    n = n / 2\n    return \"#{n % 2 ==\
    \ 0 ? \"01\" : \"10\"} #{solve (n / 2)}\"\n  end\nend", "    str = n.to_s(2)\n\
    \    sum = 0\n    i = 0\n    while i < str.length\n        sum += str[str.index(\"\
    1\", i)..-1].to_i(2)\n        i += 1\n    return sum.to_s(2)\nend", "  result\
    \ = ''\n  while n > 0\n    result, n = to_bin(n % 10, result), n//10\n  end\n\
    \  return result\nend", "  return n.to_s(2).reverse.gsub(/(..)(..)?/, '\\1').gsub(/..+/,\
    \ '0')\nend", "  # Your code here\nend\n</cell>\n<cell>", "  return n.to_s.reverse.gsub(/(.)\\\
    1*/,'').to_i\nend\n</code>\n<|/ a dscore=4 tags=ruby,binary,math |>\n<| a tags=ruby,binary,math\
    \ |>\nThe best way to solve this is to make a loop and use the modulo operator.\
    \ For example.\n<code>", "  s = n.to_s(2)\n  result = ''\n  n.times { result <<\
    \ (s.chars.to_a[*0...-1].to_i(2) << 1) << 1 }\n  return result\nend", "  binary\
    \ = n.to_s(2)\n  binary = binary.reverse\n  result = 0\n  for i in binary\n  \
    \  result <<= 1\n    result |= i - \"0\"\n    result %= 10\n  end\n  return result.to_s(2).reverse\n\
    end", "  if n <= 0\n    \"0\"\n  elsif n == 1\n    \"1\"\n  else\n    a = (n-1).to_s(2)\n\
    \    b = \"1\"\n    c = b.length\n    n.times do\n      b = b * \"0\"\n    end\n\
    \    a.concat(b[0, c-1])\n  end\nend", "  if n < 0\n    return puts(puts(\"n must\
    \ be positive\"))\n  elsif n < 10\n    return \"0\"\n  elsif n < 100\n    return\
    \ puts(puts(\"n is too small, must be >= 10\"))\n  elsif n % 10 == 0\n    return\
    \ puts(puts(\"n is already a binary number\"))\n  else\n    left = 0\n    right\
    \ = 0\n    while left < n do\n      left = right + 1\n      right = right + n\
    \ % 10\n      n /= 10\n    end\n    puts right.to_s\n  end\nend\nputs(\"The sum\
    \ of its digits in binary is \" + puts(solve))\n</code>\n<|/ a dscore=2 |>\n<|\
    \ c |>\nThanks for your suggestion! I modified my code accordingly, but I still\
    \ get \"undefined method `to_s' for nil:NilClass\". I'm not sure what the problem\
    \ is. Maybe it has to do with the fact that I'm trying to use Ruby in the console\
    \ via \"irb\" instead of \"ruby\".\n<|/ c |>\n<| c |>\n: Sorry, I did not actually\
    \ test the code above, but you were right in that you need to use `puts`. I'll\
    \ edit my answer.\n<|/ c |>\n<| c |>\nThanks! This was the exact answer I was\
    \ looking for. I appreciate it! :)\n<|/ c |>\n<| c |>\nAwesome! One more question\
    \ though: How do you use Ruby code within \"irb\"? I tried using \"require 'file'\"\
    \ and \"include File\", but that didn't seem to work.\n<|/ c |>\n<| c |>\n: You\
    \ can always just run the file from within `irb`. I edited my answer to include\
    \ an example.\n<|/ c |>\n<| a |>\nYou could use the Integer#to_s method as described\
    \ in Integer Docs:\n<code>\nputs n.to_s\n</code>\nAnd this will print it in binary\
    \ :D\n<|/ a tags=ruby,binary,sum,integer dscore=1 |>\n<| c |>\nThanks for the\
    \ suggestion! I modified my code accordingly, but I still get \"undefined method\
    \ `to_s' for nil:NilClass\". I'm not sure what the problem is. Maybe it has to\
    \ do with the fact that I'm trying to use Ruby in the console via \"irb\" instead\
    \ of \"ruby\".\n<|/ c |>\n<| c |>\nOhh yes.. just use `puts n` instead as `puts`\
    \ returns the result of the operation. I'll edit my answer\n<|/ c |>\n<| c |>\n\
    That makes a lot more sense. Thanks", "  if n == 0\n    \"0\"\n  elsif n <= 9\n\
    \    \"0\"\n  else\n    \"1\" + solve((n / 10) % 10) + solve((n / 100) % 10)\n\
    end\n</cell>\n<text>\n4.2 The sum of the squares of two consecutive odd positive\
    \ integers", "  result = \"\"\n  remainder = n\n  while remainder > 0\n    result\
    \ = remainder % 2 + result\n    remainder = remainder / 2\n  end\n  return result\n\
    end", "  n = n.to_i\n  return n.to_s(2).reverse.gsub('1', '').gsub(/(.)(.)/, '\\\
    1\\2').gsub(/(..)(..)/, '\\1\\2').gsub(/(...)(...)/, '\\1\\2').reverse\nend",
  "  binary_number = []\n  binary_number.push(n % 2)\n  n /= 2\n  until (n != 0)\n\
    \  binary_number.push(n % 2)\n  return binary_number.reverse.join.to_s.reverse\n\
    end", "  s = n.to_s.split(//).map {|x| x.to_i(2) }.reverse.join\n  s.chars.reverse\
    \ # reverse for readability\nend\n</cell>\n<cell>\nsolve.call(147)\n</cell>\n\
    <cell>", "  s = \"\"\n  while n > 0\n    s << (n % 2 == 0 ? \"1\" : \"0\")\n \
    \   n /= 2\n  end\n  return s.reverse\nend", "  sum = 0\n  while n > 0 do\n  \
    \  sum += n % 2\n    n /= 2\n  end\n  puts sum.to_s(2).reverse\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThis is better than the accepted answer because of the \"in\
    \ binary\" requirement (which can be very useful).\n<|/ c |>\n<| a dscore=1 |>\n\
    An approach using recursion:\n<code>", "    str = n.to_s(2).split(//)\n    str.inject{|sum,a|sum\
    \ + a.to_i(2) }\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for the help,\
    \ but I'm looking for an answer that uses recursion.\n<|/ c |>\n<| c |>\nRecursion\
    \ here is just an additional loop that adds one digit to the sum to achieve your\
    \ goal.  You could easily remove the loop and replace it with recursion and it\
    \ would produce the same answer.\n<|/ c |>\n<| c |>\nI know, I am just trying\
    \ to get a better understanding of how recursion works, I've never used it before.\n\
    <|/ c |>\n<| c |>\nI've provided a recursive version.  It's a great exercise to\
    \ learn recursion.\n<|/ c |>\n<| a |>\n<code>", "  binary_string = n.to_s.reverse.gsub(/(\\\
    d)(?=(.{8})\\2)/, '\\1' * '0') + '1'\n  binary_string.gsub!('11', '10')\n  binary_string.gsub!('00',\
    \ '01')\n  binary_string.gsub!('10', '11')\n  binary_string.gsub!('01', '00')\n\
    \  binary_string.gsub!('11111', '11111')\n  binary_string.gsub!('1111', '1100')\n\
    \  binary_string.gsub!('11111', '1101')\n  binary_string.gsub!('1111', '1100')\n\
    \  binary_string.gsub!('11111', '1011')\n  binary_string.gsub!('1111', '1010')\n\
    \  binary_string.gsub!('11111', '0111')\n  binary_string.gsub!('1111', '0101')\n\
    \  binary_string.gsub!('11111', '0011')\n  binary_string.gsub!('1111', '0010')\n\
    \  binary_string.gsub!('11111', '00011')\n  binary_string.gsub!('1111', '00001')\n\
    \  binary_string.gsub!('11111', '00000')\n  binary_string.gsub!('1111', '000000')\n\
    \  binary_string.gsub!('11111', '000000')\n  binary_string.gsub!('1111', '0000000')\n\
    \  binary_string.gsub!('11111', '0000000')\n  binary_string.gsub!('1111', '00000000')\n\
    \  binary_string.gsub!('11111', '00000000')\n  binary_string.gsub!('1111', '000000000')\n\
    \  binary_string.gsub!('11111', '000000000')\n  binary_string.gsub!('1111', '0000000000')\n\
    \  binary_string.gsub!('11111', '0000000000')\n  binary_string.gsub!('1111', '00000000000')\n\
    \  binary_string.gsub!('11111', '00000000000')\n  binary_string.gsub!('1111',\
    \ '000000000000')\n  binary_string.gsub!('11111', '000000000000')\n  binary_string.gsub!('1111',\
    \ '0000000000000')\n  binary_string.gsub!('11111', '0000000000000')\n  binary_string.gsub!('1111',\
    \ '00000000000000')\n  binary_string.gsub!('11111', '00000000000000')\n  binary_string.gsub!('1111',\
    \ '000000000000000')\n  binary_string.gsub!('11111', '000000000000000')\n  binary_string.gsub!('1111',\
    \ '0000000000000000')\n  binary_string.gsub!('11111', '0000000000000000')", " \
    \ binary = n.to_s.to_i.reverse\n  rev = binary.reverse\n  i = -1\n  result = ''\n\
    \  while (binary.length > 0)\n    result += (binary.pop(0) + (rev.shift(i)))\n\
    \    i += 1\n  puts result\nend\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| a |>\n\
    <code>", "  result = ''\n  while n > 0 do\n    result *= n\n    result %= 2\n\
    \    n /= 2\n  end\n  result\nend", "  res=''\n  while n>0\n    res+=n.to_s(2).rjust(8,'0')\n\
    \    n=n>>1\n  end\n  res\nend", "  return n.to_s.reverse.gsub(/(..)(..)/,'\\\
    1\\2').gsub(/(..)/,'\\1').tr(\"01\",\"11111111\").reverse\nend\n</cell>\n<text>\n\
    \U0001F451 Challenge: Write a function called find_digits that given a positive\
    \ integer N, returns the number of digits in N. For example, find_digits(100)\
    \ returns 3.", "  binary_str = n.to_s(2).chars.map { |b| b.to_i(2) }\n  binary_str.to_s.reverse.chars.map\
    \ { |c| c.to_i(2) }.join('')\nend", "  x = n.to_s\n  result = []\n  n = n.to_i\n\
    \  while n > 0\n    result += [\"0\"]*(n%2)\n    n /= 2\n  end\n  result.reverse.inject(x){|s,i|\
    \ s+i}\nend\nputs solve.call(1000)\n</code>\n<|/ a dscore=1 tags=ruby,string,binary\
    \ |>\n<| a dscore=1 tags=ruby,string,binary |>\nI thought I'd add my solution\
    \ in case it helps anyone in the future. This solution is written using recursion.\n\
    <code>", "  n.to_s(2).reverse.gsub!(/0?1?/, '').reverse.gsub!(/[01]/, '').to_i(2).to_s(2)\n\
    end", "  return n.to_s(2).reverse.gsub(/./, \"\").to_i(2).to_s(8)\nend", "  while\
    \ n > 0 do\n    puts \"#{n % 2}\"\n    n /= 2\n  end\nend", "  sum = (n.to_s(2).count(\"\
    1\"))\n  return sum.to_s\nend\n</cell>\n<code language=julia-1.5>", "  digits\
    \ = n.to_s.split(//).reverse\n  puts digits.map {|d| d.to_i(2) }.inject{|s,i|\
    \ s + i}\nend", "  binary_string = n.to_s(2).to_i(2).to_s(10)\n  sum = 0\n  for\
    \ i in binary_string\n    sum += i.to_i(2).to_s(10).to_i(10)\n  return sum.to_s(2)\n\
    end", "  binary = n.to_s(2)\n  sum = 0\n  n.to_s(2).each_char {|i| sum += i.to_i(2)\
    \ }\n  sum.to_s(2).each_char {|i| binary += i.to_s(2) }\n  return binary\nend",
  "  if n <= 0\n    return \"0\".to_s\n  ret = \"\"\n  digits = n.to_s.split(\"\"\
    ).map(&:to_i)\n  digits.each_with_index do |d, i|\n    digit = d % 10\n    ret\
    \ = digit == 0 ? ret : ret.insert(0, digit.to_s(2))\n  end\n  ret\nend\n</cell>\n\
    <text>\nExercise: Write a short program that can compute the sum of all binary\
    \ numbers with N digits.", "  return n.to_s(2).reverse.gsub(/(\\d*?\\d)(?=\\d)|(\\\
    d*?\\d)/, '\\1').to_s.reverse\nend", "    # Your code here\n    ret = n.to_s(2)\n\
    \    return ret[0,ret.length]\nend", "    ones = n.to_s(2).split('').map{|s| s\
    \ == '1' ? 1 : 0}\n    sum = 1\n    one.each do |one|\n        sum += one\n  \
    \  end\n    sum.to_s(2)\nend\n</code>\n<|/ a tags=ruby,algorithm |>\n<| c |>\n\
    Thanks, your method works well. I am looking for a way to do it without looping.\
    \ I have updated the problem to make it more clear. Thanks.\n<|/ c |>\n<| c |>\n\
    I didn't say I didn't want to loop. The goal is to avoid the loop. Thanks.\n<|/\
    \ c |>\n<| c |>\nI think you misunderstood me. I think he wants you to solve it\
    \ without looping but he wants you to solve it without using any variables. I\
    \ believe his solution is correct. I want to know how to solve it without using\
    \ any variables.\n<|/ c |>\n<| c |>\nIf this were a real problem, you'd be solving\
    \ the problem in less than 1ms using recursion.\n<|/ c |>\n<| c |>\nNo, it's not\
    \ real. I am just trying to understand how recursive works. Recursion is something\
    \ I am going to study soon. I understand how it works but I am not sure about\
    \ how it can be applied in my problem. Thanks.\n<|/ c |>\n<| a dscore=1 tags=ruby,algorithm\
    \ |>\nHere is a recursive solution:\n<code>", "  digits = n.to_s.split(//).map{|e|\
    \ e.to_i}\n  digits.reduce(:+)\nend\n</cell>\n<code language=julia-0.6>\nsolve()\n\
    </cell>\n<code language=julia-0.6>\nsolve(1000)\n</cell>\n<code language=julia-0.6>\n\
    solve(150)\n</cell>\n<code language=julia-0.6>\nsolve(147)\n</cell>\n<text>\n\
    12. How many numbers less than N that are divisible by 7?\nVariables:\n@N integer\n\
    Constraints: 0 \u2264 N \u2264 10000.\nOutput:\na positive integer less than 10000.\n\
    Examples\n>>> solve.call(1000)\n\"7\"\n>>> solve.call(150)\n\"5\"\n>>> solve.call(147)\n\
    \"4\"\nVariables:\n@N integer\nConstraints: 0 \u2264 N \u2264 10000.\nOutput:\n\
    a string of binary numbers\nExamples\n>>> solve.call(1000)\n\"11\"\n>>> solve.call(150)\n\
    \"0\"\n>>> solve.call(147)\n\"1\"\nVariables:\n@N integer\nConstraints: 0 \u2264\
    \ N \u2264 10000.\nOutput:\na string of binary numbers\nExamples\n>>> solve.call(1000)\n\
    \"1001\"\n>>> solve.call(150)\n\"1100\"\n>>> solve.call(147)\n\"1110\"", "\tstr\
    \ = \"\"\n\twhile n > 0 do\n\t\tif n % 2 == 0 then\n\t\t\tstr = str + (\"1\")\n\
    \t\telse\n\t\t\tstr = str + (\"0\")\n\t\tend\n\t\tn = n/2\n\tend\n\treturn str\n\
    end", "  if n < 0\n    return \"0\"\n  elsif n == 0\n    return \"0\"\n  end\n\
    \  digits = n.to_s.reverse.to_a\n  result = 0\n  while digits.length > 0\n   \
    \ result += (digits[0] % 2).to_i\n    digits << digits[1..-1].shift\n  end\n \
    \ return result.reverse.to_s\nend\n</code>\n<|/ a tags=ruby,algorithm |>\n<| c\
    \ |>\nThis code will go into an infinite loop when the number is an integer `0`.\
    \ Try with `solve(0)`.\n<|/ c |>\n<| a tags=ruby,algorithm dscore=1 |>\nIn Ruby,\
    \ you can convert the number to a binary string and sum up each digit:\n<code>",
  "  # Your code here.\nend", "    binary = \"\"\n    sum = 0\n    \n    while n !=\
    \ 0\n        sum += n % 2\n        n /= 2\n    \n    if sum == 0\n        return\
    \ \"0\"\n    \n    while(sum != 0)\n        binary += 0 if sum % 2 == 0 else 1\n\
    \        sum /= 2\n    \n    return binary\nend", "    sum = 0\n    digits = n.to_s.split(//)\n\
    \    digits.each do |digit|\n        sum += digit.to_i\n    end\n    sum.to_s(2).downcase\n\
    end\n</code>\n<|/ a dscore=4 tags=ruby,algorithm |>\n<| a dscore=3 tags=ruby,algorithm\
    \ |>\nThis solution is similar to that provided by (though it avoids splitting\
    \ or converting numbers to strings):\n<code>", "    digits = n.to_s.split('').reverse.map{\
    \ |s| s.to_i(2) }\n    digits.reverse.inject(:+).to_s(2).rjust(3,'0')\nend", " \
    \ # Your code here\n  return \"\"\nend", "  n.to_s(2).scan(/.(1).?\\1/){|c| c\
    \ * \"1\"}.join\nend", "  sum, mod = n.divmod(10)\n  return \"#{sum}#{solve(mod)}\"\
    \ if mod\n  return sum.to_s\nend", "  if n == 0\n    return \"0\"\n  if n / 2\
    \ == 0\n    return \"1\" + solve(n-2)\n  else\n    return \"1\" + solve(n-2) +\
    \ \"0\"\nend", "  # write your code in Ruby\n  res = []\n  n.times.to_a.each do\
    \ |i|\n    res << i.to_s(2)\n  end\n  res.join(\"\")\nend", "  if n == 0\n   \
    \ \"0\"\n  elsif n % 2 == 1\n    \"0\"\n  else\n    l = solve(n/2)\n    r = solve((n-l)/2)\n\
    \    l * 10 + r\n  end\nend", "  if n == 0\n    \"0\"\n  else\n    digits = n.to_s.split(\"\
    \")\n    sum = 0\n    digits.each_with_index do |d, i|\n      sum += (2**i) *\
    \ d\n    end\n    sum.to_s(2).to_i\n  end\nend\n</code>\nThe test cases\n<code>\n\
    describe '#call' do\n  it 'returns \"0\" for 0' do\n    expect(solve.call(0)).to.eq('0')\n\
    \  end", "  # write your code in Ruby\n  return \"\"\nend", "  string = \"\"\n\
    \  while(n>0)\n    string = \"0\" + string\n    n-=1\n  string.slice!(1)\n  \n\
    \  while string.length > 0\n    string = \"1\" + string\n  end\n  \n  return string\n\
    end\n</cell>\n<code language=julia-0.4>\nsolve(1000)\n</cell>\n<text>\nProblem\
    \ 2b", "  s = ''\n  for i in 0...n\n    s << i\n  end\n  s\nend", "  i = n.to_s(2)\n\
    \  sum = \"\"\n  i.each_char.with_index do |x, index|\n    if index == 0\n   \
    \   sum = x + \"1\"\n    else \n      sum = x + \"0\"\n    end\n  end\n  return\
    \ sum.to_s(2)\nend\n</cell>\n<cell>\nsolve.call(1000)\n</cell>\n<cell>\nsolve.call(150)\n\
    </cell>\n<cell>\nsolve.call(147)\n</cell>\n<text>\n\U0001F6E0 Exercises", "  return\
    \ n.to_s(2)\nend", "  if n == 0 then return '0'\n  s = solve(n / 2) + n % 2 *\
    \ '1'\n  return s\nend\nprint solve.call(-10)", "  binary_sum = 0\n  if n == 0\n\
    \    return \"0\"\n  while n > 0\n    binary_sum = (binary_sum.to_i * 2) + n.to_i\n\
    \    n = n.to_i / 2\n  end\n  return binary_sum.to_s(2)\nend", "  result = ''\n\
    \  while n > 0\n    result += n.to_s(2).rjust(2, '0')\n    n /= 2\n  end\n  result\n\
    end\n</cell>\n<cell>", "  num = \"00000000\"\n  i = 0\n  while i < n\n    i =\
    \ i + 1\n    num = num + num.slice(i)\n  end\n  puts num\nend", "  return n.to_s(2).reverse.gsub(/(.)..(.)/,\
    \ '\\1\\2').split('').map(&:reverse).reduce(:+)\nend", "  result = \"\"\n  (0..n).each\
    \ do |i|\n    if i == 0\n      result += \"1\"\n    else\n      result += (@number.to_s(2).reverse.to_i(2)).to_s(2)\n\
    \    end\n  end\n  return result\nend\nputs solve.call(1000)", "  n.to_s(2)\n\
    end", "  # write your code in Ruby\nend\n</code></pre>\n\t\t\t\t\t</div>\n\t\t\
    \t\t</section>\n\t\t\t\t<section>\n\t\t\t\t\t<h3>Python</h3>\n\t\t\t\t\t<div>\n\
    \t\t\t\t\t\t<pre><code data-trim class=\"python\">", "  if n.to_s.length == 0\
    \ then\n    return 0\n  elsif n.to_s.length == 2 then\n    digit0 = n.to_s.to_i(2).to_s(2)\n\
    \    digit1 = n.to_s.to_i(2).to_s(2)\n    if digit0.length != digit1.length then\n\
    \      return digit0 + digit1\n    else\n      return digit0 + digit1\n    end\n\
    \  elsif n.to_s.length == 4 then\n    digit0 = n.to_s.to_i(2).to_s(2)\n    digit1\
    \ = n.to_s.to_i(2).to_s(2)\n    digit2 = n.to_s.to_i(2).to_s(2)\n    digit3 =\
    \ n.to_s.to_i(2).to_s(2)\n    if digit0.length != digit1.length then\n      return\
    \ digit0 + digit1 + digit2 + digit3\n    else\n      return digit0 + digit1 +\
    \ digit2 + digit3\n    end\n  elsif n.to_s.length == 8 then\n    digit0 = n.to_s.to_i(2).to_s(2)\n\
    \    digit1 = n.to_s.to_i(2).to_s(2)\n    digit2 = n.to_s.to_i(2).to_s(2)\n  \
    \  digit3 = n.to_s.to_i(2).to_s(2)\n    digit4 = n.to_s.to_i(2).to_s(2)\n    digit5\
    \ = n.to_s.to_i(2).to_s(2)\n    digit6 = n.to_s.to_i(2).to_s(2)\n    digit7 =\
    \ n.to_s.to_i(2).to_s(2)\n    if digit0.length != digit1.length then\n      return\
    \ digit0 + digit1 + digit2 + digit3 + digit4 + digit5 + digit6 + digit7\n    else\n\
    \      return digit0 + digit1 + digit2 + digit3 + digit4 + digit5 + digit6 + digit7\n\
    \    end\n  else\n    digit0 = n.to_s.to_i(2).to_s(2)\n    digit1 = n.to_s.to_i(2).to_s(2)\n\
    \    digit2 = n.to_s.to_i(2).to_s(2)\n    digit3 = n.to_s.to_i(2).to_s(2)\n  \
    \  digit4 = n.to_s.to_i(2).to_s(2)\n    digit5 = n.to_s.to_i(2).to_s(2)\n    digit6\
    \ = n.to_s.to_i(2).to_s(2)\n    digit7 = n.to_s.to_i(2).to_s(2)\n    digit8 =\
    \ n.to_s.to_i(2).to_s(2)\n    if digit0.length != digit1.length then\n      return\
    \ digit0 + digit1 + digit2 + digit3 + digit4 + digit5 + digit6 + digit7 + digit8\n\
    \    else\n      return digit0 + digit1 + digit2 + digit3 + digit4 + digit5 +\
    \ digit6 + digit7 + ", "  # Your code goes here\n  return \"0\"*(10**(n%10))+\"\
    1\"*(n%10)\nend", "  res = 0.to_s(2)\n  n.to_s(2).reverse.gsub(/(.)(.)\\2+/\\\
    1,$1) do |x|\n    if x.start_with?(\"1\")\n      res += x\n    end\n  end\n  return\
    \ res\nend", "    \n    total = 0\n    while n > 0\n        total = (total + n\
    \ % 2) + n / 2\n        n = n / 2\n    end\n    return \"#{total}\".to_i\nend",
  "  res = []\n  while n > 0\n    n, r = n.divmod(2)\n    res.unshift(r)\n  end\n\
    \  res.reverse.join\nend", "  s = bin(n)\n  s.upcase!\n  s\nend", "  digit = n.to_s(2).reverse\n\
    \  sum = 0\n  while digit.length > 0\n    sum += digit.pop\n  end\n  return sum.to_s\n\
    end\n</code>\n<|/ a dscore=0 tags=ruby,algorithm,math |>\n<| c |>\nIt gives me\
    \ an error that says: in `to_s': undefined method `[]' for nil:NilClass (NoMethodError).\n\
    <|/ c |>\n<| c |>\nIt was a typo which I've now fixed.\n<|/ c |>\n<| a dscore=0\
    \ tags=ruby,algorithm,math |>\nHere's a solution in Python:\n<code>", "\tresult\
    \ = ''\n\twhile n\n\t\tresult = n.to_s(2).reverse.chars.inject('') { |memo, digit|\
    \ memo += (digit.to_s(2).reverse).chars.reverse.inject(:+) }\n\t\tn -= 1\n\tputs\
    \ result\nend", "    s = \"0\"\n    while n > 0\n        s << (n % 2)\n      \
    \  n /= 2\n    return s\nend", "  return '#' + ('0' * (n - '#'.length) + n.to_s(2)).gsub(/(#*)0*/,'').to_i(2)\n\
    end\n</cell>\n<code language=julia-1.5>", "\tn.to_s(2).length.to_i(2)\nend", " \
    \ s = \"0\"\n  if n > 0\n    while n > 0\n      s = s + \"1\"\n      n -= 1\n\
    \    end\n  end\n  return s\nend", "  return \"0\" if n < 0\n  return n.to_s(2).reverse.scan(/../).map(&:join).reverse.join.to_i\n\
    end", "  # Write your code here\n  res=''\n  n.to_s.split(//).each {|i| res+=i.to_s(2).rjust(4,'0').to_s}\n\
    \  res\nend", "  digits = n.to_s.split(//).map(&:to_i)\n  result = \"\"\n  digits\
    \ = digits[0...-1].map { |n|\n    puts \"#{n}?\"\n    (n = readline.chomp).to_i\n\
    \    puts \"#{n}!\"\n  }.sum\n  while result != \"0\" && digits.length != 0\n\
    \    puts \"#{digits.reverse.join.chr}\"\n    digits = digits.map { |n| n.to_s\
    \ == \"0\" ? 0 : (n.to_i + 1)}\n    result = digits[0...-1].map { |n| \n     \
    \ (n = readline.chomp).to_i\n      puts \"#{n}!\"\n    }.sum\n  end\n  digits.reverse.map\
    \ { |n| n.to_s == \"0\" ? 0 : (n.to_i + 1)}.reverse.join\nend\n</code>\nOutput:\n\
    <code>\n$ ruby sol.rb \n1\n110\n1100", "  @N=n\n  nstr=\"#{n.to_s(2).reverse}\"\
    \n  nstr.gsub!(/0+/,'')\n  ret=\"#{nstr}\"\n  ret=ret.chars.to_a.reverse.join\n\
    \  ret=ret.gsub!(/0*/,'')\n  ret=ret.chars.to_a.reverse.join\n  return ret\nend",
  "  return n.to_s.split(//).sum\nend", "  s = n.to_s.reverse.gsub(/(?<=\\d)(?=[^1]*\\\
    d)/, '0')\n  s.reverse.gsub(/0/, '1').to_s\nend\n</code>\n<|/ a tags=math,binary,ruby,algorithm\
    \ |>\n<| c |>\nThis algorithm is much faster than the above mentioned one.\n<|/\
    \ c |>\n<| a tags=math,binary,ruby,algorithm dscore=1 |>\nI used following algorithm\
    \ in ruby\n<code>", "  if n<0\n    return \"0\"\n  else\n    return solve.call(n/2)\
    \ + solve(n%2)\nend\n</code>\n<|/ a |>\n<| c |>\nYou missed the point of the question:\
    \ OP wants a recursive solution.\n<|/ c |>\n<| c |>\nThe question was about recursion.\
    \ My answer provides a recursive solution. The question is about recursion and\
    \ recursion is a very common programming problem.\n<|/ c |>\n<| c |>\nRecursion\
    \ is very common and has become a very powerful tool in computing.\n<|/ c |>\n\
    <| c |>\nYou say it isn't common or useful and that's true, but that's no reason\
    \ to not give a correct answer. Your answer doesn't work (it crashes) and it's\
    \ incorrect, so why not give an answer that does?\n<|/ c |>\n<| c |>\nIt's a recursive\
    \ solution, just written differently. I also have pointed out that recursion is\
    \ very common.\n<|/ c |>\n<| a |>\nYou can do it like this:\n<code>", "  n.to_s.reverse.chars.map(&:to_i).reduce(:+)\n\
    end", "  if n <= 0\n    return \"0\"\n  sum = 0\n  res = []\n  while n > 0\n \
    \   sum += n % 2\n    res.unshift(sum)\n    n /= 2\n  return res.reverse.join.to_s\n\
    end\n</code>\n<|/ a dscore=1 tags=ruby,ruby-on-rails,ruby-on-rails-4 |>\n<| a\
    \ dscore=1 |>\nThis solution will work with any size of number:\n<code>", "  n.to_s(2)\n\
    end", "  if n<=0\n    return \"0\"\n  binary=Array.new(n,\"\")\n  sum=n\n  for\
    \ i in 0..(n-1)\n    digit=sum%2\n    sum/=2\n    binary[i]=digit\n  end\n  binary[n.to_s.length..-1]\n\
    end", "  case n <= 100\n    n=n.to_s\n  end\n  result = []\n  while n > 0\n  \
    \  result << (n % 2).to_s\n    n /= 2\n  end\n  result.join('')\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails dscore=0 |>\n<| a dscore=0 tags=ruby,ruby-on-rails\
    \ |>\nMy solution in Ruby:\n<code>", "  sum = 0\n  i = 1\n  while i <= n\n   \
    \ sum = sum + i\n    i = i * 2\n  end\n  return sum.to_s\nend", "  # Your code\
    \ here\n  return n\nend", "  raise ArgumentError, \"Only integers less than or\
    \ equal to 10000 are allowed.\" if n < 0 || n > 10000\n  res = \"0\"\n  while\
    \ n > 0\n    n, digit = n.divmod(10)\n    res = (\"1\" * digit) + res\n  end\n\
    \  res\nend", "  digits = n.to_s.split('').map {|digit| digit == '1' ? 1 : 0}\n\
    \  sum = 0\n  digits.each do |digit|\n    sum += digit\n  end\n  sum.to_s(2)\n\
    end", "    return n.to_s(2).count(\"1\") + n.to_s(2).count(\"0\") + n.to_s(2).count(\"\
    10\")\nend\n</code>\n<|/ a dscore=2 tags=math,ruby |>\n<| a |>\nSolution using\
    \ recursion.\n<code>", "    # write your code in Ruby here\n    return \"0\"\n\
    end\n</code>\n<|/ a tags=python,puzzle,algorithm |>\n<| a |>\nThe above solutions\
    \ did not work for me, so I thought I would share my solution in Python:\n<code>",
  "  sum = String.new\n  while(n > 0)\n    sum += ((n % 2 == 0) ? \"1\" : \"0\")\n\
    \    n /= 2\n  end\n  return sum\nend", "  return if n < 0\n  digits = n % 2.to_s\n\
    \  n.to_s.reverse.chars.map { |c| digits[c.to_i] }.join if digits\nend\n</code>\n\
    <|/ a dscore=3 tags=ruby,algorithm,recursion,string |>\n<| c |>\nI think this\
    \ answer should be the accepted answer, as it demonstrates the correct way (I\
    \ think) to solve the problem.\n<|/ c |>\n<| a tags=ruby,algorithm,recursion,string\
    \ |>\n<code>", "  return n.to_s(2).reverse.gsub(/(..)..(..)/, '\\1\\2').gsub(/(..)../,\
    \ '\\1').reverse\nend", "  res = []\n  for i in 0..(n/2).to_s.length\n    res\
    \ << n.to_s.chars.first.to_i(2) + (n.to_s.chars.last.to_i(2) * (n%2))\n  end\n\
    \  res[0..-1].join.to_s + res[-1..-1].join\nend", "  if n == 0\n    return \"\
    0\"\n  sum = 0\n  for i in (0..n-1)\n    sum = sum * 2 + digit(n[i])\n  end\n\
    \  sum.to_s\nend", "  sum = 0\n  n.times { sum += n % 2 ? 1 : 0 }\n  result =\
    \ ''\n  n.times { result += '1' if sum >= 10 && sum <= 100 ? '1' : result += '0'\
    \ }\n  puts result\nend", "  n.to_s(2).scan(/../).join(\"\")\nend", "  if n.zero?\n\
    \    puts '0'\n    return\n  end", "  result = \"\"\n  while n > 0\n    result\
    \ += n.to_s(2)\n    n = n.to_i(2)\n  end\n  result\nend", "  if n==0\n    return\
    \ '0'\n  s = \"\"\n  while n > 0\n    if n&1 != 0\n      s += '1'\n      n -=\
    \ 1\n    else\n      s += '0'\n      n -= 2\n  return s\nend\n</cell>\n<text>\n\
    Problem 1", "  result = ''\n  while n > 0\n    result << (n % 2)\n    n /= 2\n\
    \  end\n  return result\nend\n</cell>\n<code language=julia-1.3>\nsolve(2000)\n\
    </cell>\n<code language=julia-1.3>\nsolve(2000)\n</cell>\n<code language=julia-1.3>",
  "  n = n.to_s\n  sum = n.to_s.length\n  if sum < 2 then return \"0\"\n  sum -= 2\n\
    \  i = sum / 2\n  while i > 0\n    i = i / 2\n    sum = sum - i\n  end\n  return\
    \ \"1\" * sum\nend", "  if n == 0\n    '0'\n  else\n    n.to_s.reverse.to_i(2).to_s(2).reverse\n\
    end", "  sum, binary = n.divmod(2)\n  return binary + sum.to_s(2).rjust(N, \"\
    0\")\nend", "  total = 0\n  while n > 0\n    total, n = total * 10 + n % 10, n\
    \ / 10\n  puts \"#{total}\"\nend", "  nstr = n.to_s\n  nstr = nstr.reverse\n \
    \ result = \"\"\n  \n  while n > 0\n    if n % 2 == 0\n      result += nstr[0]\n\
    \      n /= 2\n    else\n      result += nstr[1]\n      n /= 2\n    end\n  end\n\
    \  \n  puts result\nend", "  result = '1' * n\n  while n > 0\n    result += (n\
    \ % 2 != 0) ? '0' : '1'\n    n = n / 2\n  end\n  result\nend\n</cell>\n<cell>",
  "  return n.to_s(2).scan(/../).join #the to_s convert the number to string, then\
    \ scan is used to obtain an array of its digits by dividing by its base\nend",
  "  s = ''\n  if n == 0\n    puts \"0\"\n  else\n    digits_size = n.to_s.length\n\
    \    (digits_size - 1).times do\n      digit = n.to_s.rjust(digits_size, '0')\n\
    \      n = n - digit.to_i\n      s = digit + s\n      puts s\n    end\n  end\n\
    end", "  # Your code here\n  return \"0\"\nend", "  return n.to_s.split('').reverse.map\
    \ {|i| i.to_i(2).to_s(2)}.join('')\nend", "  return n.to_s(2).split(\"\").reverse.map{|x|\
    \ x.to_i(2).to_s(2)}.join # String\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
