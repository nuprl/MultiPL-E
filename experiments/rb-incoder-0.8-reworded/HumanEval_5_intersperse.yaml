name: HumanEval_5_intersperse
language: rb
prompt: "# Insert a number 'delimeter' between every two consecutive elements of input\
  \ array `numbers'\n# >>> intersperse.call([], 4)\n# []\n# >>> intersperse.call([1,\
  \ 2, 3], 4)\n# [1, 4, 2, 4, 3]\ndef intersperse(numbers, delimeter)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_intersperse\n\
  \    candidate = method(:intersperse)\n    assert_equal([], candidate.call([], 7))\n\
  \    assert_equal([5, 8, 6, 8, 3, 8, 2], candidate.call([5, 6, 3, 2], 8))\n    assert_equal([2,\
  \ 2, 2, 2, 2], candidate.call([2, 2, 2], 2))\n  end\nend\n"
completions: ["  numbers.each_with_index do |number, index|\n    if index == 0 ||\
    \ index == numbers.length - 1\n      [number]\n    elsif index > 0 && index <\
    \ numbers.length - 1\n      [numbers[index - 1], number, numbers[index + 1]]\n\
    \    else\n      [number, numbers[index]]\n    end\n  end\nend", "  return numbers.inject([],\
    \ :<<).with_index { |result, pos, index| index == 0 ?\n    result << delimeter\
    \ : result << numbers[pos - 1] }\nend", "\tnumbers = Array.from(numbers)\n\tdelimeter\
    \ = to_str(delimeter)\n\tdelimeter = \"#{delimeter}#{delimeter}#{delimeter}\"\
    \ unless delimeter == \" \"\n\tnumbers.map! { |x| x.to_s }\n\tnumbers.each_with_index\
    \ do |num, i|\n\t\tnum.insert(1, delimeter)\n\t\tnum.insert(i + 2, delimeter)\
    \ if i != numbers.length - 1\n\tend\n\tnumbers.map(&:to_i)\nend", "    numbers\
    \ = [numbers] unless numbers.is_a?(Array)\n    delimeter = delimeter, nil if delimeter\
    \ >= 0\n    delimeter = delimeter, delimeter.length if delimeter >= 0\n    delimeter\
    \ = delimeter, numbers.length if delimeter >= 0\n    \n    numbers.each_with_index\
    \ do |number, i|\n        if i > 0 && number == delimeter[i - 1]\n           \
    \ numbers[i - 1] + delimeter + numbers[i + 1]\n        else\n            number\n\
    \        end\n    end\nend", "  numbers = numbers[0..-2].map{ |i| [delimeter,\
    \ i, delimeter] }.flatten\n  numbers[-1] += delimeter\n  numbers\nend", "  if\
    \ numbers.nil? or numbers.empty?\n    numbers\n  else\n    numbers.inject([])\
    \ {|array, number| array << (number + delimeter) }\n  end\nend", "  numbers.inject([])\
    \ { |array, number| array << number << delimeter << number }\nend", "  return\
    \ numbers.zip(delimeter).map { |a,b| a+b }\nend", "  return [*numbers, *numbers.map(&:__send__(:+,\
    \ delimeter))]\nend", "  numbers = (numbers + delimeter).split(delimeter)\n  return\
    \ numbers.inject do |interspersed_numbers, number|\n    interspersed_numbers.push(number)\n\
    \    interspersed_numbers.join(\",\")\n  end\nend", "  numbers.each_cons(2).with_index\
    \ do |(numbers, index), i|\n    numbers[index] += delimeter + numbers[i + 1]\n\
    \  end\nend\n</pre>\n            </div>\n          </li>", '  interspersed = Array.new',
  "  numbers, delimeter, = numbers, delimeter\n  return nil if numbers.nil? || numbers.empty?\n\
    \  numbers, delimeter, = numbers[0], delimeter\n  numbers, delimeter = numbers,\
    \ delimeter\n  result = []\n  numbers.each_with_index do |element, index|\n  \
    \  result << element\n    result << delimeter[index + 1] if index < (numbers.length\
    \ - 1)\n  end\n  result.join(\"\")\nend", "  numbers = [numbers] unless numbers.is_a?(Array)\n\
    \  return numbers.inject([]) { |arr,n| arr.unshift(n); arr.insert(arr.length-1,\
    \ delimeter) }\nend", "  numbers, delimeter, = numbers, delimeter\n  if numbers.empty?\n\
    \    numbers\n  else\n    delimeted = []\n    numbers.each_with_index do |n, i|\n\
    \      delimeted << n if delimeted.empty? || delimeted[-2] == delimeter\n    \
    \  delimeted.push(n)\n    end\n    delimeted.reverse!\n    delimeted\n  end\n\
    end", "  return [delimeter.join(numbers[i:i + 2]) for i in range(numbers.length\
    \ - 1)]\nend", "  numbers[0], numbers[1..-1].step(delimeter) do |number|\n   \
    \ numbers.insert(0, number)\n  end\nend", "  numbers.each_cons(2).with_index do\
    \ |number, index|\n    numbers.insert(index, delimeter)\n  end\nend", "  return\
    \ [numbers[0], delimeter.join(numbers.slice(1, numbers.size + 1))]\nend", "  numbers.each_with_index\
    \ do |num, i|\n    numbers[(i+1)..-1].push(num)\n  end", "  output = []\n  numbers.each\
    \ do |i|\n    output << i << delimeter\n  end\n  output\nend", "  # Only works\
    \ for arrays\n  return numbers.dup.tap{|numbers|\n    numbers[0, numbers.size-1].zip(numbers[1,\
    \ numbers.size-1]).map do |first, last|\n      first + delimeter + last\n    end\n\
    \  }\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI like your first example and\
    \ I do like the `intersperse!` example at the end. Thank you.\n<|/ c |>\n<| c\
    \ |>\nThank you.  I like the `intersperse!` one as well.  I've added a more robust\
    \ `intersperse` example in my answer, just in case someone else has come up with\
    \ something more interesting.\n<|/ c |>\n<| c |>\nIt should be noted that `intersperse!`\
    \ returns the array `numbers` rather than the modified version (since it's mutating).\
    \ This means that in Ruby 2.2 you'll need to use [`Array#map!`](http://www.ruby-doc.org/core-2.1.1/Array.html#method-i-map-21)\
    \ to return the array.\n<|/ c |>\n<| c |>\nGood point; I've added a `intersperse!`\
    \ that returns the array with the changes made.\n<|/ c |>\n<| a tags=arrays,ruby\
    \ dscore=5 |>\nRuby 2.0:\n<code>", "  numbers.inject([]) do |output, value|\n\
    \    output << value\n    output << delimeter\n    output << value\n  end\nend",
  "  interspersed = []\n  numbers.each_with_index do |number, index|\n    interspersed\
    \ << number if index % 2 == 0\n    interspersed << delimeter if index % 2 == 1\n\
    \  end\n  interspersed\nend\n</code>\nAs you can see, it's more concise and cleaner.\
    \ Hope it helps ;)\n<|/ a |>\n<| c |>\nIn case anyone is interested, here is another\
    \ implementation of `intersperse`: `intersperse = (1..Float::INFINITY).step(2).map\
    \ { |i| [i..Float::INFINITY] }.flatten`\n<|/ c |>\n<| c |>\nThat won't work as\
    \ `Float::INFINITY` does not have a `step` method. `(1..Float::INFINITY).step(2).map\
    \ { |i| [i..Float::INFINITY] }` gives a `TypeError: wrong argument type Symbol\
    \ (expected Proc)`.\n<|/ c |>\n<| c |>\nYes, of course! That is my mistake! It\
    \ should have been `(1..Float::INFINITY).step(2).map { |i| [i..Float::INFINITY]\
    \ }.flatten`\n<|/ c |>\n<| a dscore=1 tags=ruby |>\n<code>\nirb(main):014:0> def\
    \ intersperse(array, sep)\nirb(main):015:1> array = []\nirb(main):016:1> array.zip(sep).map(&:first).join(sep)\n\
    irb(main):017:1> end\n=> nil\nirb(main):018:0> intersperse [1,2,3], 4\n=> \"1234\"\
    \nirb(main):019:0> intersperse [1,2,3], \"&\"\n=> \"1&2&3&\"\n</code>\n<|/ a |>\n\
    <| a |>\nUsing inject\n<code>\n[1,2,3,4].inject([]) { |memo, i| memo.empty? ?\
    \ [4,i] : [4,memo,i].join('') }\n=> [\"1234\"]\n</code>\n<|/ a dscore=1 tags=ruby\
    \ |>\n<| a dscore=1 |>\nYou can do that easily with inject, just by passing 2\
    \ variables to it:", "  return numbers.each_cons(2).map(&:first).inject([]) {\
    \ |l, a| l << (a << delimeter); l.reverse}.reverse\nend", "  numbers = Array(numbers)\n\
    \  delimeter = to_i(delimeter)\n  result = numbers.dup.concat(numbers.first.to_a)\n\
    \  numbers.each do |number|\n    result.push(*(number + [delimeter]))\n  end\n\
    \  result\nend", "  return numbers.each_cons(2).map(&:first).inject(:+, delimeter)\n\
    end", "  if numbers.empty?\n    numbers\n  else\n    numbers.map { |n| n.send(delimeter)\
    \ }.first\n  end\nend", "  numbers.each_with_index.map {|number, index| delimeter.nil?\
    \ ? number : delimeter << number << numbers[index + 1]}.compact\nend", "  delims\
    \ = Array.new\n  delim += delimeter\n  delims << delimeter\n  numbers(0..(numbers.length-1))\
    \ do |i|\n    numbers[i] += 1\n    delim += delimeter\n    delims << delimeter\n\
    \  end\n  delims.first(delims.length).join(delimeter)\nend", "  result = numbers.dup\n\
    \  numbers.reverse_each.with_index do |number, i|\n    result.insert(i, delimeter)\n\
    \    result << number\n    result.delete_at(i - 1)\n  end\n  result\nend", " \
    \ numbers.each_with_index do |number, index|\n    numbers[index-1] = number\n\
    \    numbers[index] = delimeter\n  end\n  numbers\nend\n</pre>", "  return concat(intersperse(numbers.reverse,\
    \ delimeter).reverse, numbers)\nend", "  numbers.inject([-1]) do |res, value|\n\
    \    res[-1] == -1 ? [value] + res : [value, delimeter] + res\n  end\nend\n</code></pre>\n\
    \t\t\t\t</section>\n\t\t\t\t<section data-markdown>\n\t\t\t\t\t## Exercises\n\t\
    \t\t\t</section>\n\t\t\t\t<section data-markdown>\n\t\t\t\t\t### Q1. Write a method\
    \ `interleave` which takes an array of strings as input (e.g., `[\"one\", \"two\"\
    , \"three\"]`) and returns a new array of strings (e.g., `[\"one\", \"two\", \"\
    three\"]`).", "  if numbers.length > 0\n    numbers.inject([]) do |output, num|\n\
    \      if num.nil?\n        output << num\n      else\n        output << (delimeter\
    \ || \", \") << num\n      end\n    end\n  else\n    []\n  end\nend", "  result\
    \ = []\n  numbers.each_with_index do |number, index|\n    result << (index ==\
    \ 0 || delimeter) ? number : delimeter + number\n  end\n  result\nend", "  result\
    \ = []\n  number.times do |i|\n    result << numbers[i - 1]\n    result << delimeter\n\
    \    result << numbers[i]\n  end\n  result\nend", "  numbers.inject([], :<<)\n\
    end", "  new_numbers = numbers.dup\n  new_numbers.each_with_index do |number,\
    \ i|\n    new_numbers[i+1] = number if new_numbers[i]\n    new_numbers[i+1] =\
    \ delimeter + number if new_numbers[i+1]\n  end\n  new_numbers.compact\nend",
  "  numbers.each_cons(2) do |number|\n    number << delimeter\n  end\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThe first solution is O(N) but slower.\n<|/ c |>\n\
    <| c |>\nThanks for mentioning that! I added an explanation about that.\n<|/ c\
    \ |>\n<| a |>\nYou can use inject for this:\n<code>\narr = [1,2,3]\narr.inject([nil])\
    \ do |a, e|\n  a << e << a.pop\nend", "  numbers.each_with_index do |number, i|\n\
    \    numbers.insert(i, delimeter + number)\n  end\n  numbers\nend\n</code>\n<|/\
    \ a tags=ruby,arrays |>\n<| c |>\nIt should be noted that `each_slice` returns\
    \ an `Enumerator`, not a `Array`, so you would need to `to_a` to get an `Array`.\n\
    <|/ c |>\n<| c |>\nThis is an incredible solution. I didn't even think about that\
    \ one. Thanks!\n<|/ c |>\n<| a tags=ruby,arrays dscore=3 |>\nHere is an approach\
    \ that uses recursion.\n<code>", "    numbers.inject([delimeter]) do |interspersed,\
    \ number|\n        interspersed << number\n        interspersed\n    end\nend",
  "  numbers.each_with_index do |number, i|\n    numbers.slice!(0, i).concat(delimeter).concat(number)\
    \ if i > 0 && i <= numbers.length\n  end\nend", "  if numbers.nil?\n    numbers\n\
    \  elsif numbers.is_a?(Array)\n    intersperse(numbers, delimeter).join(delimeter)\n\
    \  else\n    delimeter_pos = numbers.index(delimeter)\n    numbers[0...delimeter_pos\
    \ + 1] + delimeter + numbers[delimeter_pos + 1...-1]\n  end\nend\n</code>\n<|/\
    \ a dscore=5 |>\n<| a dscore=3 |>\n<code>", "  result = numbers.dup\n  numbers[0,\
    \ 0] = delimeter unless numbers.empty?\n  numbers.each_with_index do |number,\
    \ i|\n    result, i = result.insert(i, number), i\n  end\n  result\nend", "  numbers\n\
    \  numbers.length.times.collect {|i| delimeter.call(numbers, i)}\nend", "  numbers\
    \ = numbers.dup\n  numbers.each_with_index do |number, i|\n    next if i == 0\n\
    \    yield delimeter\n    yield number\n  end\nend", "  intersperse_args = Array.new(numbers.length,\
    \ delimeter)\n  Array.each numbers, &:replace(*intersperse_args)\nend", "  numbers.inject([])\
    \ { |inter, num|\n    inter.concat(num).concat(delimeter) if inter.length != 0\n\
    \    inter }\nend", "  numbers.map { |number| [number, number].join(delimeter)\
    \ }\nend", "    numbers = numbers.to_a\n    res = []\n    numbers.each_with_index\
    \ do |e, i|\n        if i % 2 == 0\n            res << e\n        else\n     \
    \       res << delimeter + e\n        end\n    end\n    res.to_a\nend\n</code>\n\
    <|/ a |>\n<| c |>\n`numbers` is an array though\n<|/ c |>\n<| c |>\nNo it's not.\
    \  Intersperse with an empty array returns the empty array.  Just because Ruby\
    \ can do it, does not make it right.  And I didn't claim that it was.\n<|/ c |>\n\
    <| a dscore=5 |>\n<code>", "  intersperse_(numbers, delimeter, \"\")\nend", " \
    \ result = []\n  numbers.each_with_index { |e, i|\n    if i > 0\n      result[-2]\
    \ += delimeter + e\n    else\n      result << e\n    end\n  }\n  result\nend",
  "  result = numbers.dup.clone\n  number_count = numbers.length - 1 if numbers.is_a?(Array)\
    \ then numbers.size else numbers.length\n  (1..number_count).each do |i|\n   \
    \ result.insert(i, delimeter)\n  end\n  result\nend", "  if numbers == [] or numbers.size\
    \ == 0\n    []\n  else\n    numbers[0, delimeter...-1] + numbers[1, delimeter..-1]\
    \ + numbers[2, delimeter..-1] + numbers[3, delimeter..-1]\n  end\nend", "  return\
    \ numbers.each_with_index.map {|n| delimeter.call(n, n + 1)}.flatten(1)\nend",
  "  if numbers.nil?\n    nil\n  else\n    numbers_length = numbers.length\n    numbers_length.times\
    \ { |i|\n      numbers.insert(i, delimeter)\n    }\n    numbers_length\n  end\n\
    end", "  numbers.inject([]) do |interspersed_numbers, number|\n    interspersed_numbers\
    \ << number\n    interspersed_numbers[interspersed_numbers.length - 2] << delimeter\n\
    \    interspersed_numbers\n  end\nend", "  result = Array.new(numbers.size)\n\
    \  i = 0\n  while i < numbers.size - 1\n    result[i] = numbers[i]\n    i += 1\n\
    \    result.concat numbers[i..numbers.size - 1]\n    i = 0\n  end\n  result[i]\
    \ = numbers[i]\n  result\nend", "\tnumbers = Array.wrap(numbers)\n\treturn []\
    \ if numbers.empty? then nil else numbers[0...numbers.size / 2] + (delimeter +\
    \ numbers[numbers.size / 2..-1]).join(\"\")\nend", "  return numbers.reduce(lambda\
    \ result, number: result + delimeter + number, \"\")\nend", "  return [] if numbers.nil?\
    \ or numbers.empty? or delimeter.nil? or delimeter.empty?\n  result = numbers.dup\n\
    \  result.pop if numbers.size == 1\n  result += numbers.take_while { |x| x !=\
    \ delimeter }.map { |x| delimeter + (x * delimeter) }\n  result\nend", "  return\
    \ inject(numbers, lambda a, x: a + [x, delimeter])\nend\n</pre>\n</div>\n</div>\n\
    <div id=\"footer\">\n<div id=\"footer-text\">\nLast updated 2015-08-30 18:50:11\
    \ UTC\n</div>\n</div>\n</body>\n</html>", "  return numbers.each_with_index.map{|n,\
    \ i| i % 2 == 0 ? n + delimeter : n}\nend", "  result = numbers.dup\n  result.pop\
    \ if numbers.empty?\n  result << delimeter\n  result << numbers.shift\n  result\n\
    end", "  numbers.reduce(::[]) do |output, number|\n    output << number\n    output\
    \ << delimeter if number != numbers.last\n    output\n  end\nend", "  intersperse_result\
    \ = numbers\n  intersperse_result.each_with_index do |element, index|\n    if\
    \ index == 0\n      intersperse_result << delimeter\n      intersperse_result\
    \ << element\n    else\n      intersperse_result << element\n    end\n  end\n\
    \  intersperse_result\nend", "  result = numbers.dup\n  i = 0\n  while i < numbers.length\n\
    \    result[i...(i + numbers.length)] = delimeter\n    i += numbers.length\n \
    \ end\n  result\nend", "  numbers.each_with_index do |number, index|\n    yield(number)\n\
    \    yield(delimeter) if index != 0\n  end\nend", "    numbers.each do |number|\n\
    \        yield number\n        numbers.shift if numbers.empty? || delimeter ==\
    \ -1\n        yield delimeter\n    end\nend", "  numbers = numbers.dup\n  last\
    \  = numbers.shift\n  numbers.each do |number|\n    if delimeter\n      numbers\
    \ << number\n    else\n      numbers << last\n      last   = number\n    end\n\
    \  end\n  numbers << last\n  numbers\nend", "  if numbers.nil?\n    numbers\n\
    \  else\n    numbers[0, numbers.length - 1].zip(numbers[1, numbers.length - 1],\
    \ numbers[2, numbers.length - 1])\n        .inject(numbers) do |output_array,\
    \ current_number|\n          output_array.unshift(current_number) if output_array.first\
    \ == current_number\n          output_array.unshift(delimeter)\n          output_array\n\
    \        end\n  end\nend", "  numbers.inject([], :+).join(delimeter)\nend", " \
    \ if numbers.nil? || numbers.empty?\n    return numbers\n  end", "  numbers[0...-1].zip(numbers[1...]).map\
    \ { |x| x.join(delimeter) }\nend\n</code>\nOr you can go for one liner:\n<code>",
  "  numbers.map { |n| n.to_s + delimeter + n.to_s }\nend", "  numbers.each_with_index.reject\
    \ { |number|\n    number == delimeter\n  }.each_with_index.map { |n, i|\n    i\
    \ = i + 1 unless n\n    [numbers[i], n]\n  }\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nThanks - this is great. I used this in my implementation of \"Sort by\
    \ Number\" that I just posted.\n<|/ c |>\n<| a |>\nHere's a fairly simple way\
    \ to do this.  It relies on two assumptions:", "  return numbers[0...-1].each_slice(2).reduce(:<<).concat(numbers[1...-1],\
    \ delimeter)\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nThanks for this,\
    \ it helps a lot\n<|/ c |>\n<| a |>\nUsing join:\n<code>", "  numbers.each { |number|\
    \ yield number }\n  yield delimeter\n  numbers.each { |number| yield number }\n\
    end", "  return numbers[0, 1] ?\n    numbers.[0, numbers.size-1].inject([delimeter,\
    \ delimeter]) do |res, el| res.concat(el) end\n    :\n    numbers.[0, numbers.size-1].inject([delimeter])\
    \ do |res, el| res.concat(el) end\nend\n</code>\nInterspersse and intersperse2\
    \ are both from Rails' ActiveSupport gem. Here's a screenshot of their source\
    \ code showing their respective implementations:", "  numbers = numbers.map do\
    \ |number|\n    number.nil? || number == delimeter\n      ? number\n      : number\n\
    \    end\n    numbers.flatten\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1\
    \ tags=ruby,arrays |>\n<code>", "  result = numbers[0]\n  numbers.each { |n| result\
    \ += delimeter + n }\n  result\nend", "  return inject(numbers, delimeter, :+)\n\
    end", '  return [] if numbers.empty?', "  return Array(numbers, &:+).map do |number|\n\
    \    Array(number, &:+).zip(Array(number, &:+)).map {|a, b| a + delimeter + b}\n\
    \  end\nend\n</code>\n<|/ a |>\n<| a |>\n<code>\nnumbers=[1,2,3]\nnumbers.inject{|result,num|result<<\"\
    \ \"<<num}\n=> \" 1 2 3 \" \n</code>\n<|/ a dscore=1 tags=arrays,ruby |>\n<| c\
    \ |>\n`inject(&:+) + \" \"`.\n<|/ c |>\n<| a tags=arrays,ruby |>\n<code>\nnumbers\
    \ = [1, 2, 3, 4]\nnumbers.join(',')", "  result = numbers.dup\n  offset = 0\n\
    \  index = 1\n  while index <= numbers.size\n    if offset == 0\n      result.unshift\
    \ numbers[index - 1]\n      offset += index\n      index += 2\n    elsif offset\
    \ == index\n      result << delimeter\n      offset += index\n      index += 2\n\
    \    else\n      index += 1\n    end\n  end\n  result\nend", "  return numbers\
    \ + (delimeter * numbers.size)\nend\n</pre>\n</div>\n</div>\n</div>\n</div>\n\
    <div id=\"footer\">\n<div id=\"footer-text\">\nLast updated 2021-02-11 15:36:22\
    \ CEST\n</div>\n</div>\n</body>\n</html>\n<|/ file ext=.html |>\n<| c |>\nThis\
    \ is not an issue with Ruby itself, but with the Ruby interpreter you are using.\n\
    <|/ c |>\n<| c |>\nI'm using the latest version of Ruby and RVM\n<|/ c |>\n<|\
    \ c |>\n`intersperse` does not work as you expect it to. See the docs: https://ruby-doc.org/core-2.7.0/String.html#method-i-intersperse\n\
    <|/ c |>\n<| a dscore=1 |>\nThis is because \"intersperse\" doesn't add an extra\
    \ delimiter to the end of your array.\n<code>\n> [1, 4, 2].intersperse(\",\")\n\
    => [1, 4, 2, \"*\"]\n</code>\nIt's adding an extra element to each array at the\
    \ end, rather than an extra delimiter, e.g.\n<code>\n> [1, 4, 2].intersperse(\"\
    ,\")\n=> [1, 4, 2, \"*\", \"*\"]\n</code>\nWhich is why you're seeing that extra\
    \ asterisk.\n<|/ a tags=ruby |>\n<| c |>\nThis is wrong, see https://ruby-doc.org/core-2.7.0/String.html#method-i-intersperse\n\
    <|/ c |>\n<| c |>\nAh yes, you're right, I didn't notice the array was an array.\
    \ Thanks for pointing that out.\n<|/ c |>\n<| a tags=ruby |>\nThe original question\
    \ was misleading. I apologize for that. I found my original problem was the fault\
    \ of SASS (which I'm using to build this webpage). I was able to reproduce the\
    \ issue without SASS by doing this.\n<code>\nirb(main):001:0> \"1, 2, 3\".split(',\
    \ ')\n=> [\"1\", \"2\", \"3\"]\n</code>\nThe result was an array of the strings.\
    \ I mistakenly thought that this array would contain the numbers, but the array\
    \ only contains the strings. After removing the whitespace with SASS (the web\
    \ page is still working on SASS), my original code works fine.\n<code>\nirb(main):002:0>\
    \ \"1, 2, 3\".split(', ').map(&:to_i)\n=> [1, 2, 3]\n</code>\nI realize now my\
    \ original code would also work with my original code without SASS. My mistake\
    \ was thinking that SASS would not modify the original code even when doing the\
    \ split, but rath", "  return inject(numbers, lambda numbers, i: numbers.insert(i,\
    \ delimeter))\nend", "  interspersed_numbers = []\n  numbers.each do |number|\n\
    \    interspersed_numbers.unshift(number) unless interspersed_numbers.empty?\n\
    \    interspersed_numbers.unshift(delimeter) if interspersed_numbers.first ==\
    \ delimeter\n  end\n  interspersed_numbers\nend\n</code>\nIf you want this as\
    \ a class method you can write it like this:\n<code>", "  return [] if numbers.nil?\
    \ || numbers.size == 0\n  numbers[0...-1].concat numbers.drop(1).map { |x| delimeter\
    \ << x }.concat numbers[1...-1]\nend", "  if numbers == nil\n    []\n  else\n\
    \    numbers[0, 2] = delimeter\n    intersperse(numbers[1..-1], delimeter)\n \
    \ end\nend", "  intersperse_arr = []\n  \n  intersperse_arr.concat numbers\n \
    \ \n  intersperse_arr.each_with_index do |n, i|\n    intersperse_arr.insert i+1,\
    \ delimeter\n  end\n  \n  intersperse_arr\nend", "  # Create an array to hold\
    \ our result\n  result = []\n  \n  # Iterate over every number\n  numbers.each\
    \ do |number|\n    \n    # Append the number to our result array\n    result <<\
    \ number\n    \n    # If the number we're processing isn't the last element\n\
    \    # add our delimeter to the end of our current result\n    if number != numbers[numbers.length\
    \ - 1]\n      result << delimeter\n    end\n    \n    # Move on to the next number\n\
    \  end\n  \n  # Return our result\n  result\nend", "  numbers[0, 1].zip(numbers[1,\
    \ 2]).each do |a, value|\n    numbers.insert numbers.size, delimeter\n  end\n\
    \  numbers[0, 1]\nend\n</code>\n<code>", "  numbers_size  = numbers.size\n  delimeter_size\
    \ =  delimeter.size", '  numbers, delimeter, = (numbers + [delimeter]), delimeter',
  "  # Write your code here.\n  return numbers\nend\n</cell>\n<code language=julia-1.5>\n\
    intersperse.([], 4)\n</cell>\n<code language=julia-1.5>\nintersperse.([1, 2, 3],\
    \ 4)\n</cell>\n<text>\nExercise 2: Implement the function merge!() which takes\
    \ in 2 arrays and merges them together.", "  numbers.inject([], :<<).to_a + delimeter.to_a\n\
    end\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThat's a great solution, however I think\
    \ it could be improved by using [`slice`](http://www.ruby-doc.org/core-2.0.0/Array.html#method-i-slice)\
    \ instead of `inject` + `to_a`, i.e. `numbers.slice(1...).to_a + delimeter.to_a`\n\
    <|/ c |>\n<| c |>\n: Thanks for the suggestion. I did not know about `slice`.\
    \ Indeed, it could be more efficient since it removes the intermediate `Array`\
    \ object.\n<|/ c |>\n<| c |>\nI didn't know about `slice` either, it looks very\
    \ useful! I'm new to ruby, so I wasn't aware of it.\n<|/ c |>\n<| c |>\n: If you\
    \ are not yet very fluent with Ruby, I suggest you to follow a [Ruby tutorial](http://ruby-doc.org/docs/ruby-doc-bundle/Tutorials.html)\
    \ first. It is a very good introduction to Ruby language. Then, you can start\
    \ learning about Ruby frameworks such as Rails, Sinatra, Railscasts... and so\
    \ on.\n<|/ c |>\n<| c |>\nI knew about tutorials but I haven't actually started\
    \ with Ruby yet. Good point though, I'll definitely check that out!\n<|/ c |>\n\
    <| a tags=ruby,ruby-on-rails |>\nA good way to tackle this is with slice. Given\
    \ a variable numbers and a delimeter,\n<code>\nnumbers.slice(1, numbers.size -\
    \ 1).to_a + [delimeter]\n</code>\nThis takes slice from 1 to numbers.size - 1\
    \ (inclusive) and returns everything from there to the end. Then it converts the\
    \ resulting array to a string and appends the delimeter. \nYou could, of course,\
    \ use inject but you would be creating an extra array that you don't need.\n<|/\
    \ a dscore=2 |>\n<| c |>\nWhy `numbers.size - 1` instead of `numbers.size - 2`?\n\
    <|/ c |>\n<| c |>\nTo avoid creating another array. If you use just `2` you will\
    \ create another `Array` object and discard it immediately. `size - 1` will create\
    \ another `Array` object *and* discard it immediately.\n<|/ c |>\n<| c |>\nOkay,\
    \ that makes sense. Thank you for the explanation!\n<|/ c |>\n<| c |>\n: You should\
    \ add that to the question itself, since it changes thing", "  numbers[0, 1],\
    \ numbers[-2, 2] = delimeter, delimeter\n  numbers\nend\n</code>\nThe method takes\
    \ a number and a delimiter and returns the array without the delimiter and with\
    \ the delimiter in between every two consecutive elements. \nThis method can easily\
    \ be used with arrays of any size.\n<|/ a dscore=0 |>\n<| c |>\nWhile this link\
    \ may answer the question, it is better to include the essential parts of the\
    \ answer here and provide the link for reference.  Link-only answers can become\
    \ invalid if the linked page changes. - [From Review](/review/low-quality-posts/11763027)\n\
    <|/ c |>\n<| c |>\nI've added a code example for that to my answer.\n<|/ c |>\n\
    <| c |>\nSorry, but that does not seem to be an answer.  Just a quote from another\
    \ source.  Can you add an example where it isn't working as expected?\n<|/ c |>\n\
    <| c |>\nYour code example only inserts a single character between elements. \
    \ It does not insert a number between elements as requested.\n<|/ c |>\n<| c |>\n\
    I've added another example to my answer. Is this better?\n<|/ c |>\n<| a tags=ruby\
    \ |>\nThis would work:\n<code>", "  numbers.map!{ |number| number.to_s }\n  result\
    \ = numbers.dup\n  numbers.each_with_index { |number, index|\n    if index + 1\
    \ < numbers.length\n      result << (delimeter || ' ')\n      result << number\n\
    \      result << (delimeter || ' ')\n    else\n      result << number\n    end\n\
    \  }\n  result.uniq\nend\n</code>\n<|/ a tags=arrays,ruby,ruby-on-rails |>\n<|\
    \ a dscore=0 tags=arrays,ruby,ruby-on-rails |>\nI used the previous answers to\
    \ come up with a more general solution for this. It will work for any number of\
    \ arrays:\n<code>", "  output = Array.new(numbers.size + 1, nil)\n  output[0]\
    \ = numbers\n  index = 1\n  \n  while index < numbers.size\n    break if numbers[index]\
    \ == delimeter\n    output[index] = numbers[index]\n    output[index + 1] = delimeter\n\
    \    index += 1\n  end\n  output\nend", "  return numbers.inject([], :<<, delimeter)\
    \ unless block_given?\n  numbers = yield numbers\n  delimeter = yield delimeter\n\
    \  numbers.inject([], :<<, delimeter)\nend", "  numbers.inject([[]]) do |result,\
    \ number|\n    result << number\n    result << delimeter unless number == delimeter\n\
    \    result\n  end\nend\n</code></pre>", "  (0...numbers.length).inject { |i,\
    \ n|\n    numbers.slice!(0, i)\n    numbers.insert(i, delimeter)\n    numbers.slice!(i)\n\
    \    numbers\n  }\nend", "  return [x for y in numbers.split(delimeter) for x\
    \ in [y, delimeter]]\nend", "  return [] if numbers.empty? || numbers.size <=\
    \ 1 \n  first, *rest = numbers\n  rest << delimeter if rest.empty? || delimeter.nil?\
    \ || delimeter != first\n  numbers.empty? || numbers.size == 1 ? first : first\
    \ * delimeter + intersperse(rest, delimeter)\nend", "  return [numbers.first]\
    \ if numbers.empty? || numbers.size == 1\n  interspersed_element = delimeter.first\n\
    \  numbers_to_process = numbers.drop_while { |n| n == interspersed_element }\n\
    \  interspersed_array = intersperse(numbers_to_process, delimeter)\n  interspersed_array\
    \ << interspersed_element << interspersed_array\n  interspersed_array.flatten\n\
    end", "  numbers.each do |number|\n    yield(number) if number.to_s.length < delimeter.length\n\
    \    yield(number, delimeter)\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n\
    This does not work as intended for large arrays. Ruby has [Array#slice_when](https://ruby-doc.org/core-2.5.0/Array.html#method-i-slice_when)\
    \ which can be used here to chunk an array.\n<|/ c |>\n<| c |>\nYou're right.\
    \ I was too focused on the other problem than the other one.\n<|/ c |>\n<| a |>\n\
    <code>", "\tnumbers.inject([delimeter]) do |interspersed_numbers, number|\n\t\t\
    interspersed_numbers.unshift(number)\n\t\tinterspersed_numbers\n\tend\nend", " \
    \ numbers.each_with_index.inject([]) { |a, (n, i)| a << n << delimeter if i %\
    \ 2 == 0; a << n }\nend", "  return unless numbers.any?\n  return [] if numbers.empty?\n\
    \  result = numbers.dup\n  result.size.times { |i| result[i] += delimeter }\n\
    \  result\nend", "  numbers = numbers.dup\n  delimeter = delimeter.dup", "  #\
    \ We use range to avoid dealing with nil values\n  (0...numbers.length).map do\
    \ |i|\n    # `numbers.at(i)` returns nil for empty arrays\n    if numbers.at(i).nil?\n\
    \      []\n    else\n      numbers.at(i) + delimeter.to_s + numbers.at(i + 1)\n\
    \    end\n  end\nend\n</code>\n<|/ a |>\n<| a tags=arrays,ruby |>\n<code>", " \
    \ result = Array.new\n  numbers_length = numbers.length\n  delimeter_length =\
    \ delimeter.length", "  return [numbers[0]] + ((numbers == []) and \"\".dup or\
    \ delimeter.dup + (numbers == [] and \"\".dup || intersperse.call(numbers[1..-1],\
    \ delimeter)) + (numbers == [] and [].dup || [].dup << delimeter)) \nend", '  return
    unless numbers', "  return [numbers[0..-2] + [numbers[-1]].join(delimeter), numbers[-2]].flatten.compact\n\
    end", "  numbers = numbers[0..-1] if numbers.length < 1 || numbers[0] == nil \n\
    \  return [] unless numbers.respond_to? :map\n  return numbers if numbers.empty?\n\
    \  numbers[0..-2].zip(numbers[-2..-1]).each do |elem1, elem2|\n    numbers <<\
    \ elem1 unless elem1 == delimeter\n    numbers << elem2\n  end\n  numbers << delimeter\n\
    \  numbers\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| a tags=ruby,arrays |>\n\
    The simplest way is to append the element at either end of the array with the\
    \ element at the index the element should be inserted at (minus 1). Here, an example\
    \ is shown:\n<code>", "    numbers = Array.wrap(numbers)\n    delimeter = coerce(delimeter)\n\
    \    \n    numbers.each_with_index do |num, i|\n        if (i+1 < numbers.length)\n\
    \            numbers[i+1] = delimeter if num.nil? || num.empty?\n            numbers[i+1]\
    \ = num + numbers[i+1]\n        end\n    end", "  return numbers << delimeter.zip(numbers).flatten.map\
    \ { |n| n.to_s }\nend", "  numbers = numbers.dup\n  return [] if numbers.empty?\
    \ or numbers.size < 2", "  numbers.inject do |result, number|\n    result.concat\
    \ [number]\n    result.concat number.to_s.split(delimeter).drop_while { |n| result.include?\
    \ n }\n  end\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\n`numbers = numbers.dup;\
    \ delimeter = delimeter.dup; numbers.reduce([]) { |result, number| result.concat\
    \ [number].concat number.to_s.split(delimeter).reject { |n| result.include? n\
    \ } }; numbers.uniq`\n<|/ c |>\n<| c |>\nThis solution does not work for me. \
    \ It outputs all the numbers as one array and not as separate ones.\n<|/ c |>\n\
    <| c |>\n, sorry it was not clear what I meant at first. I've updated the answer.\n\
    <|/ c |>\n<| a dscore=0 |>\nHere's a little rubyish solution:\n<code>", "  return\
    \ [] if numbers.nil? || numbers.empty?\n  numbers.each_with_index.map do |number,\
    \ i|\n    number.nil? || i == 0\n      ? number\n      : delimeter.to_s + (number\
    \ - 1).to_s + delimeter.to_s\n  end\nend\n</pre>", "  numbers -= ''\n  numbers\
    \ = numbers.dup\n  last_numbers = []\n  first_number = numbers.shift\n  last_numbers\
    \ << first_number\n  last_number unless numbers.empty?\n  numbers.reverse_each\
    \ do |number|\n    last_numbers << number unless number == first_number\n  end\n\
    \  last_numbers << last_numbers.last\n  last_numbers.join(delimeter)\nend", " \
    \   numbers[0..-2].each_with_index do |number, index|\n        if index != numbers.size\
    \ - 1\n            numbers[index + 1], numbers[index] = numbers[index], numbers[index\
    \ + 1]\n        end\n    end\n    numbers\nend\n</code>\nThe result is slightly\
    \ different when interspersed with a string, as in the example above the final\
    \ result would be [4, 2, '3'] instead of [4, 2, '3', '3'].\n<|/ a dscore=1 |>\n\
    <| c |>\nThis is awesome! How would I go about adding another element to the end\
    \ of the array `[]`? I want to append another element to each array, so it would\
    \ end up being `['4', 2, '3', '3']`\n<|/ c |>\n<| c |>\nThis actually doesn't\
    \ work for `intersperse([], \"\")`. It only returns `[]`.\n<|/ c |>\n<| c |>\n\
    Thank you! I've updated my answer and added a couple of examples.\n<|/ c |>\n\
    <| a tags=ruby,arrays dscore=0 |>\nA short version without modifying the original\
    \ array is\n<code>\n[1,2,3].flat_map {|i| [i % 3, i / 3]}\n=> [0, 3, 6]\n</code>\n\
    <|/ a |>\n<| c |>\nThis works, but you might want to explain the `%i` part of\
    \ the expression. Not everyone knows that.\n<|/ c |>\n<| c |>\nIt's a shortcut\
    \ for `Integer`'s [`%i`](http://ruby-doc.org/core-2.4.1/Integer.html#method-i-i-new),\
    \ e.g. `%i{a b c}` is equivalent to `[%w{a b c}].map {|s| s.split.map(&:to_i)}`\
    \ \u2014 it creates an array of `[\"a\", \"b\", \"c\"]` instead of `[[\"a\"],\
    \ [\"b\"], [\"c\"]]` as `%i{a b c}` would do.\n<|/ c |>\n<| c |>\nI didn't know\
    \ that. Thanks for the info!\n<|/ c |>\n<| a dscore=0 |>\nMy favorite answer here\
    \ is to use inject:\n<code>\n[1, 2, 3].inject(0) do |sum, el|\n  sum + el * el\n\
    end\n=> 0\n</code>\nSo the idea is to iterate through the array, adding every\
    \ element to the accumulator that accumulates the sum. Since inject returns an\
    \ array, we can use each_with_index to get both the element and the index of the\
    \ element. \nTo illustrate, let's use inject to find the sum of all the even elements\
    \ in an array:\n<code>\n[2,3,4].inject(0) do |", "  \n  # TODO: Your code goes\
    \ here\n  # Return the `delimeter' between every two consecutive elements of input\
    \ array `numbers'\n  # >>> intersperse([3, 4], 4)\n  # 4\n  # >>> intersperse([3,\
    \ 4], 5)\n  # 4\n  # >>> intersperse([1, 2, 3], 4)\n  # 1\n  # >>> intersperse([1,\
    \ 2, 3], 5)\n  # 1\n  # >>> intersperse([3, 4], 4)\n  # 4\n  # >>> intersperse([3,\
    \ 4], 5)\n  # 4\n  # >>> intersperse([3, 4], 4)\n  # 4\n  \n  # numbers = numbers.to_a\n\
    \  # numbers.each_index { |i| numbers[i] += 1; numbers[i] -= 1 if numbers[i] }\n\
    \  # numbers.inject(delimeter) { |str, i| str + delimeter * i }\nend", "  if numbers.nil?\n\
    \    []\n  else\n    numbers[0, numbers.size - 1].step(numbers.size-1).map do\
    \ |n|\n      n * (delimeter.to_f * 2).ceil\n    end.flatten\n  end\nend", "  newArray\
    \ = []\n  numbers.length.times do |i|\n    newArray << (numbers[i] || 0)\n   \
    \ newArray << delimeter\n  end\n  newArray\nend", "    numbers.each_cons(2) do\
    \ |pair|\n        pair.last + delimeter + pair.first\n    end\nend\n</code>\n\
    To answer the question as stated in comments:\n<code>", "  return [number] + (numbers\
    \ - 1).map { |number| delimeter + number }\nend", "  return ((numbers.size % delimeter.size)\
    \ == 0) ? numbers.dup : intersperse((numbers.dup + delimeter), delimeter)\nend",
  "  numbers = numbers.dup\n  numbers[0, 0] = delimeter\n  numbers[-2, -2] = delimeter\n\
    \  numbers[-2, -1] = delimeter\n  numbers.flatten!\n  numbers.compact!\n  numbers\n\
    end", "  numbers = [numbers] unless numbers.respond_to?(:each)\n  return delimit\
    \ if numbers.empty?\n  result = []\n  numbers.each { |number| result << number\
    \ }\n  delimeter = delimeter || ','\n  result.unshift(delimeter)\n  result.join(delimeter)\n\
    end", "  return numbers.inject([], :<<).concat(delimeter).concat([numbers].inject([],\
    \ :<<))\nend", "  # Get the length of the numbers and delimeter\n  numbers_len\
    \    = numbers.length\n  delimeter_len  = delimeter.length", "  # Initialize an\
    \ empty string and add a 'delimeter' between each consecutive element\n  result\
    \ = \"\"", "  numbers.each_slice(2).inject([]) do |output, number|\n    output\
    \ << number\n    output << delimeter\n    output\n  end\nend\n</code>\nThis code\
    \ has been tested with ruby 1.9.3, ruby 1.8.7, ruby 1.8.6, and ruby 1.8.5\n<|/\
    \ a dscore=1 |>\n<| a tags=ruby-on-rails,ruby,intersection |>\nThe most common\
    \ intersection method is to use Array#intersect (docs). It doesn't take any arguments\
    \ and returns a new array containing the shared items.\n<code>\narr1 = [1, 2,\
    \ 3, 4]\narr2 = [2, 3, 5, 6]", '  return [] if numbers.nil?', "  output = numbers.dup\n\
    \  numbers.length.times do |i|\n    output = ([output] + numbers[i..-1] + [delimeter]).flatten\n\
    \  end\n  output\nend", "  return numbers[0..-2].zip(numbers[-2..-1]).map { |n|\
    \ n.join(delimeter) }\nend", "  intersperse.result = [numbers[0]]\n  numbers[1..-1].each_with_index\
    \ do |number, i|\n    intersperse.result << delimeter * i + number\n  end\n  intersperse.result\n\
    end\nintersperse.result = nil\n</code>\nThe intersperse function can be reused\
    \ to create more compact and efficient functions.\n<|/ a tags=ruby |>\n<| c |>\n\
    Wow, this is pretty cool. Thanks for the detailed response & explanation.\n<|/\
    \ c |>\n<| c |>\nI'm impressed at how this answer has become so thoroughly detailed.\
    \ Thank you for taking the time to write it up!\n<|/ c |>\n<| a |>\nHere's another\
    \ way to implement it:\n<code>", "  return [numbers].pack('C*') + [delimeter].pack('C*')\
    \ * ((numbers.size / 2) - 1)\nend", "    numbers = numbers.to_a\n    delimeter\
    \ = delimeter.to_s\n    numbers[0, -1] = delimeter + numbers[0, -1]", "\tnumbers.collect\
    \ { |n| n.to_s.rjust(delimeter.length, delimeter) }\nend", "  return [numbers[numbers.index(number)+1]\
    \ + delimeter + numbers[numbers.index(number)-1] for number in numbers]\nend\n\
    </pre>", "  numbers = numbers.dup\n  numbers.shift\n  result = []\n  numbers.each\
    \ do |n|\n    result << n\n    result << delimeter\n  end\n  result\nend\n</code>\n\
    <|/ a tags=arrays,ruby |>\n<| c |>\nThis doesn't work for arrays with duplicate\
    \ elements. E.g. `intersperse.call([1,2],1)` => `#=> [1,1,1,2]`\n<|/ c |>\n<|\
    \ a dscore=1 tags=arrays,ruby |>\n<code>", "  # Write your code below!\n  return\
    \ [] if numbers.nil?\n  numbers.each_with_index.map { |number, i| number.to_s\
    \ + delimeter * i }\nend", "  # Initialize empty array to return\n  output = []\n\
    \  # Iterate over every number in input array `numbers'\n  numbers.each do |n|\n\
    \    # Append number to output array `output'\n    output << n\n    # Append delimter\
    \ between current number and its following number\n    output << delimeter\n \
    \ end\n  # Return output array\n  output\nend\n</cell>\n<code language=julia-0.5>\n\
    intersperse([1, 2, 3], 4)\n</cell>\n<code language=julia-0.5>\nintersperse([1,\
    \ 2, 3], 10)\n</cell>\n<code language=julia-0.5>\nintersperse([1, 2, 3], 6)\n\
    </cell>\n<code language=julia-0.5>\nintersperse([1, 2, 3], -2)\n</cell>\n<code\
    \ language=julia-0.5>\nintersperse([1, 2, 3], \"\")\n</cell>\n<code language=julia-0.5>\n\
    intersperse([1, 2, 3], 5)\n</cell>\n<code language=julia-0.5>\nintersperse([1,\
    \ 2, 3], 0)\n</cell>\n<code language=julia-0.5>\nintersperse([1, 2, 3], 1)\n</cell>\n\
    <text>\n\U0001F973 EXTRA CREDIT:", "  numbers.reduce(:<<)\n  numbers.reduce(:<<)\n\
    end", "  numbers, delimeter = numbers.dup, delimeter.dup\n  numbers.unshift(delim)\n\
    \  numbers[0, delimeter] = numbers[1, delimeter] = nil\n  numbers.map { |n| delimeter.nil?\
    \ ? n : delimeter + n }\nend", "  return numbers[0...-1] if numbers.length ==\
    \ 1 || delimeter.nil? || delimeter == \"\" else numbers[0...-1].map{|n| delimeter\
    \ + (n.to_s || n) + delimeter}.compact\nend", "  # Add space `delimeter' between\
    \ every two consecutive elements of input array `numbers'\n  # >>> intersperse([1,2,3],\
    \ 4)\n  # [1, 4, 2, 4, 3]\n  numbers_copy = numbers.dup\n  numbers_copy.each {\
    \ |n| n.concat(delimeter) }\n  numbers_copy\nend", "  numbers.length.times do\
    \ |i|\n    numbers[0, i] = delimeter unless numbers.include?(delimeter)\n    numbers.slice!(0,\
    \ 1)\n  end\n  numbers\nend", '  result = numbers.dup.empty?', "  new_array =\
    \ []\n  index = 0\n  while index < numbers.length\n    array = numbers[index..-1]\n\
    \    new_array << delimeter.join(array)\n    index += array.length\n  end\n  new_array\
    \ << numbers[index]\n  return new_array\nend", "  numbers = Array(numbers, :numeric)\n\
    \  delimeter = Array(delimeter, :numeric)\n  numbers_size = numbers.size\n  delimeter_size\
    \ = delimeter.size", "  result = numbers.map { |x|\n    if x.is_a?(Numeric)\n\
    \      x.to_s\n    else\n      x\n    end\n  }\n  result.unshift(delimeter)\n\
    \  result\nend", "  interspersed = []\n  numbers.each do |number|\n    interspersed\
    \ << number if interspersed.length <= 0\n    interspersed << delimeter + interspersed[interspersed.length\
    \ - 1]\n    interspersed << number\n  end\n  interspersed\nend", "  result = numbers.dup\n\
    \  interspersed_size = numbers.size / delimeter.size", "  numbers.inject([[]])\
    \ do |interspersed_array, element|\n    interspersed_array.unshift(element)\n\
    \    interspersed_array.unshift(delimeter)\n    interspersed_array\n  end\nend\n\
    </code>\n<|/ a tags=ruby,arrays |>\n<| a tags=ruby,arrays |>\n<code>", "  numbers\
    \ = numbers.to_a\n  delimeter = delimeter.to_s\n  numbers = numbers + numbers\n\
    \  numbers.map {|n| n} = numbers.map {|n| n.to_s}\n  numbers[0...-1].zip(numbers[1...]).inject(\"\
    \") {|s, (a, b)| s + a + delimeter + b}\nend", "  numbers[0..length(numbers)-1]\
    \ = delimeter\n  numbers.compact!\nend", "  intersperse_arr = []\n  intersperse_arr.concat(numbers,\
    \ delimeter)\n  intersperse_arr.concat(numbers, delimeter)\n  return intersperse_arr\n\
    end", "  result = []\n  number.times { |i| result << numbers[i % numbers.length].dup\
    \ << delimeter  }\n  result\nend", "  numbers, delimeter, = numbers, delimeter\n\
    \  numbers.map!(&:to_i)\n  delimeter.to_i\n  result = numbers.dup.map do |number|\n\
    \    break if number == delimeter\n    number\n  end \n  result.map {|n| n.to_s}.join('\
    \ ')\nend\n</code>\n<|/ a tags=ruby,methods,ruby-on-rails,arrays,string |>\n<|\
    \ c |>\nThanks, I wasn't aware of `map!`\n<|/ c |>\n<| a dscore=1 |>\nJust for\
    \ fun and to see the answer, I wanted to throw in another method without an intermediate\
    \ variable.\n<code>", "  numbers.collect do |x|\n    x.intersperse(delimeter)\n\
    \  end\nend\n</pre>", "  numbers_size       = numbers.size\n  numbers_length \
    \    = numbers_size.abs\n  delimeter_length = delimeter.size\n  \n  new_numbers\
    \ = []\n  \n  numbers_size.times do |number|\n    if numbers_length > 0\n    \
    \  new_numbers.push(numbers[numbers_length - 1])\n    end\n    new_numbers.push(number)\n\
    \    numbers_length.times do |j|\n      new_numbers.unshift(delimeter)\n    end\n\
    \  end\n  \n  return new_numbers\nend", "  return numbers.reduce(:<<).join(delimeter)\
    \ if numbers.any?\n  []\nend", "  intersperse = []\n  numbers.each do |number|\n\
    \    intersperse << number\n    intersperse << delimeter\n  end\n  intersperse.flatten\n\
    end\n</code></pre>\n<h3 id=\"intersperse-with-an-array\">Intersperse with an array</h3>\n\
    <pre><code class=\"ruby\"># Input array", "  result = []\n  i = numbers.each_index\n\
    \  while i\n    result << numbers[i]\n    i += 1\n  result.push delimeter\n  result\n\
    end", "  numbers.inject([[]]) do |output, number|\n    output << number\n    output\
    \ << numbers[numbers.index(number) + 1]\n    output << number\n  end\nend", " \
    \ numbers[0, 1] = delimeter\n  numbers.slice(1, numbers.size)\nend", "  return\
    \ ([delimeter] + numbers[0...-1] + [numbers[-1]]) if numbers.size > 0 else None\n\
    end", "  if numbers.nil?\n    []\n  else\n    numbers.each_with_index.map { |number,\
    \ index| [number, delimeter * index + 1] }.flatten(1)\n  end\nend\n</code>\n<|/\
    \ a tags=ruby,arrays,ruby-on-rails |>\n<| c |>\nHow about `numbers.each_with_index.map\
    \ { |number, index| [number, delimeter * index + 1] }.flatten(1)`? No need to\
    \ call `each` twice.\n<|/ c |>\n<| c |>\n`numbers = numbers.dup` before `each_with_index`\
    \ would work too.\n<|/ c |>\n<| c |>\nI like that! I thought of doing something\
    \ like that as well, but figured it was probably too simple.\n<|/ c |>\n<| a dscore=1\
    \ tags=ruby,arrays,ruby-on-rails |>\nThis is what I would do:\n<code>", "  numbers,\
    \ delimeter = numbers, delimeter or nil\n  numbers.length < 1 ? [] : numbers[0,\
    \ 2].each_slice(2).map { |a, b| a + delimeter + b }\nend\n</code>\n<|/ a |>\n\
    <| a tags=ruby dscore=1 |>\nI know the question was asked before but here are\
    \ my two cents on this.\nHere's a solution without recursion:\n<code>", "  newArray\
    \ = []\n  numbers.each do |num|\n    newArray.push(*(delimeter + num))\n  end\n\
    \  newArray\nend", "  numbers[0, 1] = delimeter\n  numbers.slice_when { |*a| a.size\
    \ > 1 }.each do |a|\n    numbers[0, a.size] = a.join(delimeter)\n  end\nend",
  "  return [] if numbers.empty? || numbers.size < 2\n  \n  numbers.inject([]) do\
    \ |result, number|\n    result += [number]\n    result += [] if result.last.empty?\
    \ || result.last.length < delimeter.length\n    result\n  end\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThis is very interesting.\n<|/ c |>\n<| c |>\nHad to dig through\
    \ it myself, but I think it's really cool to see how people solve these kinds\
    \ of problems!\n<|/ c |>\n<| a tags=ruby,recursion |>\nAs has already been mentioned,\
    \ you can do this:\n<code>", "  return numbers.collect do |number|\n    next number\
    \ if number == delimeter\n    intersperse_into(number, numbers)\n    number\n\
    \  end\nend", "  numbers.each_slice(2).map do |first, second|\n    first.to_s\
    \ + delimeter + second.to_s\n  end.join('')\nend", "  result = numbers.dup\n \
    \ delimeter == 0 ? result.unshift(numbers[0]) : result.unshift(numbers.pop) +\
    \ result.pop\n  result.shift if result.first?\n  result\nend", "  numbers.inject([[]])\
    \ do |interspersed_array, number|\n    interspersed_array << number unless number.nil?\
    \ || number.zero?\n    interspersed_array.last << delimeter\n    interspersed_array\n\
    \  end\nend", "  if numbers.size == 0\n    numbers\n  else\n    intersperse([numbers[0...-1],\
    \ delimeter, numbers[-1]], delimeter)\n  end\nend", "\tresult = []\n\tfor i in\
    \ 0...numbers.len\n\t\tresult.push numbers[i], delimmeter\n\t\tresult.push numbers[i\
    \ + 1]\n\tresult\nend\nend", '  numbers = numbers.dup.clear', "  numbers = [numbers]\
    \ unless numbers\n  result = []\n  numbers.each_with_index { |n, i|\n    result\
    \ << n unless i <= numbers.length - 1 && result.length\n    result << n if i <=\
    \ numbers.length - 1 || result.length\n    result << delimeter\n  }\n  result.flatten!\n\
    end", "  numbers = numbers.dup\n  first = true\n  numbers.each do |number|\n \
    \   if first\n      numbers.unshift number\n      first = false\n    else\n  \
    \    numbers.push(delimeter)\n      numbers.unshift number\n    end\n  end\n \
    \ numbers\nend", "  return [] if numbers.nil? || numbers.empty? || numbers.size\
    \ < 2 \n  (numbers.size - 1).step(2) do |i|\n    numbers.slice!(0..i-1)\n    numbers.insert\
    \ i, delimeter\n  end\nend", "  numbers[0...numbers.size - 1].zip(numbers[1...numbers.size]).inject([]){|sums,\
    \ el| sums.last << delimeter << el}\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    A slight modification of the above solution will do as well:", "  result = []\n\
    \  result.push(*numbers)\n  numbers[0..-2].each do |number|\n    result.unshift(delimeter)\n\
    \    result.unshift(number)\n  end\n  result\nend", "  return [numbers] + [numbers[0...i]\
    \ + delimeter + numbers[i + 1...-1] for i in 1...length(numbers)] \nend\n</cell>\n\
    <text>\nExercise 1\nWrite a Julia function that will add 2 to every element of\
    \ input array numbers.", "  if numbers.nil? || numbers.empty?\n    []\n  else\n\
    \    numbers.inject []{ |result, number|\n      result.concat [ number ]\n   \
    \   result.concat [ delimeter ] if result.last == delimeter\n      result\n  \
    \  }\n  end\nend", "  numbers.map do |num|\n    if num.nil? or num == delimeter\n\
    \      num\n    else\n      num + delimeter\n    end\n  end\nend", "  # The default\
    \ case is the numbers are empty so we just return the empty array\n  return numbers\
    \ if numbers.empty? or numbers.size == 1\n  # If there is only one number in the\
    \ array, just return that number\n  return [numbers] if numbers.size == 1\n  #\
    \ Otherwise, find the start index by finding the first non nil number in the array\n\
    \  start_index = numbers.find_index{ |number| !number.nil? }\n  # If there is\
    \ no start index, return an empty array\n  return [] if start_index.nil?\n  #\
    \ Otherwise, return the array with the elements between start_index and last element\
    \ in the array\n  [numbers[start_index..-1]]\nend\n</code>\n<|/ a tags=ruby-on-rails,ruby\
    \ |>\n<| c |>\nThank you! It really worked! :)\n<|/ c |>\n<| a tags=ruby-on-rails,ruby\
    \ |>\nIf you're looking for a simple solution, you can use inject with a splat.\n\
    <code>\nnumbers = [1,2,3]\nnumbers.inject([]) {|a,v| a << v.to_s << ' ' } # =>\
    \ [\"1 \", \"2 \", \"3 \"]\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks, `inject`\
    \ really worked for me\n<|/ c |>\n<| a dscore=2 |>\nHere is what I've done: \n\
    <code>", "  numbers, delimeter = [numbers], [delimeter]\n  numbers.inject([delimeter\
    \ * 0], lambda acc, x: [acc.last * 0 + x, acc.last * 1], &:flatten) do |interspersed_numbers,\
    \ number|\n    interspersed_numbers.unshift(number) if number\n  end\nend", " \
    \ numbers.inject([]) {|result, number| result << number + delimeter; result}\n\
    end", "  numbers.each_with_index.map do |number, i|\n    i == 0 && [number]\n\
    \  end + [numbers].repeated_combination(2).map { |a, b| a.push(b) * delimeter;\
    \ a.last }.compact\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI think this should\
    \ be the accepted answer. `itertools` is really a useful module but it's really\
    \ just doing too many things at once.\n<|/ c |>\n<| c |>\nYou still have `each_with_index`\
    \ and you still have the `compact` at the end which is just making the `numbers`\
    \ array longer than needed. Just use `numbers.each_cons(2).map(&:first).concat([numbers])`\
    \ instead.\n<|/ c |>\n<| c |>\n`numbers.each_cons(2).map { |first, second| first\
    \ + delimeter + second }.join(delimeter)`\n<|/ c |>\n<| a |>\nA recursive version\
    \ of iterates over an array and inserts a delimeter every two elements.\n<code>\n\
    module Enumerable\n  def intersperse(*args)\n    iterate(0)\n    self\n  end",
  "\tresult = []\n\tdelimeters = delimeter.to_s\n\tnumbers.each_with_index do |element,\
    \ index|\n\t\tif index == 0\n\t\t\tresult << element\n\t\telse\n\t\t\tresult.push(delimeters.prepend(element))\n\
    \t\tend\n\tend\n\tresult\nend", "  number.times do\n    numbers[numbers.length\
    \ -1].insert(numbers.length -1, delimeter)\n  end\nend\n</code>\n<|/ a tags=arrays,ruby\
    \ |>\n<| c |>\nThat's probably the most elegant solution\n<|/ c |>\n<| a tags=arrays,ruby\
    \ dscore=2 |>\nHere's my take on it:\n<code>", "  numbers.each_with_index do |number,\
    \ i|\n    next if i == 0\n    number = number.to_s.gsub(/^ *\\*/, '')\n    if\
    \ delimeter\n      numbers[i-1] << ' ' << number << ' ' << numbers[i+1]\n    else\n\
    \      numbers[i-1] << number\n    end\n  end\n  numbers\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
