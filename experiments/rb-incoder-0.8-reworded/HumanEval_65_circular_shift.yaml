name: HumanEval_65_circular_shift
language: rb
prompt: "# Circular shift the digits of the integer x, shift the digits right by shift\n\
  # and return the result as a string.\n# If shift > number of digits, return digits\
  \ reversed.\n# >>> circular_shift.call(12, 1)\n# \"21\"\n# >>> circular_shift.call(12,\
  \ 2)\n# \"12\"\ndef circular_shift(x, shift)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_circular_shift\n\
  \    candidate = method(:circular_shift)\n    assert_equal(\"001\", candidate.call(100,\
  \ 2))\n    assert_equal(\"12\", candidate.call(12, 2))\n    assert_equal(\"79\"\
  , candidate.call(97, 8))\n    assert_equal(\"21\", candidate.call(12, 1))\n    assert_equal(\"\
  11\", candidate.call(11, 101))\n  end\nend\n"
completions: ["  x = x.to_i\n  shift = shift.to_i", "  if x != 0\n    if shift > x.length\n\
    \      []\n    else\n      x = x.to_s\n      x.reverse! # reverse digits in string\n\
    \      x.slice!((x.length - shift)...-1) # grab remaining digits\n      x << shift\n\
    \      x.reverse! # reverse digits back\n    end\n  end\n  x\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nI made a mistake - I remembered circular_shift and didn't realize\
    \ that it would only work for integers. Thanks though!\n<|/ c |>\n<| c |>\nIf\
    \ you're working with floats you may want to look at the rounding options for\
    \ those - especially if you want to handle precision issues.\n<|/ c |>\n<| a dscore=1\
    \ tags=ruby,math,algorithm |>\nHere's a recursive solution in Ruby 1.8.7\n<code>",
  "  x[shift].upto(x[shift..-1]){|e| x << 1}\n  x\nend\n</pre>\n</div>", "  return\
    \ x.to_s.chars.drop(shift).reverse.each_char.to_a.reverse.join\nend", "  if x\
    \ != 0\n    x, remainder = divrem(shift, x)\n    x << shift\n    circular_shift(remainder,\
    \ shift)\n  end\n  x\nend\n</code>\n<|/ a tags=string,ruby,shift |>\n<| a tags=string,ruby,shift\
    \ |>\nIn case you want to shift only by one position, here's a recursive solution:\n\
    <code>", "  if shift > x.digits.length\n    shift = x.digits.length - shift\n\
    \  else\n    shift = x.digits.length - shift\n  x.digits.length, shift\n  x.digits.slice!(0,\
    \ shift)\n  x.digits.concat(x.digits.take_while {|e| e < 10 })\n  x.digits.reverse!\n\
    end", "  return x.to_s.split(//).reverse[shift].join\nend", "  x.zero? if shift\
    \ > x.length - 1 then '0' else x.to_s end\n  x = x.to_i\n  x = x.to_s(0).split(//)\n\
    \  x.reverse!\n  x.slice!(0, shift)\n  x.reverse!\n  x.join(\"\")\nend", "  if\
    \ x.zero?\n    '0'\n  elsif x < 0\n    \"#{-circular_shift(-x, shift).abs}\"\n\
    \  else\n    digits = []\n    digits_to_shift = x.digits.size - shift\n    digits[digits_to_shift]\
    \ ||= 0\n    digits[digits_to_shift] += digits[digits_to_shift].modulo(10)\n \
    \   digits[digits_to_shift].times do |i|\n      digits[digits_to_shift - i] ||=\
    \ 0\n      digits[digits_to_shift - i] += digits[digits_to_shift - i].modulo(10)\n\
    \    end\n    digits.join\n  end\nend", "  return x.reverse * shift\nend", " \
    \ if shift > x.length\n    x.split(\"\").reverse.each_with_index do |digit, i|\n\
    \      digit = digits[i - shift]\n      x[i] = digit\n    end\n  else\n    x.split(\"\
    \").each_with_index do |digit, i|\n      digit = digits[shift]\n      x[i] = digit\n\
    \    end\n  end", "  n = x.to_s.length\n  result = []\n  while n > 0\n    result.unshift(x.to_s.charAt(n\
    \ % n))\n    n /= 10\n  return result.reverse.join(\"\")\nend\n</code>\n<|/ a\
    \ tags=ruby dscore=2 |>\n<| a tags=ruby |>\n<code>", "  shift_digits = shift %\
    \ DIGITS_PER_WORD\n  digits_reversed = x.to_s.reverse\n  digits_reversed.reverse!\n\
    \  digits_reversed.slice!(0, shift_digits)\n  digits_reversed.slice!(-shift_digits,\
    \ shift_digits)\n  return digits_reversed\nend\n</code>\nNow we can do some testing!\n\
    <code>", "  if x < 0 || shift > length(x) then\n    error(\"invalid shift\")\n\
    \  end\n  local result = \"\"\n  for i = 1, length (x) do\n    local digit = x[i]\n\
    \    local carry = 0\n    for j = 1, shift do\n      digit = digit.rjust(digit:len()+1,\
    \ \" \")\n      carry = carry + digit:sub(1, 1):byte():borrow()\n      digit =\
    \ digit:sub(2)\n    end\n    if carry > 0 and i <= length (x) then\n      result\
    \ = result .. digit:sub(1, 1) .. carry:tostring()\n    else\n      result = result\
    \ .. digit:sub(1)\n    end\n  end\n  return result\nend", "  if x > 99\n    digits\
    \ = x.to_s.split('').reverse.map { |char| char.to_i }\n  else\n    digits = x.to_s.split('').map\
    \ { |char| char.to_i }\n  end\n  digits.rotate(shift).join\nend", "  return x.to_s[0...shift].rjust(int((x.to_s.length\
    \ + (shift.to_s.length - 1))/2), x.to_s[-1..-1])\nend", "  len = x.to_s.length\n\
    \  shift = shift % len\n  if shift == 0\n    return x\n  digits = x.to_s[0...len].split('')\n\
    \  digits.reverse.each_index { |i| digits[i] << shift }\n  digits.join('')\nend\n\
    end\n</code>\n<|/ a dscore=4 |>\n<| c |>\nNice! Works for me :)\n<|/ c |>\n<|\
    \ c |>\nThis solution has a bug with Ruby 2.4 if the value of `x` is larger than\
    \ a certain length.\n<|/ c |>\n<| a dscore=4 |>\nHere's a solution that I tested\
    \ in Ruby 1.8.7, 1.9.2, and 2.1.\n<code>", "  x = x.to_s\n  if shift > x.length\n\
    \    digits = x.reverse\n    shift = shift - x.length\n  else\n    digits = x\n\
    \  end\n  digits.reverse!\n  digits << shift\n  digits.reverse!\n  return digits.to_s\n\
    end", "  shift %= x.length\n  digits = x.digits.chars.reverse.slice!(0, shift)\n\
    \  x.digits = digits + digits.reverse.slice!(0, shift)\n  x\nend", "  shift =\
    \ shift || 0\n  len = x.length\n  return x.chars.map {|c|\n    (len + shift <\
    \ 0) ? c + x.chars.last : c + x.chars.first[len + shift]\n  }.join\nend", "  return\
    \ x.to_s(10).split(//).reverse.shift(shift).join\nend\n</cell>\n<text>\nThe following\
    \ function takes a string, representing the date in mm/dd/yyyy format and returns\
    \ it in dd/mm/yyyy format. Notice that the month is moved up or down by one depending\
    \ on whether it is an even or odd number of days:", "  x = x.to_i\n  shift = shift.to_i\n\
    \  digits = x.to_s(10)\n  digits = digits.chars\n  result = \"\"\n  \n  while\
    \ shift > 0\n    digits[shift..-1] += digits[-shift]\n    shift.downto(0) unless\
    \ shift > digits.length\n  end\n  \n  digits.reverse!\n  result.concat(digits.join(''))\n\
    \  result\nend\n</code>\n<|/ a dscore=1 |>\n<| a |>\nThe easiest way is to use\
    \ Array#cycle\n<code>\n(1..999).cycle.to_a.reverse.join.to_i\n</code>\n<|/ a dscore=1\
    \ tags=ruby,string |>\n<| a tags=ruby,string |>\nI would do something like this\
    \ (where number is the number you want):\n<code>", "  if shift == 0\n    return\
    \ x\n  else\n    digits = x.to_s(10).split(//)\n    shift -= 1\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits = digits.join.to_s(10).split(//)\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse",
  "  shift = [0, shift, 0].max\n  digits = x.to_s.reverse.scan(/.(?=\\d)/).map(&:first)\n\
    \  digits.reverse.scan(/.(?=\\d)/).map { |d, i| d.insert(0, digits[i + shift])\
    \ }.join(\"\")\nend", "  return x.to_s.reverse.sub(/(.)(.)/, \\2\\\\1/ ).sub(/\\\
    2(.)(.)/, /\\2\\1\\4/).sub(/\\3(.)(.)/, /\\3\\1\\4/).sub(/\\4(.)(.)/, /\\4\\1\\\
    4/)\nend", "  x.slice!(0, shift - x.length)\n  x\nend", "  return x.digits[0,\
    \ x.digits.size - shift.abs] + \\\n    circular_shift(x.digits[shift.abs:], shift.abs).digits.reverse\n\
    end", "  digits = x.to_s.split(\"\").reverse.map { |digit| digit.to_i }\n  digits.each_with_index\
    \ { |d, i| digits[i] = digits[i] - shift + d.to_i }\n  digits.reverse.join(\"\"\
    )\nend\n</code>\n<|/ a dscore=4 tags=string,ruby,number-formatting |>\n<| c |>\n\
    Ruby does string interpolation so you don't need to use backslashes for escapes.\n\
    <|/ c |>\n<| a dscore=3 |>\nThe most obvious approach is:\n<code>\nx = \"123456\"\
    \nx.gsub(/(?<=[0-9])(?=[0-9]*$)/, '').to_i", "  x -= x.to_i.to_s.reverse[shift.to_i]\n\
    \  return x.to_i\nend", "  if shift > x.length\n    x.slice!(1..shift+1)\n  else\n\
    \    x.slice!(1..shift)\n    x.slice!(0, shift)\n  end\n  x.reverse\nend", " \
    \ digits = x.to_s.chars.reverse\n  digits = digits[shift..-1] + digits[0..-shift-1]\n\
    \  return digits.reverse\nend", "  shift = shift < 0 ? shift * -1 : 0\n  digits\
    \ = x.digits.reverse", "  return x.reverse.gsub(/(.)(.*)/, \"\\\\1#{shift}\\\\\
    3\").gsub(/(?<=[a-z])(?=\\d)/i, '#').reverse\nend", "  if shift > x.digits.length\n\
    \    x.digits.reverse!\n    shift = shift - x.digits.length\n  end\n  return x.digits.to_a[x.digits.length\
    \ - shift] + x.digits.to_a[shift]\nend", "  n = x.to_s.length\n  shifted = x.to_s.reverse.slice(shift,\
    \ n).reverse\n  x.to_s.reverse + shifted\nend", "  return x.to_s[0, shift..x.to_s.length]\n\
    end", "  return x.to_s.reverse.sub(/.(?=..*)..*$/) { |s| s.reverse * shift }\n\
    end", "  shift_digits = \"\"\n  shift.times { shift_digits << x }\n  x.times {\
    \ shift_digits >> shift }\n  shift_digits\nend", "    str = x.to_s\n    shift\
    \ = shift % str.length\n    if shift == 0\n        return str\n    num = str.slice!(0,\
    \ shift)\n    num = num + str.slice!(shift, str.length)\n    return num\nend",
  "  result = \"\"\n  while x.to_s.length < shift\n    result << x.to_s\n    x >>=\
    \ shift\n  end\n  result << x.to_s[0...shift]\n  result\nend", "  digits = to_integer(x)\n\
    \  shift = to_integer(shift)\n  if shift > digits.length\n    digits = digits.digits.reverse.slice(shift)\n\
    \    shift = shift - digits.length\n  else \n    digits = digits.digits.slice(shift)\n\
    \  result = \"\"\n  digits.each do |d|\n    result = result.succ + d.to_s\n  end\n\
    \  return result\nend", "  x.to_s.reverse.chars.take(shift).join\nend\n</code>\n\
    <|/ a |>\n<| a tags=ruby dscore=0 |>\n<code>\nrequire 'csv'", "  return x.to_s.rjust(x.to_s.size,\
    \ shift)\nend\n  ", "  x_digits = x.to_s.reverse\n  shift_digits = shift.to_s\n\
    \  x_digits = (shift_digits + x_digits).chop.reverse\n  x_digits.reverse!\n  x_digits.reverse!\n\
    \  return x_digits\nend", "  digits = x.to_s.chars\n  digits_count = digits.size\n\
    \  return digits.reverse if shift > digits_count else digits.reverse.slice(shift,\
    \ digits_count)\nend", "  return x.modulo(10**shift)\nend", "  return x.gsub(/.../)\
    \ { |s| s[0...shift][0...(shift - s.length)] }\nend", "    x.to_s.split(\"\").reverse.each_slice(shift).map(&:join).join\n\
    end", "  x.to_s.reverse.slice(shift, x.to_s.size).reverse.join\nend", "  if shift\
    \ > 0 then\n    len = 1\n  else\n    len = -1\n  end\n  s = x\n  i = 2\n  while\
    \ i < len do\n    s = 10 * s + x\n    i = i + 1\n  end\n  s = 10 * s - x\n  return\
    \ s\nend", "  x_s = x.to_s\n  shifted = x_s.reverse[x_s.size.zero? || shift ==\
    \ 0 : x_s.size+shift-1..-1]\n  x_s.reverse!\n  x_s + shifted\nend", "  return\
    \ x.to_s.chars.reverse.each.rotate(shift).join\nend", "  x.zero? if shift <= 0\n\
    \  x = x.abs\n  len = x.length\n  if len == shift\n    x\n  elsif len > shift\n\
    \    x.slice(len - shift, len).reverse\n  else\n    x.slice(-shift)\n  end\nend",
  "    digits = x.to_s.length\n    return x.to_s.reverse.slice(shift, digits)\nend",
  "  n = x.to_s.length\n  rev = x.to_s[0...n]\n  digits = \"\"\n  for i in 0...n\n\
    \    digits = digits + rev[i-shift]\n  return digits\nend\n</code>\n<|/ a tags=ruby\
    \ dscore=0 |>\n<| c |>\n\"Circular shifting the digits is equivalent to rotating\
    \ the digital numbers by 180 degrees\" - this is not correct. While a rotation\
    \ by 180 degrees does yield a circular shift, \"circular rotation\" would mean\
    \ that all digits are shifted 180 degrees rather than just the one that is \"\
    behind\" the previous one. For example, the number `12` would become `\"24\"`\
    \ (rotated 180 degrees) and `\"35\"` (rotated 180 degrees) instead of `\"5\"`\
    \ and `\"6\"` (rotated 180 degrees)\n<|/ c |>\n<| c |>\nThat is true. Circular\
    \ rotation is usually applied to the entire number, not individual digits.\n<|/\
    \ c |>\n<| a |>\nThe code below is very similar to Amit Joki's solution.  But\
    \ it also works if x is negative.\n<code>", "  n = x.length\n  s = x.to_s(10)\n\
    \  return s[0...(n >> shift)].to_s + s[((n >> shift) - 1)]\nend", "  return x.to_s.split(\"\
    \").reverse.inject(\"\") do |result, digit|\n    digit = digit.to_i(10)\n    digit\
    \ = digit >> shift if digit > 0\n    digit = digit << shift if digit < 0\n   \
    \ result + digit.to_s\n  end\nend\n</code>\nNow you just need to find the largest\
    \ digit in the number and subtract 1 from it to get the next largest digit:\n\
    <code>", "  return x.digits.reverse[x.digits.size - 1 - shift]\nend", "  result\
    \ = \"\"\n  while x >= 0\n    digit = x % 10\n    x /= 10\n    result << digit\n\
    \    result << shift\n    shift -= 1\n  end\n  result.reverse\nend", "  x += \"\
    0\"\n  len = x.length\n  return len > shift ? x.reverse[0..(len - shift)].to_s\
    \ + x.reverse[shift..len].to_s : \"0\"\nend\n</code>\n<|/ a |>\n<| c |>\nI'm confused\
    \ about your first paragraph and last paragraph. Can you explain what is going\
    \ on?\n<|/ c |>\n<| c |>\nAren't you only getting the digits of x that are less\
    \ than shift?\n<|/ c |>\n<| c |>\nYes. That's why in the \"Circular Shift by n\"\
    \ section of the answer, I wrote `digits = x.to_s.scan(/\\d+/).select {|x| x.to_i\
    \ < shift}`\n<|/ c |>\n<| c |>\nThis answer is way more efficient than the selected\
    \ answer.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails dscore=3 |>\nHere is my solution.\
    \ It works for positive integers, negative integers and floats.\n<code>", "  shift\
    \ == 0 ? x : x.to_s.split(\"\").reverse.join << shift\nend\n</cell>\n<cell>",
  "  digits = x.to_s.reverse\n  x.to_s.split(//).map.with_index { |digit, i| digits[i]\
    \ = (digit.to_i + shift).to_s }.join(//)\nend\n</code>\n<|/ a dscore=1 |>\n<|\
    \ c |>\nthanks, I will try to understand your solution, now I understand that\
    \ there is a string method for this but i never used it\n<|/ c |>\n<| c |>\nI\
    \ updated my answer with a new example and explained how the code works.\n<|/\
    \ c |>\n<| a dscore=1 |>\n<code>", "  digits = x.digits.reverse if shift > x.digits.length\
    \ else x.digits\n  x = digits.join(\"\", shift, digits.length)\nend", "  x.zero?\
    \ ? x : x.succ << shift\nend", "  # x must be an integer.\n  raise TypeError,\
    \ \"Expected an integer.\" unless x.is_a?(Integer)\n  raise ArgumentError, \"\
    Expected shift >= 0.\" unless shift >= 0\n  len = x.length\n  digits = []\n  remainder\
    \ = 0\n  x.to_s.each_char {|c|\n    digits.push c.to_i\n  }\n  digits.push 1 if\
    \ len < shift else 0\n  for i in 1..(shift - 1).to_i\n    digits[len-i-0] = digits[len-i-1]\n\
    \    digits[len-i-1] = digits[len-i-2]\n    digits[len-i-2] = digits[len-i-3]\n\
    \    digits[len-i-3] = digits[len-i-4]\n    digits[len-i-0] = digits[len-i-1]\n\
    \    digits[len-i-1] = digits[len-i-2]\n    digits[len-i-2] = digits[len-i-3]\n\
    \    digits[len-i-3] = digits[len-i-4]\n  end\n  digits[(shift - 1).to_i] = remainder\n\
    \  digits.join \"\"\nend\n</code>\n<|/ a tags=ruby,algorithm,math,ruby-on-rails\
    \ |>\n<| a tags=ruby,algorithm,math,ruby-on-rails |>\nFor a non-recursive solution,\
    \ you could use something like this:\n<code>", "  shift = shift.to_i if shift.is_a?(Integer)\
    \ rescue shift\n  x           = x.to_i rescue x\n  res = []\n  while x.to_i >\
    \ 0\n    x, r = divmod(x, 10)\n    res.insert(0, r.to_s)\n  end\n  res << res[shift]\
    \ if shift > 0\n  res.reverse!\n  res.join('')\nend", "  return x[shift].to_s\
    \ + x[*0..-shift].to_s\nend", "  x = x.to_s\n  if shift > x.length\n    x.reverse\n\
    \  elsif shift < 0\n    raise ArgumentError\n  else\n    result = ''\n    x.reverse.each_with_index\
    \ do |digit, index|\n      digit = digit.to_s(10)\n      result = digit[0,(shift\
    \ * index)+shift] + result\n    end\n    result.reverse\n  end\nend", "  n = String.new(x)\n\
    \  n.slice!(0, shift)\n  n.slice!(0, shift - x.size)\n  n\nend", "  x.slice!(0,\
    \ x.length).reverse!\n  x = (x * 10).to_s + '0' * shift\n  x.slice!(0, shift)\n\
    end", "  len = 0\n  while shift > len\n    len += 1\n  end\n  return x.to_s.insert(len\
    \ - shift, x.to_s.delete(len - shift))\nend", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    digit = digit.to_s(36).rjust(shift, \"0\")\n    s << digit\n\
    \  end\nend\n</code>\n<|/ a |>\n<| a tags=ruby,string,ascii |>\nI do not see where\
    \ you convert the string to ASCII. For example, if the string is \"hello\" then\
    \ its ASCII is [97, 104, 101, 108, 108, 111].\n<|/ a dscore=1 |>\n<| c |>\nThis\
    \ looks like a good idea. Now I need to figure out how to get it to work. I was\
    \ trying to use ASCII, but I guess I didn't use it right. I'll give it another\
    \ shot.\n<|/ c |>\n<| c |>\nI added the code I used to convert each character\
    \ in the string to a number. I think I was trying to use ASCII incorrectly. I\
    \ think I'm missing something about the way Ruby uses ASCII.\n<|/ c |>\n<| a |>\n\
    Here is a version that uses String#gsub:\n<code>", "    digits = x.to_s.reverse[shift..-1].split(//)\n\
    \    shift = x.to_s.reverse[shift..-1].split(//).length\n    digits[0..shift].concat(digits[shift+1..-1])\n\
    end\n</code>\n<|/ a tags=ruby dscore=1 |>\n<| c |>\nI like how you think about\
    \ the problem and you break it down step by step.\n<|/ c |>\n<| a dscore=1 tags=ruby\
    \ |>\nI believe that this solution is quite efficient and readable:\n<code>",
  "  return x.to_s.reverse[x.to_s.size - shift.to_s.size + x.to_s.size % shift.to_s.size]\n\
    end", "  if x > shift\n    x -= shift\n    x *= 10\n    x += x % 10\n  end\n \
    \ x\nend", "  return x.to_s.reverse.gsub(\"(?<=.{#{shift}})(?=.{#{-shift}})\"\
    , '') if x.to_s.length > shift\n  x.to_s\nend\n</code>\nThis code is similar to\
    \ Ruby's built-in String#rotate, but without the limitations. It also works on\
    \ Ruby 2.0 and up.\n<|/ a tags=ruby,string dscore=5 |>\n<| c |>\nThis is a great\
    \ solution. Perfect for my needs. Thank you!\n<|/ c |>\n<| c |>\nI ran into some\
    \ problems with it when dealing with large numbers (`Bignum`) where it would return\
    \ `nil` if `x` was `0`. In that case, I used `return x.to_s.reverse.gsub(/(?<=.{#{shift}})(?=.{#{-shift}})/,\
    \ '')[1..-1] if x.to_s.length > shift`\n<|/ c |>\n<| c |>\nThanks for the addition.\
    \ I'll try it out later.\n<|/ c |>\n<| c |>\nGreat solution, great work!\n<|/\
    \ c |>\n<| c |>\nAwesome solution. Thanks!\n<|/ c |>\n<| a |>\nHere's a solution\
    \ using String#split and Array#join.\n<code>", "  x_digits = x.to_s.reverse.split('')\n\
    \  shift_digits = shift.to_s.reverse.split('')\n  shift_digits.shift\n  new_x_digits\
    \ = []\n  while shift_digits.length > 0\n    new_x_digits << shift_digits.shift\n\
    \  new_x_digits.reverse!\n  new_x_digits << x_digits.shift\n  new_x_digits.join\n\
    end\n</pre>", "  x.to_i.split(//).reverse.each.with_index.map { |v, i| v * 10**shift\
    \ > 10 ? x.to_i * 10**shift : v * 10**shift }.join\nend", "  # Return string representing\
    \ integer x with given shift.\n  num = x.to_s\n  if num.length <= shift\n    num\n\
    \  else\n    num = num.rjust(shift, \"0\")\n    num = num.substr(0, num.length\
    \ - shift)\n    num.to_s\n  end\nend", "  return x\nend", "  ret = x.to_s\n  if\
    \ shift.zero?\n    ret\n  elsif shift.zero? && x.zero?\n    self\n  else\n   \
    \ digits = x.digits(base)\n    shift = shift.to_i\n    digits = digits[0...-shift]\
    \ if shift < 0\n    digits.join(base.to_s)\n  end\nend", "  if shift > x.length\n\
    \    x\n  else\n    x.sub(shift, x.length)\n  end\nend\n</code>\n<|/ a dscore=4\
    \ tags=ruby,algorithm,python,language-features,javascript |>\n<| c |>\nI wish\
    \ I could +2 this for the use of a regex in the substitution!\n<|/ c |>\n<| c\
    \ |>\nThis doesn't work for negative integers though: `\"-5\".circular_shift(1).to_s\
    \ # => \"-51\"`\n<|/ c |>\n<| c |>\nYou're right! My solution was too simple.\
    \ I forgot that negative integers wouldn't be handled by the method.\n<|/ c |>\n\
    <| c |>\n`x.sub(/([a-z])/) { $1.succ*$1.length }` would handle negative integers\
    \ in that case.\n<|/ c |>\n<| c |>\nI was thinking about that, but then I thought\
    \ that it would require a second substitution on `$1` to turn it back into a string.\n\
    <|/ c |>\n<| a tags=ruby,algorithm,python,language-features,javascript |>\nHere's\
    \ a Ruby implementation:\n<code>", "    digits = x.to_s.split(//)\n    digits.reverse.each_index\
    \ { |i| digits[i] << (shift % digits.size) }\n    digits.join(//).to_s\nend\n\
    </code>\nThis function is probably faster than the one you proposed, but you can\
    \ also use it as it is to reverse digits in the string returned by number.to_s.\n\
    <|/ a tags=ruby,math,algorithm,ruby-on-rails,ruby-on-rails-3 dscore=2 |>\n<| c\
    \ |>\nYour function doesn't work. `circular_shift.call(123,2)` returns `321`.\
    \ It should be `21`\n<|/ c |>\n<| c |>\n: I saw that and fixed it a couple of\
    \ minutes ago and now I see that you already fixed it, so I guess I shouldn't\
    \ have bothered ;)\n<|/ c |>\n<| c |>\n: I added a solution that doesn't require\
    \ any conversion to string and that also works with floats, in case that's a requirement\
    \ for you.\n<|/ c |>\n<| c |>\nIt should be noted that this algorithm is **O(n)**\
    \ and therefore not suitable for large numbers. In fact, it should be avoided\
    \ for performance reasons.\n<|/ c |>\n<| c |>\n: I agree with you. This algorithm\
    \ is actually the one I proposed in my answer that doesn't require string conversion.\n\
    <|/ c |>\n<| a tags=ruby,math,algorithm,ruby-on-rails,ruby-on-rails-3 |>\n<code>\n\
    irb(main):001:0> num = 12345\n=> 12345\nirb(main):002:0> num.to_s.reverse.chars.take(3).to_i\n\
    => 54321\n</code>\n<|/ a dscore=2 |>\n<| a |>\nFor integers smaller than a million\
    \ (i.e. the range in which Ruby handles integers) you can use this approach:\n\
    <code>\ndigits = num.to_s.split(//)\ndigits.reverse.each_index { |i| digits[i]\
    \ << shift % digits.length }\ndigits.join(//).to_i\n</code>\nThe idea is to reverse\
    \ the digits and then use the first three characters. This is fast because digits.length\
    \ is always smaller than the largest integer you can have.\nFor numbers bigger\
    \ than a million, the performance of this approach will be too bad, so the other\
    \ answer is better. Also, if speed is really important you might want to consider\
    \ converting to a string first, which will make this solution slower than the\
    \ others.\nEDIT:\nI did some tests and the code above is ", "  x.slice!(0, shift)\n\
    \  x.slice!(shift, x.length)\n  x\nend\n</code>\nI did not understand why this\
    \ happened. I thought that the slice method was the problem, but it works fine\
    \ if the code is commented out. Why does it work with that method but not with\
    \ the one I wrote?\n<|/ q |>\n<| a dscore=2 tags=ruby,methods |>\nYou missed a\
    \ dot in your method definition:\n<code>", "  # Shift argument must be a non-negative\
    \ integer.\n  if shift.negative? || shift < 0\n    raise ArgumentError, \"shift\
    \ must be non-negative integer\"\n  # Shift argument must not be greater than\
    \ number of digits in x.\n  return x.to_s.rjust(x.to_s.length - shift, x.to_s.chars[0...shift])\n\
    end\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis was an excellent contribution since\
    \ it allows the user to specify a different radix.\n<|/ c |>\n<| c |>\nI'm surprised\
    \ that there isn't a more elegant way to do this... especially since ruby has\
    \ already `to_s` and `chr`.\n<|/ c |>\n<| c |>\nThe radix is irrelevant. `to_s`\
    \ and `chr` are just two ways of representing a number in base 10 and `to_i` and\
    \ `to_f` convert a string to an integer/float.\n<|/ c |>\n<| c |>\nYes, but they\
    \ don't convert numbers to base 26.  If you input `26` you get `A`, and if you\
    \ input `A` you get `26`.  It doesn't do any conversion to base 26 when dealing\
    \ with numbers or strings.\n<|/ c |>\n<| c |>\nThat's not the point of the code.\
    \ The point was to demonstrate that `to_s` and `chr` are the way to convert between\
    \ bases 10 and 26. `to_i` and `to_f` are not for converting numbers or strings\
    \ to base 26.\n<|/ c |>\n<| a dscore=2 |>\nI was looking for how to do this, I\
    \ didn't want to convert integers to strings. I wanted a way to shift a number\
    \ without converting it to a string. I thought the easiest way would be to use\
    \ the modulo operator like so:\n<code>\nx = 100\ny = 200\nx % y\n</code>\nThis\
    \ gives me 50, because 100 is divisible by 200. So to get the second number, I\
    \ just subtract the modulus of x by y and then add that to x. \n<code>\nx = 100\n\
    y = 200\nz = x - (x % y)\nx + (z)\n</code>\nThis works, and it's super simple.\
    \ The modulus operator returns the remainder of the division operation (x % y).\
    \ So the first line of code subtracts that remainder from x and stores it in z.\
    \ Then, it adds z back to x, giving me the second number.\n<|/ a tags=ruby,base-conversion\
    \ |>\n<| c |>\nThis is exactly what I was looking for. Thanks :)\n<|/ c |>\n<|\
    \ a |>\nI'm surprised that there isn't a more elegant way to do ", "  digits =\
    \ x.to_s.split(//).reverse\n  shifted_digits = []\n  shifted_digits.concat digits[shift..-1]\
    \ if shift < digits.length else digits.drop(shift)\n  shifted_digits.join \"\"\
    \nend", "  # Shift the digits of the integer x and return the string result.\n\
    \  x *= 10**shift\n  digits = x.to_s.reverse.split('')\n  digits.inject('') {\
    \ |s| s << shift }\nend", "  if shift > x.length\n    return x.to_s[0..length\
    \ + shift - 1]\n  else\n    x <<= shift\n    y =\n    result =\n    i =\n    shift\
    \ =\n    while true\n      i <<= 1\n      i += 1\n      result << x[i]\n     \
    \ if (i + shift) > x.length\n        return result\n      else\n        shift\
    \ -= i\n      end\n    end\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    Apologies for the late reply - I haven't had a chance to try this out, but I've\
    \ tried your method (thank you for that) and it comes up with an \"undefined method\"\
    \ error on the line \"def circular_shift(x, shift)\". Can you clarify why this\
    \ might be happening?\n<|/ c |>\n<| c |>\nHave you tried renaming the method from\
    \ `circular_shift` to `circular_shift2` or something? If not, try that. Otherwise,\
    \ I'm out of ideas. It may have something to do with the fact that you have a\
    \ local variable `shift` but also a global one `i`.\n<|/ c |>\n<| c |>\nThanks\
    \ for the suggestion, unfortunately that didn't help unfortunately. I think I've\
    \ got it down to an issue with the way my Ruby install works, I think. My local\
    \ install (Ruby version 1.9.2) works, but my colleague's version (Ruby version\
    \ 1.8.7) does not.\n<|/ c |>\n<| c |>\nThe reason for the difference is that Ruby\
    \ 1.8 is a very old version. The latest version is 1.9.3. If you're going to use\
    \ Ruby 1.8, you should upgrade to 1.93. I'd highly recommend installing RVM so\
    \ you can easily switch between different versions of Ruby.\n<|/ c |>\n<| a dscore=0\
    \ |>\nThe reason for the difference is probably that the version on your computer\
    \ is different than the one that works on your colleague's computer. I'd highly\
    \ recommend installing RVM so you can easily switch between different versions\
    \ of Ruby.\n<|/ a tags=ruby,circular-reference |>\n<| c |>\nHi Mark, I appreciate\
    \ your answer. I think I've got it down to an issue with the way my Ruby install\
    \ works, I think. My local install (Ruby version 1.9.2) works, but my colleague's\
    \ version (Ruby version 1.8.7) does not.\n<|/ c |>\n<| c |>\nThanks for your answer\
    \ Mark, I'm glad you got it solved though.\n<|/", "  return x.reverse.slice(1..-1\
    \ * shift)\nend", "  x.slice!(0, shift)\n  x.reverse!\n  x.slice!(0, shift)\n\
    \  x\nend", "  x = x.to_s\n  x.chars.reverse.each_with_index do |char, i|\n  \
    \  x.insert(i, (char + shift).chr.to_s)\n  end\nend", "  if x > 0\n    str = x.to_s\n\
    \    shiftstr = \"\"\n    (str.length / 2).times do |i|\n      shiftstr = str.slice!(0,\
    \ i) + shiftstr + str.slice!(0, i)\n    end\n    return shiftstr.reverse\n  elsif\
    \ x < 0\n    return \"#{-1 * x}#{circular_shift(-1 * x, shift)}\"\n  end\nend",
  "  x.to_s.split(//).reverse[0...shift].join(\"\").split(//)\nend\n</pre>", "  return\
    \ x.to_s.reverse.gsub(/((..)|\\A)\\1*/, '\\1'.dup * shift)\nend", "  len = x.length\n\
    \  return x.chars.reverse.first(len).inject(\"\") { |s,i| s << i + len + shift\
    \ }\nend\n</code>\n<|/ a dscore=0 tags=ruby |>\n<| a |>\n<code>", "  shift = shift\
    \ || 0\n  len = get.length(x)\n  remainders = len % shift != 0 ? Math.ceil Math.floor\
    \ Math.round Math.truncate Math.floor Math.round\n  begin = len / shift + 1\n\
    \  return x.slice(0, begin).reverse * remainders x % shift * Math.pow(10, shift)\n\
    end", "  return x.to_s.split(\"\").reverse.slice(shift, (-shift || 0).to_i).reverse.join\n\
    end", "  x = x.to_s\n  if shift > x.length\n    x.reverse!\n    shift = 0\n  end\
    \ # shift > x.length\n  x = x.reverse!\n  (0...x.length).step(shift).each do |i|\n\
    \    x = x.insert(i, x[i])\n  end\n  x.reverse!\n  x\nend", "  x.to_s.reverse.slice(shift,\
    \ x.to_s.length).join\nend", "  return x.to_s.reverse[shift.abs].to_s\nend", " \
    \ digits = x.to_s.reverse.to_i\n  digits.reverse! if shift > digits.size\n  digits.slice!(shift,\
    \ digits.size) + digits.slice!(digits.size..-1)\n  digits.reverse! if shift >\
    \ digits.size\n  digits.reverse\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis\
    \ code has a bug in it, because if `shift` is greater than the size of the digits\
    \ of `x`, it reverses the digits of `x` twice.\n<|/ c |>\n<| c |>\n, thanks for\
    \ pointing that out. I've updated my answer.\n<|/ c |>\n<| a tags=ruby,math,algorithm\
    \ dscore=3 |>\nI know this answer has been marked correct and voted up, but for\
    \ anyone who is looking for an efficient implementation I wrote this little algorithm:\n\
    <code>", "    if shift > string_length(x)\n        return reverse x\n    offset\
    \ = x.slice!(0, shift)\n    result = \"\"\n    i = 0\n    while i < shift\n  \
    \      result << offset\n        i += 1\n    result << x\n    return result\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis won't work. First you get this\
    \ error `ArgumentError: wrong number of arguments (1 for 0)`. Second, `reverse`\
    \ converts the integer to a string, which you then reverse and convert back to\
    \ a number. This will also return an error, since you cannot reverse an integer.\n\
    <|/ c |>\n<| a tags=ruby,string,number-formatting,reverse,integer dscore=2 |>\n\
    Here is a possible solution. First of all I suggest to store your numbers in an\
    \ array like [\"123\", \"456\", ..., \"999\"]. Then I suggest to loop through\
    \ the array, concatenate the elements, and convert to an integer like this:\n\
    <code>", "  n = x.abs\n  x /= n\n  x = x.floor\n  x -= x * (shift / n)\n  x =\
    \ x.floor\n  x -= x * (shift / n).abs\n  return x.to_s\nend", "  digits = x.to_s.reverse.to_a.reverse\n\
    \  digits.reverse! unless shift > digits.size\n  digits.reverse!(0, shift)\n \
    \ digits.join\nend", "  n = x.length\n  s =  []\n  i = 1\n  until i >= n\n   \
    \ s[i] = x.charAt(i)\n    i += 1\n  i = 0\n  until i >= shift\n    s[i] = x.charAt(i\
    \ + shift)\n    i += 1\n  s[s.length] = x.charAt(i)\n  return s.reverse\nend",
  "  shift = [0, shift].max\n  digits = x.to_s.reverse.split('')\n  digits[shift..-1]\
    \ = digits[shift..-1].to_a.rotate!(shift).to_s.reverse\n  digits.join('')\nend",
  "  x = x.to_s\n  shift = (shift > x.size) ? x.size - shift : shift\n  shift = x.size\
    \ - shift\n  x.reverse[shift..-1]\nend\n</pre>\n</div>\n</div>\n</div>\n</div>\n\
    <div id=\"footer\">\n<div id=\"footer-text\">\nLast updated 2021-02-08 20:09:24\
    \ UTC\n</div>\n</div>\n<link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\"\
    \ integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\"\
    \ crossorigin=\"anonymous\">\n</body>\n</html>", "  x.zero? or raise \"Argument\
    \ to 'circular_shift' must be a positive integer.\"\n  x.to_s.length == 1 or raise\
    \ \"Argument to 'circular_shift' must be an integer.\"\n  x.to_s.length <= shift\
    \ or raise \"Argument to 'circular_shift' must be less than the number of digits\
    \ in x.\"\n  s = x.to_s\n  s.slice!(-shift, shift)\n  s\nend", "  return x.to_s.reverse.slice(shift,\
    \ x.to_s.length).reverse\nend", "  x.to_s.split(\"\").reverse.inject(\"\"){|s,s|\
    \ s.gsub(/(.)(.)/,'\\1'+((shift.zero? ? \"1\" : \"0\")+\\2).reverse.to_s) }.reverse.split(\"\
    \").inject(\"\"){|s,s| s.gsub(/(.)(.)/,'\\1'+(shift.zero? \\2+\"\" : \\2+\".\"\
    ).to_s) }.reverse\nend", "  if shift < 0\n    x, shift = x, -shift\n  x = x.to_s\n\
    \  if x.chars.length <= shift\n    x.chars.reverse!\n  elsif shift > x.chars.length\n\
    \    x.chars.slice!(shift)\n  else\n    x.chars[0...shift].unshift x.chars[shift]\n\
    \  end\n  return x.to_s\nend", "  x = x.to_s\n  if x.length < shift\n    x.gsub!('^',\
    \ x.slice!(0, -shift))\n    return x\n  x.slice!(x.rindex!('-', 0, shift))\n \
    \ x.slice!(0, shift)\n  x\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n\
    Another way:\n<code>", "  n = x.length\n  x.slice!(0, shift)\n  x.slice!(0, shift)\
    \ if n < shift \n  x.reverse! if shift > n \n  x \nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| a dscore=4 |>\n<code>\nmodule StringEx\n  def rotate_right(n)\n    self[0,\
    \ n].join(self[n..-1])\n  end\nend\n</code>\nThe \"rotate right by n\" functionality\
    \ is exactly the same as the functionality of the rotate_right method in the String\
    \ module, but with more functionality. For example, you could use String#slice\
    \ to find the right position of the nth character, and replace that character:\n\
    <code>\nmy_string = \"Hello\"\nmy_string.slice_before(\"e\").first(2).reverse.insert(0,\
    \ \"z\")", "  return x.to_s.reverse.chars.rotate[0...shift].join\nend", "  x.split(\"\
    \").reverse.inject(\"\"){|s, t| s << shift ^ t}.reverse\nend\n</code></pre>\n\t\
    \t\t\t</section>\n\t\t\t</section>", "  x.to_s.chars.reverse.shift(shift).join\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis is amazing - thanks for the great\
    \ answer!\n<|/ c |>\n<| a tags=ruby,string,ruby-on-rails,ruby-on-rails-3 |>\n\
    <code>", "    digits = x.to_s.chars\n    digits.reverse!", "  \n  # Handle negative\
    \ numbers.\n  if x < 0\n    return -circular_shift(-x, shift)", "  result = \"\
    \"\n  digits.reverse.each do |x|\n    result << x if shift > x.length\n    shift\
    \ -= x.length\n  end\n  result.reverse\nend\n</code>\n<|/ a dscore=1 |>\n<| c\
    \ |>\nHi Gareth, can you explain in details the purpose of the code above?\n<|/\
    \ c |>\n<| c |>\nThanks Gareth, can you please explain the purpose of digits.reverse.each?\
    \ what exactly is the purpose of reversing an array? why don't we reverse the\
    \ string directly as string.reverse? also why does the reverse function return\
    \ an array? thanks\n<|/ c |>\n<| c |>\nIt's an array-of-strings method. `Array.reverse`\
    \ reverses its argument, `Array.reverse!` mutates its argument. As I understand\
    \ it, `digits` represents your base number. You're given an `int` so you can just\
    \ `digits` instead. `digits` will always have leading zeros.\n<|/ c |>\n<| a |>\n\
    It has some functional programming concepts in mind. For example:\n<code>\n[\"\
    1\", \"1\", \"1\", \"1\"].reverse\n</code>\nreturns an array with [\"1\", \"1\"\
    , \"1\", \"1\"] in its original order. It does not return \"21\"\n<|/ a dscore=0\
    \ tags=ruby |>\n<| c |>\nNo, it does not return `\"21\"`. It returns an array\
    \ with four elements, each of which holds a string. `[\"1\", \"1\", \"1\", \"\
    1\"].reverse.map(&:to_s).inspect` shows that `[\"1\", \"1\", \"1\", \"1\"]` is\
    \ returned as its original order.\n<|/ c |>\n<| a tags=ruby dscore=0 |>\n<code>",
  "  if shift == 0\n    x\n  else\n    mod = x % shift\n    x -= mod\n    x + (mod\
    \ * shift).to_s\n  end\nend\n  ", "  x.to_s.reverse.split(\"\").each_with_index\
    \ do |digit, index|\n    digit = digit.to_i(10)\n    digit = (digit >> shift)\
    \ | (digit << (32 - shift))\n    digit = (digit & 2**(32 - shift)) != 0 ? digit\
    \ : digit >> shift\n    x.to_s.reverse[index] = digit.to_s(10)\n  end\n  x\nend",
  "  str = \"\"\n  i = 0\n  while i < shift \n    str = str + x[i]\n    i = i + 1\n\
    \  return str\nend", "  if shift == 0\n    \"\"\n  elsif shift > length(x)\n \
    \   chars(x, shift).reverse\n  else\n    chars(x, shift - 1) * shift + chars(x,\
    \ shift - shift)\n  end\nend\n</pre>\n<p>\nLet's now move on to our next exercise.\
    \ Let's reimplement the\n<code>reverse</code> method of <code>String</code>.\n\
    </p>\n<p>\nA simple recursive implementation would be to just move each digit\n\
    backwards until you reach the beginning of the string or run out of the\ndigits.\n\
    </p>\n<p>\n<code>reverse</code> can be implemented as follows:\n</p>\n<pre class=\"\
    code\">def reverse\n  return unless @length == 0\n  chars.reverse * reverse\n\
    end\n</pre>\n<p>\nAs you can see, it just calls itself twice and concatenates\n\
    the result to the current string.\n</p>\n<p>\nLet's see how this works for a few\
    \ test cases:\n</p>\n<pre class=\"code\"># empty string\n\"\".reverse", "  # Shift\
    \ by 1 is simple (just return the integer as-is).\n  if shift == 1\n    return\
    \ x", "  if x > 0\n    digits = x.to_s.chars.reverse\n    shift = shift.to_i\n\
    \    x = x.to_i\n    digits.each_index {|i|\n      x = (x + shift.to_s).to_i\n\
    \      digits[i] = \"0\" if digits[i] >= 10 else digits[i]\n    }\n    digits.reverse!\n\
    \    digits.join\n  else\n    digits = x.to_s.chars\n    shift = shift.to_i\n\
    \    x = x.to_i\n    digits.each_index {|i|\n      x = x.to_i - shift.to_i\n \
    \     digits[i] = \"9\" if digits[i] >= 10 else digits[i]\n    }\n    digits.reverse!\n\
    \    digits.join\n  end\nend", "  shift = shift < 0 ? shift + x.size : shift ||\
    \ 0\n  return x.reverse.slice(shift, -1).reverse.join\nend", "    digits, rest\
    \ = x.divmod(shift)\n    return \"\" if rest == 0 else digits * shift + rest\n\
    end", "  x.to_s.split(\"\").reverse[0..shift].join(\"\") + x.to_s.split(\"\").reverse[shift..-1].join(\"\
    \")\nend", "  s = String(x)\n  result = s\n  while s.length > shift \n    s, r\
    \ = s[0..(s.length-1)].rjust([shift..s.length], s), r[0..(shift..s.length)].rjust([s.length],\
    \ r)\n    result = r\n  end\n  result\nend", "  if shift > x.length\n    x.to_s.reverse\n\
    \  else\n    x.to_s.split(//).reverse.join << shift\n  end\nend\n</code>\nExample\
    \ usage:\n<code>\ncircular_shift(12345, 2)", "  return x.to_s.split(//).reverse.shift(shift).join\n\
    end", "  x.digits.reverse_each do |x|\n    digit = x.digits.last\n    digit =\
    \ digit.abs % shift\n    if digit > 0\n      x.digits.unshift(x.digits.last.dup)\n\
    \      x.digits.last.next = (x.digits.last.next + 1) % shift\n    end\n  end\n\
    \  x.digits.to_a.join\nend\n</code>\n<|/ a tags=ruby,algorithm,ruby-on-rails |>\n\
    <| c |>\nI actually ended up writing something similar but with a much longer\
    \ version. This should be the accepted answer.\n<|/ c |>\n<| c |>\nCan you please\
    \ provide an example for the function `shift`? I'm still not able to figure out\
    \ what its actual purpose is. And would you mind providing a sample code of how\
    \ you would call it?\n<|/ c |>\n<| c |>\n, could you explain `x.digits.reverse_each\
    \ do |x|\n    digit = x.digits.last\n    digit = digit.abs % shift\n    if digit\
    \ > 0\n      x.digits.unshift(x.digits.last.dup)\n      x.digits.last.next = (x.digits.last.next\
    \ + 1) % shift\n    end\n  end\n  x.digits.to_a.join`\n<|/ c |>\n<| c |>\n, could\
    \ you explain `digit = x.digits.last`?\n<|/ c |>\n<| a |>\nIf you already have\
    \ access to the digits, you can just do something like this:\n<code>\ndigits.inject(&:reverse!)\n\
    </code>\nHere's an example:\n<code>\nirb(main):001:0> digits = (0..9).to_a\n=>\
    \ [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nirb(main):002:0> digits.inject(&:reverse!)\n\
    => [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n</code>\n<|/ a tags=ruby,algorithm,ruby-on-rails\
    \ dscore=2 |>\n<| c |>\nNot sure how this answers the question as you mention\
    \ \"digits\". Also, inject is very slow in ruby. See http://www.rubytapas.com/2008/03/22/how-much-faster-is-inject-than-map/\n\
    <|/ c |>\n<| c |>\n: `inject` doesn't mutate anything, so it's definitely faster\
    \ than the accepted answer. Also, as mentioned, it won't work with `Bignum`, so\
    \ I updated my answer to suggest using `reverse!` instead.\n<|/ c |>\n<| c |>\n\
    If you want a quick way to reverse a string, you can do `digits.reverse`.\n<|/\
    \ c ", "  x = x.to_s\n  x.reverse!\n  x.slice!(0, shift)\n  x.reverse!\n  x\n\
    end\nend\n</code>\n<|/ a tags=string,ruby |>\n<| a dscore=0 |>\nAnother one solution\
    \ in Ruby is:\n<code>", "  x = x.to_i\n  shift = shift.to_i\n  if shift == 0\n\
    \    x.times\n  else\n    digits = x.digits[0...shift]\n    digits[0, shift-1]\
    \ = (digits[0, shift-1] * 10) + digits[shift]\n    digits[shift, digits.size]\
    \ = digits[digits.size-1, 0]\n    x.digits = digits\n    x.digits\n  end\nend",
  "  x\n    .to_s\n    .split('')\n    .map { |d| d.to_i * 2**shift }\n    .join\n\
    end", "    if shift > x.length\n        digits = x.to_s.reverse\n    else\n  \
    \      digits = x.to_s\n    end", "  shift.times do\n    x = ((x % 10**shift)\
    \ + 10**shift) % 10**10\n  end\n  x\nend", "  digits = x.to_s.chars.reverse.join\
    \ if x.to_s.length < shift \n  else\n    x.to_s.chars[0...shift].reverse\n  end\n\
    end\n</code>\n<|/ a |>\n<| c |>\nYour answer was very helpful to me.  But it seems\
    \ that Ruby 1.9.3 has fixed this for me as well.\n<|/ c |>\n<| c |>\nYep, looks\
    \ like Ruby 1.9.3 fixed this for me too. 1.9.3 was released in 2006, and I think\
    \ it fixed this for everyone else as well. I haven't tried the fix, though, so\
    \ I can't say how well it works with floats and negative numbers.\n<|/ c |>\n\
    <| a dscore=2 |>\nI love the other answer by Steve Vinoskiy, but I just wanted\
    \ to add that there is also an extremely simple way to achieve this in Ruby 2.2.\
    \ This works well, and has the added benefit of being able to handle negative\
    \ numbers.\n<code>\nx = -12\nx.to_s.reverse * x.to_s.length\n=> -1234\n</code>\n\
    <|/ a tags=ruby,string |>\n<| a dscore=1 |>\nThe only solution I could think of\
    \ was to use a regex to find the last digit:\n<code>\n\"123\".to_s.reverse =~\
    \ /\\d/\n</code>\nWhich would give you:\n<code>\n=> 1\n</code>\nThen you could\
    \ remove the last (1 or 2) characters:\n<code>\n\"123\".to_s.reverse[1..-1]\n\
    </code>\nWhich would give you:\n<code>\n=> \"321\"\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| c |>\nI like this one. I'd be interested in seeing how it compares with\
    \ my answer.\n<|/ c |>\n<| c |>\nI posted my answer before he added his edit to\
    \ the question. I believe my answer still applies, and it probably is a little\
    \ faster than using regular expressions.\n<|/ c |>\n<| a |>\n<code>", "  x + (x\
    \ >> shift)\nend", "  if shift > x.to_s.length\n    x.to_s.reverse!\n    x.to_s.chars.map\
    \ { |y| (shift > y.to_s.length ? y : y.to_s.reverse) }.join\n  else\n    x.to_s.chars.map\
    \ { |y| y.to_s.reverse.chars.map { |z| (shift > z.to_s.length ? z : z.to_s.reverse).char\
    \ }.join(\"\") }.join\n  end\nend", "\tstring = \"\"\n\t\n\twhile x > 0 do\n\t\
    \tstring = string + (string[x%10] + string[x%10+1] + string[x%10+2])\n\t\tx =\
    \ x/10\n\tend\n\t\n\tif shift > string.length\n\t\treturn string.reverse\n\telse\n\
    \t\treturn string\n\tend\nend", "    x.to_s.split(//).reverse.each_cons(shift).map(&:join).join\n\
    end", "  x = x.to_i\n  shift = shift.to_i", "  digits, rest = x.divmod(shift)\n\
    \  if rest > 0 then digits = digits[1..] + digits[0..1]\n  return digits.to_s\n\
    end\n</code>\nThis algorithm isn't efficient if shift > 1, so a recursive algorithm\
    \ is needed. We start with a base case:\n<code>", "  x.reverse!\n  shift = x.length\
    \ + shift if shift > x.length else shift\n  x.slice!(0, shift)\n  x.reverse!\n\
    \  x\nend", "\tx = x.to_s # convert to string\n\tshift = shift || 1 # shift the\
    \ digits right by 1\n\treturn x.chars.reverse.shift(shift).reverse\nend", "  return\
    \ x.to_s.length == shift ? x.to_s.reverse : x.to_s.shift(shift)\nend", "  str\
    \ = x.to_s\n  str[shift] = str[shift].to_s[0..(shift - 1)]\n  str.to_s\nend\n\
    </code>\n<|/ a dscore=5 |>\n<| a tags=string,ruby |>\n<code>", "  x = x.to_i\n\
    \  shift = shift.to_i\n  shifted_string = \"\"\n  while x > 0\n    digit = x %\
    \ 10\n    shifted_string << digit\n    x /= 10\n  end\n  shift_digits = shifted_string.size\n\
    \  while shift > shift_digits\n    shifted_string.chop!\n  end\n  shifted_string\
    \ << shift - shift_digits\n  shifted_string.reverse\nend", "  x = x.to_s\n  shift\
    \ = shift - 1\n  return x.reverse.chars.shift(shift).reverse.join\nend\n</cell>\n\
    <cell>", "  shifted_digits = x.digits.reverse.scan(/.*/) do |digits|\n    digits[0..(shift\
    \ - 1)] + digits.take(shift).reverse\n  end\n  shifted_digits.flatten.join\nend",
  "  if x < 10\n    return x.to_s\n  digits = x.digits\n  digits_count = digits.size\n\
    \  digits_left = digits_count - shift\n  if digits_left > 0\n    digits_left--\n\
    \    digits[digits_count-digits_left] = digits[digits_count-digits_left] + digits[digits_count-digits_left-1]\n\
    \  digits_count = digits.size\n  digits_right = digits_count - shift\n  if digits_right\
    \ > 0\n    digits_right--\n    digits[digits_count-digits_right] = digits[digits_count-digits_right-1]\
    \ + digits[digits_count-digits_right]\n  new_digits = digits.reverse\n  x = x.clone\n\
    \  x.digits = new_digits\n  return x.to_s\nend", "  x.to_s.chars.each do |c|\n\
    \    next if c > 9 or (c < 0 and shift > 0)\n    digit = c % 10\n    digit = digit\
    \ + (digit > shift ? 10 : 0) - shift\n    digit = digit % 10\n    x =~ /#{digit}/\n\
    \  end\n  x\nend", "  ret = x.to_s.reverse\n  ret[0,shift] = ret[0,shift].to_s\n\
    \  ret\nend\n</code>\nThen you can run it like this:\n<code>\ncircular_shift(12,\
    \ 1).to_i", "  # Check if shift is out of bounds\n  if shift > x.length - x\n\
    \    raise ArgumentError, \"shift must be less than the number of digits\"\n \
    \ # Perform circular shift if shift > 0 digits\n  elsif shift > 0\n    # Loop\
    \ through each digit in number and keep shifting right by shift.\n    # If the\
    \ number is 0, break from the loop and return empty string\n    digits = \"\"\n\
    \    until x.zero?\n      # Extract current digit from the string\n      digit\
    \ = x.digit(0, x.length - x)\n      # Shift current digit right by shift digits\
    \ and add digit to the digits\n      digits << digit\n      x -= 1\n      shift\
    \ -= 1\n      # Break if shift is 0\n      break if shift == 0\n    # Return digits\
    \ reversed\n    digits[0...shift].reverse\n  else\n    # Return digits reversed\n\
    \    digits[0...-shift].reverse\n  end\nend", "    if shift == 0\n        return\
    \ x\n    if shift > length(x)\n        return x\n    return x[shift:length(x)\
    \ + shift]\nend", "  digits = (\"0\" * (shift % x.length)).concat(x).chars\n \
    \ digits.reverse!\n  return digits.join if shift > x.length else digits\nend",
  "  # Circularly shift x by shift digits.\n  # Shift must be non-negative and less\
    \ than or equal to number of digits.\n  if shift == 0\n    return \"\"\n  n =\
    \ x.to_s.length\n  return x.to_s[(n % shift) + shift] if n < shift and shift <\
    \ n else x.to_s\nend", "  return x.gsub(/(.)(\\d*)/, '\\1\\2').\n    gsub(/((.)(\\\
    d*))/, '\\1\\2').\n    gsub(/(.)\\2(\\d*)/, '\\1\\2').\n    gsub(/((.)\\2(\\d*))/,\
    \ '\\1\\2').\n    tr(\" \", \"0\").\n    tr(\"$\", \"0\").\n    tr(\"\\n\", \"\
    0\").\n    tr(\"\\r\\n\", \"0\").\n    tr(\"\\n\\r\", \"0\").\n    tr(\"\\n\\\
    r\", \"0\").\n    tr(\"\\n\", \"0\").\n    tr(\"\\r\\n\", \"0\").\n    tr(\"\\\
    n\\r\", \"0\").\n    tr(\"\\n\\r\", \"0\").\n    tr(\"\\n\", \"0\").\n    tr(\"\
    \\r\\n\", \"0\").\n    tr(\"\\n\\r\", \"0\").\n    tr(\"\\n\\r\", \"0\").\n  \
    \  tr(\"\\n\", \"0\").\n    tr(\"\\r\\n\", \"0\").\n    tr(\"\\n\\r\", \"0\").\n\
    \    tr(\"\\n\\r\", \"0\").\n    tr(\"\\n\", \"0\").\n    tr(\"\\r\\n\", \"0\"\
    ).\n    tr(\"\\n\\r\", \"0\").\n    tr(\"\\n\\r\", \"0\").\n    tr(\"\\n\", \"\
    0\").\n    tr(\"\\r\\n\", \"0\").\n    tr(\"\\n\\r\", \"0\").\n    tr(\"\\n\\\
    r\", \"0\").\n    tr(\"\\n\", \"0\").\n    tr(\"\\r\\n\", \"0\").\n    tr(\"\\\
    n\\r\", \"0\").\n    tr(\"\\n\\r\", \"0\").\n    tr(\"\\n\", \"0\").\n    tr(\"\
    \\r\\n\", \"0\").\n    tr(\"\\n\\r\", \"0\").\n    tr(\"\\n\\r\", \"0\").\n  \
    \  tr(\"\\n\", \"0\").\n    tr(\"\\r\\n\", \"0\").\n    tr(\"\\n\\r\", \"0\").\n\
    \    tr(\"\\n\\r\", \"0\").\n    tr(\"\\n\", \"0\").\n    tr(\"\\r\\n\", \"0\"\
    ).\n    tr(\"\\n\\r\", \"0\").\n    tr(\"\\n\\r\", \"0\").\n    tr(\"\\n\", \"\
    0\").\n    tr(\"\\r\\n\", \"0\").\n    tr(\"\\n\\r\", \"0\").\n    tr(\"\\n\\\
    r\", \"0\").\n    tr(\"\\n\", \"0\").\n    tr(\"\\r\\n\", \"0\").\n    tr(\"\\\
    n\\r\", \"0\").\n    tr(\"\\n\\r\", \"0\").\n    tr(\"\\n\", \"0\").\n    tr(\"\
    \\r\\n\", \"0\").\n    tr(\"\\n\\r\", \"0\").\n    tr(\"", "  if shift > x.length\n\
    \    x.slice!(x.length..-1)\n  else\n    x.slice!(shift..-1)\n  end\n  x\nend\n\
    </code>\nExample of usage with large integers:\n<code>", "  if shift > x.length\n\
    \    x.to_s\n  else\n    shifted_digits = \"\"\n    digit = x.to_s.chars.to_a.first\n\
    \    shift = 0 - shift\n    while shift < x.length\n      digit, shift = x.to_s.chars.to_a.first,\
    \ shift + 1\n      shifted_digits << digit\n    end\n    shifted_digits\n  end\n\
    end", "  return x.to_s.reverse.slice(shift, -shift)\nend", "  return x.to_s.length\
    \ - x.to_s.rindex(x.to_s, x.to_s.length - shift)\nend", "  if shift >= (x.length\
    \ - 1)\n    x.reverse\n  else\n    x.reverse!\n    x.slice!(0, shift)\n  end\n\
    \  x\nend\n</code>\nNow you can write the following:\n<code>", "  if shift > length(x)\n\
    \    puts x[-shift..-1]\n  else\n    puts x[0..-shift]\n  end\nend", "  x -= x.to_s\n\
    \  x.slice!(0, shift)\n  x.slice!(-shift)\nend", "  if x > 9\n    digits = x.to_s.chars.reverse\n\
    \  else\n    digits = x.to_s.chars\n  end\n  digits.each_slice(shift).to_a.join.reverse\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\n`x.to_s.chars.reverse` will reverse\
    \ the string, not digits.\n<|/ c |>\n<| c |>\nThanks I fixed the example.  I thought\
    \ it would be better than my solution, but clearly this one is better.\n<|/ c\
    \ |>\n<| a tags=ruby dscore=2 |>\nHere is another way (based on Steve's comment):\n\
    <code>", "  x = x.to_s\n  shift = shift or 0\n  if shift > x.length\n    shift\
    \ = x.length\n  elsif shift < 0\n    shift = -1 * shift\n  else\n    x = x.dup\n\
    \    x[shift..-1] = x[-shift..-1]\n  end\n  return x.reverse\nend", "  n = x.to_s.length\n\
    \  return x.to_s[0...n].insert(0, x.to_s[1...n].shift(shift).join)\nend", "  return\
    \ x.digits.reverse[shift..-shift].reverse.join\nend", "  x = x.to_i\n  shift =\
    \ shift.to_i\n  digits = x.digits\n  if shift >= 0\n    shift %= digits.count\n\
    \  else\n    shift %= (-digits.count).abs\n  end\n  digits[shift, digits.length]\
    \ = digits[digits.length-1, shift]\n  x.digit_count = (digits.length * 10).floor\n\
    \  x.digits = digits.reverse\n  x.to_s\nend\n</cell>\n<text>\nThe above method\
    \ gives us all of the digits in an integer, including leading zeros. However,\
    \ for our purpose of displaying the digits, we only want the last ones, and we\
    \ want to do that in reverse order, so we need to write a method that gets us\
    \ the last n digits.", "  string = \"\"\n  while x > 0\n    string, x = x.divmod(shift)\n\
    \    string << shift.to_s\n  end\n  return string.reverse\nend\n</code>\n<|/ a\
    \ dscore=3 |>\n<| a dscore=3 |>\nThis is a modified version of Todd McDonald's\
    \ answer to handle negative numbers correctly:\n<code>", "  return x.zero? ? ''\
    \ : x.to_s.reverse.gsub(/(.{#{shift}})(?=\\d)/, '\\\\1').reverse\nend", "  result\
    \ = x.to_s\n  for i in 0...shift\n    result = result.chars.rev[result.length\
    \ - (i + 1)]\n  end\n  return result\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\n\
    I guess you meant `circular_shift.call(12, 3)` instead of `circular_shift.call(12,\
    \ 2)` :)\n<|/ c |>\n<| c |>\nHaha yeah sorry I didn't test my code before I posted\
    \ it. I fixed the typo.\n<|/ c |>\n<| c |>\nIt was an interesting question, thank\
    \ you for answering.\n<|/ c |>\n<| a dscore=4 tags=ruby |>\nJust for the heck\
    \ of it, here is a solution in Ruby 1.9 using String#succ and String#gsub.  It\
    \ is not as fast as the other solutions, but this one is simple to understand.\n\
    <code>\n\"1\".succ   # => 2\n\"1\".succ(2  # => 3\n\"1\".succ 3  # => 4\n\"1\"\
    .succ 3  # => 5\n</code>\n<|/ a |>\n<| c |>\nThis isn't correct for integers >9.\
    \  It will go one step too far for \"10\".succ(2)\n<|/ c |>\n<| c |>\nFor integers\
    \ above 9, just do `str.gsub(/^./) { |x| x.succ }`.\n<|/ c |>\n<| c |>\nYeah,\
    \ that's what I meant to suggest, but it wasn't clear to me from the question\
    \ that he wanted it to be a generalized solution (e.g., for strings of arbitrary\
    \ length).\n<|/ c |>\n<| c |>\nThis is nice, but does not handle negative numbers.\
    \ It would be nice if you could do that without adding any unnecessary code (for\
    \ example, the if statement just to handle the negative number).\n<|/ c |>\n<|\
    \ a tags=ruby dscore=4 |>\nYou can try this:\n<code>", "  digits = x.digits.reverse\n\
    \  digits[shift].to_s(0)\nend", "  if x < 0\n    x, shift = x, 0\n  digits = String(x)\n\
    \  return String((digits[0..(shift.abs%3)-1] + digits[0..(shift.abs-1)*(shift%3)-1]).reverse)\n\
    end", "    return ((x >> shift) ^ x) & 0xffffffff\nend", "  return x.to_s.split(//).reverse[shift..-1].join\n\
    end", "  if x < 0\n    error(\"Circular shift amount must be positive\")\n  elsif\
    \ shift == 0\n    \"\"\n  else\n    n = digits(x)\n    i = shift - 1\n    # Circular\
    \ shift the digits and return as string\n    digits = n[i + 1 .. 0]\n    return\
    \ digits + digits(x >> shift)\n  end\nend", "  x = x.to_s\n  shift = shift.to_i\n\
    \  chars = x.split('')\n  result = \"\"\n  shifted_chars = chars.reverse.slice!(0,\
    \ shift).reverse\n  shifted_chars.each {|c|\n    if c.is_a?(Fixnum)\n      result\
    \ += \"#\" + c.to_s\n    else\n      result += c\n    end\n  }\n  result.to_i\n\
    end", "  x.to_s(length: shift)\nend\n</code>\n<|/ a tags=ruby,string,integer |>\n\
    <| c |>\nNice, didn't know that one. Thanks!\n<|/ c |>\n<| c |>\nNice solution,\
    \ but I would recommend against using eval.  It is unsafe because it opens up\
    \ the possibility that someone could inject code into your string and call methods\
    \ on objects that are unknown to your program.\n<|/ c |>\n<| c |>\nGood point,\
    \ I will amend my answer to use `eval` instead of `send`.\n<|/ c |>\n<| a tags=ruby,string,integer\
    \ dscore=1 |>\nHere's a very basic implementation of your problem:\n<code>", " \
    \ return x.to_s.reverse.slice(shift, x.to_s.size - shift)\nend", "    digits =\
    \ x.to_s.split(//).reverse\n    shift = shift - digits.size if shift > x.to_s.length\
    \ \n    digits[0, shift].concat(digits[shift, digits.size])\nend", "  rev = false\n\
    \  case shift\n  when 0\n    res = \"\"\n  when > x.to_s.length\n    return x.to_s.reverse\n\
    \  when x.to_s.length == 0\n    return x.to_s\n  else # Circular shift the digits\
    \ of the integer x, shift the digits right by shift\n    # and return the result\
    \ as a string.\n    rev = true\n    res = \"\"\n    x.to_s.reverse!\n    # Note:\
    \ x is treated as a float if x.to_s ends with a decimal point,\n    # because\
    \ the last digit is still part of the string, so the result is\n    # different\
    \ if x is a float, a Bignum, or a String with a decimal point\n    # at its end.\n\
    \    x.to_s.reverse!\n    # While shifting, append digits from the end of a string\
    \ to the front\n    until x.to_s.length == shift do\n      res += x.to_s.slice!(-shift,\
    \ -shift - 1)\n      shift -= 1\n    end\n    res += x.to_s.slice!(x.to_s.length\
    \ - shift, x.to_s.length)\n    x.to_s.reverse! if rev\n    return res\n  end\n\
    end\n</code>\nAnd here is the same function written more idiomatically:\n<code>",
  "  s = x.to_s(10)\n  s *= (Math.pow(shift, 1.0))\n  s -= (Math.pow(shift, 2.0))\n\
    \  s.reverse!\n  s.to_s(10)\nend\n</code>\n<|/ a |>\n<| c |>\nThis solution is\
    \ pretty neat, I think. However, I believe the Ruby API provides methods to achieve\
    \ the same result more easily. For example, I was able to implement this using\
    \ the \"digit-by-digit\" approach posted in another answer, but this seems much\
    \ more readable. Also, I believe that method name is more descriptive than the\
    \ more verbose \"shift_digits\". Thanks for the solution though!\n<|/ c |>\n<|\
    \ a dscore=3 tags=algorithm,ruby,ruby-on-rails,string |>\nHere is my solution\
    \ in Ruby 2.4.1:\n<code>", "  x = x.to_i\n  return x.digits.reverse[shift.to_i\
    \ % x.digits.length] if shift >= x.digits.length then x.digits.reverse else x.digits.reverse[(shift.to_i\
    \ + x.digits.length) % x.digits.length]\nend", "  if shift < 0\n    shift = shift\
    \ + 8\n    shift %= 8\n  elsif shift > 0\n    shift = shift - 8\n    shift %=\
    \ 8\n  else\n    shift = 8\n  end\n  digits = []\n  while x\n    digits, x = digits[0..-6].concat(x),\
    \ x >> shift\n  end\n  return digits.reverse\nend", "  x = x.to_s\n  shift -=\
    \ 1\n  result = ''\n  while shift >= 0 do\n    digit = x.slice!(shift)\n    result\
    \ = digit.to_s << shift | result unless digit.nil?\n    shift -= 1\n  end\n  result.reverse!\n\
    \  result\nend\n</pre>\n          </div>\n        </div>\n        \n      </div>\n\
    \    \n    </div>\n  </div>\n</section>", "    x.zero?\n    return x.to_s.reverse[shift]\n\
    end", "  x.downto(0) do |i|\n    x <<= shift\n  end\n  x = x.to_s\n  x.reverse!\
    \ if shift > x.length\n  x\nend", "  if shift > length(x)\n    x.to_s\n  else\n\
    \    x = x.to_s\n    x.reverse! #reverse the string\n    x.slice!(-shift, shift)\
    \ #cut out string after shift\n    x.reverse! #reverse back\n  end\nend\n</code>\n\
    Now you can implement any of these by defining these methods and calling them:\n\
    <code>", "  return x.to_s.reverse[x.to_s.reverse.length - (x.to_s.reverse.length\
    \ % shift).abs]\nend", "  if x > 10000\n    digits = x.to_s\n  else\n    digits\
    \ = x.to_s.reverse\n  end\n  digits.reverse!\n  digits.reverse! shift\n  return\
    \ digits.reverse\nend", "  len = Integer(x.length).send(:+, shift)\n  x.send(:\"\
    *\", len).send(:\"-\", len).to_s\nend", "  shifted = []\n  x.to_s.chars.each do\
    \ |char|\n    shifted.unshift(char * shift)\n    shift -= 1\n  end\n  shifted.reverse.join\n\
    end", "  if shift > x.length\n    x.reverse!\n    shift-=x.length\n  end\n  result\
    \ = \"\"\n  while x > 0, shift > 0, result = String(x.last - shift - 1) + result,\
    \ shift = shift - 1\n  return result\nend\n</code>\nThis code can probably be\
    \ optimized a bit to reduce the memory footprint, but I think it's pretty clear.\
    \  Basically, I keep a running \"tail\" of the string with leading digits until\
    \ I reach the desired length.  Then I just reverse it and then shift it back by\
    \ the same amount.  I do the same with the result.  It probably has some bugs\
    \ in it, but I think it gives the right result.\n<|/ a dscore=2 tags=string,ruby\
    \ |>\n<| c |>\nThis is very inefficient, because it creates a new string object\
    \ for every shift and appends it to the beginning of the string every time. That's\
    \ why it works only if you pass shift as a value up to 12. Try running my code\
    \ with shift == 13 and you'll see the same results as's solution.\n<|/ c |>\n\
    <| c |>\nI agree it's inefficient because it needs to create a new string for\
    \ every shift, but I don't think it creates new strings every time.  Each call\
    \ to String() creates a new object.  But it still does a single concatenation\
    \ per shift so it's still pretty efficient as well.\n<|/ c |>\n<| c |>\nI updated\
    \ my answer to include your comment.  I'm still not convinced that it's better,\
    \ since it seems that it does a whole bunch of string allocations.\n<|/ c |>\n\
    <| c |>\n: That's true. I didn't think of the possibility of shifting past the\
    \ length of the string. I'll try to modify my answer.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>", "  if shift > x.to_s.length\n    x.to_s.reverse\n  else\n    x.to_s[0...(x.to_s.length\
    \ - shift)].join\n  end\nend", "  return x.to_s.reverse.slice(shift, -shift)\n\
    end", "  shift = shift or 0\n  len = x.length\n  str = \"\"\n  while len >= shift\n\
    \    str = x[len-shift] + str\n    shift -= 1\n    len -= shift\n  str = x[len]\
    \ + str if len < x.length else str\n  return str\nend", "  if shift > x.to_s.length\n\
    \    x.to_s.reverse\n    shift\n  else\n    x.to_s.split(\"\").reverse.shift.join(\"\
    \")\n  end\nend\n</code>\n<|/ a tags=string,ruby,numbers |>\n<| a tags=string,ruby,numbers\
    \ dscore=0 |>\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
