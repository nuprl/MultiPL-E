name: HumanEval_132_is_nested
language: rb
prompt: "# Create a function that takes a string as input which contains only square\
  \ brackets.\n# The function should return true if and only if there is a valid subsequence\
  \ of brackets \n# where at least one bracket in the subsequence is nested.\n# >>>\
  \ is_nested.call(\"[[]]\")\n# true\n# >>> is_nested.call(\"[]]]]]]][[[[[]\")\n#\
  \ false\n# >>> is_nested.call(\"[][]\")\n# false\n# >>> is_nested.call(\"[]\")\n\
  # false\n# >>> is_nested.call(\"[[][]]\")\n# true\n# >>> is_nested.call(\"[[]][[\"\
  )\n# true\ndef is_nested(string)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_nested\n\
  \    candidate = method(:is_nested)\n    assert_equal(true, candidate.call(\"[[]]\"\
  ))\n    assert_equal(false, candidate.call(\"[]]]]]]][[[[[]\"))\n    assert_equal(false,\
  \ candidate.call(\"[][]\"))\n    assert_equal(false, candidate.call(\"[]\"))\n \
  \   assert_equal(true, candidate.call(\"[[[[]]]]\"))\n    assert_equal(false, candidate.call(\"\
  []]]]]]]]]]\"))\n    assert_equal(true, candidate.call(\"[][][[]]\"))\n    assert_equal(false,\
  \ candidate.call(\"[[]\"))\n    assert_equal(false, candidate.call(\"[]]\"))\n \
  \   assert_equal(true, candidate.call(\"[[]][[\"))\n    assert_equal(true, candidate.call(\"\
  [[][]]\"))\n    assert_equal(false, candidate.call(\"\"))\n    assert_equal(false,\
  \ candidate.call(\"[[[[[[[[\"))\n    assert_equal(false, candidate.call(\"]]]]]]]]\"\
  ))\n  end\nend\n"
completions: ["  nestings = string.scan(/\\[/).flatten.uniq\n  return nestings.count\
    \ > 1\nend\n</cell>\n<code language=julia-1.0>\nis_nested.(\"[[]][][][[][[][[][][][][][][][[][][][[][][][][][[]][][][][[][[][[][][[][[][[][[][[][[][][][][][][][][][][][[][][][][][[]][][][][][[][[][[][][[][[][[][][[][[][[][[][][[][][[][][[][[][[][][[][[][[][[][[][][][][][][][][[][][[][][][][][][][[][][][][][[][][][][[][][[][][[][[][][[][[][][[][[][[][][[][[][[][][[][[][][[][[][[][][[][[][[][[][][[][[][[][[][][[][[][][[][[][][[][[][[][[][[][[][[][[][[][[][[][][[][][[][[][[][[][[][][[][[][[][][][][][][][][][][][][[][][][][[][][[][][][][[][[][][[][[][[][[][][[][[][[][[][][[][[][[][[][[][][[][[][[][][[][[][[][[][][[][][][][][][][][][][][][][[][][[][][[][][[][][[][[][[][[][[][][[][[][][][][][][][][][][][][][][[][][[][][[][[][[][[][][[][[][[][[][[][][][][][][][][][][][][][[][][[][][[][[][[][[][[][][][][][][][][][][][][][][[][][[][[][[][][[][[][[]",
  "  brackets = string.count(\"[\")\n  square_brackets = string.count(\"]\")\n  return\
    \ brackets == square_brackets\nend", "  # TODO: This can be done more efficiently...\n\
    \  return string.count(\"[\")-string.count(\"]\") <= 1", "  string = \"[#{string}].to_s\"\
    \n  string.slice! \"[\"\n  string.slice! \"(\"\n  string.slice! \"{\"\n  string.slice!\
    \ \"]\"\n  string.slice! \"}\"\n  string.slice! \"]\"\n  string.slice! \"[\"\n\
    \  string.slice! \"]\"\n  string.slice! \"]\"\n  string.slice! \"[\"\n  string.slice!\
    \ \"[\"\n  string.slice! \"[\"\n  string.slice! \"]\"\n  string.slice! \"]\"\n\
    \  string.slice! \"[\"\n  string.slice! \"]\"\n  string.slice! \"]\"\n  string.slice!\
    \ \"]\"\n  string.slice! \"]]\"\n  string.slice! \"]]\"\n  string.slice! \"[\"\
    \n  string.slice! \"[\"\n  string.slice! \"]\"\n  string.slice! \"]\"\n  string.slice!\
    \ \"]\"\n  string.slice! \"]]\"\n  string.slice! \"[\"\n  string.slice! \"[\"\n\
    \  string.slice! \"]\"\n  string.slice! \"]\"\n  string.slice! \"]\"\n  string.slice!\
    \ \"]]\"\n  string.slice! \"]]\"\n  string.slice! \"[\"\n  string.slice! \"[\"\
    \n  string.slice! \"]\"\n  string.slice! \"]\"\n  string.slice! \"]\"\n  string.slice!\
    \ \"]]\"\n  string.slice! \"]]\"\n  string.slice! \"[\"\n  string.slice! \"[\"\
    \n  string.slice! \"]\"\n  string.slice! \"]\"\n  string.slice! \"]\"\n  string.slice!\
    \ \"]]\"\n  string.slice! \"]]\"\n  string.slice! \"[\"\n  string.slice! \"[\"\
    \n  string.slice! \"]\"\n  string.slice! \"]\"\n  string.slice! \"]\"\n  string.slice!\
    \ \"]]\"\n  string.slice! \"[\"\n  string.slice! \"[\"\n  string.slice! \"]\"\n\
    \  string.slice! \"]\"\n  string.slice! \"]\"\n  string.slice! \"]]\"\n  string.slice!\
    \ \"]]\"\n  string.slice! \"[\"\n  string.slice! \"[\"\n  string.slice! \"]\"\n\
    \  string.slice! \"]\"\n  string.slice! \"]\"\n  string.slice! \"]]\"\n  string.slice!\
    \ \"[\"\n  string.slice! \"[\"\n  string.slice! \"]\"\n  string.slice! \"]\"\n\
    \  string.slice! \"]\"\n  string.slice! \"]", "    match = bracket_regex.match(string)\n\
    \    return match and is_nested_helper(string.index(match[0]))", "    bracket_counts\
    \ = {}\n    bracket_level = 0", "  bracket_count = 0\n  nested_brackets = false\n\
    \  nested_brackets_count = 0\n  bracket_count = 0\n  string.gsub!( /[][]/ ) do\n\
    \    bracket_count += 1\n    if nested_brackets == false\n      if bracket_count\
    \ == 1\n        nested_brackets = true\n        nested_brackets_count += 1\n \
    \       nested_brackets_count += 1 if nested_brackets_count == 1\n      end\n\
    \    end\n    nested_brackets_count = 0 if nested_brackets_count == 0\n    nested_brackets\
    \ = false\n    bracket_count = 0\n  end\n  nested_brackets_count = 0 if nested_brackets_count\
    \ == 0\n  nested_brackets = false\n  bracket_count = 0\n  string.gsub!( /\\[\\\
    [/ ) do\n    bracket_count += 1\n    if nested_brackets == false\n      if bracket_count\
    \ == 1\n        nested_brackets = true\n        nested_brackets_count += 1\n \
    \       nested_brackets_count += 1 if nested_brackets_count == 1\n      end\n\
    \    end\n    nested_brackets_count = 0 if nested_brackets_count == 0\n    nested_brackets\
    \ = false\n    bracket_count = 0\n  end\n  nested_brackets_count = 0 if nested_brackets_count\
    \ == 0\n  nested_brackets = false\n  bracket_count = 0\n  string.gsub!( /\\[\\\
    ]\\]/ ) do\n    bracket_count += 1\n    if nested_brackets == false\n      if\
    \ bracket_count == 1\n        nested_brackets = true\n        nested_brackets_count\
    \ += 1\n        nested_brackets_count += 1 if nested_brackets_count == 1\n   \
    \   end\n    end\n    nested_brackets_count = 0 if nested_brackets_count == 0\n\
    \    nested_brackets = false\n    bracket_count = 0\n  end\n  nested_brackets_count\
    \ = 0 if nested_brackets_count == 0\n  nested_brackets = false\n  bracket_count\
    \ = 0\n  string.gsub!( /\\[\\[/ ) do\n    bracket_count += 1\n    if nested_brackets\
    \ == false\n      if bracket_count == 1\n        nested_brackets = true\n    \
    \    nested_brackets_count += 1\n        nested_brackets_count += 1 if nested_brackets_count\
    \ == 1\n      end\n    end\n    nested_brackets_count = 0 if nested_brackets_count\
    \ == 0\n    nested_brackets = false\n    bracket_count = 0\n  end\n  nested_brackets_count\
    \ = 0 if nested_brackets_count == 0\n  nested_brackets = false\n  bracket_count\
    \ = 0\n  string.gsub!( /\\[\\]\\]/ ) do\n    bracket_count += 1\n    if nested_brackets\
    \ == false\n      if bracket_count == 1\n        nested_brackets = ", "    # Initialize\
    \ a boolean to false\n    has_nested = false\n    # Loop over the string's characters\n\
    \    string.each_char do |char|\n        # Check if the current character is a\
    \ '['\n        if char == '['\n            # If so, check if the previous character\
    \ is a ']'\n            if has_nested.nil?\n                has_nested = true\n\
    \            else\n                # Otherwise, the previous character is not\
    \ a ']', so return false\n                has_nested = false\n            end\n\
    \        elsif char == ']'\n            # If we are still inside brackets, return\
    \ true\n            if has_nested.nil?\n                has_nested = true\n  \
    \          end\n        end\n    end\n    return has_nested\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nThis is exactly the type of thing I was looking for!\
    \ Thank you so much! I knew the solution had to do with splitting strings, but\
    \ I couldn't figure out how to do that recursively. Thank you so much!\n<|/ c\
    \ |>\n<| a |>\nA non-regex solution using only functional style:\n<code>", " \
    \ brackets = 0\n  nesting = 0", "  string = string.to_s\n  return string =~ /\\\
    [(\\[]*?\\[\\[/\nend", "  bracket_count = 0\n  for i in string\n    if i == \"\
    [\" \n      bracket_count += 1\n    else if i == \"]\"\n      bracket_count -=\
    \ 1\n      \n    if bracket_count == 0\n      return true\n  end\n  return false\n\
    end", "  nested.count(\"[\")\n  nested.count(\"]\")\n  nested.count(\"(\")\n \
    \ nested.count(\")\")\n  \n  if nested.length != string.count(\"[\")+string.count(\"\
    ]\")+string.count(\"(\")+string.count(\")\")\n    return false\n  \n  if nested.length\
    \ != string.count(\"[\")\n    return false\n  \n  if nested.length != string.count(\"\
    ]\")\n    return false\n  \n  if nested.length != string.count(\"(\")\n    return\
    \ false\n  \n  if nested.length != string.count(\")\")\n    return false\n  \n\
    \  if nested.length != string.count(\"(\")+string.count(\")\")\n    return false\n\
    \  \n  if nested.length != string.count(\"[\")+string.count(\"]\")+string.count(\"\
    (\")+string.count(\")\")\n    return false\n  \n  nested.each do |str|\n    if\
    \ string.count(str) > 1\n      return true\n    end\n  end\nend", "  nest = 0\n\
    \  brackets = []\n  opening_index = 0\n  closing_index = 0\n  opening_char = ''\n\
    \  closing_char = ''\n  \n  opening_chars = string.split(opening_char)\n  closing_chars\
    \ = string.split(closing_char)\n  \n  opening_counter = 0\n  opening_char_index\
    \ = 0\n  opening_char = ''\n  \n  closing_counter = 0\n  closing_char_index =\
    \ 0\n  closing_char = ''\n  \n  opening_chars.each do |char|\n    if char == closing_chars[closing_counter]\
    \ \n      closing_counter += 1\n    else \n      if char == opening_chars[opening_counter]\
    \ \n        opening_counter += 1\n      else\n        if opening_counter > closing_index\n\
    \          opening_char_index = opening_counter\n          opening_counter = 0\n\
    \        end\n        \n        if closing_counter > opening_index\n         \
    \ closing_char_index = closing_counter\n          closing_counter = 0\n      \
    \  end\n        \n        break \n      end\n    end\n  end", "  brackets = (string.count\
    \ \"[\")..-1\n  nesting = brackets.count nesting_brackets\n  return nesting >\
    \ 0\nend", "    string.gsub!(/[\\[\\]]/, '')\n    string.gsub!(/\\[[^[\\]]*\\\
    ]/, '')\n    string.gsub!(/\\[/, '') #removes the beginning of a sequence\n  \
    \  string.gsub!(/\\]/, '') #removes the end of a sequence\n    string.gsub!(/([^\\\
    [\\]]+)(\\[[^\\[\\]]*\\])/, '\\1\\2') # replaces the beginning and end of a sequence\
    \ with an empty string\n    string.gsub!(/\\]/, '') #removes the end of a sequence\n\
    \    string.gsub!(/[\\[\\]]/, '')\n    string.gsub!(/\\[/, '') #removes the beginning\
    \ of a sequence\n    string.gsub!(/\\]/, '') #removes the end of a sequence\n\
    \    string.gsub!(/([^\\[\\]]+)(\\[[^\\[\\]]*\\])/, '\\1\\2') # replaces the beginning\
    \ and end of a sequence with an empty string\n    string.gsub!(/[\\[\\]]/, '')\n\
    \    string.gsub!(/\\[/, '') #removes the beginning of a sequence\n    string.gsub!(/\\\
    ]/, '') #removes the end of a sequence\n    string.gsub!(/([^\\[\\]]+)(\\[[^\\\
    [\\]]*\\])/, '\\1\\2') # replaces the beginning and end of a sequence with an\
    \ empty string\n    string.gsub!(/[\\[\\]]/, '')\n    string.gsub!(/\\[/, '')\
    \ #removes the beginning of a sequence\n    string.gsub!(/\\]/, '') #removes the\
    \ end of a sequence\n    string.gsub!(/([^\\[\\]]+)(\\[[^\\[\\]]*\\])/, '\\1\\\
    2') # replaces the beginning and end of a sequence with an empty string\n    string.gsub!(/[\\\
    [\\]]/, '')\n    string.gsub!(/\\[/, '') #removes the beginning of a sequence\n\
    \    string.gsub!(/\\]/, '') #removes the end of a sequence\n    string.gsub!(/([^\\\
    [\\]]+)(\\[[^\\[\\]]*\\])/, '\\1\\2') # replaces the beginning and end of a sequence\
    \ with an empty string\n    string.gsub!(/[\\[\\]]/, '')\n    string.gsub!(/\\\
    [/, '') #removes the beginning of a sequence\n    string.gsub!(/\\]/, '') #removes\
    \ the end of a sequence\n    string.gsub!(/([^\\[\\]]+)(\\[[^\\[\\]]*\\])/, '\\\
    1\\2') # replaces the beginning and end of a sequence ", "  string = string[1..-2]\
    \ while string.length > 1 and string[0..0] != \"[\" \n  return string.include?(\"\
    [\")\nend", "  string = string.to_s\n  stack = []\n  stack.push string[0]\n  i\
    \ = 1\n  while i < string.length\n    if string[i] == '['\n      stack.push string[i]\n\
    \      i += 1\n      while i < string.length\n        if string[i] == '['\n  \
    \        stack.push string[i]\n          i += 1\n        else\n          break\n\
    \      i += 1\n    else if string[i] == ']'\n      if not stack.empty?\n     \
    \   if stack.pop.to_s == '['\n          return true\n      i += 1\n    else \n\
    \      break\n  end\n  false\nend", "  string.scan(/\\[([^\\[\\]]*)\\]/).count\
    \ > string.scan(/\\[([^\\[\\]]*)\\]/).count\nend", "    brackets = 0\n    bracket_depth\
    \ = 0\n    opening_brackets = 0 # Number of opening brackets\n    closing_brackets\
    \ = 0 # Number of closing brackets\n    opening_square_brackets = 0\n    closing_square_brackets\
    \ = 0\n    index = 0", "  return string.gsub('[[[]]','[').gsub('[]]',']').gsub('[[','[').gsub(']]',']')\
    \ !~ /\\[/\nend", "  matches = string.scan(/[\\[\\]]+(?=\\[\\[\\]]|\\Z)/)\n  return\
    \ matches.any?{|el| el[0].count(\"[[]]\") == 0}\nend", '    pattern = /\[(?:[^\[]|\[(?!])|\[(?:[^\[]|\[(?!])|\[(?:[^\[]|\[(?!])])*\])*\]|\[(?:[^\[]|\[(?!])|\[(?:[^\[]|\[(?!])|\[(?:[^\[]|\[(?!])])*\])*\])*\]|\[(?:[^\[]|\[(?!])|\[(?:[^\[]|\[(?!])|\[(?:[^\[]|\[(?!])])*\])*\]|\[(?:[^\[]|\[(?!])|\[(?:[^\[]|\[(?!])|\[(?:[^\[]|\[(?!])])*\])*\])*\]|\[(?:[^\[]|\[(?!])|\[(?:[^\[]|\[(?!])|\[(?:[^\[]|\[(?!])])*\])*\]|\[(?:[^\[]|\[(?!])|\[(?:[^\[]|\[(?!])|\[(?:[^\[]|\[(?!])])*\])*\]|\[(?:[^\[]|\[(?!])|\[(?:[^\[]|\[(?!])|\[(?:[^\[]|\[(?!])])*\])*\]|\[(?:[^\[]|\[(?!])|\[(?:[^\[]|\[(?!])|\[(?:[^\[]|\[(?!])])*\])*\]|\[(?:[^\[]|\[(?!])|\[(?:[^\[]|\[(?!])|\[(?:[^\[]|\[(?!])])*\])*\]|\[(?:[^\[]|\[(?!])|\[(?:[^\[]|\[(?!])|\[(?:[^\[]|\[(?!])])*\])*\]|\[(?:[^\[]|\[(?!])|\[(?:[^\[]|\[(?!])|\[(?:[^\[]|\[(?!])])*\])*\]|\[(?:[^\[]|\[(?!])|\[(?:[^\[]|\[(?!])|\[(?:[^\[]|\[(?!])])*\])*\]|\[(?:[^\[]|\[(?!])|\[(?:[^\[]|\[(?!])|\[(?:[^\[]|\[(?!])])*\])*\]|\[(?:[^\[]|\[(?!])|\[(?:[^\[]|\[(?!])|\[(?:[^\[]|\[(?!])])*\])*\]|\[(?:[^\[]|\[(?!])|\[(?:[^\[]|\[(?!])|\[(?:[^\[]|\[(?!])])*\])*\]|\[(?:[^\[]|\[(?!])|\[(?:[^\[]|\[(?!])|\[(?:[^\[]|\[',
  "  string.downcase!\n  string.gsub(/\\[+/,'').gsub(/[\\]]+/,'') == ''\nend", " \
    \ \n  # Initialize a list of pairs where each pair consists of the brackets that\
    \ are currently in the \n  # string and the positions of the brackets that are\
    \ not in the current string.\n  pairs = []\n  # Initialize a variable that indicates\
    \ if the current string contains nested brackets or not.\n  nested = false\n \
    \ \n  # Iterate over each character in the current string and add the current\
    \ char to the list of \n  # pairs.\n  i = 0\n  while i < string.length\n    \n\
    \    # If the current character is [, add the current string bracket to the list\
    \ of pairs.\n    if string[i] == \"[\"\n      pairs << [string[i], i] \n     \
    \ \n    # If the current character is ], remove the string bracket from the list\
    \ of pairs.\n    elsif string[i] == \"]\"\n      pairs.delete_at(i-2)\n      \n\
    \    # If the current character is ], break the loop.\n    elsif string[i] ==\
    \ \"]]\"\n      nested = false\n      \n    # If the current character is a ]\
    \ that is not followed by [, break the loop.\n    elsif string[i] == \"]\" &&\
    \ !nested\n      nested = false\n      break\n    \n    # If the current character\
    \ is a [ that is not followed by [, add the current string bracket\n    # to the\
    \ list of pairs.\n    elsif string[i] == \"[\" && !nested\n      pairs << [string[i],\
    \ i]\n    \n    # If the current character is a [ that is not followed by [, break\
    \ the loop.\n    elsif string[i] == \"[\" && !nested\n      nested = true\n  \
    \    break\n    \n    # If the current character is a [, break the loop.\n   \
    \ elsif string[i] == \"[\" && nested\n      nested = false\n      break\n    \n\
    \    # If the current character is not a [ or ] break the loop.\n    elsif !string[i]\
    \ == \"[\" && string[i] != \"]\" && string[i] != \"]]\"\n      break\n    \n \
    \   # If the current character is a [ and not a ] break the loop.\n    elsif string[i]\
    \ == \"[\" && string[i] != \"]\"\n      break\n    \n    # If the current character\
    \ is a [ and not a ] break the loop.\n    elsif string[i] == \"[\" && string[i]\
    \ == \"]\"\n      nested = true\n      break\n    \n    # If the current character\
    \ is not [ or ], break the loop.\n    elsif !string[i] == \"[\" && string[i] !=\
    \ \"]\"\n      break\n    \n    # Increment the counter of characters.\n    i\
    \ += 1\n  end\n  \n  # Return whether the current string contains nested brackets\
    \ or not.\n  return nested\nend", "  string = string.to_s\n  stack = []\n  stack_reached\
    \ = false\n  nests = 0\n  brackets = [\"[\", \"]\"]\n  while !stack_reached do\n\
    \    next_index = string.index(brackets[nests])\n    if nests < brackets.length\
    \ - 1 && !(next_index == string.length - 1)\n      string << \"[#{string[next_index]}#{brackets[nests]}]\"\
    \n      nests += 1\n    else if nests == brackets.length - 1 && !(next_index ==\
    \ -1)\n      stack_reached = true\n      stack.pop\n    else\n      stack_reached\
    \ = false\n      stack << string[next_index..-1]\n    end\n  end\n  stack_reached\
    \ = true unless stack_reached\n  stack.pop\n  stack_reached = true unless stack_reached\n\
    \  stack_reached = true unless stack_reached\n  return stack_reached\nend", " \
    \ count = 0\n  for i in string.chars\n    if i == \"]\"\n      count += 1\n  \
    \  elsif i != \"[\"\n      return false\n    end\n    return true if count ==\
    \ 2\n  end\n  return true\nend", "  string =~ /\\[\\[(\\]\\)]\\]\\][\\[((\\]\\\
    )]\\)]\\]\\]/\n  return $2.empty?\nend\n</code>\n<|/ a |>\n<| c |>\nThank you,\
    \ that is the correct answer.\nI changed it a bit to make it more general.\n<|/\
    \ c |>\n<| a tags=ruby |>\nI would go with regex:\n<code>", "    stack = Array.new(string.length)\n\
    \    stack.length.times do |i|\n        if string[i] == \"[\"\n            stack.push\
    \ string[i+1]\n            i += 2\n        elsif string[i] == \"]\"\n        \
    \    stack.pop\n        end\n    end\n    stack.length == 1 && stack[0] == \"\
    [\"\nend\n</code>\n<|/ a tags=ruby,string,regex dscore=4 |>\n<| a tags=ruby,string,regex\
    \ |>\nI like's solution, though it can be expressed more concisely (I think)\n\
    <code>", "  string.gsub(/\\[\\[|\\]\\]\\]|\\]\\[|\\[|\\]|\\[|\\]\\]\\]\\]/, '').empty?\n\
    end\n</code>\nThe regular expression searches for nested square brackets. A simple\
    \ gsub will replace all occurrences, but it won't remove them. We could then just\
    \ check if there was anything left by checking that the string is empty.\n<code>",
  "\tnesting = 0\n\topening = string.index(\"[\")\n\tclosing = string.index(\"]\"\
    )\n\t\n\tfor i in string.index(string[opening+1:closing]) #start loop from closing\
    \ index and end at starting index\n\t\tif string[i] == \"[\" and string[i+1] !=\
    \ \"]\" and string[i-1] != \"]\":\n\t\t\tnesting += 1\n\t\telif string[i] == \"\
    ]\" and string[i+1] == \"[\" and string[i-1] != \"]\":\n\t\t\tnesting -= 1\n\t\
    \tif nesting > 0:\n\t\t\treturn True\n\treturn False", "    string.gsub!(/\\[/,\
    \ '{')\n    string.gsub!(/\\]/, '}')\n    string.gsub!(/\\{/, '[')\n    string.gsub!(/\\\
    }/, ']')\n    string.gsub!(/\\]/, '}')\n    string.gsub!(/\\[/, '[')\n    string.gsub!(/\\\
    ]/, ']')\n    string.gsub!(/\\]/, ']')\n    string.gsub!(/\\]/, ']')\n    string.gsub!(/\\\
    ]/, ']')\n    string.gsub!(/\\]/, ']')\n    string.gsub!(/\\]/, ']')\n    string.gsub!(/\\\
    ]/, ']')\n    string.gsub!(/\\]/, ']')\n    string.gsub!(/\\]/, ']')\n    string.gsub!(/\\\
    ]/, ']')\n    string.gsub!(/\\]/, ']')\n    string.gsub!(/\\]/, ']')\n    string.gsub!(/\\\
    ]/, ']')\n    string.gsub!(/\\]/, ']')\n    string.gsub!(/\\]/, ']')\n    string.gsub!(/\\\
    ]/, ']')\n    string.gsub!(/\\]/, ']')\n    string.gsub!(/\\]/, ']')\n    string.gsub!(/\\\
    ]/, ']')\n    string.gsub!(/\\]/, ']')\n    string.gsub!(/\\]/, ']')\n    string.gsub!(/\\\
    ]/, ']')\n    string.gsub!(/\\]/, ']')\n    string.gsub!(/\\]/, ']')\n    string.gsub!(/\\\
    ]/, ']')\n    string.gsub!(/\\]/, ']')\n    string.gsub!(/\\]/, ']')\n    string.gsub!(/\\\
    ]/, ']')\n    string.gsub!(/\\]/, ']')\n    string.gsub!(/\\]/, ']')\n    string.gsub!(/\\\
    ]/, ']')\n    string.gsub!(/\\]/, ']')\n    string.gsub!(/\\]/, ']')\n    string.gsub!(/\\\
    ]/, ']')\n    string.gsub!(/\\]/, ']')\n    string.gsub!(/\\]/, ']')\n    string.gsub!(/\\\
    ]/, ']')\n    string.gsub!(/\\]/, ']')\n    string.gsub!(/\\]/, ']')\n    string.gsub!(/\\\
    ]/, ']')\n    string.gsub!(", "  string.scan(/\\[.+?\\]\\[\\[.+?\\]\\]/)\n  string.scan(/\\\
    [.+?\\]\\[\\[.+?\\]\\]/)\n  string.scan(/\\[.+?\\]\\[\\[.+?\\]\\]/)\n  string.scan(/\\\
    [.+?\\]\\[\\[.+?\\]\\]/)\n  string.scan(/\\[.+?\\]\\[\\[.+?\\]\\]/)\n  return\
    \ true\nend\n</code>\n<|/ a |>\n<| c |>\nThe recursive method of finding nested\
    \ sets of brackets can be extended to detect unclosed parentheses too.\n<|/ c\
    \ |>\n<| a dscore=2 tags=ruby,regex |>\nThe following Regex should work:\n<code>\n\
    /\\[(([^\\[\\]]|\\[(?!])*)\\]\\[\\[(([^\\[\\]]|\\[(?!])*)\\]\\]/\n</code>\nThis\
    \ finds nested square brackets.\n<|/ a |>\n<| c |>\nWhat about `a[ b[ c[ d] ]\
    \ ]` ?\n<|/ c |>\n<| c |>\n: I thought the question was about nested sets of brackets.\n\
    <|/ c |>\n<| c |>\nI agree with you on the nested sets but this Regex doesn't\
    \ work for unclosed parentheses.\n<|/ c |>\n<| c |>\n: What about `a[ b[ c[ d]\
    \ ) ] ]`? Should it return `true`?\n<|/ c |>\n<| c |>\nNo, it shouldn't: `a[ b[\
    \ c[ d] ) ] ]` is an \"unclosed bracket\", which has two opening and one closing\
    \ parentheses, which is why I asked this question.\n<|/ c |>\n<| a |>\nThis is\
    \ a solution using lookahead and lookbehind assertions and recursion:\n<code>\n\
    /\\[(?:[^[]+|\\[(?!\\]\\])|(?R))*\\]\\[\\[(?:[^[]+|\\[(?!\\]\\])|(?R))*\\]\\]/\n\
    </code>\nDemo\n<|/ a dscore=1 tags=ruby,regex |>\n<| c |>\nThanks for your answer.\
    \ But when I try it on \"[[]]\" it returns \"false\" which is not right. Because\
    \ there should be one open square bracket after closing square bracket. Your answer\
    \ doesn't work in this case.\n<|/ c |>\n<| c |>\n: I updated my answer to also\
    \ handle unclosed bracket", "  bracket_count = 0\n  opening_bracket_count = 0\n\
    \  \n  string.each_char do |char|\n    if char == \"[\" && bracket_count > 0\n\
    \      bracket_count -= 1\n    elsif char == \"]\" && bracket_count > 0\n    \
    \  bracket_count -= 1\n    elsif char == \"(\" && opening_bracket_count > 0\n\
    \      opening_bracket_count -= 1\n    elsif char == \")\" && opening_bracket_count\
    \ > 0\n      opening_bracket_count -= 1\n    end\n  end \n  \n  return bracket_count\
    \ == 0\nend", "  string.include?(\"[\") && string.include?(\"]\")\nend", "  brackets_count\
    \ = string.count(\"[\")\n  brackets_count += string.count(\"]\")\n  \n  counter\
    \ = 0\n  while counter < string.count(\"[\")\n    counter += 1\n    \n  return\
    \ brackets_count == string.count(\"[\")\nend", "  string = string.gsub(/\\[/,\
    \ '{')\n  string = string.gsub(/\\]/, '}')\n  string = string.gsub(/}/, '}[')\n\
    \  string = string.gsub(/\\{/, '{[')\n  string = string.gsub(/\\}/, '}]')\n  string\
    \ = string.gsub(/}/, '}][')\n  string = string.gsub(/\\}/, '}]')\n  string = string.gsub(/\\\
    ]\\]/, '}]{')\n  string = string.gsub(/\\}[]/, '}]{[')\n  string = string.gsub(/\\\
    }[/, '}]{[}')\n  string = string.gsub(/\\}[/, '}]{[}')\n  string = string.gsub(/\\\
    }[/, '}]{[}')\n  string = string.gsub(/\\}/, '}]{[}')\n  string = string.gsub(/\\\
    }/, '}]{[}')\n  string = string.gsub(/\\}]/, '}]{[}')\n  string = string.gsub(/\\\
    }/, '}]{[}')\n  string = string.gsub(/\\]\\]/, '}]{[')\n  string = string.gsub(/\\\
    }/, '}]{[}')\n  string = string.gsub(/\\]\\]/, '}]{[')\n  string = string.gsub(/\\\
    }[]/, '}]{[')\n  string = string.gsub(/\\]\\]/, '}]{[')\n  string = string.gsub(/\\\
    }[]/, '}]{[')\n  string = string.gsub(/\\]\\]/, '}]{[')\n  string = string.gsub(/\\\
    }[]/, '}]{[')\n  string = string.gsub(/\\]\\]/, '}]{[')\n  string = string.gsub(/\\\
    }[]/, '}]{[')\n  string = string.gsub(/\\]\\]/, '}]{[')\n  string = string.gsub(/\\\
    }[]/, '}]{[')\n  string = string.gsub(/\\]\\]/, '}]{[')\n  string = string.gsub(/\\\
    }[]/, '}]{[')\n  string = string.gsub(/\\]\\]/, '}]{[')\n  string = string.gsub(/\\\
    }[]/, '}]{[')\n  string = string.gsub(/\\]\\]/, '}]{[')\n  string = string.gsub(/\\\
    }[]/, '}]{[')\n  string = string.gsub(/\\]\\]/, '}]{[')\n  string = string.gsub(/\\\
    }[]/, '}]{[')\n  string = string.gsub(/\\", "  brackets=0\n  open_brackets=0\n\
    \  open_brackets_counter=1\n  open_brackets_counter_counter=1\n  bracket_pairs=[]\n\
    \  bracket_pairs_counter=0\n  bracket_pairs_counter_counter=0\n  while string\
    \ != \"\"\n    bracket_pairs[bracket_pairs_counter]=string.chars\n    bracket_pairs_counter=bracket_pairs_counter+1\n\
    \    if open_brackets_counter==0\n      if string==\"[\" \n        open_brackets=open_brackets_counter_counter\n\
    \      else \n        open_brackets=open_brackets_counter\n    end\n    if open_brackets_counter==open_brackets\n\
    \      open_brackets_counter=open_brackets_counter+1\n      if string==\"]\"\n\
    \        open_brackets_counter_counter=open_brackets_counter_counter+1\n     \
    \   open_brackets_counter=open_brackets_counter-1\n      else \n        open_brackets_counter_counter=open_brackets_counter_counter\n\
    \      end\n    end\n    bracket_pairs_counter=bracket_pairs_counter_counter+1\n\
    \    string=string[1..-1]\n  end\n  if open_brackets_counter-open_brackets_counter_counter\
    \ < bracket_pairs_counter-bracket_pairs_counter_counter\n    true\n  else\n  \
    \  false\n  end\nend\n</code>\nIt has some inefficiencies, but I think it will\
    \ do. Please, let me know if you find any issues or think I haven't understood\
    \ your problem enough.\n<|/ a |>\n<| c |>\nI see what you did there. But as my\
    \ question was \"how do I use recursion to solve this problem?\" I did not want\
    \ to use a function which would have just one parameter, that was just to simplify\
    \ the problem.\n<|/ c |>\n<| c |>\nYou're right, it wasn't so simple. I've edited\
    \ the answer to reflect that I'm really not that good at recursion... Sorry for\
    \ that.\n<|/ c |>\n<| c |>\nYou said 'a recursive function would have one parameter'....\
    \ I don't think you read it right... If you take a look at the [code](http://pastebin.com/mWJqZPqx),\
    \ you see that `is_nested` is actually a recursive function...\n<|/ c |>\n<| c\
    \ |>\nOh sorry, you're right. I'm not so good at recursion. I'm going to ", " \
    \ string.gsub(/\\[|\\]/, \"\").empty?\nend", "    brackets = string.scan(/[\\\
    [\\]\\{\\}]/)\n    \n    bracket_count = brackets.size\n    \n    return bracket_count\
    \ >= 2 \nend", "    string.count(\"[\") == 1\n    string.count(\"]\") == 1\nend",
  "  string = \"[\" + string + \"]\"\n  brackets = []\n  string.scan(/\\[/){|brackets\
    \ << $1; string.scan(/\\]/)}\n  return (brackets.count.nonzero? && brackets.size\
    \ == brackets.uniq.size)\nend\n</cell>\n<code language=julia-0.5>\nis_nested.call(\"\
    [[]][[[]]\")\n</cell>\n<text>\nExercise: Write a function that accepts a string\
    \ as input, and returns true if the string contains no square brackets, otherwise\
    \ false.", "  string = string.to_s\n  open_square_count = 0\n  close_square_count\
    \ = 0\n  open_bracket_count = 0\n  close_bracket_count = 0\n  \n  i = 0\n  while\
    \ i < string.length\n    if string[i] == \"[\"\n      open_square_count = open_square_count\
    \ + 1\n      i = i + 1\n      while i < string.length and string[i] != \"]\"\n\
    \        i += 1\n      close_square_count = close_square_count + 1 - open_square_count\n\
    \      if close_square_count > 0 # We must have an open square bracket\n     \
    \   if open_bracket_count > 0 # There must have been an open bracket\n       \
    \   break\n      else # We must have an close square bracket\n        if close_bracket_count\
    \ > 0 # There must have been a close bracket\n          break\n    else # string[i]\
    \ == \"{\"\n      open_bracket_count = open_bracket_count + 1\n      i = i + 1\n\
    \      while i < string.length and string[i] != \"}\" \n        i += 1\n     \
    \ close_bracket_count = close_bracket_count + 1 - open_bracket_count\n      if\
    \ close_bracket_count > 0 # We must have an open braket\n        if open_square_count\
    \ > 0 # There must have been an open square\n          break\n      else # We\
    \ must have an close bracket\n        if close_square_count > 0 # There must have\
    \ been an close square\n          break\n    i = i + 1\n  return open_square_count\
    \ >= close_square_count and open_bracket_count >= close_bracket_count\nend", " \
    \ regexp = /(?:(?:\\[(?:[^\\[\\]]|(?<=\\])])+\\])+|(?:\\[(?:[^\\[\\]]|(?<=\\])])+\\\
    ]))/\n  return regexp.test(string)\nend", "  string.length <= 0\nend", "    \n\
    \    stack = []\n    char = 0\n    while char <= string.length\n      if string[char]\
    \ == '['\n        stack << char\n      elsif string[char] == ']'\n        if stack.length\
    \ == 0\n          return false\n        else\n          stack.pop\n        end\n\
    \      end\n      char += 1\n    end\n    \n    if stack.length == 0\n      return\
    \ true\n    else\n      return false\n    end\n  end\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nYou should return `true` when stack.length reaches 0 because `[]`\
    \ can have a valid subsequence in the last character and that subsequence could\
    \ be nested inside other brackets.\n<|/ c |>\n<| c |>\nThank you for the help!\
    \ This worked!\n<|/ c |>\n<| a tags=ruby |>\n<code>", "    nesting = string.gsub('[\\\
    \\[\\\\]]', '', :gsub '[][][][]', :gsub '[][][]', :gsub '[][]')\n    nesting =\
    \ nesting == '' ? 'true' : nesting\n    return nesting == 'true'\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThat would be a lot more code, and wouldn't even work\
    \ for a valid string with brackets inside of brackets. If you don't want that\
    \ functionality, there's no need to use a regex here. Regexes are great for matching\
    \ things that can appear in strings, but not for things like brackets.\n<|/ c\
    \ |>\n<| c |>\nIt will match brackets inside of brackets, but not inside of string\
    \ delimiters. For example, it will correctly return `true` for `\"[[]]\"`, but\
    \ not `\"[[[[[]]]]][[[[[]]][[[]]]]\"`.\n<|/ c |>\n<| c |>\nOh, and I just read\
    \ your question again. You're right that regex won't work. Sorry.\n<|/ c |>\n\
    <| c |>\nNo worries, I appreciate your help so much. Now that I know what to do\
    \ with it I can probably rewrite it in a way that doesn't require the use of any\
    \ regex.\n<|/ c |>\n<| c |>\nThanks, I edited the post to add some explanation.\n\
    <|/ c |>\n<| a |>\nI did this by splitting the string by opening and closing square\
    \ brackets and then checking if the parts inside are opening and closing bracketed\
    \ pairs.\n<code>", "  brackets = string.count(\"[\")\n  nests = string.count(\"\
    [[]\")\n  return brackets > nests\nend", "  brackets_found = string.count('[')\
    \ - string.count(']')\n  return brackets_found > 0 and string.length % brackets_found\
    \ == 0\nend", "  opens = 0\n  nests = string.count(\"[\")\n  closes = string.count(\"\
    ]\")\n  \n  if nests < opens or nests > closes then \n    return false\n    \n\
    \  for i in string.chars\n    if i =~ /^\\[/ then\n      opens += 1\n    elsif\
    \ i =~ /^\\]/ then\n      opens -= 1\n    end\n  end\n  \n  return true\nend",
  "    nesting = 0\n    position = 0\n    brackets = 0\n    \n    while position <\
    \ string.length\n        if string.charAt(position) == \"[\"\n            brackets\
    \ += 1\n        else if string.charAt(position) == \"]\"\n            brackets\
    \ -= 1\n        else if brackets == 0\n            return true\n        \n   \
    \     position += 1\n        \n    return false", "  return string.scan(/\\[\\\
    [.*\\]\\]/).any?\nend", "  \n  # A stack that stores brackets \n  stack = Array.new",
  "    # Remove any whitespace\n    string = string.gsub(/\\s+/, \"\")\n    \n   \
    \ # Determine if the string is valid by checking for balanced brackets\n    bracket_counts\
    \ = Hash.new(0)\n    bracket_counts.each { |bracket_counts, bracket_count| bracket_count\
    \ += 1 if string[bracket_count] == '[' }\n    bracket_counts.each { |bracket_counts,\
    \ bracket_count| bracket_count += 1 if string[bracket_count] == ']' }\n    bracket_counts.each\
    \ { |bracket_counts, bracket_count| bracket_count += 1 if string[bracket_count]\
    \ == '}' }\n    \n    return (bracket_counts[:-2] > 0)\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>", "    bracket_count = 0\n    bracket_position\
    \ = 0\n    \n    while bracket_position < string.length\n        bracket_position\
    \ = string.index('[', bracket_position)\n        if bracket_position == -1\n \
    \           break\n        bracket_count += 1\n    \n    bracket_count += 1 #\
    \ Count final bracket as well.\n    \n    return bracket_count % 2 != 0\n    \n\
    </cell>\n<text>\nWe now define some different functions that will evaluate the\
    \ bracket string in different ways:", "  string.scan(/\\[.*?\\]/m).length\nend\n\
    </code>\n<|/ a dscore=1 tags=ruby,regex |>\n<| c |>\nI like this, very clean.\
    \ I'll see if I can implement this in ruby. Thanks\n<|/ c |>\n<| c |>\nThis is\
    \ basically the same as mine, but I was working on it, so I didn't post my answer,\
    \ but I've tested it and it works great. Thanks!\n<|/ c |>\n<| a tags=ruby,regex\
    \ dscore=1 |>\nHere's a regexp that works:\n<code>\n/\\[(?:([^\\[]+)\\[\\(([^\\\
    [\\]]*)\\)\\])?\\]/\n</code>\nTesting it out:\n<code>\nirb> string = \"[[]]\"\n\
    => \"[[]]\"\nirb> string.match(/\\[(?:([^\\[]+)\\[\\(([^\\[\\]]*)\\)\\])?\\]/)\n\
    => #<MatchData \"[[]]\">\nirb> string = \"[][[]]\"\n=> \"[][[]]\"\nirb> string.match(/\\\
    [(?:([^\\[]+)\\[\\(([^\\[\\]]*)\\)\\])?\\]/)\n=> #<MatchData \"[][[]]\">\nirb>\
    \ string = \"[]]\"\n=> \"[]]\"\nirb> string.match(/\\[(?:([^\\[]+)\\[\\(([^\\\
    [\\]]*)\\)\\])?\\]/)\n=> nil\nirb> string = \"[]]\"\n=> \"[]]\"\nirb> string.match(/\\\
    [(?:([^\\[]+)\\[\\(([^\\[\\]]*)\\)\\])?\\]/)\n=> nil\nirb> string = \"[][]]\"\n\
    => \"[][]]\"\nirb> string.match(/\\[(?:([^\\[]+)\\[\\(([^\\[\\]]*)\\)\\])?\\]/)\n\
    => nil\n</code>\nThe idea is to find all the pairs of [...] that are nested, and\
    \ get the substring of string that matches that.\nThe regexp above uses non-capturing\
    \ groups, and also contains lookarounds.\n<|/ a |>\n<| c |>\nThis seems to be\
    \ working. Just tested with `irb` and also on the website and it seems to be working.\
    \ Thanks!\n<|/ c |>\n<| a |>\nA regex that does the job:\n<code>\n/\\[([^[]*(?:\\\
    [(?!\\[\\[)|(?!])\\[[^[]*)*)]]\\]/\n</code>\nExplanation:\n<code>\n\\[       \
    \  # Match a '['\n([^[]*)   # Capture anything not a '['\n(?:", "    string.count(\"\
    [\")\n    string.count(\"]\")\n    string.count(\"(\")\n    string.count(\")\"\
    )\nend", "  regex = /(\\[)\\[(([^\\]\\[]*)\\[]|[^\\]\\[]+)\\]\\]/\n  return string\
    \ =~ regex\nend", "  string.scan(/[\\[\\]]/).count > 0\nend\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nWhy does this work? I don't see how. Can you explain the regular\
    \ expression a little bit?\n<|/ c |>\n<| c |>\nI added a description of the regular\
    \ expression to my answer. I'm also adding an explanation of how it works.\n<|/\
    \ c |>\n<| a tags=ruby,nested,arrays |>\nHere's a little bit of code I came up\
    \ with:\n<code>", "    bracket_open = string.index(\"[\")\n    bracket_close =\
    \ string.index(\"]\")\n    bracket_open = string[bracket_open + 1 : bracket_close]\n\
    \    bracket_close = string[bracket_close + 1 : bracket_close]\n    return bracket_open\
    \ != bracket_close", "    brackets_count = 0\n    index_1 = 0\n    index_2 = 0",
  "  stack = []\n  index = 0", "  string.gsub(/\\[\\[|\\]\\]|\\[\\]\\[\\]|\\[[]\\\
    ]\\[\\[|\\]\\]|\\[\\[\\]\\]|\\[\\[\\[\\]\\]\\]/).empty?\nend", "  # Write your\
    \ code here\n  string.count(\"[\") - string.count(\"]\")\nend\n</code>\n<|/ a\
    \ tags=ruby,regex,string |>\n<| c |>\nThis answer has a few bugs; for example,\
    \ `is_nested(\"[][[[]\")` returns `true`, when it should be `false`.\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>", "  brackets = 0\n  nestings = 0\n  for i in string\n\
    \    if i == '['\n      brackets += 1\n    if i == '['\n      nestings += 1\n\
    \    if i == ']'\n      nestings -= 1\n      if nestings < 0\n        return false\n\
    \    if i == ']'\n      brackets -= 1\n      if brackets < 0\n        return false\n\
    \  end\n  return true\nend", "  stack = []\n  brackets = \"[]\"\n  depth = 0\n\
    \  index = 0\n  subseq = []\n  while index < string.length\n    if string[index]\
    \ in brackets\n      subseq = [string[index]] + subseq\n      index += 1\n   \
    \ else if subseq.length > 0\n      stack.pop\n      depth += 1\n    else if stack.length\
    \ > 0\n      stack.pop\n      depth += 1\n      brackets = \"[\" + brackets\n\
    \    else\n      return false\n  end\n  return stack.length == 0 or stack.length\
    \ >= depth\nend", "  nesting.add(string)\n  bracket_count = 0\n  open_bracket\
    \ = nil\n  close_bracket = nil\n  nesting.each do |bracket|\n    bracket_count\
    \ += 1\n    if bracket.chars.all?{|c| c == open_bracket.chars.first}\n      open_bracket\
    \ = bracket\n    end\n    if bracket.chars.all?{|c| c == close_bracket.chars.first}\n\
    \      close_bracket = bracket\n    end\n  end\n  nesting.delete(string)\n  return\
    \ bracket_count > 0\nend\n</cell>\n<cell>", "  bracket_count = string.length\n\
    \  current_bracket = 0\n  found_matching_bracket = false\n  \n  while current_bracket\
    \ < bracket_count\n    if string[current_bracket] == '['\n      current_bracket\
    \ += 1\n      if found_matching_bracket\n        found_matching_bracket = false\n\
    \      else\n        found_matching_bracket = true\n        bracket_count += 1\n\
    \      end\n    elsif string[current_bracket] == ']'\n      current_bracket +=\
    \ 1\n      bracket_count -= 1\n      found_matching_bracket = false\n    end\n\
    \  end\n  \n  found_matching_bracket\nend", "  count = 0\n  for i in string.chars\
    \ \n    if i == '[' then \n      count += 1\n    elsif i == '{' then \n      count\
    \ -= 1\n    elsif i == ']' and count > 0 then \n      count -= 1\n    elsif i\
    \ == '}' and count < 0 then \n      count += 1\n    else \n      return false\n\
    \  return true\nend ", "  bracket_counts = string.scan(/\\[/)\n  (brackets, brackets_count)\
    \ = (bracket_counts[-1], bracket_counts.length) if bracket_counts.length > 0 else\
    \ (bracket_counts, 0)\n  nested_brackets = string.scan(/\\[/) - brackets\n  nested_brackets_count\
    \ = brackets_count - nested_brackets.length if brackets_count > nested_brackets.length\
    \ else 0\n  nested_brackets_count += 1 if nested_brackets_count > 1 else 0\n \
    \ (nested_brackets, nested_brackets_count) = (nested_brackets[nested_brackets_count],\
    \ nested_brackets.length) if nested_brackets.length > 0 else (nested_brackets,\
    \ 0)\n  nested_brackets_count += 1 if nested_brackets_count > 1 else 0\n  nested_brackets_count\
    \ += 1 if nested_brackets_count > 1 else 0\n  return nested_brackets_count ==\
    \ 1\nend", "  stack = []\n  for i in string.chars\n    if i == \"[\" then\n  \
    \    if stack.empty?\n        stack << i\n      else\n        stack.pop\n    \
    \  end\n    elsif i == \"]\" then\n      if stack.empty? then\n        return\
    \ false\n      else\n        stack.push i\n      end\n    elsif stack.empty? and\
    \ i != \"[\" then\n      return false\n    end\n  end\n  stack.pop\n  return true\n\
    end", "  string.scan(/\\[|\\]/)\n  \n  string.scan(/\\[|\\]|\\]/)\n  return true\
    \ if string.scan(/\\[|\\]/).count > string.length\n  \n  string.scan(/\\[|\\]|\\\
    ]\\[|\\]/)\n  return true if string.scan(/\\[|\\]|\\]\\[|\\]/).count > string.length\n\
    \  \n  string.scan(/\\[|\\]|\\]\\[|\\]\\[|\\]/)\n  return true if string.scan(/\\\
    [|\\]|\\]\\[|\\]\\[|\\]/).count > string.length\n  \n  string.scan(/\\[|\\]|\\\
    ]\\[|\\]\\[|\\]\\[|\\]/)\n  return true if string.scan(/\\[|\\]|\\]\\[|\\]\\[|\\\
    ]\\[|\\]/).count > string.length\n  \n  string.scan(/\\[|\\]|\\]\\[|\\]\\[|\\\
    ]\\[|\\]\\[|\\]\\[|\\]/)\n  return true if string.scan(/\\[|\\]|\\]\\[|\\]\\[|\\\
    ]\\[|\\]\\[|\\]\\[|\\]/).count > string.length\n  \n  string.scan(/\\[|\\]|\\\
    ]\\[|\\]\\[|\\]\\[|\\]\\[|\\]\\[|\\]\\[|\\]\\[|\\]/)\n  return true if string.scan(/\\\
    [|\\]|\\]\\[|\\]\\[|\\]\\[|\\]\\[|\\]\\[|\\]\\[|\\]\\[|\\]/).count > string.length\n\
    \  \n  string.scan(/\\[|\\]|\\]\\[|\\]\\[|\\]\\[|\\]\\[|\\]\\[|\\]\\[|\\]\\[|\\\
    ]\\[|\\]\\[|\\]\\[|\\]\\[|\\]/)\n  return true if string.scan(/\\[|\\]|\\]\\[|\\\
    ]\\[|\\]\\[|\\]\\[|\\]\\[|\\]\\[|\\]\\[|\\]\\[|\\]\\[|\\]\\[|\\]\\[|\\]\\[|\\\
    ]/).count > string.length\n  \n  string.scan(/\\[|\\]|\\]\\[|\\]\\[|\\]\\[|\\\
    ]\\[|\\]\\[|\\]\\[|\\]\\[|\\]\\[|\\]\\[|\\]\\[|\\]\\[|\\]\\[|\\]\\[|\\]\\[|\\\
    ]/)\n  return true if string.scan(/\\[|\\]|\\]\\[|\\]\\[|\\]\\[|\\]\\[|\\]\\[|\\\
    ]\\[|\\]\\[|\\]\\[|\\]\\[|\\]\\[|\\]\\[|\\]\\[|\\]\\[|\\]\\[|\\]\\[", "  regex\
    \ = /\\[([^\\[\\]]+)\\]/\n  matches = string.scan(regex)\n  matches.each do |match|\n\
    \    bracket_count = 0\n    bracket_start = match[0].length\n    bracket_end =\
    \ match.length\n    bracket = string.slice(bracket_start,bracket_end)\n    match\
    \ = match[0]\n    matches[bracket_count].each do |nested|\n      bracket = bracket.slice(0,bracket_end-1)\n\
    \      bracket_end -= 1\n      if nested[0] == match\n        bracket_count +=\
    \ 1\n        bracket_start += 1\n      end\n    end\n    return bracket_count\
    \ > 1\n  end\n  return false\nend", "  nest = 0\n  index = 1\n  while index <\
    \ string.length\n    if string[index] == \"[\"\n      nest += 1\n    elsif string[index]\
    \ == \"]\"\n      nest -= 1\n      if not nest\n        return true\n      end\n\
    \    end\n    index += 1\n  end\n  return false\nend", "    nesting = true\n \
    \   start = string.index(\"[\")\n    while start < string.rindex(\"]\") do\n \
    \       substring = string.slice(start, string.rindex(\"]\", start) + 1)\n   \
    \     if is_nested.call(substring) == false then nesting = false\n        start\
    \ = string.index(\"[\", start + 1)\n    end\n    substring = string.slice(start,\
    \ string.rindex(\"]\", start) + 1)\n    return substring == \"\" and nesting\n\
    end", "    nesting = 1\n    if string[0] != \"]\" then nesting += 0 end\n    if\
    \ string[-1] != \"]\" then nesting += 0 end\n    \n    i = 2\n    while i < string.length\
    \ and string[i] != \"[\" do\n        if string[i] == \"]\" then\n            if\
    \ string[i - 1] == \"[\" then\n                if string[i + 1] == \"]\" then\n\
    \                    nesting += 0\n                else\n                    nesting\
    \ -= 1\n                end\n            else\n                nesting -= 1\n\
    \            end\n        end\n        i += 1\n    end\n    \n    return nesting\
    \ > 0\nend", "    bracket_regex = /[][\\[\\]]/g\n    bracket_count = bracket_regex.match(string).count\n\
    \    nested_count = string.scan(bracket_regex).count - bracket_count\n    \n \
    \   if bracket_count == 0 or nested_count == 0\n        return false\n    end\n\
    \    return true\nend", "    opens = []\n    closes = []\n    index = 0\n    while\
    \ index < string.length\n        if string[index] == \"]\"\n            index\
    \ += 1\n            if index == string.length\n                return true\n \
    \           closes << index\n        elsif string[index] = \"[\"\n           \
    \ index += 1\n            if index == string.length\n                return false\n\
    \            opens << index\n        end\n        index += 1\n    end\n    opens.length\n\
    end", "  brackets = string.count(\"[\")\n  squares = string.count(\"]\")\n  \n\
    \  valid_nesting = (brackets == squares) ", "  bracket_counter = 0\n  stack =\
    \ []\n  bracket_open = false\n  bracket_close = false\n  \n  # For loop to loop\
    \ through the string\n  for char in string\n    if char == \"[\"\n      if bracket_open\n\
    \        stack.push(char)\n      else\n        bracket_open = true\n        stack.push(char)\n\
    \    elsif char == \"]\"\n      if bracket_open\n        if bracket_close \n \
    \         return stack.pop == \"[\"\n        else\n          bracket_close = true\n\
    \          stack.push(char)\n      elsif stack.length > 0\n        return stack.pop\
    \ == \"[\"\n      else\n        return false\n      end\n    else\n      if bracket_open\n\
    \        stack.push(char)\n      else\n        bracket_open = true\n        stack.push(char)\n\
    \      end\n    end\n  end\nend", "    string = get_str(string)\n    count = 0\n\
    \    stack = []\n    stack_string = ''\n    open_count = 0\n    for c in string\n\
    \        if c == '['\n            stack << c\n            open_count += 1\n  \
    \          count += 1\n        if c == ']'\n            open_count -= 1\n    \
    \        close_count = open_count if open_count > 0 else 0\n            count\
    \ += close_count\n            if close_count == 0 and open_count > 0 and stack[open_count-1]\
    \ != '['\n                return true\n            if close_count > 0 and open_count\
    \ < 1 and stack[open_count] == '['\n                return true\n            stack.pop\
    \ if close_count > 0 else None\n            stack_string = '' if close_count >\
    \ 0 else None\n    return false\nend", "  # TODO: Your code goes here\n  false\n\
    end", "  brackets = string.scan(/\\[.*?\\]/)\n  nesting = brackets.inject(0) do\
    \ |sum, s| \n    sum += s.count(\"[]\")\n  end\n  nesting > 0\nend", "  stack=Stack.new\n\
    \  stack.push(string)\n  while stack.size>0\n    content=stack.peek\n    begin=content.index(\"\
    [\")\n    if begin<0\n      return false\n    end=content.index(\"]\")\n    if\
    \ end==nil\n      return false\n    end+=1\n    if content[begin..end]!=\"[]\"\
    \n      return false\n    end+=1\n    stack.pop(true)\n  end\n  return true\n\
    end\n</code>\n<|/ a |>\n<| a dscore=0 |>\nA simple and efficient way to solve\
    \ this question would be to use a DFS algorithm. \n<code>\nprivate static boolean\
    \ isNested(String str)\n{\n    boolean[] visited = new boolean[str.length()];\n\
    \    Stack<Character> stack = new Stack<Character>();\n    stack.add('{');\n \
    \   stack.add('[');\n    for (int i = 0; i < str.length(); i++) {\n        char\
    \ ch = str.charAt(i);\n        if (ch == '{' || ch == '[') {\n            stack.add(ch);\n\
    \        }\n        else if (ch == '}' || ch == ']') {\n            while (!stack.isEmpty()\
    \ && stack.pop() != ch) {\n            }\n            if (stack.isEmpty()) {\n\
    \                return false;\n            }\n        }\n        else if (visited[i])\
    \ {\n            return false;\n        }\n        visited[i] = true;\n    }\n\
    \    return true;\n}\n</code>\n<|/ a tags=string,ruby,arrays |>\n<| c |>\nCan\
    \ you explain your answer a bit? Code-only answers tend not to help much.\n<|/\
    \ c |>\n<| a tags=string,ruby,arrays |>\nWe can use regular expressions in combination\
    \ with sub to do this.\n<code>", "    string.match?(/\\[([^]]*?)\\]$/)\nend",
  "  string.scan(/\\[\\[\\]/) != nil # return true if and only if there is a valid\
    \ subsequence of brackets\nend", "  brackets = 0\n  stack = []\n  string.gsub(/\\\
    [|\\]| /) do |match|\n    if match == \"[\" then \n      stack << match\n    \
    \  brackets += 1\n    elsif match == \"]\" then\n      brackets -= 1\n      if\
    \ brackets < 1 then \n        return stack[-1] == \"[\"\n      end\n    elsif\
    \ match == \" \" then\n      return stack.pop == \" \"\n    end\n  end\n  return\
    \ false\nend\n</code>\n<|/ a |>\n<| c |>\nI guess this doesn't work for empty\
    \ brackets []\n<|/ c |>\n<| c |>\nI believe it does work (tested on irb console,\
    \ ruby 2.5.5p157). For me, if there are no brackets [] in the string, it returns\
    \ true.\n<|/ c |>\n<| c |>\nIt works fine, thanks alot, but I thought there should\
    \ be more elegant solution, I mean in O(n) time complexity.\n<|/ c |>\n<| c |>\n\
    , maybe I missed something, but this looks O(n) to me too (if I'm right that is).\n\
    <|/ c |>\n<| c |>\nThis algorithm is correct and works fine, but I thought there\
    \ should be some elegant solution in O(n) time complexity, since this code is\
    \ in Ruby.\n<|/ c |>\n<| a dscore=2 |>\nI came up with a simple solution:\n<code>",
  "    return true if substring_nesting(string, 0, string.length, string.length)\n\
    end", "  stack = []\n  nesting = 0\n  brackets = 0\n  for i in string\n    if\
    \ i == \"]\" and nesting > 0\n      brackets = brackets - 1\n    stack << i\n\
    \    if brackets == 0 and stack[0] == \"[\" and stack[-1] == \"]\"\n      nesting\
    \ = nesting + 1\n  return nesting > 0\nend", "  return false if !string || string.empty?\
    \ || string.size == 1 || (string[0] != '[' && string[-1] != ']') else true\nend\n\
    </cell>\n<code language=julia-1.0>", "  \n  # Define a stack to keep track of\
    \ the brackets\n  stack = []\n  \n  # Split the input string into individual characters\n\
    \  chars_array = string.split(\"\")\n  \n  # Iterate through the characters in\
    \ reverse order and maintain state\n  for i in chars_array\n    if i == \"[\"\
    \ || i == \"{\" || i == \"}\" || i == \"(\"\n      stack.push(i)\n    elsif i\
    \ == \"]\" || i == \")\"\n      # Remove the top bracket and see if the top two\
    \ are matching pairs of brackets\n      if stack.pop == \"[\" && stack.pop ==\
    \ \"[\"\n        true\n      elsif stack.pop == \"{\" && stack.pop == \"{\"\n\
    \        true\n      elsif stack.pop == \"}\" && stack.pop == \"}\"\n        true\n\
    \      end\n    end\n  end\n  \n  # Return false if stack is empty\n  if stack.empty?\n\
    \    false\n  end\nend", "  stack = []\n  for i in string.chars\n    if i == \"\
    [\"\n      stack << i\n    elsif i == \"]\" and stack.length > 0\n      stack.pop\n\
    \    else\n      return false\n  \n  return true\nend", "  nest = 0\n  i = string.index(\"\
    [\")\n  while i != -1\n    nest += 1\n    i = string.index(\"[\", i + 1)\n  i\
    \ = string.index(\"]\", i + 1)\n  while i != -1\n    nest -= 1\n    i = string.index(\"\
    ]\", i + 1)\n  nest == 0\nend", "  string.scan(/(?:\\[(?:\\]|[^\\]\\[]|\\[(?1)\\\
    ]|[^\\][]*(?2)\\])|\\[([^\\[]*(?2)\\][^\\[\\]]*(?3))\\])/)\nend\n  ", "  if string.match(/\\\
    [.*\\]/)\n    return true\n  return false\nend", "  string.scan(/\\[([^\\[\\]]*\\\
    )]{0,}|\\[([^\\[\\]]*)\\]/) do |match|\n    if match[1]\n      !nested.include?(match[1])\n\
    \    elsif match[2]\n      !nested.include?(match[2])\n    end\n  end\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a |>\nHere's my solution (which has one flaw: it won't handle\
    \ nested brackets in strings that don't include brackets), but it passes your\
    \ tests \n<code>", "    string.chars.each_with_index do |char, i|\n        next\
    \ if char == \"]\" \n        char == \"[\" ? nested_depth[char] = i : nested_depth[char]\
    \ = nil\n    end\n    \n    string.chars.each_with_index do |char, i|\n      \
    \  if char == \"[\"\n            nested_depth[char] = i\n        elsif char ==\
    \ \"]\"\n            return true if nested_depth[char] - i > 0\n        end\n\
    \    end\n    \n    false\nend", "  return true if string.scan(/\\[\\[|\\]/).count\
    \ > 1\n  false\nend\n</code>\nI hope this helps. Good luck.\n<|/ a tags=string,ruby,regex\
    \ |>\n<| a tags=string,ruby,regex |>\nThe best solution I can come up with so\
    \ far is:\n<code>\nstring.scan(/\\[\\[|\\]/).count > 1\n</code>\n(I agree with\
    \ that this is the best answer so far).\nAnother solution would be to match all\
    \ possible nested brackets and test the length of the resulting array:\n<code>\n\
    string.scan(/\\[(?:\\[(?:\\[(?:\\[(?:\\[(?:\\[(?:\\[(?:\\[(?:\\[(?:\\[\\[|\\]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|]|",
  "  brackets = string.count(\"[\")\n  square = string.count(\"]\")\n  return (brackets\
    \ + square == brackets)", "    # check if there is no brackets in the string\n\
    \    if string.count \"[]\" == 0\n        return false\n    \n    # initialize\
    \ a counter of [\n    counter = 0\n    \n    # iterate over the string\n    for\
    \ index in 0..string.count(\"[]\")-1\n        # if the counter is odd, then the\
    \ string is nested with one or more brackets open\n        if counter % 2 == 1\n\
    \            return true\n        \n        # increment the counter\n        counter\
    \ += 1\n    end", "  string.scan(/[]/).all? { |el| is_bracket(el) }\nend", " \
    \ bracket_count = 0\n  stack = Array.new\n  stack.push(Array.new)\n  stack[0].push(\"\
    [\")\n  \n  for i in 0..string.length\n    if string[i] != '[']\n      stack.push(\"\
    [\")\n      bracket_count += 1\n    else \n      if bracket_count > 0\n      \
    \  bracket_count -= 1\n      else \n        stack[0].push(string[i])\n      end\n\
    \    end\n  \n  if bracket_count > 0\n    return false\n  else \n    stack[0].pop\n\
    \    bracket_count = 0\n    stack = stack[0..-2]\n    stack.each do |array|\n\
    \      new_array = Array.new\n      stack.each do |subarray|\n        new_array\
    \ << subarray.join(\"\")\n      end\n      new_array.each do |i|\n        if array[i]\
    \ != '[' or not is_nested(array[i])\n          return false\n        end\n   \
    \   end\n    end\n    return true\n  end\nend", "  nesting = false\n  bracket_count\
    \ = 0\n  bracket_level = 0\n  bracket_stack = []", "    brackets = string.count(\"\
    [\")\n    square_brackets = string.count(\"]\")\n    return brackets > square_brackets\n\
    end\n</code>\nA different way of looking at this, is to look at a string of brackets\
    \ and see how many times they occur in a row, rather than trying to deduce that\
    \ a sequence is nested with at least one bracket.\n<|/ a tags=python,string |>\n\
    <| c |>\nThis assumes the input is valid. If someone passes in a string with an\
    \ extra pair of brackets, this will give an incorrect result.\n<|/ c |>\n<| c\
    \ |>\nYes, I assumed that, but it doesn't matter if the OP wants the function\
    \ to handle a partial input as long as they know how to use this function, as\
    \ long as they can pass a string that only contains square brackets. I've updated\
    \ the function to make it clear.\n<|/ c |>\n<| a |>\nThis is a possible solution:\n\
    <code>\nstring = \"[]\"\nstack = []\nfor c in string:\n    if c == \"[\":\n  \
    \      stack.append(\"[\")\n    elif c == \"]\":\n        if len(stack) > 1:\n\
    \            stack.pop()\n            if len(stack) == 0:\n                return\
    \ True\n        else:\n            return False\n</code>\n<|/ a tags=python,string\
    \ dscore=0 |>\n<| a dscore=0 tags=python,string |>\nI came up with the following\
    \ code:\n<code>", "    # Return true if the brackets are valid nesting brackets.\n\
    \    # Brackets can be nested, so a nested bracket string should have a length\
    \ >= 2, \n    # and at most 1 other bracket.\n    # Return false if the brackets\
    \ are not valid nesting brackets.\n    nesting_count = 1\n    bracket_count =\
    \ 0\n    nested_brackets = \"\"\n    has_nested_brackets = false\n    brackets\
    \ = string.split(\" \") # Split string into array of strings\n    brackets.each\
    \ do |b|\n        if b == \"[\"\n            bracket_count += 1\n            nested_brackets\
    \ += b\n        elsif b == \"]\"\n            bracket_count -= 1\n           \
    \ if bracket_count < 0\n                # If there are less than the desired number\
    \ of brackets \n                # then we must have reached a non-nesting bracket\
    \ string\n                # and thus not nested.\n                has_nested_brackets\
    \ = false\n            elsif bracket_count > 0\n                # If we haven't\
    \ reached a non-nesting bracket string\n                # yet and there are more\
    \ than the desired number of brackets\n                # then we must have reached\
    \ the correct number of nesting brackets.\n                nesting_count = bracket_count\n\
    \            elsif bracket_count == 0\n                # If we're still counting\
    \ brackets then we must have reached the correct number of brackets\n        \
    \        nesting_count = bracket_count\n            end\n        elsif bracket_count\
    \ > 0 and b == \"[\"\n            # If the bracket is nested, then we must have\
    \ gotten a non-nested\n            # bracket, so we can't be a nested bracket.\n\
    \            has_nested_brackets = false\n        end\n    end\n    has_nested_brackets\
    \ || nesting_count > 0 || nesting_count == 0\nend", '  return string.count("[")==string.count("]")',
  "  \n  # Loop through every character in the string\n  for i in 0..length\n    if\
    \ string[i] != string[i+1]\n      # If there's a mismatch in brackets, return\
    \ false\n      return false\n    end\n  end", "  return string.match(/\\[\\[\\\
    [\\[.+?\\]\\]\\]\\]\\]/g)\nend\n</code>\nThis works because Ruby has regex-matching\
    \ capabilities. But is is also an option:\n<code>", "\tstring.gsub!(\"[\\[\\]\\\
    {\\}]\", \"\") # Remove brackets\n\tstring.gsub!(\"[\", \"\") # Remove nested\
    \ brackets\n\tstring.gsub!(\"]\", \"\") # Remove nested brackets\n\tstring.gsub!(\"\
    ]\", \"\")\n\tstring.gsub!(\"[\", \"\")\n\tstring.gsub!(\"]\", \"\")\n\tstring.gsub!(\"\
    {\", \"\")\n\tstring.gsub!(\"}\", \"\")\n\tstring.gsub!(\"{\", \"\")\n\tstring.gsub!(\"\
    }\", \"\")\n\tstring.gsub!(\"(\", \"\")\n\tstring.gsub!(\")\", \"\")\n\tstring.gsub!(\"\
    {\", \"\")\n\tstring.gsub!(\"}\", \"\")\n\tstring.gsub!(\"(\", \"\")\n\tstring.gsub!(\"\
    )\", \"\")\n\tstring.gsub!(\",\", \"\")\n\tstring.gsub!(\",\", \"\")\n\tstring.gsub!(\"\
    ,\", \"\")\n\tstring.gsub!(\",\", \"\")\n\tstring.gsub!(\",\", \"\")\n\tstring.gsub!(\"\
    ,\", \"\")\n\tstring.gsub!(\",\", \"\")\n\tstring.gsub!(\",\", \"\")\n\tstring.gsub!(\"\
    ,\", \"\")\n\tstring.gsub!(\",\", \"\")\n\tstring.gsub!(\",\", \"\")\n\tstring.gsub!(\"\
    ,\", \"\")\n\tstring.gsub!(\",\", \"\")\n\tstring.gsub!(\",\", \"\")\n\tstring.gsub!(\"\
    ,\", \"\")\n\tstring.gsub!(\",\", \"\")\n\tstring.gsub!(\",\", \"\")\n\tstring.gsub!(\"\
    ,\", \"\")\n\tstring.gsub!(\",\", \"\")\n\tstring.gsub!(\",\", \"\")\n\tstring.gsub!(\"\
    ,\", \"\")\n\tstring.gsub!(\",\", \"\")\n\tstring.gsub!(\",\", \"\")\n\tstring.gsub!(\"\
    ,\", \"\")\n\tstring.gsub!(\",\", \"\")\n\tstring.gsub!(\",\", \"\")\n\tstring.gsub!(\"\
    ,\", \"\")\n\tstring.gsub!(\",\", \"\")\n\tstring.gsub!(\",\", \"\")\n\tstring.gsub!(\"\
    ,\", \"\")\n\tstring.gsub!(\",\", \"\")\n\tstring.gsub!(\",\", \"\")\n\tstring.gsub!(\"\
    ,\", \"\")\n\tstring.gsub!(\",\", \"\")\n\tstring.gsub!(\",\", \"\")\n\tstring.gsub!(\"\
    ,\", \"\")\n\tstring.gsub!(\",\", \"\")\n\tstring.gsub!(\",\", \"\")\n\tstring.gsub!",
  "  if string.nil? || string.length == 0\n    return false\n  end\n  \n  bracket_count\
    \ = string.count(\"[\")\n  square_bracket_count = string.count(\"[]\")\n  return\
    \ square_bracket_count > bracket_count\nend", "  string=string.split(']')\n  string.each\
    \ do |char|\n    if char.count('[')==1\n      return true\n    end\n  end\n  return\
    \ false\nend\n</code>\n<|/ a tags=string,ruby,bracket |>\n<| a tags=string,ruby,bracket\
    \ dscore=0 |>\nUsing String#index and #rindex method you can find the index of\
    \ first and last brackets in string then use String#slice\n<code>\nstring.index('[')\
    \ - string.rindex(']') + 1 #to find length of [\nstring.index(']') #to find index\
    \ of last ]\nstring.slice('[]'.length) #to find substring between indexes\n</code>\n\
    <|/ a |>\n<| c |>\nThis is not actually an answer, but more a comment for the\
    \ OP's unregistered account.\n<|/ c |>\n<| c |>\nThis would have to be `string.index('['),\
    \ string.rindex(']') + 1)` to get the length of the bracket block, and `string.slice('[]'.length)`\
    \ to get the substring.\n<|/ c |>\n<| c |>\nThe question is about how to detect\
    \ nested brackets, not how to parse a string. This answer doesn't help with that.\n\
    <|/ c |>\n<| c |>\n`'[][][][]'.index('['), string.rindex(']') + 1)` will give\
    \ `1, 2`.\n<|/ c |>\n<| c |>\nI wrote this answer after seeing \"[ruby] bracket\
    \ check\" tag :)\n<|/ c |>\n<| a tags=string,ruby,bracket |>\nYou can do this\
    \ by using Regexp#match and String#sub to extract a specific sub-string between\
    \ brackets.\n<code>", "  if string == '' or string == '[' or string == '{' or\
    \ string == \"(\"\n    return false\n  end\n  \n  opening_brackets_count = 0\n\
    \  opening_curlys_count = 0\n  opening_parenthesis_count = 0\n  \n  closing_brackets_count\
    \ = 0\n  closing_curlys_count = 0\n  closing_parenthesis_count = 0", "  brackets\
    \ = []\n  opening_brackets = 0\n  nesting = false\n  \n  # Iterate through the\
    \ string to find all the brackets\n  string.length.times do |i|\n    if string[i]\
    \ == \"[\" \n      opening_brackets += 1\n      if opening_brackets > 0\n    \
    \    nesting = true\n      else\n        brackets << i\n      end\n    end\n \
    \   \n    if string[i] == \"]\"\n      opening_brackets -= 1\n      if opening_brackets\
    \ == 0\n        brackets.last.succ\n        nesting = false\n      end\n    end\n\
    \  end\n  \n  # If brackets contains anything return false\n  if brackets.length\
    \ > 0\n    false\n  else\n    true\n  end\nend\n</cell>\n<cell>", "  return string.count\
    \ \"[\" != string.count \"]\" \nend\n</cell>\n<text>\nWe can test the function\
    \ by running it against some test cases:", "  string = string.gsub(/[][]/, \"\
    []\")\n  string = string.gsub(/[]/, \"[\")\n  string = string.gsub(/[]]/, \"[]]\"\
    )\n  string = string.gsub(/[][/, \"[[]\")\n  string = string.gsub(/[]]/, \"[]]\"\
    )\n  string.count(\"[]\") >= string.count(\"[\")\nend", "  i = 0\n  open = []\n\
    \  closed = []\n  while i < string.length\n    open = false\n    close = false\n\
    \    if string[i] == \"[\"\n      open << true\n      i += 1\n    elsif string[i]\
    \ == \"[\"\n      close << true\n      i += 1\n    elsif string[i] == \"]\"\n\
    \      if open == true && close == true && string[i-1] == \"]\"\n        return\
    \ true\n      end\n      i += 1\n    end\n    i += 1\n  end\n  return false\n\
    end\n</cell>\n<text>\nExercise 2\nWrite a recursive function called \"nest\" that\
    \ takes as input a string containing square\nbrackets.", "    stack = []\n   \
    \ bracket_count = 0\n    closed_count = 0\n    opened_count = 0\n    has_opened_brackets\
    \ = true\n    \n    # Iterate through string\n    i = 0\n    while i < string.size\n\
    \        # Is open bracket?\n        if string[i] == '['\n            if has_opened_brackets\n\
    \                return false\n            has_opened_brackets = true\n      \
    \      opened_count += 1\n            stack << string[i]\n            i += 1\n\
    \            \n        # If not open bracket, is closed bracket?\n        if string[i]\
    \ != '['\n            i += 1\n            if has_opened_brackets\n           \
    \     closed_count += 1\n                stack.pop\n                has_opened_brackets\
    \ = false\n            \n        # Is open bracket?\n        if string[i] == ']'\n\
    \            has_opened_brackets = false\n            \n        # If open, is\
    \ close bracket?\n        if string[i] == ']'\n            has_opened_brackets\
    \ = false\n            opened_count -= 1\n            if opened_count == 0\n \
    \               closed_count += 1\n                if closed_count == 1\n    \
    \                return true\n                else\n                    return\
    \ false\n        end\n        i += 1\n    end\n    return false\nend", "  \n \
    \ return string.gsub!(/(\\[[^\\]]*\\])/,'') && \n    string.gsub!(/\\[\\[[^\\\
    ]]*\\]\\]/,'')\nend", "  if string.nil? || string.empty?\n    return false\n \
    \ end\n  stack = Stack.new(string)\n  stack_length = len(stack)\n  \n  return\
    \ stack.size != stack_length\nend", "    brackets = string.count(\"[\")\n    brackets\
    \ *= string.count(\"]\")\n    brackets = string.count(\"(\") - string.count(\"\
    )\")\n    return brackets == 0\nend", "  regexp = /\\[([^\\[\\]]+)\\]/\\g\n  match\
    \ = regexp.match(string)\n  return match && match[1].to_i.to_s == match[1].to_s\n\
    end", "  brackets_count = 0\n  open_brackets_count = 0\n  open_brackets = 0\n\
    \  \n  string.replace(\" \", \"\") # Remove whitespace\n  string.gsub!(/\\[/,\
    \ \"\") # Remove opening brackets\n  string.gsub!(/\\]/, \"\") # Remove closing\
    \ brackets\n  string.gsub!(/\\{\\}/, \"\") # Remove opening braces and closing\
    \ braces\n  \n  string.scan(/\\[/) do |bracket|\n    brackets_count += 1\n  end\n\
    \  string.scan(/\\{\\}/) do |bracket|\n    open_brackets_count += 1\n  end\n \
    \ \n  return brackets_count % 2 == 0 && open_brackets_count % 2 == 0\nend", " \
    \ string.gsub!(/[][]/, '[]')\n  string.gsub!(/[]/, '[][]')\n  string.gsub!(/[]/,\
    \ '[][][]')\n  string.gsub!(/[]/, '[][][][]')\n  string.gsub!(/[]/, '[][][][][]')\n\
    \  string.gsub!(/[]/, '[][][][][][]')\n  string.gsub!(/[]/, '[][][][][][][]')\n\
    \  string.gsub!(/[]/, '[][][][][][][][][][]')\n  string.gsub!(/[]/, '[][][][][][][][][][][][]')\n\
    \  string.gsub!(/[]/, '[][][][][][][][][][][][][]')\n  string.gsub!(/[]/, '[][][][][][][][][][][][][][]')\n\
    \  string.gsub!(/[]/, '[][][][][][][][][][][][][][][][][][]')\n  string.gsub!(/[]/,\
    \ '[][][][][][][][][][][][][][][][][][][][][][][][][][][][][]')\n  string.gsub!(/[]/,\
    \ '[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]",
  "  string = string.strip\n  # For each open bracket, check if there are matching\
    \ close brackets. \n  # If so, return true, otherwise, return false.\n  brackets\
    \ = string.count(\"[\")\n  return (brackets - string.count(\"]\") != 0)\nend",
  "  return string.match /\\[(?:[^[]*\\[\\]){0,}\\]\\]/\nend", "  stack = [string]\n\
    \  while stack.length > 0\n    top = stack.pop()\n    if top.length == 0\n   \
    \   return false\n    top = top[1..-1]\n    stack.push top\n  end\n  return true\n\
    end", "  return string.gsub!(/[{\\[\\]]+/, '').chars.any?{ |c| c == '[' }\nend",
  "  string.gsub!(/\\[|\\]/,'')\n  string.gsub!(/\\[[^\\]]*\\]/, '')\n  return string.gsub!(/\\\
    [|\\]/,'')\nend", "  nest = 0\n  brackets = [ '[', ']' ]\n  for i in 0...string.size\n\
    \    if brackets.include? string[i]\n      nest += 1\n    else\n      return nest\
    \ == 1\n    end\n  end\n  return nest == 0\nend", "  return true if string.is_a?\
    \ String and string.chars.all? { |c| c == \"[\" }\n  false\nend\n</cell>\n<cell>",
  "  nestings = 0\n  for i in string\n    if i == \"[\"\n      nestings += 1\n   \
    \ elsif i == \"]\"\n      nestings -= 1\n      break if nestings == 0\n    end\n\
    \  end\n  nestings == 0\nend", "    string.gsub!(/\\[+/,\"[\")\n    string.gsub!(/\\\
    ]+/,\"]\")\n    string.gsub!(/\\{+/,\"{\")\n    string.gsub!(/\\}+/,\"}\")\n \
    \   string.gsub!(/[^[]+/, \"\")\n    string.gsub!(/[^{}]/, \"\")\n    string.gsub!(/[]]/,\
    \ \"\")\n    string.gsub!(/[{}]/, \"\")\n    string.gsub!(/[]}{/, \"}\")\n   \
    \ string.gsub!(/{}]/, \"}\")\n    string.gsub!(/[]]/, \"\")\n    string.gsub!(/[{}]/,\
    \ \"\")\n    string.gsub!(/[]}{/, \"}\")\n    string.gsub!(/{}]/, \"}\")\n   \
    \ string.gsub!(/[]]/, \"\")\n    string.gsub!(/[{}]/, \"\")\n    string.gsub!(/[]}{/,\
    \ \"}\")\n    string.gsub!(/{}]/, \"}\")\n    string.gsub!(/]}/, \"]\")\n    string.gsub!(/]/,\
    \ \"]\")\n    string.gsub!(/[{}]/, \"\")\n    string.gsub!(/[]}{/, \"}\")\n  \
    \  string.gsub!(/{}]/, \"}\")\n    string.gsub!(/[]]/, \"\")\n    string.gsub!(/[{}]/,\
    \ \"\")\n    string.gsub!(/[]}{/, \"}\")\n    string.gsub!(/{}]/, \"}\")\n   \
    \ string.gsub!(/]}/, \"]\")\n    string.gsub!(/]/, \"]\")\n    string.gsub!(/[{}]/,\
    \ \"\")\n    string.gsub!(/[]}{/, \"}\")\n    string.gsub!(/{}]/, \"}\")\n   \
    \ string.gsub!(/[]]/, \"\")\n    string.gsub!(/[{}]/, \"\")\n    string.gsub!(/[]}{/,\
    \ \"}\")\n    string.gsub!(/{}]/, \"}\")\n    string.gsub!(/]}/, \"]\")\n    string.gsub!(/]/,\
    \ \"]\")\n    string.gsub!(/[]}{/, \"}\")\n    string.gsub!(/{}]/, \"}\")\n  \
    \  string.gsub!(/[]]/, \"\")\n    string.gsub!(/[{}]/, \"\")\n    string.gsub!(/[]}{/,\
    \ \"}\")\n    string.gsub!(/{}]/, \"}\")\n    string.gsub!(/]}/, \"]\")\n    string.gsub!(/",
  "  string.split(//) do |char|\n    if char == '['\n      puts \"#{char} is nested.\"\
    \ if !stack[-1].empty?\n      stack << char\n    elsif char == ']'\n      puts\
    \ \"#{char} is nested.\" if stack[-1].empty?\n      stack.pop\n    end\n  end\n\
    end\n</code>\nThis code should do what you want.\n<|/ a tags=arrays,ruby,string\
    \ |>\n<| a |>\nHere's how I'd do it:\n<code>", '  return string.match(/\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:\[(?:',
  "    string.gsub!(/\\[/, '[')\n    string.gsub!(/\\]/, ']')\n    string.gsub!(/\\\
    [([^\\[]*\\[[^\\[]*\\])*\\]/) {|match| is_nested.call(match)} unless string =~\
    \ /\\[/\n    return string !~ /\\[/\nend\n</cell>\n<cell>", "\t\n\tbracket_count\
    \ = 0\n\tstack = []\n\t\n\tstring_length = len(string)\n\t\n\tif string_length\
    \ == 0\n\t\treturn False\n\t\n\tfor i in string.each_char\n\t\n\t\tbracket_count\
    \ += 1\n\t\t\n\t\tif bracket_count > 1\n\t\t\t\n\t\t\tstack_length = stack.length\n\
    \t\t\t\n\t\t\tif stack_length > 0\n\t\t\t\t\n\t\t\t\tnext_char_index = stack[stack_length-1]\
    \ + 1\n\t\t\t\t\n\t\t\t\tif next_char_index < string_length\n\t\t\t\t\tstack.pop\n\
    \t\t\t\tend\n\t\t\tend\n\t\tend\n\t\t\n\t\tif bracket_count == 1\n\t\t\tstack\
    \ << i\n\t\tend\n\tend\n\t\n\treturn (stack.length == 0)\nend", "  result = false\n\
    \  i = 0\n  while (i < string.length)\n    if string[i] == \"[\" || string[i]\
    \ == \"{\" || string[i] == \"(\" || string[i] == \"]\" || string[i] == \"}\" ||\
    \ string[i] == \":\" || string[i] == \",\"\n      result += true if string[i +\
    \ 1] == \"]\" || string[i + 1] == \"]}\" || string[i + 1] == \"}}\" || string[i\
    \ + 1] == \")}\" || string[i + 1] == \",\" || string[i + 1] == \"]}\"\n      i\
    \ += 1\n    else \n      i += 1\n  result\nend\n</cell>\n<code language=julia-1.0>",
  "  nesting.push(nil) # reset the stack\n  stack = 0\n  \n  # Iterate through the\
    \ string from last to first. \n  # Look for matching bracket types: \"]\", \"\
    [\", \"(\", etc.\n  # If we find an opening bracket, record it. \n  # If we find\
    \ a closing bracket, look at the previous pair. \n  # If we find an unmatched\
    \ bracket, record it.\n  i = 0\n  while i < string.size - 1\n    if string[i]\
    \ == \"[\" || string[i] == \"{\" || string[i] == \"(\" || string[i] == \"[\"\n\
    \      nesting.push(string[i])\n      stack = stack + 1\n    elsif string[i] ==\
    \ \"]\" || string[i] == \"}\" || string[i] == \")\" || string[i] == \"]\"\n  \
    \    nesting.pop\n      stack = stack - 1\n    elsif stack == 0\n      return\
    \ false\n    elsif stack > 0\n      return false\n    i = i + 1\n  end\n  return\
    \ true\nend", "  brackets_count = 0\n  bracket_count = 0\n  bracket_closed = False\n\
    \  bracket_open = False\n  \n  string.length.times do |index|\n    char = string[index]\n\
    \    case char\n    when '[', ']'\n      brackets_count += 1\n      if bracket_count\
    \ == 0\n        bracket_open = true\n      else\n        bracket_closed = true\n\
    \        bracket_count = 0\n      end\n    when '('\n      bracket_count += 1\n\
    \    when ')'\n      bracket_count -= 1\n      if bracket_count == 0\n       \
    \ bracket_closed = true\n      else\n        bracket_count = 0\n      end\n  \
    \  end\n    \n    return false if bracket_closed == true && brackets_count < 1\n\
    \  end\n  return true\nend", "  bracket_count = 0\n  opening_level = 0\n  nesting\
    \ = 1\n  \n  for i in 0..string.length\n    # Count opening brackets at this position\n\
    \    if string[i] == \"[\"\n      bracket_count += 1 \n    else # string[i] ==\
    \ \"]\"\n      bracket_count -= 1\n    \n    # If we come across a closing bracket\n\
    \    if bracket_count == 0\n      # If the opening bracket level is 0\n      if\
    \ opening_level == 0\n        return false \n      # If we have started a new\
    \ nesting level\n      elsif opening_level != nesting\n        return false \n\
    \      # If we haven't closed an opening bracket for our level\n      else\n \
    \       opening_level = nesting \n      end\n    end\n  end\n  true\nend", " \
    \ string.gsub!(/\\[.*?\\]/) { |match| !match } #remove all [[ from string\n  string.gsub!(/\\\
    [[^\\]]*\\]/) { |match| match } #remove all [[...] from string\n  string.gsub!(/\\\
    [[^\\]]*\\]/) { |match| match } #remove all [[...] from string\n  string.gsub!(/\\\
    [.*?\\]/) { |match| !match } #remove all [[ from string\n  string.gsub!(/\\[[^\\\
    ]]*\\]/) { |match| match } #remove all [[...] from string\n  string.gsub!(/\\\
    [[^\\]]*\\]/) { |match| match } #remove all [[...] from string", "    stack =\
    \ []\n    brackets = [0]\n    nestings = [0]\n    count = 0\n    open_brackets\
    \ = 0\n    close_brackets = 0\n    while count < string.size do\n        if string[count]\
    \ == '[' then\n            stack.append(string)\n            count += 1\n    \
    \        open_brackets += 1\n            count += 1\n        else if string[count]\
    \ == ']' then\n            brackets.pop()\n            nestings.pop()\n      \
    \      count -= 1\n            count += 1\n            if brackets.size == open_brackets\
    \ then return true end\n        else if string[count] == '[' then\n          \
    \  brackets.insert(0,string)\n            nestings.insert(0,nestings.last() +\
    \ 1)\n            count -= 1\n            count += 1\n        else\n         \
    \   count += 1\n        end\n    end\n    return false\nend", "  stack = []\n\
    \  nests = 0\n  for i in string\n    if i == \"[\"\n      stack << i\n      nests\
    \ += 1\n    elif i == \"]\" and nests > 0\n      stack.pop\n      nests -= 1\n\
    \  end\n  stack.length == nests\nend", "    # Write your code here.\n    nesting\
    \ = 0\n    begin = 0\n    end = -1\n    \n    while end < len(string) - 1 and\
    \ string[end] != ']':\n        end += 1\n    \n    while end > 0 and string[end\
    \ - 1] == '[':\n        end -= 1\n        nesting += 1\n    \n    while nesting\
    \ > 0:\n        while end < len(string) - 1 and string[end] != ']':\n        \
    \    end += 1\n        while end > 0 and string[end - 1] == '[':\n           \
    \ end -= 1\n            nesting -= 1\n    \n    if string[end + 1] == '[' or end\
    \ + 1 == len(string):\n        return True\n    else:\n        return False",
  "  return false if string.length == 0 || string[0] == \"[\" || string[0] == \"{\"\
    \ else true\nend", "  brackets = []\n  i = 0\n  n = string.length", "\tstack =\
    \ Array()\n\tindex = 0\n\twhile index < string.size\n\t\tif string == \"[]]\"\
    \ \n\t\t\tindex += 2\n\t\t\tstack.append(string[index..index+2])\n\t\telsif string\
    \ == \"[]\"\n\t\t\tindex += 2\n\t\t\tstack.append(string[index..index+1])\n\t\t\
    elsif string == \"[[]\"\n\t\t\tindex += 3\n\t\t\tstack.append(string[index..index+3])\n\
    \t\telsif string == \"[[]]\"\n\t\t\tindex += 4\n\t\t\tstack.append(string[index..index+4])\n\
    \t\telsif string == \"[][[]\"\n\t\t\tindex += 5\n\t\t\tstack.append(string[index..index+5])\n\
    \t\telsif string == \"[][[]]\"\n\t\t\tindex += 6\n\t\t\tstack.append(string[index..index+6])\n\
    \t\telsif string == \"[[][[]\"\n\t\t\tindex += 7\n\t\t\tstack.append(string[index..index+7])\n\
    \t\telse\n\t\t\tstack.append(string)\n\t\tend\n\tend\n\treturn stack.size == 0\n\
    end", "  return string.index(\"[\") != -1 && string.index(\"]\") != -1\nend\n\
    </cell>\n<text>\nExercise: Now suppose that the square brackets are nested, but\
    \ that the brackets themselves are not nested.", "    # Remove all brackets from\
    \ string and remove any whitespace at the beginning.\n    string = string.gsub(\"\
    [\", \"\")\n    string = string.gsub(\"]\", \"\")\n    string.strip!\n    \n \
    \   if string.gsub(\"[\", \"\").length == 0\n        return false\n    end\n \
    \   \n    # Remove all brackets from the beginning and end of the string.\n  \
    \  string[0,0] = \"\"\n    string[-1,-1] = \"\"\n    \n    # Return the number\
    \ of brackets within string.\n    count = 0\n    \n    # Iterate through each\
    \ character in the string.\n    string.each_char do |c|\n        if c == \"]\"\
    \n            count = count - 1\n        else \n            count = count + 1\n\
    \        end\n    end\n    \n    # Return true if and only if there is a valid\
    \ subsequence of brackets \n    # where at least one bracket in the subsequence\
    \ is nested.\n    return count > 0\nend\n</code>\nA few tests run using rspec:\n\
    <code>\ndescribe 'is nested' do\n    it 'returns true for a nested subsequence'\
    \ do\n        string.gsub(\"[\", \"\").gsub(\"]\", \"\").strip!.should eql('[]')\n\
    \    end\n    \n    it 'returns false for an unnested subsequence' do\n      \
    \  string.gsub(\"[\", \"\").gsub(\"]\", \"\").strip!.should eql('')\n    end\n\
    \    \n    it 'returns false for a string with invalid brackets' do\n        string.gsub(\"\
    [\", \"\").gsub(\"]\", \"\").strip!.should eql('')\n    end\n    \n    it 'returns\
    \ false for a string with no brackets' do\n        string.gsub(\"[\", \"\").gsub(\"\
    ]\", \"\").strip!.should eql('')\n    end\nend\n</code>\n<|/ a tags=ruby,regex,ruby-on-rails\
    \ |>\n<| c |>\nThanks mate! I wrote a similar function. But it fails when the\
    \ string starts and ends with brackets. Do you know how to fix it?\n<|/ c |>\n\
    <| c |>\nI've edited my code to handle both cases. In your comment, your question\
    \ starts and ends with brackets, but my code will still handle nested brackets\
    \ so long as they have at least 1 nested level. I've included an example of it\
    \ working as well.\n<|/ c |>\n<| c |>\nThank you so much! :) It works as expected.\
    \ Now I understand the function :)\n<|/ c |>\n<| a tags=ruby,regex,ruby-on-rails\
    \ |>\nYou can do that with negative lookahead and lookbehind zero-width ", " \
    \   string.scan(/\\[|\\]/).none?\nend", "    stack = []\n    brackets = 0\n  \
    \  nesting = 0\n    \n    for c in string.split(\"\")\n        if c == \"[\" then\n\
    \            nesting = nesting + 1\n            \n            if nesting > 1 then\n\
    \                stack[stack.length-1] = nesting\n            end", "    stack\
    \ = []\n    opens = nested.count(\"[\")\n    closes = nested.count(\"]\")\n  \
    \  \n    char_count = 0\n    \n    for character in string\n        char_count\
    \ += 1\n        if character == \"[\"\n            stack.push character\n    \
    \        \n        if character == \"]\"\n            nested.push stack.pop\n\
    \            \n        if char_count - opens - closes == 0 && nested.count > 0\n\
    \            return true\n        \n    return false\n    \n    ", "\tstack =\
    \ []\n\tin_str = \"\"\n\tfor c in string:\n\t\tif c == \"[\":\n\t\t\tstack.append(c)\n\
    \t\tif c == \"]\":\n\t\t\tif not stack or stack.pop() != \"[\" :\n\t\t\t\treturn\
    \ False\n\t\t\tin_str = stack.pop() + in_str\n\treturn not stack", '  regexp =
    /\[([^\]]*\[\[([^\]]*\[[^\]]*\[\[([^\]]*\[[^\]]*\[\[([^\]]*\[\[[^\]]*\[\[([^\]]*\[[^\]]*\[\[([^\]]*\[[^\]]*\[[^\]]*\[\[[^\]]*\[\[([^\]]*\[[^\]]*\[\[([^\]]*\[[^\]]*\[[^\]]*\[[^\]]*\[[^\]]*\[\[[^\]]*\[\[[^\]]*\[\[([^\]]*\[[^\]]*\[[][^]]*]][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][[^\]]*][',
  "  nested.count += 1 if string =~ /\\[([^\\[\\]]+)\\]/ end\n  nested.count += 1\n\
    \  nested.count -= 1 if string =~ /\\[([^\\[\\]]+)\\]/\n  nested.count -= 1 \n\
    \  return nested.count > 0\nend", "    nestings = string.count(\"[\")\n    nestings\
    \ = nestings * string.count(\"]\")\n    return nestings > 0\nend\n</cell>\n<cell>",
  "    count = 0\n    i = 0\n    openers = 0\n    while i < string.length\n      \
    \  if string[i] == \"[\"\n            openers += 1\n        elif string[i] ==\
    \ \"]\"\n            openers -= 1\n        if openers < 0\n            return\
    \ false\n        i += 1\n    return true\nend", "  brackets = \"[]\"\n  subsequence\
    \ = []\n  bracket_count = 0\n  nesting_level = 0", "    stack = []\n    brackets\
    \ = 0\n    for c in string:\n        if c == \"[\":\n            stack.append(c)\n\
    \        elif c == \"[\":\n            stack.append(c)\n            brackets +=\
    \ 1\n        elif c == \"]\":\n            brackets -= 1\n            if brackets\
    \ == 0:\n                if stack == [\"[\"]:\n                    return True\n\
    \                stack.pop()\n        else:\n            return False\n    return\
    \ False", "\tnest = 1\n\topen_brackets = 0\n\tclose_brackets = 0\n\ti = string.index(\"\
    [\")\n\twhile i > 0\n\t\topen_brackets += 1\n\t\ti = string.index(\"[\", i+1)\n\
    \tj = string.index(\"]\")\n\twhile j > 0\n\t\tclose_brackets += 1\n\t\tj = string.index(\"\
    ]\", j+1)\n\t\tif close_brackets > nest\n\t\t\tnest = (close_brackets)\n\treturn\
    \ (open_brackets * nest) < close_brackets\nend", "    return string.gsub!(/\\\
    [/, '') && string.gsub!(/\\]/, '') && string.gsub!(/\\]/, '') && string.gsub!(/\\\
    [/, '')\nend", "    \n  # The empty string is an allowed nesting subsequence.\n\
    \  return string.empty? or string.is_a?(String)", "  \n  bracket_stack = []\n\
    \  bracket_counter = 0", "  return string[0] == \"[\" && string[-1] == \"]\"\n\
    end", "    stack = []\n    # Iterate through the string and keep track of which\
    \ brackets have already been seen.\n    # This will allow us to quickly determine\
    \ whether the nested brackets are valid.\n    for c in string\n        if stack.length\
    \ == 0\n            stack.push c\n        else\n            if c == stack.pop\
    \ c\n                stack.push c\n            else\n                false\n \
    \           end\n        end\n    end\n    stack.length == 0\nend\n</code>\n<|/\
    \ a |>\n<| a dscore=0 |>\nThis is my python program for checking if a string has\
    \ balanced brackets:\n<code>", "  stack = Stack.new\n  stack.add(string[0])\n\
    \  current_char_index = 1\n  last_char_index = 1\n  while current_char_index <\
    \ string.length\n    if string[current_char_index] == \"[\"\n      if stack.length\
    \ == 0\n        return false\n      last_char_index = current_char_index\n   \
    \   stack.add(string[current_char_index])\n      current_char_index += 1\n   \
    \ elsif string[current_char_index] == \"]\"\n      if stack.peek() == \"[\"\n\
    \        stack.pop()\n      else if stack.peek() == \"{\"\n        stack.pop()\n\
    \      else\n        return false\n      last_char_index = current_char_index\n\
    \      current_char_index += 1\n    end\n  end\n  return true\nend", "  string.scan(/\\\
    [/)\nend\n</code>\n<code>", "  string.gsub(/\\[([^\\[]*)(\\[\\[([^\\]]*)])]*\\\
    ])/, '\\1').gsub(/\\[([^\\[]*)]/, '').length == string.length\nend", "  string.gsub!(/\\\
    [|\\]\\]|\\[|\\]/, \"\")\n  string.gsub!(/\\[|]|\\]|\\[|]/, \"\")\n  string.gsub!(/\\\
    [|\\]|\\[|\\]|\\]/, \"\")\n  string.gsub!(/\\[|\\]|\\]|\\[|\\]|\\]/, \"\")\n \
    \ string.gsub!(/\\[|\\]|\\]|\\[|\\]|\\]|\\]/, \"\")\n  return string.count(']')\
    \ > 1\nend", "  brackets.each do |b|\n    string = string[0...b.begin] + string[b.end...-1]\n\
    \    string.count(\"[]\") >= 1\n  end\nend", "  nesting = 0\n  stack = []\n  for\
    \ i in string\n    if i.equals? \"]\"\n      nesting -= 1\n      stack.push i\n\
    \    elsif i.equals? \"[\"\n      nesting += 1\n      stack.push i\n    elsif\
    \ nesting > 0\n      return false\n    end\n  end\n  return stack.empty? ? true\
    \ : false\nend", "\tnest = 1\n\twhile nest > 0\n\t\tnest = string.count(\"[]\"\
    )\n\t\tstring = string[string.length - (nest * 2)]\n\t\tif nest > 0 \n\t\t\treturn\
    \ false\n\treturn true\n\t", "    stack = []\n    nest = 0\n    \n    # Iterate\
    \ through the string character-by-character\n    for char in string.split(\"\"\
    )\n    \n        # If a square bracket is encountered, add it to the stack\n \
    \       if char == \"[\"\n            stack << \"[\"]\n            nest += 1\n\
    \            \n        # If a closing bracket is encountered, pop it from the\
    \ stack\n        if char == \"]\"\n            if stack.count == \"[\" and stack.last\
    \ == \"[\"]\n                nest -= 1\n            \n            # If we were\
    \ closing a bracket when we entered it, and we still have \n            # one\
    \ left in the stack, we're in a nested bracket\n            if stack.count ==\
    \ \"]\" and nest == 1\n                return true\n            \n           \
    \ stack.pop\n        end\n    end\n    \n    return false\nend", "    \n    #\
    \ Write your code here.\n    \n    stack = []\n    stack_count = 1\n    index\
    \ = 0\n    while index < len(string):\n        if string[index] == '[' and string[index\
    \ + 1] == ']':\n            stack_count += 1\n            index += 1\n       \
    \ elif string[index] == '[':\n            stack.append(string[index])\n      \
    \      index += 1\n        elif string[index] == ']':\n            stack_count\
    \ -= 1\n            if stack_count == 0:\n                break\n            else:\n\
    \                index += 1\n        elif string[index] == ']' and stack_count\
    \ > 0:\n            stack_count -= 1\n        if stack_count == 0:\n         \
    \   return True\n    return False", "  \n  # Your code here!\n  \nend", "  \n\
    \  stack = [string]\n  \n  loop do\n  \n    top = stack.pop\n    \n    if top\
    \ == \"[]\" || top == \"[][]\"\n      return true\n    \n    if top == \"[][]\"\
    \ || top == \"[]]]]]]\"\n      return false\n    \n    stack << \"[][]\"\n   \
    \ stack << \"[]]]]]]\"\n    stack << \"[]\"\n  end\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nHi Lucas, Thanks for your suggestion. I just tried this one but\
    \ no luck. It still returns false when there are valid nested square brackets.\n\
    <|/ c |>\n<| c |>\nWhat input are you using? I just ran a test with your test\
    \ cases and it returned true.\n<|/ c |>\n<| c |>\nHi, Sorry my bad. There were\
    \ some wrong test cases. I edited my original question with the right test cases.\
    \ Can you please have a look and tell me if the algorithm is correct? I am still\
    \ getting a false return.\n<|/ c |>\n<| c |>\nNo problem. Yes, it appears to return\
    \ true as long as there are 3 or more consecutive nested brackets regardless of\
    \ whether they're in order, since it pops three off of the stack on each pass.\
    \ Let me know if that works for you!\n<|/ c |>\n<| c |>\nThanks Lucas. I tried\
    \ the new test cases with your algorithm and it worked! Thanks a lot. :)\n<|/\
    \ c |>\n<| a dscore=0 |>\nI suggest the following:\n<code>", "  string = string.gsub(\"\
    [][{}<>]\", \"\") #Remove all brackets and braces.\n  string = string.gsub(\"\
    [^][]\", \"\") #Remove all characters other than brackets.\n  return string.size\
    \ % 2 == 1\nend\n</cell>\n<text>\nPractice Practice Practice\nNow you are ready\
    \ to practice using functions to do several different tasks. You are required\
    \ to complete the following functions:", "    brackets = Array.new\n    brackets\
    \ << nil\n    brackets << string if string.include?(\"[\")\n    brackets.each\
    \ do |b|\n        if b.nil? or b.include?(\"[\") or b.include?(\"]\") and b.gsub!(/[\\\
    [\\]]/, \"\")\n            return true\n        end\n    end\n    return false\n\
    end", "  string = string.strip\n  string = string[1..-2]\n  if string.count(\"\
    [\")==string.count(\"]\")\n    string.gsub!(/[\\[\\]]/,\"\")\n    string = \"\
    [\" + string + \"[\" + \"]\"\n  else\n    string = \"[]\" + string\n  end\n  if\
    \ string.count(\"[\")==string.count(\"]\")\n    string.gsub!(/[\\[\\]]/,\"\")\n\
    \    string = \"[\" + string + \"[\" + \"]\"\n  else\n    string = \"[]\" + string\n\
    \  end\n  return string.count(\"[\") <= string.count(\"]\")\nend", "  string =\
    \ string.strip\n  string = string[1..-1]\n  nest = 0\n  i = 0\n  while i < string.size\n\
    \    if string[i] == \"[\"\n      nest += 1\n    elsif string[i] == \"]\"\n  \
    \    if nest == 0\n        return false\n      nest -= 1\n    i += 1\n  end\n\
    \  return true\nend", "  stack = string.dup\n  stack = \"\"", "  brackets_count\
    \ = string.scan(/\\[|\\]/).count\n  nesting_count = string.scan(/\\[|\\]\\[|\\\
    ]\\]/).count\n  nesting_count == brackets_count if nesting_count > brackets_count\
    \ else brackets_count > nesting_count\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\n\
    The code fails when the string has two [[ pairs and has one closing ]]. I think\
    \ it's fine for a string like \"[[]]\", but not for \"[[[][[]]]]\"\n<|/ c |>\n\
    <| a tags=python,regex |>\nThis code should work :\n<code>\nimport re", "    string.scan(/\\\
    [+/) do |brackets|\n        brackets.scan(/\\[+/) do |nested|\n            nested.scan(/\\\
    [+/) do |nest|\n                nest.scan(/\\[+/) do |nest2|\n               \
    \     nest2.scan(/\\[+/) do |nest3|\n                        nest3.scan(/\\[+/)\
    \ do |nest4|\n                            nest4.scan(/\\[+/) do |nest5|\n    \
    \                            nest5.scan(/\\[+/) do |nest6|\n                 \
    \                   nest6.scan(/\\[+/) do |nest7|\n                          \
    \              nest7.scan(/\\[+/) do |nest8|\n                               \
    \             nest8.scan(/\\[+/) do |nest9|\n                                \
    \                nest9.scan(/\\[+/) do |nest10|\n                            \
    \                        nest10.scan(/\\[+/) do |nest11|\n                   \
    \                                     nest11.scan(/\\[+/) do |nest12|\n      \
    \                                                      nest12.scan(/\\[+/) do\
    \ |nest13|\n                                                                nest13.scan(/\\\
    [+/) do |nest14|\n                                                           \
    \         nest14.scan(/\\[+/) do |nest15|\n                                  \
    \                                      nest15.scan(/\\[+/) do |nest16|\n     \
    \                                                                       nest16.scan(/\\\
    [+/) do |nest17|\n                                                           \
    \                     nest17.scan(/\\[+/) do |nest18|\n                      \
    \                                                              nest18.scan(/\\\
    [+/) do |nest19|\n                                                           \
    \                             nest19.scan(/\\[+/) do |nest20|\n              \
    \                                                                            \
    \  nest20.scan(/\\[+/) do |nest21|\n                                         \
    \                                                       nest21.scan(/\\[+/) do\
    \ |nest22|\n                                                                 \
    \                                   nest22.scan(/\\[+/) do |nest23|\n        \
    \                                                                            \
    \                    nest23.scan(/\\[+/) do |nest24|\n                       \
    \                                                                            \
    \         nest24.scan(/\\[+/) do |nest25|\n                                  \
    \                                                                            \
    \  nest25.scan(/\\[+/) do |nest26|\n                                         \
    \                                                                           nest26.scan(/\\\
    [+/) do |nest27|\n                                                           \
    \                                                             nest27.scan(/\\\
    [+/) do |nest28|\n                                                           \
    \                                                                 nest28.scan(/\\\
    [+/) do |nest29|\n                                                           \
    \                                                                     nest29.scan(/\\\
    [+/) do |nest30|\n                                                           \
    \                                                                         nest30.scan(/\\\
    [+/) do |nest31|\n                                                           \
    \                                                                            \
    \ nest31.scan(/\\[+/) do |nest32|\n                                          \
    \                                                                            \
    \                      nest32.scan(/\\[+/) do |nest33|\n                     \
    \                                                                            \
    \                                               nest", "  return true if string\
    \ =~ /\\[.*\\]/\n  false\nend", "  string.gsub!(/\\[/, '\\[')\n  string.gsub!(/\\\
    ]/, '\\]')\n  string.gsub!(/\\]/, '\\]')\n  string.gsub!(/\\]/, '\\]')\n  string.gsub!(/\\\
    ]/, '\\]')\n  string.gsub!(/\\]/, '\\]')\n  string.gsub!(/\\]/, '\\]')\n  string.gsub!(/\\\
    ]/, '\\]')\n  string.gsub!(/\\]/, '\\]')\n  string.gsub!(/\\]/, '\\]')\n  string.gsub!(/\\\
    ]/, '\\]')\n  string.gsub!(/\\]/, '\\]')\n  string.gsub!(/\\]/, '\\]')\n  string.gsub!(/\\\
    ]/, '\\]')\n  string.gsub!(/\\]/, '\\]')\n  string.gsub!(/\\]/, '\\]')\n  string.gsub!(/\\\
    ]/, '\\]')\n  string.gsub!(/\\]/, '\\]')\n  string.gsub!(/\\]/, '\\]')\n  string.gsub!(/\\\
    ]/, '\\]')\n  string.gsub!(/\\]/, '\\]')\n  string.gsub!(/\\]/, '\\]')\n  string.gsub!(/\\\
    ]/, '\\]')\n  string.gsub!(/\\]/, '\\]')\n  string.gsub!(/\\]/, '\\]')\n  string.gsub!(/\\\
    ]/, '\\]')\n  string.gsub!(/\\]/, '\\]')\n  string.gsub!(/\\]/, '\\]')\n  string.gsub!(/\\\
    ]/, '\\]')\n  string.gsub!(/\\]/, '\\]')\n  string.gsub!(/\\]/, '\\]')\n  string.gsub!(/\\\
    ]/, '\\]')\n  string.gsub!(/\\]/, '\\]')\n  string.gsub!(/\\]/, '\\]')\n  string.gsub!(/\\\
    ]/, '\\]')\n  string.gsub!(/\\]/, '\\]')\n  string.gsub!(/\\]/, '\\]')\n  string.gsub!(/\\\
    ]/, '\\]')\n  string.gsub!(/\\]/, '\\]')\n  string.gsub!(/\\]/, '\\]')\n  string.gsub!(/\\\
    ]/, '\\]')\n  string.gsub!(/\\]/, '\\]')\n  string.gsub!(/\\]/, '\\]')\n  string.gsub!(/\\\
    ]/, '\\]')\n  string.gsub!(/\\]/, '\\]')\n  string.gsub!(/\\]/, '\\]')\n  string.gsub!(",
  "  brackets = \"[]\"\n  nesting = 0\n  nested_brackets = \"{\"\n  nested_brackets_count\
    \ = 0\n  bracket_count = 0\n  \n  for i in string.chars\n    if brackets.include?(i)\n\
    \      nesting += 1\n      if nesting == 1\n        nested_brackets_count += 1\n\
    \      else\n        nested_brackets_count -= 1\n      end\n    end\n    \n  \
    \  if nested_brackets.include?(i)\n      nested_brackets_count += 1\n      if\
    \ nested_brackets_count == nesting\n        bracket_count += 1\n      else\n \
    \       bracket_count -= 1\n      end\n    end", "  string.scan(/\\[([^\\[\\]]*)]\\\
    [\\[([^\\[\\]]*)]\\]/) \n  return true if string.scan(/\\[([^\\[\\]]*)]\\[\\[([^\\\
    [\\]]*)]\\]/).length == 2 end\n  return false\nend", "  if string.count(\"[\"\
    ) != string.count(\"]\") || string.count(\"]\") != string.count(\"[\")\n    false\n\
    \  else\n    string.scan(/\\[/).size == string.scan(/\\]/).size && string.scan(/\\\
    ]/).size != 0\n  end\nend\n</code>\nThen all you have to do is count the number\
    \ of '[' in the string and compare it to the number of ']' in the string and compare\
    \ the two counts to see if they are equal:\n<code>", "    stack = Stack.new([])\
    \ # Stack of brackets\n    string = string.dup\n    \n    while string.length\
    \ > 0 # While there is still characters in the string...\n        if string.include?('[')\
    \ # If there is an opening bracket in the string...\n            stack << string.slice!('[')\
    \ # Add a bracket to the stack\n        elsif string.include?(']') # If there\
    \ is a closing bracket in the string...\n            stack.pop() # Remove the\
    \ last bracket from the stack\n        end\n    end\n    \n    return stack.nil?\
    \ # If we never find the closing bracket of the nested brackets,\n           \
    \         # then the string is nested within itself\nend", "  return string =~\
    \ /\\[*(\\[+\\]|[^][]+)*\\]/m\nend", "  \n    # Your code goes here\n  \n  # Your\
    \ code goes here\nend", "    brackets = ['[', ']']\n    bracket_count = 0\n  \
    \  bracket_count = 0\n    brackets_checked = 0\n    brackets_checked = 0\n   \
    \ nest_check = 0\n    nest_check = 0\n    nest_check = 0\n    nest_check = 0\n\
    \    \n    brackets_checked = 0\n    brackets_checked = 0\n    brackets_checked\
    \ = 0", "    string.gsub!(/\\[|\\]\\[|\\]\\]|\\]|\\[|\\]\\]\\]/, '') \n    string.downcase!\n\
    \    string.gsub(/\\[([\\[\\[|\\]\\]]+)\\]/) do \n\tsubsequence = $1;\n      \
    \  string.gsub!(/\\[|\\]\\[|\\]\\]|\\]|\\[|\\]\\]\\]/, '') \n\tsubsequence ==\
    \ \"[][]\" or \n\tsubsequence.upcase == '[' or subsequence.upcase == '{' or subsequence.upcase\
    \ == '}' or \n\tsubsequence.upcase == '(' or subsequence.upcase == ')' or subsequence.upcase\
    \ == '.' or \n\tsubsequence.upcase == '/' or subsequence.upcase == '#' or subsequence.upcase\
    \ == '[' or \n\tsubsequence.upcase == '%' or subsequence.upcase == '\\\\' or \n\
    \tsubsequence.upcase == '&' or subsequence.upcase == ']' or subsequence.upcase\
    \ == '|' or \n\tsubsequence.upcase == '=' or subsequence.upcase == '}' or subsequence.upcase\
    \ == ']' or \n\tsubsequence.upcase == '[' or subsequence.upcase == '{' or subsequence.upcase\
    \ == '(' or \n\tsubsequence.upcase == '%' or subsequence.upcase == '\\\\' or \n\
    \tsubsequence.upcase == '&' or subsequence.upcase == ']' or subsequence.upcase\
    \ == '|' or \n\tsubsequence.upcase == '=' or subsequence.upcase == '}' or subsequence.upcase\
    \ == ']' or \n\tsubsequence.upcase == '[' or subsequence.upcase == '{' or subsequence.upcase\
    \ == '(' or \n\tsubsequence.upcase == '%' or subsequence.upcase == '\\\\' or \n\
    \tsubsequence.upcase == '&' or subsequence.upcase == ']' or subsequence.upcase\
    \ == '|' or \n\tsubsequence.upcase == '=' or subsequence.upcase == '}' or subsequence.upcase\
    \ == ']' or \n\tsubsequence.upcase == '[' or subsequence.upcase == '{' or subsequence.upcase\
    \ == '(' or \n\tsubsequence.upcase == '%' or subsequence.upcase == '\\\\' or \n\
    \tsubsequence.upcase == '&' or subsequence.upcase == ']' or subsequence.upcase\
    \ == '|' or \n\tsubsequence.upcase == '=' or subsequence.upcase == '}' or subsequence.upcase\
    \ == ']' or \n\tsubsequence.upcase == '[' or subsequence.upcase == '{' or subsequence.upcase\
    \ == '(' or \n\tsubsequence.upcase == '%' or subsequence.", "  nested.delete(string)\n\
    \  nested.insert(nested.length-1,string)\n  \n  bracket_level = 0\n  bracket_start\
    \ = 0\n  bracket_end = 0\n  \n  for i in 0..nested.length-1\n    bracket_level\
    \ = nested[i].count(\"[\")\n    bracket_start = nested[i].rindex(\"[\")\n    bracket_end\
    \ = nested[i].rindex(\"]\")\n    if bracket_level > 0\n      return true\n  end\n\
    \  return false\nend", "  string.gsub!(/\\[[^\\[\\]]*\\]/, '')\n  string = '['+string+']'\
    \ if string.match('\\[[]') && string.match('\\][]]') && string.match('[[]')\n\
    \  string.gsub!(/\\[[^\\[\\]]*\\]/, '')\n  string = '['+string+']' if string.match('\\\
    [[]') && string.match('\\][]]') && string.match('[[]')\n  string\nend", "  return\
    \ false if !string || !string.count(\"[\")\n  string = \"[\" + string + \"]\"\n\
    \  nested = false\n  \n  loop do\n    index = string.index(\"[\")\n    nesting\
    \ = string[index+1...].count(\"]\")\n    \n    if nested\n      return true\n\
    \    end\n    \n    string = string[0..index] + string[index+nesting+1...]+\"\
    ]\"\n    nested = nested || nesting\n  end\nend\n</code>\n<|/ a tags=string,ruby\
    \ |>\n<| c |>\nthis does not work, your solution does not work for `\"[[][[][[]]]]\"\
    ` or `\"[[][[]][[][]]]\"`\n<|/ c |>\n<| c |>\nI didn't notice the nested `[]`\
    \ cases until you pointed it out (I only tested for the two \"unnested\" cases\
    \ as you mentioned). I've updated my solution to handle them.\n<|/ c |>\n<| c\
    \ |>\nThis isn't a bad solution, however it's worth pointing out that you can\
    \ do `string.scan(/\\[+/).any?{|l| l.include?('[]')}` (or `scan(/\\[+/).none?{|l|\
    \ l.include?('[]')}`).\n<|/ c |>\n<| a dscore=2 tags=string,ruby |>\nI believe\
    \ that a regex is overkill here, especially when it is relatively simple to check:\n\
    <code>", "  return string =~ /\\[(?:[^]]*\\]|(?R))*\\]/ \nend", "  brackets =\
    \ string.scan(/\\[*\\]/)\n  \n  return brackets && !brackets.empty?\nend", '  nesting_depth
    = string.length', "  string.scan(/\\[|\\]/)\n  string.count(/\\[|\\]/) >= string.count(/\\\
    ]|\\[/)\nend", "  string.count(\"[]\") > 1\nend\n</code>\nThis code will run a\
    \ loop on the string and check if there are any nested brackets present and return\
    \ the boolean result.\n<|/ a |>\n<| c |>\n`def is_nested?(string)\n  string.count(\"\
    []\") > 1\nend` will do the trick, no need to define a new function and call `string.count`\
    \ each time.\n<|/ c |>\n<| c |>\nThanks for that but I was trying to keep this\
    \ as simple as possible. I have edited the code though, to make it more readable.\n\
    <|/ c |>\n<| a |>\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
