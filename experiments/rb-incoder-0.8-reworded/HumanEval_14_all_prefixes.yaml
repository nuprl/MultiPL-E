name: HumanEval_14_all_prefixes
language: rb
prompt: "# Return array of all prefixes from shortest to longest of the input string\n\
  # >>> all_prefixes.call(\"abc\")\n# [\"a\", \"ab\", \"abc\"]\ndef all_prefixes(string)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_all_prefixes\n\
  \    candidate = method(:all_prefixes)\n    assert_equal([], candidate.call(\"\"\
  ))\n    assert_equal([\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"],\
  \ candidate.call(\"asdfgh\"))\n    assert_equal([\"W\", \"WW\", \"WWW\"], candidate.call(\"\
  WWW\"))\n  end\nend\n"
completions: ["  prefix = Array.new(string.length)\n  i = -1\n  while i != string.length\n\
    \    prefix[i] = string[0...i].upcase\n    i += 1\n  end\n  prefix\nend", "  #\
    \ Create array with all prefixes\n  all_prefixes = []\n  # For each letter in\
    \ the string\n  string.each_char do |c|\n    # Push the prefix onto the array\
    \ if it's not already there\n    all_prefixes << c unless all_prefixes.include?(c)\n\
    \  end\n  # Return array\n  all_prefixes\nend\n</code>\nAs you see, it's pretty\
    \ simple: you just need to iterate through the letters and check if they have\
    \ been added already.\n<|/ a tags=ruby,algorithm |>\n<| a |>\n<code>", "  array.each_with_index\
    \ { |substr, idx| substr.sub!(''*(string.length-idx), '') }\n  array.inject('')\
    \ do |result, str|\n    result += str\n  end\nend", "  prefix = \"\"\n  array\
    \ = string.split(//)\n  array.each do |i|\n    if i.length != prefix.length\n\
    \      prefix = i.dup\n    else\n      break\n    end\n  end\n  prefix\nend",
  "  if string.length == 0\n    []\n  else\n    string.split(//).map.with_index.with_object([]).each\
    \ {|i, prefixes| prefixes << i }\n  end\nend\n</code>\n<|/ a |>\n<| a tags=algorithm,ruby\
    \ |>\nHere is a solution that doesn't require using any methods.\n<code>", " \
    \ return string.split('').map { |c| c == 'a' ? nil : \"#{c}#{c}#{c}\" }\nend",
  "  array.each string.reverse.chars.take(string.size).map { |c| c.to_s.downcase }\n\
    end", "  result = []\n  prefix = string[0]\n  result.append(prefix)\n  rest =\
    \ string[1..-1]\n  if rest.empty?\n    return result\n  rest[0]\n  rest.each_byte\
    \ do |c|\n    prefix_with_char = prefix + [c].pack(\"C\")\n    result.concat(all_prefixes(prefix_with_char))\n\
    \  end\n  result\nend", '    prefixes = []', "  min_len = string.size + 1\n  max_len\
    \ = min_len - 1\n  prefixes = Array.new\n  while max_len > min_len\n    prefixes.append(string[0,\
    \ max_len])\n    min_len -= 1\n    max_len -= 1\n  end\n  prefixes\nend", "  #\
    \ Initialize array of prefixes to return\n  prefixes = []\n  # Iterate through\
    \ each character in string\n  string.each_char do |character|\n    # Initialize\
    \ array of possible prefixes for each position in string\n    # Note: array is\
    \ zero based, so array[0] = \"a\" and not \"a\"\n    possible_prefixes = (0...string.length).map\
    \ { |i| \"#{character}#{string.slice(i)}\" }\n    # Find shortest prefix that\
    \ is a prefix of string\n    # Note: returns nil if no matching prefix exists\n\
    \    prefixes << possible_prefixes.find { |prefix| string.start_with?(prefix)\
    \ }\n  end\n  # Return array of possible prefixes\n  prefixes\nend\n</code>\n\
    We can now write our solution:\n<code>", "  prefixes = Array.new\n  while string.length\
    \ > 0\n    char = string.pop\n    prefixes << char\n    string = string.join(\"\
    \")\n  end\n  prefixes\nend", "    chars = string.chars\n    prefixes = chars.drop(1).map(&:first).map\
    \ { |c| [c, c.reverse] }\n    prefixes.each do |prefix|\n        chars.drop(prefix[0].length).each\
    \ do |c|\n            chars.insert(prefix[0].length, c) if prefix[0] == c\n  \
    \      end\n    end\n    chars\nend", "  prefixes = []\n  string.each_char.with_index\
    \ do |char, i|\n    prefixes[i] = char\n    i += 1\n  end\n  prefixes\nend", " \
    \ prefixes = []\n  i = string.index(@prefix)\n  while i > 0\n    prefixes.push\
    \ string[0..i-1]\n    i = string.index(@prefix, i+1)\n  end\n  prefixes\nend",
  "  string.split(//).map{|s| s.split(//)}\nend", "  prefix = Array.new\n  string.to_s.length.times\
    \ do |i|\n    prefix << string[0, i]\n  end\n  prefix\nend", "    \n    prefixes\
    \ = []\n    string.each_char do |char|\n        prefixes << char if prefixes.empty?\
    \ || prefixes[-1] != char\n    end\n    \n    prefixes\nend", "  if string.empty?\n\
    \    return []\n  else\n    return all_prefixes(string[1..-1]) + [string[0..string.length\
    \ - 1]]\n  end\nend", "  prefix_array = []\n  prefix_array.push(\"a\")\n  prefix_array.push(string[1..-1].split(//).reverse.inject(:+))\n\
    \  prefix_array\nend", "  string.split(//).inject([]) { |prefixes, char| prefixes\
    \ << char if char == \"\" }.map { |prefix| prefix + \"*\" }\nend", "  return split_by_prefix(string).map(&:first)\n\
    end", "  prefixes = []\n  i = 0\n  while i < string.length\n    prefix = string[i,\
    \ 1]\n    next if prefix.nil?\n    prefixes << prefix\n    i += 1\n  end\n  prefixes\n\
    end", "  prefixes = []\n  string.split(\"\").each do |c|\n    prefixes << (c if\
    \ c != string[0])\n  end\n  prefixes\nend", "  prefix = Array.new\n  string.split(\"\
    \").each do |character|\n    prefix.push(character) if !prefix[-1] or prefix[-1]\
    \ != character\n  end\n  prefix.uniq!\n  prefix\nend", "  string.length.times\
    \ { |i| yield(string[0..i]) }\nend", "  if string.nil?\n    []\n  else\n    prefixes\
    \ = all_prefixes(string[0..-1])\n    prefixes.push(string[0..-1])\n    prefixes\n\
    \  end\nend", "  prefix = []\n  string.each_char do |c|\n    prefix << c unless\
    \ prefix.include?(c)\n  end\n  prefix\nend", "  result = []\n  result.unshift(\"\
    \") if string.empty?\n  string.scan(/^\\/(.+)/) { |prefix| result << prefix }\n\
    \  result\nend", "  string.chars.take(string.chars.length).map{|c| c.reverse}.flatten.uniq\n\
    end", "  if string.length <= 1\n    string\n  else\n    all_prefixes(string[0...string.length\
    \ - 1]).each { |prefix| string << prefix }\n    string\n  end\nend", "  return\
    \ string.split(\"\").map(&:first)\nend\n</code>\nThen we call our function with\
    \ the input string:\n<code>\nall_prefixes(\"abc\")", "  prefix = \"\"\n  prefix\
    \ = prefix << string.length\n  (1..string.length).each do |i|\n    prefix = prefix\
    \ << string[0..i]\n  end\n  prefix\nend", "  # Initialize result array\n  prefixes\
    \ = []", "  result = []\n  string.split('').each do |letter|\n    result << (letter\
    \ == string.chars.last ? '' : letter)\n  end\n  return result\nend", "  lengths\
    \ = Array.new(string.length) { |i| [-1 * i, 0] }\n  length = lengths.inject(0)\
    \ { |sum, el| sum + el[0] }\n  prefixes = Array.new(length) { |i| string.charAt(i)\
    \ }\n  prefixes.each do |prefix|\n    lengths[prefixs.size - 1].push(lengths[prefixs.size\
    \ - 1][1] + prefix.length)\n  end\n  return prefixes\nend", "  prefix = []\n \
    \ string_length = string.length\n  i = string_length\n  while (i>0) do\n    prefix.push(string[0..i-1])\n\
    \    i = i-1\n  end\n  return prefix\nend", "  return string.split(\"\").map.with_index\
    \ { |s, i| if i == 0 then s else s + \"##{#{i}}\" }.flat_map(&:to_s).uniq\nend\n\
    </code>\n<code>", "  string = string.split(//).map(&:capitalize).join(\" \")\n\
    \  prefixes = []\n  current = \"\"\n  while string.length > 0\n    current = string.slice!(0,\
    \ -1)\n    if current.include?(\" \")\n      current = current.slice(0...current.index(0))\n\
    \    end\n    prefixes << current\n    string = string.slice!(0, -current.length)\n\
    \  end\n  prefixes\nend", "  return string.split(//).map.with_index.with_index.map(&:first)\n\
    end\n</code>\n<|/ a tags=ruby,string |>\n<| a tags=ruby,string dscore=1 |>\nI\
    \ really like these solutions. I think one could argue that they do much more\
    \ work than is strictly necessary, and they are certainly more complex than some\
    \ of the other answers. However, in my opinion, it's worth noting that they are\
    \ both very easy to read, and don't involve any complex Ruby idiom that would\
    \ increase the complexity of the code. They also both are easy to extend if needed\
    \ - for example, if you wanted to also find the longest prefix of a string.\n\
    Here's how I would do it:\n<code>", "  prefixes = []\n  index = 0\n  while index\
    \ < string.length\n    index = string.index(index, index + 3)\n    if index ==\
    \ 0\n      prefixes << string[index + 3]\n    else\n      prefixes << string[index\
    \ + 3] + string[index - 3]\n    end\n  end\n  prefixes\nend", "  prefixes = []\n\
    \  len = string.size\n  (0...len).to_a.each { |i|\n    (len...i).to_a.each { |j|\n\
    \      prefixes << string[j..i]\n    }\n  }\n  prefixes\nend", "  return string.split(\"\
    \").map{|c| c}.reject(&:empty?).map {|prefix| prefix + \"a\"}\nend", "  prefix\
    \ = \"\"\n  prefixes = []\n  \n  while string.length >= prefix.length\n    prefix\
    \ = prefix + string[/([a-z])/]\n    prefixes << prefix\n    string = string[/([a-z])/]\n\
    \  end", "  prefixes = []\n  string.each_char{|i| prefixes << i}\n  prefixes.uniq\n\
    end", "  prefixes = string.chars.map{ |s| s.prefix }.uniq\n  prefixes.unshift(\"\
    \")\n  prefixes.map!{ |s| s.reverse }.uniq!\n  prefixes\nend", "  string = string.to_s\n\
    \  prefixes = []\n  while string.length\n    prefixes << string.slice(0, string.length\
    \ - 1)\n    string = string.slice(-1)\n  end\n  prefixes\nend", "  prefix_array\
    \ = Array.new\n  prefix_array.push(*string.split(//).reverse.each.take(2).reverse.each.take(2).to_a)\n\
    \  prefix_array.push(*string.split(//).reverse.each.take(4).reverse.each.take(4).to_a)\n\
    \  prefix_array.push(*string.split(//).reverse.each.take(8).reverse.each.take(8).to_a)\n\
    \  prefix_array.push(*string.split(//).reverse.each.take(16).reverse.each.take(16).to_a)\n\
    \  prefix_array\nend", "  return [*string.downcase.split(//).reverse].map(&:chomp)\n\
    end", "  result = []\n  i = string.count('a') + 1\n  while i < string.size\n \
    \   result.push string[0..i-1]\n    i += 1\n  end\n  result\nend", "  prefixes\
    \ = []\n  loop do\n    loop do\n      break if prefixes.size >= string.length\n\
    \      prefix = string[0..-2]\n      break unless prefixes.include? prefix\n \
    \     string = string[2..-1]\n    end\n    prefixes << prefix\n  end\n  prefixes\n\
    end", "  string = string.dup\n  prefix = []\n  while string.size > 0 do\n    prefix\
    \ << string.pop\n    break if string.size == 0\n    prefix << string.pop[0...-1]\n\
    \  end\n  prefix\nend", '  prefix = nil', "  all_chars = []\n  all_chars.push(string[0])\n\
    \  all_prefixes.each do |prefix|\n    all_chars.push(prefix[0,prefix.length-1])\n\
    \  end\n  return all_chars\nend", "  # Split string into array of individual characters,\
    \ preserving order\n  array = string.split('')\n  # Convert array to string and\
    \ trim whitespace from each string\n  array = array.map(&:strip)\n  # Return array\
    \ of all prefixes from shortest to longest of the input string\n  result = []\n\
    \  array.reverse_each.with_index do |prefix, i|\n    result += if i >= 2 \n  \
    \    [\"#{prefix}#{'.' * (i - 2)}\", prefix]\n    else\n      [prefix, prefix.first]\n\
    \    end\n  end\n  result.reverse\nend", "  result = []\n  i = 0\n  while i <\
    \ string.length\n    result[i..string.length] = string[i..string.length]\n   \
    \ i += 1\n  end\n  result\nend", "  # Add empty array if string is empty\n  if\
    \ string.nil? || string.empty?\n    []\n  else\n    # Initialize array with all\
    \ prefixes \n    all_prefixes = []\n    # Iterate through all characters of the\
    \ string\n    string.each_char do |char|\n      # If current character is not\
    \ a prefix of any element of the array\n      # or it's already in array, just\
    \ add it to the array\n      all_prefixes << char if !all_prefixes.include?(char)\n\
    \    end \n    # Return all prefixes\n    return all_prefixes\n  end\nend\n</code>\n\
    <code>", "  string.length.times.collect {|i| string[0..i]}\nend", "  prefix_array\
    \ = []\n  prefix_array_length = len(prefix_array)\n  for i = 0 to string.length\n\
    \    if string[i] == string[0]\n      add prefix_array[0] to prefix_array\n  \
    \  else\n      add string[i] to prefix_array\n  end\n  return prefix_array\nend\n\
    ```", "  prefix = []\n  string.split(\"\").each do |char|\n    prefix.concat(cyclic_prefixes(char))\n\
    \  end\n  prefix\nend", "  prefixes = []\n  \n  prefixes << string[0, string.size\
    \ / 2]\n  \n  begin_index = 2\n  while begin_index <= string.size\n    begin_index\
    \ = begin_index + string.size / 2\n    prefixes << string[begin_index, string.size]\n\
    \  end\n  \n  prefixes << string[begin_index, string.size]\n  \n  prefixes\nend",
  "  return find_all_indexes(string, /^./)\nend", "  prefixes = []\n  while string.length\
    \ > 0\n    prefix, string = string[0, 1], string[1..-1]\n    prefixes << prefix\n\
    \  end\n  return prefixes\nend", "  prefix = nil\n  prefixes = []\n  string.scan(/\\\
    A(\\A|\\z)/).each do |match|\n    prefixes << match[1] unless prefix\n    prefix\
    \ = match[1]\n  end\n  prefixes\nend", "  all_prefixes = []\n  length = string.size\n\
    \  (length - 1).downto(0) do |i|\n    prefix = string[0, i]\n    all_prefixes\
    \ << prefix\n  end\n  all_prefixes\nend", "  if string == \"\"\n    # Return an\
    \ empty array if string has no characters\n    # >>> all_prefixes.call(\"\")\n\
    \    # []\n    []\n  else\n    chars = []\n    # Loop through all the characters\
    \ in the string\n    string.chars.each do |char|\n      # Add character to a temporary\
    \ array\n      chars << char\n      # Remove first character from the string\n\
    \      string = string.chars.drop(1).join\n    end\n    # Return temporary array\n\
    \    chars\n  end\nend", "  prefix_lengths = all_prefix_lengths(string)\n  result\
    \ = prefix_lengths.map { |length| string[0, length] }\n  result.reject { |s| s.empty?\
    \ }.uniq\nend", "  prefixes = Array.new(string.length)\n  prefixes.each_index\
    \ do |i|\n    prefixes[i] = string[0..i]\n  end\n  prefixes\nend", "  if string.size\
    \ == 0\n    return []\n  \n  all_prefixes = all_prefixes.call([string[0]])\n \
    \ \n  string = string.slice(1)\n  \n  while string.size > 0\n    prefix = all_prefixes.call([string[0]])\n\
    \    \n    prefix = prefix + \"-\" + string[0]\n    \n    all_prefixes = all_prefixes.call(prefix)\n\
    \    \n    string = string.slice(1)\n  end\n  \n  all_prefixes\nend", "    prefix\
    \ = \"\"\n    prefix_list = []\n    if string.length <= 0\n        prefix_list\
    \ = string\n    else\n        prefix_list.insert(0,prefix)\n        prefix_list.insert(0,string[0])\n\
    \        prefix_list.insert(0,string.slice!(0))\n        prefix_list.insert(0,string.slice!(0,1))\n\
    \        prefix_list.insert(0,string.slice!(0,2))\n        prefix_list.insert(0,string.slice!(0,3))\n\
    \        prefix_list.insert(0,string.slice!(0,4))\n        prefix_list.insert(0,string.slice!(0,5))\n\
    \        prefix_list.insert(0,string.slice!(0,6))\n        prefix_list.insert(0,string.slice!(0,7))\n\
    \        prefix_list.insert(0,string.slice!(0,8))\n        prefix_list.insert(0,string.slice!(0,9))\n\
    \        prefix_list.insert(0,string.slice!(0,10))\n        prefix_list.insert(0,string.slice!(0,11))\n\
    \        prefix_list.insert(0,string.slice!(0,12))\n        prefix_list.insert(0,string.slice!(0,13))\n\
    \        prefix_list.insert(0,string.slice!(0,14))\n        prefix_list.insert(0,string.slice!(0,15))\n\
    \        prefix_list.insert(0,string.slice!(0,16))\n        prefix_list.insert(0,string.slice!(0,17))\n\
    \        prefix_list.insert(0,string.slice!(0,18))\n        prefix_list.insert(0,string.slice!(0,19))\n\
    \        prefix_list.insert(0,string.slice!(0,20))\n        prefix_list.insert(0,string.slice!(0,21))\n\
    \        prefix_list.insert(0,string.slice!(0,22))\n        prefix_list.insert(0,string.slice!(0,23))\n\
    \        prefix_list.insert(0,string.slice!(0,24))\n        prefix_list.insert(0,string.slice!(0,25))\n\
    \        prefix_list.insert(0,string.slice!(0,26))\n        prefix_list.insert(0,string.slice!(0,27))\n\
    \        prefix_list.insert(0,string.slice!(0,28))\n        prefix_list.insert(0,string.slice!(0,29))\n\
    \        prefix_list.insert(0,string.slice!(0,30))\n        prefix_list.insert(0,string.slice!(0,31))\n\
    \        prefix_list.insert(0,string.slice!(0,32))\n        prefix_list.insert(0,string.slice!(0,33))\n\
    \        prefix_list.insert(0,string.slice!(0,34))\n        prefix_list.insert(0,string.slice!(0,35))\n\
    \        prefix_list.insert(0,string.slice!(0,36))\n        prefix_list.insert(0,string.slice!(0,37))\n\
    \        prefix_list.insert(0,string.slice!(0,38))\n        prefix_list.insert(0,string.slice!(0,39))\n\
    \        prefix_list.insert(0,string.slice!(0,", "  (0...string.length).map {|i|\
    \ string[0..i]}\nend", "  return prefix_array(string, \"\", \"\")\nend", "  prefix_length\
    \ = nil\n  prefixes = []", "  prefixes = string.split(//)\n  prefixes.map!(&:downcase)\n\
    \  prefixes = prefixes.uniq\n  prefixes.uniq!(&:downcase)\n  prefixes\nend", " \
    \ string.split(//).map { |str| str.size }.reduce(:+)\nend", "  result = []\n \
    \ loop do\n    result << string[0...i-1]\n    break if string.length <= i\n  end\n\
    \  result\nend", "  string.split(//).slice_before(1).map(&:join)\nend", "    arr\
    \ = string.split(\"\")\n    arr.each_with_index.with_index do |e, i|\n       \
    \ if i == 0\n            arr.remove(e)\n        end\n    end\n    arr.join(\"\"\
    )\nend", "  array = []\n  string.split(\"\").each_with_index do |char, i|\n  \
    \  char.upcase! unless i == 0\n    array << char\n  end\n  array\nend", "  prefix\
    \ = []\n  while string.length > 0\n    prefix.push string[0...0]\n    string =\
    \ string[1..-1]\n  end\n  prefix\nend", "  prefixes = Array.new\n  prefix = string.to_s[0]\n\
    \  prefixes << prefix\n  suffixes = string.to_s[1..-1]\n  suffixes.each do |suffix|\n\
    \    prefix = prefix.to_s + \"#{suffix}\"\n    prefixes << prefix\n  end\n  prefixes\n\
    end", "  i = 0\n  while i <= string.length\n    yield string[0..i]\n    i += 1\n\
    \  end\nend", "  return (0..string.length).to_a.map { |i| string[0, i + 1] }\n\
    end", "  all = []\n  string.split(\"\").each do |letter|\n    all << letter if\
    \ !all.include?(letter) || letter == all[-1]\n  end\n  all\nend", "  return string.split(//)\n\
    end", "  return Array.new(string.size) { |i| string[0,i] }\nend\n</code>\nTo test\
    \ your code, you can run it line by line in the console to make sure it is doing\
    \ what you want.\n<|/ a dscore=1 |>\n<| a tags=ruby dscore=0 |>\nMy answer is\
    \ just an idea. Maybe it's not the best one:\n<code>\narr = [ 'a', 'ab', 'abc'\
    \ ]", "  all = []\n  string.split('').each { |x| all << x }\n  all.sort!\n  all.reverse!\n\
    \  all\nend", "  string.split(\"\").map{ |s| s.split(\"\") }.flatten.uniq\nend",
  "  return reduce(:concat, [string[0..-i-1] for i in 1..string.size])\nend", "  prefixes\
    \ = string.split(\"\").map { |s| s.to_s }\n  prefixes[0, prefixes.size] = prefixes[0,\
    \ prefixes.size].downcase\n  prefixes\nend", "\tresult = []\n\tprefix = \"\"\n\
    \tstring.scan(/^(\\w+)/) do |word|\n\t\tresult += [prefix] + word\n\t\tprefix\
    \ = word\n\tend\n\tresult\nend", "  return string.split(\"\").map.with_index.collect{|x,\
    \ i| [x, i]}\nend", "  string[1...string.length-1]\nend", "  result = []\n  loop\
    \ do\n    result.append(string)\n    string = string[1..-1]\n  end\n  result\n\
    end\nall_prefixes._dont_inline_ = \"all\"", "  string = string.split(//)\n  prefix.each\
    \ {|str| str[string.index(str).length..-1]}\nend\n</pre>\n</div>", "  prefixes\
    \ = []\n  prefix = string.first\n  string.drop(1)\n  while string.first != \"\"\
    \n    prefix << string.first\n    prefixes << prefix\n    string.drop(1)\n  end\n\
    \  return prefixes\nend", "  prefix = []\n  \n  i = -1\n  while i < string.length\n\
    \    if string[i, string.length] == string[i, 0]\n      prefix.concat all_prefixes(string[i\
    \ + 1:])\n    else\n      prefix.push string[i, string.length]\n    i += 1\n \
    \ end\n  \n  prefix\nend\n</code>\nAnd here is a more efficient implementation\
    \ that uses the same idea to generate all suffixes from longest to shortest. \n\
    <code>", "  string.split('').select{|x| x =~ /^\\W/ }.map{|x| x.upcase }\nend\n\
    </code>\nAnd here it is with Ruby 1.9's ability to pass methods in as a block:\n\
    <code>", "  prefix = []\n  string.split(\"\").each do |x|\n    prefix << x if\
    \ x.length <= prefix.length\n  end\n  prefix\nend", "    array = []\n    string.gsub!(/^(.+)$/)\
    \ { array << $1 }\n    string.gsub!(/^.+(.+)$/) { array << $1 }\n    string.gsub!(/(.+)\\\
    .$/) { array << $1 }\n    string.gsub!(/(.+)$/) { array << $1 }\n    array\nend",
  "  array = []\n  string.split(\"\").each do |char|\n    array << char if prefix_length(char)\
    \ == string.length\n  end\n  array\nend", "  # Return array of all prefixes from\
    \ shortest to longest of the input string\n  # >>> all_prefixes.call(\"abc\")\n\
    \  # [\"a\", \"ab\", \"abc\"]\n  # >>> all_prefixes.call(\"ab\")\n  # [\"a\",\
    \ \"ab\", \"ab\"]\n  # >>> all_prefixes.call(\"a\")\n  # [\"a\", \"a\"]\n  prefixes\
    \ = Array.new\n  prefix = string.first\n  until prefix.nil?\n    prefixes << prefix\n\
    \    prefix = prefix[1..-1]\n  end\n  prefixes\nend", "  string.to_s.split.map\
    \ { |s| s.split('').map(&:first) }.reduce(:|)\nend", "  prefixes = Array.new\n\
    \  length = (string.size - 1).downto(0)\n  (0...length).each do |i|\n    prefixes\
    \ << string[0, i + 1]\n  end\n  prefixes\nend", "  return Array.new(string.length)\
    \ do |i|\n    while i > 0\n      i -= 1\n      if string[i].downcase == string[0...i].downcase\n\
    \        yield string[0...i]\n      end\n    end\n  end\nend", "  prefix = string.dup\n\
    \  results = []\n  while prefix.length\n    prefix = prefix.chomp(prefix + (\"\
    \\n\" * 100000))\n    results << (prefix + \"\\n\")\n  end\n  results\nend", " \
    \   prefixes = []\n    length = 0\n    prefix = \"\"\n    letters = string.split(\"\
    \")\n    letters.each do |letter|\n      length += 1\n      prefix += letter\n\
    \      if length == string.size\n        prefixes << prefix\n        prefix =\
    \ \"\"\n      end\n    end\n    return prefixes\nend", "  return string.split('').reverse.map\
    \ { |s| s.reverse.length }\nend", "  all = []\n  prefix = nil\n  string.each_char\
    \ do |char|\n    prefix = char if prefix && !prefix.empty?\n    all << prefix\
    \ unless prefix.nil?\n    prefix = nil\n  end\n  return all\nend", "  return string.split(//).map\
    \ { |s| s[0] }\nend", "  result = []\n  prefix_length = 1\n  string_length = string.length\n\
    \  while prefix_length < string_length\n    prefix = string[0,prefix_length]\n\
    \    break if string.include?(prefix)\n    prefix_length += 1\n  end\n  result\
    \ << prefix until prefix_length == string_length\n  return result\nend\nend\n\
    </code>\n<|/ a tags=ruby,regex |>\n<| a |>\n<code>\nmy_string = 'abc'", "  prefixes\
    \ = []\n  i = -1\n  while i < string.length\n    if prefixes.include?(string.slice!(0,\
    \ i)) == 0\n      break\n    end\n    i += 1\n    prefixes << string.slice!(0,\
    \ i)\n  end\n  prefixes\nend", "  return Array.new(string.length) { |i| string.slice(0,\
    \ i) }\nend", "  prefixes = []\n  index = 0\n  while index < string.length\n \
    \   prefixes.push string[index..-1]\n    index += 1\n  end\n  prefixes\nend",
  "  if string == \"\"\n    []\n  else\n    string.split(\"\").inject([]) do |memo,\
    \ char|\n      memo << char\n      memo << memo.last + char\n      memo\n    end\n\
    \  end\nend", "  prefixes = []\n  prefix = \"\"\n  string.gsub!(/\\A./, prefix)\
    \ { prefixes << prefix }\n  string.gsub!(/(\\A|\\b)/, prefix) { prefixes << prefix\
    \ }\n  string.gsub!(/\\b/, prefix) { prefixes << prefix }\n  string.gsub!(/([a-zA-Z])([a-zA-Z])/,\
    \ '\\1\\2') { prefixes << prefix }\n  string.gsub!(/([a-zA-Z])\\1/, '\\1') { prefixes\
    \ << prefix }\n  string.gsub!(/[a-zA-Z]/, '') { prefixes << prefix }\n  prefixes\n\
    end\n</code>\n<|/ a |>\n<| a tags=ruby dscore=0 |>\nYou can use inject for this:\n\
    <code>", "  prefix = []\n  i = string.size\n  while i >= 0\n    prefix << string[0..i-1]\n\
    \    i -= 1\n  end\n  prefix\nend", "  if string.empty?\n    []\n  else\n    string.split('').reverse.map\
    \ { |s| s[0...s.length] }.map { |s| s.reverse.join }\n  end\nend", "\tprefixes\
    \ = []\n\t\n\tstring.split(\"\").each_with_index do |char, i|\n\t\tif i == 0\n\
    \t\t\tprefixes << char\n\t\t\tnext\n\t\tend\n\t\t\n\t\tif char == string[i-1]\n\
    \t\t\tprefixes << char\n\t\t\tnext\n\t\tend\n\t\t\n\t\tprefixes << \"#{char}#{string[i-1]}\"\
    \n\tend\n\t\n\treturn prefixes\nend", "  prefixes = []\n  i = 0\n  while i <=\
    \ (string.length - 2)\n    char = string[i]\n    next = string[i+1]\n    next\
    \ != \"\" and next != char and next != \".\" and next != \"?\" and next != \"\
    ,\" and next != \"!\" and next != \"&\" and next != \"$\" and next != \"#\" and\
    \ next != \"%\" and next != \"&\" and next != \"'\" and next != \"+\" and next\
    \ != \"-\" and next != \"*\" and next != \"/\" and next != \"[\" and next != \"\
    ]\" and next != \"(\" and next != \")\" and next != \"~\" and next != \"'\" and\
    \ next != \"!\" and next != \"?\" and next != \",\" and next != \"#\" and next\
    \ != \"&\" and next != \"'\" and next != \"+\" and next != \"-\" and next != \"\
    *\" and next != \"/\" and next != \"[\" and next != \"]\" and next != \"(\" and\
    \ next != \")\" and next != \"~\" and next != \"'\" and next != \"!\" and next\
    \ != \"?\" and next != \",\" and next != \"#\" and next != \"&\" and next != \"\
    '\" and next != \"+\" and next != \"-\" and next != \"*\" and next != \"/\" and\
    \ next != \"[\" and next != \"]\" and next != \"(\" and next != \")\" and next\
    \ != \"~\" and next != \"'\" and next != \"!\" and next != \"?\" and next != \"\
    ,\" and next != \"#\" and next != \"&\" and next != \"'\" and next != \"+\" and\
    \ next != \"-\" and next != \"*\" and next != \"/\" and next != \"[\" and next\
    \ != \"]\" and next != \"(\" and next != \")\" and next != \"~\" and next != \"\
    '\" and next != \"!\" and next != \"?\" and next != \",\" and next != \"#\" and\
    \ next != \"&\" and next != \"'\" and next != \"+\" and next != \"-\" and next\
    \ != \"*\" and next != \"/\" and next != \"[\" and next != \"]\" and next != \"\
    (\" and next != \")\" and next != \"~\" and next != \"'\" and next != \"!\" and\
    \ next != \"?\" and next != \",\" and next != \"#\" and next != \"&\" and next\
    \ != \"'\" and next != \"+\" and next != \"-\" and next != \"*\" and next != \"\
    /\" and next != \"[\" and next != \"]\" and next != \"(\" and next != \")\" and\
    \ next != \"~\" and next != \"'\" and next != \"!\" and next != \"?\" and next\
    \ != \",\" and next != \"#\" and next != \"&\" and next != \"'\" and next != \"\
    +\" and next != \"-\" and next != \"*\" and next != \"/\" and next != \"[\" and\
    \ next != \"]\" and next != \"(\" and next != \")\" and next != \"~\" and next\
    \ != \"'\" and next != \"!\" and next != \"?\" and next != \",\" and next != \"",
  "  result = []\n  prefix = nil", "  string.split(\"\").map { |s| s.split(\"\").map{|x|\
    \ x[0,s.length]}.join}\nend", "  return prefixes(string, 1)\nend", "  prefixes\
    \ = []\n  prefix = \"\"\n  string.each_char.with_object([]) do |c, chars|\n  \
    \  chars << prefix if c != prefix\n    prefix = c\n  end\nend", "  string.split(//).map.with_index\
    \ do |char, index|\n    if index == 0\n      char\n    else if index == (string.length\
    \ - 1)\n      char + char\n    else\n      char + char + string[index + 1]\n \
    \   end\n  end\nend", '  prefix_list = []', "  return string.gsub(/(.)(?=[a-z]|$)|\\\
    1*/i, '\\1')\nend\n</cell>\n<code language=julia-1.5>\nall_prefixes(\"abc\")\n\
    </cell>\n<code language=julia-1.5>", "  result = {}\n  min_len = nil\n  max_len\
    \ = nil\n  string.downcase.scan(/^[a-z]+/).each do |s|\n    min_len = s.length\
    \ if !min_len or s.length < min_len\n    max_len = s.length if max_len and s.length\
    \ >= max_len\n    result[s] = true if max_len and s.length >= max_len\n  end\n\
    \  result\nend", "  prefix_lengths = []\n  prefix_positions = []", "  prefixes\
    \ = Array.new\n  string.split(//).each do |char|\n    prefix = char.downcase\n\
    \    char.succ while prefix.empty? && char < string.length\n    prefixes << char\n\
    \  end\n  prefixes\nend", "  prefixes = []\n  index = string.size\n  while index\
    \ > 0\n    index = index - 1\n    prefixes << string[0...index]\n  end\n  prefixes\n\
    end\n</pre>", "  string.each_char.with_object([]) do |char, i|\n    char.upcase!\n\
    \    prefix = string.slice!(0, i)\n    if prefix.is_a?(String)\n      prefix.upcase!\n\
    \    end\n    prefix.empty? ? char : [char] + all_prefixes(prefix)\n  end\nend",
  "  return string.split(//).map(&:first)\nend\n</code>\n<|/ a tags=ruby,string |>\n\
    <| a |>\n<code>", "  return [string[0..k] for k in 0...(string.length-1)]\nend",
  "  prefix_array.clear\n  prefix_array << string\n  until prefix_array.empty?\n \
    \   return prefix_array\n  end\nend", "  result = []\n  current_length = string.size\n\
    \  max_prefix = string.chars[0]\n  \n  until current_length > 0\n  \n    result.append(max_prefix)\n\
    \    current_length = current_length - 1\n    max_prefix = string.chars[current_length]\n\
    \  end\n  \n  result\nend", "  prefixes = Array.new\n  string.chars.each do |c|\n\
    \    prefixes << c unless prefixes.include? c[prefixes.length..-1]\n  end\n  prefixes\n\
    end", "  string = string.dup\n  loop do\n    break if string.empty?\n    return\
    \ [] if string.length == 1\n    prefix ||= string[0..1]\n    string << prefix\n\
    \  end\n  nil\nend", "  # Convert to lowercase\n  string = string.downcase", "\t\
    prefixes = []\n\tprefix = \"\"\n\tstring.downcase.scan(/[^a-zA-Z]/).each do |character|\n\
    \t\tprefix += character\n\t\tprefixes << prefix\n\t\tprefix = \"\"\n\tend\n\t\
    prefixes\nend", "  return string.scan(/./).map { |x| x.length }\nend", "  prefixes\
    \ = []\n  string.split(\"\").each do |char|\n    prefixes << char if char != \"\
    a\"\n  end\n  prefixes\nend", "  res = []\n  prefix = \"\"\n  string.split(\"\"\
    ).each_with_index do |char, i|\n    prefix += char\n    if i < string.length -\
    \ 1\n      res.push(prefix)\n      prefix = \"\"\n    end\n  end\n  res\nend\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nYour code does work, but it's incredibly\
    \ slow.  It takes about two minutes to finish a million-character string, for\
    \ example.\n<|/ c |>\n<| a tags=string,ruby,arrays,algorithm |>\n<code>", "  return\
    \ string.split(//).inject([]) {|result, prefix| result.unshift(prefix)} if string.present?\n\
    \  []\nend\n</code>\n<|/ a |>\n<| c |>\nYou do realize that `inject` is Ruby 1.9\
    \ only? How about `.inject([], &:unshift)` ?\n<|/ c |>\n<| c |>\nOh yeah. Didn't\
    \ even notice that. Thanks. Corrected\n<|/ c |>\n<| a tags=ruby,regex dscore=3\
    \ |>\nHere is a simple regex that works:\n<code>\n/^(.+)(.{3})(.{2})$/\n</code>\n\
    <|/ a |>\n<| c |>\nThis doesn't account for cases where \"aaa...aaa\" should be\
    \ considered valid.\n<|/ c |>\n<| a tags=ruby,regex |>\n<code>", "  string = string.to_s\n\
    \  prefixes = []\n  loop do\n    prefixes << string[0,1]\n    string = string[1..-1]\n\
    \  end\n  prefixes\nend", "  Array.new(string.length, string)\n  prefix = nil\n\
    \  prefix = string if string.empty?\n  prefix = string[0...-1] if string.size\
    \ > 1\n  prefix = [prefix] if prefix.respond_to?(:[]=)\n  prefix\nend", "  result\
    \ = []\n  i = 0\n  while i < string.length\n    result[i] = string[0,i]\n    i\
    \ += 1\n  end\n  result\nend", "  if string.length == 0\n    []\n  else\n    prefix_array\
    \ = []\n    prefix_array[0] = string[0]\n    (1..string.length).each do |i|\n\
    \      prefix_array[i+1] = prefix_array[i] + string[i]\n    end\n    prefix_array\n\
    \  end\nend", "  prefixes = []\n  for i in 0...string.size\n    prefixes[i] =\
    \ string[0...i]\n    \n  prefixes.uniq\nend\n</code>\n<|/ a tags=ruby |>\n<| c\
    \ |>\n`prefixes[i] = string[0...i]` can also be written as `prefixes << string[0...i]`.\n\
    <|/ c |>\n<| a |>\nThis was my attempt at a shorter solution:\n<code>", "  return\
    \ find_all_indexes(string, 'a').reverse.map(&:first)\nend", "  all_prefixes =\
    \ []\n  prefixes_of_string = string.split(\"\")\n  while prefixes_of_string.length\
    \ > 0\n    all_prefixes.unshift(prefixes_of_string[0])\n    prefixes_of_string\
    \ = prefixes_of_string.delete_at(0)\n  end\n  all_prefixes\nend", "  prefixes\
    \ = []\n  prefix = \"\"\n  string.each_char do |c|\n    if c != prefix and c !=\
    \ string.chars.last\n      prefix = c\n    end\n  end\n  prefix << \"\" if string.size\
    \ == 0\n  until string.chars.last == prefix\n    prefix = prefix[-1]\n    prefixes\
    \ << prefix\n  end\n  prefixes\nend\n</code>\nI used Ruby 1.9's String#chars to\
    \ iterate through the string one character at a time and to remember the last\
    \ character so that we know where to append the trailing empty string. It is a\
    \ little bit more verbose than I initially wanted (though this was easier to write),\
    \ but it was very compact and readable.\nThe code is also more compact and easier\
    \ to understand than the other answers posted here.\n<|/ a |>\n<| a dscore=2 tags=ruby\
    \ |>\n<code>", "  prefixes = []\n  string.scan(/^(.*)/) do |prefix|\n    prefixes\
    \ << prefix\n  end\n  prefixes\nend", '  return [] if string.empty? || string.length
    == 1', "  return [] if string.empty?\n  prefixes = [string]\n  loop do\n    break\
    \ if string.length == 0\n    prefix = string[0...1]\n    prefixes << prefix\n\
    \    string = string[1..-1]\n  end\n  prefixes\nend", "  result = []\n  pos =\
    \ 1\n  while pos < string.length\n    char = string[pos]\n    pos +=1\n    if\
    \ char.nil?\n      result << char\n      break\n    end", "  prefixes = Array.new\n\
    \  while string.length > 0\n    prefix = string[0..-2]\n    prefixes << prefix\n\
    \    string = string[-2..-1]\n  end\n  prefixes\nend", "    string.length.times.map\
    \ { |i| string[0,i+1] }\nend", "  result = []\n  lengths = [string.length]\n \
    \ (0..string.length-1).each do |i|\n    string[0,i] = \"\"\n    lengths << string.length\n\
    \    result << string[0,i]\n  end\n  result\nend", "  return string.downcase.gsub(/^./)\
    \ { |prefix| prefix.downcase }\nend", "  string.split(//).flat_map { |s| [s[0...i],\
    \ s[i...s.length]] }.uniq.compact\nend", "  array = []\n  string.scan(/[^A-Za-z0-9_]+/)\
    \ do |word|\n    array.push(word)\n  end\n  array.uniq.sort\nend", "    string.length.times\
    \ do |i|\n        yield(string[0, i])\n    end\nend", "\tprefixes = Array.new\n\
    \tfor i in 1..string.length\n\t\twhile string[0..i] == \"#\" && i <= string.length\n\
    \t\t\tprefixes << string[0..i]\n\t\t\ti += 1\n\t\tend\n\tend\n\tprefixes\nend",
  "  return string.to_enum(:all_prefixes, string)\nend", "  string.replace(\" \",\
    \ \"\").split(\"/\").map do |i|\n    i.split(\".\").map do |j|\n      j[0..-2]\n\
    \    end\n  end.reduce(:concat).map{|s| s.join(\"/\")}\nend", "  array.map { |prefix|\
    \ prefix << string }\nend", "  string.split(\"\").map {|s| s.length == 0 ? s :\
    \ s[0...s.length]}.sort\nend", "  return string.split(/(?<=^|.)*/)\nend", "  prefixes\
    \ = Array.new\n  string.split('').each do |character|\n    prefixes.push(character)\
    \ unless prefixes.include?(character.to_s)\n  end\n  prefixes\nend", "  array.map\
    \ do |prefix|\n    array.pop if prefix != string\n    prefix\n  end\nend", " \
    \ return string.split.reduce(&:+)\nend", "  string.each_char.with_index.with_object([])\
    \ do |(c, idx), prefixes|\n    prefixes << c if idx < string.length\n  end\nend\n\
    </code>\n<|/ a |>\n<| c |>\nThis is definitely cleaner than mine.\n<|/ c |>\n\
    <| a |>\n<code>", "  prefixes = Array()\n  begin_index = 0\n  end_index = string.length\n\
    \  while begin_index < end_index\n    prefix = string[begin_index..end_index]\n\
    \    unless prefix.empty?\n      prefixes << prefix\n    end\n    begin_index\
    \ += 1\n    begin_index += 1\n    if begin_index > end_index\n      break\n  \
    \  end\n    begin_index += 1\n  end\n  return prefixes\nend", "  \n  array = string.chars\n\
    \  array.each_with_index do |char, index|\n    array[index..-1].each do |prefix|\n\
    \      yield prefix\n    end\n  end\nend", "  array.each_with_index.map { |c,\
    \ i| i }.sort.reverse.map { |i| string[0,i] }\nend", "  string.downcase!\n  result\
    \ = []\n  string.split(\"\").each do |c|\n    result << c unless result.include?(c)\n\
    \  end\n  result\nend", "  prefixes = []\n  i = 0\n  while i < string.length\n\
    \    prefix = string[prefixes.length]\n    if string.length >= i+1\n      prefix\
    \ = string[prefixes.length-1] + string[i]\n    prefixes << prefix\n    i += 1\n\
    \  end\n  return prefixes\nend", "  strings = string.split(\"\")\n  prefixes =\
    \ []\n  prefixes = []\n  current_string = \"\"\n  current_prefix = \"\"\n  current_prefix\
    \ = \"\"\n  current_string = \"\"\n  current_prefix = \"\"\n  current_prefix =\
    \ \"\"\n  current_string = \"\"\n  current_prefix = \"\"\n  current_prefix = \"\
    \"\n  current_string = \"\"\n  current_prefix = \"\"\n  current_prefix = \"\"\n\
    \  current_string = \"\"\n  current_prefix = \"\"\n  current_prefix = \"\"\n \
    \ current_string = \"\"\n  current_prefix = \"\"\n  current_prefix = \"\"\n  current_string\
    \ = \"\"\n  current_prefix = \"\"\n  current_prefix = \"\"\n  current_string =\
    \ \"\"\n  current_prefix = \"\"\n  current_prefix = \"\"\n  current_string = \"\
    \"\n  current_prefix = \"\"\n  current_prefix = \"\"\n  current_string = \"\"\n\
    \  current_prefix = \"\"\n  current_prefix = \"\"\n  current_string = \"\"\n \
    \ current_prefix = \"\"\n  current_prefix = \"\"\n  current_string = \"\"\n  current_prefix\
    \ = \"\"\n  current_prefix = \"\"\n  current_string = \"\"\n  current_prefix =\
    \ \"\"\n  current_prefix = \"\"\n  current_string = \"\"\n  current_prefix = \"\
    \"\n  current_prefix = \"\"\n  current_string = \"\"\n  current_prefix = \"\"\n\
    \  current_prefix = \"\"\n  current_string = \"\"\n  current_prefix = \"\"\n \
    \ current_prefix = \"\"\n  current_string = \"\"\n  current_prefix = \"\"\n  current_prefix\
    \ = \"\"\n  current_string = \"\"\n  current_prefix = \"\"\n  current_prefix =\
    \ \"\"\n  current_string = \"\"\n  current_prefix = \"\"\n  current_prefix = \"\
    \"\n  current_string = \"\"\n  current_prefix = \"\"\n  current_prefix = \"\"\n\
    \  current_string = \"\"\n  current_prefix = \"\"\n  current_prefix = \"\"\n \
    \ current_string = \"\"\n  current_prefix = \"\"\n  current_prefix = \"\"\n  current_string\
    \ = \"\"\n  current_prefix = \"\"\n  current_prefix = \"\"\n  current_string =\
    \ \"\"\n  current_prefix = \"\"\n  current_prefix = \"\"\n  current_string = \"\
    \"\n  current_prefix = \"\"\n  current_prefix = \"\"\n  current_string = \"\"\n\
    \  current_prefix = \"\"\n  current_prefix = \"\"\n  current_string = \"\"\n \
    \ current_prefix = \"\"\n  current_prefix = \"\"\n  current_string = \"\"\n  current_prefix\
    \ = \"\"\n  current_prefix = \"\"\n  current_string = \"\"\n  current_prefix =\
    \ \"\"\n  current_prefix = \"\"\n  current_string = \"\"\n  current_prefix = \"\
    \"\n  current_prefix = \"\"\n  current_string = \"\"\n  current_prefix = \"\"\n\
    \  current_prefix = \"\"\n  current_string = \"\"\n  current_prefix = \"\"\n \
    \ current_prefix = \"\"\n  current_string = \"\"\n  current_prefix = \"\"\n  current_prefix\
    \ = \"\"\n", "  string.split(\"\").\n    map {|char| char.downcase}.\n    sort.\n\
    \    collect {|char| char.length <= 2 ? char : char[0...1] }\nend\n</code>\n<|/\
    \ a tags=ruby |>\n<| a |>\nYou can do something like this\n<code>", "  # Initialize\
    \ an array to store all prefixes\n  all_prefixes = []", "  prefix_string = []\n\
    \  current_string = ''\n  length = string.length", "  result = []\n  prefixes(string,\
    \ [], result)\n  result\nend", "  return string.to_s.scan(/(.+)/).flatten.compact\n\
    end", "  prefix_arr = []\n  string.split('').each do |letter|\n    prefix_arr.push(letter)\n\
    \  end\n  prefix_arr.each { |prefix| return prefix_arr unless prefix_arr.index(prefix)\
    \ == 0 }\nend\n</code>\nAnd then using that to find the shortest prefix with the\
    \ longest suffix:\n<code>", "  prefixes = Array.new\n  string.split('').each {\
    \ |c| prefixes << c if c.length >= prefixes.size }\n  prefixes\nend", "  all=[]\n\
    \  for i in string.split\n    all+=[string[0,i-1]]\n  return all\nend", "  result\
    \ = []\n  max_length = string.length", "  string.split(//).map { |e| e[0..-2]\
    \ }.select { |e| e.length >= string.length }.uniq\nend", "  prefix_array = Array.new\n\
    \  string.each_char.with_index do |char, index|\n    prefix_array << char if index\
    \ == 0\n  end\n  prefix_array\nend", "  result = []\n  prefix_length = nil", " \
    \ prefixes = Array.new\n  string.length.downto(1) do |i|\n    prefixes[i] = string[0..i]\n\
    \  end\n  prefixes\nend", "  string.length.times.reduce([]) do |prefixes, character|\n\
    \    prefixes << string[0, character]\n    character\n  end\nend", "  return all_suffixes.call(string,\
    \ string)\nend", "  string.split(//).\n    map(&:first).\n    map {|s| s.match(//).to_a}.\n\
    \    reduce(:|)\nend\n</cell>\n<cell>\nall_prefixes.call(\"abc\")\n</cell>\n<text>\n\
    Satisfying an arbitrary condition", "  array = string.split(//).map { |x| x.strip\
    \ }\n  array.reject { |x| x.empty? }.map { |x| x.length }\nend", "  return []\
    \ if string.empty? || string.length < 2 # special case\n  return [string[0], string[0,\
    \ 1], string[0, 1], string[0, 1], string[0, 1]]\nend", '  prefixes = []', "  \
    \  letters = string.split(\"\")\n    prefix_array = Array.new\n    prefix_array[0]\
    \ = letters[0]\n    prefix_array[1] = letters[0]\n    prefix_array[2] = letters[0]\n\
    \    prefix_array[3] = letters[0]\n    prefix_array[4] = letters[0]\n    prefix_array[5]\
    \ = letters[0]\n    prefix_array[6] = letters[0]\n    prefix_array[7] = letters[0]\n\
    \    prefix_array[8] = letters[0]\n    prefix_array[9] = letters[0]\n    prefix_array[10]\
    \ = letters[0]\n    prefix_array[11] = letters[0]\n    prefix_array[12] = letters[0]\n\
    \    prefix_array[13] = letters[0]\n    prefix_array[14] = letters[0]\n    prefix_array[15]\
    \ = letters[0]\n    prefix_array[16] = letters[0]\n    prefix_array[17] = letters[0]\n\
    \    prefix_array[18] = letters[0]\n    prefix_array[19] = letters[0]\n    prefix_array[20]\
    \ = letters[0]\n    prefix_array[21] = letters[0]\n    prefix_array[22] = letters[0]\n\
    \    prefix_array[23] = letters[0]\n    prefix_array[24] = letters[0]\n    prefix_array[25]\
    \ = letters[0]\n    prefix_array[26] = letters[0]\n    prefix_array[27] = letters[0]\n\
    \    prefix_array[28] = letters[0]\n    prefix_array[29] = letters[0]\n    prefix_array[30]\
    \ = letters[0]\n    prefix_array[31] = letters[0]\n    prefix_array[32] = letters[0]\n\
    \    prefix_array[33] = letters[0]\n    prefix_array[34] = letters[0]\n    prefix_array[35]\
    \ = letters[0]\n    prefix_array[36] = letters[0]\n    prefix_array[37] = letters[0]\n\
    \    prefix_array[38] = letters[0]\n    prefix_array[39] = letters[0]\n    prefix_array[40]\
    \ = letters[0]\n    prefix_array[41] = letters[0]\n    prefix_array[42] = letters[0]\n\
    \    prefix_array[43] = letters[0]\n    prefix_array[44] = letters[0]\n    prefix_array[45]\
    \ = letters[0]\n    prefix_array[46] = letters[0]\n    prefix_array[47] = letters[0]\n\
    \    prefix_array[48] = letters[0]\n    prefix_array[49] = letters[0]\n    prefix_array[50]\
    \ = letters[0]\n    prefix_array[51] = letters[0]\n    prefix_array[52] = letters[0]\n\
    \    prefix_array[53] = letters[0]\n    prefix_array[54] = letters[0]\n    prefix_array[55]\
    \ = letters[0]\n    prefix_array[56] = letters[0]\n    prefix_array[57] = letters[0]\n\
    \    prefix_array[58] = letters[0]\n    prefix_array[59] = letters[0]\n    prefix_array[60]\
    \ = letters[0]\n    prefix_array[61] = letters[0]\n    prefix_array[62] = letters[0]",
  "  array = string.split(\"\")\n  array.each_index do |i|\n    array[i] = array[i]\
    \ + array[i]\n  end\n  array\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
