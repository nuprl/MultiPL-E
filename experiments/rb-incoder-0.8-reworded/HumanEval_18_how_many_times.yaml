name: HumanEval_18_how_many_times
language: rb
prompt: "# Find how many times a given substring can be found in the original string.\
  \ Count overlaping cases.\n# >>> how_many_times.call(\"\", \"a\")\n# 0\n# >>> how_many_times.call(\"\
  aaa\", \"a\")\n# 3\n# >>> how_many_times.call(\"aaaa\", \"aa\")\n# 3\ndef how_many_times(string,\
  \ substring)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_how_many_times\n\
  \    candidate = method(:how_many_times)\n    assert_equal(0, candidate.call(\"\"\
  , \"x\"))\n    assert_equal(4, candidate.call(\"xyxyxyx\", \"x\"))\n    assert_equal(4,\
  \ candidate.call(\"cacacacac\", \"cac\"))\n    assert_equal(1, candidate.call(\"\
  john doe\", \"john\"))\n  end\nend\n"
completions: ["  counter = 0\n  i = 0\n  while i < string.length\n    if string[i]\
    \ != substring[i]\n      break\n    i += 1\n    counter += 1\n  end\n  counter\n\
    end\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI think this doesn't work, if the original\
    \ string has multiple occurrences of the substring.\n<|/ c |>\n<| a dscore=2 |>\n\
    This is an extension of the answer given by Chris Taylor, using a recursive approach\
    \ instead of an explicit loop. \n<code>", "\tcounter = 0\n\ti = 0\n\twhile i <\
    \ string.size\n\t\tif string[i] == substring[i]\n\t\t\tcounter += 1\n\t\ti +=\
    \ 1\n\tcounter\nend", "  return 0 unless string\n  return string.split(substring).length\
    \ unless string.index(substring)", "  return string.count(substring)\nend", " \
    \ i = 0\n  j = 0\n  count = 0\n  while i < string.length and j < substring.length\n\
    \    if string[i] == substring[j]\n      count += 1\n      i += 1\n      j +=\
    \ 1\n    else\n      if string[i] < substring[j]\n        i += 1\n      else\n\
    \        j += 1\n    end\n  end\n  count\nend\nhow_many_times.call(\"\", \"\"\
    )\nhow_many_times.call(\"a\", \"a\")\nhow_many_times.call(\"aa\", \"a\")\nhow_many_times.call(\"\
    aaa\", \"aa\")\nhow_many_times.call(\"aaaa\", \"aa\")\nhow_many_times.call(\"\
    aac\", \"a\")\nhow_many_times.call(\"aaac\", \"a\")\nhow_many_times.call(\"aa\"\
    , \"a\")\nhow_many_times.call(\"aaa\", \"a\")\nhow_many_times.call(\"aaaaa\",\
    \ \"a\")\nhow_many_times.call(\"aaaaaa\", \"a\")\nhow_many_times.call(\"aaaac\"\
    , \"a\")\nhow_many_times.call(\"aaaca\", \"a\")\nhow_many_times.call(\"aaacaa\"\
    , \"a\")\nhow_many_times.call(\"aac\", \"a\")\nhow_many_times.call(\"aaca\", \"\
    a\")\nhow_many_times.call(\"aacaa\", \"a\")\nhow_many_times.call(\"aacaaa\", \"\
    a\")\nhow_many_times.call(\"aacaaaa\", \"a\")\nhow_many_times.call(\"aa\", \"\
    a\")\nhow_many_times.call(\"aaa\", \"a\")\nhow_many_times.call(\"aaa\", \"a\"\
    )\nhow_many_times.call(\"aaacaaa\", \"a\")\nhow_many_times.call(\"aac\", \"a\"\
    )\nhow_many_times.call(\"aacaa\", \"a\")\nhow_many_times.call(\"aacaaa\", \"a\"\
    )\nhow_many_times.call(\"aacaaaa\", \"a\")\nhow_many_times.call(\"aac\", \"a\"\
    )\nhow_many_times.call(\"aaca\", \"a\")\nhow_many_times.call(\"aacaa\", \"a\"\
    )\nhow_many_times.call(\"aacaaa\", \"a\")\nhow_many_times.call(\"aacaaaa\", \"\
    a\")\nhow_many_times.call(\"aac\", \"a\")\nhow_many_times.call(\"aaca\", \"a\"\
    )\nhow_many_times.call(\"aacaa\", \"a\")\nhow_many_times.call(\"aacaaa\", \"a\"\
    )\nhow_many_times.call(\"aacaaaa\", \"a\")\nho", "  substring.split(//).inject(0)\
    \ {|sum, el| sum + 1 if el == string} rescue 0\nend", "  result = 0\n  i = 0\n\
    \  while i < string.length\n    j = string.index(substring, i)\n    i = j + 1\
    \ # Start searching after the character\n    result += 1\n  end\n  result\nend\n\
    </cell>\n<cell>", "  return string.length if string.include?(substring) ? string.count(substring)\
    \ : string.length + (string.upcase.length > substring.upcase.length ? string.upcase.count(substring)\
    \ : string.downcase.count(substring))\nend", "  string.split(substring).length\
    \ - string.split(substring).count(substring)\nend", "  string.split(substring).uniq.size\n\
    end", "  count = 0\n  string.split(substring).each do |x|\n    if string.length\
    \ -1 ==\n      break\n    end\n    break if x == substring\n    count += 1\n \
    \ end\n  count\nend", "    i = 0\n    count = 0\n    index = string.index(substring)\n\
    \    \n    while index < string.length\n        count += 1\n        index = string.index(substring,\
    \ index + 1)\n    end\n    \n    return count\nend", "  return substring.count\
    \ string\nend", "  i = 0\n  string_with_substring =  string[0,i] + substring +\
    \ string[i..-1]\n  while i <= string.size do\n    if string_with_substring ==\
    \ string\n      return i\n    i += 1\n    string_with_substring =  string[0,i]\
    \ + substring + string[i..-1]\n  end\n  return -1\nend", "  string.gsub(substring,\
    \ \"\").length\nend\n</cell>\n<code language=julia-1.0>", "  pos = 0\n  result\
    \ = 1\n  while pos < string.length\n    i = string.index(substring, pos)\n   \
    \ result += 1\n    if i > 0 and string[i - 1] == substring\n      pos = i + 1\n\
    \    else\n      pos = i\n  end\n  result\nend", "  # Convert string to array\
    \ of lowercase characters.\n  characters = string.downcase.split(\"\")", "  count\
    \ = 0\n  string.chars.each_with_index do |char, index|\n    if substring == char\n\
    \      count += 1\n    end\n  end\n  count\nend", "  total = 0\n  string_size\
    \ = string.size\n  substring_size = substring.size\n  while string_size > 0 &&\
    \ substring_size > 0 && string.start_with?(substring)\n    total += 1\n    string.slice!(0,\
    \ substring_size)\n    string_size = 0\n  end\n  total\nend", "  return string.scan(substring).size\n\
    end", "  string_index = 0\n  while string_index < string.length\n    index = string.index(substring,\
    \ string_index)\n    if index\n      string_index = index + substring.length\n\
    \    else\n      break\n    end\n  end\n  string_index\nend", "  count = 0\n \
    \ pos = 0\n  while pos < string.length\n    pos = string.index(substring, pos)\n\
    \    if pos == string.length then return count\n    count = count + 1\n  end\n\
    end", "  i = 0\n  while true\n    if i > (string.length - substring.length)\n\
    \      break\n    if string.slice(i..(i+substring.length)).include?(substring)\n\
    \      i += 1\n    else\n      i = 0\n    end\n  end\n  return i\nend\n</code>\n\
    <|/ a dscore=3 |>\n<| a dscore=2 |>\nI find this a lot more succinct:\n<code>",
  "  n = substring.count(string)\n  n += 1 if substring == string else 0\n  n += 1\
    \ if string == \"\" else 0\n  return n\nend\nhow_many_times = :how_many_times",
  "  count = 0\n  string.downcase!\n  substring.downcase!\n  while true\n    break\
    \ if string.length <= substring.length\n    break if string[0, substring.length]\
    \ == substring\n    count += 1\n    string = string[substring.length..-1]\n  end\n\
    \  count\nend\nhow_many_times(ARGV[0], ARGV[1])", "    string_index = nil\n  \
    \  index_count = 0\n    string.each_char.with_index do |char, index|\n       \
    \ if char == substring[index]\n            index_count += 1\n            if index_count\
    \ > 1\n                string_index = index\n                break\n         \
    \   end\n        end\n    end\n    index_count + 1\nend\n</code>\nTo make things\
    \ easier, let's make some helper methods. I make them global functions so I can\
    \ use them in the console and inside of a class.\n<code>", "  string.gsub(substring,\
    \ \"\").length\nend", "\tcount = 0\n\tlast_index = -1\n\tindex = 0\n\twhile index\
    \ + 1 < string.length\n\t\tif string[index] == substring[index] && (last_index\
    \ == -1 || last_index + 1 < substring.length)\n\t\t\tcount += 1\n\t\tlast_index\
    \ = index\n\t\tindex += 1\n\tstring[last_index..-1]\nend", "  string_size    \
    \   = string.length\n  substring_size   = substring.length\n  resulting_length\
    \ = 0\n  \n  while true\n    index = string.index(substring, resulting_length)\n\
    \    \n    if index\n      # We found a match\n      resulting_length += index\n\
    \      \n    else\n      # Didn't find it\n      return resulting_length\n   \
    \ end\n    \n    if resulting_length >= string_size\n      # We found all the\
    \ substring\n      return resulting_length\n    end\n  end\nend\n</code>\n<|/\
    \ a tags=ruby,substring,string |>\n<| c |>\nThis doesn't work for `how_many_times(\"\
    aaaa\", \"aa\")`\n<|/ c |>\n<| c |>\nThat's a very good point that I forgot! I'm\
    \ editing the code to include that case too.\n<|/ c |>\n<| c |>\nIt's still wrong\
    \ though, since your code only finds overlapping matches.\n<|/ c |>\n<| c |>\n\
    Hmm... I didn't notice that when I wrote it. I updated the code to include the\
    \ correct overlapping matches. I tested it out and it seems to work perfectly.\n\
    <|/ c |>\n<| c |>\nI see what you did. It's a great solution and I like that it\
    \ uses the same basic approach to searching the string. I think it should be the\
    \ accepted answer.\n<|/ c |>\n<| a tags=ruby,substring,string |>\n<code>", " \
    \ if string.length == 0\n    return 0\n  if substring.length == 0\n    return\
    \ string.length\n  i = 0\n  j = 0\n  count = 0\n  while i < string.length\n  \
    \  while j < substring.length\n      if string[i] == substring[j]\n        count\
    \ += 1\n        break\n      j += 1\n    i += 1\n  count\nend", "  count = 0\n\
    \  i = 0\n  while i < string.length\n    if string[i] == substring[0]\n      count\
    \ += 1\n      if i == string.length\n        break unless string[i + 1] == substring[1]\n\
    \      end\n      i += 1\n    end\n    i += 1\n  end\n  count\nend", "\tstring.split(substring).length\n\
    end", "  if string == \"\"\n    then\n      0\n  else\n    begin\n      count\
    \ = string.index(substring)\n      if count == nil\n        then\n          0\n\
    \      else\n        begin\n          count = count + 1\n          while count\
    \ <= string.length\n            begin\n              if string.index(substring,\
    \ count) == nil\n                then\n                  return 0\n          \
    \      else\n                  count = count + 1\n                end\n      \
    \      end\n        end\n    end\n  end\nend", "    string_size = string.size\n\
    \    substring_size = substring.length\n    count = 0", "  count = 0\n  string.split(substring).each\
    \ do |s| count += 1 if s != \"\" end\n  count\nend", "  count = 0\n  until substring\
    \ == \"\" do\n    count += 1\n    substring = substring.chop\n  end\n  return\
    \ count\nend", "  count = [0]\n  string.each_char do |c|\n    if c =~ substring\n\
    \      count += 1 \n    end\n  end\n  count.max\nend\n</cell>\n<code language=julia-0.6>\n\
    how_many_times(string, \"a\")\n</cell>\n<code language=julia-0.6>\nhow_many_times(string,\
    \ \"c\")\n</cell>\n<code language=julia-0.6>\nhow_many_times(string, \"bc\")\n\
    </cell>\n<code language=julia-0.6>\nhow_many_times(string, \"abc\")\n</cell>\n\
    <code language=julia-0.6>\nhow_many_times(string, \"bcc\")\n</cell>\n<code language=julia-0.6>\n\
    how_many_times(string, \"abcc\")\n</cell>\n<code language=julia-0.6>\nhow_many_times(string,\
    \ \"abc\")\n</cell>\n<code language=julia-0.6>\nhow_many_times(string, \"aaa\"\
    )\n</cell>\n<code language=julia-0.6>\nhow_many_times(string, \"aaaaa\")\n</cell>\n\
    <code language=julia-0.6>\nhow_many_times(string, \"aaaaaa\")\n</cell>\n<code\
    \ language=julia-0.6>\nhow_many_times(string, \"aaaaaaa\")\n</cell>\n<code language=julia-0.6>\n\
    how_many_times(string, \"aaaaaaab\")\n</cell>\n<code language=julia-0.6>\nhow_many_times(string,\
    \ \"aaaaaaabc\")\n</cell>\n<code language=julia-0.6>\nhow_many_times(string, \"\
    aaaaaaabcc\")\n</cell>\n<code language=julia-0.6>\nhow_many_times(string, \"aaaaaaabccc\"\
    )\n</cell>\n<code language=julia-0.6>\nhow_many_times(string, \"aaaaaaabcccb\"\
    )\n</cell>\n<code language=julia-0.6>\nhow_many_times(string, \"aaaaaaabcccbb\"\
    )\n</cell>\n<code language=julia-0.6>\nhow_many_times(string, \"aaaaaaabcccbbb\"\
    )\n</cell>\n<code language=julia-0.6>\nhow_many_times(string, \"aaaaaaabcccbbbb\"\
    )\n</cell>\n<code language=julia-0.6>\nhow_many_times(string, \"aaaaaaabcccbbbbb\"\
    )\n</cell>\n<code language=julia-0.6>\nhow_many_times(string, \"aaaaaaabccc",
  "  return ((string.count(substring) + string.count(substring.downcase) - string.count(substring.upcase))/2).round\n\
    end", "  found_count = 0\n  string.each_char do |char|\n    if char == substring\n\
    \      found_count += 1\n    else\n      found_count += 1 if char == substring[0...-1]\n\
    \    end\n  end\n  return found_count\nend", "  return string.split(substring).size\
    \ - string.count(substring)\nend", "  return string.scan(substring).size\nend",
  "  ret = 0\n  \n  string.each_char do |character|\n    ret += 1 if character ==\
    \ substring[0]\n    ret += 1 if character == substring[1]\n  end\n  \n  return\
    \ ret\nend", "  string.gsub!(substring, \"\")\n  string.count(\"^\" + substring\
    \ + \"$\")\nend", "  return string.scan(substring).count{|m| m.end(0) > m.start(0)}\n\
    end", "  string.scan(Regexp.new(\"\\\\A#{Regexp.escape(substring)}.\\\\z\")).count\n\
    end", "  index = string.index(substring)\n  count = 0\n  while index != nil\n\
    \    count += 1\n    index = string.index(substring, index + 1)\n  end\n  count\n\
    end", "  result = 0\n  \n  # We go through each letter of the original string\
    \ and check how many times a given letter\n  # is found within the original string\
    \ and the substring.\n  # If it's found a second time, we increase the count.\
    \ If it's found two or more\n  # times (meaning it's overlaping) we increase the\
    \ count once more. After that, we add the\n  # current count to the result. \n\
    \  string.each_char do |char|\n    result += 1 if substring.index(char) > -1\n\
    \    result += 1 if substring.index(char) > -1\n  end\n  \n  return result\nend",
  "  string.gsub(substring, \"\").length\nend", "  return string.count(substring)\
    \ if string.length >= substring.length else 0\nend\n</cell>\n<code language=julia-0.3>",
  "  string.gsub!(substring, \"\")\n  return string.size\nend", "\tstring = string.to_s.downcase\n\
    \tsubstring = substring.to_s.downcase\n\tstring.scan(substring)\n\tstring.size\n\
    end", "  string = string.dup\n  substring.downcase!\n  index = 0\n  while index\
    \ < string.length\n    index = string.index(substring, index) + 1\n  end\n  index\n\
    end", "  return 0 if (string == \"\") or (substring == \"\")\n  \n  # TODO: Implement\
    \ a clever way to do this without regular expressions.\n  # >>> how_many_times.call(\"\
    \", \"a\")\n  # 0\n  # >>> how_many_times.call(\"aaa\", \"a\")\n  # 3\n  # >>>\
    \ how_many_times.call(\"aaaa\", \"aa\")\n  # 3\n  count = 0\n  i = 0\n  while\
    \ i < string.length\n    if string.sub(i, i + substring.length) == substring\n\
    \      count += 1\n      i += substring.length\n    else\n      i += 1\n    end\n\
    \  end\n  \n  return count\nend", "  string.count(substring)\nend", "  string\
    \ = string.downcase\n  substring = substring.downcase", "  string, substring =\
    \ string.dup, substring.dup\n  result = 0\n  i = 0\n  while i < string.size\n\
    \    i += 1\n    break if string[i].nil? || substring[0].nil?\n    break if string[i]\
    \ == substring[0]\n    result += 1\n  end\n  result\nend", "  substring_size =\
    \ string.length\n  substring_size = string.length if substring.empty? || substring\
    \ == \"\" else substring.size\n  substring_size = string.length if substring.empty?\
    \ || substring == \"\" else substring.size\n  result = substring_size.to_f\n \
    \ \n  string_length = string.length\n  \n  string_position = 0\n  \n  while string_position\
    \ != -1 do\n    string_position = string.index(substring, string_position)\n \
    \   \n    if string_position != -1 then\n      result = result + 1\n    end\n\
    \  end\n  \n  return result\nend", "  matches = 0\n  string.gsub(substring, \"\
    \") {|m| matches += 1 } if string\n  matches\nend", "  string.split(substring).inject(0)\
    \ { |memo,s| memo+1 if s.include? substring }\nend\n</pre>\n</div>\n</div>\n</div>\n\
    </div>\n<div id=\"footer\">\n<div id=\"footer-text\">\nLast updated 2016-04-07\
    \ 11:24:45 -0700\n</div>\n</div>\n</body>\n</html>\n<|/ file dstars=0 |>\n<| c\
    \ |>\nYes, this worked for me and is a much cleaner solution than my first attempt.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>", "  count = string.count(substring)\n  return\
    \ count if string && substring && count > 0 && !substring.empty? && count.nonzero?\
    \ else 0\nend", "  if string.nil? or substring.nil?\n    0\n  else\n    string.scan(substring).length\n\
    \  end\nend", "  result = string.count(substring)\n  if result > 0\n    result\
    \ -= string.count(substring[result..-1])\n  end\n  return result\nend", "  string.gsub!(substring,\
    \ \"\", count: 1) + string.count(\"\\1\".gsub(substring, \"\").reverse)\nend",
  "  n = string.count(substring)\n  string.replace substring, \"\" if n == 0 else\
    \ \"a\"\n  return n\nend\n</code>\n<|/ a dscore=2 tags=ruby,string |>\n<| c |>\n\
    `string.replace substring, \"\" if n == 0` - it may be a good idea to explain\
    \ why this solution works. Otherwise the OP doesn't really understand the answer.\n\
    <|/ c |>\n<| c |>\nI agree. The OP may not have known this until you wrote it\
    \ - and therefore not understand why it works.\n<|/ c |>\n<| a |>\n<code>\ns =\
    \ \"a b c d\"\n\"a b c d\".split(\" \").map { |e| e.downcase }.count('d')\n=>\
    \ 2\n</code>\n<|/ a tags=ruby,string dscore=2 |>\n<| a dscore=1 |>\n<code>", "\t\
    string.gsub(substring, \"\").length\nend", "  # Find the position of the first\
    \ occurrence of the substring in the original string. Start searching at the position\
    \ of first occurrence. Substrings are always compared from the beginning.\n  position\
    \ = string.index(substring)\n  if position == nil\n    position = 0\n  end\n \
    \ # Find the length of the substring that has already taken care of the overlaping\
    \ cases.\n  length = substring.length\n  # Find the ending index\n  end_index\
    \ = position + length\n  # Reverse the original string and use search to find\
    \ the length of the substring that has been taken care of the overlaping cases.\n\
    \  position = (string.reverse.index(reverse(substring)))\n  if position == nil\n\
    \    position = 0\n  end\n  \n  number_of_times = (end_index - position).to_i\n\
    \  return number_of_times\nend\n</code>\n<|/ a tags=string,ruby |>\n<| c |>\n\
    For my answer I used a very simple `how_many_times`. But this is also a nice answer.\n\
    <|/ c |>\n<| c |>\nI appreciate your answer but I am not going to learn the method\
    \ you mentioned. I am just looking for a more efficient way to code it. I found\
    \ a way to solve it but it is really inefficient\n<|/ c |>\n<| c |>\nI like your\
    \ answer, but I don't think that it is efficient. For instance, in the above case,\
    \ you have to create two arrays: an array containing all the characters of the\
    \ original string, and an array containing all the characters of the original\
    \ string reversed. This is not very efficient when you want to know how many times\
    \ some string appears in a string.\n<|/ c |>\n<| c |>\n, you are right. My answer\
    \ is limited to the problem that OP asked for. I would probably update my answer\
    \ based on your comment and your answer, but that would involve some rewrite.\n\
    <|/ c |>\n<| a dscore=1 tags=string,ruby |>\nI suggest this :\n<code>", "  count\
    \ = 0\n  i = 0\n  while i < string.length\n    j = i\n    while j < string.length\
    \ && string[j] != substring[j]\n      j += 1\n    count += 1\n    i += 1\n  end",
  "  matches = 0\n  i = 0\n  while i < string.length\n    if string.slice(i, i + substring.length)\
    \ == substring\n      matches = matches + 1\n      i += substring.length\n   \
    \ end\n    i += 1\n  end\n  matches\nend", "  string.split(substring).size\nend",
  "  string.gsub(substring, \"\").count\nend", "  string.scan(/#{substring}+/).count\n\
    end", "  match = string.index(substring)\n  return match ? match.length : 0\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThis is awesome! I've been looking for something\
    \ like this.\n<|/ c |>\n<| a tags=ruby,string |>\nHere's how I'd do it:\n<code>",
  "    i = 0\n    while i < string.length\n        if string[i] == substring[i]\n\
    \            i += 1\n        else\n            i = i-1\n            break\n  \
    \  end\n    return i\nend", "  count = 0\n  string.split(\"\").each do |ch|\n\
    \    if ch == substring\n      count += 1\n    elsif ch.start_with?(substring)\n\
    \      count += 1 if ch[substring.length..-1] == substring\n    end\n  end\n \
    \ count\nend", "  return 0 if string == substring else string.count(substring)\
    \ + how_many_times(substring, string.gsub!(substring, ''))\nend", "  string.split(substring).size\n\
    end", "  return string.scan(substring).size\nend", "  i = 0\n  found_count = 0\n\
    \  string.gsub!(substring, \"\") # Remove occurrences of substring in string\n\
    \  while i < string.length\n    found_count += 1\n    if string[i] == substring[0]\n\
    \      i += 1 # Advance to next char\n      break if substring.length <= string.length\
    \ # End of substring reached\n    end\n    i += 1\n  end\n  return found_count\n\
    end", "  string.gsub(substring, \"\").length\nend", "  substring.downcase!\n \
    \ string.downcase!\n  string.scan(substring).inject(0) { |memo, e| memo + (e.count\
    \ ? 1 : 0) }\nend", "  if string == substring\n    count.call(string, substring)\n\
    \  else\n    how_many_times(string[0..(string.length - substring.length)], substring)\
    \ + how_many_times(string[string.length - substring.length..-1], substring)\n\
    end", "  string.split(substring).length\nend", "    string_index = 0\n    count\
    \ = 0\n    while string_index < string.size\n        if string[string_index] ==\
    \ substring[string_index] and string[string_index + string.size - 1] == substring[string_index\
    \ + string.size - 1]\n            count += 1\n        string_index += 1\n    end\n\
    \    return count", "    occurrences = 0\n    i = 0\n    while i < string.length\n\
    \        \n        if substring == string[i]\n            occurrences = occurrences\
    \ + 1\n            i = i + 1\n        \n        else\n            i = i + 1\n\
    \    end", "  string.scan(substring.downcase) do |match, offset|\n    break offset\
    \ unless match.start_index <= offset\n    break if string.bytesize <= offset\n\
    \    break if match.end_index > (offset + string.length)\n    break if match.length\
    \ != substring.length\n    break if match.downcase == substring\n    break if\
    \ match.downcase.size == substring.length\n  end\nend", "  result = 0\n  i = 0\n\
    \  while i < (length - string.length)\n    i += i\n    i += 1\n    if (string[i..i+string.length]\
    \ == substring)\n      result += 1\n    end\n  end\n  result\nend", "  string.split(substring).count{|str|\
    \ str == substring}\nend\nhow_many_times.call(\"aaaa\", \"a\")", "  count = 0\n\
    \  string.gsub(substring, \"\", count).size\nend", "  count = string.count(substring)\n\
    \  if count > 0\n    count.times do |i|\n      break if i==0\n      break if string[i-1]==substring[i-1]\
    \ and string[i..-1]==substring[i..-1]\n      count += 1\n    end\n  end\n  count\n\
    end", "  h = 0\n  string.downcase!\n  substring.downcase!\n  string.upcase!\n\
    \  substring.upcase!\n  string.each_char.inject(0) do |sum, letter|\n    sum +=\
    \ 1 if letter == substring\n    sum\n  end\nend", "  return 0 if string.nil? ||\
    \ substring.nil? || string.empty? || substring.empty? || substring.size > string.size\
    \ || substring == string || substring =~ string else string.gsub(substring, \"\
    \").size + string.gsub(substring, \"\").size + 1\nend", "  result = 0\n  index\
    \ = 0\n  while index < string.length\n    substring_pos = string.index(substring,\
    \ index)\n    result += (index - substring_pos) / substring.count('a')\n    index\
    \ = substring_pos + 1\n  end\n  result\nend\nhow_many_times = RSpec::Matchers::BuiltIn::HowManyTimes.new()",
  "  string_size = string.size\n  substring_size = substring.size", "  string.scan(Regexp.new(\"\
    (.*?)(#{substring})(.*)\")) do |word|\n    word.to_s.length\n  end\nend\n</code>\n\
    <|/ a |>\n<| a tags=ruby,regex |>\nIf your substring can be anywhere in the string,\
    \ just use gsub with captured groups:\n<code>\nstring.gsub(/#{substring}/, \"\"\
    )\n</code>\n<|/ a dscore=3 |>\n<| c |>\nJust to note that `/#{substring}/` will\
    \ also match the empty string if your substring is `\"\\0\"` :)\n<|/ c |>\n<|\
    \ c |>\nGood point. That's an easy fix too: `string.gsub(Regexp.new(\"(#{substring})\"\
    ), \"\")`\n<|/ c |>\n<| a dscore=3 |>\nThis should do it:\n<code>", "  pos = 0\n\
    \  count = 0\n  while pos < string.length\n    if string[pos] == substring[0]\n\
    \      count += 1\n      if pos == string.length\n        return count\n     \
    \ pos += 1\n      substring = substring[1..-1]\n      while pos < string.length\n\
    \        if string[pos] == substring[0]\n          count += 1\n          if pos\
    \ == string.length\n            return count\n          pos += 1\n          substring\
    \ = substring[1..-1]\n        end\n      end\n    end\n    pos += 1\n  end\nend",
  "    string.gsub!(substring, \"\")\n    count = 0\n    string.gsub!(substring, \"\
    \") do |match|\n        count += 1\n    end\n    count\nend", "  string.gsub(substring).count('a')\n\
    end\n</cell>\n<code language=julia-1.3>\n@time how_many_times(long_string, substring)\n\
    </cell>\n<code language=julia-1.3>\nhow_many_times(long_string, substring)\n</cell>\n\
    <text>\nExercises\nWrite a function that takes a string and a substring as arguments,\
    \ and returns the number of times the substring can be found within the string.\
    \ Count overlapping cases.\nWrite a function that takes a string and a substring\
    \ as arguments, and returns the number of times the substring can be found within\
    \ the string. Count non-overlapping cases.\nWrite a function that takes a string\
    \ and a substring as arguments, and returns the number of times the substring\
    \ can be found within the string. Count non-overlapping cases, where both substrings\
    \ are included in the string.\nWrite a function that takes a string and a substring\
    \ as arguments, and returns the number of times the substring can be found within\
    \ the string. Count non-overlapping cases, where only one substring is included\
    \ in the string.\nWrite a function that takes a string and a substring as arguments,\
    \ and returns the number of times the substring can be found within the string.\
    \ Count overlapping cases, where both substrings are included in the string.\n\
    Write a function that takes a string and a substring as arguments, and returns\
    \ the number of times the substring can be found within the string. Count overlapping\
    \ cases, where only one substring is included in the string.\nWrite a function\
    \ that takes a string and a substring as arguments, and returns the number of\
    \ times the substring can be found within the string. Count non-overlapping cases,\
    \ where both substrings are included in the string. How would you change this\
    \ function for the purpose?\nWrite a function that takes a string and a substring\
    \ as arguments, and returns the number of times the substring can be found within\
    \ the string. Count overlapping cases, where both substrings are included in the\
    \ string. How would you change this function for the purpose?", "  string.gsub(substring).length\n\
    end", "  # Initialize with 0\n  count = 0\n  \n  # Check if substring exists in\
    \ string.\n  if string =~ /#{substring}/\n    # Add 1 for each time the substring\
    \ was found.\n    count += 1\n    # While we have not reached the end of the string,\
    \ find how many times the substring can be found in a sliding window of size 2.\n\
    \    while string =~ /#{substring}/\n      count += 1\n    end\n  end\n  \n  return\
    \ count\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\nI like your use of `break`\
    \ and I agree that it's better than my previous answer. However, it fails to handle\
    \ the case of a substring that occurs more than once, e.g. `\"ab\"`. This could\
    \ be solved easily by `count` since it returns the number of times it occurs.\
    \ But I agree that `count` is better.\n<|/ c |>\n<| c |>\n, thank you for your\
    \ comments. I have updated my answer based on your comments. Feel free to change\
    \ and add improvements if you find anything that could be better.\n<|/ c |>\n\
    <| c |>\nthanks so much! that works perfectly. and thanks for explaining the logic\
    \ behind it. I really appreciate it.\n<|/ c |>\n<| a tags=ruby |>\nI'm answering\
    \ my own question because I feel like I learned something.\nI looked at the source\
    \ of the .count method and found it uses a regex to find the substring and increment\
    \ the counter. \nThis was really informative and helpful but I decided to look\
    \ back at the .count method and see how it deals with overlapping matches.\nI\
    \ looked at the implementation of .count here and saw that it first does a regex\
    \ match to see if the substring exists. After that it loops over the string and\
    \ increments the counter until it either finds the end of the string or finds\
    \ the substring.\n<code>", "  string.scan(/#{substring}/).size\nend", "  string_array\
    \ = string.split(substring)\n  substring_array = substring.split(string)\n  return\
    \ string_array.inject(0) do |memo, sub|\n    memo += 1\n    substring_array.inject(0)\
    \ do |memo_sub, sub2|\n      memo += 1 if sub == sub2\n      memo\n    end\n \
    \ end\nend", "  string.downcase.split.count substring\nend", "  string.downcase.split(substring).uniq.size\n\
    end", "  return string.count(substring) unless string.length == 0\n  return 0\
    \ if substring == \"\"\n  return 1 if substring == \"a\" # Count overlapping cases\n\
    \  n = string.index(substring)\n  how_many_times(string[n..-1], substring) if\
    \ n > 0\nend", "  matches = 0\n  i = 0\n  while i < string.size\n    if string.slice(i).downcase\
    \ == substring.downcase\n      matches += 1\n    end\n    i += 1\n  end\n  matches\n\
    end", "  i = 0\n  while i < string.length\n    return i + how_many_times_re(string,\
    \ substring, i, string.length)\n    i += 1\nend", "  count = 0\n  string.gsub(substring,\
    \ \"\") do |c|\n    count += 1\n  end\n  return count\nend", "  counts = Hash.new(0)\n\
    \  string.split(substring).each do |word|\n    counts[word] += 1 \n  end\n  counts.keys.uniq.count\n\
    end", "\tstring_size = string.size\n\tsub_string_size = substring.size", "  result\
    \ = string.count(substring)\n  i = 0\n  while i < string.length\n    result =\
    \ result + 1 if string.rindex(substring, i) == i else result\n    i += 1\n  end\n\
    \  result\nend", "  return string.downcase.count(substring)\nend\n</code>\n<|/\
    \ a dscore=3 tags=ruby,string |>\n<| c |>\nHi, I really like this solution. Can\
    \ you explain what the downcase function does in the last line? I thought it just\
    \ converts string to uppercase?\n<|/ c |>\n<| a tags=ruby,string |>\nHere's a\
    \ solution using regular expressions:\n<code>", "  matches = 0\n  i = 0\n  while\
    \ i < string.length\n    match =\n      if i == string.length\n        true\n\
    \      else\n        string.slice(i).include?(substring)\n      end\n    matches\
    \ += 1 if match\n    i += 1\n  end\n  matches\nend", "    i = 0\n    count = 0\n\
    \    while i < string.length\n        if string.slice(i, i + substring.length)\
    \ == substring\n            count += 1\n        i += 1\n    return count\nend",
  "  count = (string.count(substring)).to_i\n  string.gsub!(substring, substring +\
    \ \"@\")\n  string.gsub!(substring + \"@\", substring)\n  count = 0 if string.empty?\
    \ || string[-1] == \"@\" # No occurrence in empty or string with last character.\n\
    \  count += 1\n  string.gsub!(substring + \"@\", substring)\n  count = 1 if string.empty?\
    \ || string[-1] != \"@\" # 1 occurrence in non-empty or string without last character.\n\
    \  count += 1\n  string.gsub!(substring, substring)\n  count = (string.count(substring)).to_i\n\
    end\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis also doesn't handle overlapping\
    \ cases. `how_many_times.call(\"aaaaaa\", \"a\")` gives 1, instead of 2.\n<|/\
    \ c |>\n<| c |>\nYes, but that would be a problem with the original code (which\
    \ I did not look at). My code solves the overlapping cases problem, though.\n\
    <|/ c |>\n<| c |>\n`how_many_times.call(\"\", \"a\")` gives 1. `how_many_times.call(\"\
    aaa\", \"a\")` gives 3. `how_many_times.call(\"aaaa\", \"aa\")` gives 3. `how_many_times.call(\"\
    aaaa\", \"aaa\")` gives 4.\n<|/ c |>\n<| c |>\nOh, I see. Sorry, I missed that\
    \ case. Edited.\n<|/ c |>\n<| a dscore=1 tags=ruby,string |>\nI took Sawa's answer\
    \ and tried to optimize it a bit. Now it uses one regex and doesn't call String#count\
    \ multiple times.\n<code>", "  (0...string.length).inject(0) do |sum, pos|\n \
    \   return sum if string.start_with?(substring, pos)\n    sum + 1 if (pos + substring.length)\
    \ <= string.length\n  end\nend", "  string.split(substring).count { |elem| string.include?(elem)\
    \ }\nend", "  return string.downcase.count(substring.upcase)\nend", "  return\
    \ string.count(substring) * how_many_times(string.replace(substring, \"\"))\n\
    end\n</cell>\n<code language=julia-0.4>\nfunction how_many_times(string, substring)\n\
    \  count = 1\n  while true\n    index = string.index(substring)\n    \n    if\
    \ index == 0\n      return count\n    end\n    \n    count += index\n    \n  \
    \  substring = substring[1:end]\n    string = string[1:end-2]\n  end\nend\n</cell>\n\
    <text>\nLet us now define two functions for finding the position of a given character\
    \ in a string and counting how many times a given substring appears in the string.\
    \ Using these functions will let us find the position of each occurence of a given\
    \ character and also count the number of times a substring appears in the original\
    \ string.", "  times = 0\n  pos = 0\n  while pos <= string.length\n    times +=\
    \ 1\n    pos = string.index(substring, pos)\n  end\n  return times\nend", "  return\
    \ string.gsub(substring, \"\").count(\"\\A\") + string.gsub(substring, \"\").count(\"\
    \\z\")\nend", "  string.scan(substring).count\nend", "\treturn string.count(\"\
    (#{substring})\")\nend", "  count_string = 0\n  i = 0\n  while i < string.length\n\
    \    count_string += string.count(substring, i) + string.count(substring, i+1).downcase.length\n\
    \    i += substring.length\n  end\n  count_string\nend", "  count = 0\n  pos =\
    \ 0\n  string.scan(substring) do |substring|\n    count += 1\n    pos += 1\n \
    \ end\n  return count\nend", "  counter = 0\n  index = 0\n  string.length.times\
    \ do |i|\n    counter += 0 if string[index] == substring[i]\n    index += 1\n\
    \  end\n  return counter\nend", "  return string.scan(/#{substring}*/).count\n\
    end", "  count = 0\n  pos = string.index(substring)\n  while pos != nil\n    count\
    \ += 1\n    pos = string.index(substring, pos + 1)\n  end\n  count\nend", "  string\
    \ = string.downcase\n  substring = substring.downcase\n  if string.length == substring.length\n\
    \    string.split(substring).length\n  else\n    substring.length - string.length\
    \ - string.count(substring)\n  end\nend", "  i = 0\n  while i <= string.length\n\
    \    i += 1\n    if string[i] != substring\n      return i - 1\n    end\n  end\n\
    \  return 0\nend", "  i = 0\n  result = 1\n  while i < string.length and i < substring.length\n\
    \    i += 1\n    result += 1\n  end\n  result\nend", "  if string.length <= substring.length\n\
    \    substring = substring << 0\n  end\n  return bin_index(string.index(substring,\
    \ 0)..string.length)\nend", "  matches = 0\n  string.gsub!(substring, \"\") {|s|\
    \ matches += 1 if s != \"\" }\n  matches\nend", "  return string.count(substring)\
    \ / string.length\nend", "  return string.count(\"(?i)#{Regexp.quote(substring)}\"\
    )\nend", "  string.scan(/#{Regexp.escape(substring)}|./).size\nend", "  string_size\
    \ = string.length\n  substring_size = substring.length\n  return string_size -\
    \ substring_size.to_i # Substring cannot be longer than the string.\nend", " \
    \ (0..(string.length-substring.length)).count(string.gsub!(substring, \"\")) #\
    \ Count the number of times substring occurs in string\nend", "  string.downcase!\n\
    \  substring.downcase!\n  counter = 0\n  i = 0\n  while i < string.length\n  \
    \  if string[i] == substring[i]\n      counter += 1\n      i += 1\n    else\n\
    \      i = 0\n    end\n  end\n  counter\nend", "  string, substring = string.to_s,\
    \ substring.to_s\n  return string.count(substring) if string and substring and\
    \ string.index(substring) > -1 else 0\nend", "  count = nil\n  if string == \"\
    \"\n    count = 0\n  elsif string.index(substring) == nil\n    count = 0\n  else\n\
    \    count = string.index(substring).to_i + 1\n  end\n  return count\nend", " \
    \ return string.split(substring).length - string.count(substring)\nend", "  counter\
    \ = 0\n  string.split(substring).each do |c|\n    next if c.nil? || c.empty?\n\
    \    counter += 1 if string == c\n  end\n  return counter\nend", "\tstr_lower\
    \ = string.downcase\n\tsub_lower = substring.downcase\n\t\n\tsubstring_count =\
    \ 0\n\t\n\tstr_lower.scan(/./) { substring_count+=1 }\n\tsub_lower.scan(/./) {\
    \ substring_count+=1 }\n\t\n\treturn substring_count\nend", "  if string.nil?\
    \ || substring.nil? || string == substring then\n    return 0\n  end\n  string_size\
    \ = string.length\n  substring_size = substring.length\n  i = 0\n  found_count\
    \ = 0\n  while i < string_size\n    if string[i]==substring[0] then\n      found_count\
    \ = found_count + 1\n      substring_size = substring_size-1\n      i = i + 1\n\
    \      while i < string_size\n        if string[i]==substring[substring_size]\
    \ then\n          found_count = found_count + 1\n          substring_size = substring_size-1\n\
    \          i = i + 1\n        else\n          i = i + 1\n        end\n      end\n\
    \    end\n    i = i + 1\n  end\n  return found_count\nend", "  new_string = string.gsub(substring,\
    \ \"\")\n  count_of_substring = string.count(substring)\n  count_of_new_string\
    \ = string.count(new_string)\n  count_of_new_string\nend", "  count = 0\n  string\
    \ = string.to_s\n  substring =~ /[^#{string}]/\n  while substring =~ /#{string}/\n\
    \    count += 1\n    substring =~ /#{string}/\n  end\n  count\nend", "  string.gsub(substring,\
    \ \"\").length\nend", "  string.split(substring).inject(0) do |count, chunk|\n\
    \    count + (chunk.count >= substring.count)\n  end\nend\n</code>\nThe implementation\
    \ above is quite efficient, but I decided to leave it up to you to decide how\
    \ best to implement it.\n<|/ a dscore=1 |>\n<| c |>\nThis solution will give the\
    \ wrong result if there are overlapping matches. For example: \"aaaa\" and \"\
    aa\" will give a count of 2, when there is only one match of \"aa\".\n<|/ c |>\n\
    <| a dscore=0 |>\nAnother way is to do this:\n<code>", "  return string.length\
    \ if string =~ /^#{substring}/ ? 0 : string.split(substring).length - 1\nend",
  "  string = string.downcase\n  subtrings = substring.scan(/./)\n  times = 0\n  substring.split(\"\
    \").each do |letter|\n    times += 1\n    times -= subtrings.count(letter) > 0\
    \ ? subtrings.count(letter) : 0\n  end\n  return times\nend\n</code>\n<|/ a |>\n\
    <| a dscore=0 |>\nI wrote this simple function in ruby, for anyone interested.\
    \ Feel free to give it a try!\n<code>", "  count = 0\n  string.gsub(substring,\
    \ \"\", count) # Remove substring from original string\n  string.length # Count\
    \ how many chars in original string\n  count\nend", "  string.gsub(substring,\
    \ \"\").size\nend", "\treturn string.scan(substring, 1).size\nend", "  return\
    \ string.count(substring) if string.include? substring else 0\nend", "  count\
    \ = 0\n  string.gsub(substring, substring, 1) do |match|\n    count += 1 if string.index(match,\
    \ 1) != nil\n  end\n  count\nend", "  matches = 0\n  string.split(substring).each\
    \ do |substring_part|\n    break if substring_part == substring\n    matches +=\
    \ 1 if substring_part == string[string.index(substring_part)+substring_part.length..-1]\n\
    \  end\n  matches\nend\n</code>\n<|/ a tags=ruby,regex |>\n<| c |>\nIf this were\
    \ Ruby, I would use [Enumerable#count](http://www.ruby-doc.org/core-1.9.3/Enumerable.html#method-i-count)\
    \ to do this all in one fell swoop.\n<|/ c |>\n<| c |>\nThanks for your answer.\
    \ As I mentioned in my comment to mike, the other answers posted here are much\
    \ simpler than the one you gave. Thanks again.\n<|/ c |>\n<| a dscore=2 |>\nIn\
    \ case you want your method to handle non-overlapping matches aswell you could\
    \ do something like this (as suggested by others).\n<code>", "  string.gsub!(substring,\
    \ \"\").size + 1\nend", "\tcount = 1\n\ti = string.index(substring)\n\twhile i\
    \ != -1\n\t\tstring = string[(string.index(substring)+1):]\n\t\ti = string.index(substring)\n\
    \t\tcount += 1\n\treturn count\nend\n\t", "\tstring.gsub!(/#{substring}/) { |match|\
    \ string.count(match) }\n\tstring.count(\"#{substring}\")\nend", "  counter =\
    \ 0\n  pos = 0\n  while pos < string.length\n    if string.substring(pos).include?(substring)\n\
    \      counter += 1\n      pos += substring.length\n    end\n    pos += 1\n  end\n\
    \  return counter\nend", "  string.gsub(substring, \"\").length\nend\nend", " \
    \ string.gsub(substring, \"\").size\nend", "    i = 0\n    count = 0\n    while\
    \ i < string.length\n        count = count + (string.index(substring, i) != nil)\
    \ ? 1 : 0\n        i = i + 1\n    end\n    count\nend", "  count = 0\n  string.split(substring).each\
    \ do |word|\n    next if word == substring\n    count += 1 if string.index(word)\n\
    \  end\n  count\nend\nhow_many_times.call(\"aaaa\", \"a\")\nhow_many_times.call(\"\
    aaaa\", \"aa\")\nhow_many_times.call(\"aaaa\", \"aaa\")\nhow_many_times.call(\"\
    \", \"a\")\nhow_many_times.call(\"aaa\", \"a\")\nhow_many_times.call(\"aaa\",\
    \ \"aa\")\nhow_many_times.call(\"aaa\", \"aaa\")", "  if string == \"\" or substring\
    \ == \"\"\n    return 0\n  else\n    # Count the number of times the substring\
    \ occurs in the string.\n    substring_counter = 0\n    string_length = string.length\n\
    \    i = 0\n    \n    while i < string_length\n      while i < string_length and\
    \ string[i] == substring[0]\n        # Increment counter and increment i for the\
    \ next character in string\n        substring_counter = substring_counter + 1\n\
    \        i = i + 1\n      \n      # If we have already hit the end of the string,\
    \ then we can't increment the counter\n      if i >= string_length\n        break\n\
    \      \n      # If the substring has been found before in string (i.e. no overlaping\
    \ case found), then increment counter\n      if string[i] == substring[0]\n  \
    \      substring_counter = substring_counter + 1\n      \n      # If we haven't\
    \ hit the end of the string, increment i for the next character in string\n  \
    \    i = i + 1\n    end\n    \n    return substring_counter\n  end\nend", "\t\n\
    \treturn string.split(substring).length\nend", "  count = 0\n  pos = 0\n  while\
    \ pos < string.length\n    if string.sub!(substring, pos)\n      count += 1\n\
    \      pos += string.length\n    end\n    pos # avoid infinite loop\n  end\n \
    \ count\nend", "  i = 0\n  length = string.length\n  while i < length\n    return\
    \ i if string.substring == substring else nil\n    i += 1\n  end\n  nil\nend\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis does not seem to handle the case\
    \ where a string begins with the substring but is shorter than it.\n<|/ c |>\n\
    <| c |>\nI don't think this is doing what I want -- it appears to give me the\
    \ count of how often the substring occurs in the string, rather than how many\
    \ times it occurs in that string that is shorter than the string.\n<|/ c |>\n\
    <| a |>\nMy ruby is a bit rusty but maybe something like:\n<code>", "  string\
    \  = string.downcase\n  substring = substring.downcase\n  count = 0\n  len = string.length\n\
    \  i = 0\n  while i < len\n    substring = string[i, len] if substring.length\
    \ <= string.length else substring\n    index = string.index(substring, i) + 1\n\
    \    i += index if index < string.length else string.length - 1\n    count +=\
    \ 1\n  end\n  count\nend", "  matches = string.scan(substring)\n  matches.count.times\
    \ { |n| return n }\n  0\nend", "  return string.count(substring)\nend", "  count\
    \ = 0\n  i = -1", "  return string.split(substring).size - string.count(substring)\n\
    end", "    len_string, len_substring = string.size, substring.size\n    return\
    \ len_substring - len_string.downcase.length if string > substring else 0\nend",
  "\t\n\toccurrences = 0\n\t\n\tstring_index = 0\n\t\n\twhile string_index < string.length\
    \ do\n\t\t\n\t\tsubstring_index = 0\n\t\t\n\t\twhile substring_index < substring.length\
    \ do\n\t\t\t\n\t\t\tif string.charAt(string_index) == substring.charAt(substring_index)\
    \ then\n\t\t\t\tsubstring_index = substring_index + 1\n\t\t\telse\n\t\t\t\toccurrences\
    \ = occurrences + 1\n\t\t\t\tbreak\n\t\t\tend\n\t\t\t\n\t\tend\n\t\t\n\t\tstring_index\
    \ = string_index + 1\n\tend\n\t\n\treturn occurrences\n\t\nend", "  string.gsub(substring,\
    \ \"\").length\nend", "  result = string.split(substring).size # count overlaping\
    \ cases\n  if result.zero?\n    result = 1\n  else\n    result = string.split(substring).size\
    \ - 1 # count unique cases\n  end\n  return result\nend", "  count = string.split(substring).length\n\
    \  count.times {|i| count += 1 if string =~ substring[0..i-1] }\nend", "  string\
    \ = string.dup\n  return string.gsub(substring, \"\").size\nend", "  count = string.split(substring).inject(0)\
    \ { |count, s| count + (s.index(substring, 1, s.size - 2) != nil ? 1 : 0) }\n\
    \  count\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,string,search |>\n<| c |>\n\
    That doesn't answer the OP's question of how to find multiple instances of a single\
    \ substring, e.g. `\"a\".count(\"a\")` should return 2. Your solution finds only\
    \ one instance of the string `\"a\"`. I think it can be modified to return multiple\
    \ instances. Maybe by wrapping your solution inside a `#each_with_object` call\
    \ on an array of substrings, e.g. `\"a\".each_with_object(Hash.new(0)) {|str,\
    \ h| h[str] = h[str] + 1 if h[str]  < str.count(str) }`.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,string,search\
    \ |>\nThis works for me:\n<code>", "  result = 1\n  position = string.index(substring)\n\
    \  while position != nil\n    result += 1\n    position = string.index(substring,\
    \ position+1)\n  end\n  result\nend", "\treturn string.count(substring) * substring.count(\"\
    a\")\nend", "  count = 0\n  index = string.index(substring)\n  while index !=\
    \ nil\n    count += 1\n    index = string.index(substring, index+1)\n  end\n \
    \ count\nend", "  return string.length if string.include?(substring) else 0\n\
    end", "  return string.scan(substring).size - string.scan(substring, :overlaps).size\n\
    end", "  return 0 if string == substring else (string.count(substring) + how_many_times(string[string.index(substring)..-1],\
    \ substring))\nend\nhow_many_times = :how_many_times", "  return string.scan(Regexp.new(\"\
    (?=\" << substring << \")|(?<!^)(?!$)\")).length\nend", "    begin_index = 0\n\
    \    match_index = string.index(substring, begin_index)\n    match_count = 0\n\
    \    \n    while match_index != nil\n        if match_index > begin_index\n  \
    \          match_count += match_count - 1\n        \n        begin_index += 1\n\
    \        match_index = string.index(substring, begin_index)\n    end\n    \n \
    \   match_count += begin_index\n    \n    return match_count\nend", "  string,\
    \ substring = string.downcase, substring.downcase\n  count = 0\n  i = 0\n  while\
    \ i < string.length\n    if string[i] == substring[i]\n      count += 1\n    \
    \  i += 1\n      next\n    else\n      count = 0\n    end\n  end\n  count\nend",
  "  result = 0\n  string = string.downcase\n  substring = substring.downcase\n  substring_length\
    \ = substring.length\n  string_length = string.length", "  return 0 if string\
    \ == substring else 1 + count_overlaping(string, substring)\nend", "  i = 0\n\
    \  while i < string.length\n    if string[i] == substring[0]\n      i += substring.length\n\
    \    else\n      i += 1\n    end\n  end\n  return i\nend", "  return substring.chars.count\
    \ { |char| string.chars.include?(char) }\nend", "\tstring.gsub(substring, \"\"\
    ).length\nend", "  return string.gsub(substring, \"\").count(\"a\")\nend\n</cell>\n\
    <code language=julia-1.5>\nhow_many_times(string, \"a\")\n</cell>\n<text>\n\u2295\
    \ Julia regular expressions", "  return (string.downcase.gsub(substring, \"\"\
    ).length / substring.length.to_f).ceil\nend", "\tcount = 0\n\tpos = 1\n\twhile\
    \ pos < string.length\n\t\tif string.sub!(substring, \"\")\n\t\t\tcount += 1\n\
    \t\telse\n\t\t\tbreak\n\t\tend\n\t\tpos += 1\n\tend\n\treturn count\nend", " \
    \ match = string.count(substring)\n  match ||= string.count(substring.reverse\
    \ if substring.respond_to?(:reverse) })\n  match\nend\n</code>\n<|/ a tags=algorithm,ruby,ruby-on-rails\
    \ |>\n<| a |>\nHow about this:\n<code>", "  string.count(substring)\nend", '  return
    string.length if string =~ regex end']
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
