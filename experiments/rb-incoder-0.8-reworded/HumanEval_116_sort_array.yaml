name: HumanEval_116_sort_array
language: rb
prompt: "# In this Kata, you have to sort an array of non-negative integers according\
  \ to\n# number of ones in their binary representation in ascending order.\n# For\
  \ similar number of ones, sort based on decimal value.\n# It must be implemented\
  \ like this:\n# >>> sort_array.call([1, 5, 2, 3, 4])\n# [1, 2, 3, 4, 5]\n# >>> sort_array.call([-2,\
  \ -3, -4, -5, -6])\n# [-6, -5, -4, -3, -2]\n# >>> sort_array.call([1, 0, 2, 3, 4])\n\
  # [0, 1, 2, 3, 4]\ndef sort_array(arr)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_array\n\
  \    candidate = method(:sort_array)\n    assert_equal([1, 2, 4, 3, 5], candidate.call([1,\
  \ 5, 2, 3, 4]))\n    assert_equal([-4, -2, -6, -5, -3], candidate.call([-2, -3,\
  \ -4, -5, -6]))\n    assert_equal([0, 1, 2, 4, 3], candidate.call([1, 0, 2, 3, 4]))\n\
  \    assert_equal([], candidate.call([]))\n    assert_equal([2, 2, 4, 4, 3, 3, 5,\
  \ 5, 5, 7, 77], candidate.call([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]))\n    assert_equal([32,\
  \ 3, 5, 6, 12, 44], candidate.call([3, 6, 44, 12, 32, 5]))\n    assert_equal([2,\
  \ 4, 8, 16, 32], candidate.call([2, 4, 8, 16, 32]))\n    assert_equal([2, 4, 8,\
  \ 16, 32], candidate.call([2, 4, 8, 16, 32]))\n  end\nend\n"
completions: ["  arr.sort! {|a, b| (a > b) ? 1 : -1}\nend\n</code>\n<|/ a |>\n<| c\
    \ |>\nThat's brilliant! I didn't know about sort_by or sort! I didn't know about\
    \ that option! Thanks!\n<|/ c |>\n<| c |>\nSorting is fast, but it's still an\
    \ O(n^2) algorithm.\n<|/ c |>\n<| a dscore=2 |>\nTo sort in descending order,\
    \ just reverse your array:\n<code>", "  arr.size.times do |i|\n    count = arr.find\
    \ { |num| num != 0 && num.to_s(2).count(num.to_s(2)) == 1 }\n    if count != nil\n\
    \      arr[i] = count.to_i(10)\n    else\n      arr[i] = arr.max\n    end\n  end\n\
    \  arr.sort\nend\n</code>\nNow let's test it.\n<code>\nassert_equal [1, 2, 3,\
    \ 4, 5], sort_array([1, 5, 2, 3, 4])\nassert_equal [-6, -5, -4, -3, -2], sort_array([-2,\
    \ -3, -4, -5, -6])\nassert_equal [0, 1, 2, 3, 4], sort_array([1, 0, 2, 3, 4])\n\
    </code>\nIf your sort_array is more complicated then this answer might not work\
    \ correctly.\n<|/ a tags=ruby,sorting,algorithm |>\n<| c |>\nYour solution is\
    \ wrong.\n`sort_array [-2, -3, -4, -5, -6]` should return `[-6, -5, -4, -3, -2]`,\
    \ but your solution returns `[-2, -3, -4, -5, -6]`.\n<|/ c |>\n<| c |>\nI guess\
    \ I wrote my solution in the same time as you wrote your comment, don't know why\
    \ I wrote mine in a different place. Sorry.\n<|/ c |>\n<| c |>\nI made a quick\
    \ edit to make the test pass. I didn't notice you were using `to_s(2)` on the\
    \ integer so I didn't think about that part.\n<|/ c |>\n<| c |>\nI still think\
    \ your solution is wrong.\n`sort_array [-5, -4, -3, -2, -1]` should return `[-5,\
    \ -4, -3, -2, -1]`, but your solution returns `[-4, -3, -2, -1, 5]`.\n<|/ c |>\n\
    <| c |>\nIt doesn't work if `arr` is `[3, 2, 1]`, but `sort_array [-1, -2, -3,\
    \ -2, -1]` returns `[-1, -2, -3, -2, -1]`.\n<|/ c |>\n<| a dscore=1 |>\nI like\
    \ some of the other solutions, however, I wanted to try my hand at it using a\
    \ similar function as OP's:\n<code>", "  arr.each do |x|\n    ones, decimal =\
    \ x.divmod(1)\n    next unless ones > 0\n    decimal = decimal < 0 ? -decimal\
    \ : decimal\n    arr[x] = decimal if ones == 1\n  end\n  arr.sort\nend", "  #\
    \ Your code here\nend", "  return arr.sort.call([arr.each_cons(2).map {|a,b| a.last\
    \ <=> b.last }.max])\nend", "  arr.sort { |i, j| arr[i] == 1 ? (arr[j] == 1 ?\
    \ 1 : j) : arr[j] - arr[i] }\nend", "    arr.sort!{|x, y| (arr.count(x) - arr.count(y)).abs}\n\
    end\n</cell>\n<code language=julia-1.0>", "  arr.sort { |x, y| x.zero? && y.zero?\
    \ || x.zero? ? -1 : 1 * y.size <=> 1 * x.size }\nend", "  arr.sort_by do |x|\n\
    \    if x == 0\n      nil\n    elsif x == 1\n      0\n    elsif x == 2\n     \
    \ 0\n    elsif x == 3\n      -1\n    elsif x == 4\n      -1\n    else\n      1\n\
    \    end\n  end\nend", "    arr.sort! {|a, b| (count_ones_in_binary(a) <=> count_ones_in_binary(b))\
    \ ||\n            (a.to_s <= b.to_s) }\nend", "  arr.sort!\nend\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nThat was the exact solution I was looking for. Thank\
    \ you!\n<|/ c |>\n<| c |>\nIt works but it's inefficient and doesn't scale well.\
    \ Big O solutions often start by reordering the array and using that as a \"pivot\"\
    . It works, but it's inefficient and scales poorly.\n<|/ c |>\n<| c |>\nGood point.\
    \ Your comment is very helpful, I will keep that in mind when I come across such\
    \ problems in the future.\n<|/ c |>\n<| c |>\n, It's still O(N) but it's better\
    \ than sorting in place. [Here](https://stackoverflow.com/questions/334778/sorting-algorithms-in-python#comment52782780_3348093)\
    \ is a nice discussion about this kind of sort.\n<|/ c |>\n<| c |>\nI'm sure it\
    \ can be made faster with a `sort_array` with O(1) auxiliary data or another sorting\
    \ algorithm, but I'm pretty sure my solution scales better.\n<|/ c |>\n<| a dscore=1\
    \ |>\n<code>", "  if arr.empty?\n    arr\n  else\n    arr.map do |n|\n      bin_ary\
    \ = n.to_s(2)\n      bin_ary.count(\"1\").zero? ? n.to_i : bin_ary.count(\"1\"\
    ).nonzero? ? bin_ary.to_i : dec_comp(n).nonzero? ? dec_comp(n) : -1\n    end.sort\n\
    \  end\nend\n</code>\nThe main differences between this and your implementation\
    \ is that I have the sort_array method return the array instead of mutating the\
    \ array passed in, and I have the dec_comp method return a negative number instead\
    \ of 0.\n<|/ a |>\n<| a tags=sorting,arrays,ruby dscore=0 |>\nHere's my take on\
    \ it. It sorts the array in place.\n<code>", "  arr.sort\nend", "  arr.sort!\n\
    end", "  # sort by number of ones\n  arr.sort! {|a, b| b.to_s.length <=> a.to_s.length}\n\
    \  # sort by decimal values\n  arr.sort! {|a, b| b.to_i <=> a.to_i}\n  arr\nend",
  "  arr.sort { |a, b| ones_in_binary(a.to_s(2)) <=> ones_in_binary(b.to_s(2)) }\n\
    end\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThanks for your answer. \nI\
    \ tried to use it but got this error:\n<main>': undefined method `to_s' for 3:Fixnum\
    \ (NoMethodError)", "  return arr.reverse.sort.call(arr).reverse\nend", "  sorted\
    \ = []\n  arr = arr.sort\n  arr.each do |i|\n    ones = bin(i).count(\"1\")\n\
    \    decimal = i / ones\n    decimal = decimal.to_i\n    sorted.unshift(decimal)\
    \ unless sorted.include?(decimal)\n  end\n  sorted\nend", "\ti = 0\n\tarr_size\
    \ = len(arr)", "  # sort by number of ones\n  ones = arr.map {|e| (e & 1) == 0}.sort\n\
    \  # sort by decimal value\n  dec = arr.map {|e| -e}.sort\n  # merge both arrays\n\
    \  merged = ones + dec\n  # sort again\n  merged.sort\nend", "  arr.sort!\n  arr.each_with_index\
    \ do |e, i|\n    if e == 0\n      arr[i] = e * 2\n    elsif e == 1\n      arr[i]\
    \ = e * 2 + 1\n    end\n  end\n  arr\nend\n</cell>\n<cell>", "  arr.sort!\nend",
  "\tsort = lambda x,y: 1 if x > y else -1 if x < y else 0\n\tsorted = []\n\tarr.each\
    \ do |num|\n\t\tif num.to_s.length == 1 # check base case\n\t\t\tsorted << num\n\
    \t\t\tnext\n\t\tend\n\t\tones = num.to_s.length - 1 # find number of ones \n\t\
    \tbase = num.to_s.reverse.index(\"1\") # find first one\n\t\tbase = base if base\
    \ > -1 # avoid out of index\n\t\tdecimal = num.to_s[base,ones] # get the number\
    \ after the first one\n\t\tdecimal = decimal.to_i if decimal.to_i > 0\n\t\tsorted\
    \ << num.to_s[base,ones-1] if num.to_s[base,ones] > decimal.to_i # sort based\
    \ on decimal value\n\tend\n\tsorted.reverse\nend", "  n = arr.length\n  if n<=0\n\
    \    throw ArgumentError.value(:arr, \"Expected a non-negative integer array\"\
    )\n  end", "  arr.sort! { |i, j| \n    [i,j].select { |x| x == 1 }.size <=> [i,j].select\
    \ { |x| x == 0 }.size \n  }\n  arr\nend\n</code>\n<|/ a tags=sorting,ruby,arrays\
    \ dscore=0 |>\n<| a tags=sorting,ruby,arrays |>\nHere's a way using Array#sort_by:\n\
    <code>\narr = [-4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6]", "  return [] if arr.empty?\n\
    \  counts = arr.map {|x| [x, arr.reject {|y| y == x}.count]}\n  counts = counts.sort\
    \ {|a, b| b[0] <=> a[0]}", "  arr.sort!\nend", "  arr.sort!\n  arr.each_with_index\
    \ do |number, i|\n    arr[i] = if number == 1\n                 number\n     \
    \          else\n                 number - 1\n               end\n  end\n  arr\n\
    end\n</pre>", "  arr = arr.reverse if arr.empty? # reverse if array is empty\n\
    \  arr.map! do |n|\n    ones = n.to_s(2) # turn n into binary string\n    ones\
    \ = ones[0...ones.length - 2] if ones[ones.length - 1] == '0' # remove last '0'\
    \ if present\n    ones = ones[0...-1] if ones[ones.length - 1] == '1' # remove\
    \ last '0' if present\n    [ones.length, ones].sort.reverse.to_i\n  end\n  arr.sort\n\
    end", "    arr.sort! # sort in place \n    i = 0\n    sum = 0\n    while i < arr.length\n\
    \        sum = sum + arr[i]\n        i += 1\n        while sum > 0\n         \
    \   arr.insert(i, arr.pop)\n            sum -= 1\n        end\n    end\n    return\
    \ arr\nend", "  arr.sort!\nend", "  arr.sort! { |a, b| b.zero? ? a.zero? ? 0 :\
    \ -1 : a.zero? ? 1 : a <=> b }\nend\n</code>\n<|/ a dscore=3 |>\n<| a dscore=2\
    \ |>\n<code>", "  return [arr[0], arr[1], arr[2], arr[3], arr[4]]\nend", "  arr.sort!\n\
    \  i = 0\n  while i < arr.length\n    j = i\n    cnt = 0\n    while j >= 0 and\
    \ arr[j] == 1\n      cnt += 1\n      j -= 1\n    end\n    if cnt > arr[i]\n  \
    \    arr[i] = cnt\n      i += 1\n    else\n      arr[arr.length - 1 - i] = cnt\n\
    \      i -= 1\n    end\n  end\n  arr\nend", "  # O(n)\n  ones = arr.select { |x|\
    \ x == 1 }\n  size = ones.length\n  size.times do |i|\n    j = size - i\n    ones[j],\
    \ ones[i] = ones[i], ones[j]\n  end\n  \n  decimal = arr.map { |i| i.to_i }\n\
    \  decimal.sort\n  \n  arr.map { |i| i % 10 }\nend\n</cell>\n<cell>", "  arr.sort!\
    \ {|x, y| count_ones(x) > count_ones(y) ?\n  count_ones(x) - count_ones(y) :\n\
    \  count_ones(y) - count_ones(x)}\nend", "  return arr.sort{|a,b| b <=> a} if\
    \ arr.size > 0\nend", "  len = arr.length\n  result = Array(len)\n  (0...len).each\
    \ { |i| result[i] = arr[i] }\n  (0...len).each { |i| arr[i] = result[i].to_i }\n\
    \  arr\nend\n</code>\nMy solution isn't very elegant, but it works as expected:\n\
    <code>\nrequire 'minitest/autorun'\nrequire 'sort'\nrequire 'binary'\nrequire_relative\
    \ 'array'\nrequire_relative 'sort'", "  arr.sort!\nend", "  a = arr.dup\n  size\
    \ = arr.size\n  max = 0\n  i = 1\n  while i < size\n    max = nil\n    while i\
    \ < size\n      if a[i] == 1\n        max = a[i]\n        break\n      end\n \
    \     i += 1\n    end", "  sorted = []\n  arr.each do |n|\n    ones = n.to_s(2).count('1')\n\
    \    ones = ones.zero? ? 0 : ones\n    \n    if ones == 0\n      sorted.push(n)\n\
    \    else\n      sorted.unshift(n)\n    end\n  end\n  \n  sorted.sort\nend", " \
    \ return nil if arr.length == 0\n  ones = arr.count(1)\n  ones = 1 if ones ==\
    \ 0\n  tens = arr.count(10)\n  tens = 1 if tens == 0\n  return arr[arr.index(ones).to_i\
    \ .. arr.index(tens).to_i].sort\nend", "    arr.sort!\nend", "  n = arr.length\n\
    \  arr.sort do |x, y|\n    count_one = bin(x).count('1')\n    count_zero = bin(y).count('0')\n\
    \    count_one.zero? && !count_zero.zero? ? count_one.to_i : count_zero.to_i\n\
    \  end\nend", "  return arr.sort { |a, b| (a < b) ? -1 : ((a > b) ? 1 : 0) }\n\
    end\n</cell>\n<cell>", "  arr.sort\n  arr.dup\nend", "  # Your code here\n  sorted\
    \ = arr.clone\n  ones = sorted.select { |e| e % 2 == 0 }\n  \n  ones = ones.map\
    \ { |e| [e, e / 2] }\n  ones = ones.sort_by { |e| e[1] }\n  \n  sorted.zip(0..sorted.length).reverse_each\
    \ do |a|\n    if a.first == 1\n      sorted.delete_at(a.last)\n    end\n  end\n\
    \  \n  sorted.zip(ones).map { |a| a[0] * (a.last + 1) }.concat(sorted.dup).uniq!\n\
    \  return sorted.sort_by { |e| e }\nend\n</cell>\n<cell>", "  return arr.sort\
    \ {|a, b| b <=> a } if arr.size == arr.sum\n  # O(nlogn) algorithm\n  # sort array\
    \ as descending order\n  arr.sort_by {|el| el if el.is_a?(Fixnum) }.reverse\n\
    \  # sort array as ascending order\n  # arr.sort_by {|el| el }.map {|el| el if\
    \ el.is_a?(Fixnum) }\nend\n</cell>\n<text>\nSum all the odd numbers in array",
  "    arr_size = arr.size\n    sorted_arr = Array.new(arr_size).to_int\n    bit_array\
    \ = Array.new(arr_size).to_int\n    ones = Array.new(arr_size).to_int\n    zeros\
    \ = Array.new(arr_size).to_int", "  result = nil\n  one_counts = count_ones(arr)\n\
    \  arr.sort.each do |num|\n    if one_counts[num] < 2 && (one_counts[num] - arr.index(num))\n\
    \      result ||= []\n      result << num\n    end\n  end\n  return result\nend\n\
    </pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"cell border-box-sizing text_cell\
    \ rendered\"><div class=\"prompt input_prompt\">\n</div>\n<div class=\"inner_cell\"\
    >\n<div class=\"text_cell_render border-box-sizing rendered_html\">\n<p>Now let's\
    \ write the function <code>count_ones</code>. This one will count the number of\
    \ occurrences of each binary digit. Here are the rules:</p>\n<ul>\n<li>If a digit\
    \ is 0, ignore it</li>\n<li>If a digit is 1, increment <code>one_counts</code>\
    \ by 1</li>\n<li>If a digit is 2, increment <code>one_counts</code> by 2</li>\n\
    <li>etc...</li>\n</ul>\n<p>And here is the code:</p>", "  arr.sort.with_index\
    \ do |t, idx|\n    # check if there are multiple ones in the same position\n \
    \   # by calculating how many ones in its binary representation\n    num = t.zero?\
    \ ? 0 : 1\n    # use \"num\" variable to get count of ones in its binary representation\n\
    \    ones = num.to_s(2).count('1')\n    # use decimal value to sort by decimal\
    \ value\n    if ones > 0\n      t.to_s\n    elsif ones == 0\n      t.to_i\n  \
    \  end\n  end\nend", "  arr.sort!\n  arr.map { |x| x.zero? ? x : (x.nonzero? ?\
    \ -x : x) }\nend", "  return arr.sort_by { |x| x.zero? ? 0 : x.one? ? x.to_i :\
    \ x.to_f.abs }\nend\n</pre>\n    </td>\n  </tr>\n  <tr>\n    <td colspan=\"2\"\
    >\n      <pre class=\"prettyprint lang-Ruby\">", "    arr1 = []\n    arr2 = []\n\
    \    binarr = Array.new\n    decimalarr = Array.new", "  # Your code goes here!\n\
    end", "    return arr\nend", "  # Your code here\nend", "    sorted = []\n   \
    \ # Write your code here.\n    return sorted", "  # Your code goes here.\nend",
  "  arr.sort!\nend", "  len = arr.length\n  if len == 0\n    return arr\n  sorted\
    \ = []\n  i = 0\n  while i < len\n    sum = arr[i].to_s(2).length\n    sorted.push\
    \ arr[i]\n    i += 1\n    until sum < len\n      sum += 1\n      until sum > len\n\
    \        sum -= 1\n        sorted.push arr[i].to_s(2).reverse.gsub(/../, '0')\n\
    \      end\n    end\n  end\n  return sorted.reverse\nend\n</code>\n<|/ a tags=ruby,arrays,algorithm\
    \ dscore=1 |>\n<| c |>\nNice answer. One thing I'd add is that you can write that\
    \ as a one-liner in the manner `arr.map { |n| n.to_s(2).length.downcase }.sort_by\
    \ { |x| x.reverse.gsub(/../, '0') } .reverse`\n<|/ c |>\n<| c |>\nOh, thanks so\
    \ much for sharing your solution here. I will definitely use it in future. Thanks.\n\
    <|/ c |>\n<| a dscore=0 tags=ruby,arrays,algorithm |>\nHere is my code:\n<code>",
  "  arr.sort!\nend", "  n = arr.length\n  sorted_arr = Array.new(n) { Array.new(n)\
    \ }\n  \n  arr.each_with_index do |num, i|\n    if num == 1\n      sorted_arr[i]\
    \ = num\n    elsif num > 0\n      max_ones = num.bit_length\n      while max_ones\
    \ > 0\n        max_ones -= 1\n        bit_val = num % 2\n        if bit_val ==\
    \ 0 && sorted_arr[max_ones] == -1\n          sorted_arr[max_ones] = num\n    \
    \    elsif bit_val == 0\n          sorted_arr[max_ones] = -1\n        end\n  \
    \      num = num / 2\n      end\n    end\n  end", "  # Convert each element into\
    \ a binary string and pad it with zeros to have length 2n.\n  bin_string = ''.join(map(str,\
    \ arr)).rjust(len(arr), '0')\n  # Convert binary strings into array of integers\
    \ and count number of ones.\n  ones = arr & 1\n  # Sort elements in decending\
    \ order based on number of ones.\n  ones = ones.sort\n  # Sort the array in ascending\
    \ order based on decimal value of ones.\n  ones = ones.sort_by{|i| i.to_s.reverse.to_i}\n\
    \  # Convert array of integers into binary string and return it\n  return bin_string\n\
    end", "  return arr.sort{|a,b|\n    sort_bit(a)<=>sort_bit(b)\n  }\nend", "  return\
    \ arr.sort{|a, b| a <=> b}\nend", "  arr.sort.each_with_index do |val, i|\n  \
    \  if val > 0\n      arr[i] = -val\n    else\n      arr[i] = val\n    end\n  end\n\
    \  arr\nend", "  size = arr.size\n  zero_count = 0\n  one_count = 0\n  max_ones\
    \ = 0\n  max_zeros = 0\n  zero_counter = 0\n  one_counter = 0\n  for i in 0...size\
    \ - 1\n    if arr[i] < 0\n      max_zeros += 1\n      while zero_counter < size\
    \ - 1\n        if arr[i + zero_counter] == 0\n          zero_counter += 1\n  \
    \      else\n          break\n      else\n        max_zeros += zero_counter\n\
    \      end\n    elsif arr[i] > 0\n      max_ones += 1\n      while one_counter\
    \ < size - 1\n        if arr[i + one_counter] == 1\n          one_counter += 1\n\
    \        else\n          break\n      else\n        max_ones += one_counter\n\
    \      end\n    else\n      max_zeros += 1\n      while zero_counter < size -\
    \ 1\n        zero_counter += 1\n      end\n      max_ones += 1\n      while one_counter\
    \ < size - 1\n        one_counter += 1\n      end\n    end\n  max_ones = max_ones\
    \ - max_zeros\n  if max_ones > max_zeros * size\n    max_ones = max_zeros * size\n\
    \  end\n  for i in 0...size - 1\n    if arr[i] > max_ones\n      arr[i], arr[i\
    \ + max_ones] = arr[i + max_ones], arr[i]\n      arr[i + max_ones], arr[i] = arr[i],\
    \ arr[i + max_ones]\n    end\n  end\nend", "  arr.sort do |a, b|\n    b_one_bits\
    \ = b.to_s(2).count(\"1\").to_i\n    if b_one_bits > 0\n      b_one_bits = b_one_bits.to_i\n\
    \      a_one_bits = a.to_s(2).count(\"1\").to_i\n      a_one_bits = a_one_bits.to_i\n\
    \      b_one_bits = b_one_bits - a_one_bits\n      a_one_bits = a_one_bits - b_one_bits\n\
    \    end\n    b_one_bits = b_one_bits < 0 ? 0 : b_one_bits\n    if a_one_bits\
    \ == 0\n      b_one_bits\n    else \n      a_one_bits\n    end\n  end\nend\n</code>\n\
    <|/ a tags=ruby dscore=0 |>\n<| c |>\nThis is a good solution but it's worth pointing\
    \ out that there are other ways to do this in Ruby. One possibility is to sort\
    \ the array first by converting to a string, then splitting the string into an\
    \ array by the 1s then sorting by the length.\n<|/ c |>\n<| a |>\nThis can be\
    \ solved using a comparison operator in ruby 1.9.3. The key is to create a hash\
    \ with the count of each bit:\n<code>", "  arr.sort do |i1, i2|\n    compare =\
    \ binary_to_decimal(i1.to_s(2)) - binary_to_decimal(i2.to_s(2))\n    compare =\
    \ compare * (-1 if i1 > i2)\n    compare\n  end\nend", "    arr.sort!\nend", " \
    \ arr.each_index do |i|\n    ones = arr[i].to_s(2).count('1')\n    decimal = arr[i].to_s.split(//).map(&:to_i)\n\
    \    decimal.each_with_index do |d, j|\n      if d >= ones\n        decimal[j]\
    \ = ones - d\n      end\n    end\n    arr[i] = decimal.join('').to_i\n  end\n\
    end", '  size = arr.size', "    \n    arr.sort\n    # Write your code here.\n\
    end", '  return arr.sort', "  sorted = []\n  arr.each do |elem|\n    sorted.push((elem.to_s(2)\
    \ rescue elem.to_s).split('').map { |s| s[/\\d/].to_i }.inject(:+))\n  end\n \
    \ sorted.sort!\n  return sorted.map { |elem| [elem].pack('U*') }\nend", '  return
    arr.sort', "    size = arr.size\n    sorted_array = []\n    ones = 0\n    decimal\
    \ = 0\n    for i in arr\n        if ones < i\n            ones = i\n        else\n\
    \            decimal = decimal + i\n        sorted_array << decimal\n    end\n\
    \    sorted_array << ones\n    sorted_array\nend", "  return sorted(arr, key=lambda\
    \ x: int(x == x.to_s(2).count(\"1\")))\nend", "  arr.sort! do |a, b|\n    if a\
    \ == 0\n      b\n    elsif b == 0\n      a\n    else\n      a^b\n    end\n  end\n\
    end\n</code>\n<|/ a |>\n<| c |>\nthank you for the answer! The reason for this\
    \ method is that the array is sorted and I wanted a method that did that. My professor\
    \ only gave us a hint for it.\n<|/ c |>\n<| c |>\n: I added my answer to your\
    \ question. I hope it is more clear now\n<|/ c |>\n<| c |>\nI added a better explanation\
    \ above. Thanks for answering my question!\n<|/ c |>\n<| c |>\n: I added more\
    \ explanation above.\n<|/ c |>\n<| c |>\nThanks for the explanation! This is exactly\
    \ what I was looking for. My professor was definitely a little confused. He also\
    \ specified that we could not use .sort method, but had to use Array#sort, so\
    \ I didn't know how to sort my array using that.\n<|/ c |>\n<| a dscore=0 |>\n\
    Here is my answer for the same problem:\n<code>", "  # Your code here\n  arr.sort{|x,y|\
    \ y if  x ==  0}.sort{|x,y| y if x  ==  0}.sort{|x,y| (x  +  y  if x  ==  y) <=>\
    \ (x + y if x == y)}\nend", "  arr.sort!\nend\n</cell>\n<cell>", "  arr.sort {\n\
    \    |a, b| a.zero? <=> b.zero? ? a <=> b : a.to_s(2) <=> b.to_s(2)\n  }\nend",
  "  # Your code here\n  arr.sort!", "  arr.sort!\nend", "  sorted_array = []\n  arr.each\
    \ do |num|\n    bin = num.to_s(2)\n    bin.count(\"1\") <= 1 ? num : num.to_i\n\
    \  end\nend", "  # write code here\nend", "  n = arr.count\n  arr.each do |i|\n\
    \    bin = i.to_s(2)\n    len = bin.length\n    last = len - 1\n    bin = bin.chars.reverse.join.to_s\n\
    \    \n    bin.chars.each_with_index do |x, i|\n      bin[(len - 1) - i] = bin[(len\
    \ - 1) - i].chr + x\n    end\n    \n    bin.chars.reverse!.join.to_s\n    \n \
    \   len = bin.length\n    bin = bin[1..len]\n    \n    if n > bin.length\n   \
    \   n -= bin.length\n      arr = arr.reverse_each.select { |i| i.to_s(2) != bin\
    \ }\n      \n      break if arr.size < n\n    end\n  end\n  \n  return arr\nend\n\
    </cell>\n<cell>", "  arr.sort.with_index { |i,j| i == 0 ? j : j - i }\nend", " \
    \   # do your work here\nend", "  sorted_array = []\n  arr.each do |element|\n\
    \    ones_count = 0\n    decimal_val = element.zero? ? 0 : element\n    decimal_val.to_s.reverse.gsub(/(.)(\\\
    d)/, '\\1 \\2').gsub(/^ /, '').gsub(/ $/, '').split(' ').each do |e|\n      if\
    \  e.gsub!(/1/, '1')\n        ones_count += 1\n      else\n        break\n   \
    \   end\n    end\n    decimal_val.to_s.reverse.gsub(/(.)(\\d)/, '\\1 \\2').gsub(/^\
    \ /, '').gsub(/ $/, '').split(' ').each do |e|\n      if  e.gsub!(/0/, '0')\n\
    \        ones_count -= 1\n      else\n        break\n      end\n    end\n    ones_count\
    \ += decimal_val.to_s.reverse.gsub(/(.)(\\d)/, '\\1 \\2').gsub(/^ /, '').gsub(/\
    \ $/, '').split(' ').count { |e| e == '1' }\n    if ones_count > 0 \n      sorted_array\
    \ << element\n    end\n  end\n  sorted_array.sort! { |a, b| b.to_s.reverse.gsub(/(.)(\\\
    d)/, '\\1 \\2').gsub(/^ /, '').gsub(/ $/, '').split(' ').count { |e| e == '0'\
    \ } - a.to_s.reverse.gsub(/(.)(\\d)/, '\\1 \\2').gsub(/^ /, '').gsub(/ $/, '').split('\
    \ ').count { |e| e == '0' } }\n  sorted_array\nend", "  return [] if arr.length\
    \ == 0 || !arr[0]\n  arr = [arr[0]] + sort_array(arr[1..-1]).reverse + arr\n \
    \ arr.sort do |a, b|\n    compare = b.to_s(2).count('1') <=> a.to_s(2).count('1')\n\
    \    compare = compare || b.to_i <=> a.to_i\n    compare ? compare : b.to_i <=>\
    \ a.to_i\n  end\nend", "    # write your solution here\n    arr.sort { |a, b|\
    \ [a, b].count(1<=>0) <=> [a, b].count(1<=>1) }\nend", "  arr.sort!\nend", " \
    \   arr.sort.with_index { |i, v|\n        # Convert i to a binary string (with\
    \ length of 32), count the ones,\n        # then convert it back to an integer\n\
    \        bits = i.to_s(32).count(\"1\") + 2**32\n        bits.to_i if bits > 0\
    \ }\nend", "  size = arr.size\n  arr.sort!\n  return arr\nend", "  arr.sort.sort!\
    \ do |a, b|\n    b.zero? ? 1 : a.zero? ? -1 : a <=> b\n  end\nend", "  arr.sort!\
    \ { |a, b| a.to_s(2).chars.sort.reverse.to_i(2) <=> b.to_s(2).chars.sort.reverse.to_i(2)\
    \ }\nend", '    arr.sort!', "    arr.sort do |x, y|\n      x = x.to_s.length\n\
    \      y = y.to_s.length\n      x <=> y || x.to_i <=> y.to_i\n    end\n    arr\n\
    end\n</cell>\n<cell>\n@test sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n@test\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n@test sort_array([1,\
    \ 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n@test sort_array([-2, -3, -4, -5, -6]) == [-6,\
    \ -5, -4, -3, -2]\n</cell>\n<text>\nPart 4: Sorting and Searching\nNow you know\
    \ how to use two simple functions to sort and search for elements in a list. Let's\
    \ see how they work in practice!", "    arr.sort!\n    arr.map { |e| -e.to_s(2).count(\"\
    1\") + e.to_s(16).to_i(16).abs }\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=sorting,ruby,arrays,ruby-on-rails\
    \ |>\nI think this would work \n<code>\nsort_array.sort_by{ |x| x.to_s(2).count(\"\
    1\") }.reverse\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 tags=sorting,ruby,arrays,ruby-on-rails\
    \ |>\n<code>\narr = [-2, -1, 0, 1, 2]", "  return arr.sort{ |a, b| b[0].to_i *\
    \ b[1].to_i < a[0].to_i * a[1].to_i }\nend", "  return nil if arr.length < 1\n\
    \  one_one = arr.count(1)\n  min_value = nil\n  max_value = nil\n  arr.each do\
    \ |i|\n    if i == 0\n      min_value = i\n      max_value = i\n    else\n   \
    \   if one_one == 0\n        one_one = i\n      end\n      if one_one < i\n  \
    \      min_value = i\n      elsif one_one > i\n        max_value = i\n      end\n\
    \    end\n  end\n  return [min_value, max_value, min_value, max_value]\nend",
  "    ones = []\n    zeros = []\n    count = []\n    arr_copy = arr.clone()\n   \
    \ \n    # Iterate over each element in the array\n    for i in arr_copy\n    \
    \    # Increment the count if the element is 1\n        if arr[i] == 1\n     \
    \       count = count + 1\n        # If it is 0, increment the zeros counter\n\
    \        if arr[i] == 0\n            zeros = zeros + 1\n        # Else, increment\
    \ the ones counter\n        else\n            ones = ones + 1\n    end\n    \n\
    \    # Iterate over each element in the array\n    for i in arr_copy\n       \
    \ # If the count is less than the number of ones, then the element has 1s\n  \
    \      # Otherwise, subtract the count\n        if count < ones\n            arr[i]\
    \ = 1\n        # Else, subtract 1 from the count (since we already checked that\
    \ count>0)\n        else\n            arr[i] = count - ones\n        end\n   \
    \ end\nend", "  arr = arr.to_a if arr.respond_to?(:to_a) rescue arr\n  arr.sort\n\
    end", "  arr.sort.with_index do |x, i|\n    if (x.to_s(2).length == 1)\n     \
    \ # ascending order\n      arr[i] || 0\n    else\n      x = x.to_i(2).to_s\n \
    \     x = x.reverse\n      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n\
    \      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n\
    \      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n\
    \      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n\
    \      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n\
    \      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n\
    \      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n\
    \      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n\
    \      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n\
    \      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n\
    \      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n\
    \      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n\
    \      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n\
    \      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n\
    \      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n\
    \      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n\
    \      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n\
    \      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n\
    \      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n\
    \      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n\
    \      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n\
    \      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n\
    \      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n      x = x.reverse\n\
    \      x = x.reverse\n      x = x.reverse", "  arr.sort\nend", "  # TODO: Write\
    \ your code here.\n  arr.sort\nend", "  arr.reverse.sort.each { |e| e.odd? ? arr\
    \ << 1 : arr << 0 }\n  arr.reverse\nend", '  return [] if arr.empty? || arr.size
    < 2 ', "  arr.sort!\nend", '  arr.sort!', "  arr.sort!\n  i = arr.length\n  while\
    \ i != 0\n    i -= 1\n    j = i\n    while j > 0 && arr[j] != 0\n      j -= 1\n\
    \    if j == 0 || j > i\n      arr[i], arr[j] = arr[j], arr[i]\n    end\n  end\n\
    \  arr\nend\n</pre>", "    arr = arr.to_a\n    arr.sort!\n    arr.map { |i| i.to_s(2)\
    \ }\nend\n</code>\n<|/ a tags=ruby,algorithm dscore=1 |>\n<| c |>\n`to_s` will\
    \ take more than 8 characters. You should use `String#length` instead of `to_s(2)`.\n\
    <|/ c |>\n<| c |>\n`to_s` will take a little more than 8 characters, because `to_s(2)`\
    \ will prepend a `0` if the number is `0`\n<|/ c |>\n<| c |>\nIn Ruby 1.9, `to_s`\
    \ will always return a `String`\n<|/ c |>\n<| c |>\n`to_i` will throw an error\
    \ if the string doesn't contain any valid integer digits.\n<|/ c |>\n<| c |>\n\
    `to_i` will also fail on strings that start with non-numeric characters.\n<|/\
    \ c |>\n<| a tags=ruby,algorithm dscore=0 |>\n<code>", "  arr.sort!\nend", " \
    \ sort = lambda a, b: a.zero? && b.zero? ? 0\n               : a == b ? 0\n  \
    \             : a > b ? 1\n               : -1\n  arr.sort { |x, y| [sort(x, 0),\
    \ sort(y, 0)] }\n  arr\nend", "  arr = arr[0]\n  arr.each do |item|\n    arr[item]\
    \ = 0 if arr[item] == 0\n  end\n  arr.sort_by! {|v| arr.count(v)}\n  arr\nend",
  "  return arr.sort{|a, b| b <=> a if bin(a).count('1') == bin(b).count('1')}\nend",
  "  return arr.sort.call(arr.reverse.zip(arr))\nend", "    return []\nend\n</cell>\n\
    <code language=julia-0.4>\nsort_array.call([1, 5, 2, 3, 4])\n</cell>\n<code language=julia-0.4>\n\
    sort_array.call([-2, -3, -4, -5, -6])\n</cell>\n<code language=julia-0.4>\nsort_array.call([1,\
    \ 0, 2, 3, 4])\n</cell>\n<code language=julia-0.4>", "  if arr.nil?\n    []\n\
    \  elsif arr.length == 0\n    arr\n  else\n    arr.map { |x| x =~ /^1/ ? 1 : x\
    \ =~ /^0/ ? -1 : x }\n    .sort { |a,b| a <=> b }\n    .reverse\n  end\nend",
  "  arr.sort!\nend", "  arr.sort! { |a, b| a.nonzero? <=> b.nonzero? }\nend", '  arr.sort!',
  '  return [] if arr.empty? || arr.length < 2 ', "  arr.sort! do |i|\n    i = i.to_s\n\
    \    i = i.split(//).map {|x| x.to_i}.to_enum\n    count = 0\n    while i.has_next?\n\
    \      count += i.next\n    end\n    count\n  end\nend", "  arr.sort.with_index\
    \ do |(v, i), i|\n    if v != 0\n      k = v.to_s(2).count('1').to_i if k\n  \
    \    [i - (k or 0), v] if k\n    else\n      i\n    end\n  end\nend", "  sorted\
    \ = []\n  array.each_with_index do |e, i|\n    sorted.push(e)\n  end\n  sorted.sort!\
    \ do |a, b|\n    if a < b\n      -1\n    elsif a == b\n      0\n    elsif b <\
    \ a\n      1\n    end\n  end\n  sorted.each { |e| sorted.push(e) }\n  return sorted\n\
    end", "  return arr.sort_by { |x| [x.zero? ? 0 : 1, x.nonzero? ? x.to_s.size :\
    \ -1].min }\nend", "  arr.sort! do |a, b|\n    if a.zero?\n      b\n    else\n\
    \      ((b & 1) == 0) ? (a.to_s.reverse <=> b.to_s.reverse).nonzero? : (a.to_s\
    \ <=> b.to_s)\n    end\n  end\nend", "  return arr.sort_by do |i|\n    i = i.reverse\n\
    \    if i[0] == '0'\n      n = i.count('0')\n      return [n] if n < 2 || n ==\
    \ 0\n      n = i.count('1').floor\n      p [n, n-1, n-2]\n    end\n    p i.to_i\n\
    \  end.reverse\nend", "    ones = arr.select { |e| e > 0 }.count\n    tens = arr.select\
    \ { |e| e >= 1 && e <= 10 }.count\n    ones_tens = arr.select { |e| e > 0 && e\
    \ <= 10 }.count\n    tens_ones = arr.select { |e| e >= 10 && e <= 100 }.count\n\
    \    ones_tens_ones = arr.select { |e| e > 0 && e <= 100 && e <= 1000 }.count\n\
    \    tens_ones_ones = arr.select { |e| e >= 100 && e <= 1000 }.count\n    ones_tens_ones_ones\
    \ = arr.select { |e| e > 0 && e <= 100 && e <= 1000 }.count\n    tens_ones_ones_ones_ones\
    \ = arr.select { |e| e > 100 && e <= 1000 }.count\n    ones_tens_ones_ones_ones_ones\
    \ = arr.select { |e| e > 100 && e <= 1000 }.count", "    # your code goes here\n\
    \    \n    # get the ones' index\n    ones = arr.count(1)\n    \n    # sort ascendingly\
    \ by ones' index\n    temp = arr.sort\n    \n    # sort descendingly by decimal\
    \ value\n    # hint: sort based on decimal value is much more efficient than sort\
    \ on binary ones' index\n    temp.sort_by!(&:to_i)\n    \n    return temp\nend",
  "  return [].tap do |res|\n    ones = arr.select { |x| x == 1 }\n    one_count =\
    \ ones.length\n    one_count = 0 if one_count < 0\n    res << ones\n    ones =\
    \ arr.select { |x| x != 1 }\n    one_count += ones.length\n    one_count = 0 if\
    \ one_count < 0\n    res << ones.sort { |a, b| a <=> b }\n    res << [one_count].sort\
    \ { |a, b| a <=> b }\n  end\nend", "  arr.sort!\n  arr.map {|i| i}\nend", "  len\
    \ = arr.length\n  if len == 0\n    return arr\n  odd_count = 0\n  even_count =\
    \ 0\n  max_odd_count = 0\n  max_even_count = 0\n  max_odd_size = 0\n  max_even_size\
    \ = 0\n  max_odd_size_arr = [0,0]\n  max_even_size_arr = [0,0]", "  if arr.empty?\n\
    \    arr\n  elsif arr.size == 1\n    [arr]\n  else\n    sorted = []", "  arr.reduce\
    \ do |r, x|\n    r.length < 2\n  ? r + [x]\n  : r.map {|y| x * 2 + y}.sort {|x,\
    \ y| y < x}.map {|x| x / 2}\n  end\nend", "  arr.sort!\nend", "  return arr\n\
    end", "  arr.sort.call(arr.uniq.sort)\nend\n</cell>\n<cell>", "  return [] if\
    \ arr.empty? else arr.sort_by { |x| count_ones(x) }.reverse\nend\n</code>\n<|/\
    \ a dscore=4 |>\n<| c |>\nI appreciate this answer as it includes some real code\
    \ examples. However, it doesn't address the specific question: \"why isn't this\
    \ working?\" If you look at my own answer below, I've included the full code for\
    \ a working solution, so I do appreciate the upvote.\n<|/ c |>\n<| a |>\nIn case\
    \ anyone is curious, the following code works in Ruby 1.9.3 too:\n<code>", " \
    \ return nil\nend", "  n = arr.length\n  sorted = Array.new(n)\n  for i in 0...n\n\
    \    bits = Array.new(n/2) + 1\n    for j in 0...n\n      bits[j] = 1 if arr[j]\
    \ > i else 0\n    end\n    sorted = sorted + Array.new(bits.sum)\n    sorted.reverse_each{|n|\
    \ sorted.push(bits.sum - n)}\n  end\n  sorted.sort!\n  for i in 0...n\n    arr[i]\
    \ = sorted[arr[i]]\n  end\nend", "    arr.sort_by! {|x| x.to_s(2).count(\"1\"\
    ) }\nend", "  arr.sort { |a, b| b <=> a }\nend", "    return arr.sort\nend", " \
    \ arr.sort!{|x,y| (x.zero? && y.zero?) ? 0 : (x.zero? ? 1 : -1) * ((2**(x.to_s(2)+1)).to_i(2))}\n\
    end\n</cell>\n<code language=other-env>", "    arr.sort!\nend", "  arr.sort!\n\
    \  arr.each_index do |i|\n    arr[i] = arr[i].to_s(2)\n  end\n  arr.each_index\
    \ do |i|\n    if arr[i].include?(\"1\")\n      arr[i] = arr[i].to_i(10)\n    end\n\
    \  end\n  arr\nend\n</code>\n<|/ a |>\n<| a |>\nJust in case someone was looking\
    \ for the python solution:\n<code>", "  arr.sort! do |a, b|\n    if a > b then\
    \ b else a end\n  end\nend", "  return arr.sort do |x,y|\n    if x==0\n      0\n\
    \    elsif y==0\n      1\n    elsif x==1 && y==1\n      -1\n    elsif x==1 &&\
    \ y==-1\n      1\n    elsif x==-1 && y==-1\n      -1\n    elsif x==-1 && y==1\n\
    \      1\n    else\n      x.to_s(2).count(\"1\").to_i<y.to_s(2).count(\"1\").to_i?-1:x.to_s(2).count(\"\
    1\").to_i>y.to_s(2).count(\"1\").to_i?1:x.to_s(2).count(\"1\")<y.to_s(2).count(\"\
    1\").to_i?-1:x.to_s(2).count(\"1\").to_i>y.to_s(2).count(\"1\").to_i?1:x.to_s(2).count(\"\
    1\").to_i<y.to_s(2).count(\"1\").to_i?-1\n    end\n  end\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nI think you should try and implement your solution yourself. It\
    \ may help future readers who are interested, and also help you learn :)\n<|/\
    \ c |>\n<| a |>\nTry this:\n<code>", "    # O(n)\n    return arr.sort do |a, b|\n\
    \        # O(1)\n        diff = bin2dec(a.bin) - bin2dec(b.bin)\n        diff2\
    \ = dec2bin(diff)\n        diff == diff2 ? a.bin <=> b.bin : diff <=> diff2\n\
    \    end\nend\n</code>\n<|/ a tags=ruby,algorithm dscore=1 |>\n<| c |>\nThanks\
    \ for the suggestion. I've tried but unfortunately that doesn't work because `bin2dec`\
    \ returns a negative number when `b` is 0. I've added a sample test to my original\
    \ post\n<|/ c |>\n<| c |>\nI've added a sample test case to my original post.\n\
    <|/ c |>\n<| c |>\nSorry, my bad. I've just edited the code and it works perfectly\
    \ now. Thank you very much!\n<|/ c |>\n<| a dscore=1 |>\nTry the following (Python\
    \ solution):\n<code>", "  return sorted(arr.select { |e| e > 0 }.sort)\nend",
  "  # Your code here\nend", "  arr.sort!\n  return arr\nend", "  sorted = []\n  arr.each_index\
    \ do |index|\n    sorted = sorted + [arr[index]]\n    break if sorted.last < sorted.first\n\
    \  end\n  sorted\nend", "    arr.sort {|a, b| (a > b) ? 1 : ((b > a) ? -1 : 0)}\n\
    \    arr\nend", "  return arr.sort.call(arr.select { |x| (x & 1) == x }).sort\
    \ { |x,y| x.to_i < y.to_i ? -1 : x.to_i > y.to_i ? 1 : 0 }\nend", "  if arr.empty?\
    \ then\n    []\n  else\n    ones = arr.group_by{|x| x % 2 == 0}\n    zeros = arr.group_by{|x|\
    \ x % 2 != 0}\n    sorted = []\n    \n    # Sort positive numbers by their ones\n\
    \    positive = ones[true] + ones[false].sort{|a, b| a.to_s <=> b.to_s}\n    \n\
    \    # Sort negative numbers by their ones\n    negative = zeros[true] + zeros[false].sort{|a,\
    \ b| a.to_s <=> b.to_s}\n    \n    # Sort numbers that come from the same source\n\
    \    sorted.concat(positive)\n    sorted.concat(negative)\n  end\nend", "  if\
    \ arr.length == 0\n    return arr\n  \n  one, two, three, four, five = arr.length\
    \ - 1, -1, 1, -1, -1\n  \n  while arr[one] == \"1\" or arr[two] == \"1\" or arr[three]\
    \ == \"1\" or arr[four] == \"1\" or arr[five] == \"1\"\n    \n    one_is_bigger\
    \ = [one]\n    two_is_bigger = [two]\n    three_is_bigger = [three]\n    four_is_bigger\
    \ = [four]\n    five_is_bigger = [five]", "  # sort based on number of 1s in binary\n\
    \  arr.sort{|a, b| a.to_s.length <=> b.to_s.length}\n  # sort based on decimal\n\
    \  arr.sort{|a, b| a.to_i <=> b.to_i}\nend", "  return arr.sort.call(arr.reduce(:+)\
    \ / arr.size)\nend", "  arr.sort { |a, b| b - a }\nend", "  arr.sort!\n  arr.map\
    \ do |e|\n    if e.is_a?(Integer)\n      1 if e.to_s(2).length == 2 && e.to_s(2).to_i(2)\
    \ >= 10\n    elsif e.is_a?(Float)\n      1 if e.to_s(2).length == 2 && e.to_s(2).to_i(2)\
    \ >= 10\n    end\n  end\nend", "  return arr\nend", "  arr.sort! {|x,y| x > y}\
    \ if arr.is_a? Array\n  arr\nend", "  arr.sort! {|a, b| a <=> b}\n  arr\nend",
  "  arr.sort.with_index do |a, b|\n    \n    # check how many 1's are in binary representation\
    \ of arr\n    # a should be more than b\n    ones_count = a / 2\n    bin_count\
    \ = b / 2\n    \n    # check how many 1's are in decimal representation of arr\n\
    \    # a should be more than b\n    ones_count_in_decimal = a.to_f / 10.0\n  \
    \  bin_count_in_decimal = b.to_f / 10.0\n    \n    # check which decimal value\
    \ is higher if there are more than ones\n    # for example\n    # if arr = [1,\
    \ 5]\n    # ones_count = 4\n    # bin_count = 2\n    # ones_count_in_decimal =\
    \ 2\n    # bin_count_in_decimal = 4\n    if ones_count > bin_count \n      decimal_value\
    \ = ones_count_in_decimal\n    else\n      decimal_value = bin_count_in_decimal\n\
    \    end\n    \n    # check if decimal_value is smaller than 0\n    \n    # if\
    \ a is less than b\n    if decimal_value < 0.0\n      -1\n    # if a is greater\
    \ than b\n    else\n      1\n    end\n  end\nend", "  # TODO: Use two loops to\
    \ sort arr\n  pass", "\tlocal a1 = {\n\t\t[1] = 3,\n\t\t[2] = 4,\n\t\t[3] = 6,\n\
    \t\t[4] = 9,\n\t\t[5] = 7,\n\t\t[6] = 8,\n\t}\n\tlocal a2 = {\n\t\t[1] = 1,\n\t\
    \t[2] = 2,\n\t\t[3] = 3,\n\t\t[4] = 4,\n\t\t[5] = 5,\n\t\t[6] = 6,\n\t\t[7] =\
    \ 7,\n\t\t[8] = 8,\n\t}\n\tlocal a3 = {\n\t\t[1] = 10,\n\t\t[2] = 11,\n\t\t[3]\
    \ = 12,\n\t\t[4] = 13,\n\t\t[5] = 14,\n\t\t[6] = 15,\n\t\t[7] = 16,\n\t\t[8] =\
    \ 17,\n\t}\n\tlocal a4 = {\n\t\t[1] = 20,\n\t\t[2] = 21,\n\t\t[3] = 22,\n\t\t\
    [4] = 23,\n\t\t[5] = 24,\n\t\t[6] = 25,\n\t\t[7] = 26,\n\t\t[8] = 27,\n\t}\n\t\
    local a5 = {\n\t\t[1] = 30,\n\t\t[2] = 31,\n\t\t[3] = 32,\n\t\t[4] = 33,\n\t\t\
    [5] = 34,\n\t\t[6] = 35,\n\t\t[7] = 36,\n\t\t[8] = 37,\n\t}\n\tlocal a6 = {\n\t\
    \t[1] = 40,\n\t\t[2] = 41,\n\t\t[3] = 42,\n\t\t[4] = 43,\n\t\t[5] = 44,\n\t\t\
    [6] = 45,\n\t\t[7] = 46,\n\t\t[8] = 47,\n\t}\n\tlocal a7 = {\n\t\t[1] = 50,\n\t\
    \t[2] = 51,\n\t\t[3] = 52,\n\t\t[4] = 53,\n\t\t[5] = 54,\n\t\t[6] = 55,\n\t\t\
    [7] = 56,\n\t\t[8] = 57,\n\t}\n\tlocal a8 = {\n\t\t[1] = 60,\n\t\t[2] = 61,\n\t\
    \t[3] = 62,\n\t\t[4] = 63,\n\t\t[5] = 64,\n\t\t[6] = 65,\n\t\t[7] = 66,\n\t\t\
    [8] = 67,\n\t}\n\tlocal a9 = {\n\t\t[1] = 70,\n\t\t[2] = 71,\n\t\t[3] = 72,\n\t\
    \t[4] = 73,\n\t\t[5] = 74,\n\t\t[6] = 75,\n\t\t[7] = 76,\n\t\t[8] = 77,\n\t}\n\
    \tlocal a10 = {\n\t\t[1] = 80,\n\t\t[2] = 81,\n\t\t[3] = 82,\n\t\t[4] = 83,\n\t\
    \t[5] = 84,\n\t\t[6] = 85,\n\t\t[7] = 86,\n\t\t[8] = 87,\n\t}\n\tlocal a11 = {\n\
    \t\t[1] = 90,\n\t\t[2] = 91,\n\t\t[3] = 92,\n\t\t[4] = 93,\n\t\t[5] = 94,\n\t\t\
    [6] = 95,\n\t\t", "    count = 0\n    arr.each_with_index do |n,i|\n        puts\
    \ \"The count is #{count}\"\n        count += 1\n        puts arr[i]\n       \
    \ puts n\n        puts n.to_s\n        puts n.to_i\n        puts n.abs\n     \
    \   puts n.abs\n        puts n.abs\n        puts n.abs\n        puts n.abs\n \
    \       puts n.abs\n        puts n.abs\n        puts n.abs\n        puts n.abs\n\
    \        puts n.abs\n        puts n.abs\n        puts n.abs\n        puts n.abs\n\
    \        puts n.abs\n        puts n.abs\n        puts n.abs\n        puts n.abs\n\
    \        puts n.abs\n        puts n.abs\n        puts n.abs\n        puts n.abs\n\
    \        puts n.abs\n        puts n.abs\n        puts n.abs\n        puts n.abs\n\
    \        puts n.abs\n        puts n.abs\n        puts n.abs\n        puts n.abs\n\
    \        puts n.abs\n        puts n.abs\n        puts n.abs\n        puts n.abs\n\
    \        puts n.abs\n        puts n.abs\n        puts n.abs\n        puts n.abs\n\
    \        puts n.abs\n        puts n.abs\n        puts n.abs\n        puts n.abs\n\
    \        puts n.abs\n        puts n.abs\n        puts n.abs\n        puts n.abs\n\
    \        puts n.abs\n        puts n.abs\n        puts n.abs\n        puts n.abs\n\
    \        puts n.abs\n        puts n.abs\n        puts n.abs\n        puts n.abs\n\
    \        puts n.abs\n        puts n.abs\n        puts n.abs\n        puts n.abs\n\
    \        puts n.abs\n        puts n.abs\n        puts n.abs\n        puts n.abs\n\
    \        puts n.abs\n        puts n.abs\n        puts n.abs\n        puts n.abs\n\
    \        puts n.abs\n        puts n.abs\n        puts n.abs\n        puts n.abs\n\
    \        puts n.abs\n        puts n.abs\n        puts n.abs\n        puts n.abs\n\
    \        puts n.abs\n        puts n.abs\n        puts n.abs\n        puts n.",
  "  \n  # sort by number of ones\n  sorted_array = arr.sort do |a, b|\n    a_ones\
    \ = a.to_s(2).count(\"1\")\n    b_ones = b.to_s(2).count(\"1\")\n    a_ones ==\
    \ b_ones ? a.to_i(10).to_s(2) : a.to_i(10).to_s(10).to_i(10).to_s(2)\n  end\n\
    \  \n  # sort by decimal value\n  sorted_array.sort! do |a, b|\n    a_num = a.to_i(10)\n\
    \    b_num = b.to_i(10)\n    a_num - b_num\n  end\n  \n  sorted_array\nend", " \
    \ return arr.sort{|a, b| a <=> b}\nend", "  arr = arr.sort.call(arr)\n  i = 0\n\
    \  while i < arr.size - 1\n    if arr[i+1] - arr[i] == 1\n      arr.swap!(i+1,\
    \ i)\n      i += 1\n    else\n      i += 1\n  end\nend\n</pre>", "  return arr\n\
    end", "  arr.sort!\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\n\
    The `sort_by` solution does not work: \n`sort_array.call([1,5,2,3,4]).sort`\n\
    <|/ c |>\n<| a |>\nIf you want more efficient and elegant solution, you can use\
    \ Integer#bit_length.\n<code>", "  return nil\nend", "  arr.sort!{|a, b| a.to_s.split('').map(&:to_i).inject(0){|s,\
    \ i| s + (1 << i) * b}}\nend\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| c |>\n\
    Nice solution, but it won't work if the array contains negative integers, e.g.\
    \ `sort_array([-20, -3, 0, -1, -2, 4])`.\n<|/ c |>\n<| c |>\nRight, my bad, thank\
    \ you for noticing. I updated my answer with your remark.\n<|/ c |>\n<| a tags=ruby\
    \ dscore=1 |>\nYou can try this - \n<code>\narr = [1, 5, 2, 3, 4]\narr.sort! {\
    \ |a, b| a.to_s.reverse.to_i(2).to_s <= b.to_s.reverse.to_i(2).to_s }\n</code>\n\
    Explanation - \n<code>\n1.to_s.reverse.to_i(2)\n</code>\nConverts first number\
    \ to string. Then reverse it, then convert it to integer. And finally convert\
    \ it back to string and return it.\n<code>\n'1'.to_s.reverse.to_i(2)\n</code>\n\
    For input 1, above function will give 2 as output. \n<code>\n'2'.to_s.reverse.to_i(2)\n\
    </code>\nFor input 2, above function will give 1 as output.\n<code>\n'5'.to_s.reverse.to_i(2)\n\
    </code>\nFor input 5, above function will give 5 as output.\n<code>\n'2'.to_s.reverse.to_i(5)\n\
    </code>\nFor input 2, above function will give 5 as output.\n<code>\n'5'.to_s.reverse.to_i(5)\n\
    </code>\nFor input 5, above function will give 5 as output.\n<code>\n'1'.to_s.reverse.to_i(5)\n\
    </code>\nFor input 1, above function will give 5 as output.\n<code>\n'2'.to_s.reverse.to_i(5)\n\
    </code>\nFor input 2, above function will give 5 as output.\n<code>\n'3'.to_s.reverse.to_i(2)\n\
    </code>\nFor input 3, above function will give 2 as output.\n<code>\n'4'.to_s.reverse.to_i(2)\n\
    </code>\nFor input 4, above function will give 2 as output.\n<code>\n'3'.to_s.reverse.to_i(5)\n\
    </code>\nFor input 3, above function will give 5 as output.\n<code>\n'4'.to_s.reverse.to_i(5)\n\
    </code>\nFor input 4, above function will give 5 as output.\n<code>\n'4'.to_s.reverse.to_i(5)\n\
    </code>\nFor input 4, above function will give 5 as output.\n<code>\n'3", "  #\
    \ Your code here\n  # return sorted(arr)\n  arr.sort\n  arr.sort!\n  arr\nend",
  "  arr.each_with_index do |elem, idx|\n    if elem>0\n      arr[idx], arr[idx+1]\
    \ = arr[idx+1], arr[idx]\n    end\n  end\n  return arr\nend", "  arr.sort\n  arr.map\
    \ { |e| e > 0 ? e : -(-e) }.sort\nend", "  arr.sort\nend", "  arr.sort.with_index\
    \ { |a, b| b.zero? || a.zero? ? a.nonzero[0].zero? ? b.nonzero[0].zero? ? a.nonzero[0].nonzero[0]\
    \ : a.nonzero[0].nonzero[0].zero? ? a.nonzero[0] : a : b }\nend", "  n = arr.size\n\
    \  arr.sort!\n  arr.reduce(0) {|sum, el| sum + el}\nend", "  return arr\nend",
  "  arr.sort\nend", "    arr.sort!\n    i = 0\n    len = arr.length\n    while i\
    \ < len\n        i += 1\n        tmp = arr[i]\n        j = i\n        while j\
    \ > 0 and tmp == arr[j - 1]\n            j -= 1\n        end\n        if j ==\
    \ 0\n            arr[i] = arr[j]\n        else\n            arr[i] = arr[j] +\
    \ 1\n            arr[j] = tmp\n        end\n    end\n    arr\nend", "  arr.sort!\n\
    end\n</cell>\n<cell>\nsort_array([1, 5, 2, 3, 4])\n</cell>\n<cell>\nsort_array([-2,\
    \ -3, -4, -5, -6])\n</cell>\n<cell>\nsort_array([1, 0, 2, 3, 4])\n</cell>\n<text>\n\
    Exercise 4: Sort an array with duplicate elements\nWrite a method to sort an array\
    \ with duplicate elements. A duplicate element is an element that is equal to\
    \ the previous element in the array. Return nil if there are no duplicate elements\
    \ in the array.", "  arr.sort do |a, b|\n    ones = (b & 1) == 0 ? 0 : -1\n  \
    \  zeros = (b & 1) == 0 ? 0 : +1\n    dec = (a ^ (b << 1)) * ones\n    dec ==\
    \ 0 ? zeros : dec\n  end\nend", "  arr.sort!\nend", "  arr.sort!\nend", '  arr.sort!',
  "  return arr.reverse.sort.join ''\nend", "  arr.sort! { |a, b| (a & 1) == (b &\
    \ 1) ? (a <=> b) : ((a & 1) <=> (b & 1) ? -1 : 1) }\nend", "  return [] if arr.empty?\
    \ else arr.sort_by { |i| dec2bin(i).count(\"1\") }\nend", "    arr.sort!\n   \
    \ arr.map { |x| x.zero? ? Float::INFINITY : -x.nonzero? }\nend", "  n = arr.size\n\
    \  if n < 2\n    arr\n  else\n    binary = arr.map { |e| (e % 2).zero? }.reduce(:+)\n\
    \    sorted = (arr - binary).sort", "  arr[0].zero? ? arr : arr.sort_by{ |x| x.to_s(2)\
    \ }\nend", '  arr.sort!']
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
