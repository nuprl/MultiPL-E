name: HumanEval_161_solve
language: rb
prompt: "# You are given a string s.\n# if s[i] is a letter, reverse its case from\
  \ lower to upper or vise versa, \n# otherwise keep it as it is.\n# If the string\
  \ contains no letters, reverse the string.\n# The function should return the resulted\
  \ string.\n# Examples\n# >>> solve.call(\"1234\")\n# \"4321\"\n# >>> solve.call(\"\
  ab\")\n# \"AB\"\n# >>> solve.call(\"#a@C\")\n# \"#A@c\"\ndef solve(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solve\n\
  \    candidate = method(:solve)\n    assert_equal(\"aSdF\", candidate.call(\"AsDf\"\
  ))\n    assert_equal(\"4321\", candidate.call(\"1234\"))\n    assert_equal(\"AB\"\
  , candidate.call(\"ab\"))\n    assert_equal(\"#A@c\", candidate.call(\"#a@C\"))\n\
  \    assert_equal(\"#aSDFw^45\", candidate.call(\"#AsdfW^45\"))\n    assert_equal(\"\
  2@6#\", candidate.call(\"#6@2\"))\n    assert_equal(\"#$A^d\", candidate.call(\"\
  #$a^D\"))\n    assert_equal(\"#CCC\", candidate.call(\"#ccc\"))\n  end\nend\n"
completions: ["    str = s.split(\"\").reverse().join(\"\")\n    return str\n</cell>\n\
    <cell>", "  s = s.downcase\n  s.gsub!(/\\d/, '') \n  if s.include?('') \n    s.gsub!(/\\\
    d/, '')\n  else \n    s = s.reverse\n  end\n  return s\nend", "    s = s.downcase\n\
    \    \n    i = 0\n    l = s.length\n    \n    while i < l\n        if s[i] ==\
    \ ?\n            s[i] = ?\n        else\n            s[i] = ?\n        i += 1\n\
    \    end", "  s.downcase!\n  s.gsub(/[[:alpha:]]/) do |c|\n    c =~ /[a-z]/i\n\
    \    c.upcase!\n    c.swapcase\n  end\n  return s\nend", "  result = \"\"\n  s.chars.each\
    \ do |letter|\n    if letter.is_a? Integer\n      result << letter\n    else\n\
    \      if letter.upcase\n        result += letter.downcase\n      else\n     \
    \   result += letter.upcase\n      end\n    end\n  end\n  result\nend\n</code>\n\
    Ruby 2.3 has some new syntax that might help make this more readable.  Ruby 2.3\
    \ added a String#reverse method, which can be used to simplify the code a bit:\n\
    <code>", "  result = s.gsub(/[[:alpha:]]/) { |c| c.upcase }\n  result = result.gsub(/[[:alpha:]]/)\
    \ { |c| c.downcase }\n  result = result.gsub(/[[:digit:]]/) { |c| c.to_i }\n \
    \ result\nend", "  s.downcase!\n  return s.gsub(/[a-z]/i) do |match|\n    if match.is_a?\
    \ String\n      match.upcase\n    else\n      match\n    end\n  end\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=1 |>\nUse this one-liner:\n<code>\ns.chars.map(&:upcase).join\n\
    </code>\n<|/ a tags=ruby,string |>\n<| a dscore=0 tags=ruby,string |>\n<code>\n\
    s.gsub(/./){|c| c.upcase if c.isupper}.join\n</code>\n<|/ a |>\n<| a |>\n<code>",
  "  return s.chars.reduce(&:capitalize!).\n    chars.reduce(&:swapcase!).\n    chars.reduce(&:reverse!).\n\
    \    join\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby dscore=1 |>\n<code>",
  "  s.chars.each do |ch|\n    if ch.match(/[a-z]/)\n      s.chars.replace(ch,ch.upcase)\n\
    \    elsif ch.match(/[A-Z]/)\n      s.chars.replace(ch,ch.downcase)\n    else\n\
    \      s.chars.replace(ch,ch)\n    end\n  end\n  s.chars.reverse\nend\n</code>\n\
    <|/ a tags=string,ruby,recursion |>\n<| c |>\nI believe this can be solved with\
    \ just one regexp using negative look behind and lookahead like this: `s.gsub(/(?<=[a-z])(?=[A-Z])|(?<=[A-Z])(?=[a-z])/)\
    \ { |s| s.upcase + s.downcase }` See https://rubular.com/r/M3jYJgZPfGp7HV7\n<|/\
    \ c |>\n<| a |>\n<code>", "\ts.downcase!\n\ts.gsub!(/[[:alpha:]]/) { |s| s[/[a-z]/i\
    \ ? s[/[a-z]/i].upcase : s[/[a-z]/i] }\n\ts.gsub!(/[^[:alpha:]]/) { |s| s[/[^a-z]/i\
    \ ? s[/[^a-z]/i].downcase : s[/[^a-z]/i] }\n\ts\nend\n</cell>\n<cell>", "    string=\"\
    \"\n    i=0\n    while i < s.length\n        if s[i] >= \"a\" and s[i] <= \"z\"\
    \n            string+=s[i].downcase.to_s\n            i+=1\n        else\n   \
    \         string+=s[i]\n            i+=1\n    end\n    string.reverse!\n    return\
    \ string\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis code will give wrong\
    \ output for input \"#a@C\"\n<|/ c |>\n<| c |>\nGood point, that's a problem with\
    \ this solution as well\n<|/ c |>\n<| c |>\nyes you are right, updated the code\
    \ with another solution using Regex\n<|/ c |>\n<| a dscore=3 tags=ruby,ruby-on-rails,string\
    \ |>\nAnother way:\n<code>", "    s = s.to_s\n    if s.length == 0\n        puts\
    \ \"#{s}\".to_s\n    else\n        \n        if s[0].is_a? String \n         \
    \   s.map {|x| x[0].upcase + x[1].downcase }.join(\"\") \n        else\n     \
    \       s.upcase \n        end\n    end\nend", "  # Your code here\n  return s.gsub(/./)\
    \ { |char| char.downcase if char.upcase == char || char.downcase == char || char.upcase\
    \ == char.upcase ? \"#{char}\" : char }\nend", "  str = s.downcase\n  str.gsub(/[a-z]/)\
    \ { |l| l[l.downcase.length..-1].upcase }\nend", "  s = s[0].upcase + s[1..-1].downcase\n\
    \  s.length == 0 ? s = \"123\" : s\nend", "    return s.gsub(/(\\p{L}*)/){|l|\
    \ l.upcase }\nend\n    ", "    return solve.helper(s)\nend\n</cell>\n<code language=julia-0.5>\n\
    solve.helper(s)\n</cell>\n<text>\nTests", "    # write your code here\n    if\
    \ s.length == 0 \n        return s \n    i = 0\n    while i < s.length \n    \
    \    if s[i] == ?? \n            i = i + 1 \n            if i == s.length \n \
    \               return s \n        else \n            s = s.insert(i, ??) \n \
    \           i = i + 1 \n    \n    return s \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        ", "  if s.length == 0 then return s\n  if s.to_s.length == 0 then\
    \ return s.to_s\n  \n  case s[0]\n    when 'a'..'z' then s.to_s.reverse!\n   \
    \ when 'A'..'Z' then s.to_s.reverse!\n    else s.to_s\n  end\n  \n  s\nend", " \
    \ s.tr!('A-Z', 'a-z')\n  s.tr!('a-z', 'A-Z')\n  s.reverse!\nend\n</code>\n<|/\
    \ a tags=ruby |>\n<| c |>\nI ran your proposed solution and I noticed that your\
    \ solution is case sensitive, whereas mine is not. How do I get your proposed\
    \ solution to be case sensitive? When I tried my proposed solution, I received\
    \ the following error message: \"NoMethodError: undefined method `tr' for \"abcde\"\
    :String\"\n<|/ c |>\n<| c |>\nI figured it out. Just needed to add \"i\" to the\
    \ end of your solution. Thanks!\n<|/ c |>\n<| c |>\nI did add an `i` to the end\
    \ of my proposed solution but that doesn't seem to solve my problem. When I run\
    \ your solution, it prints out the same thing as my code. I also added my code\
    \ to the main body of my question. Thanks!\n<|/ c |>\n<| c |>\nYes, my code was\
    \ missing an 'i' at the end of it. When I added that 'i' to the end of my code,\
    \ it worked. Thanks!\n<|/ c |>\n<| c |>\nI believe this solution is wrong in some\
    \ cases. For example: when `s` is `\"aBc\"` then it returns `\"ABC\"`. On the\
    \ other hand, when `s` is `\"aBc\"` then it returns `\"AABC\"`. That is not what\
    \ we expect.\n<|/ c |>\n<| a tags=ruby dscore=0 |>\n<code>", "    # write your\
    \ code in Ruby here\n    return s.tr(/[[:alpha:]]/).map(&:upcase).join\nend\n\
    </code>\n<|/ a dscore=4 tags=ruby,string |>\n<| c |>\nRuby 2.4 added `String#reverse`.\n\
    <|/ c |>\n<| a dscore=4 tags=ruby,string |>\n<code>", "  s = s.dup\n  \n  s.reverse!",
  "  s.reverse!\n  s.gsub!(/[a-z]/i) do |letter|\n    letter == letter ? letter.upcase\
    \ : letter\n  end\n  s.reverse!\nend\n</cell>\n<code language=julia-1.0>\n@time\
    \ solve(@beluga[\"c\"])\n</cell>\n<code language=julia-1.0>\n@time solve(@beluga[\"\
    aaa\"])\n</cell>\n<code language=julia-1.0>\n@time solve(@beluga[\"c#a\"])\n</cell>\n\
    <text>\nChallenge 3", "  s = s.chars.reverse # reverse the string\n  return s.gsub!(/[a-z]/)\
    \ { |m| m.upcase } ? s.gsub!(/[a-z]/) { |m| m.downcase } : s\nend\n</code>\n<|/\
    \ a tags=ruby,regex |>\n<| a dscore=2 |>\nA slight tweak to 's answer, which was\
    \ also helpful in solving this problem, might be:\n<code>", "  s.chars.reverse_each.with_index.reduce(:+)\n\
    end", "\tres=''\n\tfor char in s\n\t\tif char.upcase != char.downcase\n\t\t\t\
    char.upcase!='?'\n\t\t\tchar.downcase!='?'\n\t\tres+=char\n\tres\nend", "  result\
    \ = \"\"\n  s.each_char do |c|\n    result << c.downcase if c.upcase == c\n  \
    \  result << c.upcase if c.downcase == c\n  end\n  result\nend", "  s = s[0]\n\
    \  return s[0] + s.reverse.split(//).join.upcase if s[0] && s[0].length > 0 else\
    \ \"\"\nend", "  new_s = s\n  case 0 new_s << new_s << new_s << new_s\n  case\
    \ 1 new_s << new_s\n  case 2 new_s\n  case 3 new_s << new_s\n  case 4 new_s <<\
    \ new_s << new_s\n  case 5 new_s << new_s << new_s << new_s\n  case 6 new_s <<\
    \ new_s << new_s\n  case 7 new_s << new_s << new_s\n  case 8 new_s << new_s <<\
    \ new_s\n  case 9 new_s << new_s\n  case 10 new_s << new_s << new_s << new_s\n\
    \  case 11 new_s << new_s << new_s << new_s << new_s\n  case 12 new_s << new_s\
    \ << new_s << new_s << new_s << new_s\n  case 13 new_s << new_s << new_s << new_s\
    \ << new_s << new_s << new_s\n  case 14 new_s << new_s << new_s << new_s << new_s\
    \ << new_s << new_s << new_s\n  case 15 new_s << new_s << new_s << new_s << new_s\
    \ << new_s << new_s << new_s << new_s\n  case 16 new_s << new_s << new_s << new_s\
    \ << new_s << new_s << new_s << new_s << new_s\n  case 17 new_s << new_s << new_s\
    \ << new_s << new_s << new_s << new_s << new_s << new_s\n  case 18 new_s << new_s\
    \ << new_s << new_s << new_s << new_s << new_s << new_s << new_s\n  case 19 new_s\
    \ << new_s << new_s << new_s << new_s << new_s << new_s << new_s << new_s << new_s\n\
    \  case 20 new_s << new_s << new_s << new_s << new_s << new_s << new_s << new_s\
    \ << new_s << new_s\n  case 21 new_s << new_s << new_s << new_s << new_s << new_s\
    \ << new_s << new_s << new_s << new_s\n  case 22 new_s << new_s << new_s << new_s\
    \ << new_s << new_s << new_s << new_s << new_s << new_s\n  case 23 new_s << new_s\
    \ << new_s << new_s << new_s << new_s << new_s << new_s << new_s << new_s\n  case\
    \ 24 new_s << ", "  s = s.split(\"\")\n  s.map!(&:to_i)\n  s[0].downcase! if s.empty?\n\
    \  s.each{|x| x.upcase! if x.length == 1}\n  s.join(\"\")\nend\n</code>\n<|/ a\
    \ tags=ruby,arrays |>\n<| c |>\nNice solution, but you should at least explain\
    \ the reason for the changes. Otherwise others can learn from your answer.\n<|/\
    \ c |>\n<| c |>\n: I added some explanation and tested it on a large sample dataset.\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>", "  letters = s.to_s.chars\n  letters.each\
    \ do |letter|\n    if letter.downcase == letter\n      letter = letter.upcase\n\
    \    end\n  end\n  return s.to_s\nend", "  s = s.downcase\n  letter = s.gsub(/[a-z_]/i)\
    \ { |x| x.upcase }\n  letter = letter.to_s.reverse\n  letter.length == 0 ? s.reverse\
    \ : letter\nend\n</code>\n<|/ a tags=ruby |>\n<| a |>\nA more functional approach:\n\
    <code>", "  s = downcase(s)\n  return s.empty? ? downcase(s) : s\nend\n</cell>\n\
    <code language=julia-1.5>\nsolve(\"1234\")\n</cell>\n<code language=julia-1.5>\n\
    solve(\"ab\")\n</cell>\n<code language=julia-1.5>\nsolve(\"#a@C\")\n</cell>\n\
    <code language=julia-1.5>\nsolve(\"abc\")\n</cell>\n<code language=julia-1.5>\n\
    solve(\"a@C\")\n</cell>\n<text>\nProblem 8", "  case 1\n    # case 1\n    when\
    \ s[0]\n      s.reverse!\n    when s[0].upcase\n      s.reverse!\n    when s[0].downcase\n\
    \      s.reverse!\n  end\n  s\nend", "  s.split('').each_with_index {|x, i| break\
    \ if   x.nil? or x.empty? or x[0].upcase !~ /[a-zA-Z]/} \n  s.split('').each_with_index\
    \ {|x, i| break if   x.nil? or x.empty? or x.downcase !~ /[a-zA-Z]/}\nend", " \
    \   str_s = s.split(//).join\n    return str_s.downcase.sub(/./) { |c|\n     \
    \   case c\n        when 'a'..'z' then c.upcase\n        when 'A'..'Z' then c.downcase\n\
    \        else c\n        end\n    }\nend", "  return s.downcase! unless /\\A[A-Za-z]/.match(s)\n\
    \  s.split('').map { |x| x.gsub(/\\A[a-z]/, x.upcase) }.join(\"\")\nend", "  s.split('').map{|char|\
    \ char.downcase if char =~ /[[:alpha:]]/}.join('')\nend\n</code>\n<|/ a |>\n<|\
    \ a |>\n<code>", "  # Write your code in Ruby\n  new_string = \"\"\n  s.each_char\
    \ do |c|\n    if c.upcase == c\n      new_string += c.downcase\n    else\n   \
    \   new_string += c\n    end\n  end\n  new_string.reverse!\n  return new_string\n\
    end", "  \n  return s.downcase.gsub(/[[:alpha:]]/) {|m| m.upcase }\nend", "  return\
    \ s.reverse.gsub(/[a-z]/i) do |x|\n    x.upcase != x ? x : x.downcase\n  end\n\
    end\n</code>\n<|/ a |>\n<| c |>\nYeah, this is definitely the better answer, although\
    \ it can be shortened a bit: `return s.gsub(/[a-z]/i) do |x| x.upcase != x ? x\
    \ : x.downcase end`. And you don't need `return` here because `gsub` returns nil.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "  return s.chars.map { |i| i == \"a\" ?\
    \ \"A\" : i == \"b\" ? \"B\" : i == \"c\" ? \"C\" : i }.join\nend", "  s.chars.each\
    \ do |i|\n    if i.is_a? Integer\n      i.to_s\n    else\n      i.downcase\n \
    \   end\n  end\nend", "  str = s.to_s\n  return str if str.empty? else str.reverse\
    \ if str[0].upcase == str[0].downcase else str\nend\n</code>\n<|/ a |>\n<| a tags=ruby\
    \ |>\nA simple way would be to convert your string to an array and call reverse\
    \ on it.\n<code>\n> \"hello world\".split(\"\").reverse.join\n=> \"dlrow olleh\"\
    \n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis approach is better\n<|/ c |>\n<| a\
    \ dscore=3 tags=ruby |>\nA little more general and shorter than the other solutions\
    \ already given by others:\n<code>", "  return s.split('').map{ |x| x.downcase\
    \ }.join\nend\n</cell>\n<text>\nPractice with Hash Codes\nThe following two functions\
    \ should help you get comfortable with hash codes. \nThe first function should\
    \ create a hash code for a string. The hash code should use the function hash\
    \ to create a hash code from another hash code.\nThe second function should return\
    \ the reverse of its string argument.", "  result = ''\n  for i in s\n    if i.is_a?\
    \ String\n      if i.chars.map(&:casecmp('a')) == -1\n        result += i.tr('a',\
    \ 'A')\n      else\n        result += i.tr('a', 'A').tr('b', 'b')\n      end\n\
    \    else # Integer\n      result += 'a'\n    end\n  end\n  \n  return result\
    \ if s.blank?\n  \n  result = ''\n  for i in s\n    if i.is_a? String\n      if\
    \ i.chars.map(&:casecmp('a')) == -1\n        result += i.tr('a', 'A')\n      else\n\
    \        result += i.tr('a', 'A').tr('b', 'b')\n      end\n    else # Integer\n\
    \      result += 'a'\n    end\n  end\n  \n  return result\nend\nputs solve(ARGV[0])",
  "    # Write your code in Ruby here\n    s = s.chars\n    if s.empty?\n        s\n\
    \    else\n        s.select { |c| c.match /[a-zA-Z]/ }.join.chars.reverse\n  \
    \  end\nend\n</code>\n<|/ a |>\n<| c |>\nI think this solution is better than\
    \ mine. Nice use of `select!`.\n<|/ c |>\n<| a |>\nYou can try this \n<code>",
  "    letters = Array.new\n    letters.each {|char| char.downcase!}\n    s.split(\"\
    \").each {|char| char.include?(\"a\")?letters.push(\"A\"):letters.push(char)}\n\
    \    letters.join(\"\")\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>", " \
    \   \n    return s.gsub(/[[:alpha:]]/) {|char| char.swapcase}\nend", "  str =\
    \ s.downcase\n  str.gsub!(/[^a-z]/i, '')\n  str.gsub!(/([a-z])/) { $1.upcase }\n\
    \  str.gsub!(/([A-Z])/) { $1.downcase }\n  str.gsub!(/./) { |match| match.upcase\
    \ }\n  str.gsub!(/.$/, '')\n  str\nend", "  s.to_s.split(\"\").map do |letter|\n\
    \    if letter.downcase == letter\n      letter.upcase\n    else\n      letter\n\
    \    end\n  end.join(\"\")\nend", "    s = \"\" if s == \"\" or s[0] == \"#\"\
    \ else s\n    return s.tr(\"A-Z\", \"a-z\").downcase.tr(\"a-z\", \"A-Z\")\nend",
  "  s.split('').map do |e| \n    if e.match(/^[a-z]/i) and e.upcase != e \n     \
    \ e.upcase\n    elsif e.match(/^[A-Z]/i) and e.downcase != e\n      e.downcase\n\
    \    else\n      e\n    end\n  end.join('')\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| a tags=ruby,regex dscore=0 |>\nI like what user1140259 did on his code. Here\
    \ is a more Ruby like version. \n<code>", "  s = s.to_s\n  s.chars.map! { |char|\
    \ char.ord }\n  s.chars.each do |char|\n    if char.between?(97..122)\n      char.downcase!\n\
    \    elsif char.between?(65..90)\n      char.upcase!\n    end\n  end\n  s.downcase!\n\
    \  s.reverse!\n  return s\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis is a\
    \ cool solution. Sadly, it runs in O(n^2). I'd love to see a solution using regular\
    \ expressions or a hash of some sort.\n<|/ c |>\n<| c |>\nI like that you use\
    \ map!. Also, you should probably call chars.sort to make the results more consistent.\n\
    <|/ c |>\n<| c |>\nThanks for the feedback.  I have added a sort() to the solution.\n\
    <|/ c |>\n<| a tags=ruby,regex dscore=2 |>\n<code>", "    s.dup.chars.map { |c|\
    \ c.capitalize if c.is_a?(String) && c[0] =~ /^[a-z]/i }.reduce { |t,c| t ? c.reverse\
    \ : c }\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  new_string\
    \ = \"\"\n  s.each_byte do |char|\n    if char.upcase == char\n      new_string\
    \ << char.downcase\n    else\n      new_string << char\n    end\n  end\n  new_string.reverse\n\
    end", "  s = s.downcase\n  s = s.gsub(/[[:alpha:]]/) { |s| s.length == 1 ? s.reverse\
    \ : s }\n  s = s.gsub(/[[:punct:]]/) { |s| s.length == 1 ? '' : \"#{$~[-1..-1]}\"\
    \ }\n  s\nend", "  return s.reverse if s.index('@') < s.length else s\nend", " \
    \ s.gsub!(/./) { |c| c.ord < 96 ? c.chr[c.ord - 87].upcase : c.chr[c.ord - 97].downcase\
    \ }\n  s.gsub!(/[^[:alpha:]]/) { |c| c.upcase }\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| a tags=ruby,string dscore=2 |>\nHere is a very simple way (without gsub)\
    \ that works in Ruby 1.8.7 and 1.9\n<code>", "\ts = s.downcase\n\t\n\t# If the\
    \ given string has zero length\n\tif s.length == 0 \n\t\n\t\t# return the given\
    \ string.\n\t\treturn s\n\t\n\t# Find the length of the string\n\tlen = s.length\n\
    \t\n\t# If the length is odd\n\tif len % 2 != 0\n\t\n\t\t# Return the given string\
    \ with the first letter in upper case\n\t\t# ex: input = #a@C\n\t\t# output =\
    \ #A@C\n\t\ts.gsub!(/./) {|x| x.upcase }\n\t\n\t\t# Return the given string with\
    \ the first letter in lower case\n\t\t# ex: input = #a@C\n\t\t# output = #a@c\n\
    \t\ts.gsub!(/./) {|x| x.downcase }\n\t\n\t# If the length is even\n\telse\n\t\n\
    \t\t# Return the given string with the first letter in upper case\n\t\t# ex: input\
    \ = ab\n\t\t# output = AB\n\t\ts.gsub!(/./) {|x| x.upcase }\n\t\t\n\t\t# Return\
    \ the given string with the first letter in lower case\n\t\t# ex: input = ab\n\
    \t\t# output = ab\n\t\ts.gsub!(/./) {|x| x.downcase }\n\tend\n\t\n\t# Return the\
    \ string\n\treturn s\nend", "  s = s.split('')\n  s.each do |char|\n    char.upcase!\
    \ if char.upcase == char\n  end\n  s.join\nend", "  # +++your code here+++\n \
    \ s.scan(/./) { |c| c =~ /[a-z]/i ? c.upcase : c.downcase }\n  s.to_s\nend", " \
    \   puts s.reverse if s.count > 0\n    puts s.reverse.gsub(/[a-z]/i) do |match|\n\
    \        case match\n        when \"a\"\n            \"A\"\n        when \"b\"\
    \n            \"B\"\n        when \"c\"\n            \"C\"\n        when \"d\"\
    \n            \"D\"\n        when \"e\"\n            \"E\"\n        when \"f\"\
    \n            \"F\"\n        when \"g\"\n            \"G\"\n        when \"h\"\
    \n            \"H\"\n        when \"i\"\n            \"I\"\n        when \"j\"\
    \n            \"J\"\n        when \"k\"\n            \"K\"\n        when \"l\"\
    \n            \"L\"\n        when \"m\"\n            \"M\"\n        when \"n\"\
    \n            \"N\"\n        when \"o\"\n            \"O\"\n        when \"p\"\
    \n            \"P\"\n        when \"q\"\n            \"Q\"\n        when \"r\"\
    \n            \"R\"\n        when \"s\"\n            \"S\"\n        when \"t\"\
    \n            \"T\"\n        when \"u\"\n            \"U\"\n        when \"v\"\
    \n            \"V\"\n        when \"w\"\n            \"W\"\n        when \"x\"\
    \n            \"X\"\n        when \"y\"\n            \"Y\"\n        when \"z\"\
    \n            \"Z\"\n        end\n    end\nend\n</code>\n<|/ a |>\n<| a |>\nHere's\
    \ one way:\n<code>", "    if s.length == 0\n        \"\"\n    else\n        s[0]\
    \ \n    end\nend\n</code>\n<|/ a |>\n<| c |>\nI feel like you really should explain\
    \ your answer\n<|/ c |>\n<| c |>\nI didnt understand what was wrong with my code,\
    \ I tried to debug it myself and I came up with the same code as my post..\n<|/\
    \ c |>\n<| c |>\nPlease review the code in your post. Your solution has syntax\
    \ errors. If you think you found a bug in your code, I believe that you've been\
    \ testing it incorrectly. I recommend that you run your code and verify that it\
    \ works as intended before posting it as a question.\n<|/ c |>\n<| c |>\nThanks,\
    \ I updated the question to include some test cases, I hope that helps.\n<|/ c\
    \ |>\n<| c |>\nThanks a lot for the solution! I actually just finished doing this\
    \ as a kata for my ruby course, it's awesome! I wish there was more people like\
    \ you on this site :)\n<|/ c |>\n<| a tags=ruby,arrays,string dscore=3 |>\nI believe\
    \ this problem could be solved with recursion. \n<code>", "  if s.empty?\n   \
    \ return s\n  else\n    letter = s.split\n    letter.reject! {|c| c.class == String}\n\
    \    letter.reject! {|c| c =~ /[^a-z]/}\n    letter.reject! {|c| c.length < 1}\n\
    \    letter.reject! {|c| c =~ /\\W/}\n    letter.reject! {|c| c =~ /[0-9]/}\n\
    \    letter.reject! {|c| c.length != 1}\n    letter.reject! {|c| c == \"a\"}\n\
    \    letter.reject! {|c| c == \"b\"}\n    letter.reject! {|c| c == \"c\"}\n  \
    \  letter.reject! {|c| c == \"d\"}\n    letter.reject! {|c| c == \"e\"}\n    letter.reject!\
    \ {|c| c == \"f\"}\n    letter.reject! {|c| c == \"g\"}\n    letter.reject! {|c|\
    \ c == \"h\"}\n    letter.reject! {|c| c == \"i\"}\n    letter.reject! {|c| c\
    \ == \"j\"}\n    letter.reject! {|c| c == \"k\"}\n    letter.reject! {|c| c ==\
    \ \"l\"}\n    letter.reject! {|c| c == \"m\"}\n    letter.reject! {|c| c == \"\
    n\"}\n    letter.reject! {|c| c == \"o\"}\n    letter.reject! {|c| c == \"p\"\
    }\n    letter.reject! {|c| c == \"q\"}\n    letter.reject! {|c| c == \"r\"}\n\
    \    letter.reject! {|c| c == \"s\"}\n    letter.reject! {|c| c == \"t\"}\n  \
    \  letter.reject! {|c| c == \"u\"}\n    letter.reject! {|c| c == \"v\"}\n    letter.reject!\
    \ {|c| c == \"w\"}\n    letter.reject! {|c| c == \"x\"}\n    letter.reject! {|c|\
    \ c == \"y\"}\n    letter.reject! {|c| c == \"z\"}\n    letter.reject! {|c| c\
    \ == \"A\"}\n    letter.reject! {|c| c == \"B\"}\n    letter.reject! {|c| ", " \
    \ s.downcase!\n  s.gsub(/[a-z]/) { |match| match.upcase }\n  s.gsub(/[A-Z]/) {\
    \ |match| match.downcase }\n  s.gsub(/[^A-Za-z0-9]/) { |match| match.upcase }\n\
    \  s.gsub(/[^A-Za-z0-9]/) { |match| match.downcase }\nend", "  s.downcase!\n \
    \ s.split(\"\").each do |i|\n    if i.match(/^[a-z]/i)\n      i.upcase!\n    end\n\
    \  end\n  s.split(\"\").join\nend\n</code>\n<|/ a |>\n<| c |>\n`solve.call(\"\
    1234\")` returns `4321` rather than `\"4321\"`\n<|/ c |>\n<| c |>\nGood catch,\
    \ fixed it.\n<|/ c |>\n<| c |>\nHa, I was looking at it too much, just missed\
    \ that. Thanks for pointing it out.\n<|/ c |>\n<| a tags=ruby,regex dscore=2 |>\n\
    <code>", "  a = s.split(\"\")\n  a.each_index do |i|\n    if s[i] == s[i].upcase\n\
    \      a[i] = s[i].downcase\n    elsif s[i] == s[i].downcase\n      a[i] = s[i].upcase\n\
    \    end\n  end\n  a.join \"\"\nend\n</code>\n<|/ a tags=ruby,string,rubygems,function,reverse\
    \ |>\n<| c |>\nI like your solution. Would you mind adding some explanation on\
    \ what your code does and how it works?\n<|/ c |>\n<| a tags=ruby,string,rubygems,function,reverse\
    \ |>\n<code>", "  s.gsub!/[a-z]/i do |x|\n    x.upcase! if x.is_a?(String) &&\
    \ x.length == 1\n    x.downcase! if x.is_a?(String) && x.length == 1 && x[0] !=\
    \ x[0].upcase\n  end\n  s.reverse! if s.nil? || s.length == 0\nend\n</code>\n\
    <|/ a |>\n<| a tags=ruby dscore=0 |>\nI took a stab at it, and I believe it works\
    \ for the following cases:", "  str.capitalize!\n  if s.empty?\n    s = s.reverse\n\
    \  end\n  s.split(\"\").reduce(\"\", :+)\nend", "  str.gsub(/[^a-zA-Z]/,'') \n\
    \  str.gsub(/[a-z]/) { |match| match[0].upcase + match[1].downcase } \n  str.gsub(/[A-Z]/)\
    \ { |match| match[0].downcase + match[1].upcase } \n  str.downcase \nend", " \
    \ s.gsub!(/[^a-zA-Z]/,\"\")\n  s.reverse!\n  s.gsub!(/[a-z]/) do |match|\n   \
    \ match.upcase if match == match.downcase\n  end\n  s.reverse!\n  return s\nend",
  "  if s.empty?\n    \"\"\n  else\n    str = s.chars.map{|x| x.is_a?(String) ? x.downcase\
    \ : x}.join(\"\")\n    str.chars.map{|x| x.is_a?(String) ? x.upcase : x}.join(\"\
    \")\n  end\nend\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| c |>\nPlease explain\
    \ your answer. Also, why are you calling `map` twice?\n<|/ c |>\n<| c |>\nI thought\
    \ it was better to convert each letter to upper or lower case first and then join\
    \ them together after that. Maybe I should use a different method?\n<|/ c |>\n\
    <| c |>\n`map` is not a method in the Ruby core library. Can you please tell us\
    \ what library you're using?\n<|/ c |>\n<| c |>\n\"The function should return\
    \ the resulted string.\" Not my downvote but this is wrong: `map{|x| x.is_a?(String)\
    \ ? x.upcase : x}` should be `map{|x| x.is_a?(String) ? x.upcase : x.to_s}` since\
    \ `String#upcase` is an instance method.\n<|/ c |>\n<| a dscore=0 |>\nThis is\
    \ my Ruby solution:\n<code>", "    l = s.length\n    i = 0\n    while i < l\n\
    \       if s[i] >= 'a' && s[i] <= 'z'\n          s[i] = s[i].upcase\n       else\n\
    \          s[i] = s[i].downcase\n      i += 1\n    return s.reverse\nend", " \
    \   s = s.upcase\n    s.chars.reverse_each.with_index do |char, index|\n     \
    \   if char.upcase == char\n            s = s[0...index] + s[(index + 1)...-1]\n\
    \        end\n    end\n    s\nend", "  s = s.chars\n  case 0\n    when s.length\
    \ == 1\n      s.reverse\n      s.join\n    when s.all? {|ch| ch.match('^[[:alpha:]]+$')}\n\
    \      s.join.reverse\n    when s.all? {|ch| !ch.match('^[[:alpha:]]+$')}\n  \
    \    s.join\n    when s.all? {|ch| ch.upcase != ch.downcase}\n      s.join.reverse\n\
    \    else\n      s.join.reverse\n  end\nend", "  s.gsub!(/[^a-z]/i) { |x| x.upcase\
    \ }.gsub!(/\\@/) { |x| x.upcase }.gsub!(/\\#/) { |x| x.upcase }\n  if s.empty?\n\
    \    s.reverse\n  else\n    s[0] == s[0] ? s[1..-1].reverse! : s\n  end\nend",
  "    sol = \"\"\n    count = 1\n    for x in s\n        if (x.isalpha) ? x.upcase\
    \ : x\n            sol << x\n            count+=1\n        end\n    sol << ((count\
    \ > 1) ? count.to_s+1 : 1) * \" \"\n    puts sol\nend", "  str.split(s).map do\
    \ |i|\n    case i\n    when /^[a-z]/\n      i[1].upcase\n    when /^[A-Z]/\n \
    \     i[0].downcase\n    else\n      i\n    end\n  end.join(\"\")\nend\n</code>\n\
    <|/ a tags=ruby,string,algorithm |>\n<| c |>\n`str` is a class, not a method.\
    \  You'd need to call it using `str.split(\"\")`.\n<|/ c |>\n<| c |>\nThanks for\
    \ pointing that out, fixed it\n<|/ c |>\n<| c |>\nI think you forgot to include\
    \ the word `solve` in the variable name.\n<|/ c |>\n<| c |>\nHm, I'm not sure\
    \ what you mean. Do you mean variable name? It's named `s` at the top of file\n\
    <|/ c |>\n<| c |>\nAh, I see what you mean. The original code has a variable named\
    \ `str`, which refers to the String class itself. I'm assuming you are looking\
    \ for a method that would return a reversed string. I'll update my solution\n\
    <|/ c |>\n<| a dscore=2 tags=ruby,string,algorithm |>\nThis should work:\n<code>",
  "  letters = s.scan(/[a-z]/)\n  letters.each do |letter|\n    letter = letter[0]\n\
    \    break if letters.empty?\n    letters.each do |letter|\n      if letter ==\
    \ letters.shift\n        letter = letter.upcase\n        break\n      end\n  \
    \  end\n  end\n  letters.join\nend", "    return s.reverse.gsub(/./) {|s| s.upcase\
    \ } unless s.chars.all?(&:ascii_only?)\n    s.length == 1 ? s.reverse : s\nend",
  "  s = s.downcase\n  return s.gsub(/[a-z]/i) do |l|\n    l.upcase\n  end\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThis is not working. the returned string\
    \ is not correct. for \"1234\" the result is \"4321\". for \"ab\" the result is\
    \ \"ab\". for \"#a@c\" the result is \"#A@c\"\n<|/ c |>\n<| c |>\nI think you\
    \ missed the '@' in the middle of the string. \n\"#A@c\" should return \"#a@C\"\
    \n<|/ c |>\n<| c |>\nI updated my question to include all of the test cases that\
    \ I was using\n<|/ c |>\n<| a dscore=0 tags=ruby |>\nHow about this:\n<code>",
  "    \n    letters = [i for i in s.split(\"\") if i.isalpha()]\n    letters.reverse()\n\
    \    letters = [i if i.islower() else i.upper() for i in letters]\n    s = ''.join(letters)\n\
    \    \n    return s", "    arr = s.chars.to_a\n    arr.each { |e| return e.upcase\
    \ if e.is_a?(String) }\n    arr.each { |e| return e.downcase }\n    return arr.join\n\
    end\n</code>\n<|/ a tags=ruby,string |>\n<| a |>\n<code>", "  \n  \n  if(s.length\
    \ == 0)\n    return \"0\"\n  if(s.upcase == s.downcase)\n    return s\n  \n  a\
    \ = s.downcase\n  b = \"\"\n  \n  \n  if(s.index(a) == 0)\n    return s\n  \n\
    \  if(s.index(b) == 0)\n    b = s.index(a)\n  \n  \n  c = s.index(a)\n  s = s[:c]\
    \ + s[c+1:].upcase + s[c+1:].downcase\n  \n  \n  if(s.length == 0)\n    return\
    \ s\n  \n  if(s.index(b) == 0)\n    b = s.index(a)\n  \n  \n  c = s.index(a)\n\
    \  s = s[:c] + s[c+1:].upcase + s[c+1:].downcase\n  \n  \n  if(s.length == 0)\n\
    \    return s\n  \n  if(s.index(b) == 0)\n    b = s.index(a)\n  \n  \n  c = s.index(a)\n\
    \  s = s[:c] + s[c+1:].upcase + s[c+1:].downcase\n  \n  \n  if(s.length == 0)\n\
    \    return s\n  \n  if(s.index(b) == 0)\n    b = s.index(a)\n  \n  \n  c = s.index(a)\n\
    \  s = s[:c] + s[c+1:].upcase + s[c+1:].downcase\n  \n  \n  if(s.length == 0)\n\
    \    return s\n  \n  if(s.index(b) == 0)\n    b = s.index(a)\n  \n  \n  c = s.index(a)\n\
    \  s = s[:c] + s[c+1:].upcase + s[c+1:].downcase\n  \n  \n  if(s.length == 0)\n\
    \    return s\n  \n  if(s.index(b) == 0)\n    b = s.index(a)\n  \n  \n  c = s.index(a)\n\
    \  s = s[:c] + s[c+1:].upcase + s[c+1:].downcase\n  \n  \n  if(s.length == 0)\n\
    \    return s\n  \n  if(s.index(b) == 0)\n    b = s.index(a)\n  \n  \n  c = s.index(a)\n\
    \  s = s[:c] + s[c+1:].upcase + s[c+1:].downcase\n  \n  \n  if(s.length == 0)\n\
    \    return s\n  \n  if(s.index(b) == 0)\n    b = s.index(a)\n  \n  \n  c = s.index(a)\n\
    \  s = s[:c] + s[c+1:].upcase + s[c+1:].downcase", "  s = s.chars.join\n  if s.empty?\
    \ then return s end\n  if s.include?(\"@\") then \n    letters = s.chars.map{\
    \ |l| l.downcase }\n    letters.unshift s.slice!(0...1)\n    s = letters.join\n\
    \  end\n  chars = s.chars\n  chars.reverse!\n  chars.join\nend", "  return s.gsub(/[a-z]/)\
    \ {|char| char.upcase } if s[0] =~ /[a-z]/\n  return s.gsub(/[A-Z]/) {|char| char.downcase\
    \ }\nend", "  # your code goes here\n  result = \"\"\n  for i in s\n    if i.is_a?\
    \ String\n      new_result = i.chars.map {|x| x.is_a? String ? x.upcase : x.downcase}\n\
    \      result += new_result.join\n    else result += i\n  end\n  if s.chars.all?(&:is_a?\
    \ String)\n    result.upcase\n  else\n    result\n  end\nend", "    \n    s =\
    \ s.split(\"\")\n    # reverse each string individually\n    s.each do |str|\n\
    \        str = str.upcase if str[0][0].upcase == str[0][0].downcase\n        str\
    \ = str.downcase if str[0][0].upcase == str[0][0].downcase\n    end\n    s = s.join(\"\
    \")\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby dscore=1 |>\n<code>", " \
    \ if s.empty?\n    ''\n  elsif s.start_with?(\"0\")\n    s.reverse\n  elsif s.start_with?(\"\
    1\")\n    s.reverse.gsub(/[#{s.split(//).join(\",\")}]/,'').reverse\n  else\n\
    \    s\n  end\nend", "  s = s.to_s.reverse if s.to_s.include?(\" \") else s.to_s\n\
    \  s.split(\"\").each do |s|\n    if s.chars.map(&:downcase).include?(s.downcase)\n\
    \      s = s.upcase\n    end\n  end\n  s\nend", "  s.downcase! if s.length !=\
    \ 0\n  s\nend\n</cell>\n<text>\nThe solution is in the next cell. Just scroll\
    \ up.", "  s.to_s.reverse! if s[0] =~ /[A-z]/\n  s.to_s.reverse! if s.empty?\n\
    \  s.to_s\nend", "  s = s.to_s\n  s.each_char do |c|\n    if c >= 'a' && c <=\
    \ 'z'\n      s = s.gsub(/[a-z]/, c.downcase)\n    end\n    if c >= 'A' && c <=\
    \ 'Z'\n      s = s.gsub(/[A-Z]/, c.upcase)\n    end\n  end\n  s.reverse!\n  s\n\
    end\n</code>\n<|/ a dscore=3 tags=ruby |>\n<| c |>\nThis is brilliant! My solution\
    \ is almost identical, only that my solution is a tad more efficient.\n<|/ c |>\n\
    <| c |>\nThis is a really good answer. However, I'm glad that you brought up that\
    \ `char.upcase!` method is new (as of ruby 2.4.3). For anyone else who comes across\
    \ this, I found the documentation here: https://www.ruby-lang.org/en/news/2019/12/25/ruby-243-released/#no-more-force-call-for-upcase-and-downcase\n\
    <|/ c |>\n<| a |>\n<code>", "  s.each do |c|\n    if c.upcase != c\n      c.swapcase\n\
    \    elsif c.downcase != c\n      c.swapcase\n    end\n  end\n  s.join\nend\n\
    </code>\n<|/ a tags=ruby dscore=0 |>\n<| a |>\nHere's a solution which only uses\
    \ 1 character at a time:\n<code>", "    res=\"\"\n    for i in s\n        if i.isalpha()\n\
    \            if i.upcase == i.downcase\n                res.concat(i.upcase)\n\
    \            else\n                res.concat(upper(s))\n        else\n      \
    \      res.concat(i)\n    return res\n</code>\n<|/ a tags=ruby |>\n<| c |>\nYou\
    \ can improve the performance of `solve` by writing `s.each_char.with_object(\"\
    \") do |c,acc|\_\u2026` and then iterating over the `acc` as needed.\n<|/ c |>\n\
    <| a dscore=3 |>\n<code>", "  s\nend\n</pre>", "  \n  s = s.downcase\n  \n  s.each_char\
    \ do |c|\n    if !c.match?(/[a-zA-Z]/)\n      s = s.reverse \n    else\n     \
    \ s = s.gsub(c.upcase, c.downcase)\n    end\n  end\n  \n  s \nend", "\ts.split('').map!{|x|\
    \ x.downcase if x[0..0].is_a?(String)}.join\nend", "  a = s.split('').map { |c|\
    \ c.upcase if c.is_a? String else c }\n  a.empty? ? s.reverse : a.reverse.join\n\
    end\n</code>\n<|/ a tags=ruby,string,algorithm,string |>\n<| a dscore=1 tags=ruby,string,algorithm,string\
    \ |>\nA simple recursive solution: \n<code>", "  return \"#{s.split('').map{|x|\
    \ x.downcase }}@#{s.split('').map{|x| x.upcase }}\"\nend", "  s.chars.map do |c|\n\
    \    if c.isa? String\n      c.chars.map do |cc|\n        if cc.isalpha?\n   \
    \       cc.upcase\n        elsif cc.isdigit?\n          cc.to_i\n        else\n\
    \          cc\n        end\n      end.flatten\n    else\n      c\n    end\n  end.join(\"\
    \")\nend", "  reverse_case(s)\n  s\nend", "    str = s.chars.join\n    str.reverse.empty?\
    \ ? str.reverse! : \n        str.reverse!.chars.join\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nThis doesn't answer the OP's question. I think this only reverses\
    \ uppercase and lowercase letters, and only if the string contains no letters.\n\
    <|/ c |>\n<| a tags=ruby |>\n<code>", "    \n    # Write your code in Ruby here\n\
    \    reversed = s.chars.map { |char| char.upcase if char.class == String && char.empty?\
    \ == false && char.chars.all? { |c| c.class == String && c.empty? == false &&\
    \ c.chars.all? { |c| c.class == String && c.empty? == false && c.empty? == false\
    \ } }\n    reversed.empty? ? s.chars.reverse.join.chars.reverse.join : reversed.join\n\
    end", "  return s[0] if s.to_s.split(\"\").any? {|x| x =~ /^[a-zA-Z]+$/ }.to_s\
    \ \n  s.to_s.split(\"\").map {|x| x.downcase }.join \nend\n</code>\n<|/ a dscore=1\
    \ tags=string,ruby |>\n<| c |>\nYou should use `!str.nil?` instead of `str.to_s.split(\"\
    \").any? {|x| x =~ /^[a-zA-Z]+$/ }.to_s`\n<|/ c |>\n<| c |>\n: I see your point,\
    \ but I find it slightly less readable.  Also, since we're going with the `!`,\
    \ I like to see it right next to the \"truthiness\" of `!str`.\n<|/ c |>\n<| c\
    \ |>\n`!` prefix for truthiness is pretty common and doesn't require extra parenthesis.\n\
    <|/ c |>\n<| c |>\n, Yes, I agree.  I use `!` pretty often, especially in situations\
    \ where I expect a Boolean.\n<|/ c |>\n<| c |>\n`!str` is very bad practice; `str.nil?`\
    \ is much better (but probably only a matter of taste).\n<|/ c |>\n<| a tags=string,ruby\
    \ |>\nThe answer by James Conrad is the best, but here is an alternate solution:\n\
    <code>", "    \n    s = s.downcase\n    letters = s.gsub(\"[a-z]\", \"\\0\")\n\
    \    letters.gsub!(/\\0+/, \"\")\n    if letters == \"\" \n        s = s.reverse\n\
    \    else\n        s = letters + s.reverse\n    end\n    s\nend", "    str.split(s)\n\
    \    str.split(s).map { |x| x.upcase }.join.downcase\nend", "    \n    # your\
    \ code here\n    \n    return res", "  s.each_char {|c|\n    case c\n    when\
    \ 'a'..'z' then c.upcase!\n    when 'A'..'Z' then c.downcase!\n    else c\n  \
    \  end\n  }\nend\n</code>\n<|/ a tags=ruby,string dscore=2 |>\n<| c |>\nThis is\
    \ an O(n) solution.  It does not reverse the string, it reverses every single\
    \ character to upper or lower case.  If you were to do this on a string like \"\
    abc\" it would be O(n^2) worst case.\n<|/ c |>\n<| c |>\nThis solution also uses\
    \ the same O(n) time complexity as the others. Yes, it reverses every single character\
    \ to upper/lower case, but that's exactly what the OP asked for.\n<|/ c |>\n<|\
    \ c |>\n\"If the string contains no letters, reverse the string\" should I add\
    \ that if there is no letters, it should return nil or \"\" ? I am not getting\
    \ how to add this condition here. Can you please help me with this? And I also\
    \ want to know what is the complexity of .each_char{|c| .. } ?\n<|/ c |>\n<| c\
    \ |>\nThe method returns nil or \"\" if there are no letters in the string. I've\
    \ updated the answer to make it clear that it returns nil or \"\" if there are\
    \ no letters in the string. Also, I've added a link to `each_char` documentation.\n\
    <|/ c |>\n<| c |>\nThanks a lot. I understood that.\n<|/ c |>\n<| a tags=ruby,string\
    \ |>\nI'd go with\n<code>", "    if s == nil\n        return nil\n    end\n  \
    \  res = ''\n    s.each do |c|\n        if isletter(c)\n            if c == 'a'\n\
    \                res = res + c.upcase\n            elsif c == 'A'\n          \
    \      res = res + c.downcase\n            else\n                res = res + c\n\
    \            end\n        else\n            res = res + c\n        end\n    end\n\
    \    return res\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby |>\n<code>",
  "  a = s.chars\n  if s.empty?\n    return \"\"\n  else\n    return a.reduce(\"\"\
    , :<<).upcase\n  end\nend\n</code>\n<|/ a tags=string,ruby |>\n<| c |>\nthanks!\
    \ this is quite interesting, i will look into it !\n<|/ c |>\n<| c |>\nI added\
    \ a solution without `reverse`.\n<|/ c |>\n<| c |>\nAwesome thanks, I will try\
    \ to understand it !\n<|/ c |>\n<| a dscore=2 |>\nA short version for Ruby 1.8.7\n\
    <code>", "  \nend", "  s = s.to_s.downcase if s.is_a? String \n  s.split(\"\"\
    ).each do |letter|\n    case letter\n    when \"a\", \"b\", \"c\", \"d\", \"e\"\
    , \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\"\
    , \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\" then letter\
    \ = letter.upcase\n    when \"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"\
    I\",\"J\",\"K\",\"L\",\"M\",\"N\",\"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"U\",\"\
    V\",\"W\",\"X\",\"Y\",\"Z\" then letter = letter.downcase\n    end\n  end\n  s\
    \ = s\nend\n</code>\n<|/ a tags=ruby,string |>\n<| a tags=ruby,string |>\n<code>",
  "  return s.each_char.with_index.reduce(:<<).join\nend", "  s.length.times do |i|\n\
    \    next if s[i] == ' '\n    \n    s = s.gsub(s[i], '').downcase.insert(i, \"\
    A\" * (s[i].length)).upcase\n  end\n  s.reverse\nend\n</code>\n<|/ a |>\n<| a\
    \ dscore=0 |>\n<code>", "  return s\nend", "    return s.chars.map.with_index{|ch,i|\
    \ ch=ch==?a?c.chr(i)||i:ch}.join\nend\n</code>\n<|/ a tags=ruby,string,arrays\
    \ |>\n<| c |>\nYep, I missed that requirement.  Thanks for picking up on that.\n\
    <|/ c |>\n<| a dscore=1 |>\nI guess the best way would be to split the string\
    \ on every letter, and then concatenate the reversed letters.\n<|/ a tags=ruby,string,arrays\
    \ |>\n<| c |>\nI actually tried that, but I couldn't get it to work. That's why\
    \ I resorted to asking this question!\n<|/ c |>\n<| a dscore=1 |>\nHere's a solution\
    \ I made for you:\n<code>", "  s = s.to_s\n  if s == \"\"\n    s = s.chars.join\n\
    \  end\n  s = s[s.rindex(\" \")..-1]\n  if s.include? \"@\"\n    s = s[0..0] +\
    \ s[1..-1].to_s.upcase + s[0..0]\n  end\n  return s.chars.join\nend", "    str\
    \ = s.downcase\n    while str !=\"\"\n        char = str[/[a-z]/]\n        str[/[a-z]/]\
    \ = str[/[A-Z]/]\n        str[/[A-Z]/] = char\n    end\n    puts str.downcase\n\
    end", "    string.split(s).map{|i| i[0].downcase + i[1]}.join\nend\n</code>\n\
    And a test:\n<code>\n> solve(\"1234\")\n=> \"4321\"\n> solve(\"ab\")\n=> \"AB\"\
    \n> solve(\"#a@C\")\n=> \"#A@c\"\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThe OP\
    \ said \"If the string contains no letters, reverse the string.\"\n<|/ c |>\n\
    <| c |>\n- I was thinking the same thing, but I guess the spec could have said\
    \ \"If there are no letters in the string, return the same string\".  I suppose\
    \ they could have said \"If there are no letters in the string, return the empty\
    \ string\"\n<|/ c |>\n<| c |>\n- I edited my answer to reflect your clarification\
    \ and added an example test.\n<|/ c |>\n<| a tags=ruby,string |>\n<code>", " \
    \ s = s.split('').map{|x| x.downcase}.join\n  if s.empty?\n    s = s.join\n  end\n\
    \  s.gsub(/[a-z]/){|l| l.upcase }\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    Thanks a lot. Very helpful.\n<|/ c |>\n<| c |>\nThis solution seems too generic:\
    \ I guess you meant \"return **the string** with only lowercase letters reversed\"\
    \n<|/ c |>\n<| c |>\nI have revised it so that it now works with any input string.\
    \ It just returns the string with only lowercase letters reversed\n<|/ c |>\n\
    <| a tags=ruby,algorithm dscore=0 |>\n<code>", "  s.downcase!\n  s.gsub!(/./)\
    \ { |m| m.downcase if m.match?(/[a-z]/i) }\n  s\nend", "  return s.chars.each_with_object([]).inject(\"\
    \") do |result, char|\n    result += (char == char.upcase ? char.downcase : char).to_s\n\
    \  end\nend\n</code>\n<|/ a |>\n<| c |>\nPlease explain how this is different\
    \ from [the answer](https://stackoverflow.com/a/51088641/6281915) by [Oscar P\xE9\
    rez Fern\xE1ndez](https://stackoverflow.com/users/6281915/oscar-perrez-fernandez),\
    \ which is a bit more concise.\n<|/ c |>\n<| c |>\nI really did not want to add\
    \ too much to the code, but it is more readable and concise now.\n<|/ c |>\n<|\
    \ c |>\n`each_with_object` returns a new array with a string appended to it, so\
    \ you can just drop the first `inject` and use `each_char` instead of `each_with_object`.\n\
    <|/ c |>\n<| c |>\nThanks for your comment. I added your suggestion.\n<|/ c |>\n\
    <| a |>\n<code>", "    puts s.chars.reverse if s.chars.chars.size > 0 else s\n\
    end", "  return s.reverse! if s.each_char.all?(&:isalpha) \n  s.reverse!\nend\n\
    </cell>\n<text>\n5. Solution Code\nThe code solution is provided below.", "  s.chars.reverse.each_char.with_object('')\
    \ do |c, out|\n    out << case c\n            when /\\A[A-Z]/ then c.upcase\n\
    \            when /\\A[a-z]/ then c.downcase\n            else c\n           \
    \ end\n  end\nend", "  s = s.gsub(/[[:alpha:]]/) do |x|\n    x.upcase if x =~\
    \ /[a-z]/\n    x.downcase if x =~ /[A-Z]/\n    x\n  end", "  if s[0] =~ /[a-z]/\n\
    \    s[0].upcase!\n  end\n  if s[-1] =~ /[a-z]/\n    s[-1].downcase!\n  end\n\
    \  if s[0] == s[-1]\n    s[0] = s[0] + s[0]\n  end\n  s[0] = s[0].split('').sort.join\n\
    \  s[-1] = s[-1].split('').sort.join\n  s.join\nend\n</cell>\n<cell>\n%debug\n\
    </cell>\n<text>\nA little exercise on Ruby objects", "  return s.chars.reverse_each.join(\"\
    \")\nend", "  s.downcase!\n  s\nend", "  if s.length == 0 || s.length == 1\n \
    \   s == \"#a@C\"\n  else\n    i = s.length\n    while i > 0 do\n      i = i -\
    \ 1\n      if s[i] >= \"A\" and s[i] <= \"Z\"\n        s[i] = s[i].upcase\n  \
    \    end\n    end\n  end\n  return s.reverse\nend", "    s = s.to_s\n    (len1,\
    \ len2) = (s.length, s.length)\n    if s.length == 0\n        return s\n    if\
    \ s.include?(\"#\")\n        return s.gsub(\"#\", %w[\n            \"@\",\n  \
    \          \"a\"].join)\n    end", "  return s if s.count != 0 ? \"#{}@{}\".format(s.upcase,\
    \ s.downcase) : s.reverse\nend", "  s.downcase!\n  s.reverse!\n  return s\nend\n\
    </cell>\n<cell>\nsolve.call(\"1234\")\n</cell>\n<text>\nThe method downcase! reverses\
    \ all characters in the string.\nThe method reverse! reverses the string in place.\n\
    We can use this method to solve the problem of reversing a string while keeping\
    \ all capital letters intact.", "  \nend", "  string=s.downcase\n  for i in (0...(string.length-1))\
    \ do\n    letter=string[i]\n    if letter==\"a\" or letter==\"b\" or letter==\"\
    c\" or letter==\"d\" or letter==\"e\" or letter==\"f\" or letter==\"g\" or letter==\"\
    h\" or letter==\"i\" or letter==\"j\" or letter==\"k\" or letter==\"l\" or letter==\"\
    m\" or letter==\"n\" or letter==\"o\" or letter==\"p\" or letter==\"q\" or letter==\"\
    r\" or letter==\"s\" or letter==\"t\" or letter==\"u\" or letter==\"v\" or letter==\"\
    w\" or letter==\"x\" or letter==\"y\" or letter==\"z\" then\n      if letter==\"\
    a\" or letter==\"b\" then\n        string[i]=\"A\"\n      elsif letter==\"b\"\
    \ or letter==\"c\" then\n        string[i]=\"B\"\n      elsif letter==\"c\" or\
    \ letter==\"d\" then\n        string[i]=\"C\"\n      elsif letter==\"d\" or letter==\"\
    e\" then\n        string[i]=\"D\"\n      elsif letter==\"e\" or letter==\"f\"\
    \ then\n        string[i]=\"E\"\n      elsif letter==\"f\" or letter==\"g\" then\n\
    \        string[i]=\"F\"\n      elsif letter==\"g\" or letter==\"h\" then\n  \
    \      string[i]=\"G\"\n      elsif letter==\"h\" or letter==\"i\" then\n    \
    \    string[i]=\"H\"\n      elsif letter==\"i\" or letter==\"j\" then\n      \
    \  string[i]=\"I\"\n      elsif letter==\"j\" or letter==\"k\" then\n        string[i]=\"\
    J\"\n      elsif letter==\"k\" or letter==\"l\" then\n        string[i]=\"K\"\n\
    \      elsif letter==\"l\" or letter==\"m\" then\n        string[i]=\"L\"\n  \
    \    elsif letter==\"m\" or letter==\"n\" then\n        string[i]=\"M\"\n    \
    \  elsif letter==\"n\" or letter==\"o\" then\n        string[i]=\"N\"\n      elsif\
    \ letter==\"o\" or letter==\"p\" then\n        string[i]=\"O\"\n      elsif letter==\"\
    p\" or letter==\"q\" then\n        string[i]=\"P\"\n      elsif letter==\"q\"\
    \ or letter==\"r\" then\n        string[i]=\"Q\"\n      elsif letter==\"r\" or\
    \ letter==\"s\" then\n        string[i]=\"R\"\n      elsif letter==\"s\" or letter==\"\
    t\" then\n        string[i]=\"S\"\n      elsif letter==\"", "    str = s.to_s.split(\"\
    \").map(&:to_upper).join(\"\")\n    if str.length == 0\n        return str\n \
    \   str.gsub!(/./) { |c| c.chars.reduce(:\"&\")[0].ord + c.chars.reduce(:\"&\"\
    )[1].ord }\n    str.gsub!(/[^a-zA-Z]/) { |c| c.chars.reduce(:\"&\")[0].ord }\n\
    \    return str\nend", "\ts = s.to_s\n\ts.gsub!(/\\p{L}/u) do |letter|\n\t\tif\
    \ letter.upcase == letter\n\t\t\tletter.downcase!\n\t\telse\n\t\t\tletter.upcase!\n\
    \t\tend\n\tend\n\t\n\ts.gsub!(/[a-zA-Z]/u) do |letter|\n\t\tif letter.downcase\
    \ == letter\n\t\t\tletter.upcase!\n\t\telse\n\t\t\tletter.downcase!\n\t\tend\n\
    \tend\n\t\n\ts.gsub!(/[^a-zA-Z]/) do |letter|\n\t\tletter.upcase!\n\tend\n\t\n\
    \treturn s\nend", "  s.downcase!\n  s.gsub(/[[:alpha:]]/) do |char| \n    char.upcase\
    \ if char == char\n  end\nend\n</code>\nAnd here's another version:\n<code>",
  "  return s.downcase if s =~ /[a-z]/i\n  s.reverse if s.empty?\nend\n</cell>\n<cell>",
  "  return s.chars.reverse.join if s.chars.any? else s.chars.reverse\nend", "  s.downcase!\n\
    \  s.gsub!(/[^a-z]+/, '')\n  if s.size == 0\n    s.reverse\n  else\n    s.reverse!\n\
    \  end\nend", "  # Write your code here.\n  s.downcase!\n  return s\nend", " \
    \   \n    s = s.downcase\n    \n    letters = \"aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ\"\
    .downcase\n    \n    s.gsub!(/[#{letters}]/) { |match| match.upcase }\n    \n\
    \    s.gsub!(/[^#{letters}]/) { |match| match.downcase }\n    \n    s\nend", " \
    \   s = s.chars\n    s[s.length-1] = s[s.length-1].upcase\n    s[s.length-2] =\
    \ s[s.length-2].downcase\n    return s.join\nend\n</code>\n<|/ a |>\n<| c |>\n\
    I see what your saying. But it seems like your not really understanding the problem\
    \ I am having I guess. Please look at the example I wrote in the question. Thanks\
    \ anyways\n<|/ c |>\n<| c |>\nI'm sorry for not being clear. Let me see if I can\
    \ clarify, so you say that in the example \"ab#a@c\" should output \"#A@C\" and\
    \ that's what my code does with your solution?\n<|/ c |>\n<| c |>\nOh I got it,\
    \ thanks. I completely forgot about `.upcase` and `.downcase`\n<|/ c |>\n<| c\
    \ |>\nNo problem. Glad I could help and sorry if my answer was unclear. I wanted\
    \ to make sure I understood correctly haha.\n<|/ c |>\n<| a dscore=1 tags=ruby,string\
    \ |>\nA bit late, but here's my attempt at solving this problem:\n<code>", " \
    \   string.gsub(s, \"[a-z]\") do |i|\n        i.upcase if i.length > 0\n    end\n\
    end", "  if s.empty?\n    s\n  elsif s.chars.any?(&:ascii_only?)\n    s.chars.map\
    \ { |char| char.upcase }.reverse.join\n  else\n    s.chars.map { |char| char.downcase\
    \ }.reverse.join\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nThis was the quickest\
    \ answer on the page, even without the explanation.\n<|/ c |>\n<| c |>\nThis solution\
    \ doesn't work when the string is `\"\"`\n<|/ c |>\n<| a dscore=2 |>\n<code>",
  "  \n  s = s.downcase\n  letters = s.scan(/[A-z]/)", "  s.each_byte {|b| b.upcase\
    \ if b.upcase != b }\n  s.each { |l| l.upcase if l == l }\n  s\nend", "  s.downcase!\n\
    \  s.gsub(/[^a-z]/i) do |c|\n    /[a-z]/.match?(c)? c.upcase : c\n  end\nend\n\
    </code>\n<|/ a tags=ruby dscore=2 |>\n<| c |>\nNice solution. I'd just like to\
    \ add that it's also possible to avoid the regex: `s.chars.select { |c| /[a-z]/.match?(c)\
    \ }.join`.\n<|/ c |>\n<| c |>\nI like the idea of using select, but I still think\
    \ that a regex is more efficient.\n<|/ c |>\n<| a dscore=1 tags=ruby |>\nHere\
    \ is another way to solve it:\n<code>", "  s = s.downcase\n  i = 0\n  result =\
    \ ''\n  while i < s.length\n    c = s[i]\n    case c\n      when 'a' then result\
    \ << c\n      when 'z' then result << c\n      when 'A' then result << c\n   \
    \   when 'Z' then result << c\n      else result << c.reverse\n    end\n    i\
    \ += 1\n  end\n  return s.reverse\nend\n</cell>\n<text>\n6.\nWrite a function\
    \ that takes a string, s, and replaces every letter with the letter just before\
    \ it. The function should return the modified string.", "  return s\nend", " \
    \ return s.chars.reduce(lambda a,b| b==a ? a : b.upcase + a.downcase,\"\") if\
    \ s.chars.length != 0 else s\nend\n</code>\n<|/ a |>\n<| a dscore=1 |>\nIn case\
    \ someone is still interested, here's a solution in Ruby using recursion.\n<code>",
  "  s = s.split('').reverse.join\n  s.split('') do |s|\n    next if s.empty?\n  \
    \  letter = s[0]\n    unless letter.upcase[0] == letter.downcase[0]\n      s <<\
    \ letter.upcase << letter.downcase\n    end\n    s << letter.downcase\n  end.join\n\
    end\n</code>\n<|/ a |>\n<| c |>\nHi thank you for the solution and explanation.\
    \ However I do not understand how the last line works \"s.split('') do |s|\n \
    \   next if s.empty?\n    letter = s[0]\n    unless letter.upcase[0] == letter.downcase[0]\n\
    \      s << letter.upcase << letter.downcase\n    end\n    s << letter.downcase\n\
    \  end.join\n\"\n<|/ c |>\n<| c |>\n`s.split('') do |s|` iterates over the array\
    \ `s` with each element being one character from the string `s`. `next if s.empty?`\
    \ skips the rest of the block if `s` is empty, i.e. a string with only a single\
    \ character. If it didn't skip the rest of the block, `letter` would be `s[0]`\
    \ which would be `a` from the string `\"a\"`.\n<|/ c |>\n<| a |>\nHere is an example\
    \ of how this can be done using regular expressions.\n<code>", "    s=s.downcase\n\
    \    s=s.chars.reduce(&:+).to_s\n    s=s.reverse\n    s=s.chars.reduce(&:+).to_s\n\
    \    s=s.reverse\n    s=s.chars.reduce(&:+).to_s\n    s=s.reverse\n    s=s.chars.reduce(&:+).to_s\n\
    \    s=s.reverse\n    s=s.chars.reduce(&:+).to_s\n    s=s.reverse\n    s=s.chars.reduce(&:+).to_s\n\
    \    s=s.reverse\n    s=s.chars.reduce(&:+).to_s\n    s=s.reverse\n    s=s.chars.reduce(&:+).to_s\n\
    \    s=s.reverse\n    s=s.chars.reduce(&:+).to_s\n    s=s.reverse\n    s=s.chars.reduce(&:+).to_s\n\
    \    s=s.reverse\n    s=s.chars.reduce(&:+).to_s\n    s=s.reverse\n    s=s.chars.reduce(&:+).to_s\n\
    \    s=s.reverse\n    s=s.chars.reduce(&:+).to_s\n    s=s.reverse\n    s=s.chars.reduce(&:+).to_s\n\
    \    s=s.reverse\n    s=s.chars.reduce(&:+).to_s\n    s=s.reverse\n    s=s.chars.reduce(&:+).to_s\n\
    \    s=s.reverse\n    s=s.chars.reduce(&:+).to_s\n    s=s.reverse\n    s=s.chars.reduce(&:+).to_s\n\
    \    s=s.reverse\n    s=s.chars.reduce(&:+).to_s\n    s=s.reverse\n    s=s.chars.reduce(&:+).to_s\n\
    \    s=s.reverse\n    s=s.chars.reduce(&:+).to_s\n    s=s.reverse\n    s=s.chars.reduce(&:+).to_s\n\
    \    s=s.reverse\n    s=s.chars.reduce(&:+).to_s\n    s=s.reverse\n    s=s.chars.reduce(&:+).to_s\n\
    \    s=s.reverse\n    s=s.chars.reduce(&:+).to_s\n    s=s.reverse\n    s=s.chars.reduce(&:+).to_s\n\
    \    s=s.reverse\n    s=s.chars.reduce(&:+).to_s\n    s=s.reverse\n    s=s.chars.reduce(&:+).to_s\n\
    \    s=s.reverse\n    s=", "  s = String.new(s) \n  return s if s.empty? or s.chars.all?\
    \ { |c| c.is_a?(String) ? c.empty? : c.upcase != c.downcase } \n  s = s.chars.inject(\"\
    \") { |s,x|\n    cased_x = x.casecmp(s.last).zero?\n    (cased_x ? s.last + x\
    \ : s + x) \n  }\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nYou don't\
    \ need regex, you can just call s.downcase.delete(str.dup).\n<|/ a tags=string,ruby,regex\
    \ |>\n<| c |>\nNope, that doesn't work. `delete` doesn't work with `String`s.\
    \ It works only with arrays of characters, and it will return the deleted character,\
    \ but it will modify the original string.\n<|/ c |>\n<| c |>\nNo it doesn't. `String`\
    \ instances do have `delete`-method. Try it `s = 'abc'; s.delete(s.dup); s.class\
    \ #=> String`\n<|/ c |>\n<| c |>\nOh sorry, I misread the answer. I thought he\
    \ was trying to delete the letters, not the string, so `String` doesn't have `delete`.\
    \ Anyways, that's a better solution.\n<|/ c |>\n<| c |>\nThat was my first thought\
    \ as well after I read his solution. My solution is way more efficient, as it\
    \ doesn't create a new string just to reverse the case.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>", "  s = s.upcase\n  s = s.gsub(/[^A-Z]/){|s| s.downcase}\n  s.reverse!\n\
    end", "  return s if s.split(//).uniq.size == 1\n  s.gsub(/[a-z]/) do |s|\n  \
    \  s[s.downcase.length..-1].downcase + s[0,s.downcase.length]\n  end\nend", " \
    \ # Your code here\n  return \"\".join((s.capitalize).chars.map { |c| c.downcase\
    \ == c ? c : c.upcase }.reverse)\nend\n</code>\n<|/ a dscore=2 tags=ruby |>\n\
    <| c |>\nThis does not reverse the letters. `s.capitalize` returns \"Blah\".\n\
    <|/ c |>\n<| a dscore=2 tags=ruby |>\nThis is very close to Kirti's answer (which\
    \ I upvoted) but without the use of map/reverse. Instead it uses gsub to do a\
    \ regex replace on every character. \n<code>", "  s = s.chars.reverse.join.downcase\n\
    \  s = s.chars.reverse.join if s.chars.size == 1 \n  s.reverse\nend", "    s.length\
    \ == 0 ? '' : \"#@\".gsub(/./) { |c| c == 'a' ? 'A' : 'a' }\nend\n</cell>\n<text>\n\
    3. Exercise\nWhat is wrong with my solution to Exercise 1?", "  \nend", "  result\
    \ = ''\n  if s.length > 0\n    letters.each do |letter|\n      result += letter.downcase\
    \ if s[0...letter.length] == letter\n    end\n    result.empty? ? s = result.reverse.upcase\
    \ : result\n  end\nend", "  \n  # Write your code here.\n  if s[0]==\"0\"\n  \
    \  puts \"Please Enter Your Input\"\n  elsif s[1]==\"0\"\n    puts \"Please Enter\
    \ Your Input\"\n  else\n    puts \"Your input is\"\n  end\nend", "  # write your\
    \ code in Ruby\n  s.chars.sort.reverse.join\nend", "  return s.chars.reverse.join\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| c |>\nWhy would you use `join` here? Just\
    \ `s.reverse`.\n<|/ c |>\n<| c |>\nI agree, that would be better. But the OP asked\
    \ for an elegant solution.\n<|/ c |>\n<| a dscore=1 |>\nWe can solve this problem\
    \ easily using String#upcase and String#downcase:\n<code>", "    \n    # Write\
    \ your code here.\n    \n    return s\n</cell>\n<text>\nTests\nLet's test our\
    \ function with some tests:", "  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n", "  str = s.split(//).map(&:downcase)\n\
    \  case str\n    when [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"\
    , \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\"\
    , \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n      str.join\n    when /^[a-f0-9]+$/\n\
    \      str.join.gsub(/[a-f]/) {|c| c.hex}\n    else\n      str.join\n  end\nend\n\
    </code>\n<|/ a dscore=2 tags=string,ruby |>\n<| c |>\nYour solution is really\
    \ interesting. It also works with letters other than `a` and `b` but not with\
    \ `x` (which can occur in some languages like Chinese), but that is not a problem\
    \ in my case. Thank you.\n<|/ c |>\n<| a dscore=1 |>\nHere's another solution\
    \ that doesn't make use of regular expressions:\n<code>", "    \nend", "  if(s\
    \ == \"\")\n    return s\n  s = downcase(s);\n  if(s.size < 1)\n    return s\n\
    \  res = \"\";\n  for(i = 1; i < s.size; i++)\n    if(s[i] >= \"a\" && s[i] <=\
    \ \"z\")\n      s[i] = s[i].upcase;\n    elsif(s[i] >= \"A\" && s[i] <= \"Z\"\
    )\n      s[i] = s[i].downcase;\n    else\n      s[i] = s[i];\n  return s[0] +\
    \ solve.call(s.slice(1))\nend\n</cell>\n<cell>", "  return s.split(\"\").map {|c|\
    \ c.isalpha? ? c.upcase : c.downcase }.join\nend", "  s.each_byte { |c| c.ord\
    \ < 256 ? c.upcase : c.downcase }\n  s.scan(/[a-zA-Z]/).map { |c| c.ord < 256\
    \ ? c.upcase : c.downcase }.join(\"\")\nend\n</code>\n<|/ a |>\n<| a tags=ruby,string\
    \ |>\nIf you really need to do it without using regular expressions:\n<code>",
  "  return s.gsub(/[a-z]/i) { |m| m.downcase if m.downcase == m ? m.upcase : m }\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis is also a good solution (I like\
    \ it better). Just one remark: It is possible to avoid using an if condition by\
    \ using a ternary expression like `m.downcase.empty? ? m : m.downcase`\n<|/ c\
    \ |>\n<| a tags=ruby |>\nThis is my solution, without using regexp. \n<code>",
  "  s.gsub(/[a-z]/){|s| s.capitalize}\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    This won't quite work. The OP said that only letters need to be flipped. `'abc'`\
    \ is already in `'#a@C'`; `'cba'` should be `'#a@C'`; `'cbaa'` should be `'#a@C'`;\
    \ `'bba'` should be `'#a@C'`.\n<|/ c |>\n<| c |>\nThanks, I've updated my answer.\n\
    <|/ c |>\n<| c |>\nWhat is the purpose of `[s.first(s).downcase]`? Seems redundant.\n\
    <|/ c |>\n<| c |>\nBecause `s.gsub(/[a-z]/){|s| s.capitalize}` would change `'abc'`\
    \ to `'ABC'`, but we only want to change `'abc'` to `'CAb'`. Thus we need to check\
    \ whether `s` is only letters, and change it to capitalized if it's not.\n<|/\
    \ c |>\n<| a |>\nJust use a simple regexp with downcase to replace the letters.\n\
    <code>", "    letters = s.split('')\n    letters.each do |letter|\n        if\
    \ letter.to_i < 10\n            return letter.upcase\n        elsif letter.to_i\
    \ > 9\n            return letter.downcase\n        end\n    end\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nHi there, welcome to SO! I really hope you don't mind\
    \ that I edited your post to try to improve the formatting. It was really hard\
    \ to see what's going on without the code snippets being formatted as code blocks.\n\
    <|/ c |>\n<| c |>\nThanks for your advice, i will take care of it!\n<|/ c |>\n\
    <| c |>\nIf you have a new question, please ask a new question.\n<|/ c |>\n<|\
    \ c |>\nYour code has some errors: `'c'.upcase` returns `'C'` and you also need\
    \ to handle the case that `letter == '#'`\n<|/ c |>\n<| c |>\n: You're right,\
    \ thanks for pointing out the mistakes. Fixed it.\n<|/ c |>\n<| a |>\nThis should\
    \ be the solution:\n<code>", "  s.gsub!(/[[:alpha:]]/) { $1.upcase } if s.size\
    \ > 0\n  s.gsub!(/[^[:alpha:]]/) { $1.upcase } if s.size > 0\n  s.gsub!(/[[:alpha:]]/)\
    \ { $1.downcase } if s.size > 0\n  s.gsub!(/[^[:alpha:]]/) { $1.downcase } if\
    \ s.size > 0\n  s\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nYes. I thought about\
    \ it, but it was not clear to me what the question was asking for. Although the\
    \ problem statement seems to imply this (as does your solution), it is more natural\
    \ to me (and the OP) if you reverse the case of the letters in all cases.\n<|/\
    \ c |>\n<| c |>\nThis is not the correct answer. It is not just an academic exercise,\
    \ it is an actual programming question. How can you implement `solve` to do what\
    \ OP asked?\n<|/ c |>\n<| a dscore=0 |>\nThe solution by is correct but is more\
    \ like \"a workaround\" than an actual solution. \nThe real solution is to just\
    \ use the built-in String class methods reverse and chars.\n<code>", "  result\
    \ = ''\n  \n  if s.length < 2\n    return result\n  \n  for i in s\n    result\
    \ += (isletter(s.charAt(i)) ? s.charAt(i).upcase : s.charAt(i))\n  \n  result\
    \ += (s.length == s.length ? s.upcase : s)\n  \n  return result\nend", "  s.downcase!\n\
    \  \n  case s[0]\n    when \"a\"\n      \"A\"\n    when \"b\"\n      \"B\"\n \
    \   when \"c\"\n      \"C\"\n    when \"d\"\n      \"D\"\n    when \"e\"\n   \
    \   \"E\"\n    when \"f\"\n      \"F\"\n    when \"g\"\n      \"G\"\n    when\
    \ \"h\"\n      \"H\"\n    when \"i\"\n      \"I\"\n    when \"j\"\n      \"J\"\
    \n    when \"k\"\n      \"K\"\n    when \"l\"\n      \"L\"\n    when \"m\"\n \
    \     \"M\"\n    when \"n\"\n      \"N\"\n    when \"o\"\n      \"O\"\n    when\
    \ \"p\"\n      \"P\"\n    when \"q\"\n      \"Q\"\n    when \"r\"\n      \"R\"\
    \n    when \"s\"\n      \"S\"\n    when \"t\"\n      \"T\"\n    when \"u\"\n \
    \     \"U\"\n    when \"v\"\n      \"V\"\n    when \"w\"\n      \"W\"\n    when\
    \ \"x\"\n      \"X\"\n    when \"y\"\n      \"Y\"\n    when \"z\"\n      \"Z\"\
    \n    when \"A\"\n      \"a\"\n    when \"B\"\n      \"b\"\n    when \"C\"\n \
    \     \"c\"\n    when \"D\"\n      \"d\"\n    when \"E\"\n      \"e\"\n    when\
    \ \"F\"\n      \"f\"\n    when \"G\"\n      \"g\"\n    when \"H\"\n      \"h\"\
    \n    when \"I\"\n      \"i\"\n    when \"J\"\n      \"j\"\n    when \"K\"\n \
    \     \"k\"\n    when \"L\"\n      \"l\"\n    when \"M\"\n      \"m\"\n    when\
    \ \"N\"\n      \"n\"\n    when \"O\"\n      \"o\"\n    when \"P\"\n      \"p\"\
    \n    when \"Q\"\n      \"q\"\n    when \"R\"\n      \"r\"\n    when \"S\"\n \
    \     \"s\"\n    when \"T\"\n      \"t\"\n    when \"U\"\n      \"u\"\n    when\
    \ \"V\"\n      \"v\"\n    when \"W\"\n      \"w\"\n    when \"X\"\n      \"x\"\
    \n    when \"Y\"\n      \"y\"\n    when \"Z\"\n      \"z\"\n    else\n", "  s.chars.map!\
    \ do |c|\n    ( c.downcase == c ) ? c.upcase : c.downcase\n  end\n  s.chars.join\n\
    end", "    return s if s.all?{ |ch| ch.to_s.upcase == ch } \n    s.downcase\n\
    end", "    str.upcase(s)\n    str.downcase(s)\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nThis works great for uppercase but will fail for all lower case. Thanks\
    \ anyway.\n<|/ c |>\n<| c |>\nI fixed it. This should work now.\n<|/ c |>\n<|\
    \ a |>\nYou can achieve this using only one line:\n<code>\ns.downcase!.capitalize!\n\
    </code>\n<|/ a dscore=1 tags=ruby |>\n<| a tags=ruby |>\nThe question is unclear,\
    \ but I think the question asks if there's a way that Ruby could know whether\
    \ a character is upper or lowercase based on a string. So, if Ruby can do that,\
    \ then maybe we can answer this question:\n<code>", "  chars = s.split(//).map(&:capitalize).join('')\n\
    \  chars.empty? ? chars : chars.split(//).map{|x| x[0].capitalize + x.slice!(1..-1)}.join(\"\
    \")\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nYeah this one works too but I went\
    \ with the other one. Thanks though\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>",
  "  if s.nil?\n    return s\n  end\n  letters = s.downcase.split(//).reverse.join\
    \ if s.chars.all? { |c| c.is_a?(String) }\n  letters = letters.split(//).reverse.join\
    \ if letters.empty?\n  return letters if letters.length > 0\n  letters.reverse\n\
    end\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\nfunction stringToUppercase(string)\
    \ {\n  var result = \"\";\n  for(var i = 0; i < string.length; i++) {\n    var\
    \ char = string.charAt(i);\n    var lowerChar = char.toLowerCase();\n    var upperChar\
    \ = char.toUpperCase();\n    result = result + lowerChar + upperChar;\n  }\n \
    \ return result;\n}", "  return s.reverse! if s.chars.all? { |c| c.in? \"aAbBcC\"\
    \ }\n  s.reverse!\nend", "    s = s.to_s.downcase\n    s.chars.each do |c|\n \
    \       return s.gsub!(c, c.reverse).downcase if c.upcase != c\n    end\n    return\
    \ s.gsub!(\"A\", \"B\").gsub!(\"a\", \"B\").downcase\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| c |>\nThis also seems to have a space limitation\n<|/ c |>\n<| c |>\n\
    This seems like a very elegant solution.\n<|/ c |>\n<| c |>\nI think this will\
    \ fail if the string is `\"#a@C\"` as `\"#A@c\"` is not reversed properly\n<|/\
    \ c |>\n<| a |>\n<code>", "  \n    # your code here\n    \n  \n    return res\n\
    \        \n    ", "  s.downcase!\n  s.gsub(/./) do |letter|\n    if letter.ascii_only?\n\
    \      letter.upcase!\n    else\n      letter\n    end\n  end\n  s\nend\n</code>\n\
    <|/ a dscore=0 tags=ruby |>\n<| c |>\nI really like this solution. The only thing\
    \ that could be improved is that it would be better if the function returns the\
    \ \"new\" string rather than the one that receives the new string. Is that possible\
    \ or just a style thing? Also, your solution seems to work the best on Ruby 2.7.1\
    \ (`solve(\"aAbBc\")` returns `\"aAbBc\"` as expected). Do you know how I could\
    \ get it to work on Ruby 2.6.5 (`solve(\"aAbBc\")` returns `\"ABC\"`)? I really\
    \ don't care which version of Ruby it works, I just want to get it to work on\
    \ the most recent version.\n<|/ c |>\n<| c |>\nThank you. Regarding returning\
    \ the \"new\" string, I guess I would have done the same if I hadn't already used\
    \ `return`. I guess it's just a style thing, as I am more familiar with returning\
    \ strings from methods than with returning from `each` blocks, but I wouldn't\
    \ want to get in the habit of using `return` unless I really needed to.\n<|/ c\
    \ |>\n<| c |>\nThanks, that makes sense. Unfortunately, I still can't get it to\
    \ work on Ruby 2.6.5. It works fine on 2.7.1 though. Is there a way to make it\
    \ work on 2.6.5? I've been trying to figure this out for hours and haven't been\
    \ able to get it to work.\n<|/ c |>\n<| c |>\nNo, your solution does not work\
    \ on Ruby 2.6.5. Try `solve(\"aAbBc\")` on 2.6.5 and see what it returns. It returns\
    \ `\"ABC\"` instead of `\"aAbBc\"`\n<|/ c |>\n<| c |>\nOops, I didn't read your\
    \ question carefully enough. I've updated my solution to work in Ruby 2.6.5 now.\n\
    <|/ c |>\n<| a |>\n<code>", "    # Your code here\n    puts s.chars.reverse.join\
    \ res\nend\n</code>\nI hope that helps.\n<|/ a dscore=3 |>\n<| a dscore=2 |>\n\
    A bit late to the party but here is how I would do it:\n<code>", "  s=s.downcase\n\
    \  if s.include?(\"@\")\n    if s[0]==\"@\"\n      return s\n    else\n      s.gsub!(/@/,\"\
    \")\n      s.gsub!(/[^a-z]/i,\"\")\n      s.gsub!(/[^A-Z]/i,\"\")\n      s.gsub!(/[^A-Z]/i,\"\
    \")\n      s.gsub!(/[^A-Z]/i,\"\")\n      s.gsub!(/[^A-Z]/i,\"\")\n      s.gsub!(/[^A-Z]/i,\"\
    \")\n      s.gsub!(/[^A-Z]/i,\"\")\n      s.gsub!(/[^A-Z]/i,\"\")\n      s.gsub!(/[^A-Z]/i,\"\
    \")\n      s.gsub!(/[^A-Z]/i,\"\")\n      s.gsub!(/[^A-Z]/i,\"\")\n      s.gsub!(/[^A-Z]/i,\"\
    \")\n      s.gsub!(/[^A-Z]/i,\"\")\n      s.gsub!(/[^A-Z]/i,\"\")\n      s.gsub!(/[^A-Z]/i,\"\
    \")\n      s.gsub!(/[^A-Z]/i,\"\")\n      s.gsub!(/[^A-Z]/i,\"\")\n      s.gsub!(/[^A-Z]/i,\"\
    \")\n      s.gsub!(/[^A-Z]/i,\"\")\n      s.gsub!(/[^A-Z]/i,\"\")\n      s.gsub!(/[^A-Z]/i,\"\
    \")\n      s.gsub!(/[^A-Z]/i,\"\")\n      s.gsub!(/[^A-Z]/i,\"\")\n      s.gsub!(/[^A-Z]/i,\"\
    \")\n      s.gsub!(/[^A-Z]/i,\"\")\n      s.gsub!(/[^A-Z]/i,\"\")\n      s.gsub!(/[^A-Z]/i,\"\
    \")\n      s.gsub!(/[^A-Z]/i,\"\")\n      s.gsub!(/[^A-Z]/i,\"\")\n      s.gsub!(/[^A-Z]/i,\"\
    \")\n      s.gsub!(/[^A-Z]/i,\"\")\n      s.gsub!(/[^A-Z]/i,\"\")\n      s.gsub!(/[^A-Z]/i,\"\
    \")\n      s.gsub!(/[^A-Z]/i,\"\")\n      s.gsub!(/[^A-Z]/i,\"\")\n      s.gsub!(/[^A-Z]/i,\"\
    \")\n      s.gsub!(/[^A-Z]/i,\"\")\n      s.gsub!(/[^A-Z]/i,\"\")\n      s.gsub!(/[^A-Z]/i,\"\
    \")\n      s.gsub!(/[^A-Z]/i,", "  s.reverse!\n  if s.chars.empty?\n    s.replace(/../)\
    \ { |c| c.upcase }\n  else\n    s.replace(/../) { |c| c.downcase }\n  end\nend",
  "  \n  return s\nend\n        ", "  s = s.split('').join.chars\n  case s\n  when\
    \ ''\n    ''\n  when /[a-z]/\n    s.tr!{|x| x.downcase }\n  when /[A-Z]/\n   \
    \ s.tr!{|x| x.upcase }\n  else\n    s\n  end\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nPlease don't add answers to add \"thank you\" notes, instead vote for\
    \ the good ones and accept the best one.  Also note that `s.split.join.chars.join('')`\
    \ is more efficient than `s.split('').join.chars`.\n<|/ c |>\n<| c |>\nthanks,\
    \ I changed the first solution just as you said. By the way, what is the difference\
    \ between `s.split.join.chars.join('')` and `s.split('').join.chars`?\n<|/ c |>\n\
    <| c |>\nThe difference is that `chars` only converts the array to string one\
    \ time, so it is the slowest method in my answer.  Using `join` means it converts\
    \ every element in the array to a string first, then concatenates them, whereas\
    \ `chars` converts all elements to strings before returning.  Also, you don't\
    \ need to call `split` twice when `split` already returns an array: `s.split('')`.\n\
    <|/ c |>\n<| a tags=string,ruby dscore=1 |>\n<code>", "  s = s.split(\"\")\n \
    \ s.each do |c|\n    if c >= 'a' && c <= 'z'\n      s = s.reverse\n      break\n\
    \    elsif c >= 'A' && c <= 'Z'\n      s.reverse!\n      break\n    end\n  end\n\
    \  s.join(\"\")\nend", "  s.each_char do |c|\n    next if !c || c.ascii_only?\n\
    \    return c if c.upcase == c.downcase\n    return c.downcase if c.downcase ==\
    \ c.upcase\n  end", "    if s.length < 1\n        return s\n    arr = s.split(\"\
    \")\n    for e in arr\n        if e.isalpha()\n            e.upcase!\n       \
    \ else\n            e.downcase!\n        end\n    end\n    return arr.join(\"\"\
    )\nend", "  s = s[0..-2]\n  return s.chars.map { |e| e.downcase }.join('')\nend",
  "  return case ? s.downcase.gsub(/[a-z]/i) do |x| \n      x.upcase \n    end : s.gsub(/[a-z]/i)\
    \ do |x| \n      x.downcase \n    end\nend", "  s.gsub!(/[[:alpha:]]/) do |char|\n\
    \    char.downcase! if char.match?(/[a-z]/)\n    char.upcase! if char.match?(/[A-Z]/)\n\
    \    char\n  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
