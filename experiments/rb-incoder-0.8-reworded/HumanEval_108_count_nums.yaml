name: HumanEval_108_count_nums
language: rb
prompt: "# Write a function count_nums which takes an array of integers and returns\n\
  # the number of elements which has a sum of digits > 0.\n# If a number is negative,\
  \ then its first signed digit will be negative:\n# e.g. -123 has signed digits -1,\
  \ 2, and 3.\n# >>> count_nums.call([])\n# 0\n# >>> count_nums.call([-1, 11, -11])\n\
  # 1\n# >>> count_nums.call([1, 1, 2])\n# 3\ndef count_nums(arr)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_nums\n\
  \    candidate = method(:count_nums)\n    assert_equal(0, candidate.call([]))\n\
  \    assert_equal(0, candidate.call([-1, -2, 0]))\n    assert_equal(6, candidate.call([1,\
  \ 1, 2, -2, 3, 4, 5]))\n    assert_equal(5, candidate.call([1, 6, 9, -6, 0, 1, 5]))\n\
  \    assert_equal(4, candidate.call([1, 100, 98, -7, 1, -1]))\n    assert_equal(5,\
  \ candidate.call([12, 23, 34, -45, -56, 0]))\n    assert_equal(1, candidate.call([0,\
  \ 1]))\n    assert_equal(1, candidate.call([1]))\n  end\nend\n"
completions: ["  n = arr.length\n  arr.each_with_index do |n, i|\n    if n < 0\n \
    \     arr[i] = -n\n      n -= 1\n    end\n    i = i + 1\n  end\n  arr.reject {\
    \ |n| n < 0 }.size - (arr.reject { |n| n < 0 }.size - arr.size)\nend", "    arr.inject(0)\
    \ do |n, i|\n        if i >= 0\n            n += (i >= 10 ? 10 - i : i)\n    \
    \    end\n        n\n    end\nend", "  arr.inject(0) { |t, x| t + ( (x<0) ? x.abs\
    \ : x.to_i ) }\nend", "  arr.each do |x|\n    x.to_s.chars.each_with_index.with_object(0)\
    \ do |y, ycount|\n      if y > 0\n        ycount += 1\n      end\n    end\n  end\n\
    end\ncount_nums(array)", "  arr.map { |num| num }.select { |num| num.positive?\
    \ }.count { |num| num.zero? }\nend\n</code>\nHere's a more readable version of\
    \ the count_nums function:\n<code>", "  arr.each do |number|\n    if number ==\
    \ 0\n      0\n    elsif number.is_a?(Integer)\n      while number > 0\n      \
    \  number -= 1\n        if number % 10 == 0\n          break\n        end\n  \
    \    end\n      1\n    else\n      nil\n    end\n  end\nend", "  arr.inject(0)\
    \ do |counter, elem|\n    if elem.zero?\n      counter\n    elsif elem > 0 &&\
    \ elem.abs <= 9\n      counter + 1 if elem < 10 && elem.is_a? Integer\n    elsif\
    \ elem.is_a? Integer\n      counter + 1 if elem < 10 && elem.is_a?(Integer)\n\
    \    elsif elem < 0\n      counter + 1 if elem * -1 == elem\n    end\n  end\n\
    end", "  result = 0\n  arr.each do |n|\n    result += (n >= 0 ? n.to_s.split('').count\
    \ { |d| d.nonzero? } : -n.to_s.split('').count { |d| d.nonzero? }) - 1 # Count\
    \ negative sign, subtract one, and then subtract one more for +ve numbers\n  end\n\
    \  result\nend", "  arr.each do |x|\n    if x.to_s.split('').sum > 0\n      return\
    \ 1+count_nums(x/10)\n    end\n  end\n  return 0\nend", "  arr.uniq.count{|n|\
    \ n % 10 > 0}\nend", "  arr.each do |n|\n    if n < 0\n      puts \"#{n}\".to_i.abs\n\
    \      return\n    end\n    puts \"#{n}\".to_i.abs\n  end\n  puts 0\nend", " \
    \ count = 0\n  arr.each do |n|\n    count += n if n < 0\n    count += 1 if n >=\
    \ 0 && n.to_s.chars.map(&:to_i).sum >= 0\n  end\n  count\nend", "  arr.each_index\
    \ { |i| return i if arr[i] > 0 }\n  arr.size\nend\n</cell>\n<text>\nExercise 6:\
    \ Write a method count_nums which takes an array of integers and\nreturns the\
    \ number of elements which has a sum of digits > 0 and is even.\nIf no such number\
    \ exists, return 0.\nIf any element is negative, then its first signed digit will\
    \ be negative:\ne.g. -123 has signed digits -1, 2, and 3.\n>>> count_nums.call([])\n\
    0\n>>> count_nums.call([-1, 11, -11])\n1\n>>> count_nums.call([1, 1, 2])\n0\n\
    >>> count_nums.call([-10, 0, 5])\n1\n>>> count_nums.call([-10, 0, 5])\n0", " \
    \ n = arr.length\n  arr.each do |num|\n    num.abs\n    n += 1 if num > 0\n  end\n\
    \  n\nend", "  arr.map { |x| x.abs.abs > 0 ? x.to_s.split('').map(&:to_i).inject(0)\
    \ { |total, digit| total + (digit > 0 ? 1 : 0) }\nend", "    arr.each do |n|\n\
    \        n.to_i.times do |i|\n            sum += i\n            break if sum >=\
    \ 10\n            sum += n[i].to_i if n[i] < 0\n        end\n        break if\
    \ sum >= 10\n    end\n    sum\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis\
    \ works, but it only returns the digits of positive numbers. `count_nums([-12,\
    \ 9, 9])` gives me `[-10, 9, 9]`, which has three positive digits, not two.\n\
    <|/ c |>\n<| c |>\nOh, sorry, I didn't see that in the original description. I've\
    \ updated the answer now\n<|/ c |>\n<| a |>\nA recursive solution\n<code>", " \
    \ arr.each {|n|\n    n.to_s.split('').select {|i|\n      i.to_i > 0\n    }.count\
    \ { |x| x > 0 }\n  }.max\nend\n</code>\n<|/ a |>\n<| c |>\nYes, but this only\
    \ works in Ruby. In Python you need at least two lines to do it :)\n<|/ c |>\n\
    <| a dscore=2 tags=algorithm,integer,arrays,ruby |>\nHere's an iterative solution\
    \ which uses no additional data structures and uses only a single array of the\
    \ size of the largest possible number in the array:\n<code>", "  if arr.empty?\n\
    \    0\n  else\n    arr.reduce(0) { |n| n + count_nums(n.to_s.split('')) }\n \
    \ end\nend", "  arr.inject(0) { |total, elem| total + (elem.is_a?(Fixnum) && elem.abs<10)\
    \ ? 1 : 0}\nend", "  if arr.empty?\n    0\n  else\n    arr.sum - arr.each.with_index\
    \ do |i, idx|\n      if i < 0\n        -1 * i - idx\n      else\n        i\n \
    \     end\n    end.count\n  end\nend\n</code>\nNow we write a predicate which\
    \ determines if a given number is divisible by an array:\n<code>", "  arr.each\
    \ do |i|\n    arr[i] = arr[i].to_i\n  end\n  arr.select { |x| x != 0 }.count\n\
    end\n</pre>", "  arr.each do |i|\n    if i > 0\n      break if arr[i-1] == i\n\
    \    else\n      break if arr[-i - 1] == -i\n    end\n  end\n  arr.count { |i|\
    \ i > 0 }\nend", "  if arr.nil?\n    return 0\n  elsif arr.kind_of?(Array)\n \
    \   arr.each do |e|\n      next if e.kind_of?(Numeric)\n      if e < 0\n     \
    \   e *= -1\n      end\n      e *= 10\n      sum += e\n    end\n    return sum\n\
    \  end\nend\n</pre>", "  arr.each do |i|\n    next if i < 0\n    sum_of_digits\
    \ = 0.step(i, 10).inject(0, :+)\n    next unless sum_of_digits > 0 \n    count_nums\
    \ += 1 if sum_of_digits > 9 \n  end\n  count_nums\nend\nputs count_nums([-1, 11,\
    \ -11])", "  arr.inject(0, :+)\nend", "  arr.inject(0) do |sum, num|\n    sum\
    \ += num if num > 0\n    sum\n  end\nend\n</cell>\n<cell>", "  result = 0\n  arr.each\
    \ do |num|\n    result += 1 if num.zero?\n    result += num.abs\n  end\n  result\n\
    end", "  arr.inject(0, :+).to_i if arr\nend", "  arr.inject(0) do |total,n|\n\
    \    digits = n.to_s.chars.map(&:to_i)\n    total += digits.inject(0) {|sum,d|\
    \ sum + (d>0? -d:0)}\n    total\n  end\nend", "  arr.inject { |sum, num| sum +\
    \ count_digits(num) }\nend", "  arr.map! { |e| e > 0 ? e * count_digits(e) }\n\
    \  arr.sum { |e| e > 0 ? e : -e }\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    Just want to point out that `map` returns an array, whereas `sum` returns a number.\n\
    <|/ c |>\n<| c |>\nGood point. I'll update the answer. Thanks.\n<|/ c |>\n<| a\
    \ dscore=2 tags=math,ruby,integer,algorithm |>\nI like this problem. Here are\
    \ my thoughts:\nIf the number has no digits greater than or equal to zero, return\
    \ zero.\nOtherwise, subtract the number from the largest number whose digits sum\
    \ to zero.\nIf the number has no digits greater than or equal to zero, return\
    \ zero.\nOtherwise, subtract the number from the largest number whose digits sum\
    \ to zero.\nIf the number has no digits greater than or equal to zero, return\
    \ zero.\nOtherwise, subtract the number from the largest number whose digits sum\
    \ to zero.\nIf the number has no digits greater than or equal to zero, return\
    \ zero.\nOtherwise, subtract the number from the largest number whose digits sum\
    \ to zero.\nIf the number has no digits greater than or equal to zero, return\
    \ zero.\nOtherwise, subtract the number from the largest number whose digits sum\
    \ to zero.\nIf the number has no digits greater than or equal to zero, return\
    \ zero.\nOtherwise, subtract the number from the largest number whose digits sum\
    \ to zero.\nIf the number has no digits greater than or equal to zero, return\
    \ zero.\nOtherwise, subtract the number from the largest number whose digits sum\
    \ to zero.\nIf the number has no digits greater than or equal to zero, return\
    \ zero.\nOtherwise, subtract the number from the largest number whose digits sum\
    \ to zero.\nIf the number has no digits greater than or equal to zero, return\
    \ zero.\nOtherwise, subtract the number from the largest number whose digits sum\
    \ to zero.\nIf the number has no digits greater than or equal to zero, return\
    \ zero.\nOtherwise, subtract the number from the largest number whose digits sum\
    \ to zero.\nIf the number has no digits greater than or equal to zero, return\
    \ zero.\nOtherwise, subtract the number from the largest number whose digits sum\
    \ to zero.\nIf the number has no digits greater than or equal to zero, return\
    \ zero.\nOtherwise, subtract the number from the largest number whose digits sum\
    \ to zero.\nIf the number has no digits greater than or equal to zero, return\
    \ zero.\nOtherwise, subtract the number from the largest number whose digits sum\
    \ to zero.\nIf the number has no digits greater than or equal to zero, return\
    \ zero.\nOtherwise, subtract the number from the largest number whose digits sum\
    \ to zero.\nIf the number has no digits greater than or equal to zero, return\
    \ zero.\nOtherwise, subtract the number from the largest number whose digits sum\
    \ to zero.\nIf the number has no digits greater than or equal to zero, return\
    \ zero.\nOtherwise, subtra", "  arr.inject(0) { |sum, n| sum + n % 10 }\nend",
  "  arr.inject(0) do |acc, e|\n    acc = (acc.abs + e.to_i) % 10\n    (10 - acc).zero?\
    \ ? acc : acc + 1\n  end\nend", "    arr.each { |n| return n if n < 0 }.count\
    \ { |n| n < 0 }\nend", "  count = 0\n  arr.each do |num|\n    next if num.negative?\n\
    \    (num.to_s.split('').reverse.count{|d| d < 0 ? -num.to_i.abs : num.to_i}).tap\
    \ do\n      count += 1 if num > 0\n    end\n  end\n  count\nend\n</cell>\n<cell>",
  "  arr.each do |num|\n    if num > 0\n      break\n    elsif num < 0\n      num\
    \ = -num\n      break\n    end\n  end\n  arr.count{ |num| num.to_i == num.to_i}\n\
    end\n</cell>\n<cell>", "  return arr.inject(0) { |sum, elem|\n    sum + elem.to_s.length\n\
    \  }\nend", "  arr.each_with_index do |n,i|\n    if i >= 0 && (n < 0 || n % 10\
    \ == 0)\n      result = (10*(i+1))\n      break if result == sum\n      sum +=\
    \ 1\n    end\n  end\nend", "  # TODO: implement your function here\nend\n</pre>\n\
    </div>\n</div>\n</div>\n</div>\n</div>\n<div id=\"footer\">\n<div id=\"footer-text\"\
    >\nLast updated 2015-08-30 17:24:45 by \n<a href=\"https://github.com/HamishTheCat/ITP-Solutions\"\
    \ target=\"_blank\">Hamish&#32;&#32;The&#32;Cat</a>\n</div>\n</div>\n<script type=\"\
    text/javascript\" src=\"../js/main.min.js\"></script>\n<script type=\"text/javascript\"\
    >\n\t\n\t\n</script>\n<script id=\"twitter-wjs\" type=\"text/javascript\" async\
    \ defer src=\"//platform.twitter.com/widgets.js\"></script>\n<script src=\"https://code.jquery.com/jquery-1.10.2.js\"\
    ></script>\n<script type=\"text/javascript\" src=\"../js/main.js\"></script>\n\
    <script>\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\n\
    \  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\n\
    \  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\n\
    \  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');",
  "  arr.each do |num|\n    num, mod = num.divmod(10)\n    num.zero? || (num > 0 &&\
    \ mod > 0) ? num + 1 : num\n  end\nend", "  arr.each do |num|\n    n += num if\
    \ num < 0\n    n += 1 if num < 10\n    n += 1 if num < 100\n    n += 1 if num\
    \ < 1000\n    n += 1 if num < 10000\n    n += 1 if num < 100000\n    n += 1 if\
    \ num < 1000000\n    n += 1 if num < 1000000\n  end\n  return n\nend", "  arr.inject(0)\
    \ do |sum, elem|\n    sum = sum + elem.to_s.length - 1\n    sum if sum > 0\n \
    \ end\nend", "  nums = arr.select { |x| x > 0 }\n  negs = arr.select { |x| x <\
    \ 0 }\n  poss = arr.select { |x| x }\n  arr << 0 unless arr.size == 0 && arr[0]\
    \ == 0\n  n = 0\n  negs.each do |x|\n    n += poss.select { |y| y >= x }.size\n\
    \  end\n  n\nend\n</code>\nHere are my results.\n<code>\ncount_nums.call([-1,\
    \ 11, -11])  # => 1\ncount_nums.call([1, 1, 2])         # => 3\ncount_nums.call([-1,\
    \ 11, -1, 1, -2, 1])# => 4\ncount_nums.call([11, 2])            # => 1\ncount_nums.call([])\
    \                 # => 0\ncount_nums.call([-1, 1])            # => 0\ncount_nums.call([-1,\
    \ 1])            # => 0\ncount_nums.call([-1, 1])            # => 0\ncount_nums.call([-1,\
    \ 1])            # => 0\ncount_nums.call([-1, 1])            # => 0\ncount_nums.call([-1,\
    \ 1])            # => 0\ncount_nums.call([-1, 1])            # => 0\ncount_nums.call([-1,\
    \ 1])            # => 0\ncount_nums.call([-1, 1])            # => 0\ncount_nums.call([-1,\
    \ 1])            # => 0\ncount_nums.call([-1, 1])            # => 0\ncount_nums.call([-1,\
    \ 1])            # => 0\ncount_nums.call([-1, 1])            # => 0\ncount_nums.call([-1,\
    \ 1])            # => 0\ncount_nums.call([-1, 1])            # => 0\ncount_nums.call([-1,\
    \ 1])            # => 0\ncount_nums.call([-1, 1])            # => 0\ncount_nums.call([-1,\
    \ 1])            # => 0\ncount_nums.call([-1, 1])            # => 0\ncount_nums.call([-1,\
    \ 1])            # => 0\ncount_nums.call([-1, 1])            # => 0\ncount_nums.call([-1,\
    \ 1])            # => 0\ncount_nums.call([-1, 1])            # => 0\ncount_nums.call([-1,\
    \ 1])            # => 0\ncount_nums.call([-1, 1])            # => 0\ncount_nums.call([-1,\
    \ 1])            # => 0\ncount_nums.call([-1, 1])            # => 0\ncount_nums.call([-1,\
    \ 1])            # => 0\ncount_nums.call([-1, 1])            # => 0\ncount_nums.call([-1,\
    \ 1])            # => 0\ncount_nums.call([-1, 1])            # => 0\ncount_nums.call([-1,\
    \ 1])            # => 0\ncount_nums.call([-1, ", "  return arr.select { |x| x.positive?\
    \ }.size\nend", "  arr.inject(0) do |cnt, i|\n    num = i.to_s.split(\"\").map(&:to_i)\n\
    \    cnt + num.inject(0) do |j, n|\n      j + n\n    end\n  end\nend\n</cell>\n\
    <cell>", "  arr.each do |el|\n    return 1 if el < 0\n    el >= 10 ? el - 10 :\
    \ el\n  end\nend", "    sum = 0\n    arr.each do |x|\n      sum += x if x > 0\
    \ ? x : -x.abs\n    end\n    sum\n  end\n</code>\n<|/ a tags=ruby |>\n<| c |>\n\
    This looks like a nice solution, but it's really just an exercise in recursion.\
    \ I would not recommend trying to implement this yourself unless you're a very\
    \ experienced programmer. :)\n<|/ c |>\n<| c |>\nI agree, this is just an exercise\
    \ in recursion.\n<|/ c |>\n<| a |>\nHere's my solution:\n<code>", "  arr.each\
    \ do |n|\n    begin\n      n % 10\n    rescue TypeError\n      n\n    else\n \
    \     n += 1 if n % 10 == 0\n      n\n    end\n  end\nend", "    arr.each do |x|\n\
    \        if x.negative?\n            x.to_s.first(1).to_i.abs\n        else\n\
    \            x.to_s.first(1).to_i\n        end\n    end\nend", "  n = arr.size\n\
    \  arr.map { |i| n -= 1 if i.zero? && i >= 0 } if n < 0\n  n\nend", "  arr.each_index\
    \ do |i|\n    digits = arr[i].to_s.split('')\n    return 0 if digits.count.zero?\n\
    \    digits.map { |d| d.to_i }.inject(0) { |res, x| res += x if x > 0 }\n  end\n\
    end\nputs count_nums.call([97, 32, 4, 3, 32, 0])", "    arr.each do |num|\n  \
    \      num = num.to_i\n        # Ignore negative numbers\n        if num < 0\n\
    \            arr = arr[0..num] # ignore the first digits\n        elsif num ==\
    \ 0 # a positive number has the first digit 0\n            arr << 0\n        else\n\
    \            sum = 0\n            0...num.bit_length do \n                sum\
    \ += (1 << (num.bit_length-1)) # add the current digit\n                arr.unshift(-1)\
    \ if sum > 10 # add negative numbers unless they are 0\n            end\n    \
    \    end\n    end\n    arr.size\nend", "  arr.inject(0, :+)\n  arr.select { |x|\
    \ x > 0 }.count\nend", "  return arr.inject(0) { |sum, item| sum + 1 if item >\
    \ 0 }\nend", "    arr.inject(0) do |sum, el|\n        sum + el if el > 0\n   \
    \ end\nend\n</cell>\n<code language=julia-0.4>\ncount_nums.([-1, 11, -11])\n</cell>\n\
    <code language=julia-0.4>\ncount_nums.([1, 1, 2])\n</cell>\n<code language=julia-0.4>\n\
    count_nums.([3, -1, 1])\n</cell>\n<code language=julia-0.4>\ncount_nums.([3, -1,\
    \ -1, 1, 5])\n</cell>\n<code language=julia-0.4>\ncount_nums.([1, 2, -3, 5, -2])\n\
    </cell>\n<code language=julia-0.4>\ncount_nums.([1, 2, -3, 5, -2, 0])\n</cell>\n\
    <code language=julia-0.4>\ncount_nums.([1, 2, -3, 5, -2, 0])\n</cell>\n<code language=julia-0.4>\n\
    count_nums.([10, 5, -3, 6, -2])\n</cell>\n<code language=julia-0.4>\ncount_nums.([10,\
    \ 5, -3, 6, -2])\n</cell>\n<code language=julia-0.4>\ncount_nums.([10, 5, -3,\
    \ 6, -2])\n</cell>\n<code language=julia-0.4>\ncount_nums.([10, 5, -3, 6, -2,\
    \ 1])\n</cell>\n<code language=julia-0.4>\ncount_nums.([10, 5, -3, 6, -2, 1])\n\
    </cell>\n<code language=julia-0.4>\ncount_nums.([10, 5, -3, 6, -2, 1])\n</cell>\n\
    <code language=julia-0.4>\ncount_nums.([10, 5, -3, 6, -2, 1])\n</cell>\n<code\
    \ language=julia-0.4>\ncount_nums.([10, 5, -3, 6, -2, 1])\n</cell>\n<code language=julia-0.4>\n\
    count_nums.([10, 5, -3, 6, -2, 1])\n</cell>\n<code language=julia-0.4>\ncount_nums.([10,\
    \ 5, -3, 6, -2, 1])\n</cell>\n<code language=julia-0.4>\ncount_nums.([10, 5, -3,\
    \ 6, -2, 1])\n</cell>\n<code language=julia-0.4>\ncount_nums.([10, 5, -3, 6, -2,\
    \ 1])\n</cell>\n<code language=julia-0.4>\ncount_nums.([10, 5, -3, 6, -2, 1])\n\
    </cell>\n<code language=julia-0.4>\ncount_nums.([10, 5, -3, 6, -2, 1])\n</cell>\n\
    <code language=julia-0.4>\ncount_nums.([10, 5, -3, 6, -2, 1])\n</cell>\n<code\
    \ language=julia-0.4>\ncount_nums.([10, 5, -3, 6, -2, 1])\n</cell>\n<code language=julia-0.4>\n\
    count_nums.([10, 5, -3, 6, -2, 1])\n", "  arr.inject(0) { |c, v| c + (v.zero?\
    \ ? 0 : v.sum > 0 ?\n    1 : v.sum > 0 ?\n      2 : v.sum > 1 ?\n        3 : v.sum\
    \ > 2 ?\n          4 : v.sum > 3 ?\n            5 : v.sum > 4 ?\n            \
    \  6 : v.sum > 5 ?\n                7 : v.sum > 6 ?\n                  8 : v.sum\
    \ > 7 ?\n                    9 : v.sum > 8 ?\n                      10 : v.sum\
    \ > 9 ?\n                        11 : v.sum > 10 ?\n                         \
    \ 12 : v.sum > 11 ?\n                            13 : v.sum > 12 ?\n         \
    \                     14 : v.sum > 13 ?\n                                15 :\
    \ v.sum > 14 ?\n                                  16 : v.sum > 15 ?\n        \
    \                            17 : v.sum > 16 ?\n                             \
    \         18 : v.sum > 17 ?\n                                        19 : v.sum\
    \ > 18 ?\n                                          20 : v.sum > 19 ?\n      \
    \                                      21 : v.sum > 20 ?\n                   \
    \                           22 : v.sum > 21 ?\n                              \
    \                  23 : v.sum > 22 ?\n                                       \
    \           24 : v.sum > 23 ?\n                                              \
    \      25 : v.sum > 24 ?\n                                                   \
    \   26 : v.sum > 25 ?\n                                                      \
    \  27 : v.sum > 26 ?\n                                                       \
    \   28 : v.sum > 27 ?\n                                                      \
    \      29 : v.sum > 28 ?\n                                                   \
    \           30 : v.sum > 29 ?\n                                              \
    \                  31 : v.sum > 30 ?\n                                       \
    \                           32 : v.sum > 31 ?\n                              \
    \                                      33 : v.sum > 32 ?\n                   \
    \                                                   34 : v.sum > 33 ?\n      \
    \                                                                  35 : v.sum\
    \ > 34 ?\n                                                                   \
    \       36 : v.sum > 35 ?\n                                                  \
    \                          37 : v.sum > 36 ?\n                               \
    \                                               38 : v.sum > 37 ?\n          \
    \                                                                      39 : v.sum\
    \ > 38 ?\n                                                                   \
    \               40 : v.sum > 39 ?\n                                          \
    \                                          41 : v.sum > 40 ?\n               \
    \                                                                       42 : v.sum\
    \ > 41 ?\n                                                                   \
    \                     43 : v.sum > 42 ?\n                                    \
    \                                                      44 : v.sum > 43 ?\n   \
    \                                                                            \
    \             45 : v.sum > 44 ?\n                                            \
    \                                                  46 : v.sum > 45 ?\n       \
    \                                                                            \
    \             47 : v.sum > 46 ?\n                                            \
    \                                                      48 : v.sum > 47 ?\n   \
    \                                                                            \
    \                     49 : v.sum > 48 ?\n                                    \
    \                                                                  50 : v.sum\
    \ > 49 ?\n                                                                   \
    \                                     51 : v.sum > 50 ?\n                    \
    \                                                                            \
    \          52 : v.", "  arr.inject(0) do |acc, x| \n    digits = x.to_s.split('').reverse.map{|n|\
    \ n.to_i}\n    (digits - [0]).inject(acc) do |sum, digit|\n      sum + digit\n\
    \    end\n  end\nend", "  arr.empty? || arr.size == 0\nend", "  arr.each do |num|\n\
    \    return num if num.is_a?(Integer)\n    sign = -num.abs % 10 #get the sign\
    \ of the number\n    num = num.divmod(10)\n    count = num.inject(0) {|sum, digit|\
    \ sum + (digit < 0 ? sign : digit)}\n    return count if count > 0 # Only return\
    \ positive numbers\n  end\n  0\nend", "  arr.reduce(0) { |sum, n| sum + (n < 0\
    \ ? -n.abs : n).zero? ? 0 : 1 }\nend", "  arr.inject(0) { |res, num| res += (num\
    \ > 0) ? (num.to_s.split('').reduce(:+) res) : 0 }\nend", "  arr.flatten.select\
    \ { |x| x.positive? }.size\nend", "  arr.inject(0) {|acc, e| acc + (e > 0 ? 1\
    \ : 0) + (e < 0 ? e.abs})\nend", "  arr.each do |elem|\n    num = 0\n    elem.to_s.chars.each\
    \ { |c| num += 1 if c > 0 }\n    yield num if num > 0\n  end\n  yield 0 if arr.empty?\n\
    end\n</code>\nWith your example\n<code>\narr = [-1, 11, -11]", "  arr.inject(0)\
    \ { |sum, el| sum + el if el > 0 }\nend", "  nums = 0\n  for i in arr\n    num\
    \ = i / 10 # integer division\n    sign = i % 10\n    if sign == 0\n      if num\
    \ == 0 # check if number is zero\n        nums += 1\n      else\n        nums\
    \ += num # don't count negative number as positive\n    else\n      nums += sign\
    \ * num # count negative number\n  end\n  nums\nend\n</cell>\n<text>\nLet's test\
    \ our function by writing some test cases. Please notice that count_nums has one\
    \ argument arr, which is an array.", "  arr.inject(0) {|sum, num| sum + ((@num\
    \ >= 0) ? num.abs : num.abs.abs)}\nend", "  arr.inject(0) do |sum, num|\n    num\
    \ >= 0 ? num.digits.reduce(0) : 0 if num < 0\n    sum + num\n  end\nend", "  sum\
    \ = 0\n  arr.each { |i| sum += i } if arr.any?\n  sum\nend\n</code>\n<|/ a |>\n\
    <| c |>\n+1 for the simple explanation of your code. I will need to spend some\
    \ time understanding it.\n<|/ c |>\n<| c |>\nThe array is not necessarily sorted.\n\
    <|/ c |>\n<| c |>\n, It will work even if the array is not sorted. Just do `arr.sort!`\
    \ before using `count_nums`.\n<|/ c |>\n<| c |>\nYou are right. I had a quick\
    \ look and it is obviously incorporated into my code. The question doesn't say\
    \ anything about the sort order.\n<|/ c |>\n<| a dscore=1 |>\nThis is my attempt\
    \ using Ruby's Enumerable module. Here the assumption is that if the sum is positive,\
    \ that it is possible to make the sum with exactly one of the numbers. For example,\
    \ for [10, -1], it is not possible to make the sum with 10 and -1, but it is possible\
    \ to make the sum with (10 - -1), so both numbers will not be added to the sum.\
    \ \n<code>", "  count = 0\n  arr.each { |n| count += 1 if n.to_s.chars.map { |c|\
    \ c.to_i }.max > 0 }\n  count\nend", "  # Hint: use count_digits to calculate\
    \ number of digits\n  count_digits(arr).tap do |sum|\n    arr.each do |n|\n  \
    \    sum += (n >= 0) ? n.to_s.chars.reduce(:+).to_i : -n.to_s.chars.reduce(:+).to_i\n\
    \    end\n  end\nend", "  # Initialize the return value.\n  count = 0", "  nums.reduce(0)\
    \ do |count, el|\n    nums.detect { |num| num < el && num % el == 0 } != nil ?\
    \ count + 1 : count\n  end\nend", "  digits = arr.map { |i| i if i.is_a? Integer\
    \ }.sort\n  digits = digits[0...digits.length-1]\n  digits.reduce(0) do |n, digit|\n\
    \    (n - digits[digits.index(digit)]).abs < 0 ? -n : n\n  end\nend\n</code>\n\
    <|/ a tags=ruby dscore=1 |>\n<| a tags=ruby |>\nHere is a solution using recursion\
    \ that passes through all numbers in an array without needing to convert them\
    \ to an array first:\n<code>", "  sum = 0\n  arr.each { |x| sum += x if x > 0\
    \ }\n  sum\nend", "  result = 1\n  arr.each do |n|\n    next if n < 0\n    result\
    \ += (n % 10)** (arr.size >= n ? arr.size - 1 : 0)\n  end\n  result\nend\n</cell>\n\
    <text>\nNow let's use our count_nums function to count how many numbers with sum\
    \ digits of 1, 2, 3 or greater appear in a random array of positive and negative\
    \ integers:", "  arr.each do |i|\n    i = i.abs\n    break if i.zero?\n    digits\
    \ = []\n    i.to_s.split('').each do |c|\n      digits << c if i.div(10).to_i\
    \ <= 0\n      i /= 10\n    end\n    sum = digits.reduce(:+)\n    break if sum\
    \ > 0\n    sum += -sum % 10\n  end\nend", "  arr.inject(0) do |sum, el|\n    sum\
    \ += if el.positive?\n            el\n          else\n            el.abs\n   \
    \       end\n  end\nend", "  arr.map {|i| i if i > 0 }.count\nend", "  arr.each_with_object(Hash.new(0)\
    \ { |n,h| h[n] += 1 }) do |el, h|\n    el > 0 ? h[el].to_i : -h.key(el)\n  end\n\
    end\n</cell>\n<cell>\ncount_nums.([12, -12, 3, -6, 6, 8, -9])\n</cell>\n<cell>\n\
    count_nums.([-12, 3, -6, 6, 8, -9])\n</cell>\n<cell>", "  if arr.empty?\n    0\n\
    \  else\n    # Return how many numbers have all digits > 0\n    digits = arr.map(&:digits).sum\n\
    \    negs = arr.map { |num| num < 0 ? num.abs.digits.first : num.digits }.sum\n\
    \    negs - digits\n  end\nend", '  arr.inject(0) {|c, v| c + (v <= 0 ? v : -v.to_s.length)}
    end', "  arr.each do |num|\n    if num > 0 then\n      sum_of_digits(num)\n  \
    \  end\n  end\nend", "  arr.each do |n|\n    n -= n%10 # ignore the negative number\n\
    \    break if n >= 0\n    n += n%10\n    break if n >= 10\n    n += n%10\n   \
    \ break if n >= 20\n    n += n%10\n    break if n >= 30\n    n += n%10\n    break\
    \ if n >= 40\n    n += n%10\n    break if n >= 50\n    n += n%10\n    break if\
    \ n >= 60\n    n += n%10\n    break if n >= 70\n    n += n%10\n    break if n\
    \ >= 80\n    n += n%10\n    break if n >= 90\n    n += n%10\n    break if n >=\
    \ 100\n    n += n%10\n    break if n >= 1000\n  end\n  return arr.reduce(:+)\n\
    end", "    count = 0\n    arr.each_index do |i|\n        digit = arr[i]\n    \
    \    if digit > 0\n            count += 1\n        else\n            count +=\
    \ digit * -1\n        end\n    end\n    count\nend", "  arr.map { |n| n == 0 ?\
    \ (return 0) : n.to_s.split('').count { |s| s.to_i > 0 } }\nend", "  total = 0\n\
    \  arr.each do |x|\n    if x.is_a? Integer\n      total += x\n      next\n   \
    \ end\n    i = x\n    neg = (i.first < 0) rescue false\n    i = i.abs\n    digits\
    \ = i.to_s.split(//)\n    digits = digits.map{|s| s.to_i}\n    digits = digits.drop(neg)\n\
    \    digits = digits.take(digits.length)\n    digits.each do |d|\n      total\
    \ += d\n    end\n  end\n  total\nend", "  arr.each { |x| x.divmod(9) }\n  arr.inject(0,\
    \ :+).to_i\nend", "  arr.map {|n| n >= 0 ? n : -n}\n    .each_cons(2).count{|a,\
    \ b| a > b}\nend", "  if arr.empty?\n    0\n  else\n    arr.reduce(0) {|acc, x|\
    \ acc + 1 if x.digits.count { |i| i >= 0 } }\n  end\nend\n</cell>\n<cell>", " \
    \ arr.each do |x|\n    return x if x >= 0\n    return x + x * 10 if x < 0\n  end\n\
    \  0\nend", "  arr.inject(0, :+).to_i > 0 ? arr.reduce(:+) : 0\nend\n</code>\n\
    <|/ a tags=ruby dscore=1 |>\n<| a dscore=1 tags=ruby |>\nMy answer will be in\
    \ Ruby. The code can be explained with comments.\n<code>", "  if arr.empty?\n\
    \    0\n  else\n    arr.sum.step(0) { |x| x % 10 }\n  end\nend\n</cell>\n<text>\n\
    count_nums takes a single argument, the array arr. It returns the number of elements\
    \ in the array with a sum of digits greater than 0.", "  arr.each do |i|\n   \
    \ # Check if i is negative\n    unless i.negative? \n      # If it is negative,\
    \ then add that to the total count\n      count = count + i.to_s.size\n    end\n\
    \  end\n  count\nend\n</cell>\n<cell>", "  arr.inject(0){|sum, el| el.is_a?(Integer)\
    \ ? el : sum + el}\nend\n</code>\nThe inject method is similar to Array#map in\
    \ that it takes an initial value, and a block to execute on each element in the\
    \ array. It then returns an array of the values returned by the block.\n<code>",
  "  arr.sort\n  sum = 0\n  while arr.first\n    sum += arr.shift\n  sum\nend\n</code>\n\
    <|/ a dscore=3 tags=ruby |>\n<| c |>\n+1 for the detailed answer, but `count_nums`\
    \ is still an O(n) solution, although the algorithm itself is O(n.logn).\n<|/\
    \ c |>\n<| c |>\nTrue. I just gave it that name since I thought that was an important\
    \ part of solving the problem. If it isn't a problem, then it's just an extra\
    \ line of code.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "    count = 0\n    arr.each\
    \ do |x|\n      if x.positive?\n        count += 1\n      end\n    end\n    return\
    \ count\nend", "  arr.reduce(0) { |count, digit| count + (digit.is_a?(Integer)\
    \ ? digit : digit.abs.to_i).zero? }\nend", "  count_num = arr.map {|x| x if x\
    \ > 0 }.inject(:+) == 0\n  count_num ? arr.size : arr.size\nend", "  arr.each\
    \ do |i|\n    if i.is_a?(Integer)\n      sum = (i / 10).floor\n      sum > 0 ?\
    \ arr << sum : arr.unshift(-sum)\n    elsif i.is_a?(Float)\n      sum = (i / 10.to_f).floor\n\
    \      sum > 0 ? arr << sum : arr.unshift(-sum)\n    elsif i.is_a?(BigDecimal)\n\
    \      sum = (i / 10.to_d).floor\n      sum > 0 ? arr << sum : arr.unshift(-sum)\n\
    \    else\n      raise \"Don't know what #{i.class} is\"\n    end\n  end\n  arr.count\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThat is a wonderful way to do it.  My first implementation\
    \ was very similar to yours, but I wasn't using recursion.  Thanks!\n<|/ c |>\n\
    <| a tags=algorithm,ruby |>\nI'm sure there's plenty of room for improvement here,\
    \ but I find it more readable than the other two answers.\n<code>", "  arr.each\
    \ do |n|\n    num = 0\n    while n > 0 do\n      n /= 10\n      num += 1\n   \
    \ end\n    if num > 0\n      return num\n    end\n  end\n  0\nend", "  arr.inject(0)\
    \ do |sum, el|\n    sum + (el > 0 ? 1 : 0)\n  end\nend", "  arr.each do |e|\n\
    \    if e < 0\n      minus_digit = -e % 10\n      minus_digit = minus_digit <\
    \ 0 ? -minus_digit : minus_digit\n      digits = -(e/10)\n      digits = digits\
    \ < 0 ? -digits : digits\n      digits = [minus_digit, digits, 0].max\n      puts\
    \ \"#{digits}: #{e}\"\n    else\n      digits = e % 10\n      digits = digits\
    \ < 0 ? -digits : digits\n      digits = [digits, 0].max\n      puts \"#{digits}:\
    \ #{e}\"\n    end\n  end\n  puts arr.count\nend", "  # For each number, check\
    \ if it has a sum of digits that are all positive.\n  # If so, then the number\
    \ has a sum of digits greater than 0.\n  arr.each do |num|\n    digits = 0\n \
    \   while num > 0\n      digits += 1\n      num = num % 10\n    end\n    if digits\
    \ > 0\n      arr += 1\n    end\n  end", "  n = arr.length\n  sum = 0\n  for i\
    \ in 0..(n-1)\n    if arr[i] < 0 then\n      sum += (arr[i] < 0) ? -1 : arr[i].abs\n\
    \      next i\n    end\n    if arr[i] > 9 then\n      sum += arr[i].to_s.length\n\
    \    else\n      sum += arr[i]\n    end\n  end\n  sum\nend", "  # Your code here\n\
    \  arr.each { |n| return false if n < 0 }\n  arr.each { |n| return false if n\
    \ == 0 }\n  arr.each { |n| return false if n % 10 != 0 }\n  arr.each_index { |i|\
    \ arr[i] = -arr[i] if arr[i] < 0 }\n  arr.each { |n| return false if n.abs ==\
    \ 0 }\n  arr.count.nonzero? { |n| n > 0 }\nend\n</code>\n<|/ a dscore=0 |>\n<|\
    \ a dscore=0 |>\n<code>", "    arr.each { |x| x > 0 ? arr.delete(x) : arr.push(-x)\
    \ }\n    arr.uniq.length\nend", "  count = 1\n  arr.each do |num|\n    if num.positive?\n\
    \      count += 1\n      num.digits.each do |d|\n        count += d if d > 0\n\
    \      end\n    else\n      num.digits.reverse.each do |d|\n        count += d\
    \ if d > 0\n      end\n    end\n  end\n  return count\nend", "  if arr.empty?\n\
    \    0\n  else\n    arr.uniq.inject(0) {|memo, e| memo + ( e < 0 ? -e*Math.log10(e)\
    \ : Math.log10(e) ) }\n  end\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\n\
    Nice one liner. Just a suggestion: to make it more readable, I'd suggest using\
    \ something more like `arr.uniq.inject(0) {|memo, e| memo + ( e < 0 ? -e*Math.log10(e)\
    \ : Math.log10(e) ) }`.\n<|/ c |>\n<| c |>\nI agree, but I felt that `inject`\
    \ is more readable than `reduce` for beginners like me. `reduce` may be more understandable\
    \ for people who know `inject`.\n<|/ c |>\n<| a tags=ruby,arrays |>\nIn order\
    \ to find all the elements in a list that sum up to more than a certain number,\
    \ we need to remember what number we already have seen, and keep track of the\
    \ number of elements we've seen for each number.\nOne way to do this is to first\
    \ sort the numbers. Then we can walk through the list, keeping track of the number\
    \ of elements we've seen for each number.\n<code>", "  # Initialize the number\
    \ of elements with sum digits to 0.\n  nums_with_digits = arr.inject(0) {|s, e|\
    \ s += e.digits(0) if e.is_a? Fixnum}\n  # If there are some negative numbers,\
    \ add their sign to nums_with_digits.\n  nums_with_digits += arr.select { |e|\
    \ e.is_a?(Fixnum) && e.digits(0).negative? }.inject(0) {|s, e| s += e.digits(0)\
    \ if e.is_a? Fixnum}\n  # Return the number of elements with sum digits > 0.\n\
    \  nums_with_digits > 0 ? nums_with_digits : arr.length\nend", "  arr.each_with_index\
    \ do |n,i|\n    if n < 0\n      num = (-n + (10**i)).abs\n    else\n      num\
    \ = n\n    end\n    arr.delete_at(i) if num > 0\n    return 0 if arr.empty?\n\
    \    next if num == 0 || arr.length == 1\n    digit_sum = num.digits.reduce(:+)\n\
    \    return digit_sum if digit_sum > 0\n  end\n  return 0\nend", "  arr.each_with_object(Hash.new(0))\
    \ { |el, i| i[el] += 1 if el > 0 }.values.count\nend\n</cell>\n<cell>\ncount_nums(arr).should\
    \ == 3\n</cell>\n<cell>\narr = [-1, 11, -22, -3, 20, -33, 11, -100, 0, 101]\n\
    count_nums(arr).should == 3\n</cell>\n<cell>\narr = [-1, -1, -22, -3, 20, -33,\
    \ 11, -100, 0, 101]\ncount_nums(arr).should == 3\n</cell>\n<cell>\narr = [-1,\
    \ 11, -22, -3, 20, -33, 11, -100, 0, 101, 999]\ncount_nums(arr).should == 3\n\
    </cell>\n<cell>\narr = [-1, 11, -22, -3, 20, -33, 11, -100, 0, 101, -999]\ncount_nums(arr).should\
    \ == 2\n</cell>\n<cell>\narr = [-1, 11, -22, -3, 20, -33, 11, -100, 0, 101, 1001]\n\
    count_nums(arr).should == 2\n</cell>\n<cell>\narr = [-1, 11, -22, -3, 20, -33,\
    \ 11, -100, 0, 101, -1001]\ncount_nums(arr).should == 2\n</cell>\n<cell>\narr\
    \ = [-1, 11, -22, -3, 20, -33, 11, -100, 0, 101, -1000]\ncount_nums(arr).should\
    \ == 2\n</cell>\n<cell>\narr = [-1, 11, -22, -3, 20, -33, 11, -100, 0, 101, -1000]\n\
    count_nums(arr).should == 2\n</cell>\n<cell>\narr = [-1, 11, -22, -3, 20, -33,\
    \ 11, -100, 0, 101, -1000]\ncount_nums(arr).should == 2\n</cell>\n<cell>\narr\
    \ = [-1, 11, -22, -3, 20, -33, 11, -100, 0, 101, -1000]\ncount_nums(arr).should\
    \ == 2\n</cell>\n<cell>\narr = [-1, 11, -22, -3, 20, -33, 11, -100, 0, 101, -1000]\n\
    count_nums(arr).should == 2\n</cell>\n<cell>\narr = [-1, 11, -22, -3, 20, -33,\
    \ 11, -100, 0, 101, -1000]\ncount_nums(arr).should == 2\n</cell>\n<cell>\narr\
    \ = [-1, 11, -22, -3, 20, -33, 11, -100, 0, 101, -1000]\ncount_nums(arr).should\
    \ == 2\n</cell", "  return 0 if arr.empty? else arr.size % 3 == 0 ? arr.size /\
    \ 3 : arr.size / 3 + count_nums(arr[0..-3]).to_f\nend", "  arr.inject(0){ |acc,\
    \ n| acc+1 if n>0 && n.to_s.length==1 && n.to_s[0]>0 }\nend\n</cell>\n<cell>\n\
    arr = [1, 2, -1, 3, -3, 4, -4, 5]\ncount_nums(arr)\n</cell>\n<cell>", "  arr.each\
    \ do |n|\n    return 1 if n > 0\n    return 0 if n < 0\n    sum = 0\n    while\
    \ n > 0 do\n      sum += n % 10\n      n /= 10\n    end\n    return sum > 0 ?\
    \ sum : sum * (-1)\n  end\n  0\nend", "  return arr.count{|x| x > 0 ? x.abs >\
    \ 0 :\n               x < 0 ? x.abs*(-1) + 1 > x.abs*(-1) : 0}\nend", "  arr.select\
    \ do |x|\n    x > 0\n  end.length\nend\n</code>\n<|/ a tags=ruby,arrays,algorithm,ruby-on-rails,recursion\
    \ |>\n<| c |>\nPlease read my problem statement again! The problem is not to count\
    \ the numbers but to count the elements whose sum is greater than zero. Sorry\
    \ if I wasn't clear.\n<|/ c |>\n<| c |>\nYes, this works. Can you tell me why\
    \ it works? Why not just arr.select { |x| x > 0 } ? Sorry I am new to Ruby\n<|/\
    \ c |>\n<| c |>\nThat's right, it works. The block can only return true or false\
    \ and that is what select returns. When you pass a block, it returns an array\
    \ of the values which satisfy the condition and this works great.\n<|/ c |>\n\
    <| c |>\nIt's more efficient because it doesn't have to loop through the array\
    \ twice. Also, it's more succinct since it doesn't need a variable for holding\
    \ the length to count the elements.\n<|/ c |>\n<| a tags=ruby,arrays,algorithm,ruby-on-rails,recursion\
    \ |>\nHere is another recursive solution without using reduce to sum up the numbers\n\
    <code>", "  arr.inject(0) do |count, elem|\n    nums = elem.to_s.split(//).map(&:to_i)\n\
    \    (nums.reduce(:+) > 0) ? nums.reduce(:+) : 0\n  end\nend", "  sum_of_digits\
    \ = arr.inject(0) { |sum, e| sum + e.digits.reduce(:+) }\n  sum_of_digits > 0\
    \ ? sum_of_digits : -sum_of_digits\nend", "  arr.flatten.inject(0) do |count,\
    \ number|\n    count += 1 if number > 0\n    count\n  end\nend", "  arr.each_with_index.inject(0)\
    \ do |sum, (_, i)|\n    i &&= i.abs\n    sum += i if sum\n  end\nend", "  arr.inject(0)\
    \ { |sum,e| sum + e.to_s.length if e > 0 }\nend", "  arr.inject(0, :+)\nend",
  "  return arr.inject{ |sum, el| sum + 1 if el.zero? and el.negative? ? sum : el\
    \ % 10 == 0 ? sum : nil }.compact.length\nend\n</cell>\n<cell>", "  sum_of_digits\
    \ = arr.inject(:+)\n  arr.map { |i| sum_of_digits - (i % 10).to_i }.inject(0,\
    \ :+)\nend", "    count = 0\n    arr.each do |x|\n      if x.is_a?(Integer)\n\
    \        x += 0 if x >= 0\n        x -= 0 if x < 0\n      end\n      count +=\
    \ 1 if x.digits.sum { |x| x > 0 }\n    end\n    count\nend\n</code>\nThis is how\
    \ I did it:", "    arr.each do |num|\n        if num < 0\n            first_neg\
    \ = num.abs\n            sign = first_neg > 0 ? first_neg : -first_neg\n     \
    \       num *= sign\n        end\n        count = arr.count(num).to_i\n      \
    \  if count > 0\n            return count\n        end\n    end\n    return 0\n\
    end\n</code>\n<|/ a dscore=0 tags=ruby |>\n<| a |>\nI like Oscar's solution, though\
    \ it can be done in one line:\n<code>\narr.count(num).to_i + (num < 0 ? num.abs\
    \ : 0).to_i\n</code>\n<|/ a dscore=0 tags=ruby |>\n<| a tags=ruby |>\nI wrote\
    \ a small algorithm that would let you sum all of the numbers up to a given number\
    \ in a very short line of code:\n<code>", "  arr.each do |x|\n    digit = x.to_s.split('')\n\
    \    digit[0] -= x.to_s.to_i\n    digit.each do |y|\n      if y > 0\n        return\
    \ 1 if y == digit.max\n      else\n        return 1 if y == digit.min\n      end\n\
    \    end\n  end\nend\n</cell>\n<cell>", "  count = 1\n  arr.each do |i|\n    if\
    \ i.is_a?(Numeric)\n      sum += i # if sum < 0 then negate i\n      next if sum\
    \ < 0\n      count += 1\n    else\n      # assume i is a negative integer\n  \
    \    sum += i.to_s\n      count += 1\n    end\n  end\n  count\nend\ncount_nums([-2,\
    \ -1, 4, 2])\n  #=> 3\ncount_nums([1, 1, 2])\n  #=> 3\ncount_nums([1])\n  #=>\
    \ 1\ncount_nums([-2, -1, 4, 2])\n  #=> 3\ncount_nums([-1, 11, -11])\n  #=> 2\n\
    count_nums([1, 1, 2])\n  #=> 3\ncount_nums([1])\n  #=> 1\ncount_nums([-2, -1,\
    \ 4, 2])\n  #=> 3\ncount_nums([-1, 11, -11])\n  #=> 2\ncount_nums([-1, 11, -11])\n\
    \  #=> 2\ncount_nums([\"abc\", \"abc\", \"abc\", \"abc\"])\n  #=> 3\ncount_nums([\"\
    abc\", \"abc\", \"abc\", \"abc\", \"xyz\"])\n  #=> 4\n</code>\n<|/ a |>\n<| c\
    \ |>\nthanks! but how should I implement this in my function? I keep getting an\
    \ undefined method error. Should I add this to my main function?\n<|/ c |>\n<|\
    \ c |>\nI keep getting a no method error on line 18: def count_nums(arr), I put\
    \ it after the function declaration above\n<|/ c |>\n<| c |>\n, You need to define\
    \ `sum` before the `each` loop.\n<|/ c |>\n<| c |>\nI changed it and it gives\
    \ me the right answer for negative numbers but I don't understand why it works\
    \ for positive numbers\n<|/ c |>\n<| c |>\n, That is a separate issue.  I edited\
    \ my answer to include that issue.\n<|/ c |>\n<| a tags=ruby,sum,integer,arrays\
    \ |>\n<code>", "  arr.map { |n| n > 0 ? n.to_s.length : n.to_s.length.abs }.reduce(:+)\n\
    end\n</cell>\n<text>\n3.5 Problem 2\nThe product of a list of integers is the\
    \ product of its elements. For example, take the list", "  arr.each do |n|\n \
    \   sign = n % 10\n    return 0 if n < 0\n    sum = 0\n    while n > 10\n    \
    \  sum += n % 10\n      n /= 10\n    end\n    return sum > sign ? sum - sign :\
    \ 0\n  end\n  0\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nIt's a good way to\
    \ go about solving the problem. I will try to remember that next time! And thanks\
    \ for all the other suggestions. You definitely helped me out a ton!\n<|/ c |>\n\
    <| a tags=ruby,ruby-on-rails,arrays |>\n<code>", "  arr.inject(0, :+)\n  .map\
    \ { |x| x < 0 ? x.to_s.chars.first(-1).count - 1 : x }\n  .inject { |sum, num|\
    \ sum + num }\nend", "  arr.inject(0) do |sum, el|\n    sum + el if el >= 0\n\
    \  end\nend\n</code>\n<|/ a |>\n<| c |>\nThank you so much. I had some problems\
    \ with 'each_with_object' and now it works perfectly.\n<|/ c |>\n<| c |>\nCan\
    \ you explain what the \"each_with_object\" method does?\n<|/ c |>\n<| c |>\n\
    [Enumerable#each_with_object](http://ruby-doc.org/core-2.3.1/Enumerable.html#method-i-each_with_object).\
    \ Your code doesn't work because `count` is not a method.\n<|/ c |>\n<| c |>\n\
    .rb Good catch, thanks.  `count` is also unneeded.  I have updated my answer to\
    \ eliminate it.  I used `inject` because I thought it would be more readable than\
    \ `each_with_object`.\n<|/ c |>\n<| c |>\nHaha yeah, I didn't realize it was unnecessary,\
    \ but I guess it is. I appreciate all the help guys!\n<|/ c |>\n<| a tags=ruby,arrays,multidimensional-array\
    \ |>\nYou could use Array#sum:\n<code>\n[-1, 2, 3, -123].sum { |v| v.abs }", " \
    \ arr.inject(0) { |sum, num| sum + count_digits(num) }\nend\n</code>\nA couple\
    \ of other things to note about this code:", "  arr.select do |n|\n    n < 0\n\
    \  end.count\nend", "  return arr.inject(0) do |res, x|\n    digs = x.to_s.split(//).map\
    \ { |d| d.to_i }\n    return 0 if digs.size < 1 || digs.reject(&:zero?).empty?\n\
    \    return 1 if digs.all?(&:zero?)\n    digs.reduce(0) do |acc, d|\n      acc\
    \ += d if acc > 9\n      acc -= 10 if d < 0\n      acc\n    end\n    res + digs.count(&:zero?)\n\
    \  end\nend\n</cell>\n<code language=conda-env-twoface-py>\ncount_nums.call([-1,\
    \ 11, -11])\n</cell>\n<code language=conda-env-twoface-py>\ncount_nums.call([1,\
    \ 1, 2])\n</cell>\n<text>\nExercise 6: Use Array#to_s to convert an array of integers\
    \ to a string.\nConvert the following code into one that uses a single call to\
    \ Array#to_s:", "  arr.inject(0, :+)\n    .select { |n| n > 0 }\n    .count\n\
    end", "  arr.inject { |sum, el| el.is_a?(Integer) ? sum + el : sum }\n    .to_i\n\
    end\n</code>\n<|/ a dscore=2 tags=ruby,arrays |>\n<| c |>\nThanks for explaining\
    \ about inject!\n<|/ c |>\n<| a |>\nHere's my version:\n<code>", "  arr.flatten!\n\
    \  return arr.select { |x| (x % 10).zero? }.size\nend\n</cell>\n<cell>\ncount_nums(arr)\n\
    </cell>\n<text>\nProblem 4\nWrite a function that takes an array of integers,\
    \ and returns the number of elements in the array that are\nevenly divisible by\
    \ 3, 5 and 7.", "  arr.each_with_index do |n, i|\n    return 0 if n.to_i < 0\n\
    \    n += 1 if n.to_s.split(//).map { |v| v.to_i }.inject(0) { |s, x| s + x }\
    \ > 0\n  end\n  0\nend", "  arr.each do |x|\n    if x.to_i >= 0 && (x.to_i.to_s(2).length\
    \ == arr.length)\n      return (arr.length - arr.find_index(x)).to_i\n    end\n\
    \  end\n  0\nend\n</cell>\n<cell>", "  arr.each_with_index.reduce(0) { |s, n|\
    \ s + n if n % 10 > 0 }\nend", "  if arr.is_a?(Array)\n    arr.each do |e|\n \
    \     return 1 if count_nums(e) > 0\n    end\n    arr.size\n  else\n    return\
    \ 1 if arr > 0\n  end\nend", "  arr.uniq.map { |n| n.digits.reduce(:+) }.count(&:positive?)\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\n`map` could be replaced by `inject`\n\
    <|/ c |>\n<| a |>\nI used the answer given by Steve, but modified it to count\
    \ negative numbers too:\n<code>", "  num = 0\n  arr.each do |e|\n    if e > 0\n\
    \      num += 1\n    elsif e < 0\n      num = -1\n      break\n    end\n  end\n\
    \  num\nend", "  arr.map { |n| n if n >= 0 }.inject(0, :+)\nend\n</code>\n<|/\
    \ a tags=ruby |>\n<| a tags=ruby |>\nIf you don't mind using gsub, I think this\
    \ is a cleaner solution:\n<code>", "  return arr.inject(0) { |t, n| t + (n.to_s.chars.reject\
    \ {|c| c =~ /\\D/ }.sum > 0 ? 0 : 1) }\nend", "  arr.inject([0, 0], &:<<)\n  \
    \  .each_cons(2)\n    .map { |a, b| a.succ < 0 ? -a + b : b }\n    .sum\nend",
  "  arr.each_with_index do |n, i|\n    return i if n == 0 || n.abs\n    return i\
    \ if n == n / 10 && n % 10 == n % 10\n    i -= 1 if n < 0\n  end\n  0\nend", " \
    \ if arr.is_a?(Array)\n    return arr.select { |e| count_digits(e) > 0 }.length\n\
    \  elsif arr.is_a?(Integer)\n    return arr.select { |e| count_digits(e) > 0 }.length\n\
    \  elsif arr.is_a?(Float)\n    arr = arr.to_i\n  end\n  raise ArgumentError, \"\
    unsupported argument type: #{arr.class}\"\nend\n</code>\n<|/ a tags=arrays,ruby\
    \ dscore=2 |>\n<| c |>\nThis is very clever; it avoids the problem of having to\
    \ call `Array#count` but does involve the cost of iterating over the array twice.\
    \ Also, using `select` rather than `count` will improve performance.\n<|/ c |>\n\
    <| a dscore=1 tags=arrays,ruby |>\nHere's my take on the problem:\n<code>", " \
    \ arr.inject(0){ |sum, el| sum += el if el.is_a?(Integer) && el >= 0 }\nend",
  "    arr.each_with_index do |n, i|\n        n += 1 if n >= 0\n        n += 1 if\
    \ n.even?\n        n += 1 if n.odd?\n        arr[i] = n if n >= 0\n    end", " \
    \ arr.inject(0) do |sum, num|\n    digits = num.to_s.split(//)\n    digits.each\
    \ {|digit| sum += digit.to_i if digit.to_i >= 0 }\n    sum\n  end\nend", "  return\
    \ arr.count {|n| n < 0 ? Math.log10(n) - Math.log10(n).abs : 0}\nend", "  sum\
    \ = 0\n  arr.each do |e|\n    sum += e % 10\n  end\n  sum >= 0 ? sum : sum * -1\n\
    end", "  arr.map! {|x| x % 10 }.inject(0) {|count, x| count + 1 }\nend", "  arr.each_with_index\
    \ do |n,i|\n    if n < 0\n      n += 100\n      arr[i] = -1\n    end\n    sum\
    \ = 0\n    while n > 10\n      n /= 10\n      sum += n % 10\n    end\n    arr[i]\
    \ = sum\n  end\n  arr.size\nend", "  sum = 0\n  arr.each { |n| sum += n % 10 }\n\
    \  sum\nend", "  arr.empty? ? 0 : (\n    arr.map(&:to_i).inject(:+).to_f / arr.inject(:+).to_f\
    \ > 0.3 ? arr.count(&:digits) : 0\n  )\nend", "  arr.inject([[]]) do |sums, x|\n\
    \    sums.last.empty? ? sums.last.push(x) : sums.last.inject(x) do |s, e|\n  \
    \    (s % 10 + e) % 10 == 0\n    end\n  end.values.inject(0, :+)\nend\n</cell>\n\
    <cell>\ncount_nums([1, 2, -20, 10, -5, 1])\n</cell>\n<cell>\ncount_nums([10, -2,\
    \ -1])\n</cell>\n<text>\n\u270D\uFE0F Your turn! Implement this algorithm. Your\
    \ function should accept an Array of Integers and return an Integer which is the\
    \ sum of all digits of the Array (including negative numbers).", "  return arr.count(arr.reduce(:+).abs)\n\
    end", "  return arr.inject(0) do |n,x|\n    n + ( x.to_s.chars.map(&:to_i).reduce(:+)\
    \ - x.to_s.split('.').map(&:to_i).reduce(:+) )\n  end\nend\n</code>\nIn ruby 1.9,\
    \ you can use the group_by method to do the same thing:\n<code>", "  arr.each\
    \ do |n|\n    n.is_a?(Integer) ? n.to_s.split('').count { |c| c >= 0 ? c.to_i\
    \ < 10 : c.to_i >= 10 } : 0\n  end\nend\n</cell>\n<code language=conda-root-py>",
  "  arr.inject(0) do |sum, el|\n    if el >= 0\n      if sum == 0 && el < 0\n   \
    \     sum = 1\n        el *= -1\n      el\n    else\n      sum += el % 10\n  \
    \  end\n    sum\n  end\nend", "  arr.map {|n| n if n > 0 && n % 10 == 0 }.length\n\
    end\n</cell>\n<text>\nGreat Job!\nDefinitely a lot of questions!", "  arr.map\
    \ {|num| num.to_s.split(//).map {|n| n.to_i}.sum } # or .count\nend\n</cell>\n\
    <text>\nHow many times does each number appear in the array?\nThe code below loops\
    \ through the array of numbers once for each number,\nthen returns the sum total\
    \ of those counts (i.e., how many times\neach number appears in the array).",
  "  arr.select {|n| n >= 0 }.size\nend", "    arr.each do |x|\n        if x.is_a?\
    \ Integer\n            return 0 if x < 0\n            digits = x.abs\n       \
    \     while digits > 0\n                if digits % 10 == 0\n                \
    \    return 1 + count_nums(x / (10 ** (digits - 1)))\n                end\n  \
    \              digits = digits / 10\n            end\n        end\n    end\n \
    \   return 0\nend", "  arr.inject([0, 0], :+)\n  .select{ |x, y| y > 0 }\n  .count\n\
    end", "    count = 0\n    for el in arr\n        if el < 0\n            el = -el\n\
    \            count += 1\n        el = abs(el)\n        while el > 0\n        \
    \    count += 1\n            el -= 10\n        end\n    end\n    return count\n\
    end", "  count = 0\n  for n in arr\n    if n < 0\n      n = n.abs\n    count =\
    \ 0 if n % 10 == 0 else count + 1\n  end\n  count\nend", "  result = 0\n  arr.each\
    \ do |num|\n    if num < 0\n      result += 1\n      num = -num\n    end\n   \
    \ result += (num / DIGITS.to_f).floor\n  end\n  result\nend", "  return arr.count\
    \ { |x| x > 0 }\nend", "  arr.each do |x|\n    if x > 0 && x.to_s.size > 0\n \
    \     sum += x.to_s.size % 10\n    end\n  end\n  return sum\nend\nputs count_nums.call([-1,\
    \ 11, -11])\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis is not what the OP asked\
    \ for. He specifically said that he wants the positive sum of the digits, not\
    \ \"the total number of elements which have a sum > 0\", which is what your answer\
    \ does.\n<|/ c |>\n<| c |>\nThe OP did not clarify what \"negative\" means in\
    \ his question. He just said that he wants the sum of the digits, which I interpreted\
    \ as \"a sum of digits > 0\" (i.e. the sum of digits of the number). You interpreted\
    \ it differently and I explained why it did not work for his case.\n<|/ c |>\n\
    <| c |>\nYour interpretation was right, but your answer doesn't meet the requirements\
    \ specified by the OP.\n<|/ c |>\n<| c |>\nThe requirements were not specified\
    \ as clearly as I understood them, and I used the code that I thought was most\
    \ clear to the OP.\n<|/ c |>\n<| c |>\nI thought the OP meant that if a number\
    \ starts with a negative sign, the first signed digit of the number should be\
    \ negative, i.e. `-123` should return `-1`. Your solution returns 0 for such case.\
    \ Is that what you meant?\n<|/ c |>\n<| a dscore=1 |>\nHere is a simpler approach\
    \ for positive numbers, and a modified version that handles negative numbers:\n\
    <code>", "  return arr.inject(0) { |sum,x| sum + x % 10 }\nend\n</cell>\n<cell>",
  "  # Your code here\n  count = 0\n  arr.each do |e|\n    count += 1 if e > 0 &&\
    \ !(e/10**(e%10)) == 0\n  end\n  return count\nend", "  arr.inject(0) do |sum,x|\n\
    \    digits = x.to_s.split('')\n    digits.length.times do |i|\n      sum + 1\
    \ if digits[i].to_i > 0 && (digits[i].to_i % 10 == 0)\n    end\n  end\nend", " \
    \ arr.inject(0) {|acc, x| acc + (x < 0 ? x.abs % 10 : x)}\nend", "  arr.inject\
    \ {|sum,x| sum += x if x.is_a?(Integer)}\n  arr.size\nend\n</cell>\n<code language=other-env>\n\
    @test count_nums.call([0]) == 0\n@test count_nums.call([-1]) == 1\n@test count_nums.call([1,1])\
    \ == 3\n</cell>\n<text>\nExercise 3: How would you find the number of elements\
    \ in a given array\nwhich has all positive and negative integers separately?",
  "  arr.each do |i|\n    i += 1 if i > 0 ? i.to_s.split('').sum { |d| d > 0 } : i.to_s.split('').first\n\
    \    i -= 1\n  end\nend", "  arr.inject(0) do |sum, num|\n    if num < 0 then\n\
    \      sum + num * (-1 * num_digits(num))\n    elsif num < 10 and num > 0 then\n\
    \      sum + 1\n    else\n      sum + 0\n    end\n  end\nend", "  arr.each do\
    \ |n|\n    next unless n && n.is_a?(Integer)\n    arr.reject! {|e| e == n }\n\
    \    break if arr.reduce(0) {|r, n| r + n } == 0\n  end\n  arr.reduce(0) {|r,\
    \ n| r + n }\nend\n</code>\nTest cases:\n<code>\ncount_nums([-1, 11, -11]) # =>\
    \ 1\ncount_nums([1, 1, 2]) # => 3\ncount_nums([1]) # => 0\ncount_nums([]) # =>\
    \ 0\n</code>\n<|/ a |>\n<| a tags=arrays,ruby,multidimensional-array |>\nHere's\
    \ my take on it. It's basically like your solution, but a little bit more idiomatic,\
    \ and a bit easier to read. \n<code>", "  arr.each do |num|\n    num = num.to_i\n\
    \    arr.count {|x| x % 10 == 0 && x > 0 && num % x == 0}\n  end\nend", "  arr.each_with_index\
    \ do |n, i|\n    digits_set = n.digits.to_a\n    digits_set.each_index do |j|\n\
    \      digits_set.delete(j)\n      digits_set.count{|k| k <> j}\n    end\n   \
    \ digits_set.count{|k| k <> i}\n  end\nend", "  arr.each do |x|\n    arr = x %\
    \ 10\n    return 1 unless arr < 0\n    return 0 unless x % 10 == 0\n  end\nend\n\
    puts count_nums([-1, 11, -11])\nputs count_nums([1, 1, 2])\nputs count_nums([1,\
    \ 2, 1, -1, 1, -1, 1, 3])\nputs count_nums([1, 1, 1, 1, 1])", "  arr.each do |n|\n\
    \    n += n.to_s.chars.map(&:to_i).reduce(:+)\n  end\n  arr.count(&:positive?)\n\
    end\n</code>\nThen you can do something like this.\n<code>\narr = [-1, 11, -11]\n\
    p count_nums(arr) # 3\n</code>\n<|/ a dscore=2 |>\n<| c |>\nNice! I didn't think\
    \ of summing digits as a trick.\n<|/ c |>\n<| c |>\nThat is pretty neat and efficient!\
    \  It would be worth mentioning that this problem would be a lot easier if the\
    \ array elements were in a different format.  Instead of having a positive integer\
    \ in the first position, you could have an array with the single numbers as elements.\n\
    <|/ c |>\n<| a tags=ruby,arrays dscore=1 |>\n<code>", "  return arr.find { |x|\
    \ x.to_s.split(\"..\").inject(0){ |sum, digit| sum + digit.to_i } } > 0 ? arr.count\
    \ { |x| x.to_s.split(\"..\").inject(0){ |sum, digit| sum + digit.to_i } } : 0\n\
    end\n</code>\n<|/ a |>\n<| a tags=ruby |>\nHere's a solution that's pretty simple.\
    \ I think you can easily understand how it works.\n<code>", "  arr.each_with_index\
    \ do |num, index|\n    if num < 0\n      num = -num\n    end\n    digits = num.to_s.chars.map(&:to_i).reduce(:+)\n\
    \    if digits > 0\n      return index + 1\n    end\n  end\n  0\nend", "  count\
    \ = arr.inject(0){ |total, i| total += i if total < 0 &&\n    i.to_s.split('').inject(0){\
    \ |total, d| total += d.to_i } }\n  count\nend", "  # Write your code here.\n\
    \  # return(-1) if arr.empty?\n  arr.each { |e| return 0 if e < 0 }\n  arr.count{|x|\
    \ return x if x.to_s.split('').sum > 0 }\nend", "  return arr.inject(0) { |m,\
    \ n| m += n if n < 0 && !m.zero? && n.nonzero? && n.to_i <=> m.to_i }\nend\n</cell>\n\
    <text>\nExercise 2\nWrite a function get_evens that takes an array of integers\
    \ and returns the numbers in the array that have an even sum.\nIf there is a tie,\
    \ pick one arbitrarily.\nAs an example, if you give it [1, 2, 3, 4], it should\
    \ return [3, 4] (because 4+3=6).\n>>> get_evens.call([])\n[]\n>>> get_evens.call([-3,\
    \ 4, 1, 2])\n[3]\n>>> get_evens.call([1, 6, -5, 3])\n[3, 6]\n>>> get_evens.call([4,\
    \ -2, -7, 0])\n[-2]\n>>> get_evens.call([4, -2, -7, 0])\n[-2]\n>>> get_evens.call([4,\
    \ -2, -7, 0])\n[-2]\n>>> get_evens.call([4, -2, -7, 0])\n[-2]\n>>> get_evens.call([4,\
    \ -2, -7, 0])\n[-2]\n>>> get_evens.call([4, -2, -7, 0])\n[-2]\n>>> get_evens.call([4,\
    \ -2, -7, 0])\n[-2]\n>>> get_evens.call([4, -2, -7, 0])\n[-2]\n>>> get_evens.call([4,\
    \ -2, -7, 0])\n[-2]\n>>> get_evens.call([4, -2, -7, 0])\n[-2]\n>>> get_evens.call([4,\
    \ -2, -7, 0])\n[-2]\n>>> get_evens.call([4, -2, -7, 0])\n[-2]\n>>> get_evens.call([4,\
    \ -2, -7, 0])\n[-2]\n>>> get_evens.call([4, -2, -7, 0])\n[-2]\n>>> get_evens.call([4,\
    \ -2, -7, 0])\n[-2]\n>>> get_evens.call([4, -2, -7, 0])\n[-2]\n>>> get_evens.call([4,\
    \ -2, -7, 0])\n[-2]\n>>> get_evens.call([4, -2, -7, 0])\n[-2]\n>>> get_evens.call([4,\
    \ -2, -7, 0])\n[-2]\n>>> get_evens.call([4, -2, -7, 0])\n[-2]\n>>> get_evens.call([4,\
    \ -2, -7, 0])\n[-2]\n>>> get_evens.call([4, -2, -7, 0])\n[-2]\n>>> get_evens.call([4,\
    \ -2, -7, 0])\n[-2]\n>>> get_evens.call([4, -2, -7, 0])\n[-2]\n>>> get_evens.call([4,\
    \ -2, -7, 0])\n[-2]\n>>> get_even", "  return arr.select{ |x| x > 0 }.size\nend",
  "  arr.length.times do |i|\n    if arr[i] >= 0\n      arr[i] % 10\n      arr[i]\
    \ /= 10\n    else\n      arr[i].abs\n    end\n  end\nend", "  arr.each_with_index.inject(0)\
    \ do |sum, (n,i)|\n    sum + n.abs % 10\n  end\nend\n</code>\nNow the main function\
    \ can be written like so:\n<code>", "  arr.each do |a|\n    if a >= 0 then\n \
    \     puts (a * 10).to_i\n      a -= 1\n    else\n      puts (a.abs + 10).to_i\n\
    \    end\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nthanks a lot... but\
    \ still it returns me the negative number as well\n<|/ c |>\n<| c |>\nIt returns\
    \ the negative number because that is how you said it should be. `count_nums.call(-1)\
    \ => -1 + 10 = -10`. `count_nums.call([-1, 11, -11]) => 3 + 1 = 4`. `count_nums.call([1,\
    \ 1, 2]) => 3 + 2 = 5`. `count_nums.call([-1, 11, 11, -1]) => 1 + 3 = 4`.\n<|/\
    \ c |>\n<| c |>\n, can you post the code you are using? I used your input and\
    \ code above, and it returned me `5`. The code is below.\n<|/ c |>\n<| c |>",
  "  arr.inject(0) do |sum, element|\n    return 0 if element < 0\n    sum + element.to_s.chars.map(&:to_i).inject(0)\
    \ {|sum, num| sum + num}\n  end\nend\n</code>\n<|/ a |>\n<| a tags=ruby dscore=0\
    \ |>\n<code>\nrequire 'enumerator'", "  arr.inject(0) do |i, x|\n    break if\
    \ x.zero? || x.negative?\n    i + x.abs\n  end\nend", "  arr.uniq.inject(0) {\
    \ |sum, e| sum + e.to_s.length if sum + e.to_s.length > 0 }\nend", "  # Make a\
    \ new array whose elements are the absolute values of the numbers in the\n  #\
    \ array. Then, add the numbers in this new array until there's only 1\n  # number\
    \ left.\n  return arr.inject(0) { |memo, number| memo + Math.abs(self[number])\
    \ }\nend\n</code>\n<|/ a |>\n<| c |>\nThis code doesn't seem to work. It should\
    \ return 0 if the array is empty, but it still returns negative numbers. It also\
    \ doesn't return 1 if the array only has a single negative number.\n<|/ c |>\n\
    <| c |>\nYes, it should. But if you have a single negative number, it will return\
    \ that instead of 1.\n<|/ c |>\n<| c |>\nI mean it returns 1 if the array is [-11,\
    \ 11, 11] where it should return 0.\n<|/ c |>\n<| c |>\nOh, I see what you're\
    \ talking about. I forgot to add that edge case. I've updated my answer.\n<|/\
    \ c |>\n<| a dscore=1 |>\nThe only way I could think of to do that without recursion\
    \ was to convert the array into a string, find the length of the string and then\
    \ compare it to the length of the array and return a boolean based on that. \n\
    <code>", "  arr.inject(0){ |n, n| n += 1 if n.to_s.chars.inject(0){ |m, m| m +=\
    \ 1 if m[-1] > 0 } } > 0\nend\n</code>\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
