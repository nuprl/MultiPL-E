name: HumanEval_133_sum_squares
language: rb
prompt: "# You are given an array of numbers.\n# You need to return the sum of squared\
  \ numbers in the given array,\n# round each element in the array to the upper int(Ceiling)\
  \ first.\n# Examples:\n# >>> lst.call([1.0, 2.0, 3.0])\n# 14\n# >>> lst.call([1.0,\
  \ 4.0, 9.0])\n# 98\n# >>> lst.call([1.0, 3.0, 5.0, 7.0])\n# 84\n# >>> lst.call([1.4,\
  \ 4.2, 0.0])\n# 29\n# >>> lst.call([-2.4, 1.0, 1.0])\n# 6\ndef sum_squares(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_squares\n\
  \    candidate = method(:sum_squares)\n    assert_equal(14, candidate.call([1.0,\
  \ 2.0, 3.0]))\n    assert_equal(14, candidate.call([1.0, 2.0, 3.0]))\n    assert_equal(84,\
  \ candidate.call([1.0, 3.0, 5.0, 7.0]))\n    assert_equal(29, candidate.call([1.4,\
  \ 4.2, 0.0]))\n    assert_equal(6, candidate.call([-2.4, 1.0, 1.0]))\n    assert_equal(10230,\
  \ candidate.call([100.0, 1.0, 15.0, 2.0]))\n    assert_equal(200000000, candidate.call([10000.0,\
  \ 10000.0]))\n    assert_equal(75, candidate.call([-1.4, 4.6, 6.3]))\n    assert_equal(1086,\
  \ candidate.call([-1.4, 17.9, 18.9, 19.9]))\n    assert_equal(0, candidate.call([0.0]))\n\
  \    assert_equal(1, candidate.call([-1.0]))\n    assert_equal(2, candidate.call([-1.0,\
  \ 1.0, 0.0]))\n  end\nend\n"
completions: ["  # Your code here\n  return 0\nend\n</cell>\n<cell>", "  lst.map{|i|\
    \ i.round}.inject(:+)\nend", "  sum = lst.inject(0){|sum, e| sum + e**2}\n  lst.each\
    \ {|e| e = e.round}\n  sum\nend\n</cell>\n<code language=julia-0.5>\nsum_squares([1.0,\
    \ 2.5, 3.0, 4.0])\n</cell>\n<code language=julia-0.5>\nsum_squares([1.0, 4.0,\
    \ 9.0])\n</cell>\n<code language=julia-0.5>\nsum_squares([1.0, 3.0, 5.0, 7.0])\n\
    </cell>\n<code language=julia-0.5>\nsum_squares([1.4, 4.2, 0.0])\n</cell>\n<code\
    \ language=julia-0.5>\nsum_squares([-2.4, 1.0, 1.0])\n</cell>\n<code language=julia-0.5>\n\
    sum_squares([-1.1, -0.9, 0.2])\n</cell>\n<code language=julia-0.5>\nsum_squares([-10.6,\
    \ 1.2, 0.3])\n</cell>\n<code language=julia-0.5>\nsum_squares([-2.1, 1.0, 0.3])\n\
    </cell>\n<code language=julia-0.5>\nsum_squares([-10.6, 1.0, 0.3])\n</cell>\n\
    <text>\nSquaring\nNow let's write a function which returns squaring of an array.",
  "  result = 0\n  numbers.each_with_index { |item, i| result += item * item }\n \
    \ result\nend", "  lst.map(&:round)\n  lst.inject{|sum, n| sum + n * n}\nend",
  "  sum = 0.0\n  for num in lst\n    sum += num * num\n  end\n  sum\nend\n</cell>\n\
    <code language=julia-1.0>\nsum_squares([1.0, 2.0, 3.0])\n</cell>\n<code language=julia-1.0>\n\
    sum_squares([1.0, 4.0, 9.0])\n</cell>\n<code language=julia-1.0>\nsum_squares([1.0,\
    \ 3.0, 5.0, 7.0])\n</cell>\n<code language=julia-1.0>\nsum_squares([1.4, 4.2,\
    \ 0.0])\n</cell>\n<code language=julia-1.0>\nsum_squares([-2.4, 1.0, 1.0])\n</cell>\n\
    <code language=julia-1.0>", "  sum_ = 0\n  arr=[]\n  arr.map!{|n| n}\n  arr.map!{|n|\
    \ Math.ceil(n*10).to_i}\n  arr.map!{|n| n*n}\n  arr.each{|n| sum_+=n}\n  return\
    \ sum_\nend\n</cell>\n<code language=julia-1.4>\nsum_squares([-5, -4, 3])\n</cell>\n\
    <code language=julia-1.4>\nsum_squares([-5, -4, 3])\n</cell>\n<code language=julia-1.4>\n\
    sum_squares([-5, -4, 3])\n</cell>\n<code language=julia-1.4>\nsum_squares([-5,\
    \ -4, 3])\n</cell>\n<text>\nProblem 8\nGiven an array of ints, return an array\
    \ of the unique elements within that array.", "    sum = 0\n    for i in lst\n\
    \      sum += i.round * i.round\n    return sum\nend", "  return sum(x**2 for\
    \ x in lst)\nend\n</cell>\n<code language=julia-1.0>\nsum_squares(lst)\n</cell>\n\
    <text>\n3. Map and Filter\nAs mentioned before, Julia has a lot of built-in high-performance\
    \ functions that we might want to use as a part of our algorithms. Here are some\
    \ of the most useful ones:", "  return(sum((lst - int(lst)).^2))\nend", "  sum\
    \ = 0\n  for i in lst\n    sum += i * i\n  sum.round(2)\nend", "  lst.map{|e|\
    \ e.ceil}.inject(0){|sum, el| sum + el**2}\nend", "  lst.each do |x|\n    x =\
    \ x.round\n    sum += x*x\n  end\n  sum\nend\n</code>\n<|/ a tags=ruby |>\n<|\
    \ c |>\nWhy are you using `each_with_index`? `each_with_index` is for iterating\
    \ over a collection while simultaneously incrementing a counter variable (in this\
    \ case it's `i`).\n<|/ c |>\n<| a tags=ruby |>\nThe first part can be solved easily\
    \ by using Math.pow to raise to power of 10.\nThen we simply have to add the numbers\
    \ up\n<code>", "  sum = 0\n  for i in lst\n    sum += i ** 2\n  end\n  sum.round(upto(@ceiling))\n\
    end\n</code>\n<|/ a |>\n<| a tags=ruby,rounding,arrays,function |>\n<code>", " \
    \ if lst.empty?\n    0.0\n  elsif lst.size < 2\n    0.0\n  else\n    lst.reduce(:+).to_f\
    \ / lst.size.to_f * lst.inject(:+).to_f\n  end\nend", "  return lst.map(&:**2).reduce(:+)\n\
    end", "  sum = 0\n  for i in lst\n    sum += i*i\n  end\n  sum\nend", "  sum_squares(lst,0)\n\
    end", "  sum = 0\n  \n  i = 0\n  \n  while i < lst.length\n    \n    if i == lst.length\n\
    \      break", "  lst.each_with_index { |e, i| lst[i] = Math.ceil(e).to_i }\n\
    \  lst.inject(0) do |sum, v|\n    sum + v ** 2\n  end\nend\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nIt should be noted that these solutions assume that the inputs\
    \ are non-negative.  This is probably not the case in most real-life situations.\n\
    <|/ c |>\n<| c |>\nI think that's a good point.  If you're going to do this, I\
    \ recommend that you should add some checks to make sure that the array is actually\
    \ a proper array (e.g. `if !lst.is_a?(Array)`) before calling `sum_squares`.\n\
    <|/ c |>\n<| c |>\nYou also need to check for non-negative values before rounding.\n\
    <|/ c |>\n<| c |>\nThis is wrong if the list has negative numbers. Try `sum_squares([-23.0,\
    \ -6.0, 9.0])`.\n<|/ c |>\n<| c |>\nThanks for pointing that out. Fixed now (I\
    \ hope).\n<|/ c |>\n<| a tags=ruby,arrays,methods |>\nAnother solution, using\
    \ inject:\n<code>", "  # Write your solution here\nend", "  if lst.nil?\n    0\n\
    \  else\n    sum_of_squares = lst.inject {|sum, value| sum + value * value}\n\
    \    sum_of_squares.round\n  end\nend", "  lst.map!{|x| (x + x).round}\n  return\
    \ lst.inject(0) {|sum, e| sum + e * e }\nend", "  n = lst.size\n  sum = 0.0\n\
    \  for i in 0...n\n    sum += lst[i]*lst[i]\n  end\n  return sum\nend", "  sum_squares(@to_array(lst)).round\n\
    end", "  sum = 0\n  for i in 0...lst.size\n    sum += i * i\n  end\n  return sum\n\
    end", "  sum = 0.0\n  lst.each do |number|\n    sum += (number.round * number)\n\
    \  end\n  return sum\nend", "  sum=0\n  for i in lst\n    sum+=i**2\n  return\
    \ sum\nend\n</code>\nHere are a couple of other variants:\n<code>", "  sum = 0.0;\n\
    \  for x in lst\n    sum += x * x\n  sum = (sum / lst.count).ceil\n  return sum\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,arrays,math |>\nThe solution is\
    \ quite simple, but only if you know the sum of the squares (as you said in the\
    \ question). You can use the formula Sum of squares of i=(2^k)-1!/(k! * 2^k)=Sum\
    \ of squares of i=(2k+1)! / (k! * 2^k)\n<code>", "    return lst.inject(0) {|sum,x|\
    \ sum + x*x }\nend\n</code>\n<|/ a |>\n<| c |>\nThe above solution uses inject\
    \ and I dont know how that works. Could you please give me the explanation for\
    \ this code?\n<|/ c |>\n<| c |>\n, inject is the same as reduce with initial value\
    \ and `+` operator, i.e `sum_squares([1,2,3]) #=> 6`\n<|/ c |>\n<| c |>\nHow is\
    \ the `sum` variable getting initialized with `0` in the first call? I understand\
    \ that `inject` is the reducing function and `|sum,x| sum + x*x ` is the first\
    \ argument to `inject` which can be either a number or an array/collection of\
    \ numbers. I understand that `sum` is a variable that gets updated inside the\
    \ loop. My doubt is how does this `|sum,x| sum + x*x` becomes `6`?\n<|/ c |>\n\
    <| c |>\n, this is just ruby syntax. `|sum,x| sum + x*x` is block taking sum as\
    \ `0` initially and adding `x` to it on each iteration. Now `inject` will return\
    \ `sum` which is `6`.\n<|/ c |>\n<| c |>\nOh, I think I get it. I guess the `|sum,x|\
    \ sum + x*x` part is returning the updated `sum`. Thought it would return `x`\
    \ initially but that doesn't make sense because `x` won't be updated inside the\
    \ loop. Thanks for clarifying!\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  sum =\
    \ 0\n  sum = (Math.ceil(lst.inject { |sum, n| sum + Math.pow(n, 2) })).inject\
    \ { |sum, n| sum + Math.pow(n, 2) }\n  return sum\nend", "  sum_ = 0\n  for i\
    \ in lst\n    sum_ = sum_ + i.to_f**2 # convert to float to prevent precision\
    \ loss\n  return sum_\nend", "  sum = 0\n  for i in lst\n    sum += i * i\n  end\n\
    \  sum\nend\n</cell>\n<code language=julia-1.0>\nsum_squares(lst)\n</cell>\n<text>\n\
    Great! Your sum_squares function works well. Now you can start writing some of\
    \ your own.", "  arr.sort!\n  sum = 0\n  arr.map do |x|\n    sum += Math.sqrt(x)\n\
    \  end\n  sum\nend", "  sum = 0\n  for i in lst\n    sum += i ** 2\n  end\n  sum.round\n\
    \  return sum\nend", "  sum = List.new(0)\n  lst = List.round(lst)\n  for i in\
    \ lst\n    sum = sum + i ** 2\n  end\n  return sum\nend", "  return lst.inject(0)\
    \ {|sum,x| sum += x*x }\nend", "  lst.each do |num|\n    num = ceil(num)\n   \
    \ num*num\n  end\nend", "  return lst.map(&:round).reduce(:+)\nend", "  sum_squares\
    \ = 0\n  lst.each_with_index {|x,i| sum_squares += x * x if x && i > 0 }\n  sum_squares\n\
    end", "  sum = 0\n  num = 0\n  for i in lst\n    num = num * i\n    sum += num\n\
    \  end", "  sum = 0\n  lst.each do |item|\n    sum += item ** 2\n  end\n  sum\n\
    end\n</cell>\n<text>\nNotice how we first initialize sum to 0, and we only update\
    \ it when we encounter a number that is greater than 0.", "  sum = 0\n  numbers.each\
    \ do |x|\n    sum += x.to_i ** 2\n  end\n  sum\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nI'm curious why you chose that particular algorithm. Why not use Math.sqrt\
    \ or Math.abs?\n<|/ c |>\n<| c |>\nThe goal was to show how simple ruby code can\
    \ be broken down into smaller pieces. You already had the logic in the code you\
    \ had already written. I did not want to write any more lines of code. Also, my\
    \ code will break if the input is negative, which is the case for the OP's input\
    \ data. I chose `Math.sqrt` because it is guaranteed to be precise up to a point,\
    \ and `Math.abs` would be incorrect for negative numbers.\n<|/ c |>\n<| c |>\n\
    Oh, I understand that now :)\n<|/ c |>\n<| a dscore=0 |>\n<code>", "    sum =\
    \ 0\n    for i in lst\n        sum += (i ** 2)\n    return round(sum, int(math.ceil(math.log10(sum))))",
  "  # +++your code here+++\n  sum_sq = nil\n  \n  # Find the sum of the squares.\n\
    \  sum_sq = lst.inject(0){|sum, item| sum + item*item}\n  \n  # Round the sum\
    \ to the ceiling of the number.\n  sum_sq = sum_sq.round(int(math.ceil(lst.first)))\n\
    \  \n  return sum_sq\nend\n</cell>\n<code language=julia-1.0>\nsum_squares([1.0,\
    \ 4.0, 9.0])\n</cell>\n<text>\nProblem 6", "  sum = 0\n  for i in lst\n    sum\
    \ += i * i\n  return sum\nend", "    sum = 0\n    list = Array.new(lst, 1)\n \
    \   list.each do |x|\n        sum += Math.ceil(x * x)\n    end\n    sum\nend",
  "  sum = 0\n  lst.each_with_index do |e, i|\n    sum += i * i\n  end\n  return sum\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThis doesn't actually round the values. I think\
    \ OP wants something like `lst.map{|e| Math.ceil(e*e)}.reduce(:+)`.\n<|/ c |>\n\
    <| c |>\nThanks for pointing that out. I've updated the answer\n<|/ c |>\n<| a\
    \ tags=ruby |>\nThe question is not about the rounding, but about how to calculate\
    \ the sum of squared integers in an array.\nThis can be done in a single expression:\n\
    <code>", "  total = sum = 0\n  lst.each do |x|\n    total += x * x\n  end\n  total\n\
    end", "  sum = 0\n  arr.each do |x|\n    sum += (x*x)\n  end\n  sum\nend", " \
    \   sum = 0\n    sum = sum + lst[0] * lst[0]\n    sum2 = sum\n    sum2 = sum2\
    \ + lst[0] * lst[1]\n    sum3 = sum\n    sum3 = sum3 + lst[1] * lst[1]\n    sum4\
    \ = sum\n    sum4 = sum4 + lst[2] * lst[2]\n    return sum + sum2 + sum3 + sum4",
  "  sum = 0.0\n  for n in lst\n    sum += n * n\n  return sum\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nNicely done, but I'd use \"(n ^ 2)\" instead of \"n * n\", as\
    \ it's much faster. Although it won't matter much in this case, because it's only\
    \ called for a small number of elements. Also I wouldn't use \"sum_squares\" as\
    \ an actual function name, as it is a keyword. I'd suggest using \"sum_of_squares\"\
    \ instead.\n<|/ c |>\n<| c |>\nThat's true, I'll change it to sum_of_squares.\
    \ Thanks for the tip about using the fast math notation ^ instead of *. I'm a\
    \ big fan of using \"fast\" math for code readability reasons as well as to improve\
    \ speed for loops that aren't super slow.\n<|/ c |>\n<| a tags=ruby |>\n<code>",
  "    sum = 0.0\n    lst = lst.map { |x| x.round(5) }\n    lst.each do |x|\n    \
    \    sum += x*x\n    end\n    return sum\nend", "  sum = 0\n  lst.each{|x| sum\
    \ += x*x}\n  sum\nend", "  lst.map {|e| e.ceil}\n  lst.inject {|sum, i| sum +\
    \ i ** 2}\nend", "  return lst.map(&:round).reduce(:+)\nend\n</code>\n<|/ a tags=ruby\
    \ dscore=1 |>\n<| c |>\nYou can avoid the map by passing `&:round` to `reduce`:\
    \ `lst.map(&:round).reduce(:+) => 14`\n<|/ c |>\n<| c |>\n`map` creates unnecessary\
    \ intermediate arrays though. `sum_squares` would be much more efficient if it\
    \ were: `lst.map(&:round).reduce(:+).round(10)`\n<|/ c |>\n<| a tags=ruby |>\n\
    <code>\narray = [1.1, 2.2, 3.3, 4.4]\nsum_squares = (array.map { |x| x.to_f**2\
    \ }).sum\n</code>\nOr\n<code>\nsum_squares = array.map{ |x| x**2 }.inject(:+)\
    \ # =>  25.8\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby |>\nIn addition to what\
    \ have been posted already, a more functional approach (as opposed to using map\
    \ and inject) is to use reduce and yield:\n<code>", "  return lst.inject(:+).map\
    \ { |n| n.ceil ** 2 }.reduce(:+) \nend", "  result = 0.0\n  for x in lst\n   \
    \ result = result + x * x\n  end\n  return round(result)\nend", "  lst.map{|x|\
    \ x**2}.inject(:+)\nend", "  sum = 0.0\n  for i in lst\n    sum += i * i\n  end\n\
    \  return sum\nend", "  result = 0.0\n  lst.each { |x| result += (Math.ceil(x)).to_i\
    \ * Math.ceil(x.to_i) ** 2 }\n  result\nend", "  lst.map {|x| x*x}\nend", "  \
    \  # Your code here\n    lst.inject(&:+) \n    lst.map{|x| (x**2).round(Ceil)\
    \ } \nend", "  ret = 0\n  for i in 0...lst.size\n    val = lst[i]\n    ret = ret\
    \ + val*val\n  end\n  ret\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby |>\n\
    <code>", "  return sum(x**2 for x in lst.round)\nend", "  lst.map { |x| x * x\
    \ }.reduce(:+)\nend\n</cell>\n<code language=julia-1.0>\nsum_squares([1.0, 2.0,\
    \ 3.0])\n</cell>\n<code language=julia-1.0>\nsum_squares([1.0, 4.0, 9.0])\n</cell>\n\
    <code language=julia-1.0>\nsum_squares([1.0, 3.0, 5.0, 7.0])\n</cell>\n<code language=julia-1.0>\n\
    sum_squares([1.4, 4.2, 0.0])\n</cell>\n<code language=julia-1.0>\nsum_squares([-2.4,\
    \ 1.0, 1.0])\n</cell>\n<code language=julia-1.0>\nsum_squares([1.0, 2.0, 3.0])\n\
    </cell>\n<text>\nExercises", "  # Your code goes here\nend\n</cell>\n<code language=julia-1.0>",
  "  sum = 0.0\n  for i in lst\n    sum += Math.ceil(Math.pow(i, 2))\n  return sum",
  "  n = 0\n  for x in lst\n    n += (x*x)\n  return round(math.ceil(n))\nend", " \
    \ lst.map! {|num| num.round }\n  lst.inject {|sum, elem| sum + elem.to_f ** 2\
    \ }\nend", "  sum = 0\n  arr.each do |x|\n    sum += x*x\n  end\n  sum\nend",
  "  sum = 0\n  for i in lst\n    sum += i ** 2\n  sum = (sum / lst.size).round(2)\n\
    \  return sum\nend", "  sum = 0\n  for x in lst\n    sum += x*x\n  return sum\n\
    end", "  sum = 0\n  for i in lst\n    sum += i ** 2\n  return round(sum, 2)\n\
    end", "  lst.each do |i|\n    i -= i.ceil\n    i = i * i\n  end\n  sum = lst.inject(0,\
    \ :+)\n  sum\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nYou should use `inject`\
    \ instead of `each` when iterating over an array.\n<|/ c |>\n<| c |>\nAlso, you\
    \ can use `map(&:ceil).inject(:+)`.\n<|/ c |>\n<| a |>\nI see that there are some\
    \ good answers here, but I thought that I'd add a couple other answers that may\
    \ or may not be useful to the OP depending on their preference.\nHere are some\
    \ answers that use Enumerable#inject and some that use Enumerable#reduce.\n<code>",
  "  sum_ = lst.reduce(:+)\n  sum_.inject(0){|sum, e| sum + e.to_f**2}\nend", "  sum\
    \ = 0\n  for i in lst\n    sum += i ** 2\n  end\n  sum.round(2)\nend\n</cell>\n\
    <cell>", "  sum = 0\n  arr.each {|x| sum += Math.pow(x,2) }\n  sum\nend\n  ",
  "  if lst.empty?\n    0\n  else\n    lst.reduce(:+).*(lst.reduce(:+))\n  end\nend",
  "  sum = 0.0\n  (0...lst.size).each do |i|\n    sum += lst[i].round\n  end\n  sum\n\
    end\n</pre>\n</div>", "  lst.map { |x| x.round }.inject(:+)\nend\n</code>\n<|/\
    \ a tags=ruby,algorithm,ruby-on-rails |>\n<| a tags=ruby,algorithm,ruby-on-rails\
    \ |>\nYou want a one-liner, and you want the solution to be recursive, so a solution\
    \ like this will work:\n<code>", "  sum = 0.0\n  arr.each do |num|\n    sum =\
    \ sum + num*num\n  end\n  sum\nend", "  return lst.inject(0) { |sum, x| sum +\
    \ x.abs * (x <=> 0).round(1) }\nend\n</cell>\n<cell>", "  squares = []\n  sum\
    \ = 0\n  lst.each do |num|\n    sum += num ** 2\n    squares << num\n  end\n \
    \ return sum, squares.map(&:ceil)\nend", "  sum = 0\n  (0..(lst.length)).each\
    \ do |i|\n    sum += lst[i] ** 2\n  end\n  return sum\nend", "  sum = 0\n  for\
    \ i in lst\n    sum += (i.to_f*i.to_f)\n  end\n  sum\nend\n</cell>\n<code language=julia-1.0>\n\
    sum_squares([1.0, 2.3, 3.5, 4.7, 6.9, 8.0])\n</cell>\n<code language=julia-1.0>\n\
    sum_squares([4.7, 7.1, 2.3, 2.1, 9.0])\n</cell>\n<code language=julia-1.0>\nsum_squares([0.0])\n\
    </cell>\n<code language=julia-1.0>\nsum_squares([0.0, 9.0])\n</cell>\n<code language=julia-1.0>\n\
    sum_squares([0.0, 0.0, 9.0])\n</cell>\n<code language=julia-1.0>\nsum_squares([-9.0,\
    \ 0.0, 9.0])\n</cell>\n<code language=julia-1.0>\nsum_squares([-9.0, 0.0, -9.0])\n\
    </cell>\n<text>\nThe sum of squares of a number $x$ is $x^2$. For example,\n$$\
    \ \\begin{align} x + x^2 + x^3 + x^4 + x^5 + x^6 &= x^2 + 2x^3 + 3x^4 + 4x^5 +\
    \ 5x^6 \\\nx + 2x + 3x+ 4x+ 5x+ 6x&= x^2 + 2x^3 + 3x^4 + 4x^5 + 5x^6\\end{align}\
    \ $$\nThe sum of squares function should return $x^2 + 2x^3 + 3x^4 + 4x^5 + 5x^6$\
    \ rounded to an upper integer.", "  # Your code here\n  sum = 0\n  for x in lst\n\
    \    sum += x**2\n  return sum\n</code>\n<|/ a |>\n<| c |>\nI agree with your\
    \ approach, but your answer is also wrong, please check the answer below.\n<|/\
    \ c |>\n<| c |>\nHi, I think my answer is right. I think your answer is wrong.\n\
    <|/ c |>\n<| c |>\nHi yeah, you are right. the answer is actually wrong. I have\
    \ edited it.\n<|/ c |>\n<| a dscore=1 |>\nThe above code is wrong.\nPlease try\
    \ this:\n<code>", "  # Your code here\n  sq = lst.reduce(:+)\n  sq.map {|x| x.ceil}.reduce(:+)\n\
    end", "  lst.map{|x| x.round(Integer::CEILING * 2).to_i}.sum\nend\n</code>\n<|/\
    \ a tags=ruby,list dscore=3 |>\n<| a |>\nIn Ruby you can use the Enumerable#inject\
    \ method to sum the squares without having to create intermediary variables. \
    \ Since inject only takes 1 parameter, the other solutions will break for multiple\
    \ inputs.\n<code>", "  sum = 0\n  for i in lst\n    sum = sum + Math.cint(Math.ceil(i))\n\
    \    sum += Math.cint(Math.ceil(i))\n  return sum\nend\n</cell>\n<code language=julia-1.0>\n\
    sum_squares([1.0, 2.0, 3.0])\n</cell>\n<code language=julia-1.0>\nsum_squares([1.0,\
    \ 4.0, 9.0])\n</cell>\n<code language=julia-1.0>\nsum_squares([1.0, 3.0, 5.0,\
    \ 7.0])\n</cell>\n<code language=julia-1.0>\nsum_squares([1.4, 4.2, 0.0])\n</cell>\n\
    <code language=julia-1.0>\nsum_squares([-2.4, 1.0, 1.0])\n</cell>\n<code language=julia-1.0>\n\
    sum_squares([-1.9, 2.3, 7.9])\n</cell>\n<code language=julia-1.0>\nsum_squares([1.1,\
    \ 2.2, 3.3, 4.4, 5.5])\n</cell>\n<text>\nGreat! Now you have a very efficient\
    \ sum function that can sum an array of numbers.", "  lst.map!{|e| e.ceil}\n \
    \ lst.inject(0) {|sum, e| sum + e * e }\nend", "  return sum (lst.map {|x| x *\
    \ x })\nend", "  sum = 0\n  for i in lst\n    sum += i * i\n  return sum\nend",
  "  sum = 0\n  sum = (lst.inject(:+))**2\n  sum.round(int(Math.ceil(lst.max)))\n\
    end", "  sum = 0\n  sum = lst.inject(0) { |sum,x| sum + x**2 }\n  sum = round(sum)\n\
    \  return sum\nend\n</cell>\n<cell>\nsum_squares(lst)\n</cell>\n<text>\nsum",
  "  sum = 0\n  for x in lst\n    sum += x * x\n  return sum\nend", "  sum = 0\n \
    \ arr.each do |x|\n    sum += Math.ceil(x) ** 2\n  end\n  return sum\nend", " \
    \ sum = 0\n  for i in 0...lst.count\n    sum = sum + lst[i]*lst[i]\n  end\n  return\
    \ sum\nend\n</cell>\n<cell>", "  lst.map{ |x| Math.ceil(x).to_s }\n  lst.map{\
    \ |x| Math.ceil(x).to_s }.inject(:+)\nend\n</code>\n<|/ a |>\n<| a tags=ruby,sum-of-squares\
    \ |>\n<code>", "  sum = 0\n  for i in lst\n    sum = sum + i**2\n  end\n  return\
    \ sum\nend", "  sum = 0\n  for i in lst\n    sum += i*i\n  return sum\nend\n</cell>\n\
    <code language=julia-1.5>\nsum_squares([1.0, 2.0, 3.0])\n</cell>\n<code language=julia-1.5>\n\
    sum_squares([1.0, 4.0, 9.0])\n</cell>\n<code language=julia-1.5>\nsum_squares([1.0,\
    \ 3.0, 5.0, 7.0])\n</cell>\n<code language=julia-1.5>\nsum_squares([1.4, 4.2,\
    \ 0.0])\n</cell>\n<code language=julia-1.5>\nsum_squares([-2.4, 1.0, 1.0])\n</cell>\n\
    <text>\nProblem 7: Sum of the Numbers\nWrite a function sum_of_numbers that\n\
    returns the sum of all integers in the given array.", "  lst.map! { |n| Math.ceil(Math.sqrt(n))\
    \ }\n  lst.inject(0) { |sum, item| sum + item*item }\nend\n</pre>\n<p>\nRuby code\
    \ in the previous cell is pretty close to the code in the first cell. Let's look\
    \ at Ruby code and Ruby code in the first cell. As you can see, Ruby code in the\
    \ first cell is a bit different, because in Ruby we usually use <code>inject(0)</code>\
    \ method to sum up the numbers in the array. In Ruby code in the previous cell,\
    \ we use <code>map!</code> method to round the numbers to the upper int(Ceiling)\
    \ first, and then use <code>inject</code> method to sum up the squares.\n</p>",
  "  return lst.inject(0) {|s, v| s + v ** 2}\nend\n</cell>\n<cell>\nsum_squares([1.0,\
    \ 2.0, 3.0])\n</cell>\n<cell>\nsum_squares([1.0, 4.0, 9.0])\n</cell>\n<cell>\n\
    sum_squares([1.0, 3.0, 5.0, 7.0])\n</cell>\n<cell>\nsum_squares([1.4, 4.2, 0.0])\n\
    </cell>\n<cell>\nsum_squares([-2.4, 1.0, 1.0])\n</cell>\n<cell>\nsum_squares([0.6,\
    \ 2.0, 3.1])\n</cell>\n<cell>\nsum_squares([0.5, 0.0, 3.1])\n</cell>\n<cell>\n\
    sum_squares([0.6, 0.0, 3.1])\n</cell>\n<cell>\nsum_squares([0.6, 2.2, 3.1])\n\
    </cell>\n<cell>\nsum_squares([0.6, 2.2, 3.1])\n</cell>\n<cell>\nsum_squares([0.6,\
    \ 2.2, 3.1])\n</cell>\n<cell>\nsum_squares([0.6, 2.2, 3.1])\n</cell>\n<cell>\n\
    sum_squares([0.6, 2.2, 3.1])\n</cell>\n<cell>\nsum_squares([0.6, 2.2, 3.1])\n\
    </cell>\n<cell>\nsum_squares([0.6, 2.2, 3.1])\n</cell>\n<cell>\nsum_squares([0.6,\
    \ 2.2, 3.1])\n</cell>\n<cell>\nsum_squares([0.6, 2.2, 3.1])\n</cell>\n<cell>\n\
    sum_squares([0.6, 2.2, 3.1])\n</cell>\n<cell>\nsum_squares([0.6, 2.2, 3.1])\n\
    </cell>\n<cell>\nsum_squares([0.6, 2.2, 3.1])\n</cell>\n<cell>\nsum_squares([0.6,\
    \ 2.2, 3.1])\n</cell>\n<cell>\nsum_squares([0.6, 2.2, 3.1])\n</cell>\n<cell>\n\
    sum_squares([0.6, 2.2, 3.1])\n</cell>\n<cell>\nsum_squares([0.6, 2.2, 3.1])\n\
    </cell>\n<cell>\nsum_squares([0.6, 2.2, 3.1])\n</cell>\n<", "  (0..(lst.size -\
    \ 1)).map { |i| lst[i]**2 }.sum\nend", "    sum_sqr = 0.0\n    lst = lst.round().sort\n\
    \    \n    lst.each do |item|\n        sum_sqr += (item**2.0).round()\n    end\n\
    \    sum_sqr\nend", "  sum = 0\n  for i in lst\n    sum += i*i\n  return sum\n\
    end\n  \n  ", "  lst.map{|x| Math.ceil(x)}.inject(:+) * Math.sqrt(lst.length)\n\
    end", "  sum = 0.0\n  i = 0\n  while i < lst.size do\n    sum += lst[i] ** 2\n\
    \    i += 1\n  end\n  return sum\nend", "  squares.reduce(lst.map {|x| x ** 2})\n\
    end", "  sum = 0\n  for i in lst\n    sum += i**2\n  sum *= Math.ceil sum\n  return\
    \ sum\nend", "    sum = 0\n    for i in lst\n        sum += i ** 2\n    end\n\
    \    return sum\nend\n</cell>\n<code language=julia-0.5>\nsum_squares([1.0, 4.0,\
    \ 9.0])\n</cell>\n<code language=julia-0.5>\nsum_squares([1.0, 6.0, 9.0])\n</cell>\n\
    <code language=julia-0.5>\nsum_squares([1.0, 7.0, 9.0])\n</cell>\n<code language=julia-0.5>\n\
    sum_squares([1.0, 2.0, 3.0])\n</cell>\n<text>\nExercise: Sum of a Squares\nThe\
    \ sum of squared numbers can be calculated by first calculating the sum of the\
    \ numbers and then applying the square operation.", "  # write your code in Ruby\n\
    \  sum=0\n  lst.each do |x|\n    sum+=x ** 2\n  end\n  sum=Math.ceil(sum)\n  return\
    \ sum\nend\n</code>\nNow you can write the solution in Ruby:\n<code>", "  sum\
    \ = 0\n  sum.upto(lst.size, proc) do |i|\n    sum += lst[i] * lst[i]\n  end\n\
    \  sum\nend\n</cell>\n<code language=conda-root-py>\nsum_squares([1.0, 4.0, 9.0])\n\
    </cell>\n<code language=conda-root-py>", "  sum = 0.0\n  sum_squares = 0.0\n \
    \ lst.each do |num|\n    sum = sum + num\n    sum_squares = sum_squares + num\
    \ * num\n  end\n  sum_squares.round(Ceil)\nend", "  lst.each do |x|\n    sum =\
    \ 0\n    x.to_i.each do |i|\n      sum += i.round\n    end\n    puts sum\n  end\n\
    end", "  # +++your code here+++\n  if lst.empty?\n    0.0\n  else\n    sq = lst.map(&:round)\n\
    \    sq.inject(0) {|sum, item| sum + item*item }\n  end\nend\n</cell>\n<cell>",
  "  lst.map{|num| num.to_i}.inject(:+) * num.to_i\nend", "  sum = 0\n  for i in lst\n\
    \    sum += i ** 2\n    i = i ** 0.5\n  end\n  return sum\nend", "  sum = 0\n\
    \  lst.map { |x| sum += x.to_f ** 2 }\n  sum\nend", "  sum = 0\n  lst.each do\
    \ |x|\n    sum += Math.ceil(x)*Math.ceil(x)\n  end\n  return sum\nend", "    sum\
    \ = 0\n    for i in lst\n        sum += i ** 2\n    return sum\nend\n</cell>\n\
    <code language=julia-1.6>\nsum_squares([1.0, 2.0, 3.0])\n</cell>\n<code language=julia-1.6>\n\
    sum_squares([1.0, 4.0, 9.0])\n</cell>\n<code language=julia-1.6>\nsum_squares([1.0,\
    \ 3.0, 5.0, 7.0])\n</cell>\n<code language=julia-1.6>\nsum_squares([1.4, 4.2,\
    \ 0.0])\n</cell>\n<code language=julia-1.6>\nsum_squares([-2.4, 1.0, 1.0])\n</cell>\n\
    <code language=julia-1.6>\nsum_squares([2.0, 2.0, 2.0])\n</cell>\n<code language=julia-1.6>\n\
    sum_squares([-2.0, 1.0, 1.0])\n</cell>\n<code language=julia-1.6>\nsum_squares([2.0,\
    \ 2.0, 2.1])\n</cell>\n<code language=julia-1.6>\nsum_squares([-2.0, 1.0, 1.1])\n\
    </cell>\n<code language=julia-1.6>\nsum_squares([3.0, 3.0, 3.0])\n</cell>\n<code\
    \ language=julia-1.6>\nsum_squares([-3.0, 3.0, 3.0])\n</cell>\n<code language=julia-1.6>\n\
    sum_squares([3.0, 3.0, 3.1])\n</cell>\n<code language=julia-1.6>\nsum_squares([-3.0,\
    \ 3.0, 3.1])\n</cell>\n<code language=julia-1.6>\nsum_squares([3.0, 3.0, 3.2])\n\
    </cell>\n<code language=julia-1.6>\nsum_squares([-3.0, 3.0, 3.2])\n</cell>\n<code\
    \ language=julia-1.6>\nsum_squares([3.0, 3.0, 3.2])\n</cell>\n<code language=julia-1.6>\n\
    sum_squares([-2.0, 3.0, 2.0])\n</cell>\n<code language=julia-1.6>\nsum_squares([3.0,\
    \ 3.0, 3.0])\n</cell>\n<code language=julia-1.6>\nsum_squares([-3.0, 3.0, 3.0])\n\
    </cell>\n<code language=julia-1.6>\nsum_squares([3.0, 3.0, 3.0])\n</cell>\n<code\
    \ language=julia-1.6>\nsum_squares([-3.0, 3.0, 3.0])\n</cell>\n<code language=julia-1.6>\n\
    sum_squares([-2.0, 3.0, 2.0])\n</cell>\n<code language=julia-1.6>\nsum_squares([3.0,\
    \ 3.0, 3.0])\n</cell>\n<code language=julia-1.6>\nsum_squares([-3.0, 3.0, 3.0])\n\
    </cell>\n<code language=juli", "  sum_squares = 0\n  array.each do |num|\n   \
    \ sum_squares += num ** 2\n  end\n  sum_squares\nend\n</code>\n<|/ a tags=ruby\
    \ dscore=1 |>\n<| c |>\nWhy would you use a `while` loop when a `map` will do\
    \ the same and perform better?\n<|/ c |>\n<| c |>\nIt's a matter of personal preference,\
    \ it's just that I'm not a huge fan of using a while loop because I consider it\
    \ less readable then a map, but I'll edit in why I prefer it that way\n<|/ c |>\n\
    <| c |>\nIt's not about being readable. `map` does exactly the same thing. It's\
    \ just that `while` is more confusing because it's not a loop, it's just an imperative\
    \ loop.\n<|/ c |>\n<| c |>\nThanks a lot for the explanation.\n<|/ c |>\n<| c\
    \ |>\nNo problem. Don't forget to accept an answer if it helped you :)\n<|/ c\
    \ |>\n<| a dscore=0 |>\nAnother way of doing this would be:\n<code>", "  sum =\
    \ 0\n  lst.each do |x|\n    sum = sum + Math.ceil(x) ** 2\n  end\n  sum\nend",
  "  sum = 0\n  sumsq = 0\n  for i in lst do\n    sumsq = sumsq + (i * i)\n    sum\
    \ = sum + i\n  end\n  return sumsq\nend", "  sum = 0\n  i = 0\n  while i < lst.size\n\
    \    sum += lst[i] * lst[i]\n    i += 1\n  return sum\nend", "  lst.collect{|x|\
    \ x.round}.inject(0) {|sum, num| sum + num ** 2}\nend", "  sum_square = 0\n  (0...(lst.length)).each\
    \ do |i|\n    sum_square += lst[i] ** 2\n  end\n  return sum_square\nend", " \
    \ sum = 0.0\n  for i in lst\n    sum += i ** 2\n  end\n  return sum\nend\n</cell>\n\
    <cell>\nsum_squares([1.0, 2.0, 3.0])\n</cell>\n<cell>\nsum_squares([1.0, 4.0,\
    \ 9.0])\n</cell>\n<cell>\nsum_squares([1.0, 3.0, 5.0, 7.0])\n</cell>\n<cell>\n\
    sum_squares([1.4, 4.2, 0.0])\n</cell>\n<cell>\nsum_squares([-2.4, 1.0, 1.0])\n\
    </cell>\n<cell>\nsum_squares([1.0, 2.0, 3.0])\n</cell>\n<cell>\nsum_squares([1.0,\
    \ 4.0, 9.0])\n</cell>\n<cell>\nsum_squares([1.0, 3.0, 5.0, 7.0])\n</cell>\n<cell>\n\
    sum_squares([1.4, 4.2, 0.0])\n</cell>\n<cell>\nsum_squares([-2.4, 1.0, 1.0])\n\
    </cell>\n<cell>\nsum_squares([1.0, 2.0, 3.0])\n</cell>\n<cell>\nsum_squares([1.0,\
    \ 4.0, 9.0])\n</cell>\n<cell>\nsum_squares([1.0, 3.0, 5.0, 7.0])\n</cell>\n<cell>\n\
    sum_squares([1.4, 4.2, 0.0])\n</cell>\n<cell>\nsum_squares([-2.4, 1.0, 1.0])\n\
    </cell>\n<cell>\nsum_squares([1.0, 2.0, 3.0])\n</cell>\n<cell>\nsum_squares([1.0,\
    \ 4.0, 9.0])\n</cell>\n<cell>\nsum_squares([1.0, 3.0, 5.0, 7.0])\n</cell>\n<cell>\n\
    sum_squares([1.4, 4.2, 0.0])\n</cell>\n<cell>\nsum_squares([-2.4, 1.0, 1.0])\n\
    </cell>\n<cell>\nsum_squares([1.0, 2.0, 3.0])\n</cell>\n<cell>\nsum_squares([1.0,\
    \ 4.0, 9.0])\n</cell>\n<cell>\nsum_squares([1.0, 3.0, 5.0, 7.0])\n</cell>\n<cell>\n\
    sum_squares([1.4, 4.2, 0.0])\n</cell>\n<cell>\nsum_squares([-2.4, 1.0, 1.0])\n\
    </cell>\n<cell>\nsum_squares([1.0, 2.0, 3.0])\n</cell>", "  sum = 0\n  lst.each\
    \ do |n|\n    sum += n * n\n  end\n  sum\nend", "    sum_lst = 0\n    square_lst\
    \ = []\n    lst.each do |x|\n        sum_lst += x ** 2\n        square_lst.push(x\
    \ ** 2)\n    end", "    # write your code here\n    sum = 0\n    for i in lst\n\
    \        sum += i * i\n    end\n    return sum\nend", "  return lst.inject(:+).map\
    \ { |x| Math.ceil(x * x) }.sum\nend", "    sum = 0\n    arr.each {|x| sum += (x\
    \ * x)}\n    return sum\nend", "  lst.each_with_index do |elem, i|\n    lst[i]\
    \ = elem.ceil\n    elem.square\n  end\n  lst.sum\nend\n</code>\nBut I think using\
    \ each_with_index is too complicated.\n<|/ a tags=ruby,arrays,rounding |>\n<|\
    \ a dscore=1 |>\nTry this one\n<code>\nrequire 'set'\nnumbers = [1,2.0,3.0,4,5.0,6.0,7,8,9]\n\
    squares = numbers.map { |number| Math.ceil(number*number) }\nsum = squares.inject\
    \ { |sum, number| sum + number }\n</code>\n<|/ a tags=ruby,arrays,rounding |>\n\
    <| a |>\n<code>", "    # Write your code here.\n    return sum( [ (x**2.0) for\
    \ x in lst ] )", '  lst.sort!', "  lst.map {|i| i.round}\n  lst.inject {|sum,n|\
    \ sum + n ** 2}\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\n`lst.inject(&:+).inject(&:**2)`\
    \ is one liner :) but +1 anyway for being an interesting one\n<|/ c |>\n<| c |>\n\
    You don't need to do `map` twice. You can do it in one: `lst.map(&:round).reduce(:+)`\n\
    <|/ c |>\n<| a dscore=4 |>\nI believe this solution is pretty concise:\n<code>",
  "  sum_ = 0\n  i = 0\n  while i < lst.size\n    x = lst[i]\n    if x.round( :ceil\
    \ ) != x\n      sum_ += x ** 2\n    end\n    i += 1\n  end\n  return sum_\nend",
  "  return lst.map {|x| Math.ceil(x * x).to_i}.inject {|sum, value| sum + value}\n\
    end\n</code>\n<|/ a dscore=0 tags=ruby,methods,arrays,methods |>\n<| c |>\nThis\
    \ question is already answered and accepted, so why post a new answer?\n<|/ c\
    \ |>\n<| c |>\n: Because this answer is more complete, concise, more elegant,\
    \ and more useful to future readers. Additionally, this answer is better than\
    \ the one I posted and should be accepted.\n<|/ c |>\n<| c |>\n: While I agree\
    \ that your answer provides more information than this one (thanks!), it also\
    \ doesn't give an explanation of why your code is different than the code in the\
    \ question. I think that makes it less useful, and hence unacceptable.\n<|/ c\
    \ |>\n<| c |>\n: I agree that yours has more explanation, but I fail to see how\
    \ mine is better. Which one is better, yours or mine or the accepted answer? If\
    \ your answer is better than mine then it would be a good idea to add an explanation\
    \ of why.\n<|/ c |>\n<| c |>\n: Mine uses `inject` which (at least in Ruby 1.8.7)\
    \ requires Ruby 1.8.7. I think yours is slightly more efficient as `inject` has\
    \ to go through an array multiple times, but I think it's less clear.\n<|/ c |>\n\
    <| a |>\n<code>", "  return sum( [Math.ceil(Math.pow(double(lst[i]),2)) for i\
    \ in lst])\nend", "  sum = 0\n  sumsq = 0\n  lst.each do |x|\n    sum += x\n \
    \   sumsq += x*x\n  end\n  return sumsq if sumsq\n  return sum if sum < 0\n  return\
    \ sum + sumsq / 2.0;\nend", "  sum = 0\n  for x in lst\n    sum += x**2\n  return\
    \ Math.ceil(sum)\nend", "  sum = 0\n  l.map {|n| sum += (Math.ceil(n).to_i * Math.ceil(n).to_i)\
    \ }\n  sum\nend", "  result = 0\n  lst.each do |x|\n    result += x * x\n  end\n\
    \  return round(result)\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby |>\n\
    It might be good to use reduce to calculate the sum of squared values.\nFor example:\n\
    <code>\narr = [2.0, 3.0, 4.0, 5.0]\nsum = arr.reduce(:*)\n</code>\n<|/ a dscore=4\
    \ |>\n<| a tags=ruby |>\nHere is one way using inject:\n<code>\na = [1,4,6,3,12]\n\
    b = a.inject(:+)\n=> 13\n</code>\n<|/ a dscore=3 |>\n<| a dscore=2 |>\n<code>\n\
    a = [1, 3, 4, 2]\na.sum.square", "  lst.map(&:to_i).reduce(&:+)\nend\n</cell>\n\
    <cell>", "  sum = lst.inject(:+).to_i\n  return sum if sum > 0 # avoid the nil\
    \ case\n  return 0 if sum < 0\n  return sum * sum\nend", "  return lst.map(&:round).inject(0)\
    \ {|total,x| total+x*x }\nend", "  sum = 0\n  sumsq = 0\n  for n in lst\n    sum\
    \ = sum + n\n    sumsq = sumsq + n * n\n  return sumsq", "  sum = 0\n  for i in\
    \ lst\n    sum += i * i\n  return Math.ceil sum\nend", "  sum = 0\n  lst.each\
    \ do |x|\n    sum += x**2\n  end\n  sum\nend\n</code>\nAnd here's one way to do\
    \ it using reduce (which may be more appropriate than each here):\n<code>", " \
    \ # BEGIN PROBLEM 1\n  lst.map! { |n| n * n }\n  # END PROBLEM 1\n  # BEGIN PROBLEM\
    \ 2\n  lst.map! { |n| n.ceil }\n  # END PROBLEM 2\n  lst.inject(:+)\nend", " \
    \ total = 0\n  for i in lst.map{|x| Math.ceil(x)}.map(&:to_i)\n    total += i**2\n\
    \  end\n  total\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n`map!` is often a\
    \ good choice as it will modify the array in place\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>", "  lst.each do |x|\n    x.ceil\n  end\n  lst.inject{|sum, x| sum + x\
    \ * x }\nend", "  sum = 0\n  lst.map!{|x| x = Math.round(x)}\n  lst.each do |x|\n\
    \    sum += x*x\n  end\n  return sum\nend\n</cell>\n<cell>\nsum_squares([-1.5,\
    \ -0.5, -0.1])\n</cell>\n<cell>", "  return lst.map { |x| x.ceil.to_i * x.floor\
    \ + x.ceil.to_i }.sum\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,arrays\
    \ |>\n<code>\narr.map{|i| i.to_s.split('.').map{|j| j.to_i}.inject(:+)}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nWhat is the reason for doing `i.to_s.split('.').map{|j|\
    \ j.to_i}`? I mean, why not just `i.to_s.split('.')`?\n<|/ c |>\n<| c |>\n`map`\
    \ returns an array, so we need to convert it to an `Array` before we can do `inject`\
    \ on it.\n<|/ c |>\n<| c |>\nThis is wrong. `arr` is an array of strings. Strings\
    \ don't have a `to_i` method.\n<|/ c |>\n<| c |>\n`map` returns an `Array` object\
    \ of strings.  Strings do have a `to_i` method\n<|/ c |>\n<| c |>\nYou're right,\
    \ sorry. `to_i` doesn't work. Try this: `'10.2'.to_i` It raises an `NoMethodError`.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>\n  def sum_of_squares_upto(number)\n    1.upto(number).map\
    \ do |n|\n      Math.sqrt(n).to_i\n    end.inject(:+) # or .inject(&:+) if you\
    \ want to use blocks\n  end\n</code>\n<|/ a tags=ruby,arrays |>\n<| a tags=ruby,arrays\
    \ |>\nThis problem is not difficult, and you didn't try hard enough.\nThe key\
    \ is to figure out how to find the integer square root of a number.\nOnce you\
    \ have that, it's easy:\n<code>", "  return lst.inject(0) do |sum, number|\n \
    \   sum += Math.sqrt(number)\n    sum\n  end\nend\n</code>\n<|/ a |>\n<| a dscore=0\
    \ tags=ruby |>\nHere's another way of doing it that might be easier to understand:\n\
    <code>", "  sum = 0.0;\n  for n in lst\n    sum += n * n\n  end\n  return sum\n\
    end", "    i = 0\n    sum = 0\n    while i < lst.count\n        sum = sum + lst[i]\
    \ ** 2\n        i = i + 1\n    return sum\nend\n</cell>\n<cell>", "  sum = 0\n\
    \  lst.each do |n|\n    sum += Math.sqrt(n)\n  end\n  return sum\nend", "  lst.map(&:round)\n\
    \  lst.inject(0) do |sum, number|\n    sum + number ** 2\n  end\nend\n</cell>\n\
    <cell>\nsum_squares([1.0, 2.0, 3.0])\n</cell>\n<text>\nThe map function applies\
    \ a given function to the elements of an array.\nThe &: operator indicates that\
    \ it is the operator map but for arrays.\nThe inject method computes the sum of\
    \ squares.\nThe first line of the function iterates over the elements in the list\
    \ lst and rounds them up.\nThe second line of the function adds the previous sum.\n\
    The third line of the function computes the sum.", "  sum = 0.0\n  for i in lst\n\
    \    sum += i*i\n    sum += i\n    sum += i\n    sum += i*i\n  return sum\nend",
  "    sum = lst.reduce(:+)\n    sum_squares = sum.*(sum.-sum)\n    return sum_squares\n\
    end", "  return reduce(lambda a, b: a + pow(b, 2), lst, 0)\nend", "  sum = 0.0\n\
    \  lst.each do |x|\n    sum += x*x\n  end\n  sum\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| a dscore=2 tags=ruby |>\n<code>", "  sum_total = 0\n  lst.each do |num|\n\
    \    sum_total += num ** 2\n  end\n  sum_total\nend\n</code>\n<|/ a |>\n<| c |>\n\
    This doesn't round the numbers to an upper integer, it just finds the sum of squares.\n\
    <|/ c |>\n<| a tags=arrays,ruby dscore=1 |>\n<code>", "  sum = 0\n  arr.each do\
    \ |x|\n    sum += x ** 2\n  end\n  sum\nend", "  sum = 0\n  for i in lst.to_a\n\
    \    sum += i.round\n  end\n  return sum\nend\n</code>\n<|/ a tags=ruby |>\n<|\
    \ c |>\nThis isn't the question asked (which doesn't involve a method). This is\
    \ just a one-liner which I didn't want to use. Surely there's a way to do it without\
    \ converting to an array?\n<|/ c |>\n<| c |>\nIf you look at the OP's question\
    \ closely you'll see that the OP has already done what you've suggested.\n<|/\
    \ c |>\n<| c |>\nI agree with you completely, but OP did not mention any method\
    \ in his question. Not everybody is aware of such methods as methods. Just a reminder.\n\
    <|/ c |>\n<| c |>\nWhat I read from the OP's question is that he was given an\
    \ array of numbers and he needed to return the sum of squared numbers in the given\
    \ array, rounding each element in the array to the upper int(Ceiling) first. Although\
    \ he mentioned the method in the question title, the OP didn't mention any method\
    \ in the question. I believe he was looking for another method. Don't get me wrong\
    \ though. I just think that everyone here should be aware of such methods as methods.\
    \ :)\n<|/ c |>\n<| c |>\nYes, that's what I meant. Thanks for the clarification.\n\
    <|/ c |>\n<| a dscore=0 |>\nIf you have an array of the same type as your input\
    \ array you can do this\n<code>", "  return lst.map { |x| x * x }.sum\nend\n</cell>\n\
    <cell>\n@test sum_squares([3.0, 5.0, 1.4, 4.0, -9.6]) == 14\n</cell>\n<cell>\n\
    @test sum_squares([3.0, 5.0, 4.4, 0.0, -1.0]) == 28\n</cell>\n<cell>\n@test sum_squares([6.1,\
    \ 3.6, 8.3, 0.0, 0.0]) == 24\n</cell>\n<text>\nThis concludes our introduction\
    \ to Ruby arrays.", "  sum_sq = 0.0\n  lst.each do |x|\n    sum_sq += x * x\n\
    \  end\n  sum_sq = sum_sq.to_i\n  return sum_sq\nend", "  sum = 0.0\n  arr.each\
    \ do |x|\n    sum = sum + Math.pow(x.ceil, 2)\n  end\n  sum\nend", "  lst.map\
    \ { |x| x.round }.inject { |sum, x| sum + x.abs }\nend", "    sum = 0\n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n", "  sum = 0\n  for i in lst\n    sum +=\
    \ i.to_f\n    sum *= i\n  end\n  return sum\nend", "    sum = 0\n    for n in\
    \ lst\n        sum += n.to_i**2\n        sum = ceil(sum)\n        sum\n    end\n\
    end", "    # write your code here\n    sum = 0\n    count = 0\n    for i in lst:\n\
    \        sum += int(round(i))**2\n        count += 1\n    return sum\n    ", " \
    \ (0...lst.length).inject(0, &:+)\nend", "  lst.each do |num|\n    num.round(10).to_i\
    \ * num.round(10).to_i\n  end\nend", "  sum = 0.0\n  for num in lst\n    sum +=\
    \ num ** 2\n    sum = Math.ceil(sum).to_s\n  sum.to_i\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| a |>\nI prefer the following solution:\n<code>", "  sum = 0\n  for i\
    \ in lst\n    sum += Math.ceil(Math.square(i))\n  return sum\nend", "  return\
    \ sum(map(Math::round_up, lst)).call\nend", "  # Write your code here.\n  new_lst\
    \ = lst.map{ |x| x.round}\n  new_lst.inject(0, :+)\nend\n</code>\n<|/ a dscore=2\
    \ tags=ruby,arrays |>\n<| c |>\n`inject` should be `inject`.\n<|/ c |>\n<| c |>\n\
    It would be great if you could add some explanation to your code. This will help\
    \ others who are new to Ruby.\n<|/ c |>\n<| c |>\n`inject` uses two parameters\
    \ - `memo` and the block that goes with it. I think you can read about it [here](http://www.ruby-doc.org/core-2.1.4/Enumerable.html#method-i-inject).\n\
    <|/ c |>\n<| a dscore=2 tags=ruby,arrays |>\nRuby has a bunch of very powerful\
    \ built in methods for performing operations that usually require iterating over\
    \ collections. One of these is Array#sum, which returns the sum of all of the\
    \ numbers in a given Array:\n<code>\na = [1,2,3,4,5]\na.sum # => 15\n</code>\n\
    You can also pass it a block:\n<code>\na.sum { |item| item ** 2 } # => 25\n</code>\n\
    Another method that you may find useful is Array#count, which, by default, returns\
    \ the number of items in the array:\n<code>\na.count # => 5\n</code>\nYou can\
    \ also pass a block:\n<code>\na.count { |item| item > 2 } # => 3\n</code>\nLastly,\
    \ you can use the Enumerable#sum method on any Enumerable, including the Array\
    \ class:\n<code>\n[1,2,3,4,5].sum # => 15\n[1,2,3,4,5].count { |item| item > 3\
    \ } # => 3\n[1,2,3,4,5].sum {|item| item ** 2 } # => 25\n</code>\nThere are many\
    \ more Array methods that you may find useful, such as Array#map, Array#sample,\
    \ Array#reject, Array#grep, Array#sort_by, Array#chunk, and Array#chunk (which\
    \ can help you split up an array into smaller arrays).\n<|/ a |>\n<| a dscore=1\
    \ |>\nI like the solution by and\n<code>", "  sum_of_squares = 0\n  lst.each do\
    \ |item|\n    sum_of_squares += item**2 if item.is_a? Numeric\n    sum_of_squares\
    \ += item**0.5 if item.is_a? Float\n  end\n  sum_of_squares.round\nend", "  return\
    \ lst.map { |x| x**2 }.inject(:+)\nend\n</cell>\n<cell>", "  # Your code here\n\
    \  return sum( [round(math.sqrt(number)) for number in lst] )", "  lst.map{|e|\
    \ e.round}\n  lst.map{|e| Math.ceil(e).to_i ** 2}.inject(:+)\nend\n</code>\n<|/\
    \ a tags=ruby |>\n<| a tags=ruby |>\nThis is another way you can do it using inject:\n\
    <code>", "  sum = 0\n  lst.map!{|x| sum+=x*x}\n  return sum\nend", "  sum = 0\n\
    \  arr.each {|x| sum += x ** 2}\n  return sum\nend", "  total = 0\n  for i in\
    \ lst.each {|e| total += Math.round(e*e) }\n  total\nend", "    sum = 0\n    squares\
    \ = 0\n    for i in lst\n        sum += i ** 2\n        squares += i ** 2\n  \
    \  return round(sum, int(math.ceil(math.sqrt(squares))))\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nHi Ahmad, could you please explain the second code line to me?\
    \ I know what `for x in lst` does, but why would we use `range` with it? And why\
    \ does `int(math.ceil(math.sqrt(squares)))` work?\n<|/ c |>\n<| c |>\n: I added\
    \ some explanation. Hopefully that's what you were after.\n<|/ c |>\n<| a dscore=1\
    \ |>\nA variation on's answer:\n<code>", "  arr.map { |x| x.round }\n  arr.reduce(:+)\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 tags=ruby,arrays |>\n<code>\narr\
    \ = [-10.0, 0.0, 10.0, 12.0, 13.0, 14.0, 16.0, 17.0, 18.0, 19.0, 20.0, 21.0, 22.0,\
    \ 23.0, 24.0, 25.0, 26.0, 27.0, 28.0, 29.0, 30.0, 31.0, 32.0, 33.0, 34.0, 35.0,\
    \ 36.0, 37.0, 38.0, 39.0, 40.0, 41.0, 42.0, 43.0, 44.0, 45.0, 46.0, 47.0, 48.0,\
    \ 49.0, 50.0, 51.0, 52.0, 53.0, 54.0, 55.0, 56.0, 57.0, 58.0, 59.0, 60.0, 61.0,\
    \ 62.0, 63.0, 64.0, 65.0, 66.0, 67.0, 68.0, 69.0, 70.0, 71.0, 72.0, 73.0, 74.0,\
    \ 75.0, 76.0, 77.0, 78.0, 79.0, 80.0, 81.0, 82.0, 83.0, 84.0, 85.0, 86.0, 87.0,\
    \ 88.0, 89.0, 90.0, 91.0, 92.0, 93.0, 94.0, 95.0, 96.0, 97.0, 98.0, 99.0]", " \
    \   return lst.inject{|sum, element| sum + element ** 2}\nend", "  lst.map { |x|\
    \ Math.ceil(Math.sqrt(x))}.inject { |sum, item| sum + item }\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nThis is not ruby, this is ruby with a single statement\
    \ in it.\n<|/ c |>\n<| c |>\nI thought it was a question. Thanks for the correction.\n\
    <|/ c |>\n<| c |>\nYes, I saw that and edited my comment, but your answer is still\
    \ wrong.\n<|/ c |>\n<| c |>\nWhat do you mean by \"wrong\"?\n<|/ c |>\n<| c |>\n\
    Your code is ruby with a single statement. Just a small nitpick.\n<|/ c |>\n<|\
    \ a dscore=0 |>\n<code>\nlst.map{|x| x.ceil}.inject(&:+).sqrt\n</code>\n<|/ a\
    \ tags=ruby,rounding |>\n<| a dscore=0 tags=ruby,rounding |>\n<code>\nsum=0\n\
    arr.map{|x| sum+=(x+1).ceil}.sqrt\n</code>\n<|/ a |>\n<| c |>\nWhy `(x+1)`? Doesn't\
    \ that add 1 to each element of the array? Shouldn't you just be adding `x`?\n\
    <|/ c |>\n<| c |>\nYou are right, I just fixed it.\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>\nlst.map{|x| x.ceil}.inject(:+).sqrt\n</code>\n<|/ a tags=ruby,rounding\
    \ |>\n<| a dscore=0 |>\n<code>", "    # Write your code here\n    ans = []\n \
    \   for elem in lst:\n        elem = elem.ceil\n        ans.append(elem**2)\n\
    \    return sum(ans)", "  sum = 0\n  for i in lst\n    sum=sum+Math.round(i*i)\n\
    \  return sum\nend\n</cell>\n<code language=julia-1.3>\nsum_squares([0.0, 3.5,\
    \ 1.5, -4.3, 3.2, -7.1])\n</cell>\n<text>\nTask\nGiven two arrays of the same\
    \ length, find the index of the maximum value from each of the arrays in O(N)\
    \ time.\nThe index of the maximum value from each array is given in an array.\
    \ \nThe input data will be arrays of integers (integers greater than 0).", " \
    \   sum = nil\n    for i in lst\n        sum += i.round\n    end\n    sum\nend\n\
    </cell>\n<code language=julia-0.6>\nsum_squares([1.0, 2.0, 3.0])\n</cell>\n<code\
    \ language=julia-0.6>\nsum_squares([1.0, 4.0, 9.0])\n</cell>\n<code language=julia-0.6>\n\
    sum_squares([1.0, 3.0, 5.0, 7.0])\n</cell>\n<code language=julia-0.6>\nsum_squares([1.4,\
    \ 4.2, 0.0])\n</cell>\n<code language=julia-0.6>\nsum_squares([-2.4, 1.0, 1.0])\n\
    </cell>\n<text>\n1.7 The maximum of the array\nThe maximum of the array is the\
    \ element that has the highest absolute value.", "    return lst.inject{|sum,x|\
    \ sum+x**2}\nend", "    count = 0\n    i = 0\n    while i < lst.size\n       \
    \ count += lst[i].round(Ceiling) * lst[i].round(Ceiling)\n        i += 1\n   \
    \ return count\nend", "  i = 0\n  total = lst[0]\n  while i < lst.size\n    total\
    \ += lst[i] ** 2\n    i += 1\n    lst[i] = round(total)\n    total = lst[0]\n\
    \  end\n  return total\nend", "    sum = 0\n    i = 0\n    while i < lst.length\n\
    \        sum += lst[i] ** 2\n        i = i + 1\n    return sum\nend", "  sum =\
    \ 0\n  for i in lst\n    sum += i ** 2\n  end\n  return sum\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
