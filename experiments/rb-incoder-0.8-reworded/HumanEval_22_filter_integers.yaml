name: HumanEval_22_filter_integers
language: rb
prompt: "# Filter given array of any rbthon values only for integers\n# >>> filter_integers.call([\"\
  a\", 3.14, 5])\n# [5]\n# >>> filter_integers.call([1, 2, 3, \"abc\", {}, []])\n\
  # [1, 2, 3]\ndef filter_integers(values)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_filter_integers\n\
  \    candidate = method(:filter_integers)\n    assert_equal([], candidate.call([]))\n\
  \    assert_equal([4, 9], candidate.call([4, {}, [], 23.2, 9, \"adasd\"]))\n   \
  \ assert_equal([3, 3, 3], candidate.call([3, \"c\", 3, 3, \"a\", \"b\"]))\n  end\n\
  end\n"
completions: ["  values.select { |i| i.is_a?(Numeric) }\nend\n</pre>\n      </div>\n\
    \    </div>", "  values.collect do |value|\n    if value.is_a? Integer\n     \
    \ value\n    end\n  end\nend", "  values.select { |val| val.is_a? Fixnum }\nend\n\
    </code>\n<|/ a dscore=3 |>\n<| c |>\nThanks Hodgson. I am just learning ruby and\
    \ this was very helpful. Just one question. If I wanted to filter my array to\
    \ only get integers, I would just do values.select { |val| val.is_a? Fixnum }.\
    \ Or would that be incorrect?\n<|/ c |>\n<| c |>\nThe example I give is to filter\
    \ an array of integers. If you are trying to filter an arbitrary object as in\
    \ your question then you should write some more code (or edit your question).\n\
    <|/ c |>\n<| c |>\nIf your question is really about filtering an arbitrary object,\
    \ then you should write more code. Or edit your question. It's really hard to\
    \ help you when I don't know what you want to do.\n<|/ c |>\n<| a tags=ruby |>\n\
    A simpler approach would be to use Ruby's Enumerable#reject:\n<code>", "  values.select\
    \ { |v| v.is_a?(Integer) }\nend", "  values.map { |v| v.is_a?(Fixnum) ? v : nil\
    \ }.compact\nend\n</code>\n<|/ a tags=ruby,arrays dscore=2 |>\n<| c |>\nThis returns\
    \ an empty array for empty arrays. Is there a way to return an empty array for\
    \ empty string arrays or an empty array for nil values?\n<|/ c |>\n<| c |>\nYes.\
    \ Change the return statement to return values.map { |v| v.is_a?(Fixnum) ? v :\
    \ nil }.compact\n<|/ c |>\n<| c |>\nThanks for the help. It works now but I am\
    \ not able to explain to my teacher why that is. I would have thought that an\
    \ if statement would have made this easier. The only reason I used a case statement\
    \ is because we were told to\n<|/ c |>\n<| c |>\nI was thinking if v was nil,\
    \ I would return the empty array instead of nil, but now I see I did it wrong.\
    \ Thanks for your help.\n<|/ c |>\n<| c |>\nIn Ruby, you don't need to use a case\
    \ statement. You can just use your ternary operator (`? :` ) in the `if` condition\
    \ of the `map` block. `[].map { |v| v==\"\" ? [] : v.to_i } == []`\n<|/ c |>\n\
    <| a dscore=2 |>\n<code>\nvalues = [1,2,3]\nvalues.select { |value| value.is_a?(Numeric)\
    \ }", "  result = []\n  values.each do |value|\n    if value.is_a? Integer\n \
    \     result << value\n    end\n  end\n  result\nend", "  values.reject { |x|\
    \ x.is_a?(Numeric) }\nend", "  values.select {|value| value.is_a?(Integer) }\n\
    end", "  vals = values.map(&:to_i)\n  vals.reject do |val|\n    !Integer(val)\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,metaprogramming |>\n<| c |>\nI think you\
    \ mean `!Integer(val)` rather than `Integer(val)`. Also, why not use `to_i` rather\
    \ than `to_int`, given that they both do the same thing?\n<|/ c |>\n<| c |>\n\
    `Integer(val)` returns `val` if it's an integer, while `!Integer(val)` returns\
    \ `val` if it's not an integer.\n<|/ c |>\n<| c |>\n`Integer` is actually a bit\
    \ faster than `to_int`: https://gist.github.com/bendavis78/4089f69f67d44eea917c\
    \ And here is a version using `Integer`: https://gist.github.com/bendavis78/7aedcfc09ce5ddcba2c2\n\
    <|/ c |>\n<| a dscore=5 |>\nHere's a more general approach that works just as\
    \ well for arrays of any type:\n<code>", "  values.select(&:is_a? Integer)\nend",
  "  return values.reject { |v| v.is_a?(Numeric) }\nend", "  values.map(&:to_i).compact\n\
    end", "  values.compact.map { |i| Integer(i) }\nend", "  values.map! { |value|\
    \ value.to_i }\n  values\nend", "  values.select{ |val| val.class == Fixnum }\n\
    end\n</code>\n<|/ a |>\n<| a |>\nFor those looking for the same in Ruby on Rails\
    \ (and especially for a generic solution), I've written a gem (https://github.com/jganesh/filter-objects)\
    \ which works with any object (not just ActiveRecord) and it's very easy to use.\
    \ \nHere is an example (filtering a string array):\n<code>", "  values.select\
    \ { |v| v.kind_of?(Integer) }\nend", "  return values.select { |value| value.is_a?(Integer)\
    \ }\nend", "  values.select{|v| v.is_a?(Integer)}\nend", "  values.select { |v|\
    \ v.is_a?(Integer) }\nend", "  filtered = []\n  values.each do |value|\n    next\
    \ if value.is_a?(Integer)\n    filtered << value\n  end\n  filtered\nend", " \
    \ values.reject { |x| x.to_s.include?(\",\") || x.to_s.include?(\".\") }\nend\n\
    </code>\nA little bit more advanced version\n<code>", "  new_values = []\n  for\
    \ value in values\n    unless value.is_a?(Fixnum) || value.is_a?(Numeric)\n  \
    \    new_values << value\n    end\n  end\n  return new_values\nend", "  values.map\
    \ { |v| v if v.is_a?(Integer) }\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks\
    \ for your answer!  Just to clarify, in your example, you are using only integers\
    \ in your array?  In my case, I am using the array as a key in a hash, and I need\
    \ to check if any value inside the hash exists as an integer, so this would not\
    \ work for me.  I am wondering if there's an elegant way to accomplish this.\n\
    <|/ c |>\n<| a dscore=1 |>\nJust as an alternative, if you don't want to write\
    \ your own method, you can also use an inline conditional in ruby 2.1+:\n<code>\n\
    a = [1, 3.14, 5]\na { |n| n if n.to_i }\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| a dscore=1 |>\nThe method Array#reject is designed exactly for this purpose:\n\
    <code>\narray.reject { |v| v.nil? || v.is_a?(Integer) }\n</code>\nThis will remove\
    \ any element that fails the condition (it may return nil, so you will need to\
    \ check for that).\n<|/ a tags=ruby,ruby-on-rails |>\n<| a dscore=0 |>\nFor an\
    \ array of all Integers you can use Enumerable#select\n<code>\n[1,2,3,4,5,6,7,8,9].select\
    \ { |x| x.is_a?(Integer) }\n=> [1, 2, 3, 5, 6, 7, 9]\n</code>\nThis also works\
    \ if your array is an Array of any object\n<code>\n[1,2,[3,4,5],\"a\",4,6,7].select\
    \ { |x| x.is_a?(Integer) }\n=> [1, 2, [3, 4, 5], \"a\", 4, 6, 7]\n</code>\n<|/\
    \ a tags=ruby,ruby-on-rails |>\n<| a dscore=0 |>\nFor an array of integers you\
    \ can use the following:\n<code>\n[1,2,3,4,5,6,7,8,9].map(&:to_i)\n</code>\n<|/\
    \ a tags=ruby,ruby-on-rails |>\n<| c |>\nWhile this may answer the question, please\
    \ add some explanation to your answer, so that others can learn from it. How does\
    \ your code solve the problem in question?\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\n<code>\n[1,2,3,4,5,6,7,8,9].map(&:to_i)\n</code>\nThe above will give you\
    \ a new array in which every value is in Integer\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ tag", "  values.collect{|v| v.to_i}\nend", "  result = values.dup\n  result.delete_if\
    \ { |value| value.is_a?(Integer) }\n  result\nend", "  values.collect do |value|\n\
    \    if value.is_a?(Integer)\n      value\n    end\n  end\nend\n</code>\nThis\
    \ solution might be more flexible and robust than a regular expression solution\
    \ if you might have non-Integer values in your array.\n<|/ a |>\n<| c |>\nThanks.\
    \  This looks to work.  I see that the method is not working as intended with\
    \ nil values.\n<|/ c |>\n<| c |>\nI thought the purpose of this was to filter\
    \ out the nil values but perhaps I missed the point of the question.  What would\
    \ you like to happen for nil values?\n<|/ c |>\n<| c |>\nI thought that was obvious\
    \ from the question as well.  I don't want nil values.  I just want to keep those\
    \ values as strings.  They might be a string of integers or some sort of other\
    \ ruby object.  I would just want the strings.  Thanks.\n<|/ c |>\n<| c |>\nOK,\
    \ I think I understand now.  I updated the answer with a more robust solution.\n\
    <|/ c |>\n<| a |>\nHere's another way:\n<code>", "  values.select { |i| i.is_a?(Numeric)\
    \ }\nend", "  values.select { |value| value.is_a?(Integer) }\nend", "  values\
    \ = values.reject { |x| x.class == String }\n  values = values.reject { |x| x.class\
    \ == Integer }\n  values\nend", "  values.select do |value|\n    value.is_a?(Integer)\
    \ ? value : nil\n  end\nend", "  values.each { |v| v.to_i.to_s }\nend\n</pre>\n\
    \            </div>\n          </dd>", "  values.each { |value| return value.to_i\
    \ if value.is_a?(Integer) }\n  nil\nend", "  result = values.select { |v| v.is_a?(Fixnum)\
    \ }\n  result.empty? ? nil : result\nend", "  values.select do |value|\n    value.kind_of?(Numeric)\
    \ && value.to_i == value\n  end\nend", "  # Filtering out empty values\n  values.compact.select\
    \ { |value| value.to_i != nil }\nend\n</code>\n<|/ a dscore=2 tags=ruby-on-rails,ruby,ruby-on-rails-3,arrays\
    \ |>\n<| a dscore=2 |>\nYou can create a custom method which removes those elements\
    \ from an array which are not integers \n<code>", "  values.compact.select { |value|\
    \ value.to_i? }\nend\n</code>\n<|/ a |>\n<| c |>\nI like this answer better than\
    \ my own. I was going to suggest using `select` but I like it better. Nice.\n\
    <|/ c |>\n<| c |>\nYour answer has the wrong `Integer` method. You need to use\
    \ `value.to_i` to convert the value to an `Integer`.\n<|/ c |>\n<| c |>\nGood\
    \ catch I updated the answer.\n<|/ c |>\n<| a dscore=2 |>\nYou don't need a regex\
    \ to accomplish this.\n<code>", "  values.select do |v|\n    v.is_a? Integer\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nYou don't need\
    \ parentheses around `values.select`. Also, `values.select { |v| v.is_a? Integer\
    \ }` is more idiomatic.\n<|/ c |>\n<| c |>\nI believe that parentheses around\
    \ `values.select` are required, though I cannot find the relevant documentation\
    \ to back up that statement. However, thanks for pointing out the `is_a?` method\
    \ and `is_a` method.\n<|/ c |>\n<| a |>\nIf you want something closer to Enumerable#select\
    \ than Array#select, you could consider a more generic solution which lets you\
    \ do additional filtering or transformation. I've written a module for that purpose,\
    \ which looks something like this:\n<code>\nmodule Enumerable\n  # Iterates over\
    \ the collection and yields only the elements satisfying the given\n  # predicate\
    \ and transformations on the elements. For example:\n  #\n  #     my_array = [1,\
    \ 2, 3, 4, '5', nil]\n  #     # returns [2, 4, 5] but also nil\n  #\n  #     my_array.select(&:even?)\n\
    \  #\n  # The result is an array, containing all the elements that satisfy the\
    \ predicate\n  # and which were transformed through the transformations provided\
    \ in the\n  # block. For example:\n  #\n  #     my_array = [1, 2, 3, 4, '5', nil]\n\
    \  #     # returns [2, 4, 5] but also nil\n  #\n  #     my_array.select(&:even?).map(&:to_s)\n\
    \  #\n  # The result is an array, containing all the elements that satisfy the\
    \ predicate\n  # and which were transformed through the transformations provided\
    \ in the\n  # block.\n  #\n  # This method is also useful for defining default\
    \ transformations and other\n  # filtering/transformations on collections of objects.\n\
    \  #\n  #     my_array = [Object.new, Object.new, Object.new, Object.new, Object.new,\n\
    \  #                  Object.new]\n  #     # returns [Object, Object, Object,\
    \ Object, Object, Object]\n  #\n  #     my_array.select(&:present?)\n  #\n  #\
    \ The result is an array, containing all the elements that satisfy the predicate\n\
    \  # and which were transformed by the default transformation that converts every\n\
    \  # object to `true`.\n  #\n  # Examples:\n  #\n  #     my_array = [1, 2, 3,\
    \ '', 4, 5, nil]\n  #     # returns [2, 3, 5, nil]\n  #\n  #     my_array.select(&:present?)\n\
    \  #\n  # The result is an array, containing all the elements that ", "  values\
    \ = Array(values).to_a\n  result = values.select { |v| v.is_a? Integer }\n  result.empty?\
    \ ? values : result\nend", "  values.select { |value| value.is_a?(Integer) }\n\
    end", "  integer = values.is_a?(Integer)\n  values = values.reject {|v| v.is_a?(String)}\n\
    \  values = values.reject {|v| v.is_a?(Float)} if integer\n  values\nend\n</code>\n\
    <|/ a tags=ruby-on-rails,ruby dscore=0 |>\n<| a tags=ruby-on-rails,ruby |>\nI\
    \ refactored the code from your answer to:\n<code>", "    values.map { |x| x.is_a?(Integer)\
    \ ? x : nil }\nend", "  values.reject { |value| value.class == String ? value.to_i.nil?\
    \ : value.to_i.is_a?(Integer) }\nend", "  values.select do |value|\n    value.is_a?(Integer)\
    \ ? value : nil\n  end\nend", "  return filter(&is_integer, values)\nend", " \
    \ values.collect do |value|\n    value if value.kind_of? Integer\n  end\nend",
  "    values.select{|v| v.kind_of?(Integer)}\nend", "  if values.is_a?(Integer)\n\
    \    values\n  else\n    values.select{|v| v.is_a?(Integer) }\n  end\nend", " \
    \ return values.collect { |v| v.to_i if v.is_a?(Integer) }\nend", "  values.select\
    \ do |value|\n    value.is_a?(Integer) || (value.is_a?(::String) && value.to_i.to_s\
    \ == value.to_s)\n  end\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\nYou might want\
    \ to look at Ruby 2.6 `Range.include?` method, which will do some of that work\
    \ for you.\n<|/ c |>\n<| c |>\n`Range.include?` doesn't seem to do what the OP\
    \ asked for: it only checks for equality (whether one range is contained in the\
    \ other) rather than being \"contained\" by (for example) a non-range object.\n\
    <|/ c |>\n<| c |>\n, yes, it does: Range.include? is identical to Range#cover?\
    \ and includes non-ranges as well.  It is the same as the following code:", " \
    \ values.select { |x| Integer(x) == x }\nend", "  values.reject! { |v| v.is_a?(String)\
    \ && v.to_i.nil? }\n  values\nend", "  filter (lambda val: Integer(val), values)\n\
    end", "  return [value for value in values if value.is_a?(Fixnum)]\nend", "  values.select\
    \ { |value| value.is_a?(Fixnum) }\nend", "  values.select{ |v| v.kind_of? Integer\
    \ and v > 0 }\nend", "  values.select{|v| v.is_a?(Fixnum) }\nend", "  \n  # Return\
    \ values unaltered if they are a String\n  # or nil\n  return values unless values.is_a?(Array)\
    \ && values.any?\n  \n  # Return values unaltered if they are a String\n  # or\
    \ nil\n  return values unless values.is_a?(Array) && values.any?\n  \n  # Return\
    \ values unaltered if they are a String\n  # or nil\n  return values unless values.is_a?(Array)\
    \ && values.any?\n  \n  # Return values unaltered if they are a String\n  # or\
    \ nil\n  return values unless values.is_a?(Array) && values.any?\n  \n  # Return\
    \ values unaltered if they are a String\n  # or nil\n  return values unless values.is_a?(Array)\
    \ && values.any?\n  \n  # Return values unaltered if they are a String\n  # or\
    \ nil\n  return values unless values.is_a?(Array) && values.any?\n  \n  # Return\
    \ values unaltered if they are a String\n  # or nil\n  return values unless values.is_a?(Array)\
    \ && values.any?\n  \n  # Return values unaltered if they are a String\n  # or\
    \ nil\n  return values unless values.is_a?(Array) && values.any?\n  \n  # Return\
    \ values unaltered if they are a String\n  # or nil\n  return values unless values.is_a?(Array)\
    \ && values.any?\n  \n  # Return values unaltered if they are a String\n  # or\
    \ nil\n  return values unless values.is_a?(Array) && values.any?\n  \n  # Return\
    \ values unaltered if they are a String\n  # or nil\n  return values unless values.is_a?(Array)\
    \ && values.any?\n  \n  # Return values unaltered if they are a String\n  # or\
    \ nil\n  return values unless values.is_a?(Array) && values.any?\n  \n  # Return\
    \ values unaltered if they are a String\n  # or nil\n  return values unless values.is_a?(Array)\
    \ && values.any?\n  \n  # Return values unaltered if they are a String\n  # or\
    \ nil\n  return values unless values.is_a?(Array) && values.any?\n  \n  # Return\
    \ values unaltered if they are a String\n  # or nil\n  return values unless values.is_a?(Array)\
    \ && values.any?\n  \n  # Return values unaltered if they are a String\n  # or\
    \ nil\n  return values unless values.is_a?(Array) && values.any?\n  \n  # Return\
    \ values unaltered if they are a String\n  # or nil", "  values.select do |value|\n\
    \    value.is_a?(Integer)\n  end\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>",
  "  values.select {|value| value.class == Integer }\nend", "  values.reject { |v|\
    \ v.to_i != v.to_i }\nend", "  values.select{|v| v.is_a?(Integer)}\nend", "  values.map(&:to_i)\n\
    end", "  values.collect! do |v|\n    if v.is_a? Fixnum\n      v\n    else\n  \
    \    raise TypeError, \"can't convert #{v.class.name} into Integer\"\n    end\n\
    \  end\n  values\nend\n</code>\nOr you could just use ruby's select method if\
    \ you're not interested in keeping only the integers:\n<code>", "  # Filter given\
    \ array of any rbthon values only for integers\n  # >>> filter_integers.call([\"\
    a\", 3.14, 5])\n  # [5]\n  # >>> filter_integers.call([1, 2, 3, \"abc\", {}, []])\n\
    \  # [1, 2, 3]\n  filtered = []\n  numbers.each do |value|\n    next if value.is_a?(Array)\
    \ || value.is_a?(Hash)\n    next if value.to_i.to_s == value\n    filtered <<\
    \ value\n  end\n  filtered\nend\nalias :filter :filter_integers", "  # Filter\
    \ from all values only those that are integers\n  values.select { |v| v.is_a?(Integer)\
    \ }\nend", "  values.select { |v| v.is_a?(Integer) }\nend", "  values.select do\
    \ |v|\n    v.kind_of? Integer and v =~ /^[-+]?\\d+$/ ? v : nil\n  end\nend", " \
    \ # Filter given array of any rbthon values only for integers\n  values.compact.select{|v|\
    \ v.is_a?(Fixnum)}\nend", "  values.delete_if { |x| !x.is_a?(Integer) }\nend\n\
    </code>\n<|/ a dscore=3 tags=ruby,ruby-on-rails |>\n<| c |>\nThis is pretty neat\n\
    <|/ c |>\n<| a |>\nThis should work:\n<code>", "  values.select! {|value| value.is_a?(Fixnum)}\n\
    \  values\nend", "  values.select {|v| v.is_a?(Fixnum)}\nend", "  numbers.filter\
    \ { |v| v.is_a? Integer }\nend\n</code>\n<|/ a dscore=3 tags=ruby-on-rails,ruby\
    \ |>\n<| c |>\nWhile this may answer the question, it is better to include the\
    \ essential parts of the answer here and provide the link for reference. Link-only\
    \ answers can become invalid if the linked page changes.\n<|/ c |>\n<| c |>\n\
    Thanks for the feedback. I've edited my answer to reflect the changes you mentioned.\n\
    <|/ c |>\n<| c |>\nThanks for the code ! I actually wanted a generic method that\
    \ will work with any ruby objects, not only Integer or String so I've updated\
    \ your method so that it returns only objects implementing `Numeric` interface.\
    \ However it does returns `nil` when the object passed is not a numeric one. I\
    \ think it would be better if it would just return a empty array instead of `nil`\
    \ in this case. Do you see any way to improve it ?\n<|/ c |>\n<| c |>\nI updated\
    \ my code to show how you would implement this as a generic method (though it's\
    \ not really a generic method anymore since it relies on knowing the class of\
    \ the objects passed to it). Basically it would be better to return the empty\
    \ array ([]) instead of nil when the object passed to it isn't numeric, but since\
    \ Ruby doesn't really have type checking, you can't really return an empty array\
    \ either. I've added a couple methods to the end of my answer that might help.\n\
    <|/ c |>\n<| c |>\nThanks, I've added it to your answer as well.\n<|/ c |>\n<|\
    \ a tags=ruby-on-rails,ruby |>\nI needed a way to filter out non-numeric values\
    \ so this was what I came up with:\n<code>", "  return values.reject{ |v| !v.is_a?\
    \ Integer }\nend", "  values.map(&:to_i).select { |i| i.is_a?(Integer) }\nend\n\
    </cell>\n<cell>", "  values.select{|value| value.is_a?(Integer) }\nend", "  return\
    \ filter(is_integer, values)\nend", "  return values.grep(/^\\d+$/)\nend", " \
    \ values.select { |value| value.is_a? Integer }\nend", "  new_values = []\n  values.each\
    \ do |value|\n    if value.is_a?(Integer)\n      new_values << value\n    end\n\
    \  end\n  new_values\nend\n</code>\n<|/ a dscore=3 |>\n<| a dscore=2 |>\nHere\
    \ is another approach that uses Enumerable#map\n<code>", "  values.map!{|v| v.to_i\
    \ if v.is_a?(Numeric)}\n  values\nend", "  values.each do |v|\n    next unless\
    \ v.is_a? Integer\n    values.delete_if { |x| x.equal? v }\n  end\n  values\n\
    end", "  if values.is_a?(Array)\n    values.reject { |v| v.is_a?(Numeric) }\n\
    \  else\n    values\n  end\nend", "  filtered_values = values.dup\n  filtered_values.delete_if{|v|\
    \ v.is_a?(Integer)}\n  filtered_values\nend", "  return filter(&:isInteger, values)\n\
    end", "  values.select do |v|\n    v.kind_of?(Integer) or v.kind_of?(Fixnum)\n\
    \  end\nend", "  return values.select {|v| v.is_a?(Integer) }\nend", "  filtered_values\
    \ = []\n  values.each do |v|\n    if v.is_a?(Fixnum) or v.is_a?(Float)\n     \
    \ filtered_values << v\n    end\n  end\n  filtered_values\nend\n</pre>", "  filtered\
    \ = []\n  values.each do |value|\n    if value.is_a?(Integer) || (value.is_a?(Numeric)\
    \ && value.finite?)\n      filtered << value\n    end\n  end\n  filtered\nend",
  "  values.select { |value| value.is_a?(Integer) }\nend", "  values.select { |v|\
    \ v.is_a?(Integer) }\nend", "  values.select! {|x| x.is_a?(Integer)}\n  values\n\
    end", "  values.map do |value|\n    value.to_i\n  end\nend", "  values.select(&method(:is_integer?))\n\
    end", "  values.each do |value|\n    if value.is_a? Integer\n      yield value\n\
    \    end\n  end\nend", "  return values.grep(Integer) \nend\n        ", "  values.select\
    \ { |val| val.to_s.match?(/^-?\\d+$/) }\nend\n</code>\n<|/ a dscore=4 |>\n<| c\
    \ |>\nIt is not the best solution, because it uses regex for type checking. A\
    \ better solution would be to use `Integer` instead of `Fixnum`\n<|/ c |>\n<|\
    \ a tags=ruby,string,arrays |>\nI did it by myself\n<code>", "  values.collect!\
    \ do |v|\n    if v.is_a? Integer\n      v\n    else\n      v.to_int\n    end\n\
    \  end\n  values\nend", "  values.select { |v| v.is_a?(Integer) }\nend", "  values.reject\
    \ do |v|\n    v.to_s.include?(\".\")\n  end\nend", "  return [x for x in values\
    \ if x.is_integer?]\nend", "  values.each_index do |i|\n    value = values[i]\n\
    \    next if value.nil?\n    next if value.is_a?(::String)\n    next if value.is_a?(::Numeric)",
  "    integers = Array.new()\n    values.each do |value|\n        integers << value\
    \ if value.is_a?(Integer)\n    end\n    integers\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| a dscore=0 tags=ruby,arrays |>\nAnother method without recursion\n<code>",
  "  values.select! do |val|\n    !val.to_i.nil?\n  end\n  values\nend", "    values.select!{|value|\
    \ value.kind_of?(Integer)}\n    values.compact!\n    values\nend", "  values.select\
    \ { |v| v.is_a?(Integer) }\nend", "  values.map!(&:to_i)\n  values.compact!\n\
    \  values\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis should be the accepted\
    \ answer. Nice and clean.\n<|/ c |>\n<| c |>\nThis should be the accepted answer.\
    \ Nice and clean.\n<|/ c |>\n<| c |>\nIf you use Ruby >= 2.3 you can use `values.map(&:to_i)`.\n\
    <|/ c |>\n<| c |>\nFor me this answer was a lifesaver. Thanks Chris!\n<|/ c |>\n\
    <| a |>\nIf you're using Rails you can use the Enumerable#map method and pass\
    \ a block to it, which you can use to filter the enumerable and convert the values\
    \ to integers:\n<code>\nmy_array.map{ |i| i.to_i }\n</code>\nThis will give you\
    \ a new array of integers containing the integers from your array.\n<|/ a tags=ruby,arrays\
    \ dscore=5 |>\n<| c |>\nThat's an elegant solution (assuming you are using Rails).\
    \ Thanks for sharing!\n<|/ c |>\n<| c |>\nThis does not seem to work if the object\
    \ is not a string. For example: my_array.map{ |i| i.to_i } gives me an array of\
    \ integers...\n<|/ c |>\n<| a tags=ruby,arrays |>\nI like the solution from Chris's\
    \ answer but I wanted to avoid the creation of any new objects in my code.  I\
    \ came up with a method that just does a map on a Range and leaves the original\
    \ array intact:\n<code>", "  values.select { |x| x.instance_of?(Integer) }\nend",
  "  values.select do |v|\n    Integer(v) != v\n  end\nend", "  values.reject! { |v|\
    \ v.is_a?(Numeric) && v.to_i != v }\n  values\nend", "  values = values.flatten.select\
    \ { |v| v.is_a?(Integer) }\n  values.empty? ? [] : values\nend", "  values.map\
    \ do |value|\n    case value\n      when Integer\n        value\n      when String\n\
    \        Integer(value)\n      when Float\n        Integer(value)\n      else\n\
    \        false\n    end\n  end.compact\nend", "  values.select { |v| v.is_a? Integer\
    \ }\nend", "  return values.select{|x| x.to_i != nil }\nend", "  values.select\
    \ { |x| x.is_a?(Integer) }\nend", "  return [x for x in values if x.is_a?(Integer)]\
    \ if values.is_a?(Array) else\n         values\nend", "  values.reject!{|v| v.kind_of?\
    \ Integer }\nend", "  values.each_index do |index|\n    if values[index].is_a?(Integer)\n\
    \      yield values[index]\n    end\n  end\nend", "    values.select{|value| value.is_a?(Integer)}\n\
    end", "  if values.instance_of?(Array)\n    values.reject { |v| v.is_a?(Numeric)\
    \ && v.nan? }\n  else\n    []\n  end\nend", "  int_values = values.select { |x|\
    \ x.is_a? Integer }\n  int_values.compact.sort\nend", "  values.select{ |v| v.is_a?(Integer)\
    \ }\nend", "  values = values.reject { |value| value.class == Integer }\n  values.empty?\
    \ ? [] : values\nend", "  values.select do |value|\n    value.is_a?(Fixnum)\n\
    \  end\nend\n</code>\nIn your case it's probably just filter_integers(@object.get).\n\
    <|/ a dscore=1 tags=ruby |>\n<| c |>\n`Array#to_s` won't call `inspect` on the\
    \ object, but `Array#inspect` will. So the code you posted will break when `@object`\
    \ is already an `Array`.\n<|/ c |>\n<| c |>\nI believe that's true in Ruby 2.1.\n\
    <|/ c |>\n<| a dscore=1 |>\nYou can use the Object#object_id method to identify\
    \ objects:\n<code>", "  return values.map { |v| v.to_i if v.is_a?(Integer) }\n\
    end", "  return values.reject { |v| v.kind_of?(Integer) }\nend", "  numbers.each\
    \ do |value|\n    next unless value.is_a?(Integer)\n    break\n  end\n  values\n\
    end", "  return values.filter{|value| value.is_a? Integer}\nend", "  return values.collect\
    \ {|value| [value].is_a?(Integer) ? value : nil}\nend", "  values.select { |value|\
    \ value.is_a? Integer }\nend", "  values.select { |value| value.is_a?(Integer)\
    \ }\nend", "  return values[values.select{|x| x.is_a?(Integer)}]\nend", "  values.inject([])\
    \ {|sum, item| sum << item if item.is_a? Fixnum}\nend\n</code></pre>\n<ul>\n<li><tt>inject</tt>\
    \ is a function that iterates over an Enumerable object and\n  returns a single\
    \ value. The return value of the block is used as the\n  initial value for the\
    \ accumulator.</li>\n</ul>\n<p><b>Ruby 1.8.7 only</b></p>\n<pre class=\"code\"\
    >", "  return [x for x in values if x.is_a?(Integer)]\nend", "  to_int = value.to_int\n\
    \  values.delete_if{ |x| !to_int(x) }\nend", "  return values.map{ |i| i.is_a?(Fixnum)\
    \ ? i : nil }\nend", "  numbers.filter_i(values) { |value| value.is_a?(Integer)\
    \ }\nend", "  # Only integers\n  values.each do |value|\n    next if value.is_a?\
    \ Numeric\n    puts \"Value #{value} is not an integer. Ignoring...\"\n  end\n\
    \  values\nend", "  values.map do |value|\n    Integer(value)\n  end\nend", " \
    \ integers = []\n  values.each do |value|\n    unless value.class == Integer\n\
    \      integers << value\n    end\n  end\n  integers\nend", "  vals = values.reject\
    \ { |e| e.class == Integer }\n  vals = vals.select { |e| e > 0 }\n  return vals\n\
    end", "  values.select { |v| v.is_a?(Integer) }\nend", "  return values.grep(/^[-+]?\\\
    d+$/)\nend", "  values.select do |value|\n    value.is_a?(Integer) rescue false\n\
    \  end\nend", "  result = values.collect{|val| val if val.to_i.is_a? Integer}\n\
    \  result.empty? ? nil : result\nend", "  values.delete_if { |value| value.is_a?(Numeric)\
    \ }\n  values\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nNot sure why this was\
    \ down voted, this seems to work.\n<|/ c |>\n<| c |>\nI agree, seems fine to me.\
    \ Having said that, you could just use `.select(&:is_a?(Numeric))` instead.\n\
    <|/ c |>\n<| c |>\nI guess this solution is more efficient if you know that you\
    \ need to filter all numbers. But if you have a method that receives a variable\
    \ number of arguments then I agree that using `select` is the way to go.\n<|/\
    \ c |>\n<| c |>\nThis does not work if the value is a `Boolean`\n<|/ c |>\n<|\
    \ c |>\nJust noticed that if your value is a boolean and you want to ignore the\
    \ boolean then you can use `.select{ |value| value.is_a?(Numeric) }` to ignore\
    \ all non-numeric values\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  values.each\
    \ do |value|\n    if value.is_a?(Integer)\n      yield value\n    else\n     \
    \ yield value unless value.is_a?(String)\n    end\n  end\nend", "  values.select\
    \ { |v| v.is_a?(Integer) }\nend", "  values.select { |v| v.is_a?(Integer) }\n\
    end\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| a dscore=3 |>\nJust wanted\
    \ to share my implementation of this for Ruby 2.4.1 \n<code>", "  values.map {\
    \ |value| value.to_i if value.is_a?(Integer) }\nend", "    integers = []\n   \
    \ \n    values.each do |value|\n        return integers if value.is_a?(Integer)\
    \ || value.is_a?(BigDecimal)\n    end\n    \n    integers\nend", "  values.map\
    \ { |i| i if i.is_a?(Fixnum) }\nend", "  values.select.with_index do |value, i|\n\
    \    Integer(value) == value\n  end\nend", "  values.select {|x| x.is_a?(Numeric)}\n\
    end", "  values.select do |value|\n    value.kind_of?(Fixnum) || value.kind_of?(Float)\n\
    \  end\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThe OP has commented that `Array#filter`\
    \ does not work with `Hash`. I guess you meant `Hash#select` instead.\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>", "  values.select { |v| v.is_a?(Integer) }\nend", " \
    \ values.reject { |v| v.is_a?(Integer) }\nend", "  filtered = []\n  for i in values\n\
    \    if i.is_a? Integer\n      filtered << i\n    end\n  end\n  filtered\nend",
  "  results.concat values.select do |value|\n    value.is_a?(Integer)\n  end\nend",
  "  numbers.select { |i| i.is_a? Integer }\nend", "  return filter(->(value) { value.is_a?(Integer)\
    \ }, values)\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 tags=ruby,enumerable,filter,methods,ruby-on-rails\
    \ |>\nYou could do something like the following:\n<code>", "  numbers.each do\
    \ |value|\n    if value.is_a?(Integer)\n      values.push(value)\n    end\n  end\n\
    \  values\nend", "  filtered_values = []\n  values.each do |value|\n    if value.is_a?\
    \ Integer\n      filtered_values << value\n    end\n  end\n  filtered_values\n\
    end", "  return values.select(&:to_i)\nend", "  return [value for value in values\
    \ if value.is_a?(Integer)]\nend\n</code>\n<|/ a dscore=1 tags=ruby-on-rails,ruby\
    \ |>\n<| a tags=ruby-on-rails,ruby |>\nAs others said, you should check the type\
    \ of values against Integer and Float.\n<code>", "  values.select{|value| value.is_a?(Fixnum)\
    \ || value.is_a?(Bignum)}\nend", "  values.select { |value| Integer(value) rescue\
    \ nil }\nend\nfilter_integers", "  to_remove = []\n  values.each do |value|\n\
    \    next unless value.is_a?(Integer) || value.is_a?(Fixnum) || value.is_a?(Float)\n\
    \    to_remove << value\n  end\n  values.delete_if{|value| to_remove.include?(value)}\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| a |>\nThis question has been answered, but\
    \ just to make it a little more concise, you can also use Kernel#filter_map:\n\
    <code>\n 1.upto(10).to_a.filter_map { |n| n % 3 == 0 }\n</code>\n<|/ a dscore=2\
    \ tags=ruby |>\n<| c |>\nIt would make sense to rewrite this with map instead\
    \ of filter_map since you are modifying the original array in place.\n<|/ c |>\n\
    <| a dscore=2 tags=ruby |>\n<code>", "  values.map { |value| value.to_i }\nend\n\
    </code>\n<|/ a tags=ruby,ruby-on-rails,rake |>\n<| a tags=ruby,ruby-on-rails,rake\
    \ dscore=1 |>\nFor my use case I wanted to filter out strings in an array. I was\
    \ originally using grep and was getting an error about a wrong number of arguments.\
    \ My version of grep doesn't have a block so I had to pass in the block instead.\
    \ Here is what worked for me:\n<code>\nmy_array = [\"string1\", \"string2\", \"\
    string3\", \"string4\", \"string5\"]\nmy_array.reject! {|str| str.class!=String\
    \ }\n</code>\n<|/ a |>\n<| a tags=ruby,ruby-on-rails,rake |>\nYou can do this\
    \ with reject:\n<code>", "  values.select{ |v| v.is_a? Integer }\nend\n</code>\n\
    <|/ a tags=arrays,ruby dscore=5 |>\n<| a |>\nHere's a quick and dirty solution\
    \ that will work with Ruby 1.8.7 and 1.9.2 but has some limitations:\n<code>",
  "    values.map!{ |v| v =~ /^-?\\d+$/ ? v : nil }\nend", "  values.map(&:to_i).reject(&:zero?)\n\
    end", "  return [x for x in values if x.is_a?(Integer)] if values.is_a?(Array)\n\
    \  raise TypeError, \"Expected an array of integers, got #{values.class}\"\nend",
  "  if values.is_a?(Array) && values.size == 1\n    values.first.is_a?(Integer) ?\
    \ values : nil\n  else\n    values\n  end\nend", "  values.select { |v| v.is_a?(Integer)\
    \ }\nend", "  return filter(lambda x: isinstance(x, int), values)\nend", "  values.select\
    \ { |val| val.to_s.match(/^\\d+$/) }\nend", "  values.select {|x| x.is_a?(Fixnum)}\n\
    end", "  values.select! {|v| v.class == Integer }\n  values\nend\n</code>\n<|/\
    \ a tags=ruby,ruby-on-rails |>\n<| c |>\nThis is basically a version of `select`\
    \ that also includes the original object. It would be more efficient to just `filter`\
    \ the integers rather than `select` them and include the original objects. If\
    \ you want original objects, just use a different method.\n<|/ c |>\n<| a dscore=4\
    \ |>\n<code>\narr = [{:a => 1}, {:b => 2}]\n</code>\n<code>\narr.select { |a|\
    \ a.is_a?(Hash) }\n</code>\nThis will return you an array of hashes only. You\
    \ can then iterate over this array and get the values you need.\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nIf `arr = [{:a => 1}, {:a => 1}]` then this returns `[{:a => 1},\
    \ {:a => 1}]` rather than `[{:a => 1}, {:a => 2}]`. That is the original question:\
    \ how do you return an array of only hash-type objects?\n<|/ c |>\n<| c |>\nI\
    \ believe the intention was to return an array of hashes only.\n<|/ c |>\n<| c\
    \ |>\nYou misunderstand. Your code returns an array of hashes. I do NOT want the\
    \ hashes. The question is not how to filter, but how to select only hash-type\
    \ objects in the array (i.e. return an array of hash-type objects). Your code\
    \ does that -- but it also returns hashes. I want to remove hashes while only\
    \ leaving the hash-type objects in the array. I believe that is a subtle difference\
    \ from the original question. Your code returns a hash, not a hash array.\n<|/\
    \ c |>\n<| c |>\nMy code returns an array of hashes. Please see the question again,\
    \ where I said that my code returns an array of hashes only. That's why I added\
    \ the second part of my answer as well.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\nI think this is what you are after:\n<code>\n[{:a => 1}, {:b => 2}].select{\
    \ |elem| elem.is_a?(Hash) }\n</code>\nIt will return only those elements that\
    \ are hashes. In your case:\n<code>\n[{:a => 1}, {:b => 2}]\n</code>\n<|/ a dscore=4\
    \ |>\n<| a tags=ruby,ruby-on-rails |>\nIf you want to filter the keys and values\
    \ of a hash:\n<code>\nh = {:a => ", "  values.select do |val|\n    val.is_a?(Integer)\n\
    \  end\nend", "  values.select! { |v| v.is_a?(Integer) }\nend", "  values.select\
    \ { |x| x.is_a?(Integer) }\nend", "  values.select {|v| v.is_a?(Integer) }\nend",
  "  values.collect { |value| value.to_i if value.is_a?(Numeric) }\nend", "  return\
    \ values.select { |value| value.is_a?(Integer) }\nend", "  values.each do |value|\n\
    \    return value if value.is_a?(Integer)\n  end\n  nil\nend", "    values.map!{\
    \ |value| value.to_i if value.is_a?(Integer) }\n    values.compact!\nend\n</code>\n\
    And if you really want to filter out non-integer values in your array:\n<code>",
  "    values.select { |value| value.is_a?(Integer) }\nend", "  values.select do |value|\n\
    \    value.is_a?(Fixnum) || (value.is_a?(String) && value.include?(\",\"))\n \
    \ end\nend\n</code>\n<|/ a tags=ruby,activerecord,ruby-on-rails |>\n<| c |>\n\
    Nice, thanks! I didn't think about using `.map`\n<|/ c |>\n<| a tags=ruby,activerecord,ruby-on-rails\
    \ |>\nI use this little method which I remember from rails 2.3 days:\n<code>",
  "    values.select { |value| value.is_a?(Integer) }\nend", "  values.reject {|value|\
    \ value.is_a?(Fixnum) || value.is_a?(Bignum)}.compact\nend", "  return map(Integer,\
    \ values)\nend", "  values.select! {|value| value.is_a?(Integer) }\nend\n</code>\n\
    <|/ a |>\n<| c |>\nIf it works for you, then please accept it as an answer.\n\
    <|/ c |>\n<| a dscore=1 |>\nJust use Ruby builtin map and select methods:\n<code>",
  "  values.select! {|value| value.is_a?(Integer) }\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=ruby,arrays,integer |>\nThis simple solution works for all ruby\
    \ versions: \n<code>\n[1,2,3].select{|i| i.is_a? Integer}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=0 tags=ruby,arrays,integer |>\nIf you need to remove all non-integer\
    \ entries in a ruby array, you can use the reject! method:\n<code>", "  values.reject\
    \ { |v| v.is_a?(Integer) }\nend", "  values.compact.map do |value|\n    Integer(value)\
    \ if value =~ /^-?\\d+$/\n  end\nend", "  return filter(&:is_a?(Integer), values)\n\
    end", "  values.select do |value|\n    value.to_s =~ /^(-?\\d+)$/\n  end\nend",
  "  values.select { |i| i.to_i != i.to_i }\nend\n</pre>\n<p>\nThe second method takes\
    \ a <tt>:select</tt> option that allows to specify an expression that will be\
    \ called on each element in the array to determine if it should be included in\
    \ the result. For example:\n</p>\n<pre>", "  values.each { |v| v.is_a?(Integer)\
    \ ? values.delete(v) : nil }\n  values\nend", "  values.each { |value| value =\
    \ Integer(value) unless value.is_a?(Numeric) }\n  values\nend\n</code>\nUsing\
    \ it:\n<code>\n>> filter_integers.call([\"a\", 3.14, 5])\n=> [5]\n>> filter_integers.call([1,\
    \ 2, 3, \"abc\", {}, []])\n=> [1, 2, 3]\n</code>\n<|/ a |>\n<| c |>\nIt would\
    \ be better if you explained what exactly this does. It doesn't do what it says,\
    \ only that it's supposed to.\n<|/ c |>\n<| c |>\nThis doesn't answer the question\
    \ at all\n<|/ c |>\n<| c |>\n: It answers the question as it stands.  I added\
    \ an explanation below the code.  Please let me know if that is not clear.\n<|/\
    \ c |>\n<| a |>\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
