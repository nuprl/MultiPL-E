name: HumanEval_89_encrypt
language: rb
prompt: "# Create a function encrypt that takes a string as an argument and\n# returns\
  \ a string encrypted with the alphabet being rotated. \n# The alphabet should be\
  \ rotated in a manner such that the letters \n# shift down by two multiplied to\
  \ two places.\n# For example:\n# >>> encrypt.call(\"hi\")\n# \"lm\"\n# >>> encrypt.call(\"\
  asdfghjkl\")\n# \"ewhjklnop\"\n# >>> encrypt.call(\"gf\")\n# \"kj\"\n# >>> encrypt.call(\"\
  et\")\n# \"ix\"\ndef encrypt(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_encrypt\n\
  \    candidate = method(:encrypt)\n    assert_equal(\"lm\", candidate.call(\"hi\"\
  ))\n    assert_equal(\"ewhjklnop\", candidate.call(\"asdfghjkl\"))\n    assert_equal(\"\
  kj\", candidate.call(\"gf\"))\n    assert_equal(\"ix\", candidate.call(\"et\"))\n\
  \    assert_equal(\"jeiajeaijeiak\", candidate.call(\"faewfawefaewg\"))\n    assert_equal(\"\
  lippsqcjvmirh\", candidate.call(\"hellomyfriend\"))\n    assert_equal(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
  , candidate.call(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"))\n    assert_equal(\"\
  e\", candidate.call(\"a\"))\n  end\nend\n"
completions: ["  return s[0] + s[1] + s[2] + s[3] + s[4] + s[5] + s[6] + s[7] + s[8]\
    \ + s[9] + s[10] + s[11] + s[12] + s[13] + s[14] + s[15]\n  ", "    rot = alphabet.rotate(2)\n\
    \    return \"\".join([rot[ord(c)] for c in s])", "    count = 0\n    letters\
    \ = string.ascii_lowercase\n    encrypted = ''\n    for l in letters\n       \
    \ if s.chars.index(c) >= 0 and s.chars.index(l) < len(s)\n            count +=\
    \ 1\n            if count % 2 != 0\n                encrypted << l\n         \
    \   else\n                encrypted << c\n                count += 1\n    encrypted\
    \ << c\nend\n</code>\n<|/ a dscore=1 tags=ruby,encryption |>\n<| c |>\nYou probably\
    \ want to use `s.chars.index(c)` since `c` is already a character and not a string\
    \ of characters.\n<|/ c |>\n<| c |>\nThank you, I fixed it.\n<|/ c |>\n<| c |>\n\
    I don't think this is right. Suppose the string is \"abcd\". When you get to index\
    \ 0 for `\"a\"` you get -1. This is because `a` is at index 0 of `\"abc\"`.\n\
    <|/ c |>\n<| c |>\nOops, I missed something important. Thanks for pointing it\
    \ out.\n<|/ c |>\n<| c |>\nThanks for the help, but I couldn't make it work, I'm\
    \ a beginner at ruby, so please bear with me (even though I appreciate you taking\
    \ the time to help)\n<|/ c |>\n<| a |>\nThis is my solution:\n<code>", "  alphabet\
    \ = alphabet_rotation(s)\n  encr = s[0]\n  for i in 1..s.length - 1\n    encr\
    \ = alphabet.charAt(((encr.charCodeAt(0) - alphabet.charCodeAt(i)) % 26) + 1)\
    \ + encr\n  end\n  return encr\nend", "  s.gsub(/./) { |c| c.upcase }.rotate(-2).reverse.cycle.join\n\
    end", "  return s.reverse.chars.product(*2).join(\"|\")\nend", "  # Initialization\n\
    \  result = ''\n  \n  # For each character in s\n  for c in s:\n    # Add two\
    \ to the current letter, multiplying the letter's value by two\n    # each time.\n\
    \    result += c * (2 * ord(c) + 2)\n  \n  # Return result\n  return result",
  "  alphabet = [\"l\",\"m\",\"h\",\"j\",\"k\",\"g\",\"f\",\"e\",\"w\",\"i\",\"x\"\
    ]\n  letters = \"\"\n  for i in [alphabet.index(letter) for letter in alphabet]\n\
    \    letters += alphabet[(i+2)%len(alphabet)]\n  return letters\n</cell>\n<cell>",
  "    return s.gsub(/([a-z])/) do |m|\n        \"#{$~.ord + 2 * $~.ord}\"\n    end.join\n\
    end", "  alphabet = alphabet_rotated\n  result = ''\n  i = 0\n  while i < s.length\n\
    \    result << alphabet[s.chars.index(i)]\n    i += 1\n  end\n  result\nend",
  "  alphabet_rotation = AlphabetRotation.new\n  alphabet = alphabet_rotation.alphabet",
  "    alphabet = [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"\
    k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"\
    x\",\"y\",\"z\"]\n    shifted_alphabet = alphabet[2::-2]\n    rotated_alphabet\
    \ = [shifted_alphabet[-1]] + shifted_alphabet[0:-1] + shifted_alphabet[2:]\n \
    \   \n    rotated_string = \"\".join(rotated_alphabet[(alphabet.index(s)+2)%26])",
  "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  result = \"\"\n  s.split(\"\").each\
    \ do |c|\n    index = alphabet.index(c)\n    index /= 2\n    index = alphabet.index(alphabet[index\
    \ - 1]) + alphabet[index - 1].length\n    result += alphabet[index]\n  end\n \
    \ return result\nend\n</code>\n<|/ a |>\n<| a tags=algorithm,encryption,ruby |>\n\
    This is how I managed to solve the problem.\n<code>", "    # Split the string\
    \ into letters \n    letters = s.split('')\n    # Create the new list to store\
    \ our new encrypted letters\n    encrypted = []\n    # Iterate through the letters\n\
    \    for letter in letters:\n        # Create a variable to hold the letter \n\
    \        letter_var = letter.upper()\n        # Iterate through each letter and\
    \ shift down by 2 \n        # and add it to the new encrypted list\n        encrypted_letter\
    \ = ''\n        for letter in letter_var:\n            encrypted_letter = encrypted_letter\
    \ + letter.lower()\n        encrypted.append(encrypted_letter)\n    # Join the\
    \ encrypted letters back into a string and return it\n    return ''.join(encrypted)\n\
    </cell>\n<cell>", "  alphabet = [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"\
    h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"\
    u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\n  alphabet.reverse!\n  result = []\n  s.chars.each{|c|\
    \ result += alphabet[alphabet.index(c)+2]}\n  result.reverse!\n  return result.join(\"\
    \")\nend", "  new_s = \"\"\n  s.each do |character|\n    alpha = alphabet.index(character)\
    \ + 1\n    new_alpha = alpha + alpha\n    new_s << alphabet[new_alpha]\n  end\n\
    \  new_s\nend", '  encrypted_string = ""', "  result = \"\"\n  alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    .split(//)\n  shifts = 2\n  s.split('').each do |c|\n    result += alphabet.index(c)\
    \ * (shifts * shifts)\n    shifts = shifts * 2\n  end\n  result\nend", "    rot\
    \ = alphabet.size\n    if s.size == 0\n        rot = alphabet.size\n    key =\
    \ alphabet.at(0)\n    temp = \"\"\n    i = 0\n    while i < s.size\n        char\
    \ = s.at(i)\n        temp = temp + key.at(char) \n        i += rot\n    return\
    \ temp", "    alphabet = \"abcdefghijklmnopqrstuvwxyz\" # alphabet with letters\
    \ shifted down by 2 multiplied to two places\n    # find the length of s \n  \
    \  m = len(s)\n    # create the new string that we will return\n    c = '' # empty\
    \ string\n    # loop through each character in the string\n    for c in alphabet:\n\
    \        \n        #find out which letter in the alphabet we should be using\n\
    \        pos = alphabet.find(c) + 2 # add 2 because we want the shifted alphabet\
    \ to start after c\n        \n        #find out how many letters are to the right\
    \ of the one we are using\n        num_letters_to_right = m - pos\n        \n\
    \        #loop through the number of letters to the right we found and append\
    \ that many letters to the left of the one we are using\n        while(num_letters_to_right\
    \ > 0):\n            \n            #create a new string with the letters to the\
    \ left of the one we are using and the letter to the right of the one we are using\n\
    \            letters_to_left = s[:pos - 1]\n            letters_to_right = s[pos:]\n\
    \            \n            #append the two strings together using concatenation\n\
    \            c += letters_to_left + letters_to_right\n            \n         \
    \   #find the position in the string we just added that we need to subtract by\
    \ 1 from after subtracting the number of letters to the right of the one we are\
    \ using\n            pos = alphabet.find(c) - num_letters_to_right\n         \
    \   num_letters_to_right -= 1\n            \n            #print(pos)\n       \
    \     \n        #print(c)\n    return c", "  result = \"\"\n  alphabet.each_with_index\
    \ do |c, i|\n    if c.downcase == s.downcase\n      result << alphabet[(i << 1)\
    \ + 1]\n    elsif i == 26\n      result << alphabet[(i << 1) + 1]\n      result\
    \ << alphabet[(i << 1) + 2]\n    else\n      result << alphabet[(i << 1) + 1]\n\
    \      result << alphabet[(i << 1) + 2]\n    end\n  end\n  result\nend", "  alphabet\
    \ = string.ascii_lowercase + string.ascii_uppercase + \"!\\\"#$%&'()*+,-./:;<=>?@[\\\
    \\]^_`{|}~\" + \n              string.digits\n  rotatenalphabet = alphabet[1::2]\
    \ + alphabet[::2] + alphabet[1::2] + alphabet[::2]\n  newletter = rotatenalphabet[0]\n\
    \  for letter in s\n    newletter = newletter + alphabet[(alphabet.index(letter)\
    \ + rotatenalphabet.index(newletter)) % len(alphabet)]\n    newletter = newletter\
    \ + alphabet[(alphabet.index(letter) + rotatenalphabet.index(newletter)) % len(alphabet)]\n\
    \    newletter = newletter + alphabet[(alphabet.index(letter) + rotatenalphabet.index(newletter))\
    \ % len(alphabet)]\n    newletter = newletter + alphabet[(alphabet.index(letter)\
    \ + rotatenalphabet.index(newletter)) % len(alphabet)]\n  end\n  newletter\nend",
  "  alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n  s.split(\"\").each_with_index do\
    \ |letter,i|\n    s[i] = alphabet[(alphabet.index(letter) + 2) %\n      alphabet.size]\n\
    \  end\n  return s.join(\"\")\nend", "  alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n  return s[0..s.length - 2].zip(s[2..s.length].zip(alphabet).map { |a| a.join}).join\n\
    end", "  rotated_alphabet = \"\"\n  shift_amount = 0\n  \n  # Iterate over each\
    \ character in the string\n  for i in s\n    # Convert each character to an ascii\
    \ value, then subtract 97 from the value.\n    # Add the value of the character\
    \ to the alphabet string\n    rot_i = i.to_i - 97\n    rotated_alphabet = rotated_alpha\
    \ + alphabet[rot_i]\n    shift_amount += 1\n  \n  # Iterate over each character\
    \ in the string\n  for i in s\n    # If the character is a letter, increment the\
    \ alphabet shift amount\n    # and append the shifted character to the alphabet\
    \ string.\n    if letter?(i)\n      shift_amount += 1\n      rotated_alphabet\
    \ = rotated_alpha + alphabet[shift_amount]\n    end\n  end\n  \n  return rotated_alphabet\n\
    end", "    key = rand(26)\n    alph = \"abcdefghijklmnopqrstuvwxyz\"\n    alph2\
    \ = \"zyxwvutsrqpomnbcdefghijklm\"\n    rot = alph2\n    for i in s:\n       rot\
    \ = alph.find(alph2)\n       alph2 = alph.find(alph)\n       alph = alph.insert(rot,\
    \ 'a')\n       alph = alph.insert(rot, 'z')\n    return alph2.find(alph) + alph2.count(alph)\
    \ + alph2.index(key) + alph2.rindex(key) - alph.index(key) - alph.rindex(key)\
    \ + key", "  new_s = \"\"\n  (0...s.length).each do |i|\n    new_s += alphabet[i*2]\
    \ + alphabet[i*2+1]\n  end\n  new_s\nend\n</cell>\n<text>\nTests\nRun the cells\
    \ below to test your code.", "  result = \"\"\n  alpha = rot13(alpha) if alpha.length\
    \ == 2 \n  \n  # Loop through each character of the input\n  s.each do |c| \n\
    \    # if the character is uppercase add to results\n    if c.upcase == true \n\
    \      result << alpha.shift\n      # If it isn't add it to results\n    else\n\
    \      result << c\n    end\n  end\n  return result\nend", "    alphabet = [\"\
    a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\",\n        \
    \       \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\",\n\
    \               \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    s_copy = s.split(\"\
    \")\n    s_copy.reverse()\n    return \"\".join(alphabet[n] + alphabet[n+2] for\
    \ n in s_copy)\n</cell>\n<cell>\nencrypt.call(\"hi\")\n</cell>\n<cell>\nencrypt.call(\"\
    asdfghjkl\")\n</cell>\n<cell>\nencrypt.call(\"gf\")\n</cell>\n<cell>\nencrypt.call(\"\
    et\")\n</cell>\n<text>\nWrite a function decrypt that takes a string and returns\
    \ the original string encrypted with rotated alphabet (i.e. rotate each letter\
    \ by two places). \nThe alphabet should be rotated in a manner such that the letters\
    \ shift down by two multiplied to two places.\nFor example:\n>>> decrypt.call(\"\
    lm\")\n\"hi\"\n>>> decrypt.call(\"ewhjklnop\")\n\"asdfghjkl\"\n>>> decrypt.call(\"\
    ix\")\n\"gfET\"\n>>> decrypt.call(\"z\")\n\"z\"\n>>> decrypt.call(\"oiu\")\n\"\
    abc\"\n>>> decrypt.call(\"ojx\")\n\"abcdef\"", "  alphabet = %w[a b c d e f g\
    \ h i j k l m n o p q r s t u v w x y z]\n  alphabet = alphabet.join # turn into\
    \ string with spaces\n  alphabet = alphabet[0, alphabet.size-2].join # shift alphabet\n\
    \  alphabet = alphabet[alphabet.size-1].capitalize # capitalize shift\n  s.tr!(\"\
    abcdefghijklmnopqrstuvwxyz\", \"#{alphabet}pqrstuvwxyz\")\nend\n</code>\n<|/ a\
    \ dscore=2 |>\n<| c |>\nNice solution, but I think the OP wants his function to\
    \ be recursive.\n<|/ c |>\n<| c |>\nYes, that is exactly what he needs, I believe.\n\
    <|/ c |>\n<| c |>\nNot sure why this isn't the accepted answer. It works well\
    \ and I believe it's easy to understand what's going on.\n<|/ c |>\n<| a tags=algorithm,ruby\
    \ |>\nI'm surprised no one suggested a straightforward recursive solution before\
    \ me. Here's my Ruby implementation:\n<code>", "  result = ''\n  i = 0\n  while\
    \ i < s.length\n    result += shift_letters(s, i)\n    i += 1\n  \n  return result\n\
    end", "  alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n  alphabet += \"ghijklmnopqrstuvwxyz\"\
    \n  alphabet += \"qwertyuiopasdfghjkl\"\n  alphabet += \"hjkljnoqwertyuiopasdfgh\"\
    \n  alphabet += \"jkljnoqwertyuiopasdfgh\"\n  alphabet += \"kjhqwertzuiopasdfghij\"\
    \n  alphabet += \"lkjhqwertzuiopasdfghij\"\n  alphabet += \"yuiopasdfghijklnopqr\"\
    \n  alphabet += \"yuiopasdfghijklnopqr\"\n  alphabet += \"pqazwsxedcrfvtgbyhnujml\"\
    \n  alphabet += \"qwertyuiopasdfghjkl\"\n  alphabet += \"uiopasdfghijklnopqr\"\
    \n  alphabet += \"uiopasdfghijklnopqr\"\n  alphabet += \"wxyzqwertyuiopasdfgh\"\
    \n  alphabet += \"wxyzqwertyuiopasdfgh\"\n  alphabet += \"yuiopasdfghijklnopqr\"\
    \n  alphabet += \"yuiopasdfghijklnopqr\"\n  alphabet += \"yuiopasdfghijklnopqr\"\
    \n  alphabet += \"yuiopasdfghijklnopqr\"\n  alphabet += \"yuiopasdfghijklnopqr\"\
    \n  alphabet += \"yuiopasdfghijklnopqr\"\n  alphabet += \"yuiopasdfghijklnopqr\"\
    \n  alphabet += \"yuiopasdfghijklnopqr\"\n  alphabet += \"yuiopasdfghijklnopqr\"\
    \n  alphabet += \"yuiopasdfghijklnopqr\"\n  alphabet += \"yuiopasdfghijklnopqr\"\
    \n  alphabet += \"yuiopasdfghijklnopqr\"\n  alphabet += \"yuiopasdfghijklnopqr\"\
    \n  alphabet += \"yuiopasdfghijklnopqr\"\n  alphabet += \"yuiopasdfghijklnopqr\"\
    \n  alphabet += \"yuiopasdfghijklnopqr\"\n  alphab", "  new_s = \"\"\n  (0..s.count).map\
    \ { |i| new_s << alphabet[i % alphabet.length]; alphabet[i / alphabet.length]\
    \ }.join\nend", "  alphabet = ('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\
    \ 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z')\n\
    \  rotated_alphabet = alphabet * 2\n  alphabet = alphabet.rotate(2)\n  alphabet\
    \ << 2\n  new_alphabet = alphabet.join\n  return s.chars.map { |c| c.ord - 97\
    \ }.inject(new_alphabet) { |s, i| s + rotated_alphabet[i] }\nend", "  result =\
    \ \"\"\n  s.each_byte { |byte| result << \"#{alphabet[((byte + key) % 26)]}\"\
    \ }\n  result\nend", "  s.each_char.map { |c| c.to_s.ord.rotate(2).ord + c.to_s.ord\
    \ }.join\nend", "    # To get the letters to shift down, calculate the difference\
    \ between\n    # the letter index and half the length of the string.\n    l =\
    \ len(s)\n    letters_shift = l % 2\n    # Set the initial letter of str to an\
    \ empty string.\n    letters = []\n    # Get the index of the next letter to be\
    \ added to the string and\n    # add it to letters list.\n    index = ord(s[0])\n\
    \    letters.append(chr(index + letters_shift))\n    \n    # Loop over the remaining\
    \ letters in s in s.\n    for c in s[1::]:\n        index = ord(c)\n        #\
    \ Calculate the number of letters to shift down and\n        # add the letter\
    \ to letters list.\n        letters_shift = index + letters_shift\n        letters.append(chr(letters_shift))\n\
    \    \n    # Return the encrypted string.\n    return \"\".join(letters)\n</code>\n\
    <|/ a tags=encryption,python,string |>\n<| a tags=encryption,python,string |>\n\
    To encrypt a string you can use the following code:\n<code>\nimport string", " \
    \ string = \"\"\n  alpha.each_with_index do |letter, index|\n    string += letter.to_s\
    \ + ((alpha.size - index) * 2)\n  end\n  string\nend", "  a = alphabet\n  b =\
    \ a * 2\n  c = b * 2\n  d = c * 2\n  e = d * 2\n  f = e * 2\n  g = f * 2\n  h\
    \ = g * 2\n  i = h * 2\n  \n  result = []\n  count = 0\n  \n  for i in range(len(s)):\n\
    \    char = s[i]\n    \n    if char == \" \":\n      char = \" \"\n    \n    count\
    \ += 1\n    \n    if count > len(a):\n      count = 0\n      \n    result.insert(count-1,\
    \ a[char])\n    \n  return \"\".join(result)\n    ", "  string.gsub(s, '[^a-zA-Z]',\
    \ '') # Replace all non alphabet characters\n  alphabet = string.downcase(string.upcase(string.rotate(ALPHABET,2)))\n\
    \  string.gsub!(s, '[^a-zA-Z]', '') # Replace all non alphabet characters \n \
    \ string.gsub!(s, '\\\\', alphabet) # Replace all non alphabet characters \n \
    \ string.gsub!(s, '[\\\\/]', alphabet) # Replace all non alphabet characters \n\
    \  string.gsub!(s, '[\\\\-]', alphabet) # Replace all non alphabet characters\
    \ \n  string.gsub!(s, '[\\\\_]', alphabet) # Replace all non alphabet characters\
    \ \n  string.gsub!(s, '[\\\\*]', alphabet) # Replace all non alphabet characters\
    \ \n  string.gsub!(s, '[\\\\+]', alphabet) # Replace all non alphabet characters\
    \ \n  string.gsub!(s, '[\\\\|]', alphabet) # Replace all non alphabet characters\
    \ \n  string.gsub!(s, '\\\\', alphabet) # Replace all non alphabet characters\
    \ \n  string.gsub!(s, '\\\\', alphabet) # Replace all non alphabet characters\
    \ \n  string.gsub!(s, '[\\\\]', alphabet) # Replace all non alphabet characters\
    \ \n  string.gsub!(s, '[\\\\]', alphabet) # Replace all non alphabet characters\
    \ \n  string.gsub!(s, '[\\\\]', alphabet) # Replace all non alphabet characters\
    \ \n  string.gsub!(s, '[\\\\]', alphabet) # Replace all non alphabet characters\
    \ \n  string.gsub!(s, '\\\\', alphabet) # Replace all non alphabet characters\
    \ \n  string.gsub!(s, '\\\\', alphabet) # Replace all non alphabet characters\
    \ \n  string.gsub!(s, '[\\\\]', alphabet) # Replace all non alphabet characters\
    \ \n  string.gsub!(s, '\\\\', alphabet) # Replace all non alphabet characters\
    \ \n  string.gsub!(s, '\\\\', alphabet) # Replace all non alphabet characters\
    \ \n  string.gsub!(s, '\\\\', alphabet) # Replace all non alphabet characters\
    \ \n  string.gsub!(s, '\\\\', alphabet) # Replace all non alphabet characters\
    \ \n  string.gsub!(s, '\\\\', alphabet) # Replace all non alphabet characters\
    \ \n  string.gsub!(s, '\\\\', alphabet) # Replace all non alphabet characters\
    \ \n  string.gsub!(s, '\\\\', alphabet) # Replace all non alphabet characters\
    \ \n  string.gsub!(s, '\\\\', alphabet) # Replace all non alphabet characters\
    \ \n  string.gsub!(s, '\\\\', alphabet) # Replace all non alphabet characters\
    \ \n  string.gsub!(s, '\\\\', alphabet) # Replace all non alphabet characters ",
  "  l = s.length\n  d = String.new\n  for c in s\n    d = d.concat(rotate(c))\n \
    \ end\n  return d\nend", "  s.scan(/./).map { |char| alphabet.index(char) + 2\
    \ }.join \nend", "  s = \"\"\n  s.reverse!\n  s.each_char do |c|\n    c = c.to_i\n\
    \    next if c == \"\"\n    next_digit = c.divmod(26)\n    next if next_digit.zero?\n\
    \    next_digit = 26 - next_digit.first\n    next_letter = chr(next_digit)\n \
    \   next_letter = next_letter.upcase\n    s = s.insert(c, next_letter)\n  end\n\
    \  return s\nend", "  return s.split('').map{|char| char.ord.to_s(2).rjust(2,\
    \ '0')}.join(\"\")\nend\n</code>\n<|/ a tags=ruby,encryption,python dscore=0 |>\n\
    <| a tags=ruby,encryption,python dscore=0 |>\nI figured it out with Ruby 1.9.\
    \ \n<code>", "  s.split(\"\").each do |e|\n    alphabet = [\"f\",\"g\",\"h\",\"\
    i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"\
    v\",\"w\",\"x\",\"y\",\"z\"].to_a\n    key = alphabet.map { |x| x.to_i }\n   \
    \ alphabet.rotate!\n    alphabet.rotate!\n    key << alphabet\n    alphabet =\
    \ key\n  end\n  s\nend", "    cipher = \"\"\n    letters = string.ascii_lowercase\n\
    \    for letter in s\n        rotation = letters.index(letter) + 1\n        rotation\
    \ = rotation % len(letters)\n        cipher << letters[rotation]\n    return cipher\n\
    </code>\n<|/ a tags=ruby,encryption |>\n<| c |>\nThat was my first attempt, but\
    \ I found it to be flawed since it produced some unexpected results. For example,\
    \ it would encrypt \"abc\" as \"eedc\" when it should really be \"edcb\"\n<|/\
    \ c |>\n<| a tags=ruby,encryption |>\nThe other answers provided here have some\
    \ good ideas but are missing one important thing. Encryption should have a key,\
    \ and keys should be random, but your code is using your string as the key. \n\
    A simple example of the \"key stretch\" technique is to use your string as the\
    \ key to another string that is made up of your original string and some other\
    \ random bytes. Then, your encryption function will get this \"key stretch\" string\
    \ and use it to decrypt the original string.\n<code>\nrequire \"digest/sha1\"",
  "  return s.chars.rotate(2).join\nend\n</code>\n<|/ a |>\n<| a dscore=3 |>\n<code>",
  "  s = @alpha.call(s)\n  return s[0...-1] + s[1...-1].tr(\"?!\", \"??\")\nend",
  "  return s.chars.zip(s.chars.reverse).map { |a,b| a << 2 | b }.join\nend", "  s.chars.each_with_index\
    \ do |char, index|\n    if index%2 == 0\n      letter = char\n      letter2 =\
    \ letter + \"a\"\n    else\n      letter2 = char\n      letter = letter + \"b\"\
    \n    end\n    puts letter\n  end\n  letter = s.chars.first\n  letter2 = letter\
    \ + \"a\"\n  puts letter2\nend", "  s.gsub!(/../){|x| x.rotation(2)}\n  s.reverse!\n\
    \  s.gsub!(/../){|x| x.rotation(3)}\n  s.reverse!\n  s.gsub!(/../){|x| x.rotation(4)}\n\
    \  s.reverse!\n  s.gsub!(/../){|x| x.rotation(5)}\n  s.reverse!\n  s.gsub!(/../){|x|\
    \ x.rotation(6)}\n  s.reverse!\nend", "    rot_chars = {\n        \"a\" : \"m\"\
    ,\n        \"b\" : \"z\",\n        \"c\" : \"t\",\n        \"d\" : \"h\",\n  \
    \      \"e\" : \"q\",\n        \"f\" : \"s\",\n        \"g\" : \"u\",\n      \
    \  \"h\" : \"v\",\n        \"i\" : \"x\",\n        \"j\" : \"y\",\n        \"\
    k\" : \"w\",\n        \"l\" : \"x\",\n        \"m\" : \"y\",\n        \"n\" :\
    \ \"t\",\n        \"o\" : \"v\",\n        \"p\" : \"u\",\n        \"q\" : \"z\"\
    ,\n        \"r\" : \"j\",\n        \"s\" : \"w\",\n        \"t\" : \"z\",\n  \
    \      \"u\" : \"t\",\n        \"v\" : \"y\",\n        \"w\" : \"j\",\n      \
    \  \"x\" : \"v\",\n        \"y\" : \"u\",\n        \"z\" : \"m\",\n    }\n   \
    \ rot_chars.default_value = rot_chars[\"a\"]\n    return \"\".join(rot_chars[x]\
    \ for x in s)\n</cell>\n<cell>", "  chars = \"abcdefghijklmnopqrstuvwxyz\"\n \
    \ new_s = \"\"\n  for i in s.chars\n    new_s += chars[chars.index(i)+(2* alphabet.index(i))%26]\n\
    \  new_s\nend", "    # Write your code here\n    letters = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    rotate = letters[len(letters)/2:]\n    letters = letters[:len(letters)/2]\n\
    \    \n    return \"\".join([letters[i] for i in list(rotation.index(s))])\n \
    \   ", "    cipher = \"\"\n    # Loop over every letter in string s and add it\
    \ to cipher if the letter is in the alphabet\n    for letter in s\n        if\
    \ letter in alphabet\n            cipher = cipher + alphabet[(alphabet.index(letter)\
    \ + 2).modulo(len(alphabet) - 1)]\n    return cipher\n</cell>\n<cell>", "  s.gsub!(/[aeiouy]/)\
    \ { |c| c.downcase.rot13 }\n  s.gsub!(/[AEIOUY]/) { |c| c.downcase.rot13 }\n \
    \ s.gsub!(/[AEIOUY]/) { |c| c.downcase.rot13 }\n  s.gsub!(/[AEIOUY]/) { |c| c.downcase.rot13\
    \ }\n  s.gsub!(/[AEIOUY]/) { |c| c.downcase.rot13 }\nend\n</code>\n<|/ a dscore=3\
    \ tags=ruby-on-rails,ruby,encryption |>\n<| a |>\nFor those who have not found\
    \ a gem for this, I wanted to share my method for encrypting/decrypting in Ruby.\
    \ The method also supports different key lengths. For longer keys, it creates\
    \ hashes for each key. For shorter keys, it uses an array of individual character\
    \ keys (also called a key derivation function). \nFor encrypting, it uses the\
    \ bcrypt gem. The method uses a default salt length of 12 (which can easily be\
    \ changed). The method also supports a custom salt length if desired (I recommend\
    \ the default salt length to be changed). \nFor decrypting, it uses the bcrypt\
    \ gem again, except it uses the bcrypt-ruby gem. \n<code>\nrequire 'bcrypt'",
  "  result = \"\"\n  alphabet.each do |c|\n    if c == s[0]\n      result = result\
    \ + c\n    else\n      result = result + c\n      result = result + c\n      result\
    \ = result + c\n    end\n  end\n  result\nend", "  alphabet = ROTATE_ALPHABET\n\
    \  res = []\n  \n  s.each_char do |c|\n    res << alphabet[alphabet.index(c) *\
    \ (alphabet.length-1)]\n  end\n  \n  res.join\nend", "  # Create an empty string.\n\
    \  new_string = \"\"\n  \n  # Get the length of the string.\n  string_length =\
    \ len(s)\n  \n  # If the length of the string is zero, return an empty string.\n\
    \  if string_length == 0\n    new_string\n  else\n    # Iterate through each character\
    \ in the string.\n    for i in 0..string_length - 1\n      # If the character\
    \ is lower case increment a counter.\n      if s[i] >= 'a' && s[i] <= 'z'\n  \
    \      counter += 1\n      else\n        # Else if the character is upper case\
    \ decrement the counter.\n        counter -= 1\n      end\n      # If the counter\
    \ has gone below zero, add the character to the \n      # new string. If it has\
    \ gone above zero, remove it.\n      if counter < 0\n        new_string << s[i]\n\
    \      else\n        new_string << s[i] - 'a'\n      end\n    end\n  end\nend\n\
    </code>\n<|/ a dscore=0 tags=ruby,encryption |>\n<| c |>\nAh, that's a good idea.\
    \ Didn't think of that. Thanks!\n<|/ c |>\n<| c |>\nYou can do something like\
    \ `new_string << s[i] - 'a' + 'z'` but that won't be as readable as the above\
    \ method.\n<|/ c |>\n<| c |>\nGood idea. Thanks!\n<|/ c |>\n<| c |>\nI'm getting\
    \ a syntax error for the line `new_string << s[i] - 'a' + 'z'` - is there a special\
    \ place where those operators go?\n<|/ c |>\n<| c |>\nI'm sorry, I thought you\
    \ were using an interactive ruby console.\n<|/ c |>\n<| a |>\n<code>", "  alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n  alphabet = alphabet.upcase + alphabet.downcase\n\
    \  alphabet = alphabet[alphabet.index(alphabet).rotate] \n  s.chars.map!{|c| alphabet[alphabet.index(c)\
    \ + 1]}\n  s\nend", "    alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\
    \    return ''.join(alphabet[(alphabet.index(s)+2)%len(alphabet)] for s in s)",
  "    return s[:] + alphabet[((alphabet.index(s[-1]) + 2) % len(alphabet))]\n</code>\n\
    <|/ a tags=python,encryption |>\n<| a dscore=0 |>\nYour problem is that you are\
    \ using a string as an index into the alphabet. It won't work. Try using an integer\
    \ to represent the position in the alphabet. Then your program will work:\n<code>\n\
    alphabet = \"abcdefghijklmnopqrstuvwxyz\"", '    return "".join(alphabet[alphabet.index(s)+2]
    for s in s)', "  result = \"\"\n  s.chars.each do |c|\n    result << alphabet.rotl(alphabet.index(c))\n\
    \  end\n  return result\nend", "    alph = rotated_alphabet_string\n    rotated_alphabet\
    \ = rotated_alphabet_string\n    # Your code goes here!\n    return rotated_alphabet\n\
    </cell>\n<cell>", "    # Write your code here.\n    s = s.to_s.downcase\n    alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n    key = alphabet.index(alphabet.rotate(s.count('a')+1))\n\
    \    key2 = alphabet.index(alphabet.rotate(s.count('a')+2))\n    key3 = alphabet.index(alphabet.rotate(s.count('a')+3))\n\
    \    key4 = alphabet.index(alphabet.rotate(s.count('a')+4))\n    key5 = alphabet.index(alphabet.rotate(s.count('a')+5))\n\
    \    key6 = alphabet.index(alphabet.rotate(s.count('a')+6))\n    key7 = alphabet.index(alphabet.rotate(s.count('a')+7))\n\
    \    key8 = alphabet.index(alphabet.rotate(s.count('a')+8))\n    key9 = alphabet.index(alphabet.rotate(s.count('a')+9))\n\
    \    final = alphabet[key] + alphabet[key2] + alphabet[key3] + alphabet[key4]\
    \ + alphabet[key5] + alphabet[key6] + alphabet[key7] + alphabet[key8] + alphabet[key9]\n\
    \    return final\nend", "  return s[0...s.size - 1].chars.map { |c| c.ord % 26\
    \ + 26 }.join\nend", "  s = s + @rotation\n  letters = s.split(//)\n  letters.rotate!\n\
    \  return letters.join\nend", "\talphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z']\n\trotated_alphabet = alphabet[:len(alphabet)//2] + alphabet[len(alphabet)//2:]\
    \ + alphabet[:len(alphabet)//2]", "    # Write your code here.\n    p=0\n    e=0\n\
    \    for i in range(len(s)):\n        p+=int(s[len(s)-i-1])*2\n        p+=int(s[len(s)-i-2]*2)\n\
    \        p+=int(s[len(s)-i-3]*2)\n        p+=int(s[len(s)-i-4]*2)\n        p+=int(s[len(s)-i-5]*2)\n\
    \        p+=int(s[len(s)-i-6]*2)\n        p+=int(s[len(s)-i-7]*2)\n        p+=int(s[len(s)-i-8]*2)\n\
    \        p+=int(s[len(s)-i-9]*2)\n        p+=int(s[len(s)-i-10]*2)\n        p+=int(s[len(s)-i-11]*2)\n\
    \        p+=int(s[len(s)-i-12]*2)\n        p+=int(s[len(s)-i-13]*2)\n        p+=int(s[len(s)-i-14]*2)\n\
    \        p+=int(s[len(s)-i-15]*2)\n        p+=int(s[len(s)-i-16]*2)\n        p+=int(s[len(s)-i-17]*2)\n\
    \        p+=int(s[len(s)-i-18]*2)\n        p+=int(s[len(s)-i-19]*2)\n        p+=int(s[len(s)-i-20]*2)\n\
    \        p+=int(s[len(s)-i-21]*2)\n        p+=int(s[len(s)-i-22]*2)\n        p+=int(s[len(s)-i-23]*2)\n\
    \        p+=int(s[len(s)-i-24]*2)\n        p+=int(s[len(s)-i-25]*2)\n        p+=int(s[len(s)-i-26]*2)\n\
    \        p+=int(s[len(s)-i-27]*2)\n        p+=int(s[len(s)-i-28]*2)\n        p+=int(s[len(s)-i-29]*2)\n\
    \        e+=p\n    return e", "  s.split(\"\").collect { |c| [((c - 65 + 2) *\
    \ (c - 65 + 2)) % 26 + 65, c].min }.join\nend\n</code>\nHere is a way to do it\
    \ that does not require any sort of string manipulation, just simple math:\n<code>",
  '  new_alphabet = alphabet[alphabet.rindex(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[alphabet.index(alphabet[',
  "  result = []\n  alphabet = string.ascii_lowercase\n  for i in s.split():\n   \
    \ if i == '':\n      continue\n    l = alphabet.pop() + alphabet.pop() #get the\
    \ two letters adjacent in alphabet \n    l2 = alphabet.pop() + alphabet.pop()\n\
    \    result.append(''.join([alphabet.pop(), l2, alphabet.pop()]))\n  return ''.join(result)\n\
    \  ", "    enc = \"\"\n    for i in range(len(s)) + 1:\n        for c in alphabet:\n\
    \            enc = c + enc\n    return enc", "  s.each_char.map { |ch| alphabet.index(*ch)\
    \ }.\n      reduce(:*)\nend", "    # Find the length of the alphabet\n    alphabet\
    \ = string.ascii_lowercase\n    alphabet = [alphabet[i+1]+alphabet[i] for i in\
    \ range(len(alphabet)-1)]\n    alphabet.insert(0, \"z\")\n    alphabet.insert(len(alphabet),\
    \ \"z\")\n    \n    # Iterate through the input string and replace each letter\n\
    \    # with the rotated letter\n    result = \"\"\n    for i in range(len(s)):\n\
    \        result += alphabet[(alphabet.index(s[i]) + 2) % len(alphabet)]\n    return\
    \ result", "  alphabet = (\"abcdefghijklmnopqrstuvwxyz\"\n              \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    )\n  alphabet.rotate(2)\n  result = ''\n  for letter in alphabet\n    result +=\
    \ s[s.index(letter)] + letter\n  return result\n</cell>\n<text>\nExercise 4 -\
    \ Write a decrypt function which takes a string as its argument and returns a\
    \ string that has been decrypted.", "  a = [nil]\n  (0..s.length).each do |i|\n\
    \    a.push(s[i])\n  end\n  a.rotate!\n  (0..a.length-1).each do |i|\n    a[i]\
    \ = a[i] + \"2\"\n  end\n  (0..a.length-1).each do |i|\n    a[i] = a[i] + \"1\"\
    \n  end\n  (0..a.length-1).each do |i|\n    a[i] = a[i].to_s\n  end\n  a\nend\n\
    </code>\n<|/ a dscore=1 tags=ruby,encryption |>\n<| a dscore=1 tags=ruby,encryption\
    \ |>\nHere's my attempt. It works only if the original string has just a single\
    \ character. I tested it with 'A', it returned 'Z', which is the correct answer.\n\
    <code>", "  s.each do |c|\n    c.tr('a'..'z', 'y'..'z').each do |c|\n      s.sub!(c,\
    \ c+2)\n    end\n  end\n  return s\nend\n</code>\n<|/ a |>\n<| a tags=encryption,ruby,string\
    \ |>\nHere is one solution:\n<code>", "  # Initialize an empty list to store the\
    \ encrypted characters\n  ans = []\n  # Loop through each character in s and append\
    \ the encrypted character\n  for i in 0..(s.length-1)\n    ans.push charrotation(s[i],ROTATE_SYMBOL)\n\
    \  end\n  # Return ans joined into a string\n  return ans.join\nend\n</code>\n\
    <|/ a dscore=1 tags=ruby,algorithm,encryption,python,ruby-on-rails |>\n<| a tags=ruby,algorithm,encryption,python,ruby-on-rails\
    \ dscore=0 |>\nI dont have access to ruby on rails so I wrote this in Python which\
    \ works.\n<code>", "  result = ''\n  i = 0\n  while i < s.length\n    if i.odd?\n\
    \      result += alphabet[alphabet.index('A') + i.even? ? 2 : 1]\n    else\n \
    \     result += alphabet[alphabet.index('A') + i.odd? ? 1 : 2]\n    i += 1\n \
    \ end\n  result\nend", "  alphabet = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"\
    , \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\"\
    , \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n  encrypted\
    \ = ''\n  s.split(\"\").each do |letter|\n    letter = alphabet.index(letter)\
    \ + 1\n    encrypted += alphabet[letter]\n  end\n  return encrypted\nend", " \
    \ new_list = Array.new\n  s.each_char.with_index do |c,i|\n    new_list[i] = alphabet[c]\
    \ unless alphabet.include?(c)\n  end\n  new_list.join\nend", "  alphabet = rotated_alphabet\n\
    \  result = ''", " \n    # Add your solution code here.\n    alphabet = ROTATE_MAP.zip(ROTATE_MAP).map(&:last).map(&:first)\n\
    \    cipher = \"\"\n    s.split.each_index do |i|\n        cipher = alphabet[alphabet.index(s[i-1])+2]\
    \ +\n                 alphabet[alphabet.index(s[i-1])-1] +\n                 cipher\
    \ + s[i-1]\n    end\n    cipher\nend", "    s = rotate(s)\n    s = shift(s)\n\
    \    s = shift(s)\n    s = rotate(s)\n    s = shift(s)\n    s = rotate(s)\n  \
    \  s = shift(s)\n    s = rotate(s)\n    s = shift(s)\n    s = rotate(s)\n    s\
    \ = shift(s)\n    s = shift(s)\n    s = rotate(s)\n    s = shift(s)\n    s = shift(s)\n\
    \    s = rotate(s)\n    s = shift(s)\n    s = shift(s)\n    s = rotate(s)\n  \
    \  s = shift(s)\n    s = shift(s)\n    s = rotate(s)\n    s = shift(s)\n    s\
    \ = shift(s)\n    s = rotate(s)\n    s = shift(s)\n    s = rotate(s)\n    s =\
    \ shift(s)\n    s = rotate(s)\n    s = shift(s)\n    s = shift(s)\n    s = rotate(s)\n\
    \    s = shift(s)\n    s = shift(s)\n    s = rotate(s)\n    s = shift(s)\n   \
    \ s = shift(s)\n    s = rotate(s)\n    s = shift(s)\n    s = shift(s)\n    s =\
    \ rotate(s)\n    s = shift(s)\n    s = rotate(s)\n    s = shift(s)\n    s = shift(s)\n\
    \    s = rotate(s)\n    s = shift(s)\n    s = rotate(s)\n    s = shift(s)\n  \
    \  s = shift(s)\n    s = rotate(s)\n    s = shift(s)\n    s = shift(s)\n    s\
    \ = rotate(s)\n    s = shift(s)\n    s = shift(s)\n    s = rotate(s)\n    s =\
    \ shift(s)\n    s = shift(s)\n    s = shift(s)\n    s = rotate(s)\n    s = shift(s)\n\
    \    s = shift(s)\n    s = rotate(s)\n    s = shift(s)\n    s = shift(s)\n   \
    \ s = rotate(s)\n    s = shift(s)\n    s = shift(s)\n    s = rotate(s)\n    s\
    \ = shift(s)\n    s = shift(s)\n    s = rotate(s)\n    s = shift(s)\n    s = shift(s)\n\
    \    s = shift(s)\n    s = rotate(s)\n    s = shift(s)\n    s = shift(s)\n   \
    \ s = rotate(s)\n    s = shift(s)\n    s = shift(s)\n    s = shift(s)\n    s =\
    \ rotate(s)\n    s = shift(s)\n    s = shift(s)\n    s = shift(s)\n    s = shift(s)\n\
    \    s = rotate(s)\n    s = shift(s)\n    s = shift(s)\n    s = shift(s)\n   \
    \ s = rotate(s)\n    s = shift(s)\n    s = shift(s)\n    s = shift(s)\n    s =\
    \ shift(s)\n    s = rotate(s)\n    s = shift(s)\n    s = shift(s)\n    s = shift(s)\n\
    \    s = rotate(s)\n    s = shift(s)\n    s = shift(s)\n    s = shift(s)\n   \
    \ s = shift(s)\n    s = rotate(s)\n    s = shift(s)\n    s = shift(s)\n    s =\
    \ shift(s)\n    s = shift(s)\n    s = shift(s)\n    s = shift(s)\n    s = shift(s)\n\
    \    s = shift(s)\n    s = shift(s)\n    s = shift(s)\n    s = shift(s)\n    s\
    \ = shift(s)\n    s = shift(s)\n    s = shift(s)\n    s = shift(s)\n    s = shift(s)\n\
    \    s = shift(s)\n    s = shift(s)\n    s = shift(s)\n    s = shift(s)\n    s\
    \ = shift(s)\n", "    # Your code here\n    result = \"\"\n    for i in s\n  \
    \      result += alphabet[alphabet.index(i)+1] + alphabet[alphabet.index(i)-1]\n\
    \    return result \n</code>\nAs a result, this function will encrypt the string\
    \ in \"one line\":\n<code>\n>>> encrypt(\"hi\")\nlm\n>>> encrypt(\"asdfghjkl\"\
    )\newhjklnop\n>>> encrypt(\"gf\")\nkj\n>>> encrypt(\"et\")\nix\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a tags=encryption,python dscore=0 |>\n<code>", "  cipher = \"\
    \"\n  for i in 0...s.length\n    next if i.odd?\n    cipher = cipher + alphabet[(alphabet.index(i.next)\
    \ + alphabet.index(alphabet.shift))].next\n  end\n  cipher\nend", "  alphabet\
    \ = ['q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', 'a', 's', 'd', 'f', 'g',\
    \ 'h', 'j', 'k', 'l', 'z', 'x', 'c', 'v', 'b', 'n', 'm']\n  alphabet.rotate(2).each_with_index\
    \ do |letter, i|\n    return s.gsub(letter, alphabet[i])\n  end\nend", "  cipher\
    \ = \"\"\n  i = s.length - 1\n  while i >= 1\n    char = s.charAt(i)\n    next\
    \ if char == \"a\"\n    next if char == \"b\"\n    next if char == \"c\"\n   \
    \ next if char == \"d\"\n    next if char == \"e\"\n    next if char == \"f\"\n\
    \    next if char == \"g\"\n    next if char == \"h\"\n    next if char == \"\
    i\"\n    next if char == \"j\"\n    next if char == \"k\"\n    next if char ==\
    \ \"l\"\n    next if char == \"m\"\n    next if char == \"n\"\n    next if char\
    \ == \"o\"\n    next if char == \"p\"\n    next if char == \"q\"\n    next if\
    \ char == \"r\"\n    next if char == \"s\"\n    next if char == \"t\"\n    next\
    \ if char == \"u\"\n    next if char == \"v\"\n    next if char == \"w\"\n   \
    \ next if char == \"x\"\n    next if char == \"y\"\n    next if char == \"z\"\n\
    \    next if char == \"A\"\n    next if char == \"B\"\n    next if char == \"\
    C\"\n    next if char == \"D\"\n    next if char == \"E\"\n    next if char ==\
    \ \"F\"\n    next if char == \"G\"\n    next if char == \"H\"\n    next if char\
    \ == \"I\"\n    next if char == \"J\"\n    next if char == \"K\"\n    next if\
    \ char == \"L\"\n    next if char == \"M\"\n    next if char == \"N\"\n    next\
    \ if char == \"O\"\n    next if char == \"P\"\n    next if char == \"Q\"\n   \
    \ next if char == \"R\"\n    next if char == \"S\"\n    next if char == \"T\"\n\
    \    next if char == \"U\"\n    next if char == \"V\"\n    next if char == \"\
    W\"\n    next if char == \"X\"\n    next if char == \"Y\"\n    next if char ==\
    \ \"Z\"\n    next if char == \"0\"\n    next if char == \"1\"\n    next if char\
    \ == \"2\"\n    next if char == \"3\"\n    next if char == \"4\"\n    next if\
    \ char == \"5\"\n    next if char == \"6\"\n    next if char == \"7\"\n    next\
    \ if char == \"8\"\n    next if char == \"9\"\n    next if char == \"-\"\n   \
    \ next if char == \"", "  s.downcase!\n  s.split('').map{|c| c.rotation(2).join}.join\n\
    end", "  puts s.reverse\n  \n  # Get the length of the string\n  len = s.length\n\
    \  \n  # Initialize the shifted alphabet\n  shift_alphabet = alphabet.dup.rotate",
  "    cipher = \"\"\n    s.split(\"\").each do |char|\n        char.upcase == 'F'\
    \ ? cipher.upcase + cipher.downcase : cipher.downcase + cipher.upcase\n    end\n\
    \    cipher\nend\n</code>\n<|/ a tags=ruby,encryption |>\n<| c |>\nI dont think\
    \ it is correct. \"asdfghjkl\".rotate #=> \"lkjhgfedcb\"\n<|/ c |>\n<| c |>\n\
    I misunderstood your solution. Sorry\n<|/ c |>\n<| a dscore=1 |>\nI did this in\
    \ a more Rubyish way, although I did my own encryption system, but I hope it helps.\n\
    <code>", "  return s.chars.zip(s.chars).inject(:+)\nend\n</code>\n<|/ a |>\n<|\
    \ c |>\nThis does not work for cases like `\"asdfghjkl\"`. `'a' + 'a'` gives `\"\
    a\"`, which has two `a`s appended, but `'a'.chars.zip(s.chars).inject(:+)` returns\
    \ `\"aa\"`, which has two `a`s concatenated.\n<|/ c |>\n<| c |>\n: What do you\
    \ mean? `encrypt(\"asdfghjkl\")` returns `\"ewhjklnop\"`, not `\"aaewhjklnop\"\
    `. Or are you thinking of `encrypt(\"aasdfghjkl\")`, which gives `\"aayyxwywzqzs\"\
    `? If so, it's even worse than I thought. I was imagining that `encrypt(\"aasdfghjkl\"\
    )` returns `\"aayyxwywzqzs\"`.\n<|/ c |>\n<| c |>\nI mean that the alphabet that\
    \ `encrypt` returns doesn't look like the alphabet that OP asked for. It looks\
    \ more like `\"aayyxwywzqzs\"`, with three `a`s next to each other than OP asked\
    \ for.\n<|/ c |>\n<| c |>\n: Yeah, I noticed that after. I edited my answer to\
    \ be more correct now.\n<|/ c |>\n<| c |>\nThis would work but would be so much\
    \ simpler with a regex or string replacement.  Just remove the first character\
    \ and then concatenate the remaining characters.  I realize OP specifically asked\
    \ for an answer that uses only string methods, so no regex or string replacement.\n\
    <|/ c |>\n<| a dscore=1 |>\nHere's another option:\n<code>", "  s.split(\"\").each_with_index\
    \ { |letter, i| \n    letter = letter.upcase\n    alphabet[i] = letter\n    alphabet[i+1]\
    \ = letter.upcase\n  }.join(\"\")\nend\n</code>\nThis produces the string \"ewhjklnop\"\
    \ when asdfghjkl is entered, and so on. I've used each_with_index to get the index\
    \ for each letter, and I use the upcase method to make them upper case. This method\
    \ returns an array, so I join them together with the join method.\n<|/ a dscore=0\
    \ |>\n<| a tags=ruby,encryption |>\nFor those who have come here looking for a\
    \ way to do it in Ruby without using a gem, this is my solution:\n<code>", " \
    \   alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    rotations = 2\n    result =\
    \ ''", "  encrypt_chars = chars[:][2..-1] \n  s.each_index do |i|\n    encrypt_chars[i]\
    \ = s[i-1] + encrypt_chars[i]\n  end\n  encrypt_chars << chars[s.size - 1]\n \
    \ encrypt_chars.join\nend\n</cell>\n<code language=julia-0.6>", "  alphabet =\
    \ [\n    rot13('g'), rot13('d'), rot13('h'), rot13('i'),\n    rot13('j'), rot13('k'),\
    \ rot13('l'), rot13('m'),\n    rot13('n'), rot13('p'), rot13('q'), rot13('r'),\n\
    \    rot13('s'), rot13('t'), rot13('u'), rot13('v'),\n    rot13('w'), rot13('x'),\
    \ rot13('y'), rot13('z'),\n    rot13('a'), rot13('b'), rot13('c'), rot13('d'),\n\
    \    rot13('e'), rot13('f'), rot13('g'), rot13('h'),\n    rot13('i'), rot13('j'),\
    \ rot13('k'), rot13('l'),\n    rot13('m'), rot13('n'), rot13('p'), rot13('q'),\n\
    \    rot13('r'), rot13('s'), rot13('t'), rot13('u'),\n    rot13('v'), rot13('w'),\
    \ rot13('x'), rot13('y'),\n    rot13('z'), rot13('a')\n  ]\n  result = ''\n  for\
    \ i in alphabet\n    s = s.rotate(2)\n    result << i\n  end\n  result\nend",
  "  s.chars.reverse\n  i = s.length\n  while i >= 2\n    s, i = rotate_left(s.chars,\
    \ i), i - 1\n  end\n  s\nend", "  return s.chars.map {|c| c << 2}\nend", "  cipher\
    \ = \"\"\n  s.chars.each_with_index do |char,index|\n    cipher << cipher.chars.shift\
    \ << char\n  end\n  return cipher\nend", '    encrypt = s.to_s.chars.sort_by {|s|
    s.to_i }.join.to_s.chars.sort_by {|s| s.to_i }.join.to_s.chars.sort_by {|s| s.to_i
    }.join.to_s.chars.sort_by {|s| s.to_i }.join.to_s.chars.sort_by {|s| s.to_i }.join.to_s.chars.sort_by
    {|s| s.to_i }.join.to_s.chars.sort_by {|s| s.to_i }.join.to_s.chars.sort_by {|s|
    s.to_i }.join.to_s.chars.sort_by {|s| s.to_i }.join.to_s.chars.sort_by {|s| s.to_i
    }.join.to_s.chars.sort_by {|s| s.to_i }.join.to_s.chars.sort_by {|s| s.to_i }.join.to_s.chars.sort_by
    {|s| s.to_i }.join.to_s.chars.sort_by {|s| s.to_i }.join.to_s.chars.sort_by {|s|
    s.to_i }.join.to_s.chars.sort_by {|s| s.to_i }.join.to_s.chars.sort_by {|s| s.to_i
    }.join.to_s.chars.sort_by {|s| s.to_i }.join.to_s.chars.sort_by {|s| s.to_i }.join.to_s.chars.sort_by
    {|s| s.to_i }.join.to_s.chars.sort_by {|s| s.to_i }.join.to_s.chars.sort_by {|s|
    s.to_i }.join.to_s.chars.sort_by {|s| s.to_i }.join.to_s.chars.sort_by {|s| s.to_i
    }.join.to_s.chars.sort_by {|s| s.to_i }.join.to_s.chars.sort_by {|s| s.to_i }.join.to_s.chars.sort_by
    {|s| s.to_i }.join.to_s.chars.sort_by {|s| s.to_i }.join.to_s.chars.sort_by {|s|
    s.to_i }.join.to_s.chars.sort_by {|s| s.to_i }.join.to_s.chars.sort_by {|s| s.to_i
    }.join.to_s.chars.sort_by {|s| s.to_i }.join.to_s.chars.sort_by {|s| s.to_i }.join.to_s.chars.sort_by
    {|s| s.to_i ', "    cipher = ''\n    for letter in s\n        cipher[alphabet.index(letter)\
    \ + 2] += 1\n    return ''.join(cipher[i for i in range(len(alphabet))])", " \
    \ s.tr!('abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n  s.tr!('zyxwvutsrqponmlkjihgfedcba','ZYXWVUTSRQPONMLKJIHGFEDCBA')\n\
    \  s.tr!('nopqrstuvwxyzabcdefghijklm','NOPQRSTUVWXYZABCDEFGHIJKLM')\n  s.tr!('abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n\
    \  return s\nend", "  s.split(\"\").map do |c|\n    a = c.ord\n    b = a.chr\n\
    \    a.chr = (65 - a) % 26 + 65\n    b.chr = (65 - b) % 26 + 65\n    [b, a].join(\"\
    \")\n  end.join \nend", "  # TODO: Encrypt a string.\n  return s", "  result =\
    \ \"\"\n  s.each_byte do |char|\n    result << alphabet.index(char) * 2 \n  end\n\
    \  result\nend", "    alphabet = rotateByTwo(ALPHABET)\n    s = []\n    for i\
    \ in alphabet\n        s << i if s.size % 2 == 0 else s << i.upcase\n    s[s.size/2]\
    \ << alphabet[s.size/2+1].downcase\n    \n    s.join(\"\").tr(\"aeiouAEIOU\",\
    \ \"YZABCDEFGHIJKLMNOPQRSTUVWXYZ\").upcase\nend", "  n = s.length\n  \n  return\
    \ s[((n) % 25)] + s[((n) % 25) + 1]\nend\n</cell>\n<code language=julia-0.4>",
  '  alpha = [nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil,
    nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil,
    nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil,
    nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil,
    nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil,
    nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil,
    nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil,
    nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil,
    nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil,
    nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil,
    nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil,
    nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil,
    nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil,
    nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil,
    nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil,
    nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil,
    nil', "    \n    # Initialize an empty list of letters\n    letters = []\n   \
    \ \n    # Add all the letters in s to letters\n    for letter in s:\n        letters.append(letter)\n\
    \        \n    # Add two more letters into the list that aren't in the alphabet\
    \ yet\n    letters.append(\"a\")\n    letters.append(\"b\")\n    letters.append(\"\
    c\")\n    letters.append(\"d\")\n    letters.append(\"e\")\n    letters.append(\"\
    f\")\n    letters.append(\"g\")\n    letters.append(\"h\")\n    letters.append(\"\
    j\")\n    letters.append(\"k\")\n    letters.append(\"l\")\n    letters.append(\"\
    m\")\n    letters.append(\"n\")\n    letters.append(\"p\")\n    letters.append(\"\
    q\")\n    letters.append(\"r\")\n    letters.append(\"s\")\n    letters.append(\"\
    t\")\n    letters.append(\"v\")\n    letters.append(\"w\")\n    letters.append(\"\
    x\")\n    letters.append(\"y\")\n    letters.append(\"z\")\n    \n    # Initialize\
    \ a second list of letters that will hold all rotated letters\n    rotated_letters\
    \ = []\n    \n    # Loop through letters, appending rotated_letters if they are\
    \ rotated correctly\n    for letter in letters:\n        \n        # If the letter\
    \ is in the alphabet, add it to a rotated_letters list\n        if letter in alphabet:\n\
    \            rotated_letters.append(letter)\n            \n        # If the letter\
    \ is not in the alphabet, subtract one from the alphabet and find which letter\
    \ it was\n        else:\n            letter_index = alphabet.index(letter)\n \
    \           letter_pos = letter_index - 1\n            rotated_letters.append(alphabet[letter_pos])\n\
    \            \n        # Append the rotated_letters list to the rotated_letters\
    \ list at the end\n        rotated_letters += rotated_letters\n        \n    #\
    \ Return the rotated_letters list\n    return rotated_letters", "  result = \"\
    \"\n  for i in range(s.length)\n    result << s[i % alphabet.length]\n  result.downcase!\n\
    \  result\nend\n</cell>\n<code language=julia-0.4>", "  encrypted_string = \"\"\
    \n  alpha = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"\
    u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n  for i in alpha\n    encrypted_string\
    \ += s[i * 2].to_s << 2\n    encrypted_string += s[i * 2 + 1]\n  \n  return encrypted_string\n\
    end", " \n  # Create a variable letters to store a string of all\n  # the letters\
    \ in the alphabet.\n  letters = 'abcdefghijklmnopqrstuvwxyz'\n \n  # Define a\
    \ variable key to be a string of the key length divided by \n  # two followed\
    \ by the character a minus one.\n  key = ''.join(str(len(s)//2)+letters[-int(len(s)%2)-1])\n\
    \ \n  # Define a variable shifted to store a string of the key length divided\
    \ by \n  # two followed by the character a plus one.\n  shifted = ''.join(str(len(s)//2)+letters[int(len(s)%2)+1])\n\
    \ \n  # Define a variable encrypted and to store the encrypted string\n  encrypted\
    \ = \"\"\n \n  # Define a variable i to be equal to 1.\n  i = 1\n \n  # While\
    \ i is less than the length of the string s\n  while i < len(s):\n \n    # Set\
    \ the variable decrypted equal to the string s, where i\n    # has been substracted\
    \ from s\n    decrypted = s[:i]+shifted+s[i+1:]\n \n    # Set the variable shifted\
    \ equal to encrypted\n    shifted = encrypted\n \n    # Increment i by 1\n   \
    \ i += 1\n \n  # Return the value decrypted\n  return decrypted\n ", "  result\
    \ = ''\n  s.each_char { |c| result += alphabet.index(c) * (c.length + 2) }\n \
    \ result\nend\n</code>\n<|/ a tags=ruby,encryption,encryption-symmetric,ruby-on-rails-3\
    \ dscore=1 |>\n<| a dscore=1 tags=ruby,encryption,encryption-symmetric,ruby-on-rails-3\
    \ |>\nHere's a solution I came up with after reading a few of the other answers.\n\
    <code>", "    cipher = []\n    s.chars.each { |c| cipher.push(ROTATE_LETTERS[c])\
    \ }\n    cipher\nend", "  result = ''\n  s.each_char { |c| result += alphabet.chars.rotate(0,\
    \ c).join }\nend", "  s.chars.zip(s.chars[2..-1]).map(&:join).reduce(:+).\n  \
    \  chars.zip(s.chars.reverse.rotate(s.chars.length / 2)\n             .take(s.chars.length\
    \ / 2).map(&:join))\nend\n</code>\n<|/ a tags=ruby,algorithm,encryption |>\n<|\
    \ a dscore=0 |>\nI've found an answer that doesn't involve having to implement\
    \ any functional code but still takes advantage of Ruby's string methods. Here\
    \ it is:\n<code>", "  # Write your code here\n  return \"\"\nend\n</cell>\n<text>\n\
    Test your Code\nRun the cell block below to test your code.", "    alpha = \"\
    abcdefghijklmnopqrstuvwxyz\"\n    # Rotate the alphabet by two places by using\
    \ an index into alpha.\n    alpha.rotate(alpha.index('a')+1)\n    return alpha.rotate(alpha.index('a')+1).rotate(alpha.index('b')+2).rotate(alpha.index('c')+3).rotate(alpha.index('d')+4).rotate(alpha.index('e')+5).rotate(alpha.index('f')+6).rotate(alpha.index('g')+7).rotate(alpha.index('h')+8).rotate(alpha.index('i')+9).rotate(alpha.index('j')+10).rotate(alpha.index('k')+11).rotate(alpha.index('l')+12).rotate(alpha.index('m')+13).rotate(alpha.index('n')+14).rotate(alpha.index('o')+15).rotate(alpha.index('p')+16).rotate(alpha.index('q')+17).rotate(alpha.index('r')+18).rotate(alpha.index('s')+19).rotate(alpha.index('t')+20).rotate(alpha.index('u')+21).rotate(alpha.index('v')+22).rotate(alpha.index('w')+23).rotate(alpha.index('x')+24).rotate(alpha.index('y')+25).rotate(alpha.index('z')+26)\n\
    \    ", "  rev_alphabet = reverse(alphabet)\n  cipher = \"\"\n  s.split(\"\").each\
    \ do |c|\n    cipher += rev_alphabet[(alphabet.index(c) + 2) % 26]\n  end\n  return\
    \ cipher\nend", "  cipher = \"\"\n  for i in 1...s.length\n    cipher << s.charAt((i\
    \ - 1) % 26)\n  end\n  return cipher\nend", "  # Write your code here!\n  n =\
    \ s.length\n  i = 0\n  result = \"\"\n  while (i < n)\n    if s[i] == 'a'\n  \
    \    result = ''\n      i = 0\n      while i < n and s[i] != 'a'\n        result\
    \ += s[i+1]\n        i += 1\n      result += 'a'\n    else \n      result = ''\n\
    \      i = 0\n      while i < n and s[i] != 'a'\n        result += s[i+1]\n  \
    \      i += 1\n      result += 'a'\n    i += 1\n  return result", "  s.split('').inject([])\
    \ do |acc, letter|\n    acc << rotate_letter(letter)\n  end.join\nend", "  s =\
    \ s\n  # s = s.replace(\" \",\"\")\n  # s = s.lower()\n  # s = s.replace(\" \"\
    ,\"\")\n  # print s\n  s = rotate_left(s)\n  s = rotate_right(s)\n  s = rotate_left(s)\n\
    \  s = rotate_right(s)\n  # print s\n  s = insert_character(s)\n  s = insert_character(s)\n\
    \  s = insert_character(s)\n  s = insert_character(s)\n  # print s\n  s = delete_character(s)\n\
    \  s = delete_character(s)\n  s = delete_character(s)\n  s = delete_character(s)\n\
    \  # print s\n  s = delete_character(s)\n  s = delete_character(s)\n  s = delete_character(s)\n\
    \  s = delete_character(s)\n  # print s\n  s = delete_character(s)\n  s = delete_character(s)\n\
    \  s = delete_character(s)\n  s = delete_character(s)\n  # print s\n  s = delete_character(s)\n\
    \  s = delete_character(s)\n  s = delete_character(s)\n  s = delete_character(s)\n\
    \  # print s\n  s = delete_character(s)\n  s = delete_character(s)\n  s = delete_character(s)\n\
    \  s = delete_character(s)\n  # print s\n  s = delete_character(s)\n  s = delete_character(s)\n\
    \  s = delete_character(s)\n  s = delete_character(s)\n  # print s\n  s = delete_character(s)\n\
    \  s = delete_character(s)\n  s = delete_character(s)\n  s = delete_character(s)\n\
    \  # print s\n  s = delete_character(s)\n  s = delete_character(s)\n  s = delete_character(s)\n\
    \  s = delete_character(s)\n  # print s\n  s = delete_character(s)\n  s = delete_character(s)\n\
    \  s = delete_character(s)\n  s = delete_character(s)\n  # print s\n  s = delete_character(s)\n\
    \  s = delete_character(s)\n  s = delete_character(s)\n  s = delete_character(s)\n\
    \  # print s\n  s = delete_character(s)\n  s = delete_character(s)\n  s = delete_character(s)\n\
    \  s = delete_character(s)\n  # print s\n  s = delete_character(s)\n  s = delete_character(s)\n\
    \  s = delete_character(s)\n  s = delete_character(s)\n  # print s\n  s = delete_character(s)\n\
    \  s = delete_character(s)\n  s = delete_character(s)\n  s = delete_character(s)\n\
    \  # print s\n  s = delete_character(s)\n  s = ", "  cipher = []\n  s.each_char\
    \ do |char|\n    index =.index(char)\n    next if index == -1\n    cipher.push\
    \ alphabet[index] + alphabet[index+1]\n  end\n  cipher.join\nend", "  s.split(\"\
    \").map{|c| c.ord % 26 + 2}.map{|c| c.chr }.join\nend", "    alphabet = alphabet\n\
    \    \n    # Start with a copy of our string\n    result = s\n    \n    # Loop\
    \ through each character in the string\n    for character in s\n        \n   \
    \     # Find out how many letters we need to shift down by\n        shift = alphabet.index(character)\n\
    \        shift -= 2\n        \n        # Shift down our copy\n        result +=\
    \ alphabet[shift:] + alphabet[:shift]\n        \n    # Return the result\n   \
    \ return result", "    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    length =\
    \ len(s)\n    if length <= 4:\n        return \"\"\n    else:\n        rotated_string\
    \ = ''\n        alphabet.insert(alphabet.find('z') + 2, 'z')\n        alphabet.insert(alphabet.find('a')\
    \ + 1, 'a')\n        alphabet.insert(alphabet.find('b') + 1, 'b')\n        alphabet.insert(alphabet.find('c')\
    \ + 1, 'c')\n        alphabet.insert(alphabet.find('d') + 1, 'd')\n        alphabet.insert(alphabet.find('e')\
    \ + 1, 'e')\n        alphabet.insert(alphabet.find('f') + 1, 'f')\n        alphabet.insert(alphabet.find('g')\
    \ + 1, 'g')\n        alphabet.insert(alphabet.find('h') + 1, 'h')\n        alphabet.insert(alphabet.find('i')\
    \ + 1, 'i')\n        alphabet.insert(alphabet.find('j') + 1, 'j')\n        alphabet.insert(alphabet.find('k')\
    \ + 1, 'k')\n        alphabet.insert(alphabet.find('l') + 1, 'l')\n        alphabet.insert(alphabet.find('m')\
    \ + 1, 'm')\n        alphabet.insert(alphabet.find('n') + 1, 'n')\n        alphabet.insert(alphabet.find('o')\
    \ + 1, 'o')\n        alphabet.insert(alphabet.find('p') + 1, 'p')\n        alphabet.insert(alphabet.find('q')\
    \ + 1, 'q')\n        alphabet.insert(alphabet.find('r') + 1, 'r')\n        alphabet.insert(alphabet.find('s')\
    \ + 1, 's')\n        alphabet.insert(alphabet.find('t') + 1, 't')\n        alphabet.insert(alphabet.find('u')\
    \ + 1, 'u')\n        alphabet.insert(alphabet.find('v') + 1, 'v')\n        alphabet.insert(alphabet.find('w')\
    \ + 1, 'w')\n        alphabet.insert(alphabet.find('x') + 1, 'x')\n        alphabet.insert(alphabet.find('y')\
    \ + 1, 'y')\n        alphabet.insert(alphabet.find('z') + 1, 'z')\n        alphabet.insert(alphabet.find('a'),\
    \ 'a')\n        alphabet.insert(alphabet.find('b'), 'b')\n        alphabet.insert(alphabet.find('c'),\
    \ 'c')\n        alphabet.insert(alphabet.find('d'), 'd')\n        alphabet.insert(alphabet.find('e'),\
    \ 'e')\n        alphabet.insert(alphabet.find('f'), 'f')\n        alphabet.insert(alphabet.find('g'),\
    \ 'g')\n        alphabet.insert(alphabet.find('h'), 'h')\n        alphabet.insert(alphabet.find('i'),\
    \ 'i')\n        alphabet.insert(alphabet.find('j'), 'j')\n        alphabet.insert(alphabet.find('k'),\
    \ 'k')\n        alphabet.insert(alphabet.find('l", "  s.reverse\n  s = s * 2\n\
    \  s.reverse\n  s\nend", "  if s.count <= 1 \n    return s\n  \n  # Create an\
    \ empty array to hold your encrypted output\n  encrypted = Array.new\n  \n  #\
    \ Create an empty variable to hold the first letter\n  firstLetter = s[0]\n  \n\
    \  # For every letter in the string\n  for i in 1..s.length - 1\n    # Create\
    \ a variable holding the current letter\n    currentLetter = s[i]\n    \n    #\
    \ If the letter has a lower case value\n    if currentLetter >= \"a\" and currentLetter\
    \ <= \"z\"\n      # Move it down the alphabet by 2\n      currentLetter = currentLetter\
    \ + \"a\"\n      \n    # If the first letter is a lowercase letter then move it\
    \ down \n    # by 4\n    if currentLetter == \"a\"\n      currentLetter = \"b\"\
    \n    \n    # If the first letter is uppercase and there are at least 2 letters\n\
    \    # then move it down and then up by 4\n    if currentLetter == \"A\"\n   \
    \   currentLetter = \"b\"\n    \n    # Append the encrypted letter to the encrypted\
    \ array\n    encrypted << currentLetter\n    \n    # If the letter was the first\
    \ letter then move it right by\n    # 1\n    if s[i] == firstLetter\n      currentLetter\
    \ = currentLetter + 1\n    \n    # If the letter was the last letter then move\
    \ it right by\n    # 1\n    if s[i] == s[i - 1]\n      currentLetter = currentLetter\
    \ + 1\n    \n    # If the letter was the second to last letter then move it left\
    \ by\n    # 1\n    if s[i] == s[i - 2]\n      currentLetter = currentLetter -\
    \ 1\n      \n    # If the letter was the penultimate letter then move it left\
    \ by\n    # 1\n    if s[i] == s[i - 3]\n      currentLetter = currentLetter -\
    \ 1\n  end\n  \n  # Return the encrypted array\n  encrypted\nend", "    encrypted_string\
    \ = \"\"\n    s.chars.each{|c| encrypted_string += alphabet.chars.assoc(c)[1]}\n\
    \    return encrypted_string\nend\n</code>\nWe could then use a hash method to\
    \ encrypt our string\n<code>", "  s.split(\"\").each do |x|\n    alphabet[alphabet.index(x)].upcase!\n\
    \  end\nend", "  result = \"\"\n  s_chars = s.split(//)\n  s_chars.each do |char|\n\
    \    result << alpha_rotation(char)\n  end\n  result\nend\n</code>\nFor this solution\
    \ I'm using a Ruby 1.9 Hash as a lookup table. I would recommend using an Array\
    \ instead. I'm using a Hash because I want to be able to do lookups based on a\
    \ key rather than by position. So, for instance, if I wanted to find the letter\
    \ at position 4, I could do it like this:\n<code>\nkeys[4] #=> \"i\"\n</code>\n\
    This makes lookups based on a key a lot easier, but at the expense of more memory\
    \ usage.\nHere's an example of how you could use a Hash:\n<code>\nalphabet = \"\
    abcdefghijklmnopqrstuvwxyz\"\nalphabet = alphabet.split(//)\nalphabet = alphabet.map\
    \ { |char| char.ord }\nalphabet = alphabet.sort_by(&:next)\nalphabet = alphabet.map\
    \ { |char, index| [char + 2, index] }\nalphabet = alphabet.reverse.map(&:first)",
  "  result = ''\n  i = 0\n  while i < s.length\n    char = s[i]\n    i += 1\n   \
    \ result += (letters[char].rotated * 2)\n  end\n  return result\nend", "   \n\
    \    alphabet = (\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"\
    k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"\
    x\",\"y\",\"z\")", "  s.each_byte {|x| rotate(x) }\n  return s\nend", "  alpha\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n  ret = \"\"\n  while s.length > 0\n    ind\
    \ = s.index(alpha[0], 2)\n    ret = ret + (alpha[ind..ind+2].to_s + s[0..ind-1].to_s)\n\
    \    s = s[ind + 2..-1]\n  end\n  ret\nend", "  # Initialize counter to zero.\n\
    \  i = 0", "  alphabet = string.ascii_uppercase\n  alphabet.rotate(2)\n  return\
    \ ''.join(alphabet[i] for i in s)", "  result = ''\n  s.to_s.each_char do |ch|\n\
    \    ch = (ch * 2) - 1 if ch >= 0 && ch < 26\n    result << alphabet.index(ch)\n\
    \  end\n  result\nend", "  result = ''\n  for i in 0...s.length\n     result +=\
    \ alphabet[s.slice(i..).rindex(alphabet)..-1]\n     end\n  result\nend\n</cell>\n\
    <code language=julia-1.6>\ndecrypt = encrypt\nencrypt = decrypt\n</cell>\n<code\
    \ language=julia-1.6>", "  return s.each_char.map{|x| x.ord % 26 + 2}.map{|x|\
    \ x.to_a.map{|z| (z & 1) ? z.shift(2) : z}}.join(\"\")\nend\n</code>\n<|/ a dscore=2\
    \ tags=encryption,ruby |>\n<| c |>\nThat does not work with the example I gave:\
    \ `encrypt.call(\"gf\")` returns `\"j\"`, which is not what you want.\n<|/ c |>\n\
    <| a dscore=2 tags=encryption,ruby |>\nYou can do it with regular expressions.\
    \ \n<code>\ns = \"hi\"", "  str = ''\n  s.each_char do |c|\n    str = str << c\n\
    \    str = str << encrypt[c % 26]\n  end\n  return str\nend", "    alph = alphabet.split(\"\
    \")\n    rev_alph = reverse(alph)\n    \n    return \"\".join(map(lambda x: rev_alph.index(x)\
    \ + 2, s))", "    # Your code here\n    \n    return s\n    ", "  s.each_char\
    \ do |c|\n    next if c < \"a\"\n    next if c > \"z\"\n    yield(c)\n  end\n\
    end", "    cipher = \"\"\n    s.each_byte do |i|\n        cipher += alphabet[(i\
    \ / 2).ceil] + alphabet[i % 2].chr\n    end\n    return cipher\nend", "  result\
    \ = \"\"\n  s.downcase!\n  s.each_char do |c|\n    result << ROTATE_TABLE[ROTATE_TABLE[c]].to_s\n\
    \  end\n  result\nend", "  cipher = []\n  cipher = s.split(\"\")\n  \n  # Encrypt\
    \ the first letter\n  cipher[0] = alphabet[alphabet.index(cipher[0]) + 2]\n  \n\
    \  # If the alphabet is rotated once (e.g ABC to BCA or BA to AB)\n  # then shift\
    \ the letters down\n  while alphabet.index(cipher[0]) == alphabet.index(cipher[1])\
    \ + 1 \n    cipher = cipher[1:] + cipher[:1]", "  alphabet = [\"a\", \"b\", \"\
    c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"\
    n\", \"o\", \"p\"]\n  i = 0\n  j = 0\n  result = []\n  \n  # Add an extra space\
    \ on the front and back of the string\n  # to ensure that the first and last letters\
    \ don't get cut\n  s[0] = \" \"+s[0]\n  s[-1] = \" \"+s[-1]", "    alpha = \"\
    ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    cipher = \"\"", "    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    alpharotation = alphabet.rotate(2)\n    \n    encryptedString = \"\"\n \
    \   \n    for letter in s:\n        newLetter = alpharotation[alphabet.index(letter)]\n\
    \        encryptedString = encryptedString + newLetter\n        \n    return encryptedString",
  "  cipher = encryptor\n  result = ''\n  s.each_char do |c|\n    result += cipher.call(c)\n\
    \  end\n  \n  return result\nend", "    alphabet = [\"a\", \"b\", \"c\", \"d\"\
    , \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\"\
    , \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ]\n    rotated_alphabet = [alphabet[1], alphabet[0], alphabet[4], alphabet[3],\
    \ alphabet[2], alphabet[5], alphabet[6], alphabet[7], alphabet[8], alphabet[9],\
    \ alphabet[10], alphabet[11], alphabet[12], alphabet[13], alphabet[14], alphabet[15],\
    \ alphabet[16], alphabet[17], alphabet[18], alphabet[19], alphabet[20], alphabet[21],\
    \ alphabet[22], alphabet[23], alphabet[24], alphabet[25], alphabet[26], alphabet[27],\
    \ alphabet[28], alphabet[29], alphabet[30], alphabet[31], alphabet[32], alphabet[33],\
    \ alphabet[34], alphabet[35], alphabet[36], alphabet[37], alphabet[38], alphabet[39],\
    \ alphabet[40], alphabet[41], alphabet[42], alphabet[43], alphabet[44], alphabet[45],\
    \ alphabet[46], alphabet[47], alphabet[48], alphabet[49], alphabet[50], alphabet[51],\
    \ alphabet[52], alphabet[53], alphabet[54], alphabet[55], alphabet[56], alphabet[57],\
    \ alphabet[58], alphabet[59], alphabet[60], alphabet[61], alphabet[62], alphabet[63],\
    \ alphabet[64], alphabet[65], alphabet[66], alphabet[67], alphabet[68], alphabet[69],\
    \ alphabet[70], alphabet[71], alphabet[72], alphabet[73], alphabet[74], alphabet[75],\
    \ alphabet[76], alphabet[77], alphabet[78], alphabet[79], alphabet[80], alphabet[81],\
    \ alphabet[82], alphabet[83], alphabet[84], alphabet[85], alphabet[86], alphabet[87],\
    \ alphabet[88], alphabet[89], alphabet[90], alphabet[91], alphabet[92], alphabet[93],\
    \ alphabet[94], alphabet[95], alphabet[96], alphabet[97], alphabet[98], alphabet[99],\
    \ alphabet[100], alphabet[101], alphabet[102], alphabet[103], alphabet[104], alphabet[105],\
    \ alphabet[106], alphabet[107], alphabet[108], alphabet[109], alphabet[110], alphabet[111],\
    \ alphabet[112], alphabet[113], alphabet[114], alphabet[115], alphabet[116], alphabet[117],\
    \ alphabet[118], alphabet[119], alphabet[120], alphabet[121], alphabet[122], alphabet[123],\
    \ alphabet", "  s.reverse!\n  result = ''\n  \n  s.each_byte { |c| \n    result\
    \ << alphabet[((alphabet.index(c) + 1) & alphabet.size)]\n  }\n  \n  result.reverse!\n\
    \  \n  result\nend\n</code>\n<|/ a tags=ruby,encryption |>\n<| c |>\nI thought\
    \ the same thing about decrypting, but then I realized that `encrypt(\"z\")` returns\
    \ `\"aa\"`, and not `\"z\"`.\n<|/ c |>\n<| c |>\nYeah, I forgot about that edge\
    \ case. I think I'd do it a little differently anyways, to make it clear what's\
    \ going on. I'll edit my answer.\n<|/ c |>\n<| a dscore=2 |>\nHere is an implementation\
    \ in Ruby, with comments:\n<code>", "  s.gsub!(/([a-z])/) {|letter| letter.to_i\
    \ + 2 }\n  s.gsub!(/([a-z])/) {|letter| letter.to_i + 2 }\n  s.gsub!(/([a-z])/)\
    \ {|letter| letter.to_i + 2 }\n  s.gsub!(/([a-z])/) {|letter| letter.to_i + 2\
    \ }\n  s.gsub!(/([a-z])/) {|letter| letter.to_i + 2 }\n  s.gsub!(/([a-z])/) {|letter|\
    \ letter.to_i + 2 }\n  s.gsub!(/([a-z])/) {|letter| letter.to_i + 2 }\n  s.gsub!(/([a-z])/)\
    \ {|letter| letter.to_i + 2 }\n  s.gsub!(/([a-z])/) {|letter| letter.to_i + 2\
    \ }\n  s.gsub!(/([a-z])/) {|letter| letter.to_i + 2 }\n  s.gsub!(/([a-z])/) {|letter|\
    \ letter.to_i + 2 }\n  s.gsub!(/([a-z])/) {|letter| letter.to_i + 2 }\n  s.gsub!(/([a-z])/)\
    \ {|letter| letter.to_i + 2 }\n  s.gsub!(/([a-z])/) {|letter| letter.to_i + 2\
    \ }\n  s.gsub!(/([a-z])/) {|letter| letter.to_i + 2 }\n  s.gsub!(/([a-z])/) {|letter|\
    \ letter.to_i + 2 }\n  s.gsub!(/([a-z])/) {|letter| letter.to_i + 2 }\n  s.gsub!(/([a-z])/)\
    \ {|letter| letter.to_i + 2 }\n  s.gsub!(/([a-z])/) {|letter| letter.to_i + 2\
    \ }\n  s.gsub!(/([a-z])/) {|letter| letter.to_i + 2 }\n  s.gsub!(/([a-z])/) {|letter|\
    \ letter.to_i + 2 }\n  s.gsub!(/([a-z])/) {|letter| letter.to_i + 2 }\n  s.gsub!(/([a-z])/)\
    \ {|letter| letter.to_i + 2 }\n  s.gsub!(/([a-z])/) {|letter| letter.to_i + 2\
    \ }\n  s.gsub!(/([a-z", "  return s if s.length < 26 \n    else s.gsub(/.{2}/,\
    \ %w{a e i o u}.map{|s| s.reverse.upcase + s})\nend", "  puts s.chars.collect\
    \ do |c|\n    case\n    when c >= 'a' && c <= 'z'\n      c - 'a' + 2\n    when\
    \ c >= 'A' && c <= 'Z'\n      c - 'A' + 2\n    else\n      c\n    end\n  end.join\
    \ \nend", "  alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n  rotated_alphabet = \"\
    zyxwvutsrqponmlkjihgfedcba\"\n  padded_alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  encrypted_alphabet = \"\"\n  i = 0\n  l = s.length\n  while i < l\n    char\
    \ = alphabet.index(s[i])\n    encrypted_alphabet = encrypted_alphabet + rotated_alphabet[(char\
    \ + 2) % 26]\n    i += 1\n  end\n  return encrypted_alphabet\nend", "  s.chars.map\
    \ { |c| alphabet[alphabet.index(c) + alphabet.length / 2] + alphabet[alphabet.index(c)\
    \ - alphabet.length / 2]}\nend", "  # Get the alphabet\n  alphabet = getAlphabet()",
  "    alpha = string.ascii_lowercase\n    return \"\".join([alpha[(alpha.index(c)\
    \ + (alpha.index(alpha[0])//2)) % len(alpha)] for c in s])", "    # Create a variable\
    \ called encrypted_string that is an empty string \n    # and assign it the empty\
    \ string. \n    encrypted_string = \n    # Loop through each character in the\
    \ string and use each character \n    # in the string as an index in the alphabet\
    \ and add to the encrypted\n    # string a letter that has been chosen from the\
    \ alphabet based \n    # on the character position in the string. \n    for i\
    \ in s\n        encrypted_string += alphabet[i]\n    puts encrypted_string\nend",
  "  return s[0...s.length].rotate(2).map{|c| c.succ}.join(\"\")\nend\n</cell>\n<code\
    \ language=julia-0.6>", "    l = list(s)\n    i = 0\n    while i < len(l):\n \
    \       j = 0\n        while j < (len(l) - 1):\n            k = j + 1\n      \
    \      while k < len(l):\n                l[k] = l[k-1]\n                k +=\
    \ 1\n            j += 1\n        i += 1\n    return \"\".join(l)\n</cell>\n<cell>",
  "  # Implement your logic here\n  s.gsub!(/\\w+/) do |char|\n    # Replace all words\
    \ with letters by subtracting by 2 each\n    # and adding two each time\n    char.downcase.chars.zip(char.downcase.chars).map\
    \ { |x,y| x - 2 * y}.join\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nThanks a lot.\
    \ Your solution is very simple and efficient. Thanks a lot again. I also found\
    \ a simpler solution below, if you don't mind looking at it too.\n<|/ c |>\n<|\
    \ a |>\n<code>", "  l = length(s)\n  alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n  res = []\n  for i in 0 .. l-1\n    index = alphabet.index(s[i])\n    index\
    \ = index + 2\n    index = index if index < 26 else index - 26\n    res.push(alphabet[index])\n\
    \  end\n  res.join(\",\")\nend", "  alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n\
    \  shift = 2\n  result = \"\"\n  for i in s\n    result += alphabet[(alphabet.index(i)\
    \ + shift) % len(alphabet)]\n  return result\n  ", "  return s[0...-1] + s[1...-0]\
    \ * 2\nend", "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    for index, char\
    \ in enumerate(alphabet):\n        if s.count(char) >= 2:\n            return\
    \ char + alphabet[(alphabet.index(char) + 2) % len(alphabet)]\n    return s",
  "  alphabet = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"\
    u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n  rotatedAlphabet = [\"\"] * 26\n  for\
    \ letter in alphabet:\n    rotatedAlphabet[alphabet.index(letter) + 2] = letter\n\
    \    rotatedAlphabet[alphabet.index(letter) + 3] = letter\n  s = alphabet[alphabet.index(alphabet)\
    \ + 1] + s\n  for i in range(0, len(s)):\n    rotatedAlphabet[alphabet.index(s[i])]\
    \ = alphabet[alphabet.index(s[i]) + 1]\n  return rotatedAlphabet[alphabet.index(alphabet)\
    \ + 1] + rotatedAlphabet[alphabet.index(alphabet) + 1] + rotatedAlphabet[alphabet.index(alphabet)\
    \ + 2] + rotatedAlphabet[alphabet.index(alphabet) + 3]\n  ", "    alpha = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    l = len(alpha)\n    r = []\n    for i in alpha:\n        r.append(i.swapcase())\n\
    \    \n    for i in r:\n        if i in s:\n            return i\n    return s\n\
    </cell>\n<cell>\nprint(encrypt.call(\"hi\"))\nprint(encrypt.call(\"asdfghjkl\"\
    ))\nprint(encrypt.call(\"gf\"))\nprint(encrypt.call(\"et\"))\n</cell>\n<cell>",
  "    letters.each do |letter|\n        l = letter.ord.to_s\n        l = l % 26\n\
    \        if l < 10\n            l = \"0\" + l.to_s\n        end\n        l = l.chr\n\
    \        s = s.gsub(letter, l).gsub(letter + l, \"a\")\n    end\n    return s\n\
    end", "  s.split('').zip([nil,nil,nil,nil,nil,nil,nil,nil]).reduce(:zip).reduce(:inject).reduce(:join)\n\
    end", "  return s[(s.size >> 2)::2].gsub(/(.)(.)/) { |s| $1 + $2.rot13 * 2 }\n\
    end", "    s = s.downcase\n    l = s.length\n    alph = (alph_letters.map { |alpha|\
    \ alph.upcase })\n    \n    alpha_index = 0\n    \n    while (alpha_index <= l/2)\n\
    \        alpha_index = alpha_index + 1\n        \n        alpha = alph[alpha_index]\n\
    \        \n        alpha = alph + alph[alpha_index-1].upcase\n    \n        alpha\
    \ = alph + alph[alpha_index-1].upcase\n        \n        alph = alph.dup\n   \
    \     alph = alph.rotate", "  alphabet = ('A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z')\n\
    \  alphabet2 = ('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \  newS = []\n  for x in s:\n    x = x.lower()\n    if x in alphabet:\n      newS.append(alphabet2[(alphabet.index(x)+2)%len(alphabet)])\n\
    \    elif x in alphabet2:\n      newS.append(alphabet[(alphabet2.index(x)+2)%len(alphabet)])\n\
    \    else:\n      newS.append(x)\n  return ''.join(newS)", "  rot_alphabet = rot90(alphabet)\n\
    \  encrypted_string = \"\"\n  s.split(\"\").each do |letter|\n    encrypted_string\
    \ += rot_alphabet[alphabet.index(letter)]\n  end\n  return encrypted_string\n\
    end", "  return s.tr('abcdefghijklmnopqrstuvwxyz','!yuiol')\nend\n</cell>\n<code\
    \ language=julia-0.4>", "    chars = s.chars.to_a\n    chars.map do |char|\n \
    \       return char if char < 'a' or char > 'z'\n        char - 'a' + 2\n    end.join\n\
    end", "  # Convert the string into a list of characters. \n  # A list is a data\
    \ structure that holds values together and \n  # allows them to be accessed by\
    \ their position number\n  lst = list(s)\n  # Find the number of spaces in lst\n\
    \  numspaces = len(lst) - lst.count(\".\")\n  # Find the index of the last character\
    \ in lst\n  lastchar = lst[-1]\n  # Find the index of the first character in lst\n\
    \  firstchar = \".\".join(lst[0:-1])\n  # Find the number of characters to shift\
    \ each letter\n  shift = (numspaces + 1) * 2\n  # Iterate through each letter\
    \ in lst and shift them down \n  # By shift, which is 2 characters multiplied\
    \ to the right \n  # of the last letter in the alphabet\n  for i in range(numspaces):\n\
    \    lst.insert(lst.index(lastchar), lst[lst.index(lastchar) - shift])\n  # Create\
    \ a new list from the list comprehension and join \n  # it back into a string\n\
    \  return \"\".join(lst)", "  s.each_char.map { |c| alphabet.index(c.to_s) + alphabet.index(c.to_s)\
    \ + 2 }.join\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nIt seems you\
    \ only need to encrypt each letter in the string. If so, the following code should\
    \ do the trick:\n<code>\nalphabet = \"abcdefghijklmnopqrstuvwxyz\"", "    alpha\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n    shifted = alpha[-alpha.index(s)] + alpha[alpha.index(s)-2]\
    \ + alpha[alpha.index(s)+2]\n    return shifted", "    alphabet_length = len(alphabet)\n\
    \    alphabet_length_rotated_by_2 = alphabet_length >> 1\n    ciphertext = \"\"\
    \n    \n    # Loop through each character in s going from right to left\n    for\
    \ character in reversed(s):\n        # Check if the character is in the alphabet\
    \ and if it \n        # matches the letter to its right add it else append the\
    \ \n        # character to the ciphertext\n        if character in alphabet:\n\
    \            ciphertext += alphabet[alphabet_length - alphabet_length_rotated_by_2\
    \ + alphabet.index(character)]\n        else:\n            ciphertext += character",
  "  alphabet = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"\
    u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n  string = \"\"\n  for i in s\n    position\
    \ = alphabet.index(s.charAt(i))\n    string = string + alphabet[(position + 2)\
    \ % alphabet.size]\n  end\n  return string\nend", "    s = s.downcase\n    a =\
    \ s.chars.to_a\n    a.rotate!\n    b = a.map { |c| c.chr.toupper_case; c + 2 }.join\n\
    \    b.crypt\nend", "    # Create a list to hold the resulting rotated letters.\n\
    \    letters = []\n    # Loop through the string and add each letter one at a\
    \ time to the list.\n    for letter in s:\n        letters.append(alphabet[(alphabet.index(letter)\
    \ + 2) % len(alphabet)])\n    # Return the resulting string.\n    return ''.join(letters)",
  "    # To start, create a list for holding the alphabet\n    alphabet = [None] *\
    \ 26\n    # Assign the letters in the alphabet a number 0 - 25\n    # For example,\
    \ the letter 'a' would be assigned the number 97\n    for letter in alphabet\n\
    \        # Put the letter in the list for that number\n        # For example,\
    \ 'a' would be assigned the number 97\n        alphabet[alphabet.index(letter)]\
    \ = ord(letter) - 97\n    # Create a loop that iterates 26 times and shifts the\
    \ letters two places down\n    for c in s[::-1]\n        # Call the function rotate\
    \ to rotate the alphabet one step down\n        alphabet = rotate(alphabet)\n\
    \        # Add the encrypted letter to the string\n        s = s + alphabet[alphabet.index(c)]\n\
    \    # Return the encrypted string\n    return s\n</code>\n<|/ a |>\n<| c |>\n\
    It should be noted that the original question does **not** have a specific requirement:\
    \ \"rotates the alphabet two places down\"\n<|/ c |>\n<| c |>\nThanks for your\
    \ comment - I've updated my code to reflect your comment.\n<|/ c |>\n<| a |>\n\
    If you don't want to rotate the alphabet but only change the order of the letters,\
    \ this should be good enough:\n<code>\nimport string", "  result = ''\n  s.each_byte\
    \ { |b| result += alphabet[b] }\n  result + alphabet[alphabet.size-s.bytes.count-2]\n\
    end", "  result = \"\"\n  s.chars.map { |x|\n    result << alphabet[alphabet.index\
    \ x].to_s << alphabet[(alphabet.index x) + 1].to_s\n  }\n  result\nend", "  s.scan(/./)\
    \ {|char| return char.ord + 2}\nend\nputs encrypt(\"hi\")", "  s.chars.map do\
    \ |c| \n    c + 2\n  end.join\nend", "  str = ''\n  s.each_char do |letter|\n\
    \    str += alphabet[alphabet.index(letter)]\n  end\n  str\nend", "    rot = alphabet.index(s[:1])\
    \ + 2\n    s = alphabet[rot:rot+len(s)]\n    s = alphabet[:rot] + s + alphabet[rot+1:]\n\
    \    return s", "    alpha = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\
    \ 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n\
    \    rotated_alpha = alpha[1:len(alpha)] + alpha[0:len(alpha)-1]\n    new_s =\
    \ \"\"\n    \n    for c in s:\n        new_s += rotated_alpha[(alpha.index(c)+len(alpha))%len(rotated_alpha)]\n\
    \    return new_s\n</cell>\n<text>\nLet's try encrypting some strings:", "  result\
    \ = \"\"\n  s.each_char do |c|\n    result << rotate_char(alphabet.index(c)) <<\
    \ c\n  end\n  result\nend", "  s.each_char do |c|\n    c.rotate(2)\n  end\n  s.reverse!\n\
    \  s\nend", "  result = ''\n  for i in 0..s.length - 1\n    result += alphabet.chars.chars.assoc(s(i),\
    \ alphabet.chars.chars)\n  end\n  return result\nend", "  str2 = \"\"\n  for c\
    \ in s\n    str2 << encrypt(c)\n  end\n  str2\nend\n</code>\n<|/ a |>\n<| c |>\n\
    Thanks for the answer, but I'm afraid I still don't get it. Could you explain\
    \ how this would be implemented? I'd really like to understand.\n<|/ c |>\n<|\
    \ c |>\nI added an explanation.\n<|/ c |>\n<| c |>\nOkay, thanks. I'm just now\
    \ getting around to reading through this, and I have the feeling that I haven't\
    \ got it quite right. Could you possibly explain what you mean by \"The alphabet\
    \ should be rotated in a manner such that the letters shift down by two multiplied\
    \ to two places.\"\n<|/ c |>\n<| c |>\nIt means each letter should be rotated\
    \ twice in the alphabet, moving down each letter.\n<|/ c |>\n<| c |>\nOkay, so\
    \ if I've got my words correct, I need to figure out how to rotate the alphabet\
    \ twice for each letter in the word, and then I need to shift each letter one\
    \ to the right each time I run through the loop? Thanks so much for your help\
    \ so far, it's been really helpful.\n<|/ c |>\n<| a dscore=2 tags=ruby |>\nFor\
    \ those that don't know about this trick, here's a straightforward implementation\
    \ (using Ruby's rotate method).\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
