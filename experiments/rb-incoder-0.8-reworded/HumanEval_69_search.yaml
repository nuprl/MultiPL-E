name: HumanEval_69_search
language: rb
prompt: "# You are given a non-empty array of positive integers. Return the greatest\
  \ integer that is greater than \n# zero, and has a frequency greater than or equal\
  \ to the value of the integer itself. \n# The frequency of an integer is the number\
  \ of times it appears in the array.\n# If no such a value exist, return -1.\n# Examples:\n\
  # >>> search.call([4, 1, 2, 2, 3, 1])\n# 2\n# >>> search.call([1, 2, 2, 3, 3, 3,\
  \ 4, 4, 4])\n# 3\n# >>> search.call([5, 5, 4, 4, 4])\n# -1\ndef search(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_search\n\
  \    candidate = method(:search)\n    assert_equal(1, candidate.call([5, 5, 5, 5,\
  \ 1]))\n    assert_equal(4, candidate.call([4, 1, 4, 1, 4, 4]))\n    assert_equal(-1,\
  \ candidate.call([3, 3]))\n    assert_equal(8, candidate.call([8, 8, 8, 8, 8, 8,\
  \ 8, 8]))\n    assert_equal(2, candidate.call([2, 3, 3, 2, 2]))\n    assert_equal(1,\
  \ candidate.call([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10,\
  \ 8, 1]))\n    assert_equal(2, candidate.call([3, 2, 8, 2]))\n    assert_equal(1,\
  \ candidate.call([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]))\n    assert_equal(-1, candidate.call([8,\
  \ 8, 3, 6, 5, 6, 4]))\n    assert_equal(1, candidate.call([6, 9, 6, 7, 1, 4, 7,\
  \ 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]))\n    assert_equal(1,\
  \ candidate.call([1, 9, 10, 1, 3]))\n    assert_equal(5, candidate.call([6, 9, 7,\
  \ 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]))\n    assert_equal(1,\
  \ candidate.call([1]))\n    assert_equal(4, candidate.call([8, 8, 10, 6, 4, 3, 5,\
  \ 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]))\n    assert_equal(2, candidate.call([2,\
  \ 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]))\n    assert_equal(1, candidate.call([1,\
  \ 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]))\n    assert_equal(4, candidate.call([9, 2,\
  \ 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8,\
  \ 10, 9, 4]))\n    assert_equal(4, candidate.call([2, 6, 4, 2, 8, 7, 5, 6, 4, 10,\
  \ 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]))\n    assert_equal(2, candidate.call([9,\
  \ 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]))\n    assert_equal(-1,\
  \ candidate.call([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10,\
  \ 8]))\n    assert_equal(-1, candidate.call([10]))\n    assert_equal(2, candidate.call([9,\
  \ 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]))\n    assert_equal(1, candidate.call([5,\
  \ 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]))\n    assert_equal(1, candidate.call([7, 9, 9,\
  \ 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]))\n    assert_equal(-1,\
  \ candidate.call([3, 10, 10, 9, 2]))\n  end\nend\n"
completions: ["    freq = Hash.new(0)\n    rev = lst.reverse\n    \n    (freq[rev[0]]\
    \ ||= 0).times do |i|\n      freq[i] += 1\n    end\n    \n    (freq[rev[rev.size\
    \ - 1]] ||= 0).times do |i|\n      freq[i] += 1\n    end\n    \n    rev.each {\
    \ |x| freq[x].times { |i| return x if freq[x] > freq[i] } }\n    return -1\nend\n\
    </cell>\n<text>\nThe search() function in part (1) takes a sorted list as input\
    \ and returns the first integer that is greater than zero. The reason it works\
    \ is that the first element in the list is greater than zero.", "  highest = -1\n\
    \  freq = 0", "  freq = Hash.new(0)\n  freq.merge(lst)\n  max_num = 0\n  max_freq\
    \ = -1", "  lst.sort!\n  arr.each { |i| return i if i > 0 && arr[i] >= arr[i-1]\
    \ }\n  -1\nend", "  n = lst.length - 1\n  while n >= 0 do\n    temp = lst[n]\n\
    \    if temp == 0 then\n      return -1\n    end\n    if lst[n] >= temp + 1 then\n\
    \      return temp\n    end\n    n -= 1\n  end\n  return nil\nend\n</code>\n<|/\
    \ a dscore=0 tags=ruby,arrays |>\n<| c |>\nThis doesn't work for this test case:\
    \ `[1, 4, 2, 2, 3, 3, 3, 1, 2, 4, 3, 4, 3, 4, 4, 5]`. Correct output should be\
    \ `5` but your code returns `5`.\n<|/ c |>\n<| c |>\nMy bad. I've updated my answer\
    \ to reflect this. Thanks for noticing!\n<|/ c |>\n<| a tags=ruby,arrays |>\n\
    Here is a short solution with Array#count:\n<code>\narr = [1, 4, 2, 2, 3, 3, 3,\
    \ 1, 2, 4, 3, 4, 3, 4, 4, 5]", "  lst.each do |num|\n    if num.zero?\n      num\
    \ = -1\n    elsif arr.include?(num)\n      num = num\n    elsif arr.size < num\n\
    \      num = -1\n    end\n  end\nend", "    # Write your code here\n    \n   \
    \ \n    \n    \n    return -1\n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n", "  lst.sort.find {|x| x > 0 && (lst.count(x)\
    \ > lst.count(x)) }\nend", "  lst.sort.each do |x|\n    freq = lst.reject { |e|\
    \ e == x }.length\n    if freq >= x\n      return x\n    end\n  end\n  -1\nend\n\
    </code>\n<|/ a tags=ruby,algorithm |>\n<| a dscore=1 |>\n<code>", "  frequency\
    \ = frequency(lst)\n  if frequency >= 0\n    return frequency(lst)\n  else\n \
    \   return -1\nend", "  max_int = nil\n  freq = nil", "    freq, val = 0, lst[0]\n\
    \    for i in 1..lst.length\n        if val > lst[i] && freq < i\n           \
    \ freq = i\n            val = lst[i]\n    return val\nend", "  freq = Hash.new(0)\n\
    \  i = 0\n  while i < lst.size\n    freq[lst[i]] += 1\n    i += 1\n  end", " \
    \ return 0 unless lst.length\n  \n  greatest = lst.find { |v| v >= 0 }\n  return\
    \ -1 if greatest == nil\n  greatest\nend\n</cell>\n<code language=ruby-1.9.3-p448>\n\
    %w[1 2 3 4 5 6 7].grep_v(/\\d/).map(&:to_i)\n</cell>\n<code language=ruby-1.9.3-p448>",
  '  lst.sort.reverse!', "  sorted_lst = lst.sort\n  index = 0\n  while index < sorted_lst.length\n\
    \    if sorted_lst[index] > 0 \n      return sorted_lst[index]\n    index += 1\n\
    \  return -1\nend\n</cell>\n<code language=julia-1.0>", "  lst.each do |i|\n \
    \   return i if i > 0 && freq[i] >= i\n  end\n  return -1\nend", "    freqs =\
    \ frequencies(lst)\n    greatest = -1\n    max = -1\n    \n    for k,v in freqs.iteritems()\n\
    \        if max < k\n            greatest = k\n            max = v\n    return\
    \ greatest\n    ", "  hash = {}\n  arr.each do |i|\n    hash[i] ||= []\n    hash[i]\
    \ << i\n  end\n  hash.each_key do |key|\n    if hash[key].size > arr.size\n  \
    \    hash[key] -= 1\n      return key\n    end\n  end\n  return -1\nend", "  return\
    \ lst.find {|x| x > 0 &&.each {|y| if y > x then return y end}} || -1\nend", " \
    \ lst.sort.each do |x|\n    return x if x > 0 && lst.count(x) >= x\n  end\n  -1\n\
    end\n</code>\nEDIT: As pointed out by, if lst is too large, this solution will\
    \ blow memory. Also, you could modify the search function to take an array instead\
    \ of the individual numbers.\n<|/ a |>\n<| c |>\nThanks so much for the solution.\
    \  I'm wondering if anyone has come up with a more efficient way of solving this.\
    \  I'll be posting this one on the ruby forums as well.  :-)\n<|/ c |>\n<| c |>\n\
    The `each` method calls the `yield` method for each element in the array. It is\
    \ a good solution when you don't need or want to modify the original array (i.e.\
    \ you just want to get the greatest number in the array). The reason I posted\
    \ this is because I felt that it was a good solution for people that were looking\
    \ for a simple solution to a question like this. It didn't really seem like the\
    \ most efficient solution, but then I couldn't think of any way around it.\n<|/\
    \ c |>\n<| c |>\nI added a more efficient solution inspired by yours. It may still\
    \ be better than the others depending on what you are trying to do.\n<|/ c |>\n\
    <| c |>\nThe second one is really awesome because if you're looking for an extremely\
    \ large array, like `[...] * 1000000` it'll be MUCH faster than the first!  Thanks\
    \ for posting this.\n<|/ c |>\n<| c |>\nI'm getting a stack overload error for\
    \ that particular example.  It seems like it might be because I'm running it on\
    \ an array of integers (~15000 elements).\n<|/ c |>\n<| a dscore=3 |>\nI would\
    \ implement it with something like this\n<code>", "  first = first = last = -1\n\
    \  last = first = 0\n  until lst.length < 1 do\n    first = lst.index(first)\n\
    \    last = lst.index(last, first + 1)\n  end\n  lst.each_with_index do |val,\
    \ i|\n    first = i\n    last = i + 1\n    while last < lst.length do\n      last\
    \  = lst.index(last, first + 1)\n      break if (last - first) <= val\n      last\
    \ = last\n    end\n  end\n  if last == lst.length\n    -1\n  else\n    last\n\
    \  end\nend\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| a |>\nThis problem can be\
    \ solved using dynamic programming algorithm. This is a problem about finding\
    \ a sub-sequence in a given array in sorted order in O(n) time.\n<code>", "  if\
    \ lst.empty?\n    return -1\n  end\n  first = lst[0]\n  freq = lst.count(first)\n\
    \  return first if freq > 0\n  freq.times do |i|\n    freq -= lst.count(first,i)\n\
    \    return first if freq == 0\n  end\n  return -1\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a |>\nHere's another solution.\n<code>", "  lst.each {|x| if x > 0 &&\
    \ x > lst.length-1 then return x end}\nend", "  i = 0\n  result = -1\n  while\
    \ i < lst.size - 1\n    if lst[i] > 0\n      result += lst[i]\n      i += 1\n\
    \      break\n    else\n      i += 1\n    end\n  end\n  return result\nend\n</code>\n\
    <|/ a tags=ruby,arrays |>\n<| a dscore=0 |>\n<code>", "  # Your code here\n  if\
    \ lst.count >= 1\n    lst.reject! {|x| x > 0}\n    lst.reject! {|x| x.count >\
    \ lst.count }\n    lst.reduce(0) { |memo, num| memo = num if memo > num}\n  else\n\
    \    -1\n  end\nend", "  return lst.find { |x| x > 0 } if lst.any? \n  -1\nend",
  "  frequency = Hash.new(0)\n  lst.each do |i|\n    frequency[i] += 1\n  end\n  \n\
    \  frequency.keys.each do |i|\n    if frequency[i] >= frequency[frequency.keys[0]]\
    \ \n      return i\n    end \n  end\n  return -1\nend\n</code>\nThis also has\
    \ the advantage of being an O(n) solution, since you're traversing the list only\
    \ once, instead of twice.  If you were looking for multiple elements, you can\
    \ simply remove the if block which checks if frequency[i] >= frequency[frequency.keys[0]]\
    \ and simply run a loop to find all elements whose frequency is greater than or\
    \ equal to the value of the element you're looking for.\n<|/ a tags=arrays,ruby,hash\
    \ dscore=1 |>\n<| c |>\n`frequency.keys.each do |i| if frequency[i] >= frequency[frequency.keys[0]]\
    \ return i end end` can be `frequency.each do |k, v| return k if (v > frequency[k])\
    \ end`.\n<|/ c |>\n<| c |>\nYeah, that's true, but that won't work if there's\
    \ more than one element that satisfies `frequency[i] >= frequency[frequency.keys[0]]`.\
    \  So I think it's better to keep the original solution and just modify the OP's\
    \ code to work for multiple elements.\n<|/ c |>\n<| c |>\nI think you misunderstood.\
    \ OP wants to get the first matching element, so your solution returns _any_ element\
    \ with the minimum frequency.\n<|/ c |>\n<| c |>\nThe OP's description is \"Return\
    \ the greatest integer that is greater than zero, and has a frequency greater\
    \ than or equal to the value of the integer itself. If no such a value exist,\
    \ return -1.\" which is consistent with the code.  However, I will clarify.\n\
    <|/ c |>\n<| c |>\nMy reading of the code was that OP was asking for the _first_\
    \ matching element with a given frequency, but you are returning _any_ element\
    \ with the minimum frequency.\n<|/ c |>\n<| a |>\nYou could use Enumerable#min_by\
    \ with a block:\n<code>", "  lst.sort!\n  freq = Hash.new(0)\n  for i in 0..(lst.length-1)\n\
    \    freq[lst[i]] += 1\n    break if freq[lst[i]] > 0\n    freq[lst[i]]\n  return\
    \ -1\nend\n</pre>\n</div>\n</div>\n</div>\n  \n<div class=\"cell border-box-sizing\
    \ text_cell rendered\"><div class=\"prompt input_prompt\">\n</div><div class=\"\
    inner_cell\">\n<div class=\"text_cell_render border-box-sizing rendered_html\"\
    >\n<h2 id=\"Search-the-array-with-a-given-value\">Search the array with a given\
    \ value<a class=\"anchor-link\" href=\"#Search-the-array-with-a-given-value\"\
    >&#182;</a></h2>\n</div>\n</div>\n</div>\n  \n<div class=\"cell border-box-sizing\
    \ text_cell rendered\"><div class=\"prompt input_prompt\">\n</div><div class=\"\
    inner_cell\">\n<div class=\"text_cell_render border-box-sizing rendered_html\"\
    >\n<p>A faster way to get to the array is to use a binary search. Here is a binary\
    \ search to search for an item in the array:</p>", "  # Write your code here\n\
    \  return lst.sort[-1] if lst.reduce(0) > 0 then -1 else nil\nend\n</cell>\n<cell>",
  "  return find_max( lst, lst.uniq, lst.size )\nend", "  lst.each_with_index do |x,\
    \ i|\n    return i if x > 0 and frequency(lst) > x\n  end\n  return -1\nend",
  "  result = -1\n  frequency = {}\n  for i in lst\n    if frequency.has_key? i \n\
    \      frequency = frequency.merge({i => frequency[i] + 1 })\n    else\n     \
    \ frequency[i] = 1\n  end\n  frequency.values.max\nend", "  lst = lst.sort\n \
    \ if lst.length == 0 || lst.last == 0\n    return -1\n  freq = Hash.new(0)\n \
    \ for i in 0..(lst.last-1)\n    freq[i] = freq[i].succ\n  end\n  greatest = nil\n\
    \  greatest_freq = -1\n  for i in 0..(lst.last-1)\n    if freq[i].succ == freq[i]\n\
    \      if freq[i] > greatest_freq\n        greatest = i\n        greatest_freq\
    \ = freq[i]\n      end\n    end\n  end\n  if greatest == nil\n    return -1\n\
    \  end\n  return greatest\nend", "  lst.sort! { |a, b| b - a }\n  for i in 1..(lst.size\
    \ - 1)\n    return i if lst[i] >= lst[i-1]\n  end\n  return -1\nend", "  lst.sort.each\
    \ do |i|\n    if i == 0\n      max_val = i\n      max_freq = 1\n    else\n   \
    \   if i > max_val\n        max_val = i\n        max_freq = 1\n      else\n  \
    \      max_freq += 1\n      end\n    end\n  end", "  freq = freq_table lst\n \
    \ if freq > 0\n    freq.keys.max\n  else \n    -1\nend\n</code>\n<|/ a tags=ruby,algorithm,search,arrays\
    \ dscore=1 |>\n<| c |>\nWhile this is interesting, it is not an answer, but a\
    \ comment.\n<|/ c |>\n<| a |>\nThis question appears to be a homework question,\
    \ so I will give you a hint to get you started:", "    ans = 0\n    freq = {}\n\
    \    lst.each do |x|\n        freq[x] ||= 1\n        freq[x] += 1\n    end\n \
    \   freq.each do |key, value|\n        if value > ans\n            ans = key\n\
    \        end\n    end\n    return ans if ans > 0\n    return -1\nend", "  sum\
    \ = 0\n  for i in 0 ... lst.size\n    if sum > 0 then sum = sum + lst[i]\n   \
    \ elsif sum > 0 and sum < lst[i]\n      sum = sum - lst[i]\n    end\n  end\n \
    \ sum\nend", "  lst.sort.map { |x| x > 0 ? x : -1 }.reject { |i| i == -1 }.first\n\
    end", "  lst.each do |x|\n    if freq[x]\n      if freq[x] >= x\n        return\
    \ x\n      end\n    end\n  end\n  -1\nend\n        ", "    lst = lst.sort.to_a\n\
    \    return lst.detect {|x| x > 0 }.next\nend", "  # Write your code here.\n \
    \ return nil unless lst.length >= 1\n  freq = Hash.new(0)\n  lst.each { |n| freq[n]\
    \ += 1}\n  freq.max_by {|k,v| -v if v}\nend", "  \nend", "  return lst.max{|a,\
    \ b| b if(b >= a.freq)}\nend\n</code>\n<|/ a |>\n<| c |>\nI believe this should\
    \ be `lst.max{|a, b| b if(b >= a.freq)}` without the final curly bracket.\n<|/\
    \ c |>\n<| c |>\n, you are correct. The example in the question was for Ruby,\
    \ but in Ruby 1.9.3 it works without that final bracket. My mistake.\n<|/ c |>\n\
    <| c |>\n`lst.max{|a, b| b if(b >= a.freq)} ||` => `lst.max { |a, b| b if b >=\
    \ a.freq }`\n<|/ c |>\n<| a dscore=5 |>\nIn Ruby 2.1.0:\n<code>", "  lst.sort\n\
    \  lst.each_with_index do |e, i|\n    return -1 if i > lst.size\n    if lst.include?(e)\n\
    \      lst.delete_at(i)\n      lst.delete_at(i) if lst.count(e) > 1\n      lst.delete_at(i)\
    \ if lst.count(e) == 1\n    end\n  end\n  nil\nend", "    l = lst.select { |e|\
    \ e > 0 }.max\n    freq = lst.select { |e| e == l }.count\n    (freq > 0 || -1)\
    \ if freq.positive?\n  end\nend\n</code>\nThis implementation assumes that each\
    \ element in the array is unique. Also, I found this to be the fastest implementation\
    \ I could think of:\n<code>", "  lst.sort_by! { |x| x }\n  lst.each_with_index\
    \ do |x, i|\n    return i if x > 0 && frequency(lst) == i\n  end\n  -1\nend",
  "  lst.sort.reverse_each do |x|\n    return x if x > 0 && (frequencies [x]) >= x\
    \ \n  end\n  -1\nend", "    greatest, max_occurrences = lst[0], 0\n    \n    until\
    \ max_occurrences > 0\n        greatest, max_occurrences = lst.pop.pop, lst.count\n\
    \    \n    greatest\nend\n</cell>\n<code language=julia-1.3>", "  arr.map!{|x|\
    \ x.to_i}\n  arr.delete_if {|x| x == 0} if arr.empty?\n  arr.delete_if {|x| x\
    \ == a} if arr.empty?\n  max = arr.max\n  arr.delete_if {|x| x == max} if arr.empty?\n\
    \  arr.delete_if {|x| x == max - 1}  if arr.empty?\n  arr.delete_if {|x| x ==\
    \ max - 2}  if arr.empty?\n  arr.delete_if {|x| x == max - 3}  if arr.empty?\n\
    \  arr.delete_if {|x| x == max - 4}  if arr.empty?\n  max = arr.max\n  arr.delete_if\
    \ {|x| x == max} if arr.empty?\n  arr.delete_if {|x| x == max - 1}  if arr.empty?\n\
    \  arr.delete_if {|x| x == max - 2}  if arr.empty?\n  arr.delete_if {|x| x ==\
    \ max - 3}  if arr.empty?\n  arr.delete_if {|x| x == max - 4}  if arr.empty?\n\
    \  max = arr.max\n  arr.delete_if {|x| x == max} if arr.empty?\n  arr.delete_if\
    \ {|x| x == max - 1}  if arr.empty?\n  arr.delete_if {|x| x == max - 2}  if arr.empty?\n\
    \  arr.delete_if {|x| x == max - 3}  if arr.empty?\n  arr.delete_if {|x| x ==\
    \ max - 4}  if arr.empty?\n  max = arr.max\n  arr.delete_if {|x| x == max} if\
    \ arr.empty?\n  arr.delete_if {|x| x == max - 1}  if arr.empty?\n  arr.delete_if\
    \ {|x| x == max - 2}  if arr.empty?\n  arr.delete_if {|x| x == max - 3}  if arr.empty?\n\
    \  arr.delete_if {|x| x == max - 4}  if arr.empty?\n  max = arr.max\n  arr.delete_if\
    \ {|x| x == max} if arr.empty?\n  arr.delete_if {|x| x == max - 1}  if arr.empty?\n\
    \  arr.delete_if {|x| x == max - 2}  if arr.empty?\n  arr.delete_if {|x| x ==\
    \ max - 3}  if arr.empty?\n  arr.delete_if {|x| x == max - 4}  if arr.empty?\n\
    \  max = arr.max\n  arr.delete_if {|x| x == max} if arr.empty?\n  arr.delete_if\
    \ {|x| x == max - 1}  if arr.empty?\n  arr.delete_if {", '  return -1 unless lst',
  "  lst.sort.reverse!\n  frequency = freq = 0\n  for x in lst\n    freq += 1\n  \
    \  if x != 0 && (frequency += x > x)\n      break\n  end\n  if frequency > 0 \n\
    \    freq\n  else\n    -1\n  end\nend", "    arr.sort.with_index { |e, i| arr[i]\
    \ = e }\n    arr.find { |e| e >= 0 }\nend", "  lst.sort.each_with_index { |number,\
    \ index| return (number if number > 0 and index + 1 >= lst.length) || (-1 if number\
    \ == 0) }\nend", "  lst.each do |x|\n    if x > 0 && lst.count(x) >= x\n     \
    \ return x\n    end\n  end\n  return -1\nend\n</code>\n<|/ a dscore=0 tags=search,ruby,arrays\
    \ |>\n<| a dscore=0 tags=search,ruby,arrays |>\n<code>", "  freq = Hash.new(0)\n\
    \  (0...lst.length).each do |i|\n    freq[i] = freq[i] + 1 \n  end\n  res = freq.max\n\
    \  res.nil? ? -1 : freq.find { |k, v| v >= res }.last\nend", "  lst.map!{ |x|\
    \ x == 0 ? nil : x }\n  lst.sort.find{ |x| x > 0 }.last\nend", "  lst.each_with_index\
    \ do |e, i|\n    break if i > lst.length-1\n    if e == lst[i+1]\n      lst[i]\n\
    \    end\n  end\nend\n</code>\n<|/ a dscore=1 tags=ruby,arrays |>\n<| c |>\n`Array.new`\
    \ will give a _new_ array each time, so `find` will return the first value found.\n\
    <|/ c |>\n<| c |>\nYes, this would give me the first value that is greater than\
    \ zero, but if I want it to give me the greatest value that is greater than zero,\
    \ how would I do that?\n<|/ c |>\n<| c |>\n, I updated the answer with solution\
    \ for both of your requirements\n<|/ c |>\n<| c |>\nYou might also add that `each_with_index`\
    \ is a method of the `Enumerable` module which is part of the Ruby standard library:\
    \ `Array.new.method(:each_with_index).owner` -> `Enumerable`\n<|/ c |>\n<| a dscore=1\
    \ tags=ruby,arrays |>\n<code>", "  lst.sort.each_with_index do |element, index|\
    \ \n    return index if element >= index\n  end\n  -1\nend", "  lst.each do |i|\n\
    \    index = -1\n    arr.each do |j|\n      if j > 0 and arr[j] == i\n       \
    \ index = j\n        break\n      end\n    end\n    if index > -1\n      freq[index]\
    \ -= 1\n      if freq[index] <= 0\n        return index\n      end\n    end\n\
    \  end\n  return -1\nend", "  lst.each_with_index { |e, i| return i if i > 0 &&\
    \ e.to_i >= 0 && e >= lst[i] }\n  -1\nend", "  max_val = (lst.index(-1) + 1) \n\
    \  max_freq = lst[lst.index(-1) + 1]\n  for i in (max_val..lst.length)\n    if\
    \ lst[i] > max_val\n      max_val = i\n      max_freq = lst[i]\n    end\n  end\n\
    \  return max_val if max_freq >= max_val else -1\nend", "  lst.uniq.each do |value|\n\
    \    if value == 0 then\n      return -1\n    elsif lst.count { |x| x > value\
    \ } >= value then\n      return value\n    end\n  end\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a |>\n<code>", "  freq = Hash.new\n  lst.each_with_index do |n, i|\n\
    \    freq[n] = freq.fetch(n, 0)+1 if !freq.has_key?(n)\n  end\n  freq.each do\
    \ |k, v|\n    next if v < 0\n    return k if v == freq[k]\n  end\n  return -1\n\
    end\n</code>\n<|/ a tags=ruby dscore=1 |>\n<| a dscore=0 tags=ruby |>\n<code>\n\
    arr = [4,1,2,2,3,1]", "  lst.each do |x|\n    break if lst.count(x) <= x\n  end\n\
    \  lst.count\nend", "  lst.each do |x|\n    if x.to_i >= 0\n      if lst.count(x)\
    \ >= x.to_i\n        return x.to_i\n      end\n    end\n  end\n  -1\nend", " \
    \ lst.inject(:+)\n  arr.max { |a, b| a.succ == b ? a.succ : -1 }\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails,algorithm |>\n<| a dscore=0 |>\n<code>\nl = [4,\
    \ 1, 2, 2, 3, 1]\nl.sort { |a,b| a.succ==b ? a.succ : -1 }[-1]\n</code>\n<|/ a\
    \ tags=ruby,ruby-on-rails,algorithm |>\n<| c |>\n`sort` runs in `O(n log n)` time\
    \ so this is actually `O(n lg n)` which is slower than `greatest_freq` which runs\
    \ in `O(n)`.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,algorithm |>\nHere you go:\n\
    <code>", "  # Your code here\n  \n  n = lst.length\n  freq = Hash.new(0)\n  for\
    \ i in 0..n-1\n    freq[lst[i]] += 1\n  end\n  \n  for i in freq\n    if freq[i]\
    \ > 0 and freq[i] >= freq[lst[0]]\n      return i\n    end\n  end\n  -1\nend",
  "  return lst.max{|x, y| x > y ? x : (x > 0 ? y : 1) == x}\nend\n</code>\nRuby 2\n\
    <code>", "  arr = arr.sort.reverse\n  i = 0\n  while i < arr.length\n    if arr[i]\
    \ >= arr[i+1]\n      arr[i] = arr[i+1] - 1\n      arr[i+1] = arr[i+1] + 1\n  \
    \  else\n      break\n    i += 1\n  end\n  if arr.length == 0\n    return -1\n\
    \  end\n  arr[0]\nend", "  \n  sorted_array = lst.sort\n  \n  sorted_array.each\
    \ do |num|\n    if sorted_array.include?(num)\n      break\n    end\n  end\n \
    \ \n  sorted_array.count((sorted_array.find_index(num)+1)..-1)\nend\n</cell>\n\
    <cell>", "  lst.each_with_index.reduce(0) {|sum, (x, index)| sum if x > sum or\
    \ (x == sum && index > sum) ? x : -1}\nend", "  lst = lst.sort\n  \n  first =\
    \ lst[0]\n  second = first\n  freq = 0\n  \n  for i in lst\n    if i.first !=\
    \ first.first\n      second = first\n      first = i\n      freq = first.freq\n\
    \    \n    freq += 1\n    \n    if freq >= second.freq\n      return second.first\n\
    \    \n  return -1\nend", "  lst.sort\n  i = 1\n  while i < lst.size\n    if lst[i]\
    \ <= 0\n      break\n    else\n      i +=1\n  end\n  if i == lst.size\n    return\
    \ -1\n  end\n  return i\nend", "  lst.each_with_index { |e, i| break i if e <=\
    \ 0 }\n  -1 if lst.empty?\n  lst.group_by { |e| e }.max_by { |k, v| v }[1]\nend\n\
    </cell>\n<code language=conda-env-data-science-py>\n@test search([0]) == -1\n\
    @test search([-3]) == 1\n@test search([0, -2, -3, 0, 1, 2]) == 3\n@test search([1,\
    \ 3, 1, 2, 1]) == 1\n@test search([3, 4, 5, 4, 1]) == -1\n@test search([4, 5,\
    \ 1]) == -1\n@test search([5, 4, 4, 1]) == -1\n</cell>\n<code language=conda-env-data-science-py>",
  "    \n    # Solution \n    ret = -1\n    \n    # Solution \n    for i in 0..(lst.size\
    \ - 1)\n        if lst[i] == 0\n            ret = i\n            break\n    \n\
    \    if ret != -1\n        return ret\n    \n    \n    # Solution \n    for i\
    \ in 0..(lst.size - 1)\n        if lst[i] > lst[ret]\n            ret = i\n  \
    \          break\n    \n    return ret", "    freq = Hash.new(0)\n    i = 0\n\
    \    while i < lst.size do\n        num = lst[i]\n        freq[num] += 1\n   \
    \     i += 1\n    end", "  lst.uniq.each do |x|\n    return x if x > 0 \n    return\
    \ -1 if x == 0\n    x -= 1\n    break if x > 0\n  end\nend", "  n = lst.size\n\
    \  min_val = nil\n  max_val = nil\n  min_freq = nil\n  max_freq = nil", "  arr.each\
    \ do |i|\n    if arr[i] >= 0\n      if arr[i] >= arr[i-1]\n        arr[i] -= 1\n\
    \      else\n        arr[i] = -1\n        return arr[i-1]\n      end\n    end\n\
    \  end\n  return -1\nend\n</cell>\n<code language=julia-1.5>\n@assert search([1])\
    \ == -1 \n@assert search([4, 1, 2, 2, 3, 1]) == 2\n@assert search([4, 1, 2, 2,\
    \ 3, 2]) == 3\n@assert search([5, 5, 4, 4, 4]) == -1\n</cell>\n<text>\n5. Find\
    \ the minimum element in a given array.", "    min = nil\n    max = nil", "  \
    \  return lst.max_by {|x| x > 0}\nend", "    first = first = nil\n    last = last\
    \ = nil\n    freq = freq = freq = nil\n    freq = freq = 0\n    freq = freq =\
    \ freq = nil\n    freq = freq = freq = nil\n    freq = freq = freq = nil\n   \
    \ freq = freq = freq = nil\n    freq = freq = freq = nil\n    freq = freq = nil\n\
    \    freq = freq = freq = nil\n    freq = freq = freq = nil\n    freq = freq =\
    \ nil\n    freq = freq = freq = nil\n    freq = freq = nil\n    freq = freq =\
    \ freq = nil\n    freq = freq = freq = nil\n    freq = freq = freq = nil\n   \
    \ freq = freq = freq = nil\n    freq = freq = freq = nil\n    freq = freq = freq\
    \ = nil\n    freq = freq = freq = nil\n    freq = freq = nil\n    freq = freq\
    \ = nil\n    freq = freq = nil\n    freq = freq = nil\n    freq = freq = nil\n\
    \    freq = freq = nil\n    freq = freq = nil\n    freq = freq = nil\n    freq\
    \ = freq = nil\n    freq = freq = nil\n    freq = freq = nil\n    freq = freq\
    \ = nil\n    freq = freq = nil\n    freq = freq = nil\n    freq = freq = nil\n\
    \    freq = freq = nil\n    freq = freq = nil\n    freq = freq = nil\n    freq\
    \ = freq = nil\n    freq = freq = nil\n    freq = freq = nil\n    freq = freq\
    \ = nil\n    freq = freq = nil\n    freq = freq = nil\n    freq = freq = nil\n\
    \    freq = freq = nil\n    freq = freq = nil\n    freq = freq = nil\n    freq\
    \ = freq = nil\n    freq = freq = nil\n    freq = freq = nil\n    freq = freq\
    \ = nil\n    freq = freq = nil\n    freq = freq = nil\n    freq = freq = nil\n\
    \    freq = freq = nil\n    freq = freq = nil\n    freq = freq = nil\n    freq\
    \ = freq = nil\n    freq = freq = nil\n    freq = freq = nil\n    freq = freq\
    \ = nil\n    freq = freq = nil\n    freq = freq = nil\n    freq = freq = nil\n\
    \    freq = freq = nil\n    freq = freq = nil\n    freq", "  lst.map {|x| x}.reduce(:>=)\n\
    end\n</cell>\n<text>\nExercise 7: Implement a function that returns the largest\
    \ item in a non-empty array. You should use recursion to solve this problem. Hint:\
    \ You will need a helper function that takes an integer and returns the biggest\
    \ integer that is less than or equal to the input.", "  freq = Hash.new(0)\n \
    \ max_val = 0\n  max_freq = -1\n  \n  lst.each do |i|\n    freq[i] += 1\n    \n\
    \    if freq[i] > max_freq \n      max_val = i\n      max_freq = freq[i]\n   \
    \ end\n  end", "  return lst.inject(0) { |sum, el| sum + el if sum + el > 0 }.max\n\
    end", "  lst.sort.each do |i|\n    if i.zero?\n      -1\n    elsif lst.count(i)\
    \ >= i.to_s\n      lst.count(i)\n    else\n      -1\n    end\n  end\nend\n</cell>\n\
    <cell>", "  lst.sort!\n  lst.reverse!\n  freq = []\n  result = 0\n  i = 0\n  while\
    \ i < lst.size\n    if freq[lst.index(i)] >= lst.index(i)\n      result += 1\n\
    \    else\n      result -= 1\n    end\n    i += 1\n  end\n  return result < 0\
    \ ? -1 : result\nend", "  lst.sort.reverse\n  arr.each do |i|\n    return i if\
    \ i == 0 || i > lst.count\n  end\n  return -1\nend\n</code>\n<|/ a tags=ruby,arrays,search,algorithm\
    \ |>\n<| a tags=ruby,arrays,search,algorithm dscore=0 |>\nHere is a solution that\
    \ is a bit more efficient than the others provided here because it is much less\
    \ code, and also it doesn't mutate the original array (by creating a new array\
    \ of the same length). Also it only iterates through the array once to find where\
    \ the item is and then iterates again to search for the rest of the items:\n<code>",
  "  max = -1\n  frequency = Hash.new(0)\n  lst.each do |x|\n    frequency[x] += 1\n\
    \    if frequency[x] > max\n      max = frequency[x]\n    end\n  end\n  max\n\
    end", "    return lst.index(max(lst)) + 1\nend", "  lst.each_with_index {|number,\
    \ i| return i if number == 0} if lst.size > 0\n  -1\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nI like the idea of using each_with_index to find the maximum element.\
    \ However, I don't think this will work as you expect because each_with_index\
    \ will return the index of the first element and will not find the largest element.\
    \ Instead of finding the index, you should use each_cons to find two elements,\
    \ then find the maximum element by comparing the second elements frequency to\
    \ that of the first.\n<|/ c |>\n<| c |>\nI edited my solution to add an each_cons\
    \ implementation. I think this may be a better approach than your each_with_index\
    \ solution.\n<|/ c |>\n<| a tags=ruby,arrays |>\nAs you say you need to find the\
    \ max occurrence of an element in the array so you can first create an object\
    \ containing the element and its frequency by iterating through the array then\
    \ use inject to find the max occurrence:\n<code>", "  min = lst[0]\n  max = lst[0]\n\
    \  for i in 1..lst.count\n    if lst[i] > max\n      max = lst[i]\n    if lst[i]\
    \ < min\n      min = lst[i]\n  end\n  \n  if min == max\n    return -1\n  else\n\
    \    return min if (min <= max)\n    return -1\n  end\nend\n</cell>\n<code language=julia-1.0>",
  "    arr = lst.sort\n    first = arr.first\n    last = arr.last\n    count = arr.count\n\
    \    max = 0\n    i = -1\n    while count > 0 and (count == max or count > arr[i])\n\
    \        max = count\n        i = i ? i : i\n        count = arr[i]\n    end\n\
    \    if count == 0 and arr[i] != 0\n        return -1\n    else\n        return\
    \ max ? arr[i] : i\n    end\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\n\
    <code>", "  result = -1\n  lst.each_with_index do |e, i|\n    if result < 0 &&\
    \ i > 0 && e > 0 && lst.count(e) >= i\n      result = e\n    end\n  end\n  result\n\
    end", "  return lst.max{|x| x if x.to_i > 0}.to_i unless lst.nil?\n  -1\nend\n\
    </code>\n<|/ a |>\n<| c |>\n`return lst.max{|x| x.to_i if x.to_i > 0} unless lst.nil?`\n\
    <|/ c |>\n<| c |>\nOr the shorter `return lst.max { |x| x.to_i } unless lst.nil?`\n\
    <|/ c |>\n<| c |>\n: that's not necessarily better.  It will fail with a nil array\
    \ if the array contains integers and returns nil for empty arrays.\n<|/ c |>\n\
    <| c |>\n: Good catch, I forgot about that possibility, will update.\n<|/ c |>\n\
    <| c |>\nThanks for the great answer! Your solution is very elegant and efficient.\n\
    <|/ c |>\n<| a |>\nIf you don't need a generic solution (ie. if the elements in\
    \ the array are of a simple type such as strings), you can use the Ruby method\
    \ Array#max, as in \n<code>\nif arr.max { |a, b| a.to_i > b.to_i } \n  # Do something\
    \ here\nend\n</code>\n<|/ a dscore=5 tags=ruby,arrays |>\n<| c |>\nI like that.\
    \ Simple, elegant, and does the job.\n<|/ c |>\n<| c |>\nI find this the best\
    \ answer, since it does nothing if the array is empty.\n<|/ c |>\n<| c |>\nThis\
    \ is the answer that worked for me. Thank you!\n<|/ c |>\n<| a |>\nHere is a solution\
    \ that uses the Enumerator class to implement a lazily evaluated max function\
    \ which can return -1 for an empty array:\n<code>", "  return lst.select { |e|\
    \ e >= 0 }.max || -1\nend\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| a dscore=0\
    \ tags=ruby |>\nMy Ruby solution is this:\n<code>\narray.inject(0) do |memo, num|\n\
    \  memo.zero? ? memo : (num - memo) if num > memo\nend\n</code>\n<|/ a |>\n<|\
    \ a |>\n<code>", "  lst.each do |i|\n    break if lst.count(i) > i\n  end\n  nil\
    \ if lst.count < 1\n  lst.find { |i| i } + 1\nend\n</cell>\n<cell>", "    i =\
    \ 0\n    while i < lst.count(\"0\")\n        i += 1\n    if i < lst.count(\"0\"\
    )\n        puts i\n    else\n        puts -1\n    end\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThanks for the quick reply Jonathan. I was able to figure out the solution\
    \ to my problem, however, I wasn't able to understand the code you wrote. I tried\
    \ running it on my code, but I was not able to understand how you went about finding\
    \ the solution. Could you please help me understand how to approach this problem\
    \ from scratch? Thanks\n<|/ c |>\n<| c |>\nThe first time through the loop you\
    \ find an entry with `count(\"0\")`. That puts `i` where it should be, but if\
    \ you look at `i` closely, it's still `0` because `i` is incremented until `count(\"\
    0\")` is false. The second time through the loop you find an entry with `count(\"\
    0\")`. That puts `i` where it should be, but if you look at `i` closely, it's\
    \ still `1` because `i` is incremented until `count(\"0\")` is false. You keep\
    \ going through your loops until you run out of items in the list.\n<|/ c |>\n\
    <| a tags=ruby |>\nI guess this does it:\n<code>", "  result = -1\n  frequency\
    \ = {}\n  l = lst.count\n  frequency.default = l\n  frequency.default_proc = ->(lst.count)\n\
    \  frequency.nil = frequency.default\n  frequency.each_with_index do |value, index|\n\
    \    frequency[value] = frequency == value ? l : frequency - value + 1\n  end\n\
    \  frequency.values.find do |value|\n    frequency[value] >= 0\n  end == 0 ? result\
    \ : -1\nend\n</cell>\n<code language=conda-root-py>", '  lst.sort!', "  lst.sort.each_with_index\
    \ do |n,i|\n    next unless n.zero?\n    return i if n.even?\n  end\n  return\
    \ -1\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>", "  (0..(lst.length-1)).each\
    \ do |i|\n    if lst[i] > 0 && lst[i] >= lst[i-1]\n      return lst[i]\n    end\n\
    \  end\n  -1\nend", "  lst.sort\n  freq = 0\n  res = 0\n  freq = lst.inject(0)\
    \ do |acc, i|\n    acc += 1 if lst.include? i\n    acc\n  end\n  if freq > 0\n\
    \    res = freq.times {|x| lst.count}.max if freq > lst.count\n  end\n  res\n\
    end", "  lst.each_with_index do |elem, idx| \n    if elem.zero?\n      return\
    \ -1 if idx >= lst.size - 1 \n      return idx if idx == lst.size - 1 \n    end",
  "  lst.each do |x|\n    arr.each do |y|\n      if y == x\n        puts x\n     \
    \ end\n    end\n  end\nend", "  arr = lst.inject(Hash.new){ |h,e| h.update(e=>1)}.values.reverse_each.sort\n\
    \  arr.find { |x| x > 0 } || -1\nend\n</cell>\n<text>\nThis solution passes all\
    \ of the tests, except the following:", "  \n  # Get the greatest integer greater\
    \ than zero and greater than or equal to the value of each number.\n  greatest\
    \ = []\n  greatest.push(-1 until lst.count { |i| i > 0 })", "    lst = lst.sort\n\
    \    low = 0\n    high = lst.size - 1\n    \n    while low <= high\n        mid\
    \ = low + math.ceil(low / 2)\n        if lst[mid] > lst[mid + 1]\n           \
    \ low = mid + 1\n        else\n            high = mid - 1\n    end\n    \n   \
    \ if low == high\n        low\n    elsif lst[low] > lst[high]\n        low\n \
    \   else\n        high\n    end\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=0\
    \ |>\nHere is an answer using only mathematics.  It may or may not be the best\
    \ solution, but it is pretty close to what your original question was asking.\n\
    <code>", "  sorted_lst = lst.sort.to_a\n  return(sorted_lst.length > 0 &&\n  \
    \      sorted_lst.first >= 0 &&\n        sorted_lst.last  >= 0 &&\n        sorted_lst.count\
    \ >= sorted_lst.last.to_i &&\n        sorted_lst.select {|x| x > 0 }.max > sorted_lst.first)\n\
    end\n</code>\n<|/ a dscore=3 |>\n<| a |>\nThis is my solution:\n<code>", "  arr=[]\n\
    \  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n\
    \  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n\
    \  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n\
    \  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n\
    \  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n\
    \  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n\
    \  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n\
    \  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n\
    \  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n\
    \  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n\
    \  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n\
    \  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n\
    \  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n\
    \  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n\
    \  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n\
    \  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n\
    \  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n\
    \  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n\
    \  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n\
    \  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n\
    \  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n  arr.push(lst[0])\n\
    \  arr.push(lst", "  return -1 if lst.empty? or lst.size == 1 or (lst.size !=\
    \ lst.uniq.size && lst.uniq.empty?) \n  freq = lst.frequency(lst.uniq.last) \n\
    \  return lst.uniq.last if freq == lst.uniq.size || lst.uniq.last.zero? && freq\
    \ >= freq.to_i\n  val = lst.uniq.last.to_f - freq.to_f \n  lst.delete_all { |i|\
    \ i > val }\nend\n</code>\n<|/ a dscore=2 tags=ruby,arrays |>\n<| a |>\n<code>",
  "  freq = lst.inject(Hash.new){ |h, e| h[e] += 1 }.values.max || -1\n  freq > 0\
    \ ? freq.max : -1\nend", "  n = lst.length\n  sum = 0\n  max.push(n,-1)\n  count.push(n,0)",
  "    freqs = frequencies_hash(lst)\n    greatest = nil\n    greatest_num = -1\n\
    \    greatest_freq = -1\n    \n    freqs.each do |key, value|\n        if value\
    \ > greatest_freq\n            greatest_num = key\n            greatest_freq =\
    \ value\n        elsif value == greatest_freq\n            greatest_freq += 1\n\
    \        end\n    end\n    greatest\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\n<code>", "    min = -1\n    max = -1\n    freq = -1\n    for i in range(len(lst)):\n\
    \        if lst[i] >= max:\n            max = lst[i]\n            min = lst[i]\n\
    \        if lst[i] >= min and lst[i] == max:\n            freq += 1\n        \
    \    if freq >= min:\n                min = lst[i]\n    return min\n</cell>\n\
    <text>\nBacktracking Search\nYou are given a non-empty array of positive integers.\
    \ A search for a value should begin from the leftmost position \nof the array,\
    \ moving to the rightmost position in the array. If no such value exists, return\
    \ -1.\nThe search begins by going forward in the array, from the first position\
    \ (index 0) to the last position (index \nlength\u22121), wrapping around to the\
    \ beginning if the position in the array is equal to the length of the array.\
    \ If this \nposition exists in the array, return the value of the array. If there\
    \ is no such position in the array, return -1.\nThe algorithm should take linear\
    \ time in the worst case. There are several possible values of index i such that\
    \ \narr[i] >= 0, for all i \u2265 0.\nThe first possible index is 0 (because a\
    \ 0 is always greater than or equal to any positive integer). \nThe second possible\
    \ index is length\u22121, because a positive integer is always greater than or\
    \ equal to the length of the array.\nThe third possible index is i if arr[i] <\
    \ 0, for all \u2212i \u2264 0 \u2264 i. \nAfter wrapping around to index 0, the\
    \ entire array is sorted. \nWrite a function to perform a backtracking search\
    \ on a given array, and return its value if found else return -1.\nExample\nFor\
    \ inputArray = [1, 6, 3, 5], backtrackingSearch(inputArray) should return 5, since\
    \ it is the greatest \ninteger that appears in inputArray and appears at least\
    \ as frequently as the number itself.", "  index = 0\n  freq = 0\n  greatest_freq\
    \ = -1\n  while index < lst.length\n    freq += 1\n    if freq > greatest_freq\n\
    \      greatest_freq = freq\n    end\n    if lst[index] > 0\n      index += 1\n\
    \    else\n      index -= 1\n    end\n  end\n  if greatest_freq < 0\n    greatest_freq\
    \ = freq\n  end\n  return greatest_freq\nend", "  lst.each do |x|\n    return\
    \ x if x > 0 \n  end\n  -1\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThe OP explicitly\
    \ stated that they cannot use loops. That's why your solution is wrong.\n<|/ c\
    \ |>\n<| a tags=ruby,sorting |>\n<code>", "  lst.sort\n  return lst.find {|x|\
    \ (lst.count(x)>=x) } if lst.any? {|x| (lst.count(x)>=x) }\n  -1\nend", "  return\
    \ lst.find { |x| x > 0 && frequencies?(x) >= x } if lst.length > 0\n  return -1\n\
    end", "  lst.each do |number|\n    num = number\n    return num unless freq[num]\
    \ >= number\n  end\n  return -1\nend\n</code>\n<|/ a tags=ruby |>\n<| a |>\n<code>",
  "  lst.sort.each_index do |i|\n    return i if lst[i] <= 0\n    return -1 if i ==\
    \ lst.size && lst[i] > 0\n    return i if i < (lst.size % 2) ? lst[i] : search([lst[i],\
    \ *lst.slice[i+1..-1]])\n  end\n  return -1\nend\n</cell>\n<cell>", "    freq\
    \ = {}\n    freq.update(lst.group_by{|x| x}.each{|x| x.last})\n    freq.each{|k,\
    \ v| if freq[k] >= v.last}\n    return freq.keys.min\nend", "    freq=Hash.new(0)\n\
    \    arr=[]\n    arr.push(lst[0])\n    arr.push(lst[1])\n    arr.push(lst[2])\n\
    \    arr.push(lst[3])\n    arr.push(lst[4])\n    arr.push(lst[5])\n    arr.push(lst[6])\n\
    \    arr.push(lst[7])\n    arr.push(lst[8])\n    arr.push(lst[9])\n    arr.push(lst[10])\n\
    \    arr.push(lst[11])\n    arr.push(lst[12])\n    arr.push(lst[13])\n    arr.push(lst[14])\n\
    \    arr.push(lst[15])\n    arr.push(lst[16])\n    arr.push(lst[17])\n    arr.push(lst[18])\n\
    \    arr.push(lst[19])\n    arr.push(lst[20])\n    arr.push(lst[21])\n    arr.push(lst[22])\n\
    \    arr.push(lst[23])\n    arr.push(lst[24])\n    arr.push(lst[25])\n    arr.push(lst[26])\n\
    \    arr.push(lst[27])\n    arr.push(lst[28])\n    arr.push(lst[29])\n    arr.push(lst[30])\n\
    \    arr.push(lst[31])\n    arr.push(lst[32])\n    arr.push(lst[33])\n    arr.push(lst[34])\n\
    \    arr.push(lst[35])\n    arr.push(lst[36])\n    arr.push(lst[37])\n    arr.push(lst[38])\n\
    \    arr.push(lst[39])\n    arr.push(lst[40])\n    arr.push(lst[41])\n    arr.push(lst[42])\n\
    \    arr.push(lst[43])\n    arr.push(lst[44])\n    arr.push(lst[45])\n    arr.push(lst[46])\n\
    \    arr.push(lst[47])\n    arr.push(lst[48])\n    arr.push(lst[49])\n    arr.push(lst[50])\n\
    \    arr.push(lst[51])\n    arr.push(lst[52])\n    arr.push(lst[53])\n    arr.push(lst[54])\n\
    \    arr.push(lst[55])\n    arr.push(lst[56])\n    arr.push(lst[57])\n    arr.push(lst[58])\n\
    \    arr.push(lst[59])\n    arr.push(lst[60])\n    arr.push(lst[61])\n    arr.push(lst[62])\n\
    \    arr.push(lst[63])\n    arr.push(lst[64])\n    arr.push(lst[65", "    greatest\
    \ = 0\n    freq = { lst[0] => 0 }\n    \n    if lst.size == 1\n        greatest\
    \ = lst[0]\n    elsif lst.size >= 2\n        greatest = lst[1]\n    \n    freq.each\
    \ do |k, v|\n        if v > 0\n            freq[k] = v - 1\n            if k >\
    \ greatest\n                greatest = k\n            end\n        end\n    end\n\
    \    \n    if greatest == 0\n        return -1\n    end\n    \n    greatest\n\
    end\n</cell>\n<code language=julia-0.6>\nsearch(search([4, 1, 2, 2, 3, 1]))\n\
    </cell>\n<code language=julia-0.6>\nsearch(search([5, 5, 4, 4, 4]))\n</cell>\n\
    <code language=julia-0.6>\nsearch(search([5, 5, 4, 4, 5]))\n</cell>\n<text>\n\
    Exercise: Remove duplicates\nIn a previous exercise, you implemented a function\
    \ that removed duplicates from an unsorted array. You were asked to modify it\
    \ so that it can also remove duplicates from a partially sorted array. Your implementation\
    \ should also handle non-existent values (such as 0 and NaN values). In other\
    \ words, it should not fail on non-existent array elements.", "  max = -1\n  freq\
    \ = nil\n  for i in lst.to_a\n    freq = freq || { i => 0 }\n    freq.each do\
    \ |k, v|\n      if v >= i\n        max = i\n        break\n      end\n    end\n\
    \  end\n  return max\nend\n</code>\n<|/ a tags=ruby,algorithm |>\n<| c |>\nO(log\
    \ n) is `lst.max_by { |x| -x }`. This runs in O(n) because you're sorting all\
    \ n numbers.\n<|/ c |>\n<| c |>\nYour solution has two bugs. `freq = freq || {\
    \ i => 0 }` doesn't work as you expect it to. It sets freq to `nil`. The `each_with_object`\
    \ solution has a similar bug: When `freq` is `nil`, you do `freq.each do |k, v|`,\
    \ which sets `k` to `0`. Then you do `freq.each_with_object({}) do |(k, v), g|`\
    \ which sets k to `0` again, and so on.\n<|/ c |>\n<| c |>\n: I rewrote my answer\
    \ and I didn't realise that `freq` was a hash.\n<|/ c |>\n<| a dscore=3 |>\nSince\
    \ no one has posted a solution yet, here's one. This uses each_cons to get all\
    \ the odd numbers from an array and puts them in an array for easy removal with\
    \ pop and then a comprehension to do the rest:\n<code>\narr = %w[a b c d e f g\
    \ h i j k l m n o p q r s t u v w x y z]\narr.each_cons(2).select { |a,b| b %\
    \ 2 == 1 }.pop.max_by { |a| arr.count(a) }", "  n = lst.size\n  i = 0\n  while\
    \ i < n do\n    if lst[i] == 0 then return -1 # No such value\n    i = i + 1\n\
    \  end = n\n  while end > i do\n    if lst[i] > 0 then return i # Greater than\
    \ zero\n    i = i - 1\n    end = end - 1\n  end # return -1\nend\nprint search([5,\
    \ 4, 4, 6])\nprint search([4, 1, 2, 2, 3, 1])\nprint search([1, 2, 2, 3, 3, 3,\
    \ 4, 4, 4])\nprint search([5, 5, 4, 4, 4])\nprint search([5, 1, 2, 3, 4])\nprint\
    \ search([4, 1, 2, 2, 3, 1])\n</cell>\n<text>\nQuestions 6", "  freq, val = 0,\
    \ lst[0]\n  lst.each{|e| freq += 1}\n  freq.upto(val){|i|\n    if freq[i] >= val\n\
    \      return i\n    end\n  }\n  return -1\nend", "  for i in 0...lst.size\n \
    \   if lst[i] > 0 and\n        ( frequency(lst, i) >= lst[i] )\n      return i\n\
    \  end\n  return -1\nend", "  return -1 if lst.empty? || lst.size <= 1 \n  mid\
    \ = lst.size / 2\n  freq = lst.to_a.select { |x| x >= mid }.length\n  max_number\
    \ = lst.to_a.select { |x| x >= mid }.max\n  max_number > 0 ? max_number : search([mid]\
    \ + lst.to_a)\nend", "  lst.each_with_index {|x, i| return i if x > 0 && freq[x]\
    \ >= freq[i] if freq[x] > 0 }\n  return -1\nend", "  lst.each do |i|\n    if lst.count\
    \ > 0 and lst.count > i\n      return i\n    end\n  end\n  -1\nend", "  if lst.empty?\
    \ \n    return -1\n  else\n    lst.sort!\n    freq = lst.each_with_index.inject(Hash.new(0))\
    \ do |freq, (element, index)| \n      freq[element] +=1\n      freq\n    end\n\
    \    frequency = freq.values.last\n    return frequency.to_i if frequency >= frequency[0].to_i\
    \ \n    search(lst.drop(1))\nend\n</cell>\n<cell>\narr = [4, 1, 2, 2, 3, 1]\n\
    search([1, 2, 2, 3, 3, 3, 4, 4, 4])\n</cell>\n<cell>\narr = [5, 5, 4, 4, 4]\n\
    search([1, 2, 2, 3, 3, 3, 4, 4, 4])\n</cell>\n<cell>\narr = [4, 1, 2, 2, 3, 1]\n\
    search([1, 2, 3, 4, 5])\n</cell>\n<cell>\narr = [5, 5, 4, 4, 4]\nsearch([1, 2,\
    \ 3, 4, 5])\n</cell>\n<cell>\narr = [1, 2, 3, 4, 5]\nsearch([1, 2, 3, 4, 5])\n\
    </cell>\n<cell>\narr = [1, 3, 3, 4, 5]\nsearch([1, 2, 3, 4, 5])\n</cell>\n<cell>\n\
    arr = [5, 5, 4, 4, 4]\nsearch([1, 2, 3, 4, 5])\n</cell>\n<cell>\narr = [5, 5,\
    \ 4, 4, 4]\nsearch([1, 2, 3, 4, 5])\n</cell>\n<cell>\narr = [5, 4, 4, 4]\nsearch([1,\
    \ 2, 3, 4, 5])\n</cell>\n<cell>\narr = [5, 4, 4, 4]\nsearch([1, 2, 3, 4, 5])\n\
    </cell>\n<cell>\narr = [1, 2, 3, 4, 5]\nsearch([1, 2, 3, 4, 5])\n</cell>\n<cell>\n\
    arr = [1, 2, 3, 4, 5]\nsearch([1, 2, 3, 4, 5])\n</cell>\n<cell>\narr = [1, 2,\
    \ 3, 4, 5]\nsearch([1, 2, 3, 4, 5])\n</cell>\n<cell>\narr = [1, 2, 3, 4, 5]\n\
    search([1, 2, 3, 4, 5])\n</cell>\n<cell>\narr = [1, 2, 3, 4, 5]\nsearch([1, 2,\
    \ 3, 4, 5])\n</cell>\n<cell>\narr = [1, 2, 3, 4, 5]\nsearch([1, 2, 3, 4, 5])\n\
    </cell>\n<cell>\narr = [1, 2, 3, 4, 5]\nsearch([1, 2, 3, 4, 5])\n</cell>\n<cell>\n\
    arr = [1, 2, 3, 4, 5]\nsearch([1, 2, 3, 4, 5])\n</cell>\n<cell>\narr = [1, 2,\
    \ 3, 4, 5]\nsearch([1, 2, 3, 4, 5])\n</cell>\n<cell>\narr = [1, 2, 3, 4, 5]\n\
    search([1, 2, 3, 4, 5])\n</cell>\n<cell>\narr = [1, 2, 3, 4, 5]\nsearch([1, 2,\
    \ 3, 4, 5])\n</cell>\n<cell>\narr = [1, 2, 3, 4, 5]\nsearch([1, 2, ", "  lst.sort.each_index{|i|\
    \ return i if lst[i] > 0 }\n  \n  if lst.empty?\n    return -1\n  end\n  \n  search_value\
    \ = lst.first\n  \n  lst.each_index{|i| lst.delete_at(i if lst[i] == search_value\
    \ && lst.first < lst[i] && lst[i] < search_value && search_value < lst[lst.length-1]\
    \ })\n  \n  lst.sort.each_index{|i| return i if lst[i] > 0 }\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| a dscore=0 tags=algorithm,ruby |>\nHere is a way to find the\
    \ first occurrence of a value in an array:\n<code>", "  lst.reduce(:+)\nend\n\
    </cell>\n<code language=julia-0.4>\nfunction myFunc(arr::Array)\n  freq = arr.reduce(:+)\n\
    \  for n in arr\n    if n > 0\n      break\n    end\n  end\n  n\nend\n</cell>\n\
    <code language=julia-0.4>\nmyFunc(arr::Array)\n</cell>\n<code language=julia-0.4>\n\
    myFunc(arr::Array) = search(arr)\n</cell>\n<code language=julia-0.4>\narr = [4,\
    \ 1, 2, 2, 3, 1]\n</cell>\n<code language=julia-0.4>\nmyFunc(arr)\n</cell>\n<code\
    \ language=julia-0.4>\narr = [1, 2, 2, 3, 3, 3, 4, 4, 4]\n</cell>\n<code language=julia-0.4>\n\
    myFunc(arr)\n</cell>\n<code language=julia-0.4>\narr = [5, 5, 4, 4, 4]\n</cell>\n\
    <code language=julia-0.4>\nmyFunc(arr)\n</cell>\n<code language=julia-0.4>\narr\
    \ = [-1, 5, 5, 4, 4, 4]\n</cell>\n<code language=julia-0.4>\nmyFunc(arr)\n</cell>\n\
    <text>\nPart 2", "  arr = lst.sort.map { |i| i }\n  index = arr.index { |i| i\
    \ >= 0 && arr.count(i) > 1 }\n  return -1 if index.nil?\n  arr[index]\nend", " \
    \ # write your code here\n  lst.map!{|x| x > 0 ? x : 1} \n  lst.map!{|x| x > lst.count(x)\
    \ ? (lst.count(x) + x) : x }\n  lst.count('1') + -1\nend", "    \n    sorted_lst\
    \ = lst.sort { |a, b| b <=> a }\n    \n    freq_hash = {}\n    \n    sorted_lst.each\
    \ do |n|\n        freq_hash[n] ||= 0\n        freq_hash[n] += 1\n    end\n   \
    \ \n    max_freq = -1\n    \n    sorted_lst.each do |n|\n        if freq_hash[n]\
    \ > max_freq\n            max_freq = freq_hash[n]\n        end\n    end\n    \n\
    \    max_freq > 0 ? max_freq : -1\nend\n</code>\n<|/ a tags=ruby,loops,arrays\
    \ |>\n<| c |>\nWow, thank you for putting the effort into explaining what you\
    \ did. That makes it very easy to read. I think I understand it now, and I've\
    \ learned a lot more by looking at your example and understanding how it works.\n\
    <|/ c |>\n<| c |>\nYou're welcome.\n<|/ c |>\n<| c |>\nI was just wondering if\
    \ anybody was able to explain the last line. Would there be any advantage to this\
    \ method? I'm still pretty new to programming, and while I understand the code,\
    \ the last line is confusing to me.\n<|/ c |>\n<| c |>\nIt's just the ternary\
    \ operator `max_freq > 0 ? max_freq : -1`. Just like `if` statement, `?:` is called\
    \ ternary operator. If `max_freq > 0` is true, the left hand side value is returned.\
    \ Otherwise, right hand side value is returned. See http://www.tutorialspoint.com/ruby/ruby_operators.htm\n\
    <|/ c |>\n<| a tags=ruby,loops,arrays dscore=0 |>\n<code>\nmax_freq = 0", "  \
    \  # Your code here\n    l = -1\n    count = 0\n    for i in lst\n        count\
    \ += 1\n        if i > 0 and count >= i\n            l = i\n            count\
    \ = 1\n    \n    return l", "  # Your code here\n  return -1\nend", "  if lst.empty?\n\
    \    return -1\n  else\n    max_val = lst.max\n    if max_val == 0\n      return\
    \ -1\n    else \n      lst.uniq.each do |i|\n        if i > max_val\n        \
    \  return max_val\n        end\n      end\n    end\n  end\nend\n</code>\n<|/ a\
    \ tags=arrays,ruby,algorithm |>\n<| c |>\nWhy not `return max_val` if `max_val\
    \ == 0`? You never actually need the `each` loop to return -1 when `max_val ==\
    \ 0`.\n<|/ c |>\n<| c |>\nYes, you're right. I just did that just to show the\
    \ general idea\n<|/ c |>\n<| a |>\nThis would be the solution in Ruby\n<code>",
  "    i = 0\n    j = -1\n    max = lst[0]\n    freq = 0", "  i = 0\n  max = 0\n \
    \ while i < lst.size\n    if lst[i] >= 0 && lst[i] >= max\n      max = lst[i]\n\
    \    i += 1\n  return max\nend", "  arr = lst.each_with_object(Hash.new(0)) {\
    \ |x, h| h[x] += 1 }\n  arr.find { |k,v| v > 0 && arr[k] >= v }[1] || -1\nend\n\
    </code>\n<|/ a |>\n<| a tags=ruby dscore=1 |>\nI thought this was the simplest\
    \ way to do it\n<code>", "  if lst.empty? then return -1\n  el = lst[0]\n  freq\
    \ = lst.length - 1\n  for i in 2..lst.length\n    if el == lst[i] then\n     \
    \ freq -= 1\n    el = lst[i]\n  el == lst[freq] and return freq\n  return -1\n\
    end", "  return -1 if lst.empty? \n  return lst.find { |i| i.zero? ? false : i.reduce(&:+).gteq(0)\
    \ }\nend\n</cell>\n<code language=conda-env-exelis-ruby-py>\narr = [4, 1, 2, 2,\
    \ 3, 1]\nsearch(arr)\n</cell>\n<text>\nFind the maximum and minimum of a stack\
    \ of values\nGiven a stack of positive integers, return the maximum value in the\
    \ stack and the minimum value in the stack.\nFor an empty stack return [-1, -1].",
  "  return find_max_in_array(lst) if lst.size > 0 else -1\nend", "  lst.sort.each\
    \ do |e|\n    break if e == 0\n    break if e == -1\n    break if e > -1\n  end\n\
    \  return e\nend", "  n = lst.length\n  max_count = 1\n  max_index = 0", "  lst.sort.each_with_index\
    \ { |e, i| return i if e > 0 }.last rescue -1\nend\n</code>\nThe each_with_index\
    \ method returns an enumerator with the elements of\nthe collection passed to\
    \ it and the index they are at. Thus, the sort \nmethod should be called on lst\
    \ before being able to access the elements in the array. \nSince we know that\
    \ there will always be an element greater than 0, the index is \nsimply the index\
    \ of the first element greater than 0. Then, since we know that the array is \n\
    sorted, the last method call on the enumerator will return the index of the last\
    \ element \ngreater than 0 in the array.\n<|/ a dscore=0 |>\n<| c |>\nYour code\
    \ has a few syntax errors.  Firstly, the OP doesn't need to return the enumerator.\
    \  `each_with_index` returns a Enumerator, so you can simply use the `last` method.\
    \  Secondly, the OP's problem was that the OP wanted to return an `int`.  Your\
    \ code returns `Enumerator`, which I believe is incorrect.\n<|/ c |>\n<| c |>\n\
    Thank you, I will add this information to the answer and explain why `last` can\
    \ be used. I will also explain how `each_with_index` returns an enumerator.\n\
    <|/ c |>\n<| c |>\nI realized I misread the question.  You do want to return an\
    \ int, so this answer won't work.  However, I believe my answer still answers\
    \ OP's original question.  I'm adding this comment so that people don't downvote\
    \ the correct answer.\n<|/ c |>\n<| c |>\nYour code doesn't return `int`.  It\
    \ returns `Enumerator`.  My code returns `int`.  The OP's code returns `int`.\
    \  However, I believe my code answers OP's original question.  I also believe\
    \ that your answer is still the correct answer.  However, I believe my answer\
    \ to be unnecessarily complex.  It could easily be done with one or two lines\
    \ of code.\n<|/ c |>\n<| c |>\nIt answers OP's original question, even though\
    \ OP does not really state that he wants an `int`.  I'm explaining why that is\
    \ the case.\n<|/ c |>\n<| a |>\nThis is an implementation using Enumerator and\
    \ Enumerable methods:\n<code>", "  lst.sort.each do |x|\n    return x if x > 0\
    \ && x.to_i > 0\n  end\n  -1\nend", "  highest = -1\n  highest_count = 0\n  for\
    \ i in lst\n    if i > highest\n      highest = i\n      highest_count = 0\n \
    \   else \n      highest_count += 1\n    end\n  end\n  return highest\nend", " \
    \   hash = Hash.new(lst)\n    hash.each do |k,v|\n        if v < 0\n         \
    \   return -1\n        elsif v == 0\n            return k\n        end\n    end\n\
    \    return -1\nend", "  return lst.map {|x| x.reduce(:+) if x.size > 0}.reduce(:>)\
    \ if lst.map(&:size).reduce(:>=) > -1\n  -1\nend", "  greatest = nil\n  greatest_frequency\
    \ = nil\n  lst.each_with_index do |value, index|\n    if value.zero? or value\
    \ < greatest\n      greatest = value\n      greatest_frequency = 1\n    elsif\
    \ value == greatest and value > greatest_frequency\n      greatest_frequency =\
    \ value\n    end\n  end\n  greatest == -1 ? nil : greatest\nend\n</code>\nThis\
    \ is not as fast as O(n*lgn) but it's still faster than O(n) since we only need\
    \ to iterate over the list once.\n<|/ a dscore=0 tags=ruby,algorithm |>\n<| a\
    \ tags=ruby,algorithm dscore=0 |>\nThe algorithm you implemented uses nested loops\
    \ which is O(n^2) complexity. Using Hash data structure would be more efficient.\
    \ You can improve the performance by changing your algorithm to use hash tables.\n\
    <code>", "    greatest = -1\n    freq = 0\n    \n    # loop through the array\n\
    \    for i in lst\n        # check if the value exists\n        if freq >= i\n\
    \            # increment the frequency and update the greatest integer\n     \
    \       freq += 1\n            if freq > greatest\n                greatest =\
    \ i\n        end\n    end\n    \n    return greatest\nend", "  max_val = 0\n \
    \ max_val_idx = -1\n  frequencies = frequency(lst)\n  \n  frequency_size = frequencies.length\n\
    \  \n  frequency_index = 0\n  \n  while (frequency_index < frequency_size)\n \
    \   # Find the largest integer greater than or equal to the current \n    # frequency\
    \ value.\n    \n    frequency_value = frequencies[frequency_index]\n    \n   \
    \ # If the new frequency value is greater than the current frequency \n    # value,\
    \ increment the frequency index to find the next value.\n    \n    if (frequency_value\
    \ > frequency_val)\n      frequency_index += 1\n    \n    # If the new frequency\
    \ value is less than the current frequency \n    # value, set the current frequency\
    \ value to the new frequency \n    # value and increment the frequency index to\
    \ find the next value.\n    \n    else\n      frequency_val = frequency_value\n\
    \      frequency_index += 1\n      \n    # Set the highest frequency value to\
    \ the current frequency value, \n    # and set the highest frequency index to\
    \ the current frequency index.\n    \n    if (frequency_value > max_val)\n   \
    \   max_val = frequency_value\n      max_val_idx = frequency_index\n    end\n\
    \  end\n  \n  # Return the highest frequency value that is greater than zero.\n\
    \  \n  return max_val\nend", "  arr.map{|x| if x > 0\n            arr.select {|y|\
    \ y >= x}\n            arr.size\n          elsif x == 0\n            -1\n    \
    \      elsif arr.size == 0\n            -1\n          else\n            -1\n \
    \       end}\nend", "  i = lst.index(-1)\n  frequency = lst.length\n  while i\
    \ > 0\n    i = i - 1\n    frequency = frequency + 1\n  \n  if frequency > lst.last\n\
    \    return -1\n  else \n    return frequency\nend\n</cell>\n<code language=julia-1.3>",
  "  if lst.length == 0\n    return -1\n  max_val = max_freq = lst[0]\n  for i in\
    \ 1..lst.length\n    if lst[i] == max_val\n      max_freq += 1\n      \n     \
    \ return max_freq\n    else\n      if max_freq > lst[i] || max_freq == lst[i]\n\
    \        max_val = lst[i]\n        max_freq = lst[i]\n      else\n        max_freq\
    \ = max_freq\n  return -1\nend", "\tsorted = lst.sort\n\tmax_value = sorted.last\n\
    \tmin_value = sorted.first\n\twhile max_value-min_value>0\n\t\tbreak if sorted.last==0\n\
    \t\tmax_value = sorted.last\n\t\tmin_value = sorted.first\n\twhile sorted.last==0\n\
    \t\tmin_value = sorted.first+1\n\twhile sorted.first==sorted.last\n\t\tmin_value\
    \ = sorted.first+1\n\treturn min_value\nend\n\t\t", "    return lst.inject(0)\
    \ { |s, i| s + lst.count(i) if (i > 0 && lst.count(i) >= i) }\nend", "    freqs\
    \ = Array.new(0)\n    freqs.concat(lst.count)\n    return freqs.max{|a, b| (a\
    \ >= b) ? (a > 0 ? a : -1) : (b > 0 ? b : -1)}\nend", "  lst.each_with_index {\
    \ |n,i| return n if n > 0 && freq[n] >= freq[i] }\n  -1\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=arrays,ruby |>\nMy solution to find the maximum element of an\
    \ array is as follows. \n<code>\nmax_num = arr.max\nmax_num.downto(max_num.first)\
    \ do |num|\n  if num.last < max_num.last\n    max_num = num\n  end\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=arrays,ruby |>\n<code>", "  lst.each_with_index {\
    \ |x, i| return i if x > 0 } # find first index bigger than 0\n  return -1 if\
    \ lst.size == 0 # if no such value is in the array\n  lst.each_with_index { |x,\
    \ i| return i if x == lst[0] } # find first index equal to first value\n  return\
    \ -1 if lst.size == 0 # if no such value is in the array\n  lst.each_with_index\
    \ { |x, i| return i if x == lst[0] && x > lst[1] } # find first index equal to\
    \ first value and a bigger value\n  return -1 if lst.size == 0 # if no such value\
    \ is in the array\n  lst.each_with_index { |x, i| return i if x == lst[0] && x\
    \ > lst[1] } # find first index equal to first value and a bigger value\n  return\
    \ -1 if lst.size == 0 # if no such value is in the array\n  lst.each_with_index\
    \ { |x, i| return i if x == lst[0] && x > lst[1] } # find first index equal to\
    \ first value and a bigger value\n  return -1 if lst.size == 0 # if no such value\
    \ is in the array\n  lst.each_with_index { |x, i| return i if x == lst[0] && x\
    \ > lst[1] } # find first index equal to first value and a bigger value\n  return\
    \ -1 if lst.size == 0 # if no such value is in the array\n  lst.each_with_index\
    \ { |x, i| return i if x == lst[0] && x > lst[1] } # find first index equal to\
    \ first value and a bigger value\n  return -1 if lst.size == 0 # if no such value\
    \ is in the array\nend", "  \n  greatest = 0\n  freq = Hash.new(0)\n  \n  lst.each\
    \ do |i|\n    freq[i]+=1\n  end\n  \n  freq.each do |k,v|\n    if v > greatest\n\
    \      greatest = k\n    end\n  end\n  \n  return -1 unless greatest.zero?\n \
    \ greatest\nend", "  return lst.sort.find { |i| i > 0 } if lst.sort\n  lst.sort.reverse.find\
    \ { |i| i > 0 } if lst.sort && !lst.sort.reverse.empty?\nend", "  return lst.grep(&:>0).min_by{|x|\
    \ x.freq}&.last\nend", "  return lst.each do |num|\n    if num.include?(1)\n \
    \     result = num\n    end\n  end\nend\n</code>\nI am getting this error when\
    \ I am passing the array of numbers as parameter to my method.\n<code>\nNoMethodError\
    \ (undefined method 'each' for [1, 2, 3, 4, 2, 3]):\n</code>\n<|/ q dscore=0 |>\n\
    <| c |>\n\"I am getting this error when I am passing the array of numbers as parameter\
    \ to my method.\" What does that even mean? What code are you running that results\
    \ in this error?\n<|/ c |>\n<| c |>\nYou have to call the method in the `main`\
    \ method, not in the class definition. `main` is where you initialize your program\
    \ and get to start running.\n<|/ c |>\n<| c |>\n, please see my updated question\
    \ with my code.\n<|/ c |>\n<| c |>\n, please see my updated question with my code.\n\
    <|/ c |>\n<| c |>\n, please see my updated question with my code.\n<|/ c |>\n\
    <| a tags=ruby,nomethoderror |>\nYou have to call your search method in your main\
    \ method and not in the class definition.\nThe code below works as you want:\n\
    <code>", "  max = -1\n  freq = 0", "  lst.sort.find { |num| num > 0 && num % lst.count\
    \ == 0 } || -1\nend", "  lst.sort\n  i = lst.find_index(lst.first) if lst.any?\
    \ # No frequencies yet in array\n  i && lst.count(lst.first) > i && -1 || i\n\
    end\n</code>\n<|/ a dscore=1 tags=ruby,arrays |>\n<| c |>\nThank you for your\
    \ efforts. I did not know about `count` method and `first` method. Both are very\
    \ useful methods in Ruby.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "    freq = Hash.new\n\
    \    for i in lst\n        freq[i] += 1\n    \n    ret_val = -1\n    if freq.values.max\
    \ > 0\n        ret_val = freq.values.max\n    end\n    \n    return ret_val\n\
    end\n</cell>\n<code language=julia-1.5>\nsearch([4, 1, 2, 2, 3, 1])\n</cell>\n\
    <code language=julia-1.5>\nsearch([1, 2, 2, 3, 3, 3, 4, 4, 4])\n</cell>\n<code\
    \ language=julia-1.5>\nsearch([5, 5, 4, 4, 4])\n</cell>\n<code language=julia-1.5>\n\
    search([1, 4, 4, 4])\n</cell>\n<code language=julia-1.5>\nsearch([4, 4, 4, 4,\
    \ 4, 4])\n</cell>\n<code language=julia-1.5>\nsearch([4, 5, 4, 5, 4, 4, 4])\n\
    </cell>\n<code language=julia-1.5>\nsearch([1, 2, 2, 3, 3, 3, 4, 4, 4])\n</cell>\n\
    <code language=julia-1.5>\nsearch([4, 1, 2, 2, 3, 1])\n</cell>\n<code language=julia-1.5>\n\
    search([4, 1, 5, 4, 5, 1])\n</cell>\n<code language=julia-1.5>\nsearch([4, 1,\
    \ 4, 5, 4, 5, 1])\n</cell>\n<code language=julia-1.5>\nsearch([1, 1, 4, 5, 4,\
    \ 5, 1])\n</cell>\n<code language=julia-1.5>\nsearch([4, 5, 4, 5, 4, 4, 1])\n\
    </cell>\n<code language=julia-1.5>\nsearch([4, 5, 4, 4, 4])\n</cell>\n<code language=julia-1.5>\n\
    search([4, 5, 4, 4, 3, 1])\n</cell>\n<code language=julia-1.5>\nsearch([4, 5,\
    \ 4, 4, 3, 2, 1])\n</cell>\n<code language=julia-1.5>\nsearch([4, 5, 4, 4, 3,\
    \ 2, 1])\n</cell>\n<code language=julia-1.5>\nsearch([4, 5, 4, 4, 3, 2, 1])\n\
    </cell>\n<code language=julia-1.5>\nsearch([4, 5, 4, 4, 3, 2, 1])\n</cell>\n<code\
    \ language=julia-1.5>\nsearch([4, 5, 4, 4, 3, 2, 1])\n</cell>\n<code language=julia-1.5>\n\
    search([4, 5, 4, 4, 3, 2, 1])\n</cell>\n<code language=julia-1.5>\nsearch([4,\
    \ 5, 4, 4, 3, 2, 1])\n</cell>\n<code language=julia-1.5>\nsearch([4, 5, 4, 4,\
    \ 3, 2, 1])\n</cell>\n<code language=julia-1.5>\nsearch([4, 5, 4, 4, 3, 2, 1])\n\
    </cell>\n<code language=julia-1.5>\nsearch([4, 5, 4, 4, 3, 2, 1])\n</cell>\n<code\
    \ language=julia-1.5>\nsearch([4, 5, 4, 4, 3, 2, 1])\n</cell>\n<code language=julia-1.5>\n\
    search([4, 5, 4, 4, 3, 2, 1])\n</cell>\n", "  lst.each_with_index do |e, i|\n\
    \    next i if i > lst.count\n    if e*e == lst.count\n      lst.count\n    elsif\
    \ e*e > lst.count\n      lst.count\n    end\n  end\nend", "  lst.sort!\n  lst.each_with_index\
    \ do |e,i|\n    return i if e == 0\n    return i if e > 0 && freq[e] >= freq[e\
    \ - 1]\n  end\n  -1\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby |>\nJust\
    \ for fun, here's a solution I came up with after reading the answers on this\
    \ question. Basically, it uses two hash-tables to track the number of occurrences\
    \ of each element. The keys are the elements and the values are the counts. The\
    \ array is then sorted, and the elements are examined.\n<code>", "  return nil\
    \ if lst.nil?\n  frequency_hash[lst[0]].max\nend", "    i = 0\n    biggest = biggestInteger\n\
    \    while i < lst.length\n        if lst[i] <= biggest\n            biggest =\
    \ lst[i]\n        end\n        i = i + 1\n    end\n    return biggest\nend\n</code>\n\
    <|/ a tags=ruby,algorithm,arrays |>\n<| c |>\nYou might want to explain how your\
    \ solution works, or at least link [the relevant part of the docs](http://www.ruby-doc.org/core-2.1.1/Array.html#method-i-chunk).\n\
    <|/ c |>\n<| a dscore=0 |>\nHere's a solution in Python. It uses only core modules:\
    \ itertools and operator. The result is a lazy sequence that lazily computes the\
    \ greatest element greater than zero that has frequency greater than or equal\
    \ to the value of that element. We start with a sequence of zeros, which is then\
    \ updated to contain the greatest element greater than zero.\n<code>\nimport itertools\
    \ as it\nimport operator", "\tl = lst.sort\n\tm = l.index(0)\n\ti = m.next\n\t\
    while i != nil\n\t\treturn i\n\t\ti = i.next\n\t\tm = m.next\n\treturn -1\nend",
  "    freq = []\n    lst.length.times { freq << lst.at(it) }\n    freq.each { |it|\
    \ return it if freq.count(it) > freq.count(freq.first) }\n    return -1\nend",
  "    greatest = -1\n    freq_of_element = -1\n    i = 0\n    while i < lst.length\n\
    \        if lst[i].zero?\n            i += 1\n        elsif (lst[i].number > greatest)\n\
    \            greatest = lst[i].number\n            freq_of_element = lst[i].frequency\n\
    \        i += 1\n    end\n    return greatest if greatest >= freq_of_element\n\
    end\n</code>\n<|/ a tags=ruby,arrays,sorting |>\n<| c |>\nGreat answer, thanks\
    \ for sharing your code. I wasn't quite sure how to apply it exactly but I appreciate\
    \ it!\n<|/ c |>\n<| c |>\nI updated my answer with a solution that doesn't require\
    \ `sort` or `sort!`.  It was a little tricky to figure out how you wanted to use\
    \ those methods, but I was able to do it with a single loop.\n<|/ c |>\n<| c |>\n\
    Very nice solution! I was stuck on how to do this without modifying the original\
    \ array. Good job :)\n<|/ c |>\n<| a tags=ruby,arrays,sorting dscore=2 |>\nIf\
    \ you're looking for a solution that modifies the original array, here's one:\n\
    <code>\nrequire 'set'", "  lst.each do |i|\n    if frequencies{i} >= i\n     \
    \ return i\n    end\n  end\n  return -1\nend", "  greatest = 0\n  frequency =\
    \ []\n  lst.each_with_index do |value, index|\n    if value.zero?\n      break\n\
    \    elsif index == 0\n      frequency.push(value)\n      next value\n    elsif\
    \ value < frequency.last\n      frequency.push(value)\n      greatest = value\n\
    \      break\n    else\n      frequency.push(value)\n      frequency.shift\n \
    \   end\n  end\n  return greatest if frequency.last > 0 and frequency.last >=\
    \ greatest\n  return -1\nend\n</cell>\n<cell>", "  return lst.max_by { |x| x >\
    \ 0 && x[1] == lst.count(x) }[1]\nend", "  lst.each_with_index.max_by(&:first).last\n\
    end", "  lst.sort.reverse!\n  lst.each_with_index do |e, i|\n    return i if e\
    \ == 0\n    return -1 if e == -1\n    break if e > lst[i + 1]\n  end\n  -1\nend",
  "  return lst.max{|a, b| if a > b then a else b end\nend\n</code>\n<|/ a tags=arrays,ruby\
    \ |>\n<| a tags=arrays,ruby |>\n<code>", "    \n    result = []\n    freq = [0]\
    \ * 256\n    \n    for i in lst\n        if freq[i] < 1 \n            result.push(i)\n\
    \            freq[i] += 1\n            \n    if freq.include?(-1.to_i) # if freq[-1.to_i]\
    \ == 0\n        return -1\n    \n    freq.each_with_index { |v, i| freq[i] = freq[i].to_i\
    \ if freq[i].to_i >= v }\n    \n    result.min\nend", "  return lst.index(lst.sort.max)\n\
    end", "  freq.each_with_index do |v, i| \n    return v if i < freq.index(lst.max)\
    \ + 1\n  end\n  return -1\nend", "  max = nil\n  freq = Hash.new(-1)", "  freq\
    \ = {}\n  for i in lst\n    freq[i] = freq[i] || 0\n    freq[i] += 1\n  greatest_index\
    \ = -1\n  max_freq = -1\n  for i in freq\n    if freq[i] > max_freq\n      max_freq\
    \ = freq[i]\n      greatest_index = i\n  return greatest_index\nend", "  return\
    \ -1 if lst.length == 0 || lst.length == 1 && lst[0] < 0 else \n    lst[0] > 0\n\
    end", "  lst.each_with_index do |n,i|\n    idx = lst.index n\n    if idx\n   \
    \   lst.delete_at(i+1)\n      return idx\n    elsif i == lst.length \n      return\
    \ -1\n    elsif n < 0\n      return -search(lst)\n    end\n  end\nend", "  return\
    \ lst.find { |e| e > 0 }.nil? ? -1 : lst.find { |e| e >= lst.count(e) }\nend",
  "  lst.inject(0) do |sum, val|\n    sum += val if (sum >= 0 || sum < val)\n    sum\n\
    \  end\nend", "    i = 0\n    freq = [0] * len(lst)\n    \n    while i < len(lst)\n\
    \        j = i\n        while (j < len(lst)) and (freq[j] > freq[i] + 1)\n   \
    \         freq[j] = freq[j] + 1\n            j = j + 1\n        \n        if i\
    \ == j \n            return -1\n        \n        i = j\n    \n    return 0\n\
    \    ", "  l = lst.sort\n  if l.empty?\n    return -1\n  freq = freq(l)\n  if\
    \ freq == -1\n    return -1\n  if freq < 0\n    return -1\n  freq = freq.abs\n\
    \  res = 0\n  i = 0\n  while i < lsize\n    if l[i] == 0\n      i += 1\n    else\
    \ if l[i] > 0 \n      return l[i] if freq >= l[i] \n      res = i\n      i +=\
    \ 1\n    else if l[i] < 0 \n      return i\n      i += 1\n    end\n  end\n  return\
    \ res\nend", "  lst.each_with_index.reduce(:<=>).find_all {|k,i| k >= 0 && k ==\
    \ lst[i]}.last || -1\nend", "  if lst.empty?\n    return -1\n  \n  min_val = lst.min\n\
    \  max_val = lst.max\n  freq = frequency(lst)\n  \n  if freq.nil?\n    return\
    \ -1\n  elsif freq > min_val\n    return min_val\n  elsif freq < max_val\n   \
    \ return max_val\n  end\n  \n  mid = min_val..max_val\n  \n  lst.delete_if do\
    \ |i|\n    (mid.include? i) ? false : true\n  end\n  \n  search(lst)\nend\n</cell>\n\
    <code language=ruby-1.9.3-p448>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
