name: HumanEval_158_find_max
language: rb
prompt: "# Write a function that accepts an array of strings.\n# The array contains\
  \ different words. Return the word with maximum number\n# of unique characters.\
  \ If multiple strings have maximum number of unique\n# characters, return the one\
  \ which comes first in lexicographical order.\n# >>> find_max.call([\"name\", \"\
  of\", \"string\"])\n# \"string\"\n# >>> find_max.call([\"name\", \"enam\", \"game\"\
  ])\n# \"enam\"\n# >>> find_max.call([\"aaaaaaa\", \"bb\", \"cc\"])\n# \"aaaaaaa\"\
  \ndef find_max(words)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n\
  \    candidate = method(:find_max)\n    assert_equal(\"string\", candidate.call([\"\
  name\", \"of\", \"string\"]))\n    assert_equal(\"enam\", candidate.call([\"name\"\
  , \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
  , \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"\
  ]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"this\", \"game\"\
  , \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"\
  are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\"\
  , \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
  this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"\
  ]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
  \  end\nend\n"
completions: ["  chars = Hash.new(0)\n  words.each do |word|\n    word.chars.each\
    \ do |char|\n      chars[char] += 1 if chars[char] > chars[char].to_i\n    end\n\
    \  end\n  \n  chars.values.uniq.each { |c| chars[c] = 0 }\n  chars.values.find\
    \ { |c| c == chars.values.max }\nend", "  words.uniq.sort.last\nend\n</cell>\n\
    <code language=julia-1.0>\nfind_max.call([])\n</cell>\n<code language=julia-1.0>\n\
    find_max.call([\"a\"])\n</cell>\n<code language=julia-1.0>\nfind_max.call([\"\
    a\", \"a\"])\n</cell>\n<code language=julia-1.0>\nfind_max.call([\"a\", \"a\"\
    , \"a\"])\n</cell>\n<code language=julia-1.0>\nfind_max.call([\"a\", \"a\", \"\
    b\", \"b\", \"b\"])\n</cell>\n<code language=julia-1.0>\nfind_max.call([\"a\"\
    , \"a\", \"b\", \"b\", \"b\", \"a\", \"a\"])\n</cell>\n<code language=julia-1.0>\n\
    find_max.call([\"a\", \"a\", \"b\", \"b\", \"b\", \"a\", \"a\", \"a\", \"a\",\
    \ \"a\"])\n</cell>\n<code language=julia-1.0>\nfind_max.call([\"a\", \"a\", \"\
    a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"])\n</cell>\n<code\
    \ language=julia-1.0>\nfind_max.call([\"a\", \"a\", \"b\", \"b\", \"c\", \"c\"\
    , \"c\", \"c\", \"c\", \"c\"])\n</cell>\n<code language=julia-1.0>\nfind_max.call([\"\
    a\", \"a\", \"b\", \"b\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"\
    a\", \"a\", \"a\"])\n</cell>\n<text>\nWrite a function that accepts an array of\
    \ strings. The function should return a string which has maximum number of characters\
    \ and is lexicographically greater than all others. If a word has a length of\
    \ 1, return it unchanged. If all words have length of 1, return \"1\". If all\
    \ words have maximum characters, return the one which comes first in lexicographical\
    \ order. For example,", "  sorted = words.sort.reverse\n  sorted.each do |word|\n\
    \    word_count = word.count(\"a\")\n    return word if word_count == words.count(word)\
    \ and word_count > 1\n  end\n  words.first\nend\n</code>\n<|/ a |>\n<| a |>\n\
    Just in case:\n<code>\na = [1, 2, 1, 2, 1, 2, 1, 2]\na.uniq.sort_by { |e| a.count(e)\
    \ }.last", "  unique_chars_count = Hash.new(0)\n  unique_chars_hash = {}\n  unique_chars_sorted_list\
    \ = Array.new\n  words.each do |word|\n    unique_chars_count.update(word.chars).merge(unique_chars_hash)\n\
    \    unique_chars_sorted_list << word\n  end\n  unique_chars_sorted_list.each\
    \ do |word|\n    unique_chars_hash[word] += 1 if unique_chars_count.has_key?(word)\n\
    \  end\n  unique_chars_sorted_list.sort do |w1, w2|\n    unique_chars_count[w1]\
    \ <=> unique_chars_count[w2]\n  end[0]\nend", "  max_count = nil\n  max_word =\
    \ nil\n  \n  words.each do |word|\n    count = word.chars.uniq.size\n    \n  \
    \  if count.nonzero?\n      if max_count.nonzero? || count > max_count\n     \
    \   max_count = count\n        max_word = word\n      end\n    end\n  end\n  \n\
    \  return max_word\nend", "  words.sort_by!{ |word| word.size }.reverse!\n  words.uniq!.size\n\
    \  words[0, words.size - 1] if words.size > 1\nend", "  words.length.times do\
    \ |i|\n    words.slice!(0, i)\n    break if words.length.zero? || words.length\
    \ == i\n    words[i] = words[i].downcase.split(//).uniq.length\n  end\n  words.uniq.max\n\
    end", "  # Write your code here.\n  words = words.sort\n  words.uniq.length\n\
    end", "  words.max_by { |word| word.chars.count }.first\nend", "  sorted_by_count\
    \ = words.sort_by { |word| word.chars.uniq.size }\n  return sorted_by_count.last\
    \ if sorted_by_count.size < 2\n  sorted_by_count.first.chars.uniq.first\nend",
  "  word_counts = Hash.new(0)\n  words.each do |word|\n    word_counts[word] += 1\
    \ if word_counts[word] > 0\n  end\n  word_counts[words.first]\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nThis is a good approach, but you should make it `Hash.new(0)`.\
    \ And also fix the bug that `word_counts` is defined with zero values.\n<|/ c\
    \ |>\n<| c |>\nAwesome! I just realized that my code was flawed and missed that\
    \ bug so I just fixed it. Thanks for the tip!\n<|/ c |>\n<| c |>\nAlso, note that\
    \ if performance is a concern, it is better to use a hash than a set, since sets\
    \ are faster for finding single keys.\n<|/ c |>\n<| c |>\nI really like this solution,\
    \ but I got this error `ArgumentError: wrong number of arguments (0 for 1)`, in\
    \ line `word_counts[word] += 1`.\n<|/ c |>\n<| c |>\nHmm this worked for me. I\
    \ guess it's ruby version dependent. I'm using 1.9.3. `word_counts[word] ||= 0`\
    \ also worked\n<|/ c |>\n<| a tags=ruby |>\nHere's another variation of my original\
    \ answer:\n<code>", "  sorted = words.sort.reverse\n  sorted.each do |word|\n\
    \    if word.count.uniq.to_f == word.length\n      return word\n    end\n  end\n\
    \  return nil\nend", "  unique_chars = Set.new\n  max_words = nil\n  words.each\
    \ do |word|\n    unique_chars.merge(word.split(\"\"))\n    unique_chars.uniq.each\
    \ do |char|\n      if max_words.nil? || (max_words.length < unique_chars.length\
    \ &&\n                            unique_chars.include?(char))\n        max_words\
    \ = word if unique_chars.length == word.length\n      end\n    end\n  end\n  return\
    \ max_words\nend", "  # Write your code here.\n  # Use Enumerable#max_by to solve\
    \ the problem. \n  words.max_by { |word| word.size }\nend", "  words.inject(0)\
    \ do |max, word|\n    max = max + (word.length ** words.size - 1)\n    word =\
    \ word.downcase\n    word.chars.uniq.size >= max ? word : max\n  end\nend\n</code>\n\
    <|/ a tags=arrays,ruby |>\n<| c |>\nThis implementation works perfectly on my\
    \ machine and as far as I can tell runs in <1ms.  It is a great solution.  I wish\
    \ I could up vote it more than once.\n<|/ c |>\n<| c |>\nI guess I never saw your\
    \ solution\n<|/ c |>\n<| a |>\nI made a solution which uses Ruby 2.3.0 and Ruby's\
    \ own Enumerable#max_by method. Here's a demonstration:\n<code>", "  words_with_unique_characters\
    \ = Hash.new(0)\n  words.each_with_index do |word, index|\n    words_with_unique_characters[word]\
    \ += 1\n    words_with_unique_characters.keys.uniq.each do |unique_character|\n\
    \      words_with_unique_characters[unique_character] += 1 if unique_character.size\
    \ < word.size\n    end\n  end\n  sorted_characters = words_with_unique_characters.keys.sort.reverse\n\
    \  sorted_characters.each do |character|\n    return character if words_with_unique_characters[character]\
    \ == words_with_unique_characters[character].max\n  end\nend", "  return words[words.inject(0)\
    \ { |max, w| w.count(max) == w.count(max) ? max : nil }]\nend", "  return words.inject([])\
    \ do |memo, word|\n    memo << word if memo.uniq.size >= memo.size.max\n  end\n\
    end\n</cell>\n<cell>", "  return words.index(words.max_by { |w| w.length })\n\
    end\n</code>\n<|/ a dscore=2 tags=ruby |>\n<| a dscore=2 |>\nThis works:\n<code>\n\
    > def biggest_string(words)\n>  max_word_len = nil\n>  words.each do |word|\n\
    >    word.chars.uniq.size > max_word_len ? max_word_len = word.chars.uniq.size\
    \ : max_word_len\n>  end\n>  words.find { |word| word.chars.uniq.size == max_word_len\
    \ }\n> end\n> biggest_string([\"word\", \"word\", \"word\", \"word\", \"word\"\
    , \"word\", \"word\", \"word\", \"word\"])\n=> \"word\"\n</code>\nIt compares\
    \ the length of each word with maximum length of each word and finds the string\
    \ which has the maximum length.\n<|/ a tags=ruby |>\n<| a tags=ruby |>\nThis question\
    \ was asked a while ago and I had answered it, but since I wanted to contribute\
    \ an alternative solution I thought it would be useful to post this here too.\n\
    The original solution was not working properly for words with duplicate letters.\
    \ Let's see why:\n<code>", "  return words.group_by { |word| word.chars.uniq.size\
    \ }.max_by { |word, count| count }.first\nend", "  return words.sort.reduce(:&).first\n\
    end\n</code>\n<|/ a tags=ruby dscore=2 |>\n<| a dscore=2 |>\nRuby has a built-in\
    \ method Hash#max_by which does this:\n<code>\nwords.max_by { |s| s.length }",
  "  return words[words.sort{|x,y| y.size<=>x.size}.first]\nend\n</cell>\n<cell>",
  "  words.sort do |x, y|\n    x.size <=> y.size || x <=> y\n  end\n  words[0]\nend\n\
    </cell>\n<code language=julia-1.5>\nfind_max.([\"abba\", \"bb\", \"cc\"])\n</cell>\n\
    <code language=julia-1.5>\nfind_max.([\"abba\", \"bb\", \"cc\", \"c\"])\n</cell>\n\
    <text>\nFind word with maximum count and character with maximum number of unique\
    \ characters.", "  words.inject([]) do |unique, word|\n    unique.size < word.size\
    \ ? unique << word : unique\n  end\n  return unique.max_by { |word| word.size\
    \ }\nend", "  unique_chars = Hash.new(0)\n  words.each do |word|\n    word.split(\"\
    \").uniq.each do |c|\n      unique_chars[c] += 1\n    end\n  end\n  unique_chars.max_by\
    \ { |k,v| v }\nend\n</code>\n<|/ a tags=string,ruby |>\n<| a |>\n<code>", "  words\
    \ = words.map(&:to_s)\n  words.sort!\n  words.uniq!\n  words.last\nend", "  return\
    \ words[words.index(words.group_by{|s| s.count}.max_by{|s| s.count})]\nend", " \
    \ max = 0\n  max_word = \"\"\n  words.each do |word|\n    count=0\n    word.each_char\
    \ do |char|\n      count += 1\n    end\n    if count > max then\n      max = count\n\
    \      max_word = word\n    end\n  end\n  return max_word\nend\n</code>\n<|/ a\
    \ |>\n<| a |>\nI wrote a recursive method using Enumerable#each_cons, and Array#uniq\
    \ to find the largest unique word:\n<code>", "  word = words.max_by { |s| s.length\
    \ }\n  return word if word\n  return words.first.to_s if words.count > 1\n  words.first\n\
    end\n</cell>\n<text>\nThe find method of Array will take a block/proc which takes\
    \ a single argument, in this case the element to work on. The block will be called\
    \ on each element of the array, and the return value will be used as the value\
    \ for the max. max_by is similar in that it calls the block for each element and\
    \ returns the maximum value. We could write find_max as:", "  letters = letters(words.join(\"\
    \ \"))\n  words.map {|word| letters.uniq.size}.max.compact.first\nend", "  # sort\
    \ with number of unique characters\n  sorted_words = sorted(words, :key => :length).uniq\n\
    \  # find max string\n  sorted_words.max.first\nend\n</code></pre>", "  max_chars\
    \ = \"\"\n  max_count = 0\n  words.each do |word|\n    char_count = word.count(\"\
    a\")\n    char_count += word.count(\"A\")\n    char_count += word.count(\"e\"\
    )\n    char_count += word.count(\"E\")\n    char_count += word.count(\"i\")\n\
    \    char_count += word.count(\"I\")\n    char_count += word.count(\"o\")\n  \
    \  char_count += word.count(\"O\")\n    char_count += word.count(\"u\")\n    char_count\
    \ += word.count(\"U\")", "  uniques = Hash.new(0)\n  words.each do |word|\n  \
    \  word.each_char do |char|\n      uniques[char] += 1\n    end\n  end\n  max_key\
    \ = nil\n  max_value = uniques.values.max\n  words.each do |word|\n    word.each_char\
    \ do |char|\n      if uniques[char] > max_value\n        max_value = uniques[char]\n\
    \        max_key = char\n      end\n    end\n  end\n  return max_key\nend", " \
    \ words.size() <= 1 ? \"not found\" : words[words.index(words[0])]\nend", "  \
    \  char_count = Hash.new(0)\n    word_count = words.map { |word| char_count[word]\
    \ }\n    return nil if word_count.empty?\n    max_word, max_count = word_count.max,\
    \ word_count.min\n    words.each do |word|\n        char_count[word] += max_count\n\
    \        word.downcase! if word\n        word.squeeze! unless word.length == 1\n\
    \    end\n    return nil if char_count.empty?\n    max_char_count, max_char_word\
    \ = char_count.max, char_count.key\n    if max_char_count == max_count\n     \
    \   words.each do |word|\n            char_count[word] -= max_count\n        \
    \    word.downcase! if word\n            word.squeeze! unless word.length == 1\n\
    \        end\n        return max_char_word if char_count.empty?\n    end\n   \
    \ return max_char_word if char_count.key?(max_char_word)\n    words.reverse.find\
    \ do |word|\n        char_count[word] > max_char_count\n    end\nend\n</code>\n\
    <|/ a tags=ruby dscore=3 |>\n<| c |>\n`word_count.key` is redundant and can be\
    \ dropped, `return max_char_word if char_count.empty?` can be dropped, `char_count.key?(max_char_word)`\
    \ can be replaced with `char_count.max_by{|k,v| v} == max_char_count`\n<|/ c |>\n\
    <| a dscore=1 tags=ruby |>\nHere is a solution using sort_by and uniq methods\
    \ of Array:\n<code>", "  result = nil\n  count = words.uniq.length\n  words.each\
    \ { |word| result = word if count > words.uniq.count }\n  result\nend", "  words.size>0?\
    \ words[words.map{|word| word.length}.uniq.sort_by{|x| x}.reverse.first] : \"\"\
    \nend", "  hash = {}\n  max = 0\n  word = nil", "  words.map(&:count).uniq.max_by(&:itself).first\n\
    end", "  max_count = words.map(&:count).max || 0\n  words.max_by {|word| word.count(max_count)\
    \ }\nend", "  unique_chars = words.map(&:uniq.size).max\n  char_counts = words.map\
    \ do |word|\n    word.chars.uniq.size rescue 0\n  end\n  char_counts.min\nend",
  "  unique_chars = {}\n  best_word, best_count, best_index = nil, nil, nil\n  words.each\
    \ do |word|\n    word.chars.uniq.each do |char|\n      if char.nil?\n        next\n\
    \      end\n      count = unique_chars[char] or 0\n      if count > best_count\n\
    \        best_word, best_count, best_index = word, count, char\n      end\n  \
    \    unique_chars[char] = count + 1\n    end\n  end\n  best_word\nend", "  word_counter\
    \ = Hash.new(0)\n  words.each do |word|\n    word = word.downcase\n    word_counter[word]\
    \ += 1\n  end\n  max_word_count = word_counter.values.max\n  max_word = word_counter.values.max_by\
    \ {|count| count}\n  max_word\nend", "  result = \"\"\n  unique_char_count = {}\n\
    \  unique_char_count[result] += 1\n  for i in words\n    unique_char_count[i.downcase]\
    \ += 1\n  return result[1..-1] if result == \"\" then words[0] end\nend", "  return\
    \ words.max_by { |word| word.chars.uniq.size }.first\nend", "  words.map! {|word|\
    \ word.downcase}\n  words_in_order.map! {|word| word.downcase}", "  # Your code\
    \ here\n  result = {}\n  count = {}\n  for i in words\n    count[i] = count.has_key?(i)?\
    \ count[i] : 0\n    result[i] = count[i] > result.has_key?(i)? result[i] : i\n\
    \  end\n  \n  result.each_key do |k|\n    result.each do |k, v|\n      break if\
    \ v >= k\n    end\n  end\n  \n  result.max\nend", "  # Write your code here\n\
    \  max_count = 0\n  max_word = \"\"", "  hash = {}\n  words.each do |word|\n \
    \   hash[word] ||= 0\n    hash[word] += 1\n  end\n  hash.max_by do |key, val|\n\
    \    val\n  end\nend", "  result = \"\"\n  i = 0\n  \n  while i < words.size\n\
    \    if words[i].length == words.length\n      result << \"#{words[i]}\"\n   \
    \   i += 1\n    else \n      count = words.map { |word| words[i].length }.uniq.count\n\
    \      result = count > result ? count : result\n      i += 1\n    end\n  end\n\
    \  result\nend", "  words.sort.with_index do |x, i|\n    x.uniq.count if i <=\
    \ x.uniq.count\n  end\nend\n</code>\nThe algorithm is very simple - count the\
    \ unique characters in each word in the array (sort them alphabetically) and return\
    \ the word which has maximum count (this could be the word which comes first in\
    \ lexicographical order). The solution with Enumerable#sort_by is more efficient\
    \ and better readable, however, it can only sort by the first character, which\
    \ is not what you need. So the solution using Enumerable#sort_by is:\n<code>",
  "  unique, counts = unique_count(words)\n  max_index = counts.max\n  max_count \
    \ = counts[max_index]", "  return words[words.index(max_word(words))] if words.uniq.count\
    \ > 0 \nend", "  max_word = \"\"\n  max_count = 0\n  words.each do |word|\n  \
    \  count = words.count(word).to_i\n    if count > max_count\n      max_word =\
    \ word\n      max_count = count\n    end\n  end\n  return max_word\nend", "  words.size().times\
    \ do |i|\n    unique_char = words[i].chars.uniq.size\n    if unique_char == words[i].chars.uniq.length\n\
    \      words[i] = words[i].chars.uniq.to_a.join\n      break\n    elsif unique_char\
    \ > words[i].chars.uniq.length\n      words[i] = words[i].chars.uniq.to_a.join\n\
    \    end\n  end\n  words.first\nend\n</code>\n<|/ a tags=ruby-on-rails,ruby |>\n\
    <| c |>\nAh, okay, I see where you went wrong. Thanks!\n<|/ c |>\n<| a |>\nA short\
    \ and sweet version which solves the problem with 'a' (in the last array):\n<code>\n\
    words=[]\na=%w{a b c d a e f g h i a j k l m n o p q r s t u v w x y z}\na.each\
    \ {|w| words << w if w !~ /\\w/}\np words[words.select {|w| w !~ /\\w/}.max_by\
    \ {|w| w.size}]\n</code>\n<|/ a tags=ruby-on-rails,ruby dscore=1 |>\n<| a tags=ruby-on-rails,ruby\
    \ |>\n<code>\nwords = ['aa', 'bb', 'ccc', 'abc', 'zzz']\narr = words[0..-2].uniq.sort.last\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\n`words[0..-2]` will give `['aa', 'bb', 'ccc']`\
    \ instead of `['abc', 'zzz']`. Also, `sort` will return a sorted array which is\
    \ not required here\n<|/ c |>\n<| a dscore=0 |>\nAnother alternative.\n<code>\n\
    words = ['aa', 'bb', 'ccc', 'abc', 'zzz']\nwords[0..-2].uniq.sort.last", "  words\
    \ = words.map { |word| word.chars.uniq.size }\n  words.max\nend", "  return words.group_by{|word|\
    \ word.count{|char| char.downcase == \"a\"}}.max_by{|word, count| count}\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| a |>\nThe easiest way is to sort and get the first\
    \ element from the resulting array in Ruby\n<code>\nrequire \"set\"", "  words.sort_by(&:length).reverse_each.find(&:unique?)\n\
    end", "    words=words[1..-1]\n    words=words.collect{|w| w.split('').uniq.size}.max\n\
    \    words.to_s\nend", "  words.sort_by { |word| word.count() }.first\nend", " \
    \ word_count = words.inject(Hash.new(0)) {|h, word| h[word] += 1; h}\n  word_count.max_by\
    \ { |k,v| v }\nend", "  words.uniq.max { |a, b| a.length <=> b.length } || words.first\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work for strings with spaces, e.g.\
    \ `find_max.call([\"Name and surname\", \"Name and surname\"])`\n<|/ c |>\n<|\
    \ a dscore=2 |>\nSince this question was asked so long ago, I thought it would\
    \ be nice to provide a more elegant solution than the currently accepted answer.\
    \ For Ruby 2.7+ (or even 2.4), you could use the new Enumerable#max_by method:\n\
    <code>", "  words.sort.reverse.max_by { |word| word.chars.uniq.size }\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nI am getting \"undefined method `uniq' for Array\"\
    \ when I run this script\n<|/ c |>\n<| c |>\n`Array` doesn't have a `uniq` method.\
    \ `words` is an array of strings, not an `Array`. You'll want to use [`Array#uniq`](https://ruby-doc.org/core-2.7.1/Array.html#method-i-uniq).\n\
    <|/ c |>\n<| c |>\nI tried that before but got \"undefined method `sort' for nil:NilClass\"\
    . Is there something else I need to change?\n<|/ c |>\n<| c |>\nAh, I see now.\
    \ `words` is nil, which means that you're not calling the method on anything.\
    \ You'll want to make sure `words` isn't nil before you run the function.\n<|/\
    \ c |>\n<| c |>\nThanks for the help so much! I got it figured out!\n<|/ c |>\n\
    <| a dscore=0 |>\nI came up with this solution, not sure if it's the best solution:\n\
    <code>\nwords = [\n  \"name1\", \"name2\", \"name3\", \"name4\", \"name5\", \"\
    name6\", \"name7\",\n  \"name8\", \"name9\", \"name10\", \"name11\", \"name12\"\
    , \"name13\", \"name14\",\n  \"name15\", \"name16\", \"name17\", \"name18\", \"\
    name19\", \"name20\"\n]", "  # Split each word into characters and return word\
    \ with max number of unique characters.\n  word_counts = Hash.new(0)\n  words.each\
    \ { |word| word_counts[word] += 1}\n  word_counts.max_by { |word, count| count\
    \ }[1]\nend", "  words.uniq.sort! # Ensure that words are sorted before we look\
    \ at them\n  max_words = words.uniq.size # How many unique characters do we have?\n\
    \  max_word = words[0] # Where will the most unique character go?", "  return\
    \ words.reduce(:uniq).compact.map { |s| s.length }.uniq.max || words[0]\nend",
  "  unique_chars = Hash.new(0)\n  words.each do |word|\n    unique_chars[word] +=\
    \ 1\n  end\n  unique_chars.each do |word, count|\n    break if count == unique_chars[word]\n\
    \  end\n  words[words.index(word)]\nend", "    unique_chars = []\n    max_chars\
    \ = 0\n    word_count = {}\n    words.each do |word|\n        word.split(\"\"\
    ).each do |char|\n            if word_count.has_key?(char)\n                word_count[char]\
    \ += 1\n            else\n                word_count[char] = 1\n            end\n\
    \        end\n        unique_chars << word if word_count.values.max == word_count.values.min\n\
    \    end\n    unique_chars.uniq.each do |word|\n        if word_count.has_key?(word.downcase)\n\
    \            word_count[word.downcase] += 1\n        else\n            word_count[word.downcase]\
    \ = 1\n        end\n    end\n    word_count.each do |k, v|\n        if v == word_count.values.max\n\
    \            return k\n        end\n    end\nend", "  words.each do |word|\n \
    \   word = word.downcase\n    unique = word.count('a')\n    unique += word.count('e')\n\
    \    unique += word.count('i')\n    unique += word.count('o')\n    unique += word.count('u')\n\
    \    unique += word.count('y')\n    return word if unique == word.count\n  end\n\
    end", "  return words[words.index(words.uniq.length.max)]\nend\n</code>\n<|/ a\
    \ dscore=1 |>\n<| c |>\n`uniq` won't work, since it can remove duplicates with\
    \ different order.\n<|/ c |>\n<| a dscore=1 |>\nIf you have a set of strings you\
    \ want to compare, you can use sort to get them in alphabetical order, and uniq\
    \ will remove duplicates:\n<code>", "  # Set current and max as empty strings.\n\
    \  current = \"\"\n  max = 0\n  \n  # Iterate through all the strings in the array.\n\
    \  words.each do |word|\n    # If current word and max word are the same string\
    \ then increase max\n    # else if max is greater than current word's max then\
    \ set max as current\n    # and set current as word and set as max to 1.\n   \
    \ if word == current && (current > max)\n      max = 1\n      current = word\n\
    \    elsif current > max\n      max = 1\n      current = word\n    else\n    \
    \  current += word\n    end\n  end\n  \n  # Return the current word with the max\
    \ number of unique characters.\n  current\nend", "  max = 0\n  index = 0\n  while\
    \ index < words.length\n    char = words[index].chars.join\n    if max < char.call(words).length\n\
    \      max = char.call(words).length\n      index = 0\n      next\n    end\n \
    \   index += 1\n  end\n  return words[index]\nend\n    ", "  unique_chars = Hash.new(0)\n\
    \  unique_chars.keys.each do |k|\n    unique_chars[k] += words.length - k\n  end\n\
    \  unique_chars.max_by { |k,v| v }\nend\n</code>\n<|/ a tags=arrays,hash,ruby\
    \ |>\n<| a tags=arrays,hash,ruby dscore=0 |>\n<code>", "  unique = {}\n  max_length\
    \ = 0", "  result = words[0]\n  unique_count = Hash.new(0)\n  words.each do |word|\n\
    \    word.chars.uniq.each do |c|\n      unique_count[c] += 1\n    end\n    unique_count\
    \ = Hash.new(0)\n  end\n  return result if unique_count.values.max == unique_count[:a]\n\
    \  words[0]\nend\n</code>\n<|/ a |>\n<| a |>\nHere is a solution that uses Ruby's\
    \ Enumerable#sort_by and Hash#merge:\n<code>", "  return words.inject({}) {|hash,\
    \ (word, count)| count > hash[word] ? (hash[word] = count, word) : hash[word]\
    \ }.last\nend", "  sorted_by_len = words.sort_by{|s| s.length}\n  highest_count\
    \ = sorted_by_len.length.last\n  highest_word = sorted_by_len.last\n  if highest_count.positive?\n\
    \    highest_word\n  else\n    sorted_by_len.first\n  end\nend", "  return words.max_by\
    \ { |word| word.length }\nend", "  unique = {}\n  words.each do |word|\n    letters\
    \ = word.split(//).uniq.size\n    unique[letters] ||= 0\n    unique[letters] +=\
    \ 1\n  end\n  unique.values.max_by(&:last).last\nend", "  return words[words.max_by\
    \ { |word| word.chars.uniq.count }] \nend", "  return words.inject(Hash.new(0))\
    \ { |memo, word| \n    memo[word.dup] += 1\n    if memo.keys.sort.last == word.dup\n\
    \      memo.keys.sort.last\n    elsif memo[word.dup] == 1\n      memo.keys.sort.last\n\
    \    else\n      memo[word.dup]\n    end\n  }\nend", "  words = words.sort\n \
    \ words.max_by { |word| word.chars.uniq.size }\nend", "  words.each_with_index\
    \ do |word, i|\n    counts = Hash.new(0)\n    word.each_char.uniq.each_with_index\
    \ { |char, i| counts[char] += 1 }\n    return words[i] if counts.max_by { |k,\
    \ v| v }[:count] == counts.max_by { |k, v| k }[:count]\n  end\nend", "  chars\
    \ = Hash.new(:int)\n  words.each do |word|\n    chars.merge(word.downcase.chars.uniq,\
    \ chars[word]) { |acc, val| acc + val }\n  end\n  chars.max_by {|k,v| v}[0]\n\
    end\n</pre>\n          </li>\n          <li>\n            <p>\n              The\
    \ <tt>Hash#merge</tt> method combines two hashes, each mapping keys to values.\
    \ The\n              first hash's mapping is merged with the second hash, so if\
    \ both hashes have a\n              mapping for the same key, the mapped value\
    \ is merged. If the value for\n              <tt>:key</tt> is an Array, <tt>Hash#merge</tt>\
    \ iterates over the array, appending all\n              of the mapped values,\
    \ then merges that into the returned hash.\n              <tt>Hash#merge</tt>\
    \ also accepts a <tt>:if</tt> option, which specifies a Proc that\n          \
    \    is called for each element and the element returned if the Proc is true.\n\
    \              If the element returned is falsy, the element from the first hash\
    \ is returned.\n              When a Proc is given, it is called with three arguments:\n\
    \            </p>\n            <ul>\n              <li>The mapped value in the\
    \ first hash.</li>\n              <li>The <tt>Hash</tt> being merged into (<tt>self</tt>).</li>\n\
    \              <li>The <tt>Hash</tt> being merged into (<tt>other</tt>).</li>\n\
    \            </ul>\n            <pre>", "    words.length <= 1 ? words.first :\
    \ words[0, words.size-1].inject({}) {|h, x| h[x] = h[x].to_i + 1; h }\nend", " \
    \ return words.max_by(&:length).tap { |s| s.map(&:first) }\nend\n</code>\n<|/\
    \ a tags=ruby |>\n<| c |>\n`max_by` requires the block parameter to provide a\
    \ comparison operator such as `:>`, so you should replace `length` by `length`\
    \ in the example above to get the same result.  Also, `first`/`last` would return\
    \ the first or last word in the array; you need `[0]` to get the first word in\
    \ the array.\n<|/ c |>\n<| c |>\nYou are right about `length`. I fixed it. I used\
    \ `first` because I was only looking for the first word in the array. I also added\
    \ a note about the `length` method of the `String` class.\n<|/ c |>\n<| a |>\n\
    This may not be the most elegant solution, but I did something like this:\n<code>",
  "  max_count = words.map { |w| w.length }.max\n  words.sort.each do |word|\n   \
    \ return word if word.length == max_count\n  end\n  nil\nend\n</code>\n<|/ a dscore=1\
    \ tags=ruby,sorting,arrays |>\n<| c |>\nThis doesn't work as it gives the word\
    \ with the minimum number of unique characters first\n<|/ c |>\n<| c |>\nYes,\
    \ you are right. I updated my answer. Thanks\n<|/ c |>\n<| a |>\nHere is my solution:\n\
    <code>", "  words.uniq.length.max\nend\n</cell>\n<code language=julia-0.6>", " \
    \ words.each do |word|\n    count = word.length\n    word.chars.uniq.each do |c|\n\
    \      count -= 1\n      return c if count < 0\n    end\n  end\nend", "  uniques\
    \ = Hash.new(0)\n  word = nil\n  words.each do |word|\n    uniques[word.chars.uniq.length]\
    \ += 1 if uniques[word.chars.uniq.length] > 0\n  end\n  word.chars.uniq.first\
    \ if uniques[word.chars.uniq.length] > 0\nend", "    words = words.sort!\n   \
    \ word = nil\n    max_count = 0\n    words.each do |word|\n        if word.count\
    \ > max_count\n            max_count = word.count\n            word = word\n \
    \       end\n    end\n    word\nend\n</cell>\n<text>\nExercise 4\nWrite a function\
    \ that accepts an array of strings and returns a new array that contains only\
    \ unique strings.", "  max_count = words.count\n  max_word = nil\n  max_idx =\
    \ nil\n  words.each_with_index do |word, idx|\n    if word.count(max_count) >\
    \ max_count\n      max_count = word.count(max_count)\n      max_word = word\n\
    \      max_idx = idx\n    end\n  end\n  return max_word, max_idx\nend", "  # Initialize\
    \ max\n  max = nil", "  max_letters = Hash.new(0)\n  min_letters = Hash.new(0)\n\
    \  max_word = nil\n  words.each do |word|\n    letters = word.split('')\n    letters.uniq.each\
    \ do |letter|\n      max_letters[letter] += 1 if max_letters.has_key?(letter)\n\
    \      min_letters[letter] -= 1 if min_letters.has_key?(letter)\n    end\n   \
    \ max_word = word if max_letters.values.max == max_letters.values.min\n  end\n\
    \  return max_word\nend\n</cell>\n<cell>\nfind_max.call([\"name\", \"of\", \"\
    string\"])\nfind_max.call([\"name\", \"enam\", \"game\"])\nfind_max.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n</cell>\n<text>\nHash Keys and Values\nSometimes you need\
    \ access to both the key and the value of a hash. This is easy, you just call\
    \ the key and value method on the hash. But sometimes you need to access the key\
    \ and the values simultaneously. Perhaps the hash is sorted, and you only want\
    \ to see keys that are greater than or equal to some particular value. In this\
    \ case, you need to use the each method. Let's look at some examples:", "  words=words.split(\"\
    \ \").sort_by{|x| x.size}\n  word=words[0..words.count-1].max_by{|x| x.size}\n\
    \  if word\n    return word.first\n  else\n    return nil\n  end\nend", "  unique_count\
    \ = words.inject(Hash.new(0)) {|count, s| count[s] += 1; count}\n  max_count =\
    \ -1\n  max_word  = nil\n  words.each {|s| \n    if unique_count[s] > max_count\
    \ \n      max_count = unique_count[s]\n      max_word = s\n    end\n  }\n  max_word\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThanks Tulentsev. I'll try this and get back\
    \ with the results. :)\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  unique_chars =\
    \ Hash.new(0)\n  max_chars = nil", "  words.each_with_index do |word, index|\n\
    \    word = word.to_s\n    chars = chars(word).uniq.length\n    word_chars = chars(word)\n\
    \    if chars == word_chars && chars.positive? && word_chars.positive?\n     \
    \ words[index] = word\n    end\n  end\n  words[words.count - 1]\nend", "  \nend",
  "  char_count = Hash.new(0)\n  words.each do |word|\n    word.chars.each { |char|\
    \ char_count[char] += 1 }\n  end\n  char_count.max_by { |_, count| count }\nend",
  "  hash = Hash.new(0)\n  words.each do |word|\n    hash[word] += 1\n  end", "  words.each_with_index.inject(0)\
    \ { |s, (_, i), i| s + i }\n  .to_a.sort.last || ''\nend", "  words.uniq.sort!\
    \ do |a, b|\n    a.size <=> b.size\n  end\n  return words[0, words.size - 1]\n\
    end\n</cell>\n<text>\nLet's see how it works:", "  words.size!=0\n  words.length!=0\n\
    \  words[0].length!=0\n  result=0\n  count=0\n  words.each do |word|\n    count=0\n\
    \    word.each_char do |c|\n      count+=1\n    end\n    if count>result\n   \
    \   result=count\n    end\n  end\n  if count==result\n    words[0]\n  else\n \
    \   result\n  end\nend", "  words.uniq.sort!\n  words.uniq.each do |word|\n  \
    \  word.chars.group_by(&:itself).max_by { |_, v| v.size }.first\n  end\nend",
  "  sorted_words = words.sort.uniq\n  sorted_words.max || words[0]\nend", "  # Your\
    \ code here\n  max = \"\"\n  max_count = 0\n  for i in words[0]\n    if i.count\
    \ == max_count\n      max == i\n      break\n    else \n      if i.count > max_count\n\
    \        max_count = i.count\n        max == i\n      end\n    end\n  end\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nAs an aside, I think that your solution can\
    \ be improved by using a Hash instead of an array.  It will make finding the maximum\
    \ much more efficient if you have repeated words in the array.\n<|/ c |>\n<| a\
    \ tags=ruby,string,arrays |>\n<code>", "  max_count = 0\n  max_word = \"\"\n \
    \ words.each do |word|\n    word.chars.uniq.each do |c|\n      count = word[c].to_i.to_s.length\n\
    \      if count > max_count or max_count == 0\n        max_count = count\n   \
    \     max_word = word\n      end\n    end\n  end\n  return max_word\nend\n</code>\n\
    <|/ a tags=ruby,arrays |>\n<| a tags=ruby,arrays |>\nThis is a more Ruby way of\
    \ doing it\n<code>", "  return words[words.group_by{|x| x.chars.length}.max{|a,b|\
    \ a.chars.join.to_i<=>b.chars.join.to_i}.key]\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nI do not agree with that `a<=>b` is better than `b.chars.join.to_i<=>a.chars.join.to_i`.\
    \ It returns `[['a', 'b'], ['c', 'a']]` instead of `[['a', 'b'], ['c', 'b']]`.\
    \ I think that `join.to_i` is less efficient than `chars.count` here.\n<|/ c |>\n\
    <| c |>\nI agree that `join.to_i` would probably be faster. Although, that would\
    \ also be true if `chars.count` were more efficient, since `chars` is an Array\
    \ method and `chars.length` is an Array property\n<|/ c |>\n<| c |>\nIn fact `chars.join`\
    \ is more efficient than `chars.length`.\n<|/ c |>\n<| c |>\n`a<=>b` is better\
    \ than `b.chars.join.to_i<=>a.chars.join.to_i` is also true with `count`. You\
    \ just compare `count` with `join.to_i`. `chars.count` is more efficient than\
    \ `chars.length`.\n<|/ c |>\n<| a dscore=1 tags=ruby,sorting,string |>\nYou can\
    \ use Enumerable#sort_by and Enumerable#max_by, e.g.:\n<code>\nwords = [\"name\"\
    , \"of\", \"string\"]\nsorted_words = words.sort_by { |w| w.chars.count }\nsorted_words.max_by\
    \ { |w| w.chars.count }", "  max_count = 1\n  max_str = nil\n  words.each do |word|\n\
    \    str_count = word.length\n    str_count.times do |i|\n      if str_count-i\
    \ == max_count then max_str = word end\n      str_count -= 1\n    end\n    if\
    \ str_count > max_count then max_count = str_count end\n  end\n  max_str\nend\n\
    </cell>\n<cell>\nfind_max.call([\"name\", \"of\", \"string\"])\n</cell>\n<cell>\n\
    find_max.call([\"name\", \"enam\", \"game\"])\n</cell>\n<cell>\nfind_max.call([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n</cell>\n<cell>", "  result = 0\n  word.each do |word|\n\
    \    result +=1 if word.count > result\n  end\n  return result > 0 ? word : nil\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThank you very much, it is what I was looking\
    \ for! :)\n<|/ c |>\n<| c |>\nThe result should be an array with only one element,\
    \ and it should be the element which comes first in lexicographical order.\n<|/\
    \ c |>\n<| c |>\nThanks for the comment. Added the array as return value in `find_max`.\
    \ But I guess you meant something else. Added the test case to my answer.\n<|/\
    \ c |>\n<| a tags=ruby dscore=0 |>\nA possible answer to your question can be\
    \ found here:\n<code>", "  \n  unique = words.uniq.count\n  if unique > unique_count\n\
    \    unique_count = unique\n    max_value = words.uniq.first\n  elsif unique ==\
    \ unique_count\n    max_value = words.uniq.first\n  end", "  counter = Hash.new(0)\n\
    \  words.each do |word|\n    word = word.to_s.downcase\n    counter[word] += 1\n\
    \  end\n  counter.max_by{ |word, count| count }\nend", "  letters = {}\n  words.sort.each\
    \ do |word|\n    word.chars.uniq.each do |letter|\n      letters[letter] ||= 0\n\
    \      letters[letter] += 1\n    end\n  end\n  letters.max_by { |k, v| v }.first\n\
    end\n</pre>", "  letters = letters_count(words)\n  max_letters = letters.max_by\
    \ { |k, v| v }\n  return max_letters.last if max_letters.size > 1\n  max_letters.first\n\
    end", "  return words.group_by { |s| s.count(\"a\") }.max_by { |_, v| v.size }\n\
    end", "  unique.clear words\n  unique_characters = []\n  word = \"\"\n  length\
    \ = 0\n  words = words.clone\n  while length < words.length\n    word = words[length]\n\
    \    unique_characters = []\n    length = length + 1\n    unique.each do |word|\n\
    \      unique.each do |word|\n        unique_characters.each do |character|\n\
    \          word.include? character if word.include? character\n        end if\
    \ word.include? character\n      end if word.include? character\n    end if word.include?\
    \ character\n    unique_characters.push(character) if character in unique_characters\n\
    \    if unique_characters.length >= word.length\n      break\n    end if unique_characters.length\
    \ >= word.length\n    unique.push(word) if unique_characters.length >= word.length\n\
    \  end\n  unique.sort do |word1, word2|\n    word1.length < word2.length\n  end\n\
    \  unique.first\nend\n</cell>\n<text>\nProblem 3\nYou are given an array of integers\
    \ that represents characters of a string. You need to find the longest word possible\
    \ in the array. The word must be formed of same characters in the same order and\
    \ must not be a substring of any other word. Return the longest word in string.",
  "  max_value = words.max_by(&:length).length\n  words.sort.reverse.find { |word|\
    \ word.length == max_value }\nend", "  words.each_with_index.max_by do |word,\
    \ index|\n    word.count(\"a\").to_i + (word.count(\"A\") + 1)\n  end\nend\n</code>\n\
    <|/ a dscore=0 tags=algorithm,ruby,arrays |>\n<| c |>\nIt seems that your solution\
    \ is faster than mine. I compared your code against mine, it's faster than yours.\
    \ I wonder where is the reason of this.\n<|/ c |>\n<| c |>\nThis is because the\
    \ algorithm is naive. There are many many `O(N^2)` operations (there are many\
    \ words in an array), which is slower than `O(N)`.\n<|/ c |>\n<| a |>\nYou can\
    \ try this as well:\n<code>", "  hash = {}\n  words_by_count = words.group_by{|word|\
    \ word.chars.uniq.size}.max{|_, word| word.chars.uniq.size}\n  words_by_count.each{|word,\
    \ count|\n    hash[word] = count\n  }\n  words_by_count.each do |word, count|\n\
    \    index = words.index { |w| w == word }\n    words[index].uniq.length == count\
    \ and words.delete_at(index+1)\n  end\n  words_by_count.count.to_f == words.max_by(&:size).size\
    \ ? words[words.index{|w| w == words.max_by(&:size).size}] : nil\nend", "  words\
    \ = [\"a\",\"b\",\"a\",\"b\"]\n  words.select do |word|\n    word.to_s.split(//).uniq.size\
    \ >= words.uniq.size\n  end\nend", "  return words[0,1] if words.size > 1 && (words[0,1].size\
    \ < words[0,2].size) \n  else\n    words[0,1]\nend\n</cell>\n<cell>", "  counts\
    \ = Hash.new(0)\n  words.each do |word|\n    counts[word] += 1 if counts[word]\
    \ > 0\n  end", "  sorted = words.sort { |a,b| b.length <=> a.length }\n  max =\
    \ 0\n  sorted.each do |word|\n    if word.length > max then max = word.length\n\
    \  end\n  return max\nend", "  words.group_by {|x| x.count(\"a\") + x.count(\"\
    e\") + x.count(\"i\") + x.count(\"o\") + x.count(\"u\")}.max_by {|x, v| v}\nend\n\
    </code>\n<|/ a tags=ruby,string |>\n<| a tags=ruby,string |>\nHere is my solution:\n\
    <code>", "  uniques = {}\n  max_word = nil\n  words.each do |word|\n    uniques[word]\
    \ = uniques[word].to_i + 1 if uniques[word]\n    uniques[word] = 1 if !uniques[word]\n\
    \  end\n  uniques.max_by{|k, v| -v}.first\nend", "  return words.uniq.compact.inject(:<<).to_s.reverse\
    \ \nend", "  words.inject(0) do |memo, word|\n    memo.zero? || (memo.zero? &&\
    \ memo == word.size)\n  end\nend", "  chars = words.map(&:length).uniq.sort\n\
    \  word = chars.max { |a, b| a.length <=> b.length }.first\n  words.select { |w|\
    \ w == word || w.length == chars[chars.index(w)].length }[0]\nend", "  chars =\
    \ words.uniq.length\n  words.sort { |a,b| chars <=> a.length <=> b.length }\n\
    \  words[0]\nend", "  words.group_by(&:length).max_by { |_, v| v.size }.first\n\
    end", "  words.reduce(:min)\nend", "  sorted_words = {}\n  sorted_words.default\
    \ = []\n  sorted_words.each{ |word| sorted_words[word] += 1 }\n  sorted_words.each{\
    \ |word|\n    sorted_words[word] = sorted_words[word].to_i\n  }\n  sorted_words.each{\
    \ |word, count|\n    if count == sorted_words[word]\n      return word\n    end\n\
    \  }\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThe first thing I would say is\
    \ you should be careful when asking questions, you might get negative responses\
    \ because your question doesn't follow the standards of stackoverflow.\n<|/ c\
    \ |>\n<| c |>\nHow does it matter how you write your questions? This is your blog,\
    \ I will update as my question changes. Thanks for your advice.\n<|/ c |>\n<|\
    \ c |>\nThe thing is that if you don't follow the community guidelines of stackoverflow,\
    \ you might get downvotes. It's not my fault, it's just something that comes to\
    \ mind when asking questions. I apologize if I came across as harsh.\n<|/ c |>\n\
    <| c |>\nI do apologize for that. I did not realize that downvotes are so serious.\
    \ I have learned that lesson from you. Thanks for your time! I will keep that\
    \ in mind next time I am asking questions.\n<|/ c |>\n<| a tags=ruby,algorithm\
    \ |>\nMy solution:\n<code>", "  chars = chars(words).uniq.length\n  words.each_with_object({})\
    \ do |word, memo|\n    memo[word] = chars.size > chars[word] ? word : nil\n  end[words.min]\n\
    end", "  sorted_words = []\n  word_dict = {}\n  words.each do |word|\n    word_dict[word.length]\
    \ = word if word_dict.has_key?(word.length)\n  end\n  sorted_words = [word_dict[word_dict.values.max]]\
    \ if word_dict.has_key?(word_dict.values.max)\n  sorted_words.each do |word|\n\
    \    sorted_words = sorted_words.select { |word| word.include?(word) }\n    break\
    \ if sorted_words.length == 0\n  end\n  sorted_words.max\nend\n</code>\n<|/ a\
    \ tags=algorithm,ruby,hash |>\n<| c |>\nWhile this technically answers the question,\
    \ this is not the best way to solve this problem. Although this solves the problem,\
    \ it would be much better to give the OP a solution that doesn't rely on hashes.\n\
    <|/ c |>\n<| c |>\nThanks. I agree that this solution is not very efficient.\n\
    <|/ c |>\n<| c |>\nThis solution is inefficient. Hashes are inefficient for many\
    \ purposes. To understand why, you must understand the hash table and its complexity\
    \ characteristics. When you have a hash table, each lookup is `O(1)`. But in your\
    \ solution, each lookup is `O(n)`, where `n` is the number of unique character\
    \ in the string. You have to remember that you are iterating through the string's\
    \ unique character list, and each iteration is `O(n)`. So overall your solution\
    \ is `O(n^2)`! See also: https://en.wikipedia.org/wiki/Hash_table\n<|/ c |>\n\
    <| c |>\nAgreed. I'll edit my answer.\n<|/ c |>\n<| c |>\nI think this is a more\
    \ elegant solution than my hash-based solution. The only modification I would\
    \ make is to replace the `word_dict[word.length]` with `word_dict[word.downcase]`\
    \ to ensure that case is retained for strings longer than 4 characters.\n<|/ c\
    \ |>\n<| a tags=algorithm,ruby,hash dscore=2 |>\nUse a hash to store the unique\
    \ lengths of words as keys. Then you can keep track of the most repeated length\
    \ and its corresponding word by iterating through the hash's keys. When a length\
    \ has gone over its maximum, clear the key's entry and store the new most repeated\
    \ length with the new word as the value. \n<code>\nwords = [\"the\", \"and\",\
    \ \"of\", \"a\"]\nword_count = Hash.new(0)", "  return words.sort.first(2).map\
    \ { |word| word.count(word[0]) }.reverse.first\nend\n</code>\n<|/ a |>\n<| a dscore=1\
    \ |>\nIt was a fun challenge! I used Ruby on Rails (4.1.0), a combination of Hash\
    \ and Enumerator to get this solution.\n<code>", "  words.each_with_object(Hash.new(0))\
    \ { |w, hash| hash[w] += 1 }\n          .max_by { |w| hash[w] }\nend", "  unique_chars\
    \ = Set.new\n  unique_chars.merge! words[0]\n  max_size = 0\n  max_index = 0\n\
    \  words.each_with_index do |word, index|\n    unique_chars.merge! word\n    unique_chars.uniq!\n\
    \    if unique_chars.size > max_size\n      max_size = unique_chars.size\n   \
    \   max_index = index\n    end\n  end\n  words[max_index]\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nPlease explain what your code is doing. This way it won't be obvious\
    \ for someone who reads your answer.\n<|/ c |>\n<| c |>\n, Thank you! I will add\
    \ an explanation!\n<|/ c |>\n<| c |>\n\"If multiple strings have maximum number\
    \ of unique characters, return the one which comes first in lexicographical order.\"\
    \n<|/ c |>\n<| a dscore=0 tags=ruby,algorithm |>\n<code>", "  chars = {}\n  words.each\
    \ do |word|\n    word.each_char do |char|\n      chars[char] ||= 0\n      chars[char]\
    \ += 1\n    end\n  end\n  char = chars.max_by { |k, v| v }\n  chars[char] || nil\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby |>\nThis code does not require\
    \ any external gems, and it also does not sort the string alphabetically, but\
    \ rather counts the frequency of the letters. \nIt uses hash to store the frequency\
    \ of each letter, and uses Enumerable#group_by method instead of Hash#each_with_object.\
    \ I believe it's more efficient than the other answer. \n<code>", "  max_word\
    \ = nil\n  max_count = 0\n  words.each do |word|\n    count = word.length\n  \
    \  if count > max_count\n      max_count = count\n      max_word = word\n    end\n\
    \  end\n  return max_word\nend", "  result = nil\n  words.each do |word|\n   \
    \ letters = word.split(\"\").uniq.count\n    if letters > result \n      result\
    \ = letters\n    end\n  end\n  words.each do |word|\n    letters = word.split(\"\
    \").uniq.count\n    if letters == result\n      result = word\n    end\n  end\n\
    \  result\nend", "  max_char = nil\n  max_val = nil\n  \n  words.each_with_index\
    \ do |word, i|\n    \n    char_array = word.to_s.chars.uniq", "  words.size==0\
    \ ? nil : words.uniq.size\nend", "  chars = chars.dup\n  words.each_with_object([[\"\
    \", 0]]) do |word|\n    chars.zip(word).each do |a,b|\n      c = a.to_i.chr\n\
    \      word[b.to_i] = word[b.to_i].to_i + 1\n      word[b.to_i] = c if word[b.to_i]\
    \ < word[a.to_i]\n    end\n    chars.clear\n  end\n  words.find do |word, count|\n\
    \    count.to_i == words.size\n  end[0]\nend\n</cell>\n<text>\nWe can use the\
    \ inject method on the array to get the maximum count of unique characters.",
  "  unique_chars = {}\n  max_length = 0\n  max_string = \"\"\n  words.each do |word|\n\
    \    word.chars.uniq.each do |char|\n      if max_length < char.length\n     \
    \   max_length = char.length\n      end\n      if unique_chars[char].nil?\n  \
    \      unique_chars[char] = 0\n      else\n        unique_chars[char] += 1\n \
    \     end\n    end\n  end\n  unique_chars.each_value do |v|\n    if v > unique_chars.values.max\n\
    \      max_string = words.find { |word| word.length > v }\n    end\n  end\n  max_string.nil?\
    \ ? nil : max_string\nend", "  max_length = words[0].count\n  unique_characters\
    \ = words.map(&:uniq.length).max\n  words.each do |word|\n    word_length = word.count\n\
    \    if word_length > max_length || word_length == unique_characters\n      max_length\
    \ = word_length\n      word = word.gsub(/[^a-z]/i, '')\n    end\n  end\n  return\
    \ word\nend", "  # write your code in Ruby\n  words.max_by(&:length).to_s.downcase\n\
    end", "  words.sort(&:length).map(&:first).uniq.length.last\nend", "  words.map(&:split).inject([])\
    \ { |list, words| list << words.uniq.count if list.empty? || list.last.uniq.count\
    \ == words.uniq.count }.reverse.first\nend", "  max = 0\n  words.size\n  words.each\
    \ do |word|\n    char_count = Hash.new(0)\n    word.split('').each { |char| char_count.update(char=>1)\
    \ }\n    if char_count.values.uniq.count == max\n      max = char_count.values.uniq.count\n\
    \    end\n  end\n  words[max-1]\nend\n</cell>\n<text>\nMore on Arrays\nIn case\
    \ you wonder how to use arrays in Ruby, here's a short introduction. You don't\
    \ need to understand all this code right away, but it's still a good place to\
    \ start.", "  # TODO Implement this\nend", "  # Your code here\n  maximum = words.inject(0){|max,\
    \ elem| elem == words[max].split(//).uniq.size ? elem : max }\n  words.sort_by{|i|\
    \ i.split(//).uniq.size}.first(maximum)\nend\n</code>\n<|/ a tags=string,ruby,arrays\
    \ |>\n<| a dscore=3 tags=string,ruby,arrays |>\n<code>\na = [\"aa\",\"ab\",\"\
    ac\",\"ad\",\"b\",\"bb\",\"c\"]\na.uniq.sort\n</code>\n<|/ a |>\n<| a dscore=3\
    \ tags=string,ruby,arrays |>\nThis works for me for most cases, although there\
    \ are some edge cases that throw up errors.  For instance:\n<code>\na = [\"aa\"\
    ,\"ab\",\"ac\",\"ad\",\"b\",\"bb\",\"c\"]\na.uniq", "  max_count = 0\n  max_word\
    \ = nil", "  words.sort.each do |word|\n    word.chars.uniq.count.to_i == word.chars.uniq.size\
    \ ? max_word = word : nil\n  end\n  max_word\nend\n</code>\n<|/ a |>\n<| c |>\n\
    This is a nice solution, but I think it would be a good idea to add a little explanation.\
    \ Also, the OP asked for the word with the maximum character count which means\
    \ there should be a `max` method that returns only one word (or nil if no word\
    \ has the highest character count).\n<|/ c |>\n<| c |>\nI agree with you, I've\
    \ updated my answer with explanation.\n<|/ c |>\n<| a dscore=1 |>\nAnother possibility\
    \ would be:\n<code>\nwords.sort_by { |word| word.chars.uniq.size }.last\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nNot bad, but doesn't work. `sort_by` returns an array,\
    \ so `last` will give you the first element of that array. I think you want `max`.\n\
    <|/ c |>\n<| a |>\n<code>", "  unique = {}\n  words.each do |word|\n    word.chars.each\
    \ do |char|\n      if unique.has_key?(char)\n        unique[char] += 1\n     \
    \ else\n        unique[char] = 1\n      end\n    end\n  end\n  unique.sort {|a,b|\
    \ b.last <=> a.last }\nend\n</cell>\n<text>\nThe \"unique\" variable is a dictionary\
    \ containing all unique characters in all words in the given array. Each key in\
    \ the dictionary contains the character and the value is a count of the number\
    \ of occurrences of that character. Using the method \"sort\" on the list, we\
    \ can sort the dictionary by its keys in ascending order.", "  words.map {|word|\
    \ word.length.uniq.length}\n  words.sort{|a,b| b.length <=> a.length}.first\n\
    end\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nYour answer does not handle\
    \ duplicate maximum values correctly.\n<|/ c |>\n<| c |>\n- thanks for noticing.\
    \ I've fixed it now.\n<|/ c |>\n<| c |>\n`count` is an alias for `count` so you\
    \ can also write `words.map(&:count).max`\n<|/ c |>\n<| c |>\nI still get `undefined\
    \ method `length' for \"name\":String` in Ruby 2.3.8\n<|/ c |>\n<| a |>\nTo handle\
    \ duplicate maximum values:\n<code>", "  word = words.sort_by {|e| e.length }.first\n\
    \  word = word.length if word.blank?\n  word.gsub(/[aeiou]/, '').downcase if word\n\
    end", "  unique_chars = {}\n  unique_chars.default_proc = Proc.new { |key,| 0\
    \ }\n  words.each { |word| unique_chars[word] = unique_chars[word].to_i + 1 }\n\
    \  unique_chars.sort_by{|key,| -key }.first\nend\n</code>\n<|/ a dscore=1 tags=arrays,ruby\
    \ |>\n<| c |>\n`words.inject(Hash.new(0)) { |h,w| h[w] += 1 }.values.max` - this\
    \ is another nice solution. I didn't know `inject` method and I like how you used\
    \ `h[w]+=1`.\n<|/ c |>\n<| c |>\n, why not just `words.size` instead of `words.each.with_index\
    \ { |word, i| words[i] }.length`? And why `each` instead of `inject` when you\
    \ can just `map` it?\n<|/ c |>\n<| c |>\n, you're right `words.size` is faster,\
    \ I've updated my answer. Also I've changed `inject` with `map`\n<|/ c |>\n<|\
    \ c |>\n, thank you. As I remember, I wanted to have as little as possible, but\
    \ now I realized that `map` also creates enumerator, so my code has less code\
    \ :)\n<|/ c |>\n<| a tags=arrays,ruby dscore=0 |>\n<code>\narr = [\"car\", \"\
    carpet\", \"carr\", \"cart\", \"carr\", \"carpet\"]\narr.uniq.max_by(&:length)",
  "  max_length = 0\n  result = nil\n  words.each do |word|\n    word.chars.uniq.each\
    \ do |char|\n      if max_length < word.length\n        max_length = word.length\n\
    \        result = word\n      end\n    end\n  end\n  result\nend\n</cell>\n<cell>",
  "  words.length.times do |i|\n    max = words[i].length\n    words.delete_at(i).each_with_index\
    \ do |word, j|\n      if word.length < max then\n        max = word.length\n \
    \       word = words[j]\n      end\n    end\n    words.insert(i, word)\n  end\n\
    \  words[0]\nend\n</code>\n<|/ a |>\n<| c |>\nThis isn't what the OP asked, they\
    \ are asking for the word, which has the most letters based on the length of the\
    \ string. For example, the word `word` has 13 letters so `word.length` is 13.\n\
    <|/ c |>\n<| c |>\nBut `word` has 13 characters, not 13 letters.\n<|/ c |>\n<|\
    \ c |>\nyeah sorry, I misread his question. He should clarify his question then.\n\
    <|/ c |>\n<| c |>\nThe OP says \"Return the word with maximum number of unique\
    \ characters\"\n<|/ c |>\n<| a dscore=0 tags=ruby |>\n<code>", "  words.each_with_object({})\
    \ { |w, h| h[w] = w.chars.uniq.size }\n    .max_by { |k, v| v }\n    .last\nend",
  "  result = nil\n  words.each do |word|\n    result ||= word\n    next if word.size\
    \ < result.size\n    word.chars.uniq.each { |c|\n      result = word if c.size\
    \ < result.size\n    }\n  end\n  result\nend", "  words.inject([:first]) {|t,s|\
    \ t.max{|a,b| a.length<b.length ? -1 : a.length<b.length ? a.length : b.length}\
    \ }\nend\n</cell>\n<code language=ruby-3>", "  return words[max_index(words)]\n\
    end", "  chars = Set.new\n  words.each do |word|\n    chars.merge(word.split(//)).count\n\
    \  end\n  \n  words.max_by { |word| chars.merge(word.split(//)).count }\nend",
  "  words.inject(0) do |max, word|\n    max = max + word.scan(/[+-]?\\d+/).size\n\
    \    max\n  end\nend\n</pre>", "  max_count = words.length\n  max_word = nil\n\
    \  words.each do |word|\n    count = (word.split(//).length).to_i\n    if (count\
    \ > max_count)\n      max_count = count\n      max_word = word\n    end\n  end\n\
    \  return max_word\nend", "  max_char = words[0].length\n  max_word = nil\n  max_word\
    \ = words.first if words.first.eql?(words[0])\n  words.each do |word|\n    word.chars.each\
    \ do |char|\n      break if max_char > char.length\n      max_char = char.length\n\
    \      max_word = word if word.eql?(word)\n    end\n  end\n  max_word\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails-3,arrays,sorting |>\n<| c |>\nI believe this is\
    \ a much better solution. It will also work on words that have numbers in them,\
    \ such as \"2nd\"\n<|/ c |>\n<| c |>\nThanks guys, but I guess this is something\
    \ Ruby doesn't have?\n<|/ c |>\n<| c |>\nI really don't think so. I'm sure there\
    \ might be some regex that would return such words in different order, but I'm\
    \ not sure that would be better than just sorting..\n<|/ c |>\n<| c |>\nOk, then\
    \ I'll use your solution, since it looks like it should work\n<|/ c |>\n<| a dscore=0\
    \ |>\nYou can use the following code:\n<code>\narray=[\"name\", \"enam\", \"game\"\
    ]\narray.sort_by do |word|\n  word.split(//).uniq.size\nend\n</code>\nIf you don't\
    \ want the last word, you can use:\n<code>\narray=[\"name\", \"enam\", \"game\"\
    ]\narray.sort_by do |word|\n  word.split(//).uniq.size.reverse\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails-3,arrays,sorting |>\n<| c |>\nThe OP asked for the\
    \ word with the most unique characters, not the most unique characters.\n<|/ c\
    \ |>\n<| c |>\nThanks, but this doesn't work well if there are two or more words\
    \ with the same number of unique characters.\n<|/ c |>\n<| c |>\nYes, I agree,\
    \ but I don't see another way to do it other than sorting and checking the first\
    \ word.\n<|/ c |>\n<| c |>\nAh... yes, I missed that part. Sorry. I was trying\
    \ to answer the question before I saw the comment to another answer.\n<|/ c |>\n\
    <| a dscore=0 |>\nThis is another way to solve the problem. \n<code>\narr = [\"\
    name\", \"enam\", \"game\"]", "  return words.sort.last.uniq.length if words.sort.last.uniq.length\
    \ == words.sort.last.length else\n    words.sort.last.uniq.first\nend", "  return\
    \ words.sort.max{|a, b| a.length <=> b.length}\nend", "  max_count = 0\n  max\
    \ = ''\n  \n  words.each do |word|\n    if word.size > max_count\n      max_count\
    \ = word.size\n      max = word\n    end\n  end\n  \n  max\nend\n</cell>\n<cell>",
  "  words.max_by { |w| w.uniq.size }\nend\n</cell>\n<text>\nThe map method creates\
    \ a new array with the results of running a block.", "  words = words.reject {\
    \ |w| w =~ /^[a-z]+$/ }\n  words_and_counts = words.group_by { |w| w.length }\n\
    \  max_count = words_and_counts.values.max\n  max_count.each { |word_count| words_and_counts.delete(word_count)\
    \ }\n  return nil unless words_and_counts\n  word = words_and_counts.values.min.last\n\
    \  if word\n    word = word.first\n    words_and_counts.delete(word)\n  end\n\
    \  words_and_counts.values.each { |count| words_and_counts.delete(count) }\n \
    \ return word\nend", "  unique = {}\n  word.to_enum(:each_char).with_index.inject(0)\
    \ { |result, (c, n)| if !unique[c] then unique[c] = n; result else unique[c] >\
    \ n ? unique[c] : result end}\n  words.max { |word1, word2| word1.chars.uniq.size\
    \ == word2.chars.uniq.size ? word1.chars.uniq.size : word1.chars.uniq.size <=>\
    \ word2.chars.uniq.size }\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,sorting,algorithm\
    \ dscore=0 |>\nThe solution I came up with is the following:\n<code>", "    words\
    \ = (words) ? words : []\n    unique_chars = []\n    unique_chars_count = {}\n\
    \    unique_chars_array = []", "  # Write your code here.\n  counts = Hash.new(0)\n\
    \  words_with_char_count = words.inject(counts){ |c,w| c[w] = c[w] + 1 if c.has_key?(w)\
    \ }\n  words_with_char_count.max_by { |k,v| v } \nend", "  max_count = words[0].length\n\
    \  max_word = words[0]\n  max_idx = 0\n  \n  1.upto(words.length-1) do |i|\n \
    \   counts = Hash.new(0)\n    words.each do |word|\n      counts[word] += word[i].length\n\
    \    end\n    counts = counts.select { |key, value| value > max_count }\n    \n\
    \    max_idx = i if counts.empty?\n    max_count = counts.last[1] if counts.last?\n\
    \    max_word = counts.last[0] if counts.last?\n  end\n  \n  max_word\nend", " \
    \ uniques = Hash.new(0)\n  uniques_indexes = []\n  max_length = 0\n  index = 0\n\
    \  words.each do |word|\n    if uniques[word]\n      uniques_indexes[index] =\
    \ uniques[word]\n      uniques[word] += 1\n    elsif uniques[word] == 0\n    \
    \  uniques[word] = 1\n      uniques_indexes[index] = word\n      max_length +=\
    \ 1\n    end\n    index += 1\n  end\n  if uniques_indexes.count == 0\n    uniques_indexes.push(words[0])\n\
    \  end\n  return uniques_indexes[max_length - 1]\nend\n</code>\n<|/ a |>\n<| c\
    \ |>\nThank you! Your answer is much more elegant than mine, so I have upvoted\
    \ it. The only thing is that it is limited to string lengths of up to about 20\
    \ characters. I am planning to extend this implementation to solve this problem.\
    \ Thank you again!\n<|/ c |>\n<| a tags=string,ruby dscore=0 |>\nHere's a variation\
    \ on Tin Man's answer. Not very elegant, but I think it might help.\n<code>",
  "  max = nil\n  count = 0\n  words.each do |word|\n    if word.length < count\n\
    \      max = word\n      count = 1\n    elsif word.length > count\n      max =\
    \ word\n      count = word.length\n    end\n  end\n  return max\nend", "  # TODO:\
    \ Write the code here.\n  raise NotImplementedError()", "  words.sort.reverse.uniq.length.last\n\
    end", "  return words.sort.max_by { |e| e.uniq.size }\nend\n</cell>\n<cell>\n\
    @test find_max.call([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\n</cell>\n<text>\n\
    The other method of Arrays module is max_by which returns the word with maximum\
    \ number of\nunique characters. Use this method if you find this easier to understand:",
  "  words.sort.map!{ |s| s.length }\n  return words.max { |a, b| a.length <=> b.length\
    \ } \nend\n</cell>\n<cell>\nfind_max.call([\"aaaaaaa\", \"bb\", \"cc\"])\n</cell>\n\
    <cell>\nfind_max.call([\"name\", \"of\", \"string\"])\n</cell>\n<cell>\nfind_max.call([\"\
    name\", \"enam\", \"game\"])\n</cell>\n<cell>", "  max = 0\n  word = \"\"\n  max_index\
    \ = 0\n  word_count = {}\n  words.each do |word|\n    word_count[word] = word_count.has_key?(word)\
    \ ? word_count[word] + 1 : 1\n    if word_count.has_key?(word) && (word_count[word]\
    \ > max) && (word_count[word] < 100) \n      max = word_count[word]\n      word\
    \ = word\n      max_index = word_count.keys.find_index(word)\n    end \n  end\n\
    \  return word\nend", "  word_counts = Hash.new(0)\n  words.each do |word|\n \
    \   word_counts[word] += 1\n  end\n  max_key = word_counts.max_by { |k, v| v }\n\
    \  max_key.nil? ? nil : word_counts.max_by { |k, v| v }[1]\nend", "  words.reduce(:*)\n\
    end", "  words.inject(0, Hash.new(0)) do |max, word|\n    word.length.upto(max.last)\
    \ do |i|\n      max[i] += 1\n    end\n    max\n  end\nend", "  max_count = words.length\n\
    \  max_word = nil\n  words.each do |word|\n    count = word.length\n    if count\
    \ > max_count then\n      max_count = count\n      max_word = word\n    end\n\
    \  end\n  max_word\nend", "  sorted = words.map(&:sort).flatten\n  max = sorted.reduce(0,\
    \ :&)\n  sorted.select { |s| s.size < max }.first || sorted[0]\nend\n</pre>\n\
    </div>\n</div>\n</div>\n</div>\n<div class=\"cell border-box-sizing text_cell\
    \ rendered\"><div class=\"prompt input_prompt\">\n</div>\n<div class=\"inner_cell\"\
    >\n<div class=\"text_cell_render border-box-sizing rendered_html\">\n<p>The first\
    \ function returns the longest word in an array.</p>", "  unique = {}\n  word.uniq.each\
    \ do |word|\n    unique[word] = unique[word].length unless unique[word].include?(word)\n\
    \    unique[word] ||= 0\n    unique[word] += 1\n  end\n  unique.sort.first\nend",
  "  words.sort.reverse.inject(nil) {|max_word,word|\n    word.each_char.uniq.count{|c|c>max_word}.nil?\
    \ ? word : max_word\n  }\nend\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| a tags=ruby\
    \ dscore=1 |>\n<code>\na = [ \"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\" ]\na.sort{|x,y|\
    \ x.size <=> y.size }", "  return words.sort {|a,b| a.length <=> b.length}.uniq.length\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis does not give the correct result.\
    \ Try `[\"a\",\"b\",\"a\",\"b\",\"c\"]`\n<|/ c |>\n<| c |>\nI tested it and works.\
    \ What is the incorrect result?\n<|/ c |>\n<| c |>\nAh, yes. You're right. Sorry.\
    \ Not sure why I thought that'd be the case. I should probably test before posting\
    \ :(\n<|/ c |>\n<| c |>\nIt would probably be faster to use `Array#<=>`\n<|/ c\
    \ |>\n<| c |>\nThe OP asked for \"the word with maximum number of unique characters\"\
    \ not the number of unique characters\n<|/ c |>\n<| a dscore=0 |>\nI wrote a solution\
    \ for you. It works pretty good. The solution is iterative and recursive.\n<code>",
  "  words_to_sort = words.sort.sort\n  words_to_sort.each_with_index do |word, i|\n\
    \    word.each_char.uniq.size == words_to_sort[i].each_char.uniq.size ? word :\
    \ nil\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=ruby,algorithm\
    \ |>\nI wrote an approach using Ruby but this should work in most other languages\
    \ as well.\n<code>", "  max_length = words.max_by { |s| s.length }.length\n  words.sort!.take(1).each\
    \ { |s| return s if s.length == max_length }\nend\n</cell>\n<text>\nSum & Average\n\
    Write a function that accepts an array of integers and returns the sum of all\n\
    the numbers in the array. The function should accept both integers and floats\n\
    as arguments. In case of input values other than those of the type int,\nfloat,\
    \ convert them to an integer.", "  words.uniq.length\n  words.min_by { |w| w.length\
    \ }\nend", "  sorted = words.map(&:to_s)\n  sorted.uniq.length.max\nend", "  return\
    \ words.max_by(&:length).first\nend", "  words.inject(Hash.new(0)) {|h, k| h[k]\
    \ += 1; h}.max_by {|_,v| v}\nend", "  max_count = words.uniq.size\n  if max_count.zero?\n\
    \    nil\n  else\n    words[0]\n  end\nend", "  # TODO: Use helper function\n\
    \  sorted = words.sort_by { |word| word.length }\n  word = sorted.first\n  while\
    \ word\n    return word\n    word = sorted.shift\n  end\nend\n</code>\n<|/ a |>\n\
    <| c |>\n`words.max_by { |word| word.length }` also works in Ruby 1.8.7.\n<|/\
    \ c |>\n<| c |>\n: Thanks for the update! I was using 1.9 (which uses 1.8.7.)\n\
    <|/ c |>\n<| c |>\nAh, I thought I was on 1.8.7! Thanks for updating :-)\n<|/\
    \ c |>\n<| a dscore=4 |>\n<code>\na = \"abcdef ghijkl\".split(//)\na.uniq.max_by{|word|\
    \ word.length}\n</code>\n<|/ a tags=string,ruby |>\n<| c |>\nThis will also return\
    \ nil if the array contains no unique elements.\n<|/ c |>\n<| a |>\nRuby 1.8.7\
    \ uses Array#uniq which does what you want:\n<code>\np \"abcdef ghijkl\".split.uniq\n\
    </code>\nprints\n<code>\n[\"abcdef\", \"ghijkl\"]\n</code>\n<|/ a dscore=3 tags=string,ruby\
    \ |>\n<| a tags=string,ruby dscore=3 |>\n<code>\na = \"abcdef ghijkl\".split\n\
    a.sort.uniq.length\n</code>\n<|/ a |>\n<| c |>\nThis solution doesn't always work.\n\
    <|/ c |>\n<| a dscore=2 |>\nTo add up all the answers, I would suggest that you\
    \ use max_by as max_by is more Ruby-esque than max_or_first or min_or_last.\n\
    max_by will return only the element that has the maximum length. \n<code>\narray\
    \ = \"abcdef ghijkl\".split\narray.max_by(&:length) # => \"ghijkl\"\n</code>\n\
    <|/ a tags=string,ruby |>\n<| c |>\nThe question asked for the maximum word size,\
    \ not for the maximum length.\n<|/ c |>\n<| a tags=string,ruby dscore=2 |>\n<code>\n\
    a = \"abcdef ghijkl\".split\na.sort.uniq.max # => \"ghijkl\"\n</code>\n<|/ a |>\n\
    <| c |>\nThis doesn't work if there are two words that have the same max length\n\
    <|/ c |>\n<| c |>\n: It will give the second one. That's how `max` works.\n<|/"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
