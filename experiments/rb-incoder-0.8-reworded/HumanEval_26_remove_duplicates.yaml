name: HumanEval_26_remove_duplicates
language: rb
prompt: "# From an array of integers, remove all elements that occur more than once.\n\
  # Keep order of elements left the same as in the input.\n# >>> remove_duplicates.call([1,\
  \ 2, 3, 2, 4])\n# [1, 3, 4]\ndef remove_duplicates(numbers)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_remove_duplicates\n\
  \    candidate = method(:remove_duplicates)\n    assert_equal([], candidate.call([]))\n\
  \    assert_equal([1, 2, 3, 4], candidate.call([1, 2, 3, 4]))\n    assert_equal([1,\
  \ 4, 5], candidate.call([1, 2, 3, 2, 4, 3, 5]))\n  end\nend\n"
completions: ["  numbers.uniq!\n  numbers\nend\n</pre>\n            </div>\n     \
    \     </li>\n          <li>\n            <div data-class=\"method\" id=\"Method:remove-duplicates-for-enumerable\"\
    >\n              <h3 class=\"section-title\">Method:remove-duplicates-for-enumerable</h3>\n\
    \              <ul class=\"object-docs\">\n                <li>\n            \
    \      <code class='method-name method-doc'>\n                    remove_duplicates-for-enumerable\n\
    \                  </code>\n                  <code>\n                    <span\
    \ class=\"method-params\">\n                      <code>\n                   \
    \     <span class=\"method-param\">numbers</span>\n                      </code>\n\
    \                      <code class=\"method-signature\">\n                   \
    \     <span class=\"method-result\">\n                          <span class=\"\
    method-result-type\">\n                            <span class=\"method-result-type-name\"\
    >Array</span>\n                          </span>\n                        </span>\n\
    \                      </code>\n                    </span>\n                \
    \  </code>\n                </li>\n              </ul>\n              <p class=\"\
    return-value\">\n                Returns <code>numbers</code>.\n             \
    \ </p>\n              <p class=\"return-description\">\n                This method\
    \ is similar to <code>remove_duplicates</code>, however it returns an enumerator\
    \ instead.\n              </p>\n              <pre data-class=\"code\" data-code-language=\"\
    ruby\">", "  numbers.uniq!\nend", "  numbers = numbers.to_a\n  last_number = numbers.shift\n\
    \  numbers.uniq!", "  result = numbers.dup\n  numbers.map { |number| result -=\
    \ [number] unless result.include?(number) }\n  result\nend", "  numbers.inject([])\
    \ do |result, el|\n    result << el if result.count(el) < 2\n    result\n  end\n\
    end", "  numbers.uniq\nend", "  numbers.uniq.compact!\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=2 |>\nIn Ruby 2.7 you can use Array#minmax\n<code>\nrequire\
    \ 'minitest/autorun'", "  numbers_sorted = numbers.sort\n  index = 1\n  while\
    \ index < numbers_sorted.length\n    if numbers_sorted[index] == numbers_sorted[index\
    \ - 1]\n      numbers_sorted.delete_at(index)\n    else\n      index += 1\n  end\n\
    \  return numbers_sorted\nend", "  unique_hash = {}\n  numbers.each do |number|\n\
    \    unique_hash[number] = number if unique_hash.has_key?(number)\n  end\n  unique_hash.values\n\
    end\n</code>\n<|/ a dscore=3 tags=ruby,sorting,arrays,unique,duplicates |>\n<|\
    \ c |>\nNot quite the same as the question. `uniq` will return an array of unique\
    \ elements. Here, the question asked for an array of non-unique elements. The\
    \ solutions by and are better for what he asked for though.\n<|/ c |>\n<| a dscore=3\
    \ |>\n<code>\narr = [\"a\", \"a\", \"b\", \"c\", \"c\", \"c\", \"d\", \"e\"]\n\
    arr.select {|x| arr.count(x) > 1 }.sort", "  sorted = numbers.sort\n  result =\
    \ sorted.dup\n  index = 0\n  while index < sorted.size\n    found = false\n  \
    \  while index < result.size && !found\n      found = result[index] == sorted[index]\n\
    \      index = index + 1\n    end\n    if found\n      result.delete_at(index)\n\
    \    else\n      index = index + 1\n    end\n  end\n  result\nend", "  numbers_with_counts\
    \ = numbers.group_by{|x| x}.map{|_, v| v}\n  numbers_with_counts.select{|v| v.size\
    \ > 1}.map{|v| v.first}\nend", '  result = numbers.clone', "  numbers.uniq.sort_by!(&:to_s)\n\
    end", "  numbers.uniq!\n  numbers\nend", "  numbers_without_duplicates, unique\
    \ = {}, {}\n  numbers.each do |number|\n    if !numbers_without_duplicates[number]\n\
    \      numbers_without_duplicates[number] = true\n      unique[number] = true\n\
    \    end\n  end\n  numbers_without_duplicates\nend", "  numbers_to_remove = []\n\
    \  new_numbers = []", "  numbers.uniq!\nend\n</pre>\n          <p>\n         \
    \   Now that we have implemented the <code>remove_duplicates</code> method,\n\
    \            we can use it as a helper method.\n          </p>\n          <pre\
    \ class=\"language-bash\"><code class=\"language-bash\">$ rake add_duplicates\n\
    $ rake remove_duplicates\n</code></pre>\n          <p>\n            To actually\
    \ use these helper methods in our program, we can use them like so\n         \
    \   in our <code>lib/tasks/</code> directory:\n          </p>\n          <pre\
    \ class=\"language-bash\"><code class=\"language-bash\">$ rake add_duplicates:tasks\n\
    $ rake remove_duplicates:tasks\n</code></pre>\n          <p>\n            That\
    \ is all there is to it!\n          </p>\n          <h2 id=\"rake-tasks\">\n \
    \           Running Rake Tasks\n          </h2>\n          <p>\n            There\
    \ are many ways to run Rake tasks. Here are the two main ways you\n          \
    \  should look at running Rake tasks:\n          </p>\n          <ul>\n      \
    \      <li>\n              <strong>Via a bash script</strong>\n            </li>\n\
    \            <li>\n              <strong>Via the rake task</strong>\n        \
    \    </li>\n          </ul>\n          <p>\n            Both methods are described\
    \ in the next few sections.\n          </p>\n        </div>\n      </div>\n  \
    \  </div>\n  </section>", "  seen = {}\n  numbers.delete_if do |i|\n    seen[i]\
    \ = true if seen[i]\n    seen[i] = false\n  end\n  numbers\nend", "  numbers_with_count\
    \ = numbers.each_with_index.map do |number, index|\n    (numbers[index], number)\
    \ if number != index\n  end", "  new_numbers = []\n  numbers.each do |n|\n   \
    \ if new_numbers.include?(n)\n      next\n    end\n    new_numbers << n\n  end\n\
    \  return new_numbers\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| a |>\n<code>",
  "  numbers = numbers.dup\n  result = []\n  numbers << nil\n  numbers.each do |number|\n\
    \    result << number if result.include?(number)\n  end\n  result\nend", "   \
    \ unique = []\n    seen   = {}\n    numbers.each do |num|\n        if seen[num]\
    \ then\n            unique.push(num)\n        else\n            seen[num] = true\n\
    \        end\n    end\n    unique\nend", "  number_set = Hash.new(0)\n  numbers.each\
    \ {|x| number_set[x] += 1}\n  numbers.delete_if {|x| number_set[x] > 1}\nend",
  '  counts = Hash.new(0)', "  numbers_with_count = numbers.each_with_object(Hash.new(0))\
    \ { |number, counts| counts[number] += 1 }\n  numbers_with_count.reject { |number,\
    \ count| count == 1 }\nend", "  numbers.uniq!\n  numbers\nend", "  result = numbers.clone\n\
    \  last_index = numbers.size - 1\n  numbers.each_with_index do |number, index|\n\
    \    if (index == last_index) then\n      result.remove(number)\n    else\n  \
    \    result.insert_after(number, index)\n    end\n  end\n  result\nend\n</code>\n\
    <|/ a |>\n<| a dscore=0 tags=ruby |>\nHere is a quick one-liner that doesn't require\
    \ any additional modules:\n<code>\nnumbers = [1,1,3,3,4,5,5,7,8,9,9,9,9,9,10,11,12,12,14,14,14,14,14]",
  "    numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,arrays,unique,sorting dscore=4\
    \ |>\n<| c |>\nThanks for that answer.\n<|/ c |>\n<| c |>\nRuby 1.8.7 says `uniq`\
    \ is deprecated.\n<|/ c |>\n<| c |>\nI used uniq_by to replace uniq since Ruby\
    \ 1.8.7\n<|/ c |>\n<| c |>\nuniq_by is a method in Ruby 1.8.7: http://ruby-doc.org/core-1.8.7/Array.html#method-i-uniq_by\n\
    <|/ c |>\n<| c |>\nThis solution is perfect for Ruby 1.8.7, and will work for\
    \ 1.9.2.\n<|/ c |>\n<| a tags=ruby,arrays,unique,sorting |>\nMy take on it\n<code>\n\
    array = [4, 8, 6, 1, 3, 5, 7]\narray.inject([]) { |acc, e| acc << e if !acc.include?(e)\
    \ }\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis is really the most effective solution\
    \ for Ruby 1.9. Thanks!\n<|/ c |>\n<| a |>\n<code>\na = [1, 2, 3, 2, 4, 6, 3,\
    \ 6, 3, 6, 7, 3, 1]\na.inject([]) { |c, x| c << x if c.include?(x) }\n=> [3, 4,\
    \ 6, 6]\n</code>\n<|/ a tags=ruby,arrays,unique,sorting dscore=4 |>\n<| a tags=ruby,arrays,unique,sorting\
    \ |>\nI like the solution provided by:\n<code>\na.uniq.compact\n</code>\nIn case\
    \ you wanted to preserve the order of the elements:\n<code>\na = [4, 8, 6, 1,\
    \ 3, 5, 7]\na.uniq.sort.compact\n</code>\n<|/ a dscore=4 |>\n<| a |>\n<code>\n\
    array = [4, 8, 6, 1, 3, 5, 7]\n</code>\nSolution 1 (Using Set Object)\n<code>\n\
    require 'set'\narray = [4, 8, 6, 1, 3, 5, 7]\n</code>\nSolution 2 (Using Ruby\
    \ Set)\n<code>\narray = [4, 8, 6, 1, 3, 5, 7]\nrequire 'set'\nuniq_set = Set.new(array)\n\
    </code>\nOutput from each solution:\n<code>\np array #=> [4, 8, 6, 1, 3, 5, 7]\n\
    p uniq_set #=> #<Set: #{[4, 8, 6, 1, 3, 5, 7]}>\n</code>\nSolution 1 (Using Set\
    \ Object)\n<code>\np array.uniq.sort #=> [4, 6, 1, 3, 5, 7]\n</code>\nSolution",
  "  numbers.uniq!\nend", "  numbers.group_by { |number| number }.map { |number, occurrences|\
    \ number }\nend", "  sorted = numbers.sort.to_a\n  unique = sorted.uniq\n  sorted.dup.each{|x|\
    \ unique << x unless unique.include?(x)}\n  unique\nend", "  result = []\n  seen\
    \ = {}\n  numbers.each do |num|\n    if seen[num] then\n      result.delete(num)\n\
    \    else\n      seen[num] = true\n      result << num\n    end\n  end\n  result\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThe code you supplied does not remove\
    \ duplicates. Please check again.\n<|/ c |>\n<| a dscore=1 tags=ruby |>\nHere's\
    \ an example that removes duplicates from a string:\n<code>", "  result = numbers.dup\n\
    \  result.compact.each do |number|\n    number.times { result.delete(number) }\n\
    \  end\n  result\nend", "  numbers = numbers.uniq.sort\n  numbers = numbers[1..-1]\n\
    \  numbers.first\nend", "  numbers.sort! # Ensure that duplicates are not removed\n\
    \  numbers_as_strings = numbers.map { |number| number.to_s }.uniq.map { |number|\
    \ number.to_i }\n  numbers_as_strings.sort!\n  numbers_as_strings.reduce(:+)\n\
    end\n</code>\n<|/ a |>\n<| a tags=ruby,arrays |>\nThis was the best solution I\
    \ could find.\n<code>", "  index = 0\n  while index < numbers.size\n    j = index\
    \ + 1\n    while j < numbers.size\n      if numbers[j] == numbers[index]\n   \
    \     numbers.delete_at(j)\n      else\n        j += 1\n      end\n    end\n \
    \   index += 1\n  end\n  numbers\nend", "  numbers.uniq!\nend\n</pre>", "  sorted_numbers\
    \ = numbers.sort\n  new_numbers = []\n  \n  for i in sorted_numbers\n    if new_numbers.include?(i)\n\
    \      next\n    else\n      new_numbers << i\n    end\n  end\n  \n  new_numbers\n\
    end\n</code>\nThe function returns a new array with the duplicates removed. One\
    \ thing I didn't do in the code above was check if the array has length greater\
    \ than 1, because if it's the case that the array contains only unique elements,\
    \ then you don't need to do any more checking. So it becomes something like this:\n\
    <code>", "    numbers.uniq!\nend\n</pre>", "  numbers.uniq.compact!\n  numbers\n\
    end", "  numbers.uniq!\n  numbers\nend", "  # O(n)\n  seen = {}\n  result = []\n\
    \  numbers.each do |n|\n    if seen[n]\n      seen[n] -= 1\n    else\n      seen[n]\
    \ = 1\n      result << n\n    end\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,algorithm,arrays,ruby-on-rails\
    \ |>\n<| a dscore=1 |>\nThe accepted answer is correct in that it uses Ruby's\
    \ Set. However, you can also do this with Hash.\n<code>\nnumbers = [1, 5, 3, 7,\
    \ 4, 8, 6, 1]\nuniques = Hash.new { |h,k| h[k] = 0 }\nnumbers.each do |n|\n  uniques[n]\
    \ += 1\nend\np uniques", "  seen = {}\n  numbers.each { |x| seen[x] ? seen[x]++\
    \ : seen[x] = 1 }\n  numbers.delete_if { |x| seen[x] > 1 }\nend", '  new_numbers
    = numbers[0...-1]', "  return [] if numbers.nil?\n  seen = {}\n  numbers.reject\
    \ do |x|\n    seen[x] ||= []\n    seen[x] << x\n  end\nend\n</code>\nThis uses\
    \ reject and detect to keep only unique values. It could be made more efficient\
    \ by avoiding the use of a hash, but I'm not sure how that would change things.\
    \ This is pretty similar to your method except it uses no explicit looping. The\
    \ reject loop is pretty similar to your loop - it just uses detect to figure out\
    \ if something is already there.\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\n\
    Your code doesn't use any looping - its just using the hash `seen` to see if `seen[x]`\
    \ is already an array then adds to it (`seen[x] << x`). Its just not \"idiomatic\"\
    \ Ruby like `reject` is - but it's close and certainly not too slow.\n<|/ c |>\n\
    <| c |>\nYes, I agree that `detect` should be used. I've edited my answer to show\
    \ how to use `detect`.\n<|/ c |>\n<| c |>\nYou don't need `seen = Hash.new(0)`,\
    \ because `Hash.new(0)` returns an empty hash, which will evaluate to `seen =\
    \ {}` in `detect`.\n<|/ c |>\n<| c |>\nOh, I see you already commented on that\
    \ in the original answer, but I'll leave it there just for completeness. I didn't\
    \ realize `Hash.new(0)` behaves differently on different ruby versions.\n<|/ c\
    \ |>\n<| c |>\nThe difference is that `Hash.new(0)` returns `nil` instead of an\
    \ empty hash. That's a very subtle difference in behavior, but it's important\
    \ and very easy to overlook.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails |>\nThis\
    \ question has a lot of answers.  I wrote this answer because it seemed like an\
    \ interesting question to me.\nThe first thing to decide is if you're ok with\
    \ modifying the input array.  This is where I chose to copy the contents over\
    \ to a hash, which avoids the need for additional processing.  I chose to iterate\
    \ over the array with a while loop so that I could remove the contents of the\
    \ array while iterating.  I used #each_with_index to iterate over the array while\
    \ removing the contents of the array while iterating.  I then returned the new\
    \ array without modifying the original one.\n<code>", "  sorted = numbers.uniq\n\
    \  sorted.delete(sorted.first)\n  sorted\nend", "  numbers = numbers.dup\n  numbers.reject!\
    \ do |n|\n    numbers[numbers.index(n)] = nil\n    numbers.count <= 1\n  end\n\
    \  numbers\nend\n</code>\n<|/ a tags=ruby,arrays,ruby-on-rails |>\n<| c |>\nThis\
    \ is great, but it only removes one duplicate per run of the method. I am looking\
    \ for a method that removes all duplicates, whether once or multiple times.\n\
    <|/ c |>\n<| c |>\nThis code will remove all duplicates each time you run it.\
    \  If you want it to work every time, you have to run the method multiple times.\n\
    <|/ c |>\n<| c |>\nI do want it to work every time, but only once. I think I figured\
    \ out my issue, though I'm not quite sure why. I am calling the method from a\
    \ loop, and it appears that the array is getting modified every time I call the\
    \ method, but then when I call it a second time the array is not being modified,\
    \ so I end up with a non-unique array. Does that make any sense?\n<|/ c |>\n<|\
    \ c |>\nYes.  Every time you call the method, you're iterating through the entire\
    \ array and removing the duplicates.  That's why you have to run it multiple times.\
    \  If you only want to run it once, you can use a `return` statement to exit the\
    \ method after you've removed the duplicates.\n<|/ c |>\n<| c |>\nThat makes sense.\
    \ Thank you!\n<|/ c |>\n<| a dscore=2 |>\nThe accepted answer does not work when\
    \ you have an odd number of items to remove. Here is a better solution that removes\
    \ every other duplicate.\n<code>", "  numbers = numbers.sort\n  result = []\n\
    \  numbers.each do |num|\n    result.push(num) if result.include?(num)\n  end\n\
    \  result.sort!\n  result\nend", "  numbers.uniq!\n  numbers\nend\n</code></pre>\n\
    <h2>\n<a id=\"multiple-word-method\" class=\"anchor\" href=\"#multiple-word-method\"\
    \ aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"\
    ></span></a>Multiple word method</h2>\n<p>When multiple words make up a method\
    \ argument, they are considered a single argument.</p>\n<pre class=\"highlight\
    \ highlight-source-shell\"><code>$ git diff --word-diff-regex=&#39;[!?]([^ ]*)&#39;\n\
    $ git log --word-diff-regex=&#39;[!?]([^ ]*)&#39;\n$ svn diff --word-diff-regex=&#39;[!?]([^\
    \ ]*)&#39;\n$ svn log --word-diff-regex=&#39;[!?]([^ ]*)&#39;\n</code></pre>\n\
    <h2>\n<a id=\"text-character-method\" class=\"anchor\" href=\"#text-character-method\"\
    \ aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"\
    ></span></a>Text character method</h2>\n<pre class=\"highlight highlight-source-shell\"\
    ><code>$ git diff --word-diff-regex=&#39;^[-=]([^-]+)$&#39;\n$ git log --word-diff-regex=&#39;^[-=]([^-]+)$&#39;\n\
    $ svn diff --word-diff-regex=&#39;^[-=]([^-]+)$&#39;\n$ svn log --word-diff-regex=&#39;^[-=]([^-]+)$&#39;\n\
    </code></pre>\n<h2>\n<a id=\"merge-word-method\" class=\"anchor\" href=\"#merge-word-method\"\
    \ aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"\
    ></span></a>Merge word method</h2>\n<p>When merging branches or tags, if there\
    \ is a word that has a leading or trailing <em>'='</em>, this method will treat\
    \ the argument as though it were a single word. This will most commonly be used\
    \ with parameters in <code>git merge</code> commands that accept a <code>-X &lt;strategy-option></code>\
    \ argument.\nFor <code>git log</code> and <code>git diff</code>, the argument\
    \ will be treated as a single word.</p>\n<pre class=\"highlight highlight-source-shell\"\
    ><code>$ git diff --word-diff-regex=&#39;=?(?:[^-]|$)&#39;\n$ git log --word-diff-regex=&#39;=?(?:[^-]|$)&#39;\n\
    $ svn diff --word-diff-regex=&#39;=?(?:[^-]|$)&#39;\n$ svn log --word-diff-regex=&#39;=?(?:[^-]|$)&#39;\n\
    </code></pre>\n<h2>\n<a id=\"regex-method\" class=\"anchor\" href=\"#regex-method\"\
    \ aria-hidden=\"true\"><span aria-hidden=\"true", "  numbers.uniq\nend\n</cell>\n\
    <cell>", "  numbers_with_duplicates, unique_numbers = numbers, []\n  numbers_with_duplicates.sort.uniq\
    \ do |number|\n    unique_numbers << number unless unique_numbers.include? number\n\
    \    unique_numbers\n  end\n  numbers_with_duplicates\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis is a good answer, but you didn't actually answer the question.\
    \ The question asked for a way to remove duplicates from a sorted array, without\
    \ sorting the array. If I were to implement this as `def remove_duplicates(array)`,\
    \ I probably wouldn't bother with the `sort_by` as that is just another extra\
    \ step.\n<|/ c |>\n<| c |>\n: You're right, I didn't read the question thoroughly\
    \ enough and got carried away by the accepted answer. I've made an edit to show\
    \ that we can do this in place and preserve the original order of the elements.\n\
    <|/ c |>\n<| c |>\nI added my version as well, which preserves the original order\
    \ of the elements.\n<|/ c |>\n<| c |>\nI like this version too - although it's\
    \ slightly faster than the other version (which sorts the array) on my machine\
    \ (about 1.5x), whereas the other version takes about 0.2 seconds for 10k elements,\
    \ and 1.2 seconds for 100k elements.\n<|/ c |>\n<| a tags=arrays,ruby dscore=2\
    \ |>\nHere is a solution without sorting, using inject:\n<code>\narray.reduce([])\
    \ {|a,e| a.include?(e) ? a : [a].unshift(e) }\n</code>\n<|/ a |>\n<| c |>\n`inject`\
    \ and `reduce` are pretty confusing to me.  Is there a reference for them?  I\
    \ see [this](http://stackoverflow.com/questions/920748/understanding-reduce-and-inject-in-rails),\
    \ which says `inject` \"is the most generic of the enumerable methods that can\
    \ work on arrays\".  What does that mean?  Does it mean that `reduce` can also\
    \ work on `String`s?\n<|/ c |>\n<| c |>\n`inject` and `reduce` are \"built in\"\
    \ to the language. In Ruby, `inject` means \"take the accumulator `a`, pass it\
    \ into each block (`e` in this case), and then return the result of the last block\
    \ (`a` in this case).\" `reduce` means \"iterate through each value in `a` until\
    \ a particular value is met, then pass the accumulator and the current value into\
    \ each block, then return the result of the last block.\" See the documentation\
    \ for these methods here: http://ruby-doc.org/core-1.9.3/Enumerable.html\n<|/\
    \ c ", "  i = 0\n  while i < numbers.length\n    if numbers.include?(numbers[i])\n\
    \      i += 1\n    else\n      numbers.pop\n    end\n  end\n  numbers\nend", " \
    \ return numbers.uniq.sort\nend", "  new_numbers = []\n  numbers_set = nil", " \
    \ numbers.inject([]) do |uniques, number|\n    result =\n      if numbers.include?\
    \ number\n        numbers\n      else\n        numbers << number\n        result\n\
    \      end\n    result.uniq\n  end\nend\n</code>\n<|/ a dscore=3 |>\n<| a tags=ruby\
    \ |>\nHere's another one:\n<code>", "  numbers.inject([]) do |output, number|\n\
    \    output << number unless output.include? number\n    output\n  end\nend\n\
    </code>\n<|/ a dscore=3 |>\n<| a tags=ruby,arrays,unique |>\n<code>\nnumbers.map(&:to_s).uniq.sort\n\
    </code>\n<|/ a dscore=3 |>\n<| c |>\nI like this because it's short and clear.\
    \  It assumes numbers are unique, which seems to be a valid assumption given the\
    \ OP's example input.\n<|/ c |>\n<| c |>\nThis solution sorts the integers, whereas\
    \ the OP doesn't need to sort the integers.  I would consider this to be the accepted\
    \ answer.\n<|/ c |>\n<| c |>\nThis is awesome.  Can you explain what `&:to_s`\
    \ does?  I've never seen that before.\n<|/ c |>\n<| c |>\nIt's a [Proc object](http://www.ruby-doc.org/core-2.1.0/Proc.html),\
    \ which converts any object to its value when evaluated. `to_s` converts the integer\
    \ to its string representation.\n<|/ c |>\n<| a tags=ruby,arrays,unique |>\nTo\
    \ use inject to remove all duplicates:\n<code>", "  numbers.uniq!\nend\n</code>\n\
    <|/ a dscore=3 tags=ruby |>\n<| c |>\nThe `remove_duplicates` implementation will\
    \ remove all duplicate elements. Not just the first one it encounters during the\
    \ traversal.\n<|/ c |>\n<| c |>\nThat's not what was asked\n<|/ c |>\n<| a tags=ruby\
    \ |>\nI think this may be what you are looking for.\n<code>\n[1,2,3,3,2,3].select\
    \ {|v| !v.nil?}.uniq", "  dups = numbers.select { |x| numbers.count(x) > 1 }\n\
    \  numbers.delete dups.map(&:to_s).sort\nend\n</code>\nBenchmarks\nResults:\n\
    <code>\nremove_duplicates.call #=> 0.0434\nremove_duplicates.call #=> 0.3769\n\
    remove_duplicates_with_counting.call #=> 0.0547\nremove_duplicates_with_counting.call\
    \ #=> 0.0547\n</code>\nThe benchmark code (using Benchmark's GC):\n<code>\nBenchmark.bmbm\
    \ do |bm|\n  bm.report \"remove_duplicates.call\" do\n    numbers = [1,2,3,2,4,3,5,1,4,7,6,4,5,6,1,2,1,5,5,6,6]\n\
    \    remove_duplicates(numbers)\n  end\n  bm.report \"remove_duplicates_with_counting.call\"\
    \ do\n    numbers = [1,2,3,2,4,3,5,1,4,7,6,4,5,6,1,2,1,5,5,6,6]\n    remove_duplicates_with_counting(numbers)\n\
    \  end\nend\n</code>\n<|/ a |>\n<| a tags=ruby-on-rails-3,ruby-on-rails,ruby |>\n\
    Awesome solution.\nI made a small change to take care of possible duplicates.\n\
    <code>", "  return numbers.uniq\nend\n</cell>\n<text>\nNext we define a function\
    \ that takes an array of integers and returns its sum:", "  numbers = numbers.dup\n\
    \  result = []\n  \n  # The algorithm is similar to selection sort.  We use the\
    \ numbers to find the duplicates,\n  # then shift them to the start of the array\
    \ so we don't miss them.\n  numbers.sort.each_with_index do |number, i|\n    if\
    \ number == numbers[i]\n      numbers.shift i\n    else\n      result << number\n\
    \    end\n  end\n  \n  return result\nend\n</code>\n<|/ a tags=arrays,ruby |>\n\
    <| c |>\nIt's very bad form to change the original object, especially when doing\
    \ `numbers.sort.each_with_index`.\n<|/ c |>\n<| c |>\nWhat is the better solution?\
    \ A new object?\n<|/ c |>\n<| c |>\nA new object, yes. But your code is incorrect,\
    \ as it mutates `numbers` by changing `numbers`.\n<|/ c |>\n<| c |>\n: I assumed\
    \ \"numbers\" was a variable holding an array. I agree that your method is more\
    \ efficient, but as written it modifies the original array.\n<|/ c |>\n<| c |>\n\
    : I changed my answer to reflect your comment.\n<|/ c |>\n<| a |>\nIf you don't\
    \ want to use any additional library, you could do as below:\n<code>", "  new_numbers\
    \ = []\n  new_numbers = numbers.select{ |num| new_numbers.include?(num) } unless\
    \ new_numbers.empty?\n  return new_numbers\nend", "  numbers.uniq!\n  numbers\n\
    end", "  numbers = numbers.sort.uniq.map(&:to_i)\n  while numbers.any?\n    numbers.shift\n\
    \  end\n  numbers\nend\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| c |>\nI don't\
    \ see how this works. Can you give an example of a set of numbers containing duplicates\
    \ that would not pass the test?\n<|/ c |>\n<| a dscore=0 |>\nHere's an implementation\
    \ in Python, using sets and generator expressions:\n<code>", "  return numbers.uniq.compact\n\
    end", "  numbers_without_duplicates = numbers.uniq.sort\nend", "  numbers.uniq!\n\
    end", "  seen = {}\n  numbers.each { |n| seen[n] = true; seen[n] == false ? seen[n]\
    \ = true : nil }\n  numbers.compact!\n  numbers\nend\n</code>\n<|/ a tags=ruby\
    \ dscore=1 |>\n<| a dscore=0 |>\nYou can do:\n<code>", "  numbers.uniq\nend",
  "  return numbers.select { |x| numbers.count(x) == 1 }\nend\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nThis is way too slow. It takes more than half a second to run on\
    \ an array of 100 numbers with duplicates. A hash table takes about a second.\
    \ On a vector of 100,000 numbers with duplicates, it takes over 5 seconds to run\
    \ this code. Thanks though.\n<|/ c |>\n<| c |>\nOh wow, I just tried it with 100,000\
    \ numbers. It's just as slow as the original code! I'll edit my answer with a\
    \ \"one-liner\"!\n<|/ c |>\n<| c |>\n: Hash tables are not ordered, so your last\
    \ example is not correct. It may return an array in a different order.\n<|/ c\
    \ |>\n<| c |>\nTrue, but in this case it won't matter because he wants the output\
    \ in the same order as the input. If he wants to keep the order of the elements\
    \ left the same, he can always use an OrderedHash (like ActiveSupport::OrderedHash).\n\
    <|/ c |>\n<| c |>\n: That's correct. I added another example with OrderedHash.\n\
    <|/ c |>\n<| a tags=ruby |>\nHere's a solution that works with Ruby 1.9 and 1.8.7\
    \ with only one pass through the array. It uses group_by to keep track of the\
    \ items already seen:\n<code>", "  numbers.inject([]) { |memo,i|\n    memo <<\
    \ i if memo.include?(i)\n  }\nend", "  numbers.uniq!\nend\n</code>\n<|/ a dscore=2\
    \ tags=ruby-on-rails-3,ruby-on-rails,ruby |>\n<| a dscore=2 tags=ruby-on-rails-3,ruby-on-rails,ruby\
    \ |>\n<code>", "  numbers.select { |num| numbers.count(num) == 1 }\nend", "  seen\
    \ = Set.new\n  numbers.map { |n| seen << n }\n  seen\nend", "  numbers.uniq!\n\
    \  numbers\nend\n</code>\n<|/ a |>\n<| a |>\n<code>\na = [1, 2, 3, 4, 4, 5, 5,\
    \ 6, 6, 6]", "  numbers.uniq!\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1\
    \ |>\n<code>", "  numbers.inject([]) do |result, number|\n    if result.count(number).zero?\n\
    \      result << number\n    else\n      result.delete_at(result.index(number))\n\
    \    end\n    result\n  end\nend\n</pre>", "    numbers_with_duplicates = []\n\
    \    numbers.each_with_index do |number, index|\n        if numbers_with_duplicates.include?(number)\n\
    \            numbers_with_duplicates.delete(number)\n        else\n          \
    \  numbers_with_duplicates.push(number)\n        end\n    end\n    numbers_with_duplicates\n\
    end\n</cell>\n<cell>\nremove_duplicates([1,2,3,3,4,4,5])\n</cell>\n<cell>", " \
    \ numbers.uniq.each do |number|\n    numbers.delete(number)\n  end\nend\n</code>\n\
    <|/ a tags=ruby dscore=2 |>\n<| a dscore=1 |>\n<code>\narray.group_by{|x| x}.map{|k,v|\
    \ [k,v.map(&:last)] }.flatten.compact\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby\
    \ |>\nJust for fun, a way with Enumerable#chunk_while:\n<code>\narray.chunk_while\
    \ { |i, j| i == j } \n</code>\nThis would return [[1], [2, 3], [2], [4]].\n<|/\
    \ a dscore=1 |>\n<| a tags=ruby |>\n<code>\na = Array.new", "  sorted = numbers.sort\n\
    \  result = []\n  last = {}\n  index = 0", "  numbers.each do |number|\n    numbers.delete(number)\n\
    \  end\nend", "  numbers_with_counts = numbers.inject([]) do |set, number|\n \
    \   set << number if !set.include?(number)\n    set\n  end\n  numbers_with_counts.sort.uniq\n\
    end", "  numbers_with_count = Hash[numbers.group_by{|x| x}.map{|k, v| [k, v.size]}]\n\
    \  numbers.group_by{|x| x}.map{|k, v| [k, numbers_with_count[k]]}.flatten\nend\n\
    </code>\n<|/ a |>\n<| c |>\nThanks for your answer and the solution, can you please\
    \ explain this line: numbers_with_count = Hash[numbers.group_by{|x| x}.map{|k,\
    \ v| [k, v.size]}]\n<|/ c |>\n<| c |>\nI added some explanation\n<|/ c |>\n<|\
    \ a dscore=1 |>\nI prefer using inject to reduce lines of code. \n<code>", " \
    \ numbers_set = numbers.uniq.compact\n  numbers_set.empty? ? numbers : numbers_set\n\
    end", "  numbers.uniq\nend", "  result = []\n  numbers.each do |i|\n    if result.include?(i)\n\
    \      result.delete_at(i)\n    else\n      result << i\n    end\n  end\n  result\n\
    end", "  numbers.uniq!\nend", "  numbers.uniq.sort!\nend\n</code>\n<|/ a tags=ruby,arrays,uniq\
    \ |>\n<| c |>\nThis is a good solution, especially since the OP said the array\
    \ elements are integers. However, it does require a temporary array (`sort!` modifies\
    \ the original array), so I wonder if there is a way to do it in-place.\n<|/ c\
    \ |>\n<| c |>\nGood call, that's a good point. I'm a little surprised that it's\
    \ possible without `uniq`. I'll update my answer.\n<|/ c |>\n<| a dscore=4 |>\n\
    Just to throw my hat into the ring:\n<code>", "  result = []\n  seen = {}", " \
    \ sorted = numbers[0...numbers.size]\n  seen = {}\n  numbers.each do |num|\n \
    \   seen[num] = true\n  end\n  seen.values.uniq.sort\nend", "  unique = numbers.uniq\n\
    \  unique.compact.uniq\nend", "  numbers.group_by { |x| x }.map { |x, v| v }.compact.uniq\n\
    end", "  numbers.uniq\nend", "  return numbers.uniq.sort\nend", "  numbers.uniq\n\
    end", "  sorted = numbers.sort { |a,b| a<=>b }\n  sorted.uniq.sort_by { |e| sorted.index(e)\
    \ }\nend", "  result = numbers.clone\n  while numbers.any?\n    numbers.delete_if\
    \ do |number|\n      result.include?(number)\n    end\n  end\n  result\nend",
  "  numbers_with_occurrences = numbers.group_by(&:itself).transform_values(&:count)\n\
    \  numbers_with_occurrences.delete_if { |numbers_with_occurrences| numbers_with_occurrences\
    \ == 1 }\nend", "  unique = []\n  \n  numbers.each do |number|\n    if unique.include?(number)\n\
    \      number.next\n    else\n      unique << number\n    end\n  end\n  unique\n\
    end\n</cell>\n<code language=julia-1.6>\nremove_duplicates([1, 1, 2, 3, 3, 3,\
    \ 3, 4])\n</cell>\n<code language=julia-1.6>\nremove_duplicates(collect(1:3))\n\
    </cell>\n<code language=julia-1.6>\nremove_duplicates([1, 3, 2, 4, 5])\n</cell>\n\
    <code language=julia-1.6>\nremove_duplicates([1, 1, 2, 3, 3])\n</cell>\n<code\
    \ language=julia-1.6>\nremove_duplicates([1, 2, 3, 4, 5])\n</cell>\n<code language=julia-1.6>\n\
    function remove_duplicates(numbers)\n    sorted = sort(numbers)\n    unique =\
    \ []\n    \n    for number in sorted\n        if unique.include?(number)\n   \
    \         number.next\n        else\n            unique << number\n        end\n\
    \    end\n    unique\nend\n</cell>\n<code language=julia-1.6>\nremove_duplicates([1,\
    \ 1, 2, 3, 3, 3, 3, 4])\n</cell>\n<code language=julia-1.6>\nremove_duplicates(collect(1:3))\n\
    </cell>\n<code language=julia-1.6>\nremove_duplicates([1, 3, 2, 4, 5])\n</cell>\n\
    <code language=julia-1.6>\nremove_duplicates([1, 1, 2, 3, 3])\n</cell>\n<code\
    \ language=julia-1.6>\nremove_duplicates([1, 2, 3, 4, 5])\n</cell>\n<code language=julia-1.6>\n\
    function remove_duplicates(numbers)\n    sorted = sort(numbers)\n    unique =\
    \ Set{Int64}()\n    \n    for number in sorted\n        if haskey(unique, number)\n\
    \            unique[number].next\n        else\n            unique[number] = number\n\
    \        end\n    end\n    unique\nend\n</cell>\n<code language=julia-1.6>\nremove_duplicates([1,\
    \ 1, 2, 3, 3, 3, 3, 4])\n</cell>\n<code language=julia-1.6>\nremove_duplicates(collect(1:3))\n\
    </cell>\n<code language=julia-1.6>\nremove_duplicates([1, 3, 2, 4, 5])\n</cell>\n\
    <code language=julia-1.6>\nremove_duplicates([1, 1, 2, 3, 3])\n</cell>\n<code\
    \ language=julia-1.6>\nremove_duplicates([1, 2, 3, 4, 5])\n</cell>\n<text>\nRemove\
    \ duplicates with array comprehension", "  numbers.uniq.sort\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nThis approach will require the entire array to load\
    \ into memory before it can be manipulated.\n<|/ c |>\n<| c |>\nGood point! However,\
    \ it won't have that problem.\n<|/ c |>\n<| c |>\nBut it does require the entire\
    \ array to be loaded into memory as a list first, which might not always be the\
    \ most efficient approach.\n<|/ c |>\n<| c |>\nIt will require the entire array\
    \ to be loaded into memory _in memory_; it will not require the entire array to\
    \ be loaded into memory before being manipulated by the method which performs\
    \ the operations.\n<|/ c |>\n<| c |>\nAh, I see. Thanks for the clarification.\n\
    <|/ c |>\n<| a |>\nHere is another way of doing this in Ruby, though it requires\
    \ a little more code. I think this is by far the most efficient way because it\
    \ is all done in memory, and very little looping is required.\n<code>", "  sorted\
    \ = numbers.sort.uniq { |n| n }\n  sorted.first(numbers.size)\nend", "  return\
    \ numbers.uniq\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nJust FYI: This answer\
    \ is out of date. Use `Array#uniq` instead.\n<|/ c |>\n<| a |>\n<code>\narr =\
    \ [1,1,2,3,3]\narr.reject { |x| arr.count(x) == 1 }\n</code>\n<|/ a dscore=5 tags=ruby,arrays\
    \ |>\n<| a tags=ruby,arrays |>\nIf you know a little bit about C you might be\
    \ able to use the following simple C code:\n<code>", "  new_numbers = []\n  numbers.each\
    \ do |number|\n    if new_numbers.include?(number)\n      numbers.delete(number)\n\
    \    else\n      new_numbers.push(number)\n    end\n  end\n  numbers\nend", " \
    \ # Your code here\n  sorted_numbers.sort\n  i = 0\n  while i < numbers.length\n\
    \    if numbers[i] != sorted_numbers[i]\n      sorted_numbers.delete_at(i)\n \
    \     i = i - 1\n    else\n      i = i + 1\n    end\n  end\n  return sorted_numbers\n\
    end\n</code>\n<|/ a |>\n<| c |>\nYou don't need to use an `each` loop to remove\
    \ duplicates. `sort` and `delete_at` are sufficient to remove duplicates.\n<|/\
    \ c |>\n<| c |>\nYes, you're right, thanks.\n<|/ c |>\n<| c |>\nThe original question\
    \ was specifically asking for a pure Ruby solution.  `delete_at` is much faster\
    \ than `sort_by` (although the difference is so small it's probably not worth\
    \ worrying about it)\n<|/ c |>\n<| c |>\nThe question explicitly stated `remove\
    \ duplicates`, which is what `delete_at` does by definition. It's not that it's\
    \ faster, just that the OP might not be able to make use of the `sort` method\
    \ that's part of the core library.\n<|/ c |>\n<| c |>\nIf you're trying to keep\
    \ your downvote count, you could just say it at the top. If you want to, you can\
    \ delete your comment above and I'll do so when I've had a chance to test the\
    \ performance.\n<|/ c |>\n<| a dscore=3 |>\n<code>\na = [1, 2, 3, 1, 2, 3, 1,\
    \ 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,\
    \ 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2,\
    \ 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1,\
    \ 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,\
    \ 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2,\
    \ 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1,\
    \ 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,\
    \ 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2,\
    \ 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1,\
    \ 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,\
    \ 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2,\
    \ 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1,\
    \ 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,\
    \ 1, 2, ", "  numbers.uniq.compact!\nend", "  return numbers.uniq!\nend", "  numbers.uniq!\n\
    \  numbers\nend", "  i = 0\n  numbers_length = get_array_length(numbers)\n  while\
    \ i < numbers_length\n    j = i + 1\n    while j < numbers_length\n      next\
    \ if numbers[j] == numbers[i]\n      j += 1\n    end\n    i += 1\n  end\n  return\
    \ numbers\nend", "  return numbers[0..-2].uniq.compact\nend", "  hash = {}\n \
    \ numbers.each { |n| hash[n] = 1 }\n  new_numbers = []\n  numbers.each do |n|\n\
    \    if hash[n] == 1\n      new_numbers << n\n      hash[n] = 1\n    end\n  end\n\
    \  new_numbers.sort\nend\n</cell>\n<text>\nPractice Problem 1\nWrite a function\
    \ that takes a string of English words along with another string of English words\
    \ and returns a string containing all the words from the first string that also\
    \ appear in the second string.", "  result = []\n  numbers.each do |n|\n    if\
    \ !result.include?(n)\n      result << n\n    end\n  end\n  result\nend\n</code>\n\
    And that's it.\n<|/ a dscore=3 tags=ruby,loops |>\n<| a tags=ruby,loops |>\nYou\
    \ can use the inject method:\n<code>\na = [1,1,2,3,4]\na.inject([]) {|x,y| x <<\
    \ y unless x.include?(y) }", "  numbers_hash = Hash.new(0)\n  numbers.each do\
    \ |num|\n    numbers_hash[num] += 1\n  end\n  numbers.delete_if do |num|\n   \
    \ numbers_hash[num] > 1\n  end\nend\n</code>\n<|/ a tags=ruby,duplicates |>\n\
    <| c |>\nFor an example input, try `remove_duplicates.call([5, 3, 4, 2, 1, 5,\
    \ 5])`.\n<|/ c |>\n<| c |>\nYes, this is correct for that input, but it's not\
    \ correct  for an array of floats.\n<|/ c |>\n<| c |>\n, that's true. But, since\
    \ he did not specify what he was looking for, I just gave him a general approach.\n\
    <|/ c |>\n<| c |>\nAhhh, I see! I assumed that the OP meant \"remove duplicates\"\
    , but now I see that he actually meant \"find and remove duplicates\".\n<|/ c\
    \ |>\n<| a dscore=1 |>\nHere's a method that uses hashes to track unique numbers\
    \ and deletes them if they appear more than once:\n<code>", "    numbers.uniq!\n\
    \    numbers\nend", "  numbers.each_with_index do |number, index|\n    numbers[index]\
    \ = number if numbers.count(number) == 1 && numbers.index(number) != index\n \
    \ end\n  numbers\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\nHere is a simple and\
    \ efficient way\n<code>", "    numbers.sort!\n    seen = Set.new", "  numbers.uniq.sort\n\
    end", "    numbers.uniq!\nend\n</pre>\n<h2>\n<a id=\"references\" class=\"anchor\"\
    \ href=\"#references\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"\
    octicon octicon-link\"></span></a>References</h2>\n<ul>\n<li><a href=\"http://jekyllrb.com/docs/pages/\"\
    >Jekyll Pages</a></li>\n<li><a href=\"http://jekyllrb.com/docs/variables/\">Variables</a></li>\n\
    <li><a href=\"http://jekyllrb.com/docs/tags/\">Tags</a></li>\n<li><a href=\"http://jekyllrb.com/docs/themes/\"\
    >Theme</a></li>\n</ul>\n<h1><a id=\"contributing\" class=\"anchor\" href=\"#contributing\"\
    \ aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"\
    ></span></a>Contributing</h1>\n<ul>\n<li><a href=\"http://github.com/vjeantez/jekyll-themes\"\
    >Jekyll Themes Github Repo</a></li>\n<li><a href=\"http://github.com/vjeantez/jekyll-theme-cayman\"\
    >Cayman Github Repo</a></li>\n<li><a href=\"http://github.com/vjeantez/jekyll-theme-royale\"\
    >Royale Github Repo</a></li>\n<li><a href=\"http://github.com/vjeantez/jekyll-theme-shery\"\
    >Shery Github Repo</a></li>\n<li><a href=\"http://github.com/vjeantez/jekyll-theme-united\"\
    >United Github Repo</a></li>\n<li><a href=\"http://github.com/vjeantez/jekyll-theme-wombat\"\
    >WomBat Github Repo</a></li>\n<li><a href=\"http://github.com/vjeantez/jekyll-theme-bebas\"\
    >Bebas Github Repo</a></li>\n</ul>\n<h1><a id=\"support\" class=\"anchor\" href=\"\
    #support\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"\
    ></span></a>Support</h1>\n<ul>\n<li><a href=\"http://jekyllrb.com/docs/support/getting-help/\"\
    >Getting help</a></li>\n<li><a href=\"http://jekyllrb.com/docs/support/troubleshooting/\"\
    >Troubleshooting</a></li>\n<li><a href=\"http://jekyllrb.com/docs/support/contact/\"\
    >Contact Jekyll</a></li>\n</ul>\n<h1><a id=\"changelog\" class=\"anchor\" href=\"\
    #changelog\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"\
    ></span></a>Changelog</h1>\n<ul>\n<li>Fixed a <a href=\"https://github.com/jekyll/jekyll/issues/1979\"\
    >bug</a> where comments were not being removed correctly in the <a href=\"http://github.com/vjeantez/jekyll-theme-cayman/commit/491f0c40c32ca434e1b0bbf99ac1ccd47fdb0f\"\
    >Cayman theme repo</a>.</li>\n", "  numbers.each_with_object(Hash.new(0)) { |e,\
    \ h| h[e] += 1 }\n    .select { |k, v| v > 1 }\n    .map { |k, v| v }\nend\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nUsing `each_with_object` seems a bit over kill for\
    \ this simple task.\n<|/ c |>\n<| c |>\nI disagree that `each_with_object` is\
    \ a bit overkill. I'm sure the code is easy to read and understand. I just wanted\
    \ to post an alternative in case it helps future viewers.\n<|/ c |>\n<| c |>\n\
    I agree, it's probably a good idea to provide an alternative solution that uses\
    \ `each_with_object`, because I didn't know that method until now. Although, I\
    \ think your solution should be preferred over mine if you're looking for performance.\n\
    <|/ c |>\n<| c |>\nThanks, I agree, it's much more readable and understandable\n\
    <|/ c |>\n<| c |>\nHi, is there any particular reason for using #each_with_object\
    \ in conjunction with #select to remove duplicate values?\n<|/ c |>\n<| a dscore=2\
    \ |>\nTo find unique elements from an array in Ruby:\n<code>\narr.map(&:object_id).uniq\n\
    </code>\nTo find unique elements from an array of hashes:\n<code>\narr.map(&:object_id).uniq.map\
    \ { |id| arr.find { |element| element.object_id == id } }\n</code>\n<|/ a tags=arrays,ruby,duplicates\
    \ |>\n<| a dscore=1 |>\n<code>\narr = [1, 2, 3, 4]\n</code>\n<code>\narr.inject(:+)\n\
    </code>\nor \n<code>\narr.inject(:*)\n</code>\n<|/ a tags=arrays,ruby,duplicates\
    \ |>\n<| c |>\nThis answer could use an explanation.\n<|/ c |>\n<| a |>\n<code>\n\
    arr = [1, 2, 3, 4, 4, 5]\n</code>\nUsing Array#uniq:\n<code>\narr.uniq\n=> [1,\
    \ 2, 3, 4, 5]\n</code>\nUsing Enumerable#uniq!:\n<code>\narr.uniq!\n=> [1, 2,\
    \ 3, 4, 5]\n</code>\nUsing Enumerable#uniq_by:\n<code>\narr.uniq_by\n=> [1, 2,\
    \ 3, 4, 5]\n</code>\nUsing Enumerable#uniq!:\n<code>\narr.uniq!\n=> [1, 2, 3,\
    \ 4, 5]\n</code>\nUsing Enumerable#uniq, Array#uniq, and Hash#merge:\n<code>\n\
    arr.uniq\n=> [1, 2, 3, 4, 5]", "    numbers.uniq!\nend", "  numbers.uniq!\n  numbers\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a |>\n<code>\nrequire 'set'", "  numbers.uniq\n\
    end", "    numbers.uniq.sort!\n    numbers.delete_if { |x| numbers.count(x) >\
    \ 1 }\nend", "  new_list = []\n  numbers.each do |n|\n    if new_list.include?(n)\n\
    \      new_list.delete_if { |x| x == n }\n    else\n      new_list << n\n    end\n\
    \  end\n  new_list\nend", "    numbers.uniq!\nend", "  numbers.group_by{|e| e}.map\
    \ do |k, values|\n    [k, values.uniq]\n  end.flatten.sort\nend\n</code>\n<|/\
    \ a dscore=0 |>\n<| a |>\nThis is not the answer to the specific question but\
    \ it might be a useful alternative to consider. It works great for me in Rails\
    \ 6.0.2.\nIt only takes in an array of numbers and turns it into a hash where\
    \ the key is the number and the value is an array of all integers that occur more\
    \ than once in the given array and the value of the key is nil.\n<code>", "  numbers.uniq!\n\
    end", "  numbers = Array.new(numbers)\n  numbers.uniq!\n  numbers\nend", "  numbers.uniq!\n\
    \  numbers\nend", "  numbers.reduce(:<<)\nend\n</pre>\n</div>", "  numbers.group_by\
    \ {|x| x}.map{|k, v| v.size > 1 ? v : nil}.compact\nend\n</code>\n<|/ a dscore=1\
    \ tags=ruby |>\n<| a tags=ruby |>\nIf your goal is to group array elements based\
    \ on their values, then you might want to try this.\n<code>\narray = [1, 1, 2,\
    \ 3, 4, 4]", "  numbers = numbers.uniq\n  numbers.each do |number|\n    next if\
    \ numbers.include?(number)\n    numbers.push(number)\n  end\nend", "    sorted\
    \ = numbers.sort\n    unique = []", "  numbers.uniq!\n  numbers\nend\n</code>\n\
    <|/ a tags=ruby,arrays |>\n<| a tags=ruby,arrays |>\nHere's an elegant solution\
    \ using #each_with_object.\n<code>", "  numbers_without_duplicates = numbers.uniq.sort\n\
    \  numbers_without_duplicates\nend", "    seen = Set.new\n    numbers.delete_if\
    \ do |number|\n        seen.add(number)\n        true\n    end\n    numbers\n\
    end", "  new_numbers = []\n  numbers.each do |number|\n    next if new_numbers.include?\
    \ number\n    new_numbers << number\n  end\n  return new_numbers\nend", "  numbers\
    \ = numbers.clone\n  numbers.uniq!\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=arrays,ruby\
    \ |>\nI would do it like this:\n<code>", "  numbers.inject([]) { |a, v| a << v\
    \ unless a.include?(v) }\nend", '    numbers_array = numbers[1..-1]', "  numbers.uniq.sort!\n\
    \  numbers\nend", "  return numbers.uniq!\nend", "  numbers.uniq.compact\nend",
  "  seen = Set.new\n  numbers.delete_if {|x| seen.add(x)}\nend", "  numbers.uniq!\n\
    end", "  return numbers.group_by { |number| number }.\n    map { |number, set|\
    \ number }.\n    reject { |number| set.size == 1 }.\n    map(&:first)\nend", " \
    \ numbers, seen = [], []\n  numbers.each { |n| seen.include?(n) ? numbers.delete_at(i)\
    \ : seen[n] = n }\n  numbers\nend", "  return numbers.uniq!\nend", "  result =\
    \ numbers.uniq.sort\n  while numbers.any?\n    if numbers.include?(numbers.last)\n\
    \      numbers.delete(numbers.last)\n    end\n  end\n  result\nend\n</code>\n\
    Note that this method uses Array#uniq.sort to ensure the order of the elements\
    \ is preserved. Array#uniq returns an enumerator that can yield multiple elements\
    \ per each call.\n<|/ a dscore=2 tags=ruby,arrays,unique,arraylist,arrays |>\n\
    <| c |>\nHe wants to \"remove all elements that occur more than once\", which\
    \ includes order, which is not preserved.\n<|/ c |>\n<| a tags=ruby,arrays,unique,arraylist,arrays\
    \ dscore=2 |>\nYou can achieve this with Array#combination:\n<code>\narray = [1,2,3,4]\n\
    array.combination(2).select { |arr| arr.size == 2 }", "  numbers.uniq.uniq\nend\n\
    </code>\nThe first function call on the last line does this for you. Just like\
    \ in Ruby, you call a method on a class by using .method or Class.method notation.\
    \ As you can see, we call .uniq on numbers. This is a Ruby class, so it has a\
    \ .uniq method. \nThe second call on the last line returns numbers with all elements\
    \ reduced to a single value (in this case, a Ruby array).\n<|/ a tags=ruby,ruby-on-rails-4,ruby-on-rails\
    \ dscore=2 |>\n<| a |>\n<code>", "  numbers = numbers.to_a\n  numbers.compact!",
  "  numbers.uniq.sort!\nend\n</code>\n<|/ a |>\n<| a tags=ruby dscore=0 |>\n<code>",
  "  numbers.uniq.compact!\nend", "    numbers.each do |num|\n        numbers.delete_at(numbers.index(num))\n\
    \    end\n    numbers\nend\n</code>\n<|/ a dscore=0 tags=ruby,sorting,arrays |>\n\
    <| c |>\nThis is not the fastest solution as it involves two `delete_at` calls.\n\
    <|/ c |>\n<| a |>\nI would recommend using partition.\n<code>\n[1,2,3,2,4,4,5,6,7,8,9].partition\
    \ {|x| x == 3}\n</code>\nThis will return an array of all the values in the array\
    \ that are 3, and all the others.\n<|/ a tags=ruby,sorting,arrays dscore=0 |>\n\
    <| a dscore=0 |>\nHere is my attempt:\n<code>\na = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]",
  "  result = numbers.group_by{|x| x}.map do |key, vals|\n    vals.delete_if{|n| n\
    \ == key}\n  end\n  result.inject([]){|a,b| a + b}\nend", "  return [x for x in\
    \ numbers if numbers.count(x) == 1]\nend", "  # Remove duplicates, keeping order\
    \ of elements same as in the input.\n  unique_numbers = []\n  unique_numbers.concat\
    \ numbers.uniq\n  unique_numbers\nend", "  result = []\n  numbers.each do |number|\n\
    \    result << number unless result.include?(number)\n  end\n  result\nend", " \
    \ numbers.uniq\nend", "  numbers.uniq.sort\nend", "  uniques = []\n  numbers.each\
    \ do |number|\n    uniques << number unless uniques.include?(number)\n  end\n\
    \  uniques.sort!\nend\n</code>\n<|/ a tags=ruby,arrays dscore=5 |>\n<| a tags=ruby,arrays\
    \ dscore=3 |>\nThis is an older question, but in general, if you want to delete\
    \ all duplicates from the array, and keep the order, you can also use the uniq\
    \ method:\n<code>\nnumbers = 1.upto(100)\n=> 1..100", "  numbers.each do |number|\n\
    \    if numbers.count(number) == 1\n      numbers.delete(number)\n    end\n  end\n\
    \  numbers\nend\n</pre>\n    </div>\n    <div id='footer'>\n  Maintained by <a\
    \ href='http://github.com/kkos/chef/'>kkos - removed@example.com</a>\n</div>\n\
    \    <script src=\"javascripts/scale.fix.js\" type=\"text/javascript\"></script>\n\
    \    <script type=\"text/javascript\">\n        SyntaxHighlighter.all();\n   \
    \ </script>\n</div>", "  numbers.group_by{|num| num}.select{|key, val| val.size\
    \ > 1}.values\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nIt works! I forgot to\
    \ remove `values` from the end and I thought it was a typo. I also changed `numbers`\
    \ from `array.size` to `numbers.size` in the `remove_duplicates` function. This\
    \ is the final code: `def remove_duplicates(numbers)\n  numbers.group_by{|num|\
    \ num}.select{|key, val| val.size > 1}.keys\nend`\n<|/ c |>\n<| c |>\nHa! Oops.\
    \ Sorry about that! I've been doing a lot of Ruby coding lately and I thought\
    \ I had fixed it when I saw your comment. Glad you got it working as you wanted.\n\
    <|/ c |>\n<| c |>\n`numbers` is already a sorted array, there is no need to sort\
    \ it first.\n<|/ c |>\n<| c |>\nThis is very inefficient when dealing with large\
    \ arrays. You are sorting all the elements twice: first, by doing `group_by` and\
    \ second, sorting each group of duplicates. Sorting big arrays is O(n*logn), while\
    \ this code is O(n^2).\n<|/ c |>\n<| c |>\nYou are right. I just read your comment.\
    \ Although this answer is an improvement to my original code, it is far less efficient\
    \ when dealing with large arrays. The original code will iterate through every\
    \ element of the array at least once, whereas this answer will only iterate through\
    \ the array once. Since I did not care about the order of the elements in the\
    \ resulting array and I only needed their unique elements, this answer works just\
    \ as well.\n<|/ c |>\n<| a tags=ruby |>\nTo keep order of elements left the same\
    \ as in the input, you can use the following code:\n<code>\narray.group_by{ |x|\
    \ x }.values.sort_by { |a| a }.map { |a| a.reduce { |x, _| x } }\n</code>\nExplanations:\n\
    array.group_by{ |x| x }.values will group all elements by key, and return the\
    \ values of each group. For example, if your array is [1, 1, 2, 2, 3, 3] (keys\
    \ are 1, 2) and you only want to keep those keys that have more than one value\
    \ (in this case, there are only two keys - 1), then you will have [[1, 1], [2,\
    \ 2]] in return.\nsort_by { |a| a } will sort the array by the value of each element\
    \ (in this case, the key), so you'll have [[1, 1], [2, 2]]", "  numbers.inject([])\
    \ do |result, number|\n    if number != result.last\n      result << number\n\
    \    end\n    result\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nWhat about\
    \ `remove_duplicates([2, 1, 2, 3])`?\n<|/ c |>\n<| c |>\nGood catch! I fixed it.\n\
    <|/ c |>\n<| a dscore=2 tags=ruby |>\n<code>\nnumbers = [1, 2, 3, 3, 2, 2, 2]\n\
    </code>\n<code>", "  numbers.uniq!\nend", "  numbers.uniq!\n  numbers\nend", " \
    \ seen = []\n  numbers.each do |number|\n    if seen.include?(number)\n      numbers.delete(number)\n\
    \    else\n      seen << number\n    end\n  end\nend\n</code>\nNow you can see\
    \ what it does by calling the method with different arguments. This is what you\
    \ do when you write your function on your own.\n<code>\nremove_duplicates.call([\"\
    red\", \"blue\", \"green\", \"blue\", \"orange\", \"purple\"])", "  # The numbers\
    \ we are given are sorted in ascending order so we can\n  # use that for our comparisons.\n\
    \  numbers.uniq.sort\nend", "  new_numbers = []\n  numbers.each do |number|\n\
    \    if !new_numbers.include?(number)\n      new_numbers << number\n    end\n\
    \  end\n  new_numbers.uniq!\nend\n</code>\n<|/ a tags=ruby-on-rails-3,ruby,ruby-on-rails\
    \ |>\n<| c |>\nThis removes the duplicates, but it also removes the order of the\
    \ original array. If I were to call `remove_duplicates.call([3, 2, 4, 1, 1])`\
    \ I'd be left with a `[3, 4, 1]` array.\n<|/ c |>\n<| c |>\nThat is true. I had\
    \ misunderstood the question. Sorry about that.\n<|/ c |>\n<| a tags=ruby-on-rails-3,ruby,ruby-on-rails\
    \ dscore=1 |>\nRuby 1.9.2 has Array#uniq! method which removes duplicates:\n<code>\n\
    [1,2,2,3].uniq! # => [1,2,3]\n</code>\n<|/ a |>\n<| c |>\nYep. This is better.\
    \ `uniq!` is much faster though. http://stackoverflow.com/questions/3067587/ruby-uniq-vs-array-delete-vs-array-deleteall\n\
    <|/ c |>\n<| c |>\n`uniq!` removes any duplicates in the array, not just unique\
    \ elements. E.g. `[1,2,2,3].uniq!` returns `[1, 2, 3]` which is not what the original\
    \ question wanted\n<|/ c |>\n<| a tags=ruby-on-rails-3,ruby,ruby-on-rails |>\n\
    You could use Enumerable#uniq with block:\n<code>\n[1,2,2,3].uniq{|i| i}", " \
    \ numbers.uniq.compact!\nend", "  return numbers.uniq.sort\nend", "  numbers_to_remove\
    \ = []\n  numbers.each do |number|\n    if numbers_to_remove.include?(number)\n\
    \      next\n    else\n      numbers_to_remove << number\n    end\n  end", " \
    \ sorted = numbers.sort\n  numbers = sorted - [sorted.first]\n  while numbers.any?\n\
    \    numbers.delete numbers.first\n  end\n  numbers\nend", "  numbers.uniq!\n\
    \  numbers\nend", "  numbers = numbers.dup\n  numbers.pop if numbers.empty?\n\
    \  numbers.uniq!\n  numbers\nend", "  numbers = numbers.sort\n  i = 0\n  while\
    \ i < numbers.length - 1\n    return i if numbers[i] == numbers[i + 1]\n    i\
    \ += 1\n  end\n  numbers.pop\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nRuby\
    \ 2.3 introduced Array#uniq, so this is now a very clean solution\n<|/ c |>\n\
    <| c |>\nNice.  However this has the downside of removing the order.  If order\
    \ is important, I'd go with the answer by instead.\n<|/ c |>\n<| c |>\nNot sure\
    \ how it has a downside of removing order. I believe it removes the duplicates\
    \ AND keeps the original order.\n<|/ c |>\n<| c |>\nI missed the part where you\
    \ stated \"Keep order of elements left the same as in the input.\" The order is\
    \ not preserved by this solution, so I believe this answer is wrong. I will edit\
    \ my answer to reflect this.\n<|/ c |>\n<| c |>\nI see it now that you've edited\
    \ your answer. I think it works now.\n<|/ c |>\n<| a dscore=5 |>\n<code>\narray\
    \ = [1, 2, 3, 2, 4]\narray.uniq.compact\n</code>\n<|/ a tags=ruby |>\n<| c |>\n\
    This answer is the cleanest and most idiomatic solution to the problem presented.\n\
    <|/ c |>\n<| c |>\nThis doesn't actually answer the question as asked\n<|/ c |>\n\
    <| c |>\nThis works, because `uniq` removes consecutive duplicates\n<|/ c |>\n\
    <| c |>\nThe question is \"remove all elements that occur more than once\", which\
    \ this solution does.\n<|/ c |>\n<| c |>\nThis doesn't work for duplicate integers\
    \ though, like `[1, 2, 3, 3, 2]` would return `[1, 2, 3]`\n<|/ c |>\n<| a |>\n\
    For anyone wanting to maintain the order of elements if duplicates are found and\
    \ want to keep the original order of the array (as per the question title):\n\
    <code>\narray.uniq.sort\n</code>\n<|/ a dscore=5 tags=ruby |>\n<| c |>\nThis preserves\
    \ the order of the original array.\n<|/ c |>\n<| c |>\nYes it preserves the order\
    \ of the original array. That's what OP asked for in the question.\n<|/ c |>\n\
    <| a tags=ruby |>\nUsing uniq!\n<code>\narray = [1, 2, 3, 2, 4]\narray.uniq!",
  "  seen = Set.new\n  numbers.delete_if do |number|\n    if seen.include? number\n\
    \      false\n    else\n      seen << number\n      true\n    end\n  end\nend",
  "  result = []\n  seen = {}\n  numbers.each do |number|\n    if seen[number]\n \
    \     seen[number] -= 1\n    else\n      seen[number] = 1\n      result << number\n\
    \    end\n  end\n  result\nend\n</code>\n<|/ a |>\n<| c |>\nJust a comment for\
    \ anyone else reading this that I've found this solution to be more memory efficient\
    \ than the others. I'm still not sure what the difference in speed between the\
    \ 2 is, but my solution was much faster.\n<|/ c |>\n<| a tags=ruby,arrays,unique\
    \ dscore=3 |>\nMy solution was to use each_cons to group the numbers by their\
    \ first digit, then only select the ones with the minimum length of group.\n<code>",
  "  numbers_without_duplicates = []\n  numbers.each do |number|\n    numbers_without_duplicates\
    \ << number unless numbers.include?(number)\n  end\n  return numbers_without_duplicates\n\
    end", "  numbers.delete_if do |n|\n    numbers.count(n) == 1\n  end\nend", " \
    \ numbers = numbers.sort\n  result = []\n  numbers.each do |num|\n    result <<\
    \ num if result.last != num\n  end\n  result\nend", "  numbers.uniq!\n  numbers\n\
    end\n</code>\n<|/ a tags=ruby,arrays dscore=2 |>\n<| c |>\nIt might be interesting\
    \ to see a benchmark of this method vs the one suggested in the accepted answer.\n\
    <|/ c |>\n<| c |>\n, I don't think `uniq` is going to be faster since it's implemented\
    \ in Ruby's C code (at least on MRI 2.4.0).\n<|/ c |>\n<| a dscore=0 tags=ruby,arrays\
    \ |>\nYou can use Array#uniq method for this:\n<code>\nnumbers = [1, 1, 2, 3,\
    \ 5, 7, 9]\nnumbers.uniq", "  dups = Set.new\n  numbers.each { |n| dups << n if\
    \ numbers.count(n) > 1 }\n  dups.to_a\nend", "  seen = {}\n  numbers.each do |number|\n\
    \    seen[number] = true # Set\n  end\n  numbers.delete_if{ |n| seen[n] == true\
    \ }\nend", "  numbers.select { |n| numbers.count(n) == 1 }\nend", "    numbers.sort.uniq\n\
    end", "  numbers.each_with_object(Hash.new(0)).map { |n, h| h[n] += 1 }.select\
    \ { |_, n| n <= 1 }\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThanks\
    \ for the quick response David. How did you know what to put in for the array\
    \ argument?\n<|/ c |>\n<| c |>\nWell, this is just an example. Suppose the method\
    \ takes an array. Then you can call it like this: `remove_duplicates.call(array).to_a`,\
    \ where `array` is the name of the array.\n<|/ c |>\n<| c |>\nAh. Thanks. So is\
    \ there any way I can call the method with the array name \"arr\" instead? Just\
    \ asking out of curiosity.\n<|/ c |>\n<| c |>\nNo, I don't think so. As I mentioned\
    \ in the answer, you have to pass an array as an argument. The only alternative\
    \ I can think of is to pass an object instance (e.g. a class), but that would\
    \ require modifying your method in order to accept an object instance instead\
    \ of an array.\n<|/ c |>\n<| a dscore=2 tags=ruby,arrays |>\nHow about this?\n\
    <code>", "  numbers = Array.new\n  numbers.clear\n  numbers.concat numbers\n \
    \ numbers.uniq!\n  numbers\nend", "  numbers.uniq.sort!\n  numbers.shift\nend\n\
    </code>\n<|/ a |>\n<| a dscore=0 tags=ruby |>\nIf you want a more efficient method,\
    \ and don't mind using an array and some kind of hash (this would work with any\
    \ kind of object), you can use the uniq method:\n<code>\nnumbers = [1,4,4,3,5,7,4,6,7]\n\
    numbers.uniq", "  result = numbers.uniq!\n  result.each do |number|\n    number.downto(result)\
    \ do |next_number|\n      break if number == next_number\n    end\n  end\n  result\n\
    end", "  numbers.uniq.compact\nend\n</code>\n<|/ a tags=arrays,ruby |>\n<| c |>\n\
    This should be the accepted answer since it's the most straight forward.\n<|/\
    \ c |>\n<| a tags=arrays,ruby |>\nRuby's Set is the best option if you want to\
    \ preserve the original order of items in the array.\nTo preserve the order of\
    \ items in the array use the Hash class.\nHash.new { |h, k| h[k] = [] } ensures\
    \ that the value of each item in the set is an empty array ([]).\n<code>\na =\
    \ [1, 2, 2, 3, 3, 4]\nHash.new{ |h, k| h[k] = [] }.each { |k,v| h[k].push(a[k])\
    \ }\np a", "  numbers.uniq.each { |x| numbers.delete(x) }\nend", "  numbers.uniq.compact\n\
    end", "  duplicates = []\n  number_index = 1\n  number_index.times do |i|\n  \
    \  duplicate = numbers.shift\n    unless duplicates.include? duplicate\n     \
    \ duplicates.push(duplicate)\n    end\n  end\n  duplicates\nend", "  seen = {}\n\
    \  numbers.map do |n|\n    seen[n] ||= []\n    seen[n] << n\n  end", "  numbers_to_remove\
    \ = numbers.uniq.select { |n| numbers.count(n) == 1 }\n  numbers.reject { |n|\
    \ numbers_to_remove.include?(n) }\nend", "  numbers.uniq!\nend", "  numbers.compact.uniq.compact\n\
    end", "  # Create a hash with no duplicates.\n  hash = {}\n  # Iterate over the\
    \ array.\n  numbers.each do |number|\n    # Check if this number exists in the\
    \ hash. \n    if hash[number]\n      # Already seen, remove this number.\n   \
    \   hash[number] = nil\n    else\n      # Not seen before, add this number to\
    \ the hash.\n      hash[number] = true\n    end\n  end\n  # Convert to an array,\
    \ sorted by keys.\n  numbers.sort { |a, b| a <=> b }\nend", "  numbers_sorted\
    \ = numbers.sort\n  numbers.delete_if { |x| numbers_sorted.count(x) == 1 }\n \
    \ numbers\nend", "    numbers.uniq!\n    numbers\nend", "  numbers.uniq!\n  numbers\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
