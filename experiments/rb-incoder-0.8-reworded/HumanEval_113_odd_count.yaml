name: HumanEval_113_odd_count
language: rb
prompt: "# Given an array of strings, where each string consists of only digits, return\
  \ an array.\n# Each element i of the output should be \"the number of odd elements\
  \ in the\n# string i of the input.\" where all the i's should be replaced by the\
  \ number\n# of odd digits in the i'th string of the input.\n# >>> odd_count.call([\"\
  1234567\"])\n# [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n\
  # >>> odd_count.call([\"3\", \"11111111\"])\n# [\"the number of odd elements 1n\
  \ the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of\
  \ the 8nput.\"]\ndef odd_count(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_odd_count\n\
  \    candidate = method(:odd_count)\n    assert_equal([\"the number of odd elements\
  \ 4n the str4ng 4 of the 4nput.\"], candidate.call([\"1234567\"]))\n    assert_equal([\"\
  the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd\
  \ elements 8n the str8ng 8 of the 8nput.\"], candidate.call([\"3\", \"11111111\"\
  ]))\n    assert_equal([\"the number of odd elements 2n the str2ng 2 of the 2nput.\"\
  , \"the number of odd elements 3n the str3ng 3 of the 3nput.\", \"the number of\
  \ odd elements 2n the str2ng 2 of the 2nput.\"], candidate.call([\"271\", \"137\"\
  , \"314\"]))\n  end\nend\n"
completions: ["  return lst.map {|s| s.chars.map {|c| c.to_i}.count {|c| c % 2 ==\
    \ 1 }}.map {|s| s.join(' ') }}\nend", "  if lst.is_a?(Array)\n    return lst.map\
    \ { |e| odd_count(e) }\n  end\n  lst.gsub!(/[^\\d]/, '')\n  if lst.length % 2\n\
    \    lst.delete_at(lst.length/2)\n  else\n    lst.delete_at(0)\n  end\n  lst.chars.each_with_index.inject(0)\
    \ do |m, s| \n    m += 1 if s % 2 != 0\n  end\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nThe solution you propose doesn't give the expected result. `[1,2,3,4,5].count\
    \ { |x| x % 2 != 0 }` is `3`, but should be `5`.\n<|/ c |>\n<| c |>\nYes. I should\
    \ clarify that I had tested that code on ruby 1.8.7. `[1,2,3,4,5].count { |x|\
    \ x % 2 != 0 }` is `5`\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  lst.map { |str|\
    \ str.chars.map { |x| x.to_i }.count { |x| x % 2 != 0 } }\nend", "  arr.each do\
    \ |i|\n    puts i.gsub!(/\\d/) { |m| m.to_i.odd? ? m.to_i : 1 }\n  end\nend",
  "  lst = lst.map { |s| s.to_s.split(\"\").select { |e| e =~ /^\\d+$/ && !e.empty?\
    \ }.size }\n  result = lst.map { |s| s.length }\n  result.inject(:+)\nend", " \
    \ count = 0\n  lst.each do |s|\n    count += s.chars.inject(0) do |sum, char|\n\
    \      sum + 1 if char.to_i%2 == 1\n    end\n  end\n  count = count.to_s\n  count\
    \ = count.gsub(/\\d+/) {|s| s.to_i}\n  count.gsub(/[^0]/, '').split(//).map {|s|\
    \ s.to_i}\nend", "  even = lst.select { |s| s.chars.all? { |c| c == '0' } }\n\
    \  odd = lst.select { |s| s.chars.all? { |c| c != '0' } }\n  even.map { |str|\
    \ str.chars.map { |c| c.to_i * (-1) + 1 }.inject(:+) }\n  odd.map { |str| str.chars.map\
    \ { |c| c.to_i }.inject(:+) }\nend", "  lst.map { |s| s.chars.inject(0) { |s,\
    \ c| s + [c % 10] % 2 == 1 }.size }\nend\n</code>\n<|/ a |>\n<| c |>\nThis looks\
    \ like the fastest answer thus far. I think I can see how this can speed things\
    \ up a bit, thanks for posting it.\n<|/ c |>\n<| c |>\nFor a large enough input\
    \ size you should see a significant improvement on readability. However the code\
    \ is not actually any faster.\n<|/ c |>\n<| c |>\nIf anyone is interested, I've\
    \ benchmarked some of the other answers in this thread, including the accepted\
    \ answer. [The fastest answer](http://stackoverflow.com/a/14151666/838992) is\
    \ the `odd_count.map` solution, with timing numbers in comments above.\n<|/ c\
    \ |>\n<| c |>\nI'm a bit surprised that your timing numbers are any different\
    \ than mine. `odd_count.map` seems to be the fastest by a large margin, while\
    \ my `odd_count.inject` solution was twice as fast.\n<|/ c |>\n<| c |>\nThis was\
    \ the result of a few tests on my machine. I'm running Ruby 1.9.3-p125 (2012-02-16)\
    \ [i686-darwin9] and JRuby 1.6.7.\n<|/ c |>\n<| a tags=ruby,inject,enumerable\
    \ |>\nHere's a version that has more of an explanation and is cleaner IMHO. \n\
    <code>", "  lst.each_with_index.inject([]) do |a,(e,i)|\n    a.push(\"the number\
    \ of odd elements #{i} #{e} of the #{e}nput.\") if i % 2 == 1\n    a\n  end\n\
    end", "    count = 0\n    arr = arr.to_a\n    arr.each do |x|\n        count +=\
    \ x.count(\"1\") - (x.count(\"0\") || 1)\n    end\n    count\nend\n</code>\n<|/\
    \ a tags=ruby |>\n<| a tags=ruby |>\nHere's a quick solution that should be efficient\
    \ (O(n)). \n<code>", "  n = 0\n  odd_str = []\n  i = 0\n  while i < lst.size\n\
    \    n.even? ? n += 1 : n -= 1\n    odd_str << n.to_s\n    i += 1\n  end\n  odd_str\n\
    end", "  results = []\n  lst.each do |s|\n    results << s.to_i.to_s.length -\
    \ s.scan(/\\d/).length\n  end\n  results\nend", "  return map(\"the number of\
    \ odd elements {count} of the str{count} of the {input}\", lst.map.with_index.to_a)\n\
    end", "  if lst.size == 0\n    []\n  else\n    even = lst.each_with_object([]).to_a\n\
    \    odd = lst.collect do |str|\n      str.chars.each_with_object([]).inject(0)\
    \ {|sum, char| sum + str[char].to_i(2)} #String#to_i returns 0 for non digit.\n\
    \    end\n    (even + odd).map {|num| [num.digits.count, num.digits.reduce(:+)]\
    \ }\n  end\nend", "  odd_sum = 0\n  odd_count = 0\n  \n  lst.each do |str|\n \
    \   str.each_char.with_object({}) do |char, occs|\n      next if char.to_i.odd?\n\
    \      occs['odd'] = occs['odd'].to_i + 1\n      odd_sum = odd_sum + occs['odd']\n\
    \      odd_count += 1\n    end\n  end\n  \n  odd_sum.to_s.ljust(4, \"0\")\nend",
  "  lst.each do |x|\n    puts \"the number of odd elements for #{x} is: #{x.count(/_/)}\"\
    \n  end\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks, this helps tremendously.\
    \ :)\n<|/ c |>\n<| a dscore=0 tags=ruby |>\nJust for fun\n<code>\n[1,2,3].map{|x|\
    \ puts x.to_s.count('_')}\n</code>\n<|/ a |>\n<| c |>\nIt should be noted that\
    \ the code you give here will yield different results than the code in the question,\
    \ depending on the type of the argument. If the argument is `\"123_456\"`, for\
    \ example, your code will yield `1`, `2` and `1`; while the code in the question\
    \ will yield `3`, `4` and `2`. That's because `.count` counts *all* occurrences\
    \ of `_`, not just non-digits. To get the same results as in the question, use\
    \ `.count('_').to_f`, or `.count('_').to_i`.\n<|/ c |>\n<| c |>\n.Goswami I agree\
    \ that `\"123_456\".count('_').to_i` is probably the best solution for this particular\
    \ problem. But the OP should probably just consider what he really wants to do.\n\
    <|/ c |>\n<| c |>\nYeah, I was just adding that comment because I noticed that\
    \ myself after posting the comment. :)\n<|/ c |>\n<| c |>\nYes, I agree with you.\
    \ I just wanted to point out that there might be another use case where the code\
    \ in the question might give unexpected results.\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>\nodd_count = lambda {|x|\n  x.count('_').to_i\n}", "  strs = lst.collect{|s|\
    \ s.to_s}\n  strs.collect{|s| s.split(\"\").inject(0){|c,v| c+=1 if v%2==1;c}}\n\
    end", "  return [ \"the number of odd elements #{n} #{s} #{n}\" % (n, s=s.to_s)\
    \ for n in lst for s in \"0123456789\" if s.to_s.count(n) % 2 == 1]\nend", " \
    \   even = count_evens(lst)\n    odd = (even.map { |x| x.to_s.size }.to_a + even.map\
    \ { |x| x.to_s.chars.reject { |c| c.to_i==0 }.size }.to_a) - even.length\n   \
    \ odd.map { |x| x.to_s.gsub(/(?<=\\s)(?=[\\d])/,\"\").length}\nend\n</code>\n\
    <|/ a tags=ruby,arrays,string |>\n<| c |>\n`odd.map { |x| x.to_s.gsub(/(?<=\\\
    s)(?=[\\d])/,\"\").length}`\n<|/ c |>\n<| c |>\nThis isn't giving the correct\
    \ answer, `odd_count.call([\"1234567\"]) #=> [ \"the number of odd elements 4n\
    \ the str4ng 4 of the 4nput.\" ]`\n<|/ c |>\n<| c |>\n`odd.map { |x| x.to_s.gsub(/(?<=\\\
    s)(?=[\\d])/,\"\").length}`  Fixed that typo.\n<|/ c |>\n<| c |>\nOh... I thought\
    \ I had it fixed then... :)  Thanks for your help and time!\n<|/ c |>\n<| a tags=ruby,arrays,string\
    \ dscore=1 |>\nHere's my solution\n<code>", "  if lst.empty?\n    []\n  else\n\
    \    digits = lst.map(&:to_i)\n    odd_digits = digits.select(&:odd?)\n    odd_digits.inject([0,\
    \ \"\"]) do |memo, i|\n      memo[0] += 1\n      memo[1] += digits[i].to_s.length\
    \ if digits[i].odd?\n      memo\n    end\n  end\nend", "  lst.map { |s| s.chars.each.with_object(0)\
    \ }.group_by(&:odd?).map { |k, v| [k, v.length] }\nend", "  return lst.map { |s|\
    \ s.chars.reject(&:odd?).count }\nend\n</code>\n<|/ a tags=ruby,regex,ruby-on-rails\
    \ |>\n<| a tags=ruby,regex,ruby-on-rails dscore=0 |>\nThis is what I think would\
    \ be the best solution:\n<code>", "  odds = Array.new\n  lst.each do |item|\n\
    \    item.to_s.split(\"\").each_with_index do |c, i|\n      if i % 2 == 1\n  \
    \      odds[i] = \"#{odds[i] + 1}\"\n      end\n    end\n  end\n  return odds\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThank you for the response. Although\
    \ I like that it's more concise than mine, I am still having issues returning\
    \ the values correctly, and I'm not sure why. I edited my original post with my\
    \ current code.\n<|/ c |>\n<| c |>\nAh I see what you're saying now - I edited\
    \ my answer.\n<|/ c |>\n<| a |>\n<code>", "  return lst.map { |s| s.scan(/\\d+/).map(&:odd?).count(&:itself).join('\
    \ ') }\nend", "  lst.each do |i|\n    i.to_s.chars.each do |c|\n      if c.to_i\
    \ >= 10\n        digit = c.to_i.odd? ? '1' : '0'\n      else\n        digit =\
    \ c.to_i.odd? ? '0': '1'\n      end\n      puts \"the number of odd element#{digit}n\
    \ the str#{c}#{digit} of the str#{i}#{digit}.\"\n    end\n  end\nend", "  lst.map\
    \ {|s| s.split('').count {|c| c % 2 != 0}}\nend", "    odd_digits = []\n    odd_digits_count\
    \ = 0\n    odd_digits_sum = 0\n    odd_digits_sum2 = 0\n    for i in lst\n   \
    \     if i.to_s.match(/\\A\\d+\\Z/)\n            odd_digits_count += i.to_s.length\n\
    \            odd_digits_sum += i.to_s.length.to_i\n            odd_digits_sum2\
    \ += i.to_s.length.to_i * i.to_s.length.to_i\n            odd_digits << i.to_s.length.to_i\
    \ * i.to_s.length.to_i\n        else\n            odd_digits_count += 0\n    \
    \        odd_digits_sum += 0\n            odd_digits_sum2 += 0\n            odd_digits\
    \ << 0\n        end\n    end\n    odd_digits.inject([]) {|acc, i| acc << [acc.length,\
    \ sum2(acc)]}\n    odd_digits.uniq.inject([]) {|acc, i| acc << [acc.length, sum2(acc)]}\n\
    \    odd_digits.uniq.map {|i| i << \"the number of odd elements \" * odd_digits_count\
    \ * \" the str\" * odd_digits[i] * \" of the str\" * odd_digits_sum2 \" of the\
    \ str\" * odd_digits_sum * \".\"}\nend\n</code>\n<|/ a dscore=1 tags=ruby,arrays\
    \ |>\n<| c |>\nI really appreciate this, and i did manage to write an almost identical\
    \ solution myself with just a little bit of tweaking of my original methods. I'll\
    \ post it as an answer in the next minute and you too if I like it. My answer\
    \ would be very similar, and i'm guessing your solution is more efficent than\
    \ mine would be. Either way, it's good to have two different ways to do it!\n\
    <|/ c |>\n<| c |>\nActually, your first answer is a bit more efficent than mine\
    \ because it doesn't go through the entire array twice, it only goes through it\
    \ once, sums the digits, and then creates a new array based on those sums. Mine\
    \ is a bit inefficient because it goes through the array twice, and it takes more\
    \ memory because it creates a new array in each loop.\n<|/ c |>\n<| c |>\nThis\
    \ is not true. The first loop is just for counting the numbers of digits in each\
    \ string. It doesn't have to go through each string more than once, because it\
    \ can just go through the string once, and count the numbers of digits in it.\
    \ Then, when you get the length of the string, you can multiply it by that numbers\
    \ of digits and sum that number to the total sum. Mine only goes through each\
    \ string once.\n<|/", "  lst.map! do |x|\n    x.to_s.split(\"\").map { |y| y[-1]\
    \ == \"1\" ? 1 : 0 }.count\n  end.flatten\nend\nputs odd_count.call([\"1234567\"\
    ])\nputs odd_count.call([\"3\", \"11111111\"])", "  counts = (0...lst.count).to_a.map\
    \ { |i| (lst[i].count('9') % 2) }\n  return [ \"the number of odd elements #{\
    \ counts } \" + lst.map {|s| s.count('9') % 2 }.inject(:+) ]\nend", "  odd_count_result\
    \ = [0] * len(lst)\n  odd_count_result.each_with_index do |element, index|\n \
    \   odd_count_result[index] = element.count('1')\n  end\n  return odd_count_result\n\
    end", "  lst.map!{|str| str.count('1')}\n  lst.map!{|str| str.count('9')}\n  lst.map!{|str|\
    \ str.count('0')}\n  lst.map!{|str| str.count('5')}\nend", "    odd_digits = lst.map\
    \ {|s| s.length % 2 != 0}\n    odd_count = odd_digits.inject([0,0]){ |memo, i|\
    \ memo[0] + odd_digits[i].to_i + 1, memo[1] }\n    odd_count.map { |s| \"the number\
    \ of odd elements #{s} of the #{s}input.\"}\nend", "  lst.map {|s| s.to_s.chars.map\
    \ {|c| c.to_i.to_s.split(//).count {|x| x.is_a?(Integer) && x.odd?}}.map {|c|\
    \ c.count}}.flatten.map {|x| x.to_s.split(//).size if x }.compact.map {|s| s.to_s\
    \ + \"'nth odd digit\"}\nend\n</code>\n<|/ a tags=ruby,string |>\n<| a dscore=0\
    \ tags=ruby,string |>\n<code>", "  lst.map!{|str| str.gsub(/\\d/).length}\n  lst.map!{|num|\
    \ lst.count(num.to_s.to_i)}\n  lst.map!{|num| num.odd? ? \"#{num} number of odd\
    \ elements\" : \"#{num} number of even elements\"}\n  lst\nend\n</code>\n<|/ a\
    \ dscore=0 |>\n<| a |>\n<code>", "  lst.each.with_index.inject([]) do |a,i|\n\
    \    a << lst.each.with_index.select { |s| s =~ /^\\d+/ }.size << i\n    a\n \
    \ end\nend", "  lst.map(&:to_i).select { |n| n % 2 == 1 }\nend", "  return lst.inject([])\
    \ { |memo,str|\n    if str =~ /^\\d+$/\n      len = str.to_s.length\n      memo\
    \ << [len, str.count(str[len.to_s.length..-1])]\n    else\n      memo << str\n\
    \    end\n    memo\n  }\nend", "  lst.each {|x| puts \"the number of odd elements\
    \ #{x}n the str#{x.count('1')}#{x.count('0')} of the #{x.count('0') > x.count('1')\
    \ ? x.count('1') : x.count('0') } nput.\" if x.count('0') > x.count('1')}\nend",
  "  lst.inject([]) {|result, x| result + [x.to_s.scan(/(\\d+)\\D/).map {|n| n.to_i}\
    \ % 2 == 1 ? 2 : 1]}\nend", "  lst.each do |i|\n    i.split(\"\").inject(0) do\
    \ |sum,n|\n      sum + 1 if n % 2 == 1\n    end\n  end\nend", "  return lst.inject([])\
    \ do |acc, x|\n    acc.map { |y| x.count(y) % 2 == 1 ? y.count(y) : y }\n  end\n\
    end", "  lst.map do |s|\n    s[0].length.to_i * (s[1..-1].length.to_i - 1)\n \
    \ end\nend", "  result = []\n  even = odd(lst)\n  result.concat(even.map {|x|\
    \ x * 2} )\n  result.concat(even.map {|x| x * 3} )\n  result.concat(even.map {|x|\
    \ x * 4} )\n  result.concat(even.map {|x| x * 5} )\n  result.concat(even.map {|x|\
    \ x * 6} )\n  result.concat(even.map {|x| x * 7} )\n  result.concat(even.map {|x|\
    \ x * 8} )\n  result.concat(even.map {|x| x * 9} )\n  result.concat(even.map {|x|\
    \ x * 10} )\n  result.concat(even.map {|x| x * 11} )\n  result.concat(even.map\
    \ {|x| x * 12} )\n  result.concat(even.map {|x| x * 13} )\n  result.concat(even.map\
    \ {|x| x * 14} )\n  result.concat(even.map {|x| x * 15} )\n  result.concat(even.map\
    \ {|x| x * 16} )\n  result.concat(even.map {|x| x * 17} )\n  result.concat(even.map\
    \ {|x| x * 18} )\n  result.concat(even.map {|x| x * 19} )\n  result.concat(even.map\
    \ {|x| x * 20} )\n  result.concat(even.map {|x| x * 21} )\n  result.concat(even.map\
    \ {|x| x * 22} )\n  result.concat(even.map {|x| x * 23} )\n  result.concat(even.map\
    \ {|x| x * 24} )\n  result.concat(even.map {|x| x * 25} )\n  result.concat(even.map\
    \ {|x| x * 26} )\n  result.concat(even.map {|x| x * 27} )\n  result.concat(even.map\
    \ {|x| x * 28} )\n  result.concat(even.map {|x| x * 29} )\n  result.concat(even.map\
    \ {|x| x * 30} )\n  result.concat(even.map {|x| x * 31} )\n  result.concat(even.map\
    \ {|x| x * 32} )\n  result.concat(even.map {|x| x * 33} )\n  result.concat(even.map\
    \ {|x| x * 34} )\n  result.concat(even.map {|x| x * 35} )\n  result.concat(even.map\
    \ {|x| x * 36} )\n  result.concat(even.map {|x| ", "  lst.map {|s| s.split(//).length}\n\
    end", "    arr = lst.map {|e| e.to_s.chars.map(&:to_i).map(&:odd?).reduce(:+)\
    \ }\n    arr.map {|n| n==0 ? \"0\" : \"the number of odd elements #{n} of the\
    \ str#{n}\".gsub(/n(\\d+)$/, '\\1') }\nend", "  lst.each {|s| return \"the number\
    \ of odd elements \" + s.gsub(/\\d/, 'n') + \"n the str\" + s.gsub(/\\d/, 'n')\
    \ + \"n of the \" + s.gsub(/\\d/, 'n') + \".\" } \nend\n</code>\n<|/ a |>\n<|\
    \ c |>\nAwesome. Thank you!\n<|/ c |>\n<| a dscore=1 tags=ruby,regex |>\nHow about\
    \ this:\n<code>", "  lst.map! { |x| x.to_s.split(\"\").map { |y| y.to_i }.inject(:*)\
    \ }\n  lst.map { |x| x.inject(:*) }\nend", "  o = []\n  l.each {|i|\n  o.push\
    \ \"the number of odd element\" + i.to_s.length.to_s + \" in the \" + i.to_s.to_s\
    \ + \" is: \" + i.to_s.chars.select {|x|\n    x.to_s.to_s.length % 2 == 1 }.to_s.length.to_s\n\
    \  }\n  return o\nend", "  sum = 0\n  odd_lst = []\n  for i in lst\n    if i.to_s.split(//).map(&:to_i).inject(:+)%2\
    \ == 1\n      odd_lst << i\n    end\n  end\n  odd_lst.map{|x| sum+= x.to_s.split(//).map(&:to_i).inject(:+)\
    \ }\n  sum.to_s\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails dscore=1 |>\n<| c\
    \ |>\n`odd_count.call([\"3\", \"11111111\"])` returns `[\"the number of odd elements\
    \ 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 1n the str1ng\
    \ 1 of the 1nput.\"]` when it should only return `[\"the number of odd elements\
    \ 1n the str1ng 1 of the 1nput.\"]` which is what my code is returning.\n<|/ c\
    \ |>\n<| c |>\nI'm getting a syntax error in the code above. Did you make any\
    \ changes?\n<|/ c |>\n<| c |>\nYour code returns `\"the number of odd elements\
    \ 8n the str8ng 8 of the 8nput.\"` when it should only return `\"the number of\
    \ odd elements 1n the str1ng 1 of the 1nput.\"`\n<|/ c |>\n<| c |>\nSorry, I thought\
    \ it was obvious how to fix the logic. See the edited answer.\n<|/ c |>\n<| c\
    \ |>\nI'm getting a syntax error in the code above. Did you make any changes?\n\
    <|/ c |>\n<| a dscore=1 |>\nFor each digit, you can check if it's odd by using\
    \ modulo (%) 2\n<code>", "  lst.map { |s| s.length % 2 == 1 ? s.length.to_i *\
    \ 2 : s.length.to_i }\nend\n</cell>\n<cell>", "  return [x.count { |x| x.odd?\
    \ } for x in lst]\nend", "  output = []\n  for i in lst\n    count  = 0\n    while\
    \ i != '0'\n      i =~ /\\d/ && count += 1 if $&.odd?\n    end\n    output <<\
    \ \"the number of odd elements #{ count } of the str#{ i.size } of the #{ i }\
    \ input.\"\n  end\n  return output\nend", "    odd_digits = []\n    lst.each do\
    \ |word|\n        odd_digits.push(word.split(//).map { |i| i.to_i }.select { |i|\
    \ i.odd? }.size)\n    end\n    odd_digits\nend\n</code>\n<|/ a dscore=0 tags=ruby\
    \ |>\n<| c |>\nHmm, I like the idea of using hashes to keep the counts. I never\
    \ thought about using an array. Thanks for the help!\n<|/ c |>\n<| a |>\nA more\
    \ compact way in Ruby 1.9 is to count the number of odd digits per string:\n<code>\n\
    numbers = [ \"1234567\",\n            \"3\",\n            \"11111111\",\n    \
    \        \"01234567\",\n            \"123123123\",\n            \"111111122\"\
    \ ]", "  even = lst[0].length.to_i\n  odd = lst.map { |x| x.chars.map{ |c| c.to_i}}.transpose.map\
    \ { |x| x.map { |y| y*2}}.inject(0){ |sum, el| sum + el }\n  [ even.to_s + \"\
    \ (the number of odd elements \" + even.to_s + \"n the str\" + even.to_s.to_s\
    \ + \" of the \" + even.to_s + \" input)\", odd.to_s + \" (the number of odd elements\
    \ \" + odd.to_s + \"n the str\" + odd.to_s.to_s + \" of the \" + odd.to_s + \"\
    \ input)\" ]\nend", "  return lst.map { |num| num_odd(num) }\nend\n</code></pre>\n\
    </div>", "  odd_count = 0\n  result = \"\"\n  for i in lst\n    digits = i.to_s.split(//)\n\
    \    odd_count += digits.length\n    result += \"the number of odd elements \"\
    \ + digits.length.to_s + \" the str\" + digits.length.to_s + \"of the \" + digits.length.to_s\
    \ + \"nput.\"\n  end\n  result\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n`digits\
    \ = i.to_s.split(//)` should be `digits = i.to_s.split(//)` (drop the trailing\
    \ `'` after `//`).\n<|/ c |>\n<| a tags=ruby |>\nHere's another solution. \nIt\
    \ converts strings to integers and sums up their powers of two, i.e. powers of\
    \ 2.\nIt also avoids the use of count, and it uses the each_cons iterator.\n<code>",
  "  digits = lst.collect {|i| i.to_s.split(//).select {|s| s.match(/^\\d+$/)}}\n\
    \  odd_digits = digits[0..-2].inject{|sum, digit| sum + digit.count {|x| x % 2\
    \ == 0}}\n  digits[0..-2].inject{|sum, digit| sum + digit.count {|x| x % 2 ==\
    \ 1}}\nend", "  if lst.blank?\n    []\n  else\n    lst.each_with_index do |value,\
    \ index|\n      value.chars.each_with_index do |char, i|\n        if i % 2 !=\
    \ 0\n          lst.delete(index)\n          break\n        end\n      end\n  \
    \  end\n    odd_count(lst)\n  end\nend", "  lst.each do |str|\n    str2 = str.chars.map\
    \ { |s| s.to_i }\n    odd_count = str2.reject { |s| s == 0 }.length\n    str2.each\
    \ do |num|\n      next if num == odd_count\n      str2.delete(num)\n    end\n\
    \    str2.each_with_index do |num, i|\n      str[i] = \"the number of odd elements\
    \ #{odd_count}n the str#{num}#{i + 1}\"\n    end\n  end\nend", "  lst.flatten.inject([]){\
    \ |sum, str|\n    sum + str.split(//).select { |x| x.to_i.odd? }.size\n  }\nend",
  "  lst.inject([]) { |memo, string| memo << memo.length.odd? ? memo.length.odd? :\
    \ memo << string }\nend", "  lst.map do |el|\n    count = el.to_s.length.odd?\
    \ ? el.to_s.length : nil\n    el.gsub!('n', ''.pluralize(el.to_s.length))\n  \
    \  el.gsub!('n', ''.pluralize(count))\n  end\nend", "  lst.inject([]) do |sum,\
    \ elem|\n    sum << elem.to_i.odd? ? \"the number of odd elements #{elem.to_i}\
    \ of the #{elem.to_s}nput.\" : \"the number of odd elements #{elem.to_i} of the\
    \ #{elem.to_i}nput.\"\n  end\nend", "  n = []\n  n.push(\"the number of odd elements\"\
    )\n  n.push(\"n the str\")\n  n.push(\"n of the input\")\n  n.push(\"str the str\"\
    )\n  n.push(\"str of the input\")\n  n.push(\"the input\")\n  n.push(\"the input\
    \ str\")\n  n.push(\"the input str of the input\")\n  n.push(\"the str of the\
    \ input\")\n  n.push(\"the str of the input\")\n  n.push(\"the input str of the\
    \ input\")\n  n.push(\"the input str of the input\")\n  n.push(\"the str of the\
    \ input\")\n  n.push(\"the str of the input\")\n  n.push(\"the input str of the\
    \ input\")\n  n.push(\"the input str of the input\")\n  n.push(\"the str of the\
    \ input\")\n  n.push(\"the str of the input\")\n  n.push(\"the input str of the\
    \ input\")\n  n.push(\"the input str of the input\")\n  n.push(\"the str of the\
    \ input\")\n  n.push(\"the str of the input\")\n  n.push(\"the input str of the\
    \ input\")\n  n.push(\"the input str of the input\")\n  n.push(\"the str of the\
    \ input\")\n  n.push(\"the str of the input\")\n  n.push(\"the input str of the\
    \ input\")\n  n.push(\"the input str of the input\")\n  n.push(\"the str of the\
    \ input\")\n  n.push(\"the str of the input\")\n  n.push(\"the input str of the\
    \ input\")\n  n.push(\"the input str of the input\")\n  n.push(\"the str of the\
    \ input\")\n  n.push(\"the str of the input\")\n  n.push(\"the input str of the\
    \ input\")\n  n.push(\"the input str of the input\")\n  n.push(\"the str of the\
    \ input\")\n  n.push(\"the str of the input\")\n  n.push(\"the input str of the\
    \ input\")\n  n.push(\"the input str of the input\")\n  n.push(\"the str of the\
    \ input\")\n  n.push(\"the str of the input\")\n  n.push(\"the input str of the\
    \ input\")\n  n.push(\"the input str of the input\")\n  n.push(\"the str of the\
    \ input\")\n  n.push(\"the str of the input\")\n  n.push(\"the input str of the\
    \ input\")\n  n.push(\"the input str of the input\")\n  n.push(\"the str of the\
    \ input\")\n  n.push(\"the str of the input\")\n  n.push(\"the input str of the\
    \ input\")\n  n.push(\"the input str of the ", "  lst.map! {|s| s.to_s.chars.reject\
    \ {|c| c.to_i.odd? }}.inject([]) {|s, i| s << sprintf(\"the number of odd elements\
    \ %dn the str%2$*% %d of the %1$*% %d\", i.length, *i.map! {|s| s.to_i.odd? }.zip([0]).map\
    \ {|s| s.last + 1 }).join(\", \") }\nend\n</code>\nAs you can see, this can be\
    \ made quite a lot smaller, by removing the redundant map! and inject!.\n<code>",
  "  lst.each do |e|\n    p e.to_s.scan(/[+-]?\\d+/).inject(0) {|s,v| s +1 if v =~\
    \ /\\d/ && v.to_i.odd?}\n  end\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1\
    \ |>\nA little more concise, using Enumerable#map to turn each string into a sequence\
    \ of numbers:\n<code>", "  # Your code here\n  output = []\n  for i in lst\n \
    \   count = 0\n    arr = i.split(\"\")\n    arr.each { |x| x =~ /[13579]/ ? count\
    \ += 1 : count = 0 }\n    output << \"the number of odd elements \" + count.to_s\
    \ + \"n the str\" + arr.join(\"n\") + \"of the \" + i.size + \".\"\n  end\n  output\n\
    end", "  return lst.map { |s| s.length.to_s.length - s.to_s.gsub(\"0\", \"\").length\
    \ }.uniq\nend", "  ret = []\n  lst.each do |i|\n    num = 0\n    i.split('').each\
    \ do |num|\n      num += 1 if num =~ /[13579]/ && num != 0\n    end\n    ret <<\
    \ \"the number of odd elements\" << num.to_s << \" of the str\" << i << \" of\
    \ the str\" << i << \".\" if num != 0\n  end\n  ret\nend", "  odd_counter(lst).map\
    \ { |s| s.length }.inject(:+)\nend", "  lst.each_with_index do |str, index|\n\
    \    if index == 0\n      puts \"#{str} is an empty string\"\n      next\n   \
    \ elsif str.empty?\n      puts \"#{str} has no odd numbers\"\n      next\n   \
    \ end\n    puts \"#{str} has #{str.scan(/\\d/).size - str.scan(/\\d/).to_s.length}\
    \ odd digits\"\n  end\nend\n</code>\nThe above method is used as:\n<code>\nputs\
    \ odd_count.call([\"1234567\"])", "  even = lst.each_with_index.map { |s,i| (i\
    \ % 2) == 0 ? s : nil }\n  odd = even.compact.map { |s| s.split(\"\").count {\
    \ |e| e =~ /\\d/ } }.compact\n  odd.each_with_index.map { |s,i| [\"the number\
    \ of odd elements #{@input_lengths[i - 1]} #{@input_strings[i - 1]} of the #{@input_lengths[i\
    \ - 1]} #{@input_strings[i - 1]}.\"].join(\"\\n\") }\nend", "  lst.map { |s| s.chars.map(&:to_i).reduce(:&)\
    \ }\nend", "  lst.map do |str|\n    str.scan(/\\d/).map do |digit|\n      digit.to_i.odd?\
    \ ? digit.to_i : digit.to_s.length\n    end.inject(0, :+)\n  end\nend", "    evens\
    \ = lst.reverse.inject(:+)\n    odds = evens.divmod(10)\n    \n    return evens,\
    \ odds\nend", "  odd_array = []\n  odd_count = 0\n  for x in lst\n    if Integer(x)%2\
    \ == 1\n      odd_count += 1\n    end\n  end\n  odd_array << \"the number of odd\
    \ elements #{odd_count} of the #{lst[0]}.\"\n  odd_array.map do |x|\n    x.gsub(/n\
    \ the /, \" of the \")\n  end\nend", "  # your code goes here\n  count = Array.new\n\
    \  lst.each do |x|\n    if x.is_a? String\n      if x.to_s.chars.sort.uniq.count\
    \ > 1\n        x =  \"the number of odd elements #{x.to_s.chars.sort.uniq.count}\
    \ the #{x.to_s.chars.sort.uniq.count}nd str#{x.to_s.chars.sort.uniq.count} of\
    \ the #{x.to_s.chars.sort.uniq.count}nput.\"\n      end\n    end\n    count.push(x)\n\
    \  end\n  count\nend\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| c |>\nI'm getting\
    \ `[\"the number of odd elements 2n the strnng 2 of the 2nput.\"]\n[\"the number\
    \ of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements\
    \ 8n the str8ng 8 of the 8nput.\"]`\n<|/ c |>\n<| c |>\nI just posted an answer\
    \ with my code, so you can see what I'm talking about\n<|/ c |>\n<| c |>\nThanks\
    \ for your help, But I'm also still getting the same `[\"the number of odd elements\
    \ 2n the strnng 2 of the 2nput.\"]\n[\"the number of odd elements 1n the str1ng\
    \ 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"\
    ]` when I use the code\n<|/ c |>\n<| c |>\nI just realized, I was using a different\
    \ array in my test, so I changed my answer, you can try it again\n<|/ c |>\n<|\
    \ c |>\nThanks a lot you for your help.\n<|/ c |>\n<| a |>\nYou can just use gsub\
    \ with a regex pattern and count the matches:\n<code>", "  if lst.empty?\n   \
    \ []\n  else\n    count = lst.map { |str| str.count(/\\d/) }\n    odd_count =\
    \ count.map { |c| c + c%2 }\n    odd_count.map { |c| c.to_s.gsub(/\\D/, ' ') }\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,string,ruby-on-rails |>\n<| c |>\nWhile\
    \ this may work for the given input, it would fail in other cases, e.g.: `odd_count.call([\"\
    123456789\"])`, which would return `[\"the number of odd elements 1n the str1ng\
    \ 1 of the 1nput.\", \"the number of odd elements 11n the str11ng 11 of the 11nput.\"\
    ]`, but should return `[\"the number of odd elements 9n the str9ng 9 of the 9nput.\"\
    ]`.\n<|/ c |>\n<| c |>\nI agree with you, I think the input may contain too many\
    \ digits. We just need to handle it in this case, which is easy.\n<|/ c |>\n<|\
    \ c |>\nI updated my answer to handle input such as `\"123456789\"`, which would\
    \ return `[\"the number of odd elements 9n the str9ng 9 of the 9nput.\"]`.\n<|/\
    \ c |>\n<| c |>\nThanks for this. I actually just realized that I was getting\
    \ some funky results with this because this was actually a class method on some\
    \ other model I'm using, I guess I should have gone with something else. I will\
    \ accept this if someone else doesn't beat me to it.\n<|/ c |>\n<| c |>\nI should\
    \ probably note that this code was a quick answer that I typed in, as I didn't\
    \ want to give the code too much of a whirl on a sieve for testing. I'd really\
    \ recommend doing something more robust with regex, like `\\d` instead of just\
    \ `/\\d/` as this will also match `1` and `12`.\n<|/ c |>\n<| a dscore=2 |>\n\
    <code>", "  return lst.inject([]) do |arr, str|\n    arr.concat(str_count(str).map(&:odd?))\n\
    \  end\nend", "  lst.each_with_index do |str, i|\n    puts \"the number of odd\
    \ elements for #{str.to_s} is #{str.scan(/\\d/).length}\"\n  end\nend", "  result\
    \ = []\n  i = 0\n  while i < lst.length\n    result.push \"the number of odd elements\
    \ #{lst.slice!(i, i+2).reduce(:+)} #{lst.slice!(0, i+2).reduce(:+)} of the #{lst.slice!(0,\
    \ i+2).reduce(:+)} #{lst.slice!(0, i+2).reduce(:+)}.\"\n    i += 1\n  end\n  result\n\
    end", "  return lst.collect {|x| x.to_s.chars.uniq.inject(0) {|sum, s| sum + s.to_i(2)}}\n\
    end", "  result = []\n  str_count = lst.inject(0) do |count, str|\n    str_count.times\
    \ { count += 1 unless str =~ /\\d/ }\n  end\n  str_count = str_count.to_i\n  str_count.times\
    \ do |count|\n    result << \"the number of odd elements #{\"%.0f\"%count}n the\
    \ str#{\"%03d\"%count}ng #{count}#{count < 100?\"0\":\"\"} of the #{str_count.to_s}nput.\"\
    \n  end\n  result\nend", "  number_of_odd_elements = 0\n  number_of_inputs = 0\n\
    \  number_of_digits_odd_elements = 0", "  # Your code here\n  odd = lst.select\
    \ do |item|\n    item.to_s.chars.map(&:to_i).inject(&:+)%2 == 1\n  end\n  odd.reduce([])\
    \ do |memo,item|\n    memo << [\"the number of odd elements\",item.to_s,\"in the\
    \ string\",item.to_s.chars,\"of the string\"].join(\" \")\n  end\nend", "  digits\
    \ = lst.map {|x| x.to_s.split(\"\").map(&:to_i).reduce(:&)}\n  odd_digits = digits.zip(digits).map\
    \ {|i| i.inject(0, :&) }\n  odd_digits.map {|a| a.length}.map {|x| [ \"the number\
    \ of odd elements\",x] }\nend", "  lst.map { |s| s.chars.map { |c| c % 2 == 1\
    \ ? '1' : '0' }.to_s }.inject(:+)\nend", "  lst.inject([]) do |count, x|\n   \
    \ count << x.to_s.length if x.to_s.chars.reduce(0) {|s,c| s+1 if c == '1'} ==\
    \ 1\n  end\nend", "  lst.size.times.map do |i|\n    lst[i].split.each_with_index\
    \ do |s, j|\n      next if s.empty? or s.size != 1\n      odd_number = s.select\
    \ {|x| x.to_i.odd?}.length\n      lst[i] = \"the number of odd elements #{ odd_number\
    \ } #{ s.inspect } in the #{ j }th string\" if odd_number\n    end\n  end\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThank you so much. I'm very much a beginner\
    \ and learning so much from your comments. I really appreciate your time and effort.\n\
    <|/ c |>\n<| c |>\nHi, no problem. I'm glad you were able to understand the code!\n\
    <|/ c |>\n<| c |>\nThanks again. I'm really excited about the answers you gave\
    \ me and how you think about my question. You've really helped me understand more\
    \ about Ruby and Ruby on Rails so I'm grateful. I really appreciate your time\
    \ and effort. Thank you!\n<|/ c |>\n<| a |>\nI'm just giving you a ruby program\
    \ that could give you an idea how to do it. I have made it more efficient that\
    \ way you can understand it better. \n<code>", "  return lst.inject([]) { |acc,\
    \ x| acc += 1 if x.to_s.scan(/\\d/).length == 1}.inspect\nend", "  return lst.map\
    \ {|s| s.scan(/\\d+/).length if s.match(/\\D/) }.compact\nend\n</code>\n<|/ a\
    \ tags=ruby,regex dscore=0 |>\n<| c |>\n`odd_count(\"123abc\")` returns `nil`\
    \ rather than `[1, 3]`. Also, the code would be more concise if you replace `if\
    \ s.match(/\\D/)` with `s.match(/\\d/).to_i`.\n<|/ c |>\n<| c |>\n: You're right.\
    \ `to_i` makes it work even with non-digit strings. And the `if s.match(/\\D/)`\
    \ was a leftover from when I tested it on multiple inputs (it didn't seem to work\
    \ anymore).\n<|/ c |>\n<| c |>\n`odd_count(\"123abc\")` returns `nil` rather than\
    \ `[1, 3]`\n<|/ c |>\n<| a dscore=0 tags=ruby,regex |>\n<code>", "  result = []\n\
    \  for str in lst\n    str = str.to_s.strip.to_i unless str.nil?\n    unless str\n\
    \      result << result[0].to_s.dup\n      next\n    end\n    result << result[0].to_s.dup\
    \ if result[0].is_a?(String)\n    odd = 0\n    str = str.to_s.strip.to_i unless\
    \ str.nil?\n    until str.nil?\n      odd += str % 10\n      str /= 10\n    end\n\
    \    result[0] << odd.to_s\n  end\n  return result\nend\n</code>\n<|/ a tags=ruby,functional-programming\
    \ dscore=2 |>\n<| a |>\nHere's another way of doing it.\n<code>", "  lst.each_with_index\
    \ do |str, index|\n    digits = str.chars.map(&:to_i)\n    odd_digits = digits.select\
    \ { |x| x % 2 != 0 }\n    count  = odd_digits.size\n    odd_digits.length == 0\
    \ ? \"the number of odd elements #{count} of the str#{index} of the #{index}input.\"\
    \ : odd_digits.map(&:to_s).to_sentence\n  end\nend", "    odd_count = 0\n    list_of_odd_count\
    \ = []\n    i = 0\n    \n    while i < lst.length\n        digits = lst[i].split('')\n\
    \        odd_count = odd_count + digits.count { |i| i.to_i & 1 }\n        list_of_odd_count\
    \ << odd_count\n        i += 1\n        odd_count = 0\n    \n    list_of_odd_count\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThe OP asked for a solution in ruby,\
    \ not C#. Your answer is very helpful.\n<|/ c |>\n<| c |>\n: That is true. I've\
    \ added a Ruby solution.\n<|/ c |>\n<| a tags=ruby |>\nUsing String#scan with\
    \ gsub:\n<code>\nputs [\"12323\".gsub(/\\d/, '&1')]", "  return lst.map { |x|\
    \ [x.size, x.size&1].join.inspect }\nend\n</code>\nThis gives the result you want:\n\
    <code>\nputs odd_count([\"1234567\"]).join(\"\\n\")", "  lst.map!{|x| x.to_i}\n\
    \  lst.each{|x| x.odd? ? @odds += 1 : @odds -= 1}\n  @odds.to_a\nend", "  result\
    \ = []\n  lst.each do |num|\n    result.push \"the number of odd elements \" +\
    \ num.count(num.rindex(num.rindex(num) + 1)) + \".\"\n  end\n  result\nend", " \
    \ odd = lambda n: (n & 1).nonzero? : nil\n  \n  if lst.is_a?(Array)\n    arr =\
    \ lst.dup\n  else\n    arr = [lst]\n  end\n  \n  arr.map do |x|\n    x.each_char.select\
    \ {|c| c.to_i.odd? }.size\n  end\nend", "  lst.each_with_index do |e, i|\n   \
    \ e = e[0] if e.is_a?(String)\n    puts \"the number of odd elements #{lst.count(e).to_s.count('0')}n\
    \ the str#{lst.count(e).to_s.count('0')} #{e}#{lst.count(e).to_s.count('0')} of\
    \ the #{lst.count(e).to_s.count('0')}nput.\"\n  end\nend", "  count = 0\n  i =\
    \ 0\n  while i < lst.length\n    if lst[i].to_i.odd? then count += 1 end\n   \
    \ i += 1\n  end\n  return [count]\nend", "  return [ \"the number of odd elements\
    \ \" + count.call(lst, /\\d+/) + \"n the str\" + count.call(lst, /\\d/) + \"ng\
    \ \" + count.call(lst, /\\d+/) + \"of the \" + count.call(lst, /\\d/) + \"nput.\"\
    \ ]\nend", "  count = []\n  odd_digits = 0\n  for i in lst\n    if i.to_s.chars.map(&:odd?).all?\n\
    \      count << i\n      odd_digits += i.to_s.chars.map(&:odd?).count\n    end\n\
    \  end\n  \n  count.map do |str|\n    \"the number of odd elements #{odd_digits}n\
    \ the str#{str.size}#{str.to_s.chars.count}#{str.to_s.chars.map(&:odd?).count}\
    \ in the #{i}th string\"\n  end\nend", "  odd_count_input = lst.map(&:to_i).reduce(:+)\n\
    \  return lst.map {|str| \"the number of odd elements #{odd_count_input.divmod(str.length)[1]}\
    \ the str#{str.length} of the str#{str.length}put.\"}\nend", "  result = []\n\
    \  for i in lst\n    result.push(count_odd(i))\n  return result\nend\n</code>\n\
    <|/ a tags=arrays,ruby dscore=0 |>\n<| c |>\nThanks for your help, but I don't\
    \ think I'm understanding where you mean to put this code. Are you saying I should\
    \ put this in my ruby file? I tried that, but it didn't work.\n<|/ c |>\n<| c\
    \ |>\nI put it in my ruby file and it didn't work. I also tried placing it in\
    \ my ruby file with the other function and it still didn't work. I placed it at\
    \ the bottom of my ruby file and that didn't work either. It said there was an\
    \ error at line 10\n<|/ c |>\n<| c |>\nI should add that I'm trying to get the\
    \ code I posted in my original question to work, but I'm not quite sure where\
    \ to place it in order to make it work.\n<|/ c |>\n<| c |>\nYour code works perfectly\
    \ fine and I understand what you are trying to do. Thanks. But I can't seem to\
    \ get this to work. I copied and pasted it into my ruby file and it still isn't\
    \ working. I placed it at the bottom of my ruby file and that didn't work either.\
    \ It said there was an error at line 10. I'm new to Ruby, but I have tried everything\
    \ I can think of to fix this. Any suggestions?\n<|/ c |>\n<| c |>\nCould you please\
    \ post your code here so that we can better see what you're doing wrong?\n<|/\
    \ c |>\n<| a dscore=0 tags=arrays,ruby |>\n<code>", "  lst.map { |el| el.chars.map\
    \ { |char| char.odd? ? 1 : 0 }.size }.inject(:+)\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=ruby,arrays,string dscore=1 |>\nIf you need the number of occurrences\
    \ of each character in a string, you can do:\n<code>", "  n = 0\n  while lst.count\
    \ > 0\n    n += lst.count % 2 == 1 ? 1 : 0\n    lst.shift 1\n  end\n  [n]\nend",
  "  return [ \"the number of odd elements #{n} the str#{n} #{n} of the #{n}put.\"\
    \ for n in lst.count{|s| s.is_a?(Integer)}+1 ]\nend", "  lst.map!{|x| x.to_s.split('').inject(0)\
    \ { |sum, element| sum + element.to_i.odd? ? sum + 1 : sum }}\n  lst.map!{|x|\
    \ x.to_s.split('').inject(0) { |sum, element| sum + element.to_i.odd? ? sum +\
    \ 1 : sum }}\n  lst\nend\n</code>\n<|/ a dscore=0 tags=string,ruby |>\n<| a dscore=0\
    \ |>\nI think you wanted something like this :\n<code>", "  o_c = lst.map {|i|\
    \ i.chars.map(&:to_i).inject(:&)}\n  o_c.map {|i| [\"the number of odd elements\
    \ #{i}n the str#{i} #{o_c.count(i)} of the str#{i} #{o_c.count(i)}\"].join(\"\\\
    n\")}\nend", "  lst = lst.dup\n  lst.delete('0').delete('1').delete('2').delete('3').delete('4').delete('5').delete('6').delete('7').delete('8').delete('9')\n\
    \  return lst.inject([]) do |count, str|\n    if str.length % 2 == 1\n      count\
    \ << str.length\n    else\n      odds = str.length/2\n      count << (odds - str.index(/0/).to_i)\
    \ if (odds - str.index(/0/).to_i) > 0\n      count << (odds - str.index(/1/).to_i)\
    \ if (odds - str.index(/1/).to_i) > 0\n      count << (odds - str.index(/2/).to_i)\
    \ if (odds - str.index(/2/).to_i) > 0\n      count << (odds - str.index(/3/).to_i)\
    \ if (odds - str.index(/3/).to_i) > 0\n      count << (odds - str.index(/4/).to_i)\
    \ if (odds - str.index(/4/).to_i) > 0\n      count << (odds - str.index(/5/).to_i)\
    \ if (odds - str.index(/5/).to_i) > 0\n      count << (odds - str.index(/6/).to_i)\
    \ if (odds - str.index(/6/).to_i) > 0\n      count << (odds - str.index(/7/).to_i)\
    \ if (odds - str.index(/7/).to_i) > 0\n      count << (odds - str.index(/8/).to_i)\
    \ if (odds - str.index(/8/).to_i) > 0\n      count << (odds - str.index(/9/).to_i)\
    \ if (odds - str.index(/9/).to_i) > 0\n    end\n    count\n  end\nend\n</code>\n\
    <|/ a |>\n<| a |>\n<code>", "  lst.map!(&:to_i)\n  lst.map { |e| lst.count(&:odd?).to_s\
    \ }\nend", "  if lst.empty? or lst.all?(&:blank?) #return if blank or if all blank\n\
    \    []\n  elsif lst.all?(&:digit?) # all strs are digits\n    lst.reduce(&:odd?).map{|s|\
    \ s.to_s.size }\n  else\n    odd_count(lst.take(1)).map{|s| s + \" and the \"\
    \ + odd_count(lst.drop(1).drop(1)).join(\"n the str\" + s.size + \"nput.\") }\n\
    \  end\nend", "  lst.map { |s| s.split(\"\").select { |c| c == \"1\" || c == \"\
    0\" }.count }\nend", "  result = \"\"\n  lst.each_index { |i|\n    result += [\
    \ \"the number of odd elements \", sum( lst.map { |j| j[j] % 2 }.select { |j|\
    \ j % 2 != 0 } ), \"n the str#ng #{i+1} of the #nput.\" ].join(\" \")\n  }\n \
    \ return result\nend", "  counts = Hash.new(0)\n  lst.each do |x|\n    counts[x]\
    \ += 1\n  end\n  counts[:odd] & counts[:even]\nend\n</code>\nAnd we can use it\
    \ thus:\n<code>\nprint odd_count.call([\"1234567\"]) # => [\"the number of odd\
    \ elements 4n the str4ng 4 of the 4nput.\"]\nprint odd_count.call([\"3\", \"11111111\"\
    ]) # => [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number\
    \ of odd elements 8n the str8ng 8 of the 8nput.\"]\n</code>\n<|/ a |>\n<| c |>\n\
    +1 for making it a separate method.  I wasn't aware of Hash#&, which is a really\
    \ handy method to know, but I see that you do so much more in my book than I have.\
    \  Thanks!\n<|/ c |>\n<| c |>\n: You're welcome. I really enjoy Ruby so much,\
    \ I even write my own interpreter (though I wrote mine in Smalltalk). :-)\n<|/\
    \ c |>\n<| c |>\n: Thanks for the book reference.  I had no idea that was a thing\
    \ until now.\n<|/ c |>\n<| c |>\n: Thanks. I learned some Ruby from CodeAcademy\
    \ and it's been a pleasure to read.\n<|/ c |>\n<| c |>\nYeah, I love Ruby.  I've\
    \ been using it for about 5 years, but I'm still struggling with some of the more\
    \ basic things.  I'm glad I decided to learn it.  Thanks again!\n<|/ c |>\n<|\
    \ a tags=ruby |>\n<code>", "  result = []\n  result[0] = lst[0].to_s.length\n\
    \  result[1] = lst[1].to_s.length\n  result[2] = lst[2].to_s.length\n  result[3]\
    \ = lst[3].to_s.length\n  result[4] = lst[4].to_s.length\n  result[5] = lst[5].to_s.length\n\
    \  result[6] = lst[6].to_s.length\n  result[7] = lst[7].to_s.length\n  result[8]\
    \ = lst[8].to_s.length\n  result[9] = lst[9].to_s.length\n  result[10] = lst[10].to_s.length\n\
    \  result[11] = lst[11].to_s.length\n  result[12] = lst[12].to_s.length\n  result[13]\
    \ = lst[13].to_s.length\n  result[14] = lst[14].to_s.length\n  result[15] = lst[15].to_s.length\n\
    \  result[16] = lst[16].to_s.length\n  result[17] = lst[17].to_s.length\n  result[18]\
    \ = lst[18].to_s.length\n  result[19] = lst[19].to_s.length\n  result[20] = lst[20].to_s.length\n\
    \  result[21] = lst[21].to_s.length\n  result[22] = lst[22].to_s.length\n  result[23]\
    \ = lst[23].to_s.length\n  result[24] = lst[24].to_s.length\n  result[25] = lst[25].to_s.length\n\
    \  result[26] = lst[26].to_s.length\n  result[27] = lst[27].to_s.length\n  result[28]\
    \ = lst[28].to_s.length\n  result[29] = lst[29].to_s.length\n  result[30] = lst[30].to_s.length\n\
    \  result[31] = lst[31].to_s.length\n  result[32] = lst[32].to_s.length\n  result[33]\
    \ = lst[33].to_s.length\n  result[34] = lst[34].to_s.length\n  result[35] = lst[35].to_s.length\n\
    \  result[36] = lst[36].to_s.length\n  result[37] = lst[37].to_s.length\n  result[38]\
    \ = lst[38].to_s.length\n  result[39] = lst[39].to_s.length\n  result[40] = lst[40].to_s.length\n\
    \  result[41] = lst[41].to_s.length\n  result[42] = lst[42].to_s.length\n  result[43]\
    \ = lst[43].to_s.length\n  result[44] = lst[44].to_s.length\n  result[45] = lst[45].to_s.length\n\
    \  result[46] = lst[46].to_s.length\n  result[47] = lst[47].to_s.length\n  result[48]\
    \ = ", "  lst.map { |str|\n    str.chars.map { |c|\n      1 if c == \"0\" else\
    \ 0 if c == \"1\" else 0 }\n  }.inject(:+)\nend", "  lst.map!{ |str| str.to_i\
    \ }\n  lst.map!{ |i| i.to_s.split(\"\").map { |d| d.to_i }.inject(0) { |sum, d|\
    \ sum + d if d % 2 != 0 } }.map!{ |i| i.to_s + \"s\" }\n  lst.compact!\n  lst.map!{\
    \ |i| i.to_s + \"s\" }\nend", "  lst.map { |i| i.to_s.split(//).count(1) / i.to_s.split(//).size\
    \ }\nend", "  result = []\n  lst.each do |string|\n    string.chars.each do |char|\n\
    \      if char.to_i.odd?\n        result << char\n      end\n    end\n  end\n\
    \  result\nend", "  return [ \"the number of odd elements #{lst[i].length} the\
    \ str#{lst[i].length} #{lst[i]} of the #{lst[i].length}nput.\" for i in lst ]\n\
    end", "  odd_count = 0\n  odd_list = []\n  lst.each do |i|\n    i.split(\"\").each\
    \ do |num|\n      if num.to_i % 2 == 1\n        odd_count += 1\n      end\n  \
    \  end\n    odd_list << \"the number of odd elements #{odd_count} of the #{i}\"\
    \n    odd_count = 0\n  end\n  odd_list\nend", "  lst.map! {|x| x.split(\"\").reject\
    \ {|y| y =~ /\\d/}.size }\n  lst.inject {|memo, str| memo << str.size << \"n\"\
    \ }\nend", "  lst.each_with_index.map do |element, index|\n    element = element.to_s.strip.to_i\n\
    \    odd_elements = (element / 10).to_i\n    odd_elements = 0 if odd_elements\
    \ == 0\n    \"the number of odd elements #{odd_elements} of the #{element}th input.\"\
    \n  end\nend", "  lst.map { |s| s.chars.count(&:odd).to_s }.join(\", \")\nend",
  "  lst.inject([]) do |odd, str|\n    str =~ /(\\d)/ ? odd << $1.to_i : odd << 0\n\
    \  end\nend", "  output = []\n  odd_digits = Array.new(lst.length)\n  odd_digits.each\
    \ do |i|\n    digits = i.to_s.chars.map(&:to_i)\n    odd_digits.map! { |j| j +\
    \ digits.length % 2 } unless digits.length % 2 == 0\n  end\n  odd_digits.each\
    \ do |i|\n    output << i.to_s.chars.map(&:to_i).reduce(0) { |sum, el| sum + el\
    \ % 2 }\n  end\n  return output\nend", "  odd_counter = 0\n  lst.each do |x|\n\
    \    odd_counter = odd_counter + 1 if x.is_a?(Integer) && x.odd?\n  end\n  odd_counter\n\
    end", "  result = []\n  lst.each do |str|\n    result.concat(lst.count(str).divmod(2))\n\
    \  end\n  result\nend", "  lst.map!{|i| i.to_i}\n  result = lst.select do |i|\n\
    \    i.odd?\n  end\n  result.map!{|i| i.to_s.length}\n  result\nend", "  if lst.is_a?(Array)\
    \ then\n    return lst.map { |i| odd_count(i) }\n  elsif lst.is_a?(String) then\n\
    \    digits = lst.gsub(/\\d/).length\n    if digits > 0 then\n      odd_counts\
    \ = lst.scan(/\\d/).map do |i|\n        digits = i.gsub(/\\d/).length\n      \
    \  if digits > 0 then \"the number of odd elements #{\"#{digits}n\"} the str#{\"\
    #{digits}ng\"}#{digits} of the #{digits}nput.\" else \"the number of odd elements\
    \ #{digits}n the str#{\"#{digits}ng\"}#{digits} of the #{digits}nput.\"\n    \
    \    else\n          \"the number of odd elements #{digits}n the str#{\"#{digits}ng\"\
    }#{digits} of the #{digits}nput.\"\n        end\n      end\n      odd_counts.compact.join(\"\
    \ \")\n    end\n  end\nend", "  lst.map {|s| s.split(//).length.to_i*(s.split(//)[-1].length.to_i-1)}\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI am not getting the expected output\
    \ from your code. Let me try some other codes.\n<|/ c |>\n<| c |>\ncan you paste\
    \ the actual output? It is not clear.\n<|/ c |>\n<| c |>\nMy output is `[\"the\
    \ number of odd elements 4n the str4ng 4 of the 4nput.\"]`\n<|/ c |>\n<| c |>\n\
    This is not correct. Your output is `[\"the number of odd elements 1n the str1ng\
    \ 1 of the 1nput.\", \"the number of odd elements 1n the str1ng 1 of the 1nput.\"\
    ]`\n<|/ c |>\n<| c |>\n: Yes. Sorry, I edited my code. Now it should work and\
    \ do what I wanted.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,arrays dscore=0 |>\n\
    <code>", "  return [] if lst.nil? || lst.size == 0\n  odd = lst.group_by { |s|\
    \ s.to_i }.map do |k, v|\n    odd = v.map { |s| s.size % 2 != 0 }.sum\n    [ \"\
    the number of odd elements\", k, \"n the str\", k.to_s, \"of the \", k.to_s, \"\
    input.\"]\n  end\n  odd += [ [ \"the number of odd elements\", lst.size.to_s,\
    \ \"n the str\", lst.size.to_s, \"of the \", lst.size.to_s, \"input.\"] ] if lst.size\
    \ > 1\n  odd.flatten\nend", "  lst.inject([]){|sum, str|\n    if str =~ /^\\d+$/\n\
    \      sum = sum + 1 if str =~ /\\d/\n    end\n    sum\n  }\nend\n</code>\n<|/\
    \ a |>\n<| a tags=ruby,regex |>\nA simple solution that is still fast and uses\
    \ no extra memory:\n<code>", "  lst.inject([]) { |acc, x| acc << x.to_i.odd? ?\
    \ acc << \"the number of odd elements \" << x.to_i.odd? << \" n the str\" << x.to_i.odd?\
    \ << \" \" << x << \".\" : acc << \"the number of odd elements \" << x.to_i.odd?\
    \ << \" n the str\" << x.to_i.odd? << \" \" << x << \".\" ; acc }\nend\n</code>\n\
    <|/ a |>\n<| c |>\nYou beat me by 10 seconds. You should accept his answer.\n\
    <|/ c |>\n<| c |>\n, I've been waiting 2 minutes and was glad to have it answered\
    \ this instantly.\n<|/ c |>\n<| a dscore=0 tags=ruby |>\n<code>", "  str.split(\"\
    \").inject([]) do |odd_counts, char|\n    odd_counts << char.scan(/\\d/).length\
    \ if char.match(/\\A\\d+\\Z/)\n    odd_counts\n  end\nend", "    odd = lst.reduce(:+)\n\
    \    odd_count = lst.map { |str| str.length.times.map { |i| (str[i].to_i % 2).to_s\
    \ } }\n    return [odd_count.reduce(:+).to_s, odd_count.map { |arr| arr.reduce(:+).to_s\
    \ }.join(', ')]\nend\n</code>\n<|/ a |>\n<| c |>\nThe second return statement\
    \ should be `return [odd_count.reduce(:+).to_s, odd_count.map { |arr| arr.reduce(:+).to_s\
    \ }.join(', ')]`. But then I get a wrong answer:\n`[\"the number of odd elements\
    \ 4n the str4ng 4 of the 4nput.\", \"the number of odd elements 4n the str4ng\
    \ 4 of the 4nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"\
    ]`\n<|/ c |>\n<| c |>\nSorry about that, I made an edit that fixes it. Does it\
    \ work for you?\n<|/ c |>\n<| c |>\nYes, thank you so much! I really appreciate\
    \ it. I had to add a `.to_i` on the end of the `reduce` call. I'm not sure why.\
    \ I'm guessing the `Array` doesn't know that `reduce` returns a `Fixnum`? EDIT:\
    \ Actually I just tested it, and `reduce` knows what to do with a `Fixnum`. That's\
    \ good to know, thanks!\n<|/ c |>\n<| c |>\nYes, that makes sense. Glad I could\
    \ help!\n<|/ c |>\n<| c |>\nOkay, one more quick question: in the 3rd example,\
    \ `[\"1\", \"11\", \"111\", \"1111\"]`, I'm getting `[\"the number of odd elements\
    \ 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 1n the str1ng\
    \ 1 of the 1nput.\", \"the number of odd elements 1n the str1ng 1 of the 1nput.\"\
    , \"the number of odd elements 1n the str1ng 1 of the 1nput.\"]` instead of just\
    \ `\"1\"`. How can I fix that? Thanks!\n<|/ c |>\n<| a tags=ruby,arrays |>\nHere\
    \ is a short solution:\n<code>", "  result = lst.map { |s| s.length }\n  result.zip(result).map\
    \ { |x, y| y if x % 2 != 0 }\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| a |>\n\
    Here's a one-liner:\n<code>\n(1..@list.length).map { |i| (i..@list.length).reduce(:+)\
    \ }\n</code>\n<|/ a dscore=2 tags=ruby,arrays |>\n<| a dscore=0 |>\nHere's one\
    \ way you could do it:\n<code>", "  lst.size.times.map {|i| i.to_s.length}.inject(:+)\n\
    end", "  lst.map!{|i| i.to_i}\n  odd_sum = []\n  lst.each_with_index do |num,i|\n\
    \    if num.to_s.include?('1')\n      odd_sum.push(num.to_s.split('1').length-1)\n\
    \    else\n      odd_sum.push(num.to_s.split('8').length-1)\n    end\n  end\n\
    \  return odd_sum\nend", "  # TODO: write your code here\nend", "  result = \"\
    \"\n  lst.each do |s|\n    result += s.to_s.chars.map {|c| c.to_i}.select {|n|\
    \ n % 2 == 1 }.count\n  end\n  result\nend", "  puts \"the number of odd elements\
    \ #{ndigits(lst).odd}n the str#{ndigits(lst).odd}n of the #{ndigits(lst).odd}nput.\"\
    \nend", "  return lst.map { |s| s.chars.reject(&:odd?).size }.compact\nend", " \
    \ odd_count = Array.new\n  for i in 0...lst.size\n    odd_count << [lst[i].scan(/\\\
    d/).size.odd? ? lst[i].scan(/\\d/).size.odd? : \"the number of odd elements \"\
    \ + lst[i].scan(/\\d/).size.odd? +\" of the str\" + lst[i].scan(/\\d/).size.odd?.to_s\
    \ + \" of the \" + lst[i].scan(/\\d/).size.odd? +\" \" + lst[i].to_s]\n  end\n\
    \  odd_count\nend", "  return lst.map {|x| x.chars.select{|y| y.odd?}.size}.join(\"\
    \\n\")\nend", "  count = [0] * 1000\n  \n  lst.each do |s|\n    i = 0\n    while\
    \ i < s.length\n      count[i] = count[i] + 1\n      i += 1\n    end\n  end",
  "  lst.map {|e| \n    e.to_s.chars.to_a.map {|x| x.count(1) / 2 }\n  }\nend", " \
    \ result = []\n  lst.each do |el|\n    result = [result.size, \"the number of\
    \ odd elements #{el.scan(/\\d/).size}n the str#{el.size}ng #{el.size}n of the\
    \ #{el.size}nput.\"]\n  end\n  result\nend\n</code>\n<|/ a dscore=1 |>\n<| a |>\n\
    Here's my solution:\n<code>", "  odd = lst.inject(0){ |sum, str| sum + 1 if str\
    \ =~ /^\\d+$/ && (str.length % 2 == 1) }\n  [ \"the number of odd elements #{odd}\
    \ #{lst.to_a.join.chars.count('0')} #{lst.to_a.join.chars.count('1')}.\", \n \
    \   \"the number of odd elements #{odd}n the str#{odd} #{lst.to_a.join.chars.count('0')}n\
    \ the 4nput.\", \n    \"the number of odd elements #{odd}n the str#{odd}n the\
    \ 1nput.\", \n    \"the number of odd elements #{odd}n the str#{odd}n the 8nput.\"\
    ]\nend", "  if lst.size == 0\n    []\n  else\n    odd_count.(st[1..-1]) + [nil]\n\
    \  end\nend", "  lst.map {|s| s.scan(/\\d/).size}\nend", "  results = []\n  lst.each\
    \ do |s|\n    results << \"the number of odd elements #{s.chars.map {|c| c if\
    \ c.odd?}.count} #{s}\"\n  end\n  return results\nend", "    odd_digits = 0\n\
    \    odd_count_lst = []\n    odd_count_lst.push(\"The number of odd elements are\
    \ \" + odd_digits.to_s + \" elements in the first string.\")\n    odd_count_lst.push(\"\
    The number of odd elements are \" + odd_digits.to_s + \" elements in the second\
    \ string.\")\n    odd_count_lst.push(\"The number of odd elements are \" + odd_digits.to_s\
    \ + \" elements in the third string.\")\n    odd_count_lst.push(\"The number of\
    \ odd elements are \" + odd_digits.to_s + \" elements in the fourth string.\"\
    )\n    odd_count_lst.push(\"The number of odd elements are \" + odd_digits.to_s\
    \ + \" elements in the fifth string.\")\n    odd_count_lst.push(\"The number of\
    \ odd elements are \" + odd_digits.to_s + \" elements in the sixth string.\")\n\
    \    odd_count_lst.push(\"The number of odd elements are \" + odd_digits.to_s\
    \ + \" elements in the seventh string.\")\n    odd_count_lst.push(\"The number\
    \ of odd elements are \" + odd_digits.to_s + \" elements in the eighth string.\"\
    )\n    odd_count_lst.push(\"The number of odd elements are \" + odd_digits.to_s\
    \ + \" elements in the ninth string.\")\n    odd_count_lst.push(\"The number of\
    \ odd elements are \" + odd_digits.to_s + \" elements in the tenth string.\")\n\
    \    odd_count_lst.push(\"The number of odd elements are \" + odd_digits.to_s\
    \ + \" elements in the eleventh string.\")\n    odd_count_lst.push(\"The number\
    \ of odd elements are \" + odd_digits.to_s + \" elements in the twelfth string.\"\
    )\n    odd_count_lst.push(\"The number of odd elements are \" + odd_digits.to_s\
    \ + \" elements in the thirteenth string.\")\n    odd_count_lst.push(\"The number\
    \ of odd elements are \" + odd_digits.to_s + \" elements in the fourteenth string.\"\
    )\n    odd_count_lst.push(\"The number of odd elements are \" + odd_digits.to_s\
    \ + \" elements in the fifteenth string.\")\n    odd_count_lst.push(\"The number\
    \ of odd elements are \" + odd_digits.to_s + \" elements in the sixteenth string.\"\
    )\n    odd_count_lst.push(\"The number of odd elements are \" + odd_digits.to_s\
    \ + \" elements in the seventeenth string.\")\n    odd_count_lst.push(\"The number\
    \ of odd elements are \" + odd_digits.to_s + \" elements in the eighteenth string.\"\
    )\n    odd_count_lst.push(\"The number of odd elements are \" + odd_digits.to_s\
    \ + \" element", "  odd_count = 0\n  lst.each do |str|\n    odd_count += str.scan(/\\\
    d/).length\n  end\n  [ odd_count, \"the number of odd elements of the str#{lst.size}\
    \ of the str#{lst.size}.\" ]\nend", "  lst.length.times.with_object(\"the number\
    \ of odd elements #{lst.map(&:to_i).sum} of the str#{lst.map(&:length).sum} #{lst.map(&:odd?).map{|s|\
    \ s ? \"is\" : \"is not\"}.join(' ')} of the #{lst.map(&:length).sum} #{lst.map(&:odd?).map{|s|\
    \ s ? \"is\" : \"is not\"}.join(' ')}.\")\nend", "  lst.map { |x|\n    x.chars.map\
    \ { |y|\n      if y.to_s.split(//).length != 1 \n        (x.to_s.split(//).length\
    \ * y.to_s.split(//).length).to_s\n      else\n        (y.to_s.split(//).length).to_s\n\
    \      end\n    }\n  }.flatten.count{|x| x.odd? }\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nThanks everyone for their comments. I figured it out; will post\
    \ my answer shortly.\n<|/ c |>\n<| c |>\nThat's not a Ruby method, you meant `odd?`,\
    \ right?\n<|/ c |>\n<| a tags=ruby |>\nI figured it out. Thanks to all those who\
    \ answered. Here is the code that I came up with, hope it helps someone else.\
    \ \n<code>", "  odd_count = 0\n  arr.each do |num|\n    odd_count += num.count('o')\
    \ - num.count('0')\n  end\n  return([odd_count.to_s].join(', '))\nend\n</code>\n\
    <|/ q dscore=0 tags=ruby,arrays |>\n<| c |>\nWhat is `arr` in your last code block?\
    \ What is `odd_count`? What do you expect `odd_count.call([\"3\", \"11111111\"\
    ])` to return?\n<|/ c |>\n<| c |>\n`odd_count` is defined in the last code block.\
    \ It is a method that should count the number of \"o\"s in a string and return\
    \ the amount of \"o\"s minus the amount of \"0\"s.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  even = lst.map {|s| s.to_s.chars.map(&:odd?).count(true)}\n\
    \  odd = lst.map {|s| s.to_s.chars.map(&:odd?).count(false)}\n  lst.map! {|s|\
    \ s.to_s.chars.map{|c| c == ?d ? odd : even}.sum}\nend", "  arr.each do |n|\n\
    \    odd_number = n.count('1') % 2\n    if odd_number == 0\n      p \"the number\
    \ of odd elements #{n} of the str#{n} of the input.\"\n    end\n  end\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis solution is incorrect. Try it with `[\"11\",\
    \ \"10\", \"100\"]` It outputs 2 times \"the number of odd elements in str11 of\
    \ the input.\" which is wrong.\n<|/ c |>\n<| c |>\n- It was a mistake in my code.\
    \ I've edited the answer, now it works as expected\n<|/ c |>\n<| a tags=ruby |>\n\
    As already said, you need to loop over the array only once.\nBut since you do\
    \ not use results from the previous iteration you can do the following:\n<code>",
  "  lst.map { |x| [x, \"the number of odd elements \" + x.to_s.chars.map{|c| c=='1'?\
    \ c.to_s.to_i : c.to_s.to_i}.inject(:+).to_s + \" of the \" + x.to_s.to_s + \"\
    \ of the \" + x.to_s.chars.map{|c| c=='1'? c.to_s.to_i : c.to_s.to_i}.inject(:+).to_s\
    \ + \" of the \" + x.to_s.to_s] }.inject(:+).to_s + \"\\n\"\nend", "  counts =\
    \ Array.new(lst.size, 0)\n  lst.each_with_index do |x, i|\n    counts[i] = x.count('0')\n\
    \  end\n  counts\nend", "  lst.each do |l|\n    l.each_char do |c|\n      l[l.index(c)]\
    \ = l.count{|x| x =~ /^.\\d+$/ }\n    end\n  end\n  return lst\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 tags=ruby |>\n<code>", "  if lst.empty?\n   \
    \ []\n  else\n    odd_count_aux(lst.to_a)\n  end\nend", "  result=[]\n  lst.each{|element|\n\
    \    if (element =~ /^\\d+$/)\n      result.push(element.to_s.length - element.to_s.scan(/\\\
    d/).length)\n    end\n  }\n  result\nend", "  lst.map { |s| s.length.times.reduce(0)\
    \ {|sum, i| sum + (s.include?(i) ? 1 : 0); }}\nend\n</code>\n<|/ a |>\n<| a dscore=0\
    \ |>\n<code>", "  ret = []\n  lst.each do |x|\n    x.split(\"\").each_with_index\
    \ do |x, i|\n      if x.to_i != 0\n        if i%2 == 0\n          ret << x.to_i\n\
    \        end\n      end\n    end\n  end\n  return ret\nend\n</code>\n<|/ a tags=ruby,string,arrays\
    \ |>\n<| c |>\nThis is great. Thanks for the help.\n<|/ c |>\n<| a dscore=0 tags=ruby,string,arrays\
    \ |>\nJust to keep it a little more Rubyish you could also do this:\n<code>",
  "  even = (0..(lst.length-1)).to_a\n  odd = (even.size - even.map {|i| lst.index(i).to_s}.uniq.size).to_a\n\
    \  return even.map {|i| odd.index(i).to_s}.join(\"n\")\nend", "  lst.map { |s|\
    \ s.length.to_s.length }.inject(:+)\nend", "  lst.map!(&:to_i) unless lst.instance_of?(Array)\n\
    \  results = []\n  lst.each do |str|\n    results.push(\"the number of odd elements\
    \ #{str.gsub(/\\d+/){|e| e.to_i}.odd?} #{str.gsub(/\\d+/){|e| e.to_i}.count('1')}\
    \ #{str.length} of the #{str.length} string.\") unless str.empty?\n  end\n  return\
    \ results\nend", "  lst.each_index do |i|\n    digits = lst[i].to_s.chars\n  \
    \  digits = digits.reject(&:odd?)\n    digits = digits.uniq.size\n    lst[i] =\
    \ digits.length\n  end\n  return lst\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\n\
    <code>", "  num = 0\n  for i in lst\n    num += ((1..i.length).to_a - i.scan(/\\\
    d/).length).inject(0){|sum, n| sum + n}\n    puts \"the number of odd elements\
    \ for #{i} is #{num}\"\n  end\nend", "  str1 = lst[0]\n  str2 = lst[1]\n  return\
    \ [\n    \"the number of odd elements #{str1.size}n the str#{str1.size}#{str2.size}\
    \ of the #{str1.size}#{str2.size}input.\",\n    \"the number of odd elements #{str2.size}n\
    \ the str#{str1.size}#{str2.size} of the #{str1.size}#{str2.size}input.\"\n  ]\n\
    end", "  lst.map!{|s| s.chars.map{|c| c != (c == '1') ? 1 : 0}.reduce(:+)}\n \
    \ lst.inject([]) {|acc, x| acc << x if acc.last > 0 && acc.last % 2 == 1 && x.to_i\
    \ > 0}.compact\nend\n</code>\n<|/ a |>\n<| c |>\nThis is beautiful.\n<|/ c |>\n\
    <| c |>\n: Thanks. I really like the way you solved the problem.\n<|/ c |>\n<|\
    \ c |>\nThanks very much. It was very informative. Yes, this is for a class assignment,\
    \ but I am just starting to learn Ruby so I appreciate all the help. :)\n<|/ c\
    \ |>\n<| c |>\n: It was a pleasure.\n<|/ c |>\n<| a dscore=0 tags=ruby,arrays\
    \ |>\nNot as pretty as your original post, but here's another way to do it.\n\
    <code>", "  odd_count = 0\n  lst.each_with_index { |element, index|\n    if element.to_s.to_i\
    \ % 2 != 0\n      odd_count += 1\n    end\n  }\n  return \"the number of odd elements\
    \ (#{odd_count}) in the str#{\"%02d\" % index} #{element.to_s.to_i} of the #{element.to_s.to_i}.\"\
    \nend", "  return lst.map do |elem|\n    elems.map {|e| e.odd? ? elem.count(e)\
    \ : 0}\n  end\nend", "  lst.map!{|str| str.split(//)}\n  lst.map!{|str| str.chars.map{|c|\
    \ c.to_i}.count}\n  lst.map!{|str| str.length.times.map{|n| str.chars.map{|c|\
    \ c.to_i}.reduce(:+) == n ? n : 0}}.compact!\nend", "  lst.map!{|s| s.chars.map(&:to_i).reduce(:+)&.odd?\
    \ ? 1 : 0}\nend", "  odd = Array.new\n  lst.each { |s| odd << s.length.to_i**2\
    \ if s.to_s.chars.map(&:odd?).sum == 0 }\n  odd.map { |s| s.to_s.gsub(/\\d+/)\
    \ { |m| \"the number of odd elements #{m.to_i**2} the str#{ m.to_i**2 } of the\
    \ #{m.to_i**2}nput.\" } }\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nWhile this\
    \ may be the correct answer, please consider providing a little explanation of\
    \ how this solves the OP's issue.\n<|/ c |>\n<| c |>\nI thought it was self explanatory,\
    \ but I'll add some comments I hope to be more clear with my answer.\n<|/ c |>\n\
    <| c |>\nIt certainly did help me. I'm just having trouble implementing the `odd_count`\
    \ method into my program. I tried `def odd_count(strings)\n  odd = Array.new\n\
    \  strings.each { |s| odd << s.length.to_i**2 if s.to_s.chars.map(&:odd?).sum\
    \ == 0 }\n  odd.map { |s| s.to_s.gsub(/\\d+/) { |m| \"the number of odd elements\
    \ #{m.to_i**2} the str#{ m.to_i**2 } of the #{m.to_i**2}nput.\" } }\nend` but\
    \ I'm not really sure where to go from there\n<|/ c |>\n<| c |>\nI edited my original\
    \ answer with code I hope is easier to understand.\n<|/ c |>\n<| c |>\nI guess\
    \ you could do something like `gsub(/\\d+/) { |m| \"the number of odd elements\
    \ #{m.to_i**2} the str#{ m.to_i**2 } of the #{m.to_i**2}nput.\" }` instead...\n\
    <|/ c |>\n<| a dscore=3 |>\n<code>\n  def odd_count(strings)\n    strings.map\
    \ { |string| string.length.to_i ** 2 }\n             .select { |number| number.odd?\
    \ }\n             .map { |number| 'number of odd elements is ' + number.to_s }\n\
    \  end\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis is a good answer, but please\
    \ consider adding some explanation as to how it works so OP and future readers\
    \ can understand why it works.\n<|/ c |>\n<| a dscore=2 ", "  lst.each_with_index.map\
    \ { |str, i| str.count( /\\d/).zero? ? 0 : str.count( /\\d/) }\nend", "  result\
    \ = []\n  n = lst.count\n  n = 0 if n < 0 else n\n  lst.each do |i|\n    i.each_char\
    \ do |c|\n      n += 1 if c.to_i.odd?\n    end\n    result.push((\"the number\
    \ of odd elements #n the str#n of the #nput.\") % (n)) if n > 0\n    result.push((\"\
    the number of odd elements #n the str#n of the #nput.\") % (n)) if n == 0\n  \
    \  result.push((\"the number of odd elements #n the str#n of the #nput.\") % (n))\
    \ if n < 0\n  end\n  return result\nend\n</code>\n<|/ a tags=ruby,string,string-formatting,arrays,format\
    \ dscore=1 |>\n<| a dscore=1 |>\nHere is a solution that is simple and easy to\
    \ understand.\n<code>", "  result = []\n  arr.each { |x|\n    result << [\"the\
    \ number of odd elements #{x.chars.map { |y|\n      y.to_i }.inject(:+) }n the\
    \ str#{x.size}b of #{x.size}bput.\"]\n  }\n  result\nend", "  # initialize an\
    \ array to hold our results\n  result = Array.new", "  count = []\n  (0..(lst.length-1)).each\
    \ do |i|\n    count[i] = (lst[i].to_s.split('').size).odd? ? 1 : 0\n  end\n  count.map(&:to_s)\n\
    end", "  lst.map {|str| str.split(//).map{|x| x.to_i}.reduce(:+) }\nend\n</code>\n\
    <|/ a tags=ruby,arrays,string |>\n<| c |>\nYou don't need to iterate over the\
    \ string and split it again and again, you can just do `str.split(//)` :)\n<|/\
    \ c |>\n<| c |>\nYeah, you're right. I didn't think about it (because I wasn't\
    \ sure if the OP would want to make that string a multidimensional array or not).\
    \ Thank you! :)\n<|/ c |>\n<| c |>\nAh I see what you're doing there. You're counting\
    \ the number of characters. That's not the same thing as the number of characters\
    \ in the string. I'm going to edit my answer to reflect this.\n<|/ c |>\n<| c\
    \ |>\nI've posted a much simpler version of this answer, which does exactly what\
    \ you're looking for.\n<|/ c |>\n<| c |>\n: Thanks for your help! :)\n<|/ c |>\n\
    <| a tags=ruby,arrays,string |>\nI'd use inject to increment the counter for each\
    \ sub-string of each string in the array:\n<code>", "  # your code here\nend",
  "  return lst.map { |e| [e.scan(/\\d+/).length.to_s.center(5, \"0\")] }\nend", " \
    \ lst.each_with_index.map {|s, i| [s.split(//).length * \"n the str#ng #{s.length}\"\
    \ + (s.length - 1) * (\"#\" if s.length == 1), i]}\nend", "  # Your code here\n\
    end", "  return lst.inject([]) do |odd_count, string|\n    odd_count + string.to_s.split(//).map(&:to_i).count\
    \ { |x| x % 2 != 0 }\n  end\nend", "  return lst.inject([]){|output, element|\
    \ output << [element.to_i.to_s.length.odd? ? 1 : 0] + element.to_i}.flatten\n\
    end", "  lst.map { |i| i.to_s.length }\nend\n</code>\nYou also need to define\
    \ odd_count using map rather than each:\n<code>", "  lst.map!{ |s| s.split(\"\"\
    ).map { |c| 1 if c.odd? }.sum }\nend\n</code>\n<|/ a tags=string,ruby,arrays dscore=2\
    \ |>\n<| c |>\nYou shouldn't use map for this - you should use reduce\n<|/ c |>\n\
    <| a |>\n<code>\nodd_count = lambda do |string|\n  string.split('').inject(Hash.new(0)){|hash,char|\
    \ hash[char] += 1; hash}\nend", "  lst.each do |str|\n    str.chars.each.with_index\
    \ do |char, i|\n      if !str[i].nil? and char.to_i is char.to_i\n        str[i]\
    \ = str[i].to_s.length\n      end\n    end\n  end\n  odd_count = lst.map { |str|\
    \ str[1..-1].select { |s| s.to_s.chars.count.with_index{|i,j| i.odd? }} }.flatten.uniq\n\
    \  odd_count.map {|num| num.to_s.length}.each {|num| puts \"the number of odd\
    \ elements in the #{num}nd string of the input.\"}\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nHi Jason,\nthanks for the help. I ran your script and it worked\
    \ perfectly. However I wasn't sure how to adapt it to my question. I would appreciate\
    \ it if you can give me some help on how to implement your answer to my question.\
    \ Thanks again. :) I really appreciate your help.\n<|/ c |>\n<| c |>\n: I added\
    \ some description.\n<|/ c |>\n<| c |>\nHi Jason, thanks a lot for your help.\
    \ I really appreciate it. :)\n<|/ c |>\n<| a tags=ruby,arrays,string |>\nMy first\
    \ thought would be to create a new array using map and then count the odd characters,\
    \ like so\n<code>", "    lst = lst.map(&:to_i)\n    odd_str = lst.map { |x| x.odd?\
    \ ? \"1\" : \"0\" }\n    odd_str.map { |x| x.to_s.length }\nend\n</code>\n<|/\
    \ a tags=ruby,arrays,string |>\n<| c |>\nThank you so much for this. I was able\
    \ to adapt it to my situation with a few tweaks.\n<|/ c |>\n<| a dscore=1 |>\n\
    <code>", "    odd_digits = []\n    odd_digits_count = 0\n    evens_digits = []\n\
    \    evens_digits_count = 0\n    \n    if lst.empty?\n        odd_digits_count\
    \ = evens_digits_count = 0\n        odd_digits.join(\" \")\n    elsif lst.length\
    \ == 1\n        odd_digits_count += 1\n        evens_digits_count += 1\n     \
    \   odd_digits.join(\" \")\n    else\n        lst = lst.chars\n        odd_digits_count\
    \ = odd_digits_count + odd_count(lst.take(odd_digits_count + 1)) - odd_count(lst.take(odd_digits_count))\n\
    \        evens_digits_count = evens_digits_count + evens_count(lst.take(evens_digits_count\
    \ + 1)) - evens_count(lst.take(evens_digits_count))\n        odd_digits_count.times\
    \ do |i|\n            odd_digits << i\n        end\n        evens_digits_count.times\
    \ do |i|\n            evens_digits << i\n        end\n    end\n    \n    odd_digits.append(evens_digits[evens_digits_count])\n\
    \    odd_digits.join(\" \")\nend", "  lst.size.times do |i|\n    # this line makes\
    \ the code easier to understand. the [...] syntax is a list literal\n    # it\
    \ creates a new array with the result of evaluating the expression between the\n\
    \    # brackets\n    odds = lst[i].scan(/\\d/).count\n    # this is a list comprehension\
    \ that creates a list with the number of times each string in the array is found\
    \ in one of the strings in the array\n    # this is what gets returned as a result\
    \ of the odd_count function\n    [odds]\n  end\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=ruby |>\nHere's a short way to do it with a regular expression:\n<code>",
  "  lst.each_with_index.inject([]) do |odd_count, (n,i)|\n    odd_count << \" the\
    \ number of odd elements in #{n} the #{lst.count('0'+n.to_s(2))} of the #{lst.count('0'+n.to_s(16))}.\"\
    \n    odd_count\n  end\nend", "    even = lst.select { |s| s.to_s.include?('0')\
    \ }\n    odd = even.select { |s| s.to_s.include?('1') }\n    odd_count = even.size.times.map\
    \ { |n| odd.size if n < even }\n    odd_count.flatten.compact\nend\n</code>\n\
    <|/ a tags=ruby,string,arrays |>\n<| a dscore=0 tags=ruby,string,arrays |>\nA\
    \ simple one-line solution based on regular expression:\n<code>", "  result =\
    \ []\n  odd_digits = 0.\n  lst.each do |n|\n    if n.to_s.length <= 1\n      result\
    \ << n\n      next\n    end\n    n.each_char.with_index do |c, i|\n      if c\
    \ % 2 != 0\n        odd_digits += 1\n      end\n    end\n    result << odd_digits\n\
    \    odd_digits = 0\n  end\n  result\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
