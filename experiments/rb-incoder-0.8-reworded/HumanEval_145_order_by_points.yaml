name: HumanEval_145_order_by_points
language: rb
prompt: "# Write a function which sorts the given array of integers\n# in ascending\
  \ order according to the sum of their digits.\n# Note: if there are several items\
  \ with similar sum of their digits,\n# order them based on their index in original\
  \ array.\n# For example:\n# >>> order_by_points.call([1, 11, -1, -11, -12])\n# [-1,\
  \ -11, 1, -12, 11]\n# >>> order_by_points.call([])\n# []\ndef order_by_points(nums)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_order_by_points\n\
  \    candidate = method(:order_by_points)\n    assert_equal([-1, -11, 1, -12, 11],\
  \ candidate.call([1, 11, -1, -11, -12]))\n    assert_equal([0, 2, 3, 6, 53, 423,\
  \ 423, 423, 1234, 145, 37, 46, 56, 463, 3457], candidate.call([1234, 423, 463, 145,\
  \ 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]))\n    assert_equal([], candidate.call([]))\n\
  \    assert_equal([-3, -32, -98, -11, 1, 2, 43, 54], candidate.call([1, -11, -32,\
  \ 43, 54, -98, 2, -3]))\n    assert_equal([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9], candidate.call([1,\
  \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]))\n    assert_equal([-76, -21, 0, 4, 23, 6, 6],\
  \ candidate.call([0, 6, 6, -76, -21, 23, 4]))\n  end\nend\n"
completions: ["  # Your code here\n  nums.sort! {|a, b| (a.to_s.split('').map(&:to_i).reduce(:+)\
    \ <=> b.to_s.split('').map(&:to_i).reduce(:+))}\nend\n</code>\nTest Cases\n<code>",
  "  nums = nums.dup\n  nums.map! {|n| [n, n.to_i].sort_by! { |n| n.to_i }}\n  nums\n\
    end\n</cell>\n<cell>\norder_by_points.call([1, 11, -1, -11, -12])\n</cell>\n<cell>\n\
    order_by_points.call([])\n</cell>\n<text>\nProblem 12", "    sorted_nums = []\n\
    \    sum_of_nums = 0", "  nums.each do |num|\n    arr = num.to_s.split('')\n \
    \   idx = arr.index { |e| e == num.to_s.to_i }\n    arr[idx] = num.to_i\n    arr\n\
    \  end\n  .sort\n  .map{ |e| e.to_i }\nend", "  n = nums.size\n  if n <= 1\n \
    \   return nums\n  nums.sort!\n  left, right = 0, n - 1\n  while left < right\n\
    \    sum = nums[left] + nums[right]\n    if sum < 0\n      sum *= -1\n      nums[left],\
    \ nums[right] = nums[right], nums[left]\n      left += 1\n      right -= 1\n \
    \   elsif sum > 0\n      left += 1\n    else\n      right -= 1\n    end\n  end\n\
    \  nums\nend", "  nums.sort!\n  (0...nums.size).map { |i| nums[i] }\nend", " \
    \ nums.sort do |a,b|\n  \tsum1 = sum_of_digits(a)\n  \tsum2 = sum_of_digits(b)\n\
    \  \tif sum1 == sum2\n  \t\ta.index(nums)\n  \telse \n  \t\tb.index(nums)\n  \t\
    end\n  end\nend", "  nums ||= []\n  nums = nums.sort{|a, b| a.to_f <=> b.to_f}\n\
    \  return nums if nums.count > 0\n  nums\nend", "  return nums.sort(&:to_s)\n\
    end", '  nums.sort!', "  # Your code here\n  nums.inject({}) { |hash, (key, val)|\
    \ hash[val] = key.to_i; hash }\n  nums.sort! { |a, b| a.to_i + b.to_i }\nend\n\
    </code>\n<|/ a |>\n<| a |>\nI believe the following is your desired output.  It\
    \ is an extension function of the Enumerable module.  \n<code>", "  # Your code\
    \ here!\nend", "  nums = nums.sort { |a, b| b - a }\n  nums\nend", "  nums = nums.sort\n\
    \  nums.sort do |a, b|\n    sum_a = nums.map { |i| i } + [0]\n    sum_b = nums.map\
    \ { |i| i }\n    sum_a <=> sum_b\n  end\nend", "  nums = nums.sort.to_a if nums.is_a?\
    \ Array else nums\n  if nums.empty?\n    return []\n  end\n  nums.inject do |total,\
    \ num|\n    digits = num.to_s.split(//)\n    next total if digits.count == 1\n\
    \    next total if total == 0 \n    next total if total > 0 && total < 0\n   \
    \ total += digits.reduce(0) { |total, n| total * 10 + n.to_i }\n    next total\
    \ if total == 0 || total > 0 && total < 0\n    next total if total < 0 && total\
    \ > 0\n    total\n  end\nend\n</code>\n<|/ a |>\n<| a dscore=0 tags=ruby,arrays,sorting\
    \ |>\n<code>", '  nums.sort!', "    # Write your code here\n    return nums.sort_by\
    \ { |x| x.to_s.chars.map(&:to_i).reduce(:+) }\nend\n</code>\n<|/ a tags=ruby,arrays,sorting\
    \ |>\n<| a tags=ruby,arrays,sorting |>\n<code>", "    sorted = []\n    sorted\
    \ = nums.sort.reverse\n    sorted = sorted.map{|x| x.to_i}\n    sorted = sorted.map{|x|\
    \ [x, x]}\n    sorted = sorted.group_by{|x| x.last}\n    sorted = sorted.map{|k,\
    \ v| [k, v.reverse.first]}\n    sorted = sorted.map{|k, v| v.first}\n    sorted.flatten\n\
    end", "  nums = nums.dup\n  return [] if nums.empty?\n  digits.max_by do |x|\n\
    \    sum = 0\n    nums.each do |y|\n      sum += y * y\n    end\n    sum\n  end\n\
    end", "  nums.sort.with_index do |sum, idx|\n    if sum == 0\n      idx\n    else\n\
    \      sum.to_s.rjust(digits_of(sum).length)\n    end\n  end\nend\n</code>\nTo\
    \ solve this question, we will sort numbers in increasing order, using sums of\
    \ their digits. Therefore, we will need to find the sum of digits in each number.\
    \ To do this, we can use the function digits_of, which returns the number of digits\
    \ (including 0) as a string: \n<code>", "    sorted_nums = nums.sort{|a, b|\n\
    \        sort_key = a.to_s + b.to_s\n        sort_key <=> b.to_s\n    }\n    \n\
    \    return sorted_nums\nend\n</code>\n<|/ a tags=ruby dscore=1 |>\n<| c |>\n\
    `sort_by(&:to_s)` might improve readability here.\n<|/ c |>\n<| a dscore=1 |>\n\
    I prefer using sort_by since it gives me more control on how elements are compared.\n\
    <code>", "  return [] if nums.empty? || nums.all? { |x| x.zero? } # Don't allow\
    \ the sum of digits to equal 0.\n  max_num = nums.max.to_i\n  nums_sorted = nums.sort_by\
    \ do |x|\n    digits = x.to_s.chars.map { |d| d.to_i }\n    (digits[-1] + digits).to_i\n\
    \  end\n  nums_sorted.reverse + [max_num] if max_num < 0\nend\n</code>\n<|/ a\
    \ dscore=3 |>\n<| c |>\nNicely done. Thank you! BTW, what is the `nums_sorted`\
    \ line? I see it being used, but I don't see how it's being used in the rest of\
    \ the method.\n<|/ c |>\n<| c |>\nAhhh, I see... It's for adding the numbers up\
    \ to that point together. Thank you!\n<|/ c |>\n<| c |>\nI suppose this is O(n^2)\
    \ though. The code could be optimised further, but that would be a more complicated\
    \ solution that I didn't want to think about. :) The idea was to find the sum\
    \ of digits of all numbers in sorted order, and find the maximum of the numbers,\
    \ to put them at the end in the correct order. In the example above, `nums_sorted`\
    \ would equal `[11, -12, 1, -1, -1]`. `digits` would equal `[11, -12, 1]`.\n<|/\
    \ c |>\n<| c |>\nYeah, that's why I added the caveat that `nums_sorted` shouldn't\
    \ be modified. `nums_sorted` should just be returned. I'll add an explanation\
    \ of the algorithm.\n<|/ c |>\n<| c |>\nAhh, I see. The `nums_sorted` line was\
    \ used to add the numbers up to that point together. Thank you so much!\n<|/ c\
    \ |>\n<| a tags=sorting,arrays,ruby |>\nHere's a one liner\n<code>\nnums = [-1,1,-10,11]\n\
    nums.sort_by { |num| [-num.to_s.chars.map(&:to_i).sum, num] }", "    sorted =\
    \ nums.dup\n    sorted.sort!\n    sorted.each_with_index do |num, i|\n       \
    \ nums[i] = num\n    end\n    return nums\nend\n</code>\n<|/ a dscore=2 |>\n<|\
    \ c |>\nWow, this is really cool! But how does `sort` function actually work?\
    \ Does it compare numbers in some way?\n<|/ c |>\n<| c |>\nYes, `sort` uses `<=>`\
    \ operator which compares objects according to their `<=>` value. And `<=>` is\
    \ very fast and comparing numbers in base 10 arithmetics is very fast. There are\
    \ a lot of examples of how `<=>` works, like here https://www.tutorialspoint.com/ruby/ruby_operators.htm\n\
    <|/ c |>\n<| c |>\nThank you very much! Could you tell me more about why you used\
    \ `dup`? Why did you use it? And why did you use the `each_with_index` method?\n\
    <|/ c |>\n<| c |>\nUsing `dup` allows you to sort the same array multiple times.\
    \ The sorting is done in place. `each_with_index` just makes sure that the original\
    \ array is not modified, even after the sorting is done. `each_with_index` returns\
    \ `nil` if the array is empty.\n<|/ c |>\n<| c |>\nAs a general rule of thumb,\
    \ you should use `dup` if you mutate an object in place and `clone` if you need\
    \ to preserve the original object. You should also consider using `sort!` rather\
    \ than `sort`. `sort!` doesn't modify the array while `sort` does.\n<|/ c |>\n\
    <| a tags=ruby,sorting,algorithm dscore=1 |>\nI recently was looking for the same\
    \ answer and this is my solution after experimenting several times.\n<code>\n\
    array = [1, -12, -3, 1, -13, -15, 2, -9, -12]", '  n = nums.length', "    sorted_array\
    \ = []\n    nums.each do |num|\n        sorted_array.push(num) if num < 0\n  \
    \      sorted_array.push(num) if num > 0\n        sorted_array.push(num) if num.to_s.split(//).sort.sum\
    \ > 0\n        sorted_array.push(num) if num.to_s.split(//).sort.sum < 0\n   \
    \ end\n    sorted_array\nend", "  arr = nums.to_a\n  arr.sort!{|a,b| b.to_s.length\
    \ <=> a.to_s.length } #sort descending by length, then ascending\n  nums.clear\n\
    \  nums << arr\nend", "  if nums.is_a? Array\n    nums.sort!\n    return nums\n\
    \  else\n    return []\n  end\nend\n</cell>\n<text>\nTask 8. Write a function\
    \ which sorts the given array of integers\nin descending order according to the\
    \ sum of their digits.\nNote: if there are several items with similar sum of their\
    \ digits,\norder them based on their index in original array.\nFor example:\n\
    >>> order_by_points.call([1, 11, -1, -11, -12])\n[12, -11, 11, -1, -1]\n>>> order_by_points.call([])\n\
    []\n</text>\n<cell>", "  nums = nums.sort_by { |num| [num.zero? ? 0 : num.abs]\
    \ }\nend\n</code>\n<|/ a |>\n<| a dscore=0 tags=ruby |>\n<code>\narr = [9, 5,\
    \ -7, 6, 3, -4, -5]\narr.sort!\narr.reverse\np arr", "    nums = nums.sort.map\
    \ {|a| a.to_i }\n    sums = nums.group_by{|n| n.to_i}.map {|k, v| [k, v.map(&:length).max]\
    \ }.sort_by {|x, y| x[1] <=> y[1] }\n    return sums.map {|k, v| [v, k] }\nend",
  "  nums.sort do |a, b|\n    sum_a = 0\n    sum_b = 0\n    for i in 0...a.length\n\
    \      sum_a += a[i].to_i\n    end\n    for i in 0...b.length\n      sum_b +=\
    \ b[i].to_i\n    end\n    sum_a - sum_b\n  end\nend\n</code>\n<|/ a |>\n<| c |>\n\
    If nums is empty then order_by_points.call([]) should return []. How would you\
    \ do this?\n<|/ c |>\n<| c |>\nThe OP didn't specify what should happen if nums\
    \ is empty.\n<|/ c |>\n<| a tags=ruby,sorting,ruby-on-rails |>\nHere is another\
    \ way with Enumerable#sort_by\n<code>\na = [4, 2, 5, 1, 4]\na.sort_by { |x| x.digits.sum\
    \ }", "    # O(n log n) time and O(1) space\n    nums = nums.sort\n    i = 0\n\
    \    while i < nums.length\n        digit = nums[i].abs\n        i += 1\n    \
    \    while i < nums.length and digits_sum(nums[i]) < digits_sum(nums[i - 1])\n\
    \            i += 1\n        if digits_sum(nums[i]) == digit\n            return\
    \ nums.insert(i, nums[i])\n        nums.insert(i, nums[i-1])\n    return nums\n\
    end\n</cell>\n<code language=julia-1.5>\nfunction sum_digits(n::Int64)\n    if\
    \ n < 0\n        digits = -digits\n        n = 0 - n\n    end\n    digits = 0\n\
    \    while n > 0\n        digits += n % 10\n        n /= 10\n    end\n    digits\n\
    end\n</cell>\n<code language=julia-1.5>\nfunction digits_sum(n)\n    sum_digits(n)\n\
    end\n</cell>\n<code language=julia-1.5>\nfunction digits_sum(nums)\n    return\
    \ reduce(+, nums .% 10)\nend\n</cell>\n<code language=julia-1.5>\ndigits_sum(5)\n\
    </cell>\n<code language=julia-1.5>\ndigits_sum([1, 10, 100])\n</cell>\n<code language=julia-1.5>\n\
    digits_sum([1, -10, -100])\n</cell>\n<code language=julia-1.5>\ndigits_sum([-1,\
    \ 11, -100])\n</cell>\n<code language=julia-1.5>\ndigits_sum([-10, 11, -100])\n\
    </cell>\n<code language=julia-1.5>\ndigits_sum([])\n</cell>\n<code language=julia-1.5>\n\
    digits_sum([1, 11, -100])\n</cell>\n<code language=julia-1.5>\ndigits_sum([-1,\
    \ -11])\n</cell>\n<code language=julia-1.5>\ndigits_sum([1]) == digits_sum([1])\
    \ == digits_sum([1]) == 1\n</cell>\n<code language=julia-1.5>\ndigits_sum([1,\
    \ 11, -100, 1000]) == digits_sum([1, 11, -100, 1000]) == digits_sum([1, 11, -100,\
    \ 1000]) == 9\n</cell>\n<code language=julia-1.5>\ndigits_sum([1, 11, -100, 1000])\
    \ == digits_sum([1, 11, -100, 1000]) == digits_sum([1, 11, -100, 1000]) == 9\n\
    </cell>\n<code language=julia-1.5>\ndigits_sum([1, 11, -100, 1000]) == digits_sum([1,\
    \ 11, -100, 1000]) == digits_sum([1, 11, -100, 1000]) == 9\n</cell>\n<code language=julia-1.5>\n\
    digits_sum([1, 11, -100, 100", "  nums.sort { |a, b| sums = a.digits.map(&:to_i)\
    \ + b.digits.map(&:to_i); sums.min }\nend\n</cell>\n<cell>", "  if nums == []\n\
    \    nums\n  else\n    nums.sort! do |a, b|\n      sum1 = 0\n      sum2 = 0\n\
    \      a.reduce(0) { |sum, n| sum << n << sum }\n      b.reduce(0) { |sum, n|\
    \ sum << n << sum }\n      sum1 < sum2\n    end\n    nums\n  end\nend", "  return\
    \ [] if (nums.empty?) else nums.sort.reverse.map { |num| num % 10 }\nend", " \
    \ nums.sort.tap do |result|\n    nums.each_with_index do |n, i|\n      break if\
    \ (result[i] && result[i].digit == n.digit)\n      result[i] = n\n    end\n  end\n\
    end", "    nums.sort!\n    # Find all the different numbers with the same sum.\n\
    \    sums = nums.inject(0){|sum, item| sum + item}\n    i = 0\n    while sums\
    \ != nums[i] \n        sums = sums - nums[i]\n        i += 1\n    end\n    nums.sort!\n\
    \    nums[i..-1]\nend", "  return nums.uniq.sort_by {|num| nums.map(&:to_i).sum}\n\
    end\n</cell>\n<cell>", "  nums = nums.dup\n  nums.sort do |a, b|\n    abs = a.abs\n\
    \    abs_b = b.abs\n    if abs_b > abs\n      a\n    elsif abs_b == abs\n    \
    \  if a > b\n        b\n      else\n        a\n      end\n    else\n      b\n\
    \    end\n  end\nend", "  sorted = nums\n  sorted = sorted.sort_by { |num| sum_remainder(num)\
    \ }\n  sorted.reverse!\nend", "  if nums.empty?\n    []\n  else\n    nums.sort_by\
    \ do |num|\n      sum_digits(num).reverse\n    end\n  end\nend\n</code>\n<|/ a\
    \ dscore=0 tags=ruby |>\n<| a |>\n<code>", "  # Write your code here.\n  n = nums.size\n\
    \  nums.sort{|a,b| a<b ? -1 : a==b ? 0 : (a<0 ? 1 : a>b ? -1 : 0)}\nend", "  if\
    \ nums.size == 0 then return []\n  nums = nums.sort\n  return nums\nend", "  if\
    \ nums.empty?\n    []\n  else\n    smallest = nums[0]\n    sorted_nums = []\n\
    \    nums.each do |num|\n      sorted_nums << num if num < smallest or smallest.zero?\n\
    \      smallest = num if num < smallest\n    end\n    sorted_nums\n  end\nend",
  "  if nums.size < 2\n    puts \"#{nums} is empty!\"\n    return\n  end", "  # +++your\
    \ code here+++\nend\n</cell>\n<text>\nNow write a function that takes in a list\
    \ of points, checks if they all have equal coordinates, and returns them in a\
    \ list.", "  if nums.length < 2 \n    return nums\n  sum = nums.reduce(:+)\n \
    \ return nums.sort { |a, b| sum <=> sum_of_digits(a) <=> sum_of_digits(b) }\n\
    end", "  nums.sort_by(&:to_s)\nend\n</cell>\n<cell>", "    nums.sort!\n    nums.each\
    \ do |n|\n        if n<0 \n            nums.unshift(n)\n        end\n        if\
    \ n>0 \n            nums.push(n)\n        end\n    end\n    nums\nend\n</cell>\n\
    <code language=julia-0.5>\nnums = [10, 4, 1, 6, 2]\n</cell>\n<code language=julia-0.5>",
  "  nums = nums.sort.reverse\n  if nums.empty?\n    return []\n  end\n  sums = nums.map\
    \ { |n| n.to_s.split('').inject(0) { |sum, digit| sum + digit } }.sort\n  nums.zip(sums).map\
    \ { |n, s| [n, s].max }\nend", "  nums.uniq.sort! do |a, b|\n    a = nums[a]\n\
    \    b = nums[b]\n    if a && b && a == b\n      a\n    else\n      b ? a : -a\
    \ #sort descending\n    end\n  end\n  nums\nend\n</code>\n<|/ a dscore=2 tags=sorting,ruby,arrays,algorithm\
    \ |>\n<| a tags=sorting,ruby,arrays,algorithm |>\nI used the Array#sort method.\
    \ It has a block and returns the original array. You can pass it a block to sort\
    \ using the comparison operator <=>. Here is an example of how it works:\n<code>\n\
    [10, 11, 12, 13].sort do |a, b|\n  a - b\nend\n</code>\nThis will output:\n<code>\n\
    [10, 11, 12, 13]\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't answer the\
    \ question.\n<|/ c |>\n<| a tags=sorting,ruby,arrays,algorithm |>\nThis works\
    \ for me in Ruby 1.9.3:\n<code>", "  nums.sort.with_index do |x,index|\n    nums[index]<0\
    \ ? nums[index]*-1 + x : x\n  end\nend\np order_by_points.call([1, 11, -1, -11,\
    \ -12])", "  return if nums.empty? then [] else nums.sort{|a,b| (a.to_s.split('.').map(&:to_i).inject(0)\
    \ {|sum,x| (sum + x.to_i) <=> sum <=> x.to_i} }\nend", "  nums.sort.tap do |result|\n\
    \    result.reverse! if nums.sum > 0\n  end\nend", "  nums.sort! { |a, b| \n \
    \   (a+b).to_s.split(//).map { |n| n.to_i }.inject(:+) \n  }\nend", "  nums.sort!\
    \ {|a,b| a.to_s + b.to_s}\nend", "  # Write your code here.\n  sorted = nums.sort\
    \ {|x,y|\n    (x == -1) ? -1 : (y == -1) ? 1 : (x - y)\n  }\n  return sorted\n\
    end", "  nums.sort(&:sum)\nend", "  nums = nums.sort\n  nums.reverse\n  nums\n\
    end\n</code>\nAnd now the solution works:\n<code>\norder_by_points.call([12, 20,\
    \ 13, 5, -33])", "  arr=[]\n  sum=0\n  (0...nums.length).each do |i|\n    arr\
    \ << nums[i]\n    sum+=nums[i]\n  end\n  arr.sort!{|a,b| a-b }\n  arr\nend\n</cell>\n\
    <cell>", "  nums.sort.with_index do |x, i|\n    break if i == 0\n    (nums[i]\
    \ - nums[i-1]).abs\n  end\nend\n</code>\n<|/ a tags=ruby,sorting |>\n<| a tags=ruby,sorting\
    \ |>\nYou could use the inject method to sum the digits of each number and then\
    \ sort on the sum of the digits of each number.\n<code>", "  if nums.empty?\n\
    \    return []\n  digits = nums.map &:to_i\n  digits = digits.sort_by &:last\n\
    \  digits = digits.map { |d| -d.abs }\n  nums.sort!\n  nums.map { |d| d.abs }\
    \ * digits\nend\n</code>\nAnd the solution using it...\n<code>", "  # Write your\
    \ code in Ruby\n  nums.sort{|a, b| a.to_i + b.to_i}\nend", "  nums.sort\nend",
  "  return nums.sort_by { |n| n.to_s.split(//).map(&:to_i).inject(0) { |sum, el|\
    \ sum + el } }\nend\n</cell>\n<cell>\norder_by_points.call([10, 5, 3, 6, 2, 1])\n\
    </cell>\n<text>\nThe Ruby way\nThere are many ways of accomplishing the same goal\
    \ in Ruby.  The following uses Array#<=>, which compares the elements of the array\
    \ according to some given ordering rule.  There are many other ways to do the\
    \ same thing, including some more powerful but more advanced sorting methods described\
    \ in the Array and Enumerable documentation.", "  # TODO: rewrite this algorithm\
    \ using stack\n  nums = nums.dup\n  nums.sort!\n  return nums\nend", "    sorted_index\
    \ = []\n    sorted_nums = []\n    sums_of_digits = nums.inject{|sum, el| sum +\
    \ el}\n    nums.each_index{|i| sorted_index.push(i)}\n    nums.each_with_index{|num,\
    \ index| sorted_nums << num if sums_of_digits[index] == sums_of_digits[sorted_index[index]]}\n\
    \    sorted_nums\nend", "  nums.dup.sort!\n  nums.dup.reverse!\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nWhat if I only wanted to sort by the sum of the digits?\
    \ i.e. -1, -12, -1 instead of -1, -11, -1?\n<|/ c |>\n<| c |>\n.J. - Oh, you wanted\
    \ them sorted by index, not by sum of the digits. That's a different requirement,\
    \ and a lot more involved. I'll update the answer.\n<|/ c |>\n<| c |>\nYeah that\
    \ would be a lot more complicated :)\n<|/ c |>\n<| c |>\n.J. - Updated my answer,\
    \ now it sorts by the sum of digits. :)\n<|/ c |>\n<| c |>\nThank you for the\
    \ additional help! I was able to get this working and it does exactly what I asked\
    \ for :)\n<|/ c |>\n<| a |>\n<code>\narr = [\"1\", \"11\", \"2\", \"12\", \"3\"\
    , \"13\", \"4\", \"14\", \"5\", \"15\", \"6\", \"16\", \"7\", \"17\", \"8\", \"\
    18\", \"9\"]\narr.sort.reverse\n</code>\n<|/ a tags=arrays,ruby dscore=1 |>\n\
    <| c |>\nThis doesn't sort by sum of the digits.\n<|/ c |>\n<| c |>\nThis is nice\
    \ but only sorts the string as opposed to the int array.\n<|/ c |>\n<| a dscore=1\
    \ |>\nYou can create a custom comparator, which will sort your array by summing\
    \ the digits and keeping the original index\n<code>", "  nums.sort do |a,b|\n\
    \    sum1 = sum(b)\n    sum2 = sum(a)\n    if sum1 > sum2\n      a\n    else\n\
    \      b\n    end\n  end\nend", "  sorted_nums = nums\n  if nums.empty? || nums.size\
    \ == 1\n    sorted_nums\n  else\n    nums.size.times do |i|\n      sorted_nums[i]\
    \ = nums.select{|num| nums.sum > i && nums.sum > sorted_nums.sum }.max\n    end\n\
    \    sorted_nums\n  end\nend", "  # Your code here\nend\n</cell>\n<code language=julia-0.6>\n\
    @assert order_by_points.([-4, -2, 1, 4, 3]) == [1, -4, 2, -3, 4]\n@assert order_by_points.([-1,\
    \ -4, -2, 1, 4, 3]) == [-3, 1, -4, 2, 4, -1]\n@assert order_by_points.([-2, -4,\
    \ -2, 1, 4, 3]) == [-2, -1, -4, 3, 1, 2]\n</cell>\n<code language=julia-0.6>\n\
    function order_by_points(nums)\n  min_sum = minimum(nums)\n  max_sum = maximum(nums)\n\
    \  n = 1\n  for m in nums\n    if m == min_sum\n      continue\n    end\n    if\
    \ m == max_sum\n      n+=1\n      continue\n    end\n    if m < min_sum && m >\
    \ max_sum\n      n+=1\n      continue\n    end\n    if m > min_sum && m < max_sum\n\
    \      continue\n    end\n    if m < min_sum\n      n+=1\n      continue\n   \
    \ end\n    if m > max_sum\n      n+=1\n      continue\n    end\n    if m < min_sum\n\
    \      continue\n    end\n    if m > max_sum\n      continue\n    end\n    if\
    \ m < min_sum\n      continue\n    end\n    if m > max_sum\n      continue\n \
    \   end\n    n+=1\n  end\n  for i in 1:n\n    nums[i] = nums[i] + n\n  end\nend\n\
    </cell>\n<code language=julia-0.6>\n@assert order_by_points.([-4, -2, 1, 4, 3])\
    \ == [1, -4, 2, -3, 4]\n@assert order_by_points.([-1, -4, -2, 1, 4, 3]) == [-3,\
    \ 1, -4, 2, 4, -1]\n@assert order_by_points.([-2, -4, -2, 1, 4, 3]) == [-2, -1,\
    \ -4, 3, 1, 2]\n</cell>\n<code language=julia-0.6>\n@assert order_by_points.([-4,\
    \ -2, 1, 4, 3]) == [1, -4, 2, -3, 4]\n@assert order_by_points.([-1, -4, -2, 1,\
    \ 4, 3]) == [-3, 1, -4, 2, 4, -1]\n@assert order_by_points.([-2, -4, -2, 1, 4,\
    \ 3]) == [-2, -1, -4, 3, 1, 2]\n</cell>\n<text>\nPart II - More Practice with\
    \ Julia\nIn the last part of the assignment, you solved exercise 1.1. In this\
    \ part, you are going to practice your knowledge with Julia.", "  nums.sort.with_index\
    \ { |n, _i| n }\nend", "    # Your code here\n    sorted_nums = []\n    sums_of_digits\
    \ = {}\n    temp_sum = 0\n    for i in range(len(nums)):\n        temp_sum +=\
    \ nums[i]\n        if temp_sum in sums_of_digits:\n            sums_of_digits[temp_sum].append(i)\n\
    \        else:\n            sums_of_digits[temp_sum] = [i]\n    for sum_of_digit,\
    \ indices in sums_of_digits.items():\n        if len(indices) > 1:\n         \
    \   sorted_nums.extend(sorted(nums[i] for i in indices))\n        else:\n    \
    \        sorted_nums.append(nums[indices[0]])\n    return sorted_nums", "  nums.sort!\
    \ do |a, b|\n    digit_sum = a.digits.sum + b.digits.sum\n    if digit_sum ==\
    \ 0 || digit_sum == a.digits.size + b.digits.size\n      a.to_i - b.to_i\n   \
    \ else\n      a.digits.index(a.digits.rindex(digit_sum) + 1) - b.digits.index(b.digits.rindex(digit_sum)\
    \ + 1)\n    end\n  end\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c\
    \ |>\nThis is very slow. O(n\xB2).\n<|/ c |>\n<| c |>\nYeah I'm doing something\
    \ similar. Have you tried my solution?\n<|/ c |>\n<| c |>\n: I have tried my solution\
    \ and it works pretty well. Although it does need some optimization (like pre-computing\
    \ `digit_sum`, storing `digit_sum` instead of computing it in `rindex`), it also\
    \ doesn't need `sort_by`. My solution also needs `sort_by`, but it uses `Array#sort!`\
    \ method which doesn't need `sort_by`.\n<|/ c |>\n<| c |>\nThe idea here was to\
    \ make the code more readable by replacing `sort_by` with `sort!`. I can't find\
    \ a way to make `sort!` more efficient than `sort_by`.\n<|/ c |>\n<| c |>\n: Yeah,\
    \ sorry I didn't notice that `sort_by` was replaced by `sort!`. Well, my solution\
    \ is inefficient, but it's not slow. Also, `sort!` doesn't require `sort_by`.\
    \ It uses `Array#sort!`.\n<|/ c |>\n<| a dscore=0 tags=ruby,sorting,arrays |>\n\
    <code>\na = [-1, -11, 3, 7, -13, -5, 9, -12]\na.sort_by{|e| a.count(e) + b.count(e)}",
  "  nums.sort!\n  nums.each_with_index do |num, i|\n    if num == 0\n      nums.shift\n\
    \      nums.insert(i, num)\n    end\n  end\nend\n</code>\n<|/ a dscore=4 |>\n\
    <| c |>\nThis looks good and is what I ended up going with. However, I had to\
    \ change the second line to nums.sort! to avoid a SystemStackError in some cases\
    \ where the array of integers is empty.\n<|/ c |>\n<| c |>\nThanks for noticing\
    \ that. I was testing the algorithm with a negative number and forgot to update\
    \ the solution.\n<|/ c |>\n<| a |>\nHere's a solution with time complexity of\
    \ O(n).\n<code>", "  if nums.length < 2 then\n    return nums\n  end\n  local\
    \ digits = {}\n  for _, num in pairs(nums) do\n    digits[num] = digits[num] or\
    \ 0\n    digits[num] = digits[num] + 1\n  end\n  local order = {}\n  local max_num\
    \ = 0\n  local max_key = nil\n  for _, key in pairs(digits) do\n    if digits[key]\
    \ > max_num then\n      max_num = digits[key]\n      max_key = key\n    end\n\
    \  end\n  local idx = 1\n  for _, key in pairs(digits) do\n    if key ~= max_key\
    \ and digits[key] == max_num then\n      order[max_key] = idx\n      idx = idx\
    \ + 1\n    end\n  end\n  for _, num in pairs(nums) do\n    order[num] = idx\n\
    \    idx = idx + 1\n  end\n  for i = 1, #order do\n    nums[order[i]] = i\n  end\n\
    \  return nums\nend\n</code>\n<|/ a tags=arrays,lua |>\n<| a |>\nI made a lot\
    \ of different examples, but I thought I'd share the most readable one I've found:\n\
    <code>\nlocal function sortBySum(nums)\n  local sums = {}\n  local uniqueSums\
    \ = {}", "  sorted = nums.sort.with_index\n  nums.each { |x| x.update({ x: x.to_i\
    \ }) }\n  sorted.map { |n, i| [n, i] }\nend", "  return nums.sort do |a, b|\n\
    \    sum_a = (a.to_s.split(\"\").map(&:to_i).sum.to_f)\n    sum_b = (b.to_s.split(\"\
    \").map(&:to_i).sum.to_f)\n    sum_a_desc = sum_a > sum_b ? 1 : sum_a < sum_b\
    \ ? -1 : 0\n    sum_a_num = a.to_s.split(\"\").map(&:to_i).sum.to_f\n    sum_b_num\
    \ = b.to_s.split(\"\").map(&:to_i).sum.to_f\n    sum_a_desc_num = sum_a_desc >\
    \ 0 ? sum_a_desc : sum_a_num > 0 ? sum_a_num : sum_a_desc_num\n    if sum_a_desc_num\
    \ == sum_b_num\n      return sum_a_num > sum_b_num ? 1 : -1\n    elsif sum_a_desc_num\
    \ < sum_b_num\n      return 1\n    else\n      return -1\n    end\n  end\nend\n\
    </code>\n<|/ a tags=ruby dscore=1 |>\n<| c |>\nThis is still a good solution to\
    \ the problem. The problem is that the problem description specifically says \"\
    the sum of the digits in the numbers given should always be greater than the sum\
    \ of the digits in the numbers given - 1\". I am not sure this is what the OP\
    \ wants.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  return [] if nums.empty? else\
    \ nums.select { |i| i.digits.sort.reverse.uniq.first == i }\nend", "  nums = nums.sort_by!\
    \ { |n| n.digits.reduce(:+) }\n  nums = nums.reverse.sort_by! { |n| n.digits.reduce(:+)\
    \ }\n  nums\nend", "  nums.sort! do |a, b|\n    sum = a.to_s + b.to_s\n    sum.split('').uniq.map\
    \ { |c| c.to_i }.sort.last\n  end\nend", "  if nums.empty?\n    return nums\n\
    \  \n  digits = nums.map(&:to_i).map(&:to_s)\n  \n  # Build a hash where keys\
    \ are digits and values are indices\n  # of nums with same digit.\n  digits_hash\
    \ = digits.each_with_object(Hash.new(0)) { |digit,h| h[digit] += 1 }\n  \n  #\
    \ Sort the nums by index\n  nums.sort_by { |n| digits_hash[n.to_s].to_i }\nend\n\
    </code>\n<|/ a tags=ruby,arrays |>\n<| a tags=ruby,arrays |>\nI wrote a solution\
    \ that sorts the array in place.\n<code>", "    nums = nums.sort_by { |num| num.digits.inject(0)\
    \ { |total, digit| total + digit } } \n    nums.empty? ? [] : nums\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThe other answers are right on, you could avoid the\
    \ additional method calls by doing `nums.sort_by { |num| num.digits.inject(0)\
    \ { |total, digit| total + digit } } ` instead. Also if you had Ruby 1.9+ you\
    \ could avoid the additional method calls and just use `nums.sort { |a, b| a.digits.inject(0)\
    \ { |sum, digit| sum + digit } <=> b.digits.inject(0) { |sum, digit| sum + digit\
    \ } }` which also gives you the original array back if you need to do stuff with\
    \ it afterwards.\n<|/ c |>\n<| c |>\n, thank you very much for the answer, but\
    \ unfortunately it doesn't work for me - it still returns empty array when given\
    \ empty arrays. I've tried debugging and it seems that somehow it doesn't even\
    \ enter the block for the empty arrays.\n<|/ c |>\n<| c |>\nAre you sure you didn't\
    \ copy/paste it wrong? I edited the answer to add `return` before `[]` (which\
    \ you shouldn't need in ruby). Also, try copy/pasting exactly as I put it and\
    \ see if it works.\n<|/ c |>\n<| a tags=arrays,ruby dscore=1 |>\n<code>", "  return\
    \ [] if nums.empty? || nums.size < 2 # no valid points for ordering in the empty\
    \ list or one point\n  odd_points = nums.take_while{ |num| num % 2 == 1 }\n  odd_points.reverse!\
    \ # reversed order to fix ordering for sum\n  odd_sums = odd_points.map{ |num|\
    \ num.digital_sum } # map to digits sum\n  odd_sums.compact.sort! # sort in ascending\
    \ order\n  odd_sums.compact.reverse_each { |odd_sum| odd_points[odd_sums.index{|sum|\
    \ sum == odd_sum}] }\nend", "    nums = nums.sort\n    nums << nums.map { |n|\
    \ n.to_i }\n    return nums\nend", "    i = 0\n    nums.each do |num|\n      i\
    \ += num if num > 0\n    end\n    nums.sort.reverse.concat(nums[0..i - 1])\nend",
  "  return [] if nums.empty? else nums.sort.reverse.map do |num|\n    num = num.to_i\n\
    \    [num, digits(num).sum]\n  end\nend", "  if nums.length == 0 then return []\n\
    \  local sum = 0\n  for i,v in ipairs(nums) do sum = sum + v end\n  return order_by_points.call(nums,\
    \ sum, nums.length)\nend", "    # Write your solution here.\n  \n    nums.sort!\n\
    \  \n    if nums.empty?\n        puts []\n    elsif nums.length == 1\n       \
    \ puts [nums[0]]\n    else\n        temp = nums[0]\n        sum = 0\n        i\
    \ = 0\n        while i < nums.length\n            if nums[i] + sum < temp + sum\n\
    \                sum += nums[i]\n                nums[i] = temp\n            else\n\
    \                i += 1\n            end\n        end\n        nums[i] = temp\n\
    \        puts nums\n    end\nend", "  return nums.sort do |a, b|\n    # Find the\
    \ least summand\n    least_summand = nil\n    least_summand_idx = nil\n    idx\
    \ = 0\n    while idx < nums.length and least_summand == nil\n      summand = nums[idx]\n\
    \      idx += 1\n      if summand != 0\n        least_summand = summand\n    \
    \    least_summand_idx = idx\n      end\n    end\n    if least_summand == nil\n\
    \      idx = nums.length - 1\n      summand = nums[idx]\n      idx -= 1\n    \
    \  while idx > 0 and summand == 0\n        idx -= 1\n        summand = nums[idx]\n\
    \      end\n      least_summand_idx = idx\n    end\n    # Compare them\n    least_summand_idx\
    \ <=> least_summand_idx\n  end\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nCan\
    \ you explain what that `@nums.sort do |a, b|` means? What does the `|a, b|` mean?\n\
    <|/ c |>\n<| c |>\n[Enumerable#sort](https://ruby-doc.org/core-2.5.1/Enumerable.html#method-i-sort)\
    \ accepts a block of code which takes two items from `nums`, and compares them.\
    \ Using `|a, b|` as an argument means that the block will accept two variables\
    \ which are already defined by the `sort` method. Here is a [link](https://www.railstips.org/blog/archives/2009/05/11/enumerable_sort.html)\
    \ to a Rails article that explains Enumerable#sort and blocks.\n<|/ c |>\n<| c\
    \ |>\nThanks for the explanation!\n<|/ c |>\n<| a tags=ruby,sorting,arrays |>\n\
    <code>", "  if nums.empty?\n    nums\n  else\n    nums.sort.reverse!\n    nums.sort\
    \ { |a, b| a + b.to_i }\n  end\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nPlease\
    \ add an explanation to your answer.\n<|/ c |>\n<| c |>\nThe sorting method will\
    \ sort this way: [-1, -11, 1, -12, 11]. Is this the expected result?\n<|/ c |>\n\
    <| c |>\nYou will also have to add a condition for empty list. Your code doesn't\
    \ do it.\n<|/ c |>\n<| a dscore=0 tags=ruby,sorting,arrays |>\n<code>\n[5, 10,\
    \ 11, 12, 13].sort.each {|a| puts a}", "  if nums.empty? || nums.length == 0 ||\
    \ nums[0] == 0 \n  then return nums\n  end\n  \n  sums = {}\n  \n  nums.each do\
    \ |num|\n    sum = num.to_s.split('').inject(0) do |sum, digit|\n      sum + digit.to_i\n\
    \    end\n    sums[sum] = num\n  end", "  return nums.sort_by{ |x|\n    (x % 10)\
    \  + 9 * (x % 100) / (x % 1000)\n  }\nend\n</cell>\n<cell>", "  nums = nums[0..(nums.length)-1]\n\
    \  nums.sort!\n  i = 0\n  while i < nums.length\n    if nums[i] > 0 && nums[i]\
    \ < 10\n      nums[i+1] = nums[i]\n      nums[i] = 0\n    i += 1\n  end\n  nums\n\
    end", "    return nums if nums.any? { |num| num.is_a?(Integer) } \n    return\
    \ [] if nums.empty?\n    num = nums[0]\n    other = nums.delete_at(0) unless nums.size\
    \ == 1\n    return [] if other.is_a?(Integer) && num < other\n    return nums\
    \ if num > other\n    return [num, *order_by_points(nums.drop(1))]\nend", "  #\
    \ Write your code below!\n  nums\nend\n</cell>\n<cell>", "  # write your code\
    \ here\n  nums.each_with_index { |n, i| nums[i] = [n, i]}\n  nums.sort do |x,y|\n\
    \    x[0] <=> y[0] || (x[1] <=> y[1])\n  end\n  nums.map { |n| n[0] }\nend", '  return
    [] if nums.empty? || nums.size == 1', "  nums = nums.sort { |x, y| y <=> x }\n\
    \  return nums\nend", "  nums.sort! { |a,b| a.to_s + b.to_s }\nend", "  # Write\
    \ your code here.\n  nums.sort!\n  nums.reverse!\n  nums.map! {|x| x.to_i}\n \
    \ nums\nend", "  # TODO: Write a loop to sort nums according to their digits.\n\
    \  # In case of equal digits, sort them according to their index in nums.\n  #\
    \ For example: nums = [1, 11, -1], return [1, -1, 1, 11]\n  # Note: if there are\
    \ several items with equal digits,\n  # order them based on their index in nums.\n\
    \  # For example: nums = [1, 11, -1], return [1, -1, 1, 11]\n  # Note: if there\
    \ are several items with equal digits,\n  # order them based on their index in\
    \ nums.\n  # For example: nums = [1, 11, -1], return [1, -1, 1, 11]\n  # Note:\
    \ if there are several items with equal digits,\n  # order them based on their\
    \ index in nums.\n  # For example: nums = [1, 11, -1], return [1, -1, 1, 11]\n\
    \  # Note: if there are several items with equal digits,\n  # order them based\
    \ on their index in nums.\n  # For example: nums = [1, 11, -1], return [1, -1,\
    \ 1, 11]\n  # Note: if there are several items with equal digits,\n  # order them\
    \ based on their index in nums.\n  # For example: nums = [1, 11, -1], return [1,\
    \ -1, 1, 11]\n  # Note: if there are several items with equal digits,\n  # order\
    \ them based on their index in nums.\n  # For example: nums = [1, 11, -1], return\
    \ [1, -1, 1, 11]\n  # Note: if there are several items with equal digits,\n  #\
    \ order them based on their index in nums.\n  # For example: nums = [1, 11, -1],\
    \ return [1, -1, 1, 11]\n  # Note: if there are several items with equal digits,\n\
    \  # order them based on their index in nums.\n  # For example: nums = [1, 11,\
    \ -1], return [1, -1, 1, 11]\n  nums.sort!", "  nums.map! { |x| x.to_i }\n  nums.sort!\n\
    \  nums\nend", "  return [] if nums.empty? else [nums.min].concat(\n    (nums.map\
    \ { |num| num.digits(2) }.sort.map { |sum| nums.index(sum) })\n  )\nend", "  nums\
    \ ||= []\n  result = []\n  nums.each do |num|\n    result[num] = nums[num] unless\
    \ result[num].nil?\n  end", "  return [] if nums.empty? || nums.size < 2 \n  sum_nums\
    \ = nums.reduce(0, :+)\n  return nums if sum_nums == 0\n  \n  sorted_nums = nums.sort{\
    \ |a, b| sum_of_digits(a) > sum_of_digits(b) }\n  max_i = sorted_nums.index {\
    \ |n| sum_of_digits(n) == sum_nums }\n  sorted_nums[max_i..-1] + sorted_nums[0,\
    \ max_i]\nend", "  # Write your code here.\nend", "  nums.sort.with_index{ |x,y|\
    \ y < x ? y : x}.\n    map { |x| x.to_i }.\n    sort_by { |x| x.reduce(:+) }\n\
    end", "  if nums.empty?\n    nums\n  else\n    nums.inject([]) do |array, number|\n\
    \      sum = 0\n      (0 ... number.to_s.size).each do |i|\n        sum += number.to_s[i].to_i\n\
    \      end\n      array << number if sum >= 0\n      array\n    end\n  end\nend",
  "  sorted_array = nums.sort_by { |num| sum_of_digits(num) }\n  return sorted_array.reverse\n\
    end", "  nums.sort! { |a, b| a.to_s + b.to_s }\nend", "    digits = []\n    sum\
    \ = 0\n    digits_index = 0\n    nums_index = 0\n    while nums_index < len(nums)\n\
    \        sum = sum + nums[nums_index]\n        digits.append(sum % 10)\n     \
    \   nums_index += 1\n        sum = 0\n    digits.reverse()\n    nums.reverse()\n\
    \    digits_index = 0\n    nums_index = 0\n    while nums_index < len(nums)\n\
    \        sum = sum + nums[nums_index]\n        digits[digits_index] = (sum % 10)\n\
    \        digits_index += 1\n        nums_index += 1\n    nums.reverse()\n    digits_index\
    \ = 0\n    nums_index = 0\n    while digits_index < len(digits)\n        nums[nums_index]\
    \ = digits[digits_index]\n        digits_index += 1\n        nums_index += 1\n\
    \    return nums\n</code>\n<|/ a tags=arrays,algorithm,sorting,ruby |>\n<| a tags=arrays,algorithm,sorting,ruby\
    \ dscore=1 |>\n<code>", "  # Write your code here.\n  nums.sort!\nend", "  nums.sort\
    \ do |a, b|\n    a <=> b if (a =~ /^-?\\d+$/ && b =~ /^-?\\d+$/) || a <=> b\n\
    \  end\nend", "  # Your code here\n  sums = nums.inject(Hash.new(0)){|memo, num|\
    \ memo[num.to_s.to_i] += num}\n  sums.sort{|a, b| b - a}\nend", "  return nums.sort.collect\
    \ do |n|\n    digits = n.to_s.chars.map(&:to_i)\n    sum  = digits.inject(:+)\n\
    \    \n    if sum == digits.length\n      [n].concat(digits.drop(sum))\n    elsif\
    \ sum > digits.length\n      [n]\n    elsif sum < digits.length\n      [n] + digits.take(sum)\n\
    \    end\n  end\nend\n</code>\n<|/ a dscore=3 tags=algorithm,ruby |>\n<| a dscore=2\
    \ |>\nI would use recursion as follows:\n<code>", "  sorted_nums = nums\n  sum\
    \ = 0\n  sums_of_digits = []\n  sorted_nums.each do |num|\n    digits = num.to_s.split(\"\
    \")\n    digits.each do |digit|\n      sums_of_digits << digit.to_i\n    end\n\
    \    sum = sums_of_digits.reduce(:+)\n    sums_of_digits.clear\n    sorted_nums.delete_at(nums.index(num))\n\
    \    sorted_nums.insert(nums.index(num) + 1, sum)\n    break if sums_of_digits.count\
    \ == 0\n  end\n  sorted_nums\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 tags=ruby,sorting,arrays\
    \ |>\nHere is an implementation which sorts the array in O(nlogn):\n<code>", " \
    \ sums = nums.inject(:+)\n  sums.sort_by{|x|sums[x]}\nend\n</cell>\n<cell>", " \
    \ if nums.empty?\n    return []\n  digits = nums.map(&:to_i)\n  min_digit = digits.min\n\
    \  max_digit = digits.max\n  digit_sum = digits.reduce(:+)", "  if nums.nil?\n\
    \    []\n  else\n    sort_nums = nums.sort\n    sorted_nums = []\n    \n    while\
    \ nums.length > 0\n      sum = 0.0\n      \n      while nums.length > 0\n    \
    \    if sum >= 10\n          break\n        \n        sum += nums.shift\n    \
    \  end\n      \n      if sum < 0\n        sorted_nums = nums + sorted_nums\n \
    \       nums = sort_nums\n      else\n        sorted_nums.unshift(nums.pop)\n\
    \      end\n    end\n    \n    sorted_nums\n  end\nend", "  sorted = []\n  sorted\
    \ = nums.sort {|a, b| compare_digits(a, b) }\n  return sorted if sorted.empty?\n\
    \  sorted = sorted.reverse\nend", "  # Write your code here.\n  if nums.empty?\
    \ then return nil end\n  nums, nums_copy = nums.dup, []\n  nums_copy.sort_by do\
    \ |x|\n    nums_copy.each { |y| return x if sum?(x) <=> sum?(y) }\n    nums_copy.each\
    \ { |y| return y if sum?(y) <=> sum?(x) }\n    x.to_i\n  end\nend", "  nums.sort\
    \ { |n1, n2| n1.digits_sum - n2.digits_sum }\nend", "    # Fill in the code here.\n\
    \    nums = nums.sort\n    nums.each do |num|\n        if nums.sum > 0\n     \
    \       return num if nums.sum == num\n        end\n    end\n    return []\nend",
  "  # Your code here\n  nums.sort!\nend", "  # Your code here\n  return nums.sort\n\
    end", "  # Your code here\n  \nend", "  nums.sort!\n  index = 0\n  while index\
    \ < nums.length\n    sum = 0\n    while sum < 10\n      sum += nums[index]\n \
    \     index += 1\n    sum -= 10\n    if sum > 0\n      nums.swap(index, index)\n\
    \      index -= 1\n    end\n  end\n  nums\nend", "  # Write your code here.\n\
    end\n</cell>\n<text>\nNow you can call order_by_points to sort the given array\
    \ of integers:", "  return [] if nums.empty? then return [] else (nums[0]+nums[1]+nums[2]...).sort\n\
    end", "  return [] if nums.empty? else [nums.sort.reverse.last]\nend", "  return\
    \ [] if nums.empty? || nums.size < 2\n  \n  nums.each_with_index do |num,i|\n\
    \    num.zero? && return\n    num.zero? || nums.size - i > 1 ? nums[i - 1] + num\
    \ : num\n  end\n  \n  nums\nend", "  nums.sort { |a, b| b + a } \nend", "  nums\
    \ = nums.sort\n  while nums.length > 0\n    sum = nums.inject { |s, i| s + i }\n\
    \    if sum > 0\n      nums.unshift(nums.pop)\n    else\n      break\n    end\n\
    \  end\n  nums\nend\n</code>\nThen you can test it with:\n<code>\ntest_nums =\
    \ [\n  [1, 111, -1, -11, -12],\n  [],\n  [-21, -12, 11],\n  [1, 2, 2, 3, 4, 4,\
    \ 4, 4, -12, -11],\n]\nnums = test_nums.map{ |n| n.sort }\nnums.each_with_index\
    \ do |num, i|\n  puts \"[#{i}] #{num}\"\nend", "    # Write your solution here\n\
    \    hash = {}\n    for num in nums\n        num_bin = num.to_s(2)\n        if\
    \ num_bin in hash\n            hash[num_bin] += num\n        else\n          \
    \  hash[num_bin] = num\n    end\n    nums.sort\n    return nums\nend\n</cell>\n\
    <text>\n4.5\nWrite a function, using map and sort, which returns true if at least\
    \ one of two given lists has elements with same sum and false otherwise. For example,\
    \ given two lists [1, 3] and [3, 3] your function should return true.", "  nums.sort!{\
    \ |x,y| x.to_s.length <=> y.to_s.length }.\n  nums\nend", "  return [] if nums.empty?\
    \ else nums.sort{ |a,b| a.to_f <=> b.to_f }.map { |x| x.to_i }\nend", "  nums.sort!\
    \ {|x, y| x.digits.sum + y.digits.sum if x != y}\nend", "  # Your code goes here\n\
    \  arr.sort.sort!\nend", "  if nums.size == 0\n    return nums\n  last_sum_digits\
    \ = nums.sum.to_f\n  last_sum_index = nums.size - 1\n  nums.sort.reverse!\n  nums.each\
    \ do |num|\n    if num.digits == last_sum_digits\n      nums.swap last_sum_index,\
    \ nums.index(num) \n    end\n    last_sum_digits = nums.sum.to_f\n  end\n  nums\n\
    end\n</code>\nI hope that this helps! The algorithm is not very efficient as it\
    \ has O(n^2) time complexity, but since your problem is a standard sorting problem\
    \ I believe that the time complexity is not too bad. Here is an example where\
    \ I used a sorted array to show that it is still doable in linear time complexity.\
    \ \n<code>", "    # Write your code here\n    if nums == []\n        return []\n\
    \    sum = 0\n    for x in nums\n        sum += x\n    sort = nums\n    sort.reverse()\n\
    \    sort_sum = 0\n    sort_index = []\n    for x in sort\n        sort_sum +=\
    \ x\n        if sort_sum < sum:\n            sort_index.append(sort.index(x))\n\
    \            sort_sum -= x\n            sum -= x\n        else:\n            sort.remove(x)\n\
    \            sort.insert(sort_index.index(x), x)\n            sort_index.remove(sort.index(x))\n\
    \            sort_sum -= x\n            sum -= x\n    return sort", "  nums_sum\
    \ = nums.reduce(0)\n  return nums.sort.map {|n| n.to_i + nums_sum}\nend\n</cell>\n\
    <text>\nLet's have a try at using the new order_by_points function.", "  return\
    \ [] if nums.empty?\n  nums.sort.each do |i|\n    digits = nums[i].digits\n  \
    \  digits = [digits, 0] if digits.empty?\n    digits[2] = digits[2] + digits[1]\n\
    \    nums[i] = Point.new(digits)\n  end\n  nums\nend", "    nums, length = nums,\
    \ len(nums)\n    result = []\n    digits = [0] * 10\n    while nums != []:\n \
    \       digits[nums[0] % 10] += 1\n        for i in range(1, len(nums)):\n   \
    \         digits[i] += digits[nums[i]]\n        nums = nums[1:]\n    for digit\
    \ in reversed(digits):\n        if digit > 0:\n            result.insert(0, digit)\n\
    \    return result\n</cell>\n<cell>\norder_by_points(range(-100, 100))\n</cell>\n\
    <text>\n2.7 Recursion\nGiven a binary search tree and a target value, return the\
    \ path from root to the target value.", "  nums.sort.with_index { |num, i| num.divmod(10).to_a.sum\
    \ + i }\nend", "  nums = nums.dup.sort\n  if nums.empty?\n    return []\n  end\n\
    \  if nums.length == 1\n    return nums\n  end\n  cur_sum = 0\n  cur_point = nil\n\
    \  nums.each_with_index do |n, i|\n    cur_sum += n.to_i\n    if cur_sum != 0\n\
    \      if cur_sum > cur_point\n        cur_point = cur_sum\n      end\n    end\n\
    \  end\n  if cur_point == 0\n    nums[0]\n  else\n    [nums[0], nums[nums.size\
    \ - 1].divmod(10).to_i]\n  end\nend\n</code>\n<|/ a tags=sorting,ruby |>\n<| a\
    \ tags=sorting,ruby |>\n<code>", "    sorted = nums.sort {|a, b| b.to_f - a.to_f}\n\
    \    sorted.empty? ? [] : nums.zip(sorted)\nend\n</code>\n<|/ a tags=arrays,ruby\
    \ dscore=3 |>\n<| c |>\nI prefer `a.to_i <=> b.to_i`, because `sort` sorts lexicographically\
    \ by default.\n<|/ c |>\n<| a tags=arrays,ruby |>\n<code>\narray.sort{|x,y| x.to_f\
    \ - y.to_f}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>\narray.sort\
    \ {|a, b| a.to_i <=> b.to_i }\n</code>\n<|/ a tags=arrays,ruby |>\n<| a tags=arrays,ruby\
    \ |>\nFor a quick solution:\n<code>\narray.sort do |a, b|\n  a.to_i <=> b.to_i\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nIf you want a more robust solution\
    \ (i.e. you want to have more than just strings) then you can also use the case\
    \ insensitive comparison operator <=> on the strings themselves (i.e. the two\
    \ elements being compared are both strings, not just integers) and let the numbers\
    \ be sorted as normal:\n<code>\narray.sort {|a, b| a.to_i <=> b.to_i}\n</code>\n\
    <|/ a tags=arrays,ruby |>\n<| c |>\nThis works, but it only works in Ruby 1.9\
    \ and newer. The question was tagged ruby 1.8 but this should be the accepted\
    \ answer.\n<|/ c |>\n<| a tags=arrays,ruby |>\n<code>\narray.sort{|x,y| x.to_i\
    \ <=> y.to_i}\n</code>\nWorks fine for me :)\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\nJust a small addition to the previous answers - since they used a lambda\
    \ as comparator they will sort the strings as well as integers. So if you want\
    \ a more robust solution use to_i on the strings themselves:\n<code>\narray.sort\
    \ {|a, b| a.to_i <=> b.to_i}\n</code>\n<|/ a tags=arrays,ruby |>\n<| a dscore=0\
    \ tags=arrays,ruby |>\n<code>\narray.sort_by!(&:to_i)\n</code>\n<|/ a |>\n<| a\
    \ dscore=0 tags=arrays,ruby |>\n<code>", "    nums = [*nums].sort{ |a, b| a.to_s.to_i(10)\
    \ + b.to_s.to_i(10) << 1 }\n    nums ||= []\n    nums\nend\n</cell>\n<cell>",
  "  nums.sort do |a,b|\n    sum_a = (a.to_s.split(//).sum.to_i).abs\n    sum_b =\
    \ (b.to_s.split(//).sum.to_i).abs\n    sum_a == sum_b ? a : b\n  end\nend\n</code>\n\
    <|/ a tags=ruby,sorting,algorithm dscore=1 |>\n<| a tags=ruby,sorting,algorithm\
    \ |>\nA bit late, but I just had a similar question and thought I could share\
    \ my solution:\n<code>", "  nums.compact.sort_by do |number|\n    sum = 0;\n \
    \   (nums - [number]).each do |digit|\n      sum += digit.to_i\n    end\n    sum\n\
    \  end\nend", "  # Follow steps in the pseudocode below\n  points = []\n  num_points\
    \ = []\n  # For each number in the input array\n  for n in nums\n    # For each\
    \ digit in the number\n    # Find out if the current number has that digit\n \
    \   # Keep a counter of how many times the number has that digit\n    # If the\
    \ counter is 1, then the number has that digit\n    # Add the number to the output\
    \ array \n    # if the counter is greater than 1, then there are multiple\n  \
    \  # instances of the number with that digit, so just sort by the\n    # index\
    \ in the original array\n    num_digits = count_digits(n)\n    if num_digits >\
    \ 1\n      num_points.push(num_digits)\n      points.push(n)\n    else\n     \
    \ points.push(n)\n  end\n  # Sort the output array by number of digits\n  points.sort\
    \ { |a, b| num_points.index b - num_points.index a}\nend", "  return nums.sort\
    \ do |a,b|\n    sum = 0\n    (a || b || 0).to_s.chars.each do |c|\n      sum +=\
    \ if c == ?-\n        10\n      else\n        c.ord\n      end\n    end\n    sum\
    \ < 0 ? a : b\n  end\nend", "  sorted = []\n  nums.each do |n|\n    if n.to_s.split(\"\
    \").sort.join.to_i ==\n      n.to_s.split(\"\").sort.join.to_i\n      sorted <<\
    \ n\n    end\n  end\n  sorted.sort! { |a, b| a.to_i <=> b.to_i }\nend", "  nums\
    \ = nums.sort\n  nums.sort! { |a, b| a <=> b }\n  nums\nend", "    # Write your\
    \ code here.\n    \n    sorted = nums\n    sorted = sorted.sort\n    sorted =\
    \ sorted.reverse!\n    return sorted\nend\n</cell>\n<text>\n3. Given a list of\
    \ strings, return a list of strings in which each element\nis a possible permutation\
    \ of the string.", "  nums.sort!\n  index = 0\n  last_digit = nil\n  nums.each\
    \ do |n|\n    if (last_digit == n.to_s.split('').sort)\n      nums.delete(nums[index])\n\
    \      nums.insert(index, n)\n      break\n    end\n    last_digit = n.to_s.split('').sort\n\
    \    index += 1\n  end\n  nums\nend", "  nums.sort!\n  i = 0\n  while i < nums.length\
    \ && nums[i] == 0\n    i += 1\n  end\n  nums.sort!\n  i = 0\n  while i < nums.length\
    \ && nums[i] != 0\n    nums[i] = nums[i] - nums[i+1]\n    i += 1\n  end\n  nums\n\
    end", "  # TODO: Implement function\n  nums.sort!\n  i = 0\n  while i < nums.length\
    \ - 1\n    if nums[i] <= nums[i + 1]\n      nums[i], nums[i + 1] = nums[i + 1],\
    \ nums[i]\n    end\n    i += 1\n  end\nend", "  return [] if nums.empty? else\
    \ nums.uniq.sort_by { |num| sum_of_digits(num) }.uniq\nend", "  nums_sorted =\
    \ nums\n  sums = []\n  if nums_sorted.empty?\n    return nums_sorted\n  i = 0\n\
    \  while i < nums_sorted.length\n    sum = nums_sorted[i]\n    sums.push(sum.to_s)\n\
    \    i += 1\n  end\n  i = 0\n  while i < nums_sorted.length\n    sums.sort! {\
    \ |a, b| a.to_i < b.to_i ? -1 : a.to_i > b.to_i ? 1 : 0 }\n    sum = sums[i]\n\
    \    sums.delete(sum)\n    nums_sorted.insert(i, sum)\n    i += 1\n  end\n  nums_sorted\n\
    end", "  nums.sort! { |x,y| x.to_s.length <=> y.to_s.length }\nend", "  nums.sort.with_index{\
    \ |n, i| n.to_s.split(//).map {|n| n.to_i}.inject(:+) }\nend\n</code>\n<|/ a |>\n\
    <| a tags=sorting,ruby |>\nYou could do something like this...\n<code>\nnumbers\
    \ = Array.new\n10.times do\n  numbers << rand(100) + 1\nend", "  nums.sort{|a,\
    \ b| a.to_s + b.to_s}\nend", "  nums = nums.sort\n  i = 0\n  sum = 0\n  while\
    \ i < nums.length\n    sum += nums[i]\n    i += 1\n  end\n  i = 0\n  while i <\
    \ nums.length\n    nums[i], nums[sum - nums[i]] = nums[sum - nums[i]], nums[i]\n\
    \    i += 1\n    sum -= nums[i]\n  end\n  nums\nend", "    sums = nums.map{|n|\
    \ n.to_s.length}.inject(0){|acc, n| acc + n}\n    sorted_nums = []\n    nums.each\
    \ do |n|\n        digits = n.to_s.length\n        digits = 1 if digits == 0 &&\
    \ n >= 0 ? 1 : digits\n        digits = 0 if digits == 0 && n >= 0 ? 0 : digits\n\
    \        sorted_nums << n if n.to_s.size == digits && n >= 0\n        sorted_nums\
    \ << n if n.to_s.size == digits && n < 0\n    end\n    sorted_nums = sorted_nums.sort_by{|n|\
    \ sums - n.to_s.length}\nend", "  return [] if nums.empty? \n  \n  nums.sort!\
    \ do |a, b|\n    a_sum = a.digits.inject(0) {|sum, digit| sum + digit}\n    b_sum\
    \ = b.digits.inject(0) {|sum, digit| sum + digit}\n    a_sum.to_i - b_sum.to_i\
    \ if a_sum > b_sum\n  end\n  \n  nums\nend\n</cell>\n<cell>", "  nums.sort(&:<=>)\n\
    end", "  return nums.sort{|a,b| a.to_s.split(//).reduce(:+) - b.to_s.split(//).reduce(:+)}\n\
    end", "  nums.sort! {|a,b| a.to_s.size + b.to_s.size}\nend\n</cell>\n<cell>\n\
    order_by_points.call([1, 11, -1, -11, -12])\n</cell>\n<cell>\norder_by_points.call([])\n\
    </cell>\n<cell>", "    # Write your implementation here.\n    return nums\nend\n\
    </cell>\n<cell>\nnums_1 = [1, 11, -1, -11, -12]\nnums_2 = []\nnums_3 = [1]\nnums_4\
    \ = [1, 11, -1, -11, -12]\nnums_5 = [1, 11, -1, -11, -12, 1, 11, -1, -11, -12,\
    \ -1]\nnums_6 = [1, 11, -1, -11, -12]\nnums_7 = []\nnums_8 = [1, 11, -1, -11,\
    \ -12, 1, 11, -1, -11, -12, -1]\nnums_9 = [1, 11, -1, -11, -12]\nnums_10 = [1,\
    \ 11, -1, -11, -12, 1, 11, -1, -11, -12, -1]\nnums_11 = [1, 11, -1, -11, -12]\n\
    nums_12 = [1, 11, -1, -11, -12, 1, 11, -1, -11, -12, -1]\nnums_13 = [1, 11, -1,\
    \ -11, -12]\nnums_14 = [1, 11, -1, -11, -12, 1, 11, -1, -11, -12, -1]\nnums_15\
    \ = [1, 11, -1, -11, -12, 1, 11, -1, -11, -12, -1]\nnums_16 = [1, 11, -1, -11,\
    \ -12]\nnums_17 = [1, 11, -1, -11, -12]\nnums_18 = [1, 11, -1, -11, -12]\nnums_19\
    \ = [1, 11, -1, -11, -12]\nnums_20 = [1, 11, -1, -11, -12]\nnums_21 = [1, 11,\
    \ -1, -11, -12]\nnums_22 = [1, 11, -1, -11, -12]\nnums_23 = [1, 11, -1, -11, -12]\n\
    nums_24 = [1, 11, -1, -11, -12]\nnums_25 = [1, 11, -1, -11, -12]\nnums_26 = [1,\
    \ 11, -1, -11, -12]\nnums_27 = [1, 11, -1, -11, -12]\nnums_28 = [1, 11, -1, -11,\
    \ -12]\nnums_29 = [1, 11, -1, -11, -12]\nnums_30 = [1, 11, -1, -11, -12]\nnums_31\
    \ = [1, 11, -1, -11, -12]\nnums_32 = [1, 11, -1, -11, -12]\nnums_33 = [1, 11,\
    \ -1, -11, -12]\nnums_34 = [1, 11, -1, -11, -12]\nnums_35 = [1, 11, -1, -11, -12]\n\
    nums_36 = [1, 11, -1, -11, -12]\nnums_37 = [1, 11, -1, -11, -12]\nnums_38 = [1,\
    \ 11, -1, -11, -12]\nnums_39 = [1, 11, -1, -11, -12", "  nums = nums.sort.to_a\
    \ if nums.is_a?(Enumerable)\n  nums.sort_by do |n|\n    points = 0\n    n.to_s.split(\"\
    \").each do |c|\n      points += 1 if c =~ /\\d/\n    end\n    points\n  end\n\
    end\n</code>\nAnd then I can call it as:\n<code>\np order_by_points.call([-5,\
    \ -2, 1, 5, 2]) # => [-2, 1, -5, 5, 2]\np order_by_points.call([-5, -2, 1, 5,\
    \ 2, -1, 1])\np order_by_points.call([-5, -2, 1, 5, 2, -1, 2])\np order_by_points.call([-5,\
    \ -2, 1, 5, 2, -1, 2, -5, -1])\np order_by_points.call([-5, -2, 1, 5, 2, -1, 2,\
    \ -5, -1, -5, -5, 1])\np order_by_points.call([-5, -2, 1, 5, 2, -1, 2, -5, -1,\
    \ -5, -5, 2])\n</code>\n<|/ a dscore=3 |>\n<| a tags=ruby,ruby-on-rails,arrays\
    \ |>\n<code>", "  nums = nums.sort\n  nums.sort { |a,b| a + b }\nend\n</cell>\n\
    <text>\nLet's test our solution:", "  nums << []\n  nums.uniq.each do |num|\n\
    \    i = 0\n    while num > 0 do\n      nums[i] = num % 10\n      i +=1\n    \
    \  num /= 10\n    end\n    nums[i] = 0\n    i += 1\n  end\n  nums.sort\n  nums\n\
    end", "    # write your code in Ruby\n    sorted = nums.sort\n    sorted = sorted.each_with_index.map\
    \ {|n, i| [n, i]}\n    sorted = sorted.sort_by{|n| -n.last}\n    sorted = sorted.map(&:first)\n\
    end\n</code>\n<|/ a tags=ruby,arrays,algorithm |>\n<| c |>\n`sorted = sorted.each_with_index.map\
    \ {|n, i| [n, i]}`\n<|/ c |>\n<| a tags=ruby,arrays,algorithm dscore=0 |>\n<code>",
  '  nums.sort!', "  nums.sort do |a, b|\n    sumA = a.to_s.split(//).sum.to_i\n \
    \   sumB = b.to_s.split(//).sum.to_i\n    if sumA == sumB\n      a.to_i <=> b.to_i\n\
    \    else\n      sumA <=> sumB\n    end\n  end\nend\n</code>\nThe solution with\
    \ sort_by is definitely better because it avoids doing the sum in Ruby.\n<|/ a\
    \ dscore=2 |>\n<| c |>\n`sort_by` is definitely better (because you don't need\
    \ to convert the strings to arrays and `sum` is O(n)), but it still doesn't solve\
    \ the problem, because `sum` is unordered.\n<|/ c |>\n<| c |>\n: That's not correct,\
    \ `sort_by` will always put the `-1` before the `1`.\n<|/ c |>\n<| c |>\n: Right,\
    \ it is not obvious that `sort_by` is always better. Also, `sum` isn't O(n). It's\
    \ O(1).\n<|/ c |>\n<| c |>\n: Yeah, I wasn't really thinking about performance\
    \ here. But `sort_by` always sorts one item after another. That's O(n) anyway.\n\
    <|/ c |>\n<| c |>\n: Yes, `sort_by` is O(n) but `sum` is O(n). Think about it:\
    \ `sort` is O(n log n) and `sum` is O(n). So if you use `sort_by` instead of `sort`,\
    \ you are making your algorithm O(n). That is why the solution with `sum` is better.\n\
    <|/ c |>\n<| a |>\nIf it is not a homework, and you want to solve it with Python,\
    \ then this answer will be a possible solution for you.\nThe idea is to create\
    \ a dictionary of digits of the number, and then sort them by the keys of the\
    \ dictionary. This will give you a correct sorted list.\n<code>", "  nums.sort.with_index\
    \ { |i, val| nums[i] <=> nums[val] }\nend", "  nums.sort!{ |a,b| a.to_i + b.to_i\
    \ }\nend\n</cell>\n<cell>", "  # Write your code here\n  nums_sorted = nums.sort_by{|n|\
    \ n.to_s.split(\"\").map(&:to_i).inject(:+)}\n  nums_sorted.each do |n|\n    if\
    \ n < nums.last\n      nums.last.next!(n)\n    else\n      nums.push n\n    end\n\
    \  end\nend\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| a tags=ruby dscore=0 |>\n\
    <code>", "  nums.sort!\n  nums.group_by {|n| n.to_s.length}.\n  reduce([]) {|res,\
    \ el| el.length == 1 ? [el] : res.unshift(el)}.\n  sort_by {|el| el.length}.\n\
    \  map(&:first)\nend", "    sorted_nums = []\n    digits = nums.map(&:to_s).sort\n\
    \    sums = digits.each_with_object({}) { |d, memo| memo[d] = 0 }\n    nums.each\
    \ { |n| sums[n.to_s] += n.to_s.length }\n    nums.each_with_index { |n, i| sorted_nums[i]\
    \ = n if sums[n.to_s] <= sums[nums[i - 1].to_s] }\n    return sorted_nums\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\nI like the solution, however I don't think\
    \ it's possible to do it without looping through each element at least once.\n\
    <|/ c |>\n<| c |>\n: Indeed, I'm afraid so.\n<|/ c |>\n<| a tags=ruby dscore=1\
    \ |>\nHere's a solution using reduce and each_cons:\n<code>", "    \n    # Write\
    \ your code here.\n    \n    digits = []\n    sum = 0\n    sorted_nums = []\n\
    \    sorted_index = []\n    for num in nums:\n        digit = num % 10\n     \
    \   sum += digit\n        digits.append(digit)\n    \n    sorted_index = sorted(range(len(nums)),\
    \ key=lambda i: nums[i])\n    for i in sorted_index:\n        sorted_nums.append(digits[i])\n\
    \    \n    return sorted_nums", "  return nums.sort{ |a, b| (a.to_i.to_s + b.to_i.to_s).to_i\
    \ < =>(a.to_i + b.to_i) } if nums.present?\n  []\nend", "  nums.sort! do |n1,\
    \ n2|\n    if n1==0\n      if n2==0\n        n2\n      else\n        n1\n    \
    \  end\n    elsif n2==0\n      n1\n    else\n      ((n1 + n2) + n1).abs\n    end\n\
    \  end\nend", "  nums = nums.to_a\n  if nums.empty?\n    return []\n  end\n  nums\
    \ = nums.reverse\n  nums.sort!\n  nums = nums.reverse\n  return nums\nend", " \
    \ nums.sort.each_with_index do |n,i|\n    break i if n.to_s.chars.map(&:to_i).sum\
    \ == n.to_s.chars.map(&:to_i).min\n  end\nend\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| c |>\nWhy convert `to_i` multiple times in the same line? I bet `to_i`\
    \ is more expensive than `to_s`.\n<|/ c |>\n<| c |>\nWhy sort two times? `nums.sort\
    \ { |a, b| a.to_s.chars.map(&:to_i).min <=> b.to_s.chars.map(&:to_i).min }`.\n\
    <|/ c |>\n<| c |>\nThanks, I just found it by benchmarking, I guess it's better\
    \ to convert `to_s` only once.\n<|/ c |>\n<| c |>\nThe `sort` method is slow when\
    \ compared to a simple loop. My implementation is about 2x faster.\n<|/ c |>\n\
    <| c |>\n: I wonder how you're measuring the time it takes to sort two arrays\
    \ of size 10K and 50K. I'm getting `real    0m0.048s`, `user    0m0.040s`, `sys\
    \     0m0.008s` for an array of size 10K and a size of 50K. I think the difference\
    \ is because you're using benchmarking tool which is not deterministic (the order\
    \ is different).\n<|/ c |>\n<| a dscore=5 |>\nHere are three different sorting\
    \ algorithms for Ruby which can be applied on arrays of any size.", "  nums.sort!\
    \ {|a, b| b <=> a}\nend", "  nums = nums.dup\n  nums.sort! do |a, b|\n    sum1\
    \ = sum2 = b - a\n    while sum2.zero? do\n      a += a\n      a -= 1\n      sum2\
    \ += b\n      sum2 -= 1\n    end\n    while sum1.zero? do\n      b += b\n    \
    \  b -= 1\n      sum1 += a\n      sum1 -= 1\n    end\n    a - b\n  end\n  nums\n\
    end\n</pre>\n</div>", "  nums.sort.tap do |sorted_nums|\n    sorted_nums.group_by\
    \ do |num|\n      nums.map(&:to_i).reduce(0) { |sum, e| sum + e }\n    end.sort_by\
    \ { |k, v| v }.map(&:first)\n  end\nend", "    return nil unless nums.is_a?(Array)\n\
    \    nums.sort.each do |n|\n        n.to_s.split(//).each_with_index do |s, i|\n\
    \            digit = s.to_i + (i % 10)\n            n.send(:\"<=>\", digit).tap\
    \ do |order|\n                next if n == -1\n                next unless order\n\
    \                nums[order] = -1\n            end\n        end\n    end\n   \
    \ nums\nend\n</code>\nAnd this is how you can test it out:\n<code>\nassert(order_by_points.call([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points.call([])\
    \ == [])\n</code>\nHope this helps you\n<|/ a dscore=0 |>\n<| a tags=sorting,algorithm,ruby,math\
    \ |>\nThis is not the fastest solution, but is easy to understand:\n<code>", " \
    \ return nums.sort.map { |n| [n.abs, n] }.sort_by{|_, v| v[0]}\nend", "  sorted\
    \ = nums.sort do |a, b|\n    nums_sum = [a,b].inject(:+).abs\n    a.zero? ? b\
    \ : a.succ if nums_sum < b\n    b.zero? ? a : b.succ if nums_sum < a\n    nums_sum\n\
    \  end\n  sorted\nend", "  n = nums.size\n  num_sums = Array.new(n) {0}\n  (0...n).each\
    \ do |i|\n    num = nums[i]\n    num_sums[i] = num.to_s.chars.map(&:to_i).inject(0,\
    \ :+)\n  end\n  num_sums.sort!\n  num_sums.each_with_index {|num_sum, index| nums.insert(index,\
    \ num_sum)}\nend", "  # Your code here\n  if nums.length == 0\n    return []\n\
    \  \n  digits.each_with_index do |d, i|\n    d.zero? ? nums.delete_at(i) : nums.insert(i,\
    \ 0)\n  end\n  \n  nums.sort\nend", "  return [] if nums.empty? || nums.size ==\
    \ 0 \n  nums.sort{|a,b| sort_sum_of_digits(a) <=> sort_sum_of_digits(b)}\nend\n\
    </cell>\n<cell>", "  if nums.length == 0\n    return []\n  sums = nums.map(&:to_s).inject([0,\
    \ '']) do |(sum, digits), n|\n    (digits.empty? ? sum : sum + digits.length).to_s\
    \ << n\n  end\n  sums.sort.map { |s| nums[sums.index(s)] }\nend", "  nums.sort!\n\
    \  result = []\n  while nums.length > 0\n    num = nums.shift\n    result = [num,\
    \ *result]\n  end\n  result\nend", "  nums.sort! {|x,y| x + y == 0 ? 0 : (x +\
    \ y).abs} if nums.any?\nend", "  # Your code here\nend\n</cell>\n<cell>", "  #\
    \ Use helper method to create map of digits sum\n  digits_sums = digits_sums(nums)\n\
    \  # Return sorted array according to map\n  sorted_nums = sort_by_key(digits_sums,\
    \ :desc)\n  return sorted_nums\nend", "  sorted = nums.dup\n  sorted.sort!\n \
    \ sorted.reverse!\n  return sorted\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
