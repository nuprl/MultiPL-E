name: HumanEval_39_prime_fib
language: rb
prompt: "# prime_fib returns n-th number that is a Fibonacci number and it's also\
  \ prime.\n# >>> prime_fib.call(1)\n# 2\n# >>> prime_fib.call(2)\n# 3\n# >>> prime_fib.call(3)\n\
  # 5\n# >>> prime_fib.call(4)\n# 13\n# >>> prime_fib.call(5)\n# 89\ndef prime_fib(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prime_fib\n\
  \    candidate = method(:prime_fib)\n    assert_equal(2, candidate.call(1))\n  \
  \  assert_equal(3, candidate.call(2))\n    assert_equal(5, candidate.call(3))\n\
  \    assert_equal(13, candidate.call(4))\n    assert_equal(89, candidate.call(5))\n\
  \    assert_equal(233, candidate.call(6))\n    assert_equal(1597, candidate.call(7))\n\
  \    assert_equal(28657, candidate.call(8))\n    assert_equal(514229, candidate.call(9))\n\
  \    assert_equal(433494437, candidate.call(10))\n  end\nend\n"
completions: ["  if n < 0 then return nil\n  i = 2\n  prime_fib2 = prime_fib.call(i)\n\
    \  while prime_fib2 == nil and i < n do\n    prime_fib2 = prime_fib.call(i)\n\
    \    i = i + 1\n  end\n  if prime_fib2 == nil and i == n then return i\n  return\
    \ prime_fib2\nend\n</cell>\n<cell>", "  n.upcase!\n  fib = Fibn.new(2) # 2 is\
    \ the initial Fibonacci number for our purpose\n  n.times do |i|\n    fib = (fib.next\
    \ + fib.next.next) % Fibn.new(Fibn.new(fib).next.next)\n  end\n  fib\nend\n</code>\n\
    <|/ a tags=ruby dscore=2 |>\n<| c |>\nWon't this generate an infinite loop?\n\
    <|/ c |>\n<| c |>\nThanks, I fixed that.\n<|/ c |>\n<| c |>\nThis solution is\
    \ still O(Fibn.new(Fibn.new(fib).next.next)), isn't it?  It would be better to\
    \ compute it just once, though.\n<|/ c |>\n<| c |>\nYes, this is still O(Fibn.new(Fibn.new(fib).next.next)).\
    \  It's not particularly fast, but it's probably faster than the code I had in\
    \ mind anyway.  I thought I remembered someone posting something to do it, and\
    \ it was a while back.  I guess I got confused by the fact that the Fibonacci\
    \ numbers grow exponentially, so I was thinking it could get very slow once you\
    \ got past the 10th Fibonacci number.\n<|/ c |>\n<| c |>\nIf you have access to\
    \ a C compiler, you can do an O(1) version of this in about 20 lines of code,\
    \ but it's probably not worth the effort.  You could also do it in about 8 lines\
    \ of Ruby, but it's probably harder than writing it in C.\n<|/ c |>\n<| a tags=ruby\
    \ dscore=1 |>\nHere's my solution. Not particularly efficient, but it doesn't\
    \ require a C compiler.\n<code>", "  if n < 2\n    0\n  elsif n < 4\n    1\n \
    \ else\n    fib = prime_fib.call(n - 1) + prime_fib.call(n - 2)\n    prime_fib.call(n)\n\
    \  end\nend", "  fib = Array.new(n)\n  fib[0] = 0\n  fib[1] = 1\n  n.times { fib[i]\
    \ = fib[i-1] + fib[i-2] }\n  n = fib[n.to_i - 1]\n  i = 1\n  while i * i <= n\n\
    \    if n % i == 0\n      return 0\n    i += 1\n  return n\nend\n</code>\n<|/\
    \ a dscore=3 |>\n<| c |>\nI appreciate this solution, however it would be better\
    \ to just use a conditional instead of a while loop to exit the loop in the event\
    \ of an improbable value.\n<|/ c |>\n<| c |>\n- I think you misunderstood my comment.\
    \ :) He didn't mean that you should `break` out of the loop - he meant that the\
    \ loop should terminate when the number is a prime. As soon as it finds a number\
    \ that isn't a prime, `break` out of the loop, and return `0`.\n<|/ c |>\n<| c\
    \ |>\nHa, I see where I misunderstood, thanks for the correction. I was thinking\
    \ that you were talking about exiting the loop if the number was a prime but your\
    \ solution will exit it anyway, no?\n<|/ c |>\n<| c |>\n- I wasn't thinking of\
    \ your solution. I was talking about my solution, which does _not_ `break` out\
    \ of the loop. It simply returns `0` once it finds the number that's not a prime.\
    \ See my updated answer.\n<|/ c |>\n<| c |>\nYes, my solution is pretty much the\
    \ same as yours. I just was saying that your solution is much more elegant and\
    \ clean.\n<|/ c |>\n<| a dscore=3 |>\nThis is my solution:\n<code>", "  return\
    \ 2 if n <= 1 else 1 if n <= 3 else prime_fib.call(n - 2) + prime_fib.call(n -\
    \ 1)\nend\n</cell>\n<code language=julia-0.3>\nprime_fib.call(0)\n</cell>\n<code\
    \ language=julia-0.3>\nprime_fib.call(8)\n</cell>\n<code language=julia-0.3>\n\
    prime_fib.call(9)\n</cell>\n<code language=julia-0.3>\nprime_fib.call(10)\n</cell>\n\
    <code language=julia-0.3>\nprime_fib.call(11)\n</cell>\n<code language=julia-0.3>\n\
    prime_fib.call(12)\n</cell>\n<code language=julia-0.3>\nprime_fib.call(13)\n</cell>\n\
    <code language=julia-0.3>\nprime_fib.call(14)\n</cell>\n<text>\nTo solve Project\
    \ Euler #52, it's good to know when to stop. Let's solve it by finding the maximum\
    \ fibonacci number less than 20,000 (i.e., find the maximum fibonacci number less\
    \ than 100,000):", "  sum = 0\n  prime = 1\n  i = 2\n  until prime > n\n    sum\
    \ += i\n    i += 1\n    prime += 2\n  end\n  return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    prime_fib.call(0)\n</cell>\n<code language=julia-1.5>\nprime_fib.call(20)\n</cell>\n\
    <code language=julia-1.5>\nprime_fib.call(100)\n</cell>\n<code language=julia-1.5>\n\
    prime_fib.call(500)\n</cell>\n<code language=julia-1.5>\nprime_fib.call(1000)\n\
    </cell>\n<code language=julia-1.5>\nprime_fib.call(10000)\n</cell>\n<text>\nJulia's\
    \ native support for BigIntegers\nJulia's native support for BigInteger is available\
    \ with the Fraction type in the Frac module.  It has two methods: num and den\
    \ for conversion to/from integers.  These two methods are also available for floating-point\
    \ numbers in the Frac module as num and den.  Both methods can be used to perform\
    \ operations that are valid for arbitrarily large integers.  As an example, let's\
    \ see what happens when we add two BigIntegers.", "  n\n  if n == 1\n    1\n \
    \ elsif n == 2\n    2\n  else\n    (fib(n-1) + fib(n-2))\n  end\nend", "  prime_fib.call(0)\n\
    \  fib = 2\n  while true\n    if fib > n\n      return fib\n    fib = fib + fib\n\
    \  end\nend", "  return n if n <= 1 else prime_fib.call(n-2) + prime_fib.call(n-1)\n\
    end\n</cell>\n<code language=julia-0.6>\n@time prime_fib.call(10);\n</cell>\n\
    <text>\nThe Fibonacci numbers grow very rapidly in general. Let's see what happens\
    \ when we exceed the recursion limit.", "  if n <= 1 then return n\n  return prime_fib.call(n-1)\
    \ + prime_fib.call(n-2)\nend\n</cell>\n<cell>\nprime_fib.call(1)\nprime_fib.call(2)\n\
    prime_fib.call(3)\nprime_fib.call(4)\nprime_fib.call(5)\n</cell>\n<text>\nSort\
    \ Lists\nThe sort function in Julia takes two arguments: an input sequence and\
    \ an output sequence. These two arguments can both be collections (arrays, matrices,\
    \ dictionaries, or lists). The sort function will return a sequence of the elements\
    \ of the input sequence ordered according to the order of the elements of the\
    \ output sequence. To see an example, let's sort a vector:", "  return n.even?\
    \ if n <= 2 \n  i = 1\n  prime_fib = (i.next)\n  while prime_fib.next < n\n  \
    \  i += 1\n    prime_fib = (i.next)\n  return prime_fib\nend", "  a, b = 0, 1\n\
    \  (n.call(n) if n.respond_to?(:call)\n    && n.call.empty?\n    && n >= 2 &&\
    \ n <= 5).each do |n|\n    a, b = b, a+b\n  end\n  b.to_i\nend\n</code>\nI tested\
    \ it using ruby 2.4.3 and 2.5.1\n<|/ a tags=ruby,ruby-on-rails,primes |>\n<| a\
    \ |>\nMy solution is very similar to your original solution, just with more Ruby\
    \ idioms. In general, Ruby methods return self for chainable methods and you don't\
    \ have to explicitly call a method on a given object. Instead, Ruby methods can\
    \ be chained by returning an object that encapsulates multiple methods. If you\
    \ want a method that returns the Fibonacci number that is a prime, that method\
    \ is prime and looks something like this:\n<code>", "  return n if n <= 2 else\
    \ prime_fib(n - 2) + prime_fib(n - 1)\nend\n</cell>\n<code language=julia-1.0>\n\
    @code_warntype prime_fib.call(4)\n</cell>\n<text>\nFibonacci numbers grows slowly\n\
    Let us compute $n = F^k$, where", "  if n < 3\n    prime = 3\n  elsif n <= 5\n\
    \    prime = 1\n  elsif n <= 13\n    prime = 2\n  else\n    prime = 3\n  end\n\
    \  return prime\nend", "  a, b = 0, 1\n  while b < n do\n    a, b = b, a + b\n\
    \  end\n  return a\nend", "    primes = [0, 2]\n    i = 3\n    while i <= n\n\
    \        if primes.include? i\n            primes << i \n        else \n     \
    \       primes << primes.last + primes.last + 1\n        end\n        i += 2\n\
    \    primes[-1] \nend\n</code>\n<|/ a tags=ruby-on-rails,ruby,fibonacci,ruby-on-rails-3\
    \ |>\n<| c |>\nThis looks very interesting. Can you explain the advantage of using\
    \ recursion for this approach?\n<|/ c |>\n<| a tags=ruby-on-rails,ruby,fibonacci,ruby-on-rails-3\
    \ dscore=3 |>\n<code>", "  a, b = 0, 1\n  while a < n\n    a, b = b, a + b\n \
    \ end\n  return b\nend", "  return is_prime?(n) ? n : prime_fib.call(n / 2) +\
    \ prime_fib.call(n / 3)\nend", "  if n < 2 then return 1\n  if n % 2 == 0 then\
    \ return prime_fib(n - 1) + prime_fib(n - 2)\n  else return prime_fib(n - 1) *\
    \ prime_fib(n - 2)\nend", "  if n < 2\n    next\n  else\n    prime_fib.call(n-2)\
    \ + prime_fib.call(n-2)\n  end\nend", "  if n == 0 then\n    return 1\n  else\
    \ if n == 1 then\n    return 2\n  else\n    return prime_fib.call(n - 1) + prime_fib.call(n\
    \ - 2)\n  end\nend", "  return fib(n) if n <= 1 else fib(n-1) + fib(n-2)\nend",
  "    if n < 2\n        2\n    elsif n == 2\n        3\n    elsif n % 2 == 0\n  \
    \      prime_fib.call(n - 1) + prime_fib.call(n - 2)\n    else\n        prime_fib.call(n\
    \ - 1) + prime_fib.call(n - 3)\n    end\nend", "  return Fib(n+1) + Fib(n-1)\n\
    end", "  primes = []\n  is_prime = true\n  (2...n).each { |n| primes << n if is_prime\
    \ == true }\n  primes.each_with_index do |x, i|\n    if is_prime == true\n   \
    \   primes << x\n      is_prime = false\n    else\n      is_prime = true\n   \
    \ end\n  end\n  primes\nend", "  if n <= 1\n    2\n  else\n    prime_fib.call(n-1)\
    \ + prime_fib.call(n-2)\n  end\nend", "  return 0 if (n == 0 || n == 1) || n ==\
    \ n\n  return prime_fib.call(n-1) + prime_fib.call(n-2)\nend\n</cell>\n<code language=julia-0.4>",
  "  if n == 0\n    1\n  elsif n == 1\n    2\n  else\n    prime_fib.call(n-1) + prime_fib.call(n-2)\n\
    \  end\nend", "    a,b = 0,1\n    loop do\n        a,b = b,a+b\n        n == a\
    \ ? return n : a == b ? raise StopIteration : n\n    end\nend\n</cell>\n<text>\n\
    The fibonacci series is defined by the recurrence equation\n\\begin{equation}F{n}\
    \ = \\begin{cases} 1,&n=0 \\cr \\frac{F{n-1} + F_{n-2}}{2},&n=1 \\cr \\frac{F{n-1}\
    \ + F_{n-2} + F_{n-3}}{3},&n=2 \\cr \\cdots \\cr \\frac{F{n-1} + F_{n-2} + F_{n-3}\
    \ + F_{n-4}}{4} \\cr F_{n-2} + F_{n-3},&n=3 \\cr F_{n-3} + F_{n-4},&n=4\\end{cases}\n\
    \\end{equation}\nwhere $F_0=F_1=F_2=F_3=F_4=1$. An efficient algorithm for this\
    \ recurrence equation, as discussed on Wikipedia, is called linear recurrence\
    \ relation (LRT).", "  n = n.to_i\n  if n <= 1\n    n\n  else\n    prime_fib.call(n-1)\
    \ + prime_fib.call(n-2)\n  end\nend", "  if n.zero?\n    return 0\n  elsif n.is_a?(Integer)\n\
    \    return prime_fib(n - 1) + prime_fib(n - 2)\n  elsif n.is_a?(Numeric)\n  \
    \  prime_fib.send(n)\n  else\n    super\n  end\nend", "  if n < 2 then return\
    \ 1\n  if n == 2 then return 2\n  return prime_fib.call(n - 2) + prime_fib.call(n\
    \ - 1)\nend", "  return n.prime? ? n : (n % 2 ==0 ? n : prime_fib(n - 1) + prime_fib(n\
    \ - 2))\nend\n</cell>\n<code language=julia-1.3>\nprime_fib(10)\n</cell>\n<text>\n\
    Exercise: Fibonacci number using memoization", "  return n if n.even? || (n.odd?\
    \ && prime_fib(n.next).even?) || (n.odd? && !prime_fib(n.next).even?) else None\n\
    end\n</cell>\n<code language=julia-0.4>\nprime_fib.call(2)\n</cell>\n<code language=julia-0.4>\n\
    prime_fib.call(3)\n</cell>\n<code language=julia-0.4>\nprime_fib.call(4)\n</cell>\n\
    <code language=julia-0.4>\nprime_fib.call(5)\n</cell>\n<code language=julia-0.4>\n\
    prime_fib.call(6)\n</cell>\n<code language=julia-0.4>\nprime_fib.call(7)\n</cell>\n\
    <code language=julia-0.4>\nprime_fib.call(8)\n</cell>\n<code language=julia-0.4>\n\
    prime_fib.call(9)\n</cell>\n<code language=julia-0.4>\nprime_fib.call(10)\n</cell>\n\
    <text>\nFibonacci numbers", "  prime_fib.cache[yield(n)] = prime_fib.cache.fetch(n)\
    \ { fib_prime(n) }\nend", "  if n <= 2 then return n else prime_fib.call(n - 1)\
    \ + prime_fib.call(n - 2)\nend", "    if n == 1 then\n        return 1\n    else\
    \ if n == 2 then\n        return 2\n    else if n % 2 = 0 then\n        return\
    \ prime_fib(n - 1) + prime_fib(n - 2)\n    else\n        return prime_fib(n -\
    \ 3) + prime_fib(n - 2)\n    end\nend\n</cell>\n<cell>", "  if n <= 2\n    2\n\
    \  else\n    prime_fib.call(n-2) + prime_fib.call(n-1)\n  end\nend", "    a, b\
    \ = 0, 1\n    while b < n\n        a, b = b, a+b\n    end\n    return a\nend",
  "  return if n <= 0\n  return if n % 2 == 0\n  return if n % 3 == 0\n  prime_fib.call(n\
    \ / 2)\n  prime_fib.call(n / 3)", "  prime_fib_call_stack[n-1] = nil\n  prime_fib_call_stack[n-2]\
    \ = nil\n  fib = prime_fib_call_stack[n-1] + (prime_fib_call_stack[n-2] == nil\
    \ ? 1 : 2)\n  prime_fib_call_stack[n] = fib\n  prime_fib_call_stack.last[n] =\
    \ fib\n  prime_fib_call_stack.last.last[n] = fib\n  prime_fib_call_stack.last.last.last[n]\
    \ = fib\n  prime_fib_call_stack.last.last.last.last[n] = fib\n  prime_fib_call_stack.last.last.last.last.last[n]\
    \ = fib\n  prime_fib_call_stack.last.last.last.last.last.last[n] = fib\n  prime_fib_call_stack.last.last.last.last.last.last.last[n]\
    \ = fib\n  prime_fib_call_stack.last.last.last.last.last.last.last.last[n] = fib\n\
    \  prime_fib_call_stack.last.last.last.last.last.last.last.last.last[n] = fib\n\
    \  prime_fib_call_stack.last.last.last.last.last.last.last.last.last.last[n] =\
    \ fib\n  prime_fib_call_stack.last.last.last.last.last.last.last.last.last.last.last[n]\
    \ = fib\n  prime_fib_call_stack.last.last.last.last.last.last.last.last.last.last.last[n]\
    \ = fib\n  prime_fib_call_stack.last.last.last.last.last.last.last.last.last.last.last.last[n]\
    \ = fib\n  prime_fib_call_stack.last.last.last.last.last.last.last.last.last.last.last.last.last[n]\
    \ = fib\n  prime_fib_call_stack.last.last.last.last.last.last.last.last.last.last.last.last.last[n]\
    \ = fib\n  prime_fib_call_stack.last.last.last.last.last.last.last.last.last.last.last.last.last.last[n]\
    \ = fib\n  prime_fib_call_stack.last.last.last.last.last.last.last.last.last.last.last.last.last.",
  "  if n == 0\n    0\n  else\n    prime_fib.call(n-1) + prime_fib.call(n-2)\nend",
  "    prime_factor = 1\n    fib = 0\n    while prime factor < n and fib < n do\n\
    \        fib = fib + prime_factor\n        prime_factor = prime_factor + 1\n \
    \   end\n    return fib\nend", "  a = b = nil\n  if n <= 1\n    1\n  else\n  \
    \  while n > 0\n      a,b = b,a+b\n      n -= 1\n    end\n  end\n  a\nend", " \
    \ # Check if n is a Fibonacci number.\n  if n <= 2:\n    return 2\n  # Check if\
    \ n is prime.\n  if prime_check(n) == False:\n    return n", "    if n <= 2\n\
    \        2\n    elsif n % 2\n        n\n    elsif prime_fib.call(n-1) == prime_fib.call(n-2)\n\
    \        n\n    else\n        prime_fib.call(n-1) + prime_fib.call(n-2)\n    end\n\
    end", "  return n if n < 3 else prime_fib(n - 2) + prime_fib(n - 1) if n % 2 ==\
    \ 0 else prime_fib(n - 3)\nend", "  return prime_fib(n-1).call(n-2) if n.odd?\
    \ and n.even? and n > 1 \n  2\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=1\
    \ |>\nI think you can just write it like:\n<code>", "  prime_fib.primes[n] = prime_fib.primes[n]\
    \ || {fib_n: 0, prime_n: 1}\n  prime_fib.primes[n].prime_n += 1\n  return prime_fib.primes[n].fib_n\n\
    end\nprime_fib.primes = {\n  1: { fib_n: 1, prime_n: 1 },\n  2: { fib_n: 2, prime_n:\
    \ 1 },\n  3: { fib_n: 1, prime_n: 2 },\n  5: { fib_n: 3, prime_n: 3 },\n  8: {\
    \ fib_n: 2, prime_n: 5 },\n  13: { fib_n: 7, prime_n: 8 },\n  21: { fib_n: 7,\
    \ prime_n: 13 },\n  34: { fib_n: 3, prime_n: 21 },\n  55: { fib_n: 5, prime_n:\
    \ 34 },\n  89: { fib_n: 8, prime_n: 55 }\n}\nprime_fib.default = { fib_n: 1, prime_n:\
    \ 1 }\nprime_fib.__index = prime_fib", '    return prime_fib.call(n, 2)', "  return\
    \ PrimeFib(n).call()\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI really liked\
    \ your implementation of prime_fib. Thanks for the contribution!\n<|/ c |>\n<|\
    \ a |>\nHere is a simple implementation that works well enough in practice:\n\
    <code>", "  return nil if n <= 2\n  return 1 if n == 2\n  return prime_fib.call(n\
    \ - 1) + prime_fib.call(n - 2) if prime_fib.call(n - 2) < n\nend", "  prime_numbers\
    \ = []\n  prime_numbers.push(n)\n  if n == 0 then\n    prime_numbers.push(prime_numbers[2])\n\
    \    return prime_numbers[2]\n  else if n == 2 then\n    prime_numbers.push(prime_numbers[1])\n\
    \    return prime_numbers[1]\n  else\n    prime_numbers.push(n-1)\n    prime_numbers.push(n-2)\n\
    \    prime_numbers.push(prime_numbers[3])\n    return prime_numbers[3]\n  end\n\
    end", "  # redefining 'n' as global variable, otherwise it wouldn't change in\
    \ 'call' function.\n  global n\n  if n < 2\n    n = 1\n  else\n    call(n-1)\n\
    \  end\n  call(n-1)\nend", "  if n == 0\n    return 2\n  elsif n == 1\n    return\
    \ 3\n  elsif n <= 2\n    return 2\n  end\n  \n  return prime_fib(n - 1) + prime_fib(n\
    \ - 2)\nend", "  return n if n < 2 else prime_fib(n - 1) + prime_fib(n - 2)\n\
    end", "  prime =[2,3]\n  sum = 1\n  for i in (2..n-1)\n    sum+=prime[i-1]\n \
    \   prime << sum\n  end\n  prime[n]\nend", "  # initialize with n-th Fibonacci\
    \ number\n  if n == 0\n    1, 0\n  elsif n == 1\n    0, 1\n  elsif n % 2 == 0\n\
    \    prime_fib(n - 1) + prime_fib(n - 2)\n  else\n    prime_fib(n - 1) + prime_fib(n\
    \ - 3)\n  end\nend\n</cell>\n<code language=julia-1.5>", "  prime_fibs = []\n\
    \  a, b = 0, 1\n  while a < n\n    prime_fibs << a\n    a, b = b, a + b\n  end\n\
    \  prime_fibs << n\n  prime_fib_with_n = prime_fib.new(prime_fibs)\n  prime_fib_with_n\n\
    end", "  if n < 2 then\n    n\n  else\n    if n < 3 then\n      n\n    else\n\
    \      prime_fib.call(n - 1) + prime_fib.call(n - 2)\n    end\n  end\nend\n</code>\n\
    The above function can compute n-th Fibonacci number using recursion. \n<code>",
  "\tif n<3 || n%2==0\n\t\treturn n\n\telse\n\t\treturn prime_fib.call(n-1) + prime_fib.call(n-2)\n\
    end", "  return 0 if n < 2 then return 2 else prime_fib.call(n / 2) + prime_fib.call(n\
    \ / 2)\nend\n</cell>\n<cell>", "  if n <= 2\n    1\n  else\n    prime_fib.call(n-1)\
    \ + prime_fib.call(n-2)\n  end\nend", "  return 1 if n < 2 else prime_fib(n -\
    \ 1) + prime_fib(n - 2)\nend\n</cell>\n<code language=julia-0.6>\nprime_fib.call(1)\n\
    </cell>\n<text>\nThe prime number theorem states that a positive integer $n$ can\
    \ be expressed as the sum of two prime integers as $n + \\textrm{prime}$, where\
    \ $\\textrm{prime}$ is called the smallest prime number.", "  return prime_fib.call(n,\
    \ false)\nend", "  return fibonacci(n).find { |x| x % n != 0 }\nend", "  if n\
    \ < 2 then return 1\n  else return prime_fib(n - 2) + prime_fib(n - 1)\nend\n\
    puts prime_fib(10)", '  return n < 1 ? n : prime_fib.call(n-1) + prime_fib.call(n-2)
    if prime_fib.call(n) < n else n', "  if n == 0\n    prime = 0\n  elsif n == 1\n\
    \    prime = 1\n  else\n    prime = prime_fib(n - 1) + prime_fib(n - 2)\n  end\n\
    \  return prime\nend", "  return fib(n) if n <= 1 || (n > 1 and prime_fib(n -\
    \ 1))\nend", "  n==0 ? 1 : fib(n-1) + fib(n-2)\nend\n</code>\nNow we can get to\
    \ our actual question:\n<code>", "  if n == 2\n    return 2\n  else if n == 0\n\
    \    return 1\n  else\n    if n % 2 == 1\n      return prime_fib(n - 1) ** 2\n\
    \    else\n      return prime_fib(n - 1) + (prime_fib(n - 2) ** 2)", "  primes\
    \ = [2,3]\n  for i in 1..n\n    prime_found =  primes.any? {|p| p > i}\n    if\
    \ prime_found\n      primes << primes.last\n    else\n      primes << i\n    end\n\
    \  end\n  primes.last\nend", "  if n < 2\n    return n\n  return prime_fib(n -\
    \ 1) + prime_fib(n - 2)\nend", "  FibUtils.prime_fib(n)\nend", "  if n == 0\n\
    \    Fib\n  else\n    prime_fib.call(n-1) + prime_fib.call(n-2)\n  end\nend",
  "  return n > 1 ? prime_fib.call(n - 1) + prime_fib.call(n - 2) : n\nend", "  a\
    \ = 0\n  b = 1\n  while true\n    break if a > n\n    next_b = a + b\n    a +=\
    \ b\n    b = next_b\n    break if b > n\n  end\n  return b\nend", "  a,b = 0,\
    \ 1\n  while a < n\n    a,b = b, a+b\n  end\n  return a\nend", "    if n <= 2\
    \ then\n        return n\n    else\n        return prime_fib.call(n-2) + prime_fib.call(n-1)\n\
    \    end\nend", "  prime ||= begin\n    memo = {}\n    prime_fib.call(1)\n   \
    \ prime_fib.call(2)\n    prime_fib.call(3)\n    prime_fib.call(4)\n    prime_fib.call(5)\n\
    \    memo\n  end\n  if n >= memo[n] then\n    memo[n]\n  else\n    prime ||= begin\n\
    \      prime_fib.call(n-1)\n      memo[n] = prime_fib.call(n-2) + prime_fib.call(n-3)\n\
    \    end\n  end\nend", "  if n < 2\n    n\n  else\n    if n == 2\n      2\n  \
    \  elsif n == 3\n      3\n    elsif n % 2 == 0\n      n = n-1\n      prime_fib.call(n-1)\
    \ + prime_fib.call(n-2)\n    else\n      prime_fib.call(n-1) + prime_fib.call(n-2)\n\
    \    end\n  end\nend", "  return n if n < 2 else prime_fib.call(n-1) + prime_fib.call(n-2)\n\
    end\n</cell>\n<cell>", "  f1, f2 = 0, 1\n  fib_list = [f1, f2]\n  prime_list =\
    \ []\n  while n != f2\n    n -= f1\n    prime_list.append(f1)\n    prime_list.append(f2)\n\
    \    f1, f2 = f2, (f1 + f2)%n\n    fib_list << f1\n  end\n  prime_list << f2\n\
    \  fib_list.unshift(f2)\n  return prime_list\nend", "    i = 2\n    while i <\
    \ n\n        if sieve.include?(i)\n            return i\n        i += 1\n    end\n\
    \    return n\nend", "  a = b = 2\n  while a < n\n    puts a\n    a, b = b, a\
    \ + b\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nYou know that `a`, `b`,\
    \ and `c` only exist as local variables, and that your `prime_fibonacci` method\
    \ will not return anything (it doesn't have a `return` statement). But otherwise,\
    \ good job :-)\n<|/ c |>\n<| c |>\nI knew that return was there in code but I\
    \ forgot to remove it. Thanks for pointing out. :)\n<|/ c |>\n<| c |>\nI see what\
    \ you're saying, but I think `a` and `b` will exist for the lifetime of the function,\
    \ otherwise how would you ever get past the while loop?\n<|/ c |>\n<| c |>\nyes,\
    \ that's what I wanted to say... but you got it wrong.\n<|/ c |>\n<| c |>\nAh,\
    \ okay... yep I didn't see the `return` statement before. You're right\n<|/ c\
    \ |>\n<| a dscore=4 |>\nThis should do the trick:\n<code>", "    if n < 3\n  \
    \      return n\n    else\n        return prime_fib.call(n-2) + prime_fib.call(n-1)\n\
    end", "  return (n==0 or n==1 or n % 2 == 0 or n % 3 == 0) &&\n    (!(n > 1) &&\
    \ ((prime_fib(n-1) + prime_fib(n-2))%n==0))\nend", '    return fib(n) if n <=
    2 else prime_fib(n - 1) + prime_fib(n - 2)', "    if n == 0 then\n        return\
    \ 1\n    elif n == 1 then\n        return 1\n    else\n        return prime_fib(n\
    \ - 1) + prime_fib(n - 2)\n    end\nend", "  if n == 1\n    2\n  else\n    prime_fib.call(n\
    \ - 2) + prime_fib.call(n - 1)\nend\n</cell>\n<cell>", "  prime_fib_cache[n] ||=\
    \ prime_fib_cache[n-1] + prime_fib_cache[n-2]\nend", "  f = [1,1]\n  f.each do\
    \ |i|\n    f.insert(i-1, f[i-1] + f[i-2])\n  end\n  f[n]\nend\n</code></pre>\n\
    <h3 id=\"ruby-range-functions\">Ruby Range</h3>\n<pre><code class=\"language-ruby\"\
    ># range(a,b) returns an array with elements of a to b", "  a, b = 0, 1\n  while\
    \ true\n    return a if n == b || n % b == a\n    a, b = b, a + b\n  end\nend",
  "  if n < 2\n    return 0\n  elsif n == 0\n    return 1\n  elsif n == 1\n    return\
    \ 2\n  end\n  call = prime_fib.call\n  if call != nil\n    return call\n  end\n\
    \  result = call\n  i = 2\n  while i < n\n    result = result + call(i)\n    i\
    \ += 1\n  end\n  return result\nend", "  a = b = 2\n  while (b < a) or (a == 0\
    \ and b == 1) do\n    (a, b) = (b, a + b)\n  end\n  return b\nend", "    primes\
    \ = Enumerator.new do |y|\n        if n <= 1 then\n            y.yield n\n   \
    \     else\n            y.yield prime_fib.call(n-1) + prime_fib.call(n-2)\n  \
    \      end\n    end\n    primes.next\nend", "  return 1 if n < 2 else prime_fib.call(n-1)\
    \ + prime_fib.call(n-2)\nend", "  if n < 2\n    n\n  else\n    prime_fib.call(n\
    \ - 1) + prime_fib.call(n - 2)\n  end\nend", "    a,b=0,1\n    while n>1:\n  \
    \      a,b = b,a+b\n        n-=1\n    return b\n</code>\nWe can now write our\
    \ code using prime fib as follows:\n<code>", "  if n == 0 or n == 1\n    prime_fib.call(1)\n\
    \  elsif n == 2\n    prime_fib.call(2)\n  elsif n % 2 == 0\n    prime_fib.call(prime_fib.call(n\
    \ % 2 + 1) * 3)\n  else\n    prime_fib.call(prime_fib.call(n % 2 + 1) * 5) + prime_fib.call(n\
    \ % 2 + 1)\n  end\nend", "  return 1 if n < 2 then 2 else prime_fib.call(n-1)\
    \ + prime_fib.call(n-2)\nend", "  if n < 2\n    1\n  else\n    prime_fib.call(n-1)\
    \ + prime_fib.call(n-2)\n  end\nend\n</cell>\n<code language=julia-1.0>\nprime_fib.call(10)\n\
    </cell>\n<code language=julia-1.0>\nfunction prime_fibonacci(n)\n  if n < 2\n\
    \    1\n  else\n    prime_fibonacci(n-1) + prime_fibonacci(n-2)\n  end\nend\n\
    </cell>\n<code language=julia-1.0>\nprime_fibonacci(10)\n</cell>\n<code language=julia-1.0>\n\
    function prime_fibonacci(n)\n  if n < 2\n    1\n  else\n    prime_fibonacci(n-1)\
    \ + prime_fibonacci(n-2)\n  end\nend\n</cell>\n<code language=julia-1.0>\nprime_fibonacci(10)\n\
    </cell>\n<code language=julia-1.0>\nfunction prime_fibonacci(n)\n  if n < 2\n\
    \    1\n  else\n    prime_fibonacci(n-1) + prime_fibonacci(n-2)\n  end\nend\n\
    </cell>\n<code language=julia-1.0>\nprime_fibonacci(10)\n</cell>\n<code language=julia-1.0>",
  "  return fib(n) if n > 1 && (prime?(n) || fib(n-1) == 0)\nend", "  if n < 2 then\
    \ return n\n  return prime_fib.call(n - 1) + prime_fib.call(n - 2)\nend\n</cell>\n\
    <cell>\n@inline def fib(n)\n  if n < 2 then return n\n  return fib.call(n - 1)\
    \ + fib.call(n - 2)\nend\n</cell>\n<cell>\n@inline def prime_fib(n)\n  return\
    \ @show(isprime(fib(n))) \nend\n</cell>\n<text>\nFibonacci", "    prime_number\
    \ = 2\n    previous_prime_number = 1\n    while prime_number < n:\n        if\
    \ n % prime_number == 0:\n            prime_number = previous_prime_number\n \
    \       else:\n            previous_prime_number = prime_number\n            prime_number\
    \ += 1\n    return prime_number", "  return n if n < 2 else prime_fib.call(n-1)\
    \ + prime_fib.call(n-2)\nend", "    if n == 0 or n == 2\n        return n\n  \
    \  return prime_fib.call(n-1) + prime_fib.call(n-2)", "  return 1 if n <= 2 else\
    \ prime_fib.call(n - 1) + prime_fib.call(n - 2)\nend", "    return n>=0 and ((1<<(n-1))==(1<<n)\
    \ and prime_fib(int(log(n,2)/log(2))))\nend", "    if n < 2 then \n        return\
    \ n\n    elif n == 2 then \n        return 1\n    else\n        return fib(n-1)\
    \ + fib(n-2)\n    end\nend\nend\n</code>\n<|/ a tags=python-3.x,python dscore=1\
    \ |>\n<| c |>\nThanks so much for the code! This was exactly what I was looking\
    \ for! I was wondering if there was a way to make this work without the use of\
    \ globals? I am fairly new to python so I am sorry if this is a very basic question.\
    \ Also I was wondering why my code is not working? Thanks again!\n<|/ c |>\n<|\
    \ c |>\nOh okay, I got it now. Thanks again!\n<|/ c |>\n<| a tags=python-3.x,python\
    \ |>\nI think it is easiest to just add an argument to prime_fib so you can specify\
    \ which Fibonacci number to return. Then, you could call prime_fib with fibonacci_number\
    \ == 1 or fibonacci_number == 2 to get the correct fibonacci number.\n<code>",
  "  fib = Fib.get(n) # get Fib(n) from the map if exist\n  p # print the value if\
    \ exists\n  return fib if fib.nil? # if Fib(n) doesn't exist just return nil\n\
    \  return fib.call(n) if p # if Fib(n) exist and p value is 0 then print it\n\
    \  p # print p value\nend", "  if n < 2\n    next\n  else\n    prime_fib.call(n-1)\
    \ + prime_fib.call(n-2)\n  end\nend\n</cell>\n<cell>\n%matplotlib inline\nimport\
    \ matplotlib.pyplot as plt\n</cell>\n<cell>", "    primes_cache = {} # Cache to\
    \ avoid recomputing primes more than once.\n    # Sieve of Eratosthenes for large\
    \ n\n    if n < 2:\n        return 2 if n == 2 else 3\n    else:\n        i =\
    \ 3\n        while i <= n:\n            if primes_cache.has_key(i):\n        \
    \        primes_cache[i] += 1\n                if primes_cache[i] > 2:\n     \
    \               return i\n            i += 2\n    return n\n</cell>\n<cell>",
  "\tif n == 0\n\t\t1\n\telsif n == 1\n\t\t2\n\telse\n\t\tprime_fib.call(n - 1) +\
    \ prime_fib.call(n - 2)\n\tend\nend", "    if n == 0 or n == 1 then\n        return\
    \ 1\n    end\n    return prime_fib.call(n - 1) + prime_fib.call(n - 2)\nend",
  "  prime_fib_limit = n.prime?\n  if prime_fib_limit == nil || prime_fib_limit ==\
    \ false || prime_fib_limit < 0\n    raise ArgumentError.new(\"prime limit must\
    \ be positive\")\n  end\n  prime_fib_list = [ 2, 3 ]\n  prime_fib_list[0] ||=\
    \ 2\n  prime_fib_list[1] ||= 3\n  prime_fib_list.each do |n|\n    prime_fib_list[n]\
    \ = prime_fib_list[n].prime?\n    next if prime_fib_list[n] == false || prime_fib_list[n]\
    \ < 0\n  end unless prime_fib_list.any?\n  prime_fib_list.each do |n|\n    if\
    \ prime_fib_list[n] == true\n      prime_fib_list.delete_at(n)\n      prime_fib_list.delete_at(n-1)\n\
    \      prime_fib_list.delete_at(n+1)\n      break\n    end\n  end\n  prime_fib_list[n]\n\
    end", "  return n if n < 2 else prime_fib(n - 2) + prime_fib(n - 3)\nend", " \
    \ if n == 0 then\n    return 1\n  else\n    return prime_fib.call(n - 1) + prime_fib.call(n\
    \ - 2)\n  end\nend\n</cell>\n<cell>\n%matplotlib inline\n</cell>\n<cell>", " \
    \   if n == 0 then\n        return 0, 1\n    else if n == 1 then\n        return\
    \ 1, 1\n    else\n        x, y = prime_fib(n - 1), prime_fib(n - 2)\n        if\
    \ x % n == 0 then\n            return x, y + 1\n        else\n            return\
    \ x + y, y\n        end\n    end\nend\n</cell>\n<text>\nRecursion", "  if n <\
    \ 2 then return 2 else return prime_fib.call(n-2) + prime_fib.call(n-1)\nend",
  "    a,b=0,1\n    while n>0:\n        a,b=b,a+b\n        n-=1\n    return b\n</cell>\n\
    <cell>\nprime_fib.call(-1)\n</cell>\n<cell>", '    return fib(n) if (n <= 2) else
    prime_fib(n - 1) + prime_fib(n - 2)', "  if n < 2\n  then return n\n  else return\
    \ (prime_fib.call(n-1) + prime_fib.call(n-2))\nend", "  if n < 2\n    prime\n\
    \  else\n    prime_fib(n - 1) + prime_fib(n - 2)\nend\n</cell>\n<code language=julia-1.5>\n\
    prime_fib.call(10)\n</cell>\n<text>\nAnother way to implement this recursion is\
    \ using the iterative form of a while loop.", "  if n <= 2 \n    return n\n  else\
    \ \n    return prime_fib.call(n - 1) + prime_fib.call(n - 2)\nend", "  # first\
    \ check if n is even or odd.\n  return 0 if (n.zero? || (n%2==0))\n  # find sum\
    \ of first two numbers in Fibonacci series\n  sum_fib = 0\n  next_fib = 1\n  while\
    \ (n>0)\n    sum_fib = sum_fib + next_fib\n    next_fib = next_fib + next_fib\n\
    \    n = n - 2\n  end\n  return sum_fib\nend", "  if n < 2\n    n\n  else\n  \
    \  prime_fib.call(n-2) + prime_fib.call(n-1)\n  end\nend", "\tif n == 0\n\t\t\
    return 0\n\telse if n == 1\n\t\treturn 1\n\telse\n\t\treturn prime_fib.call(n-1)\
    \ + prime_fib.call(n-2)", "  return 1 if n<2 else prime_fib(n - 1) + prime_fib(n\
    \ - 2) if n >= 2 \nend", "    if n < 2\n        0\n    elsif n < 5\n        return\
    \ 1\n    else \n        return prime_fib.call(n-2) + prime_fib.call(n-3)\n   \
    \ end\nend\n</code>\nNow the most basic recursive function you can implement is\
    \ called fibonacci in Ruby that returns the nth Fibonacci number:\n<code>\nfibonacci\
    \ = Proc.new do |n|\n    if n < 2\n        n\n    elsif n < 5\n        1\n   \
    \ else \n        fibonacci.call(n - 2) + fibonacci.call(n - 3)\n    end\nend\n\
    </code>\nAnd here is a test:\n<code>\nfibonacci.call(7)", "  return ( n == 1)\
    \ ? 1 : ( n == 2) ? 1 : ( n % 2 == 0) ? prime_fib(n - 1) + prime_fib(n - 2) :\
    \ prime_fib(n - 3) + prime_fib(n - 2)\nend", "  if n == 0\n    prime_fib.call(0)\n\
    \  elsif n == 1\n    prime_fib.call(1)\n  elsif n == 2\n    prime_fib.call(2)\n\
    \  elsif n % 2 == 0\n    prime_fib.call(3 * n - 2)\n  else\n    prime_fib.call(3\
    \ * n - 3) + prime_fib.call(3 * n - 2)\n  end\nend", "  x = 2\n  y = 1\n  while\
    \ x < n\n    x, y = y, x + y\n  end\n  y\nend\n</code>\nAnd just for fun, I added\
    \ a memoization for prime_fib:\n<code>", "  return n if n < 4 or n % 2 == 0 or\
    \ n % 3 == 0 else prime_fib(n - 1) + prime_fib(n - 2)\nend", "  if n == 1 then\n\
    \    return 2\n  else \n    if n % 2 == 0 then\n      return prime_fib(n - 1)\
    \ + prime_fib(n - 2)\n    else\n      return prime_fib(n - 3)\n    end\n  end\n\
    end", "  sieve = Array.new(n+1)\n  prime = []\n  prime_no = 1\n  sieve << prime_no\n\
    \  prime_no += 1\n  prime_no += 2\n  until prime_no == n\n    prime_no += 1\n\
    \    until prime_no > n\n      prime_no += 2\n      until prime_no > n\n     \
    \   prime_no += 1\n        until prime_no > n\n          prime_no += 2\n     \
    \     until prime_no > n\n            prime_no += 1\n            until prime_no\
    \ > n\n              prime_no += 2\n              until prime_no > n\n       \
    \         prime_no += 1\n                until prime_no > n\n                \
    \  prime_no += 2\n                  until prime_no > n\n                    prime_no\
    \ += 1\n                    until prime_no > n\n                      prime_no\
    \ += 2\n                      until prime_no > n\n                        prime_no\
    \ += 1\n                        until prime_no > n\n                         \
    \ prime_no += 2\n                          until prime_no > n\n              \
    \              prime_no += 1\n                            until prime_no > n\n\
    \                              prime_no += 2\n                              until\
    \ prime_no > n\n                                prime_no += 1\n              \
    \                  until prime_no > n\n                                  prime_no\
    \ += 2\n                                  until prime_no > n\n               \
    \                     prime_no += 1\n                                    until\
    \ prime_no > n\n                                      prime_no += 2\n        \
    \                              until prime_no > n\n                          \
    \              prime_no += 1\n                                        until prime_no\
    \ > n\n                                          prime_no += 2\n             \
    \                             until prime_no > n\n                           \
    \                 prime_no += 1\n                                            until\
    \ prime_no > n\n                                              prime_no += 2\n\
    \                                              until prime_no > n\n          \
    \                                      prime_no += 1\n                       \
    \                         until prime_no > n\n                               \
    \                   prime_no += 2\n                                          \
    \        until prime_no > n\n                                                \
    \    prime_no += 1\n                                                    until\
    \ prime_no > n\n                                                      prime_no\
    \ += 2\n                                                      until prime_no >\
    \ n\n                                                        prime_no += 1\n \
    \                                                       until prime_no > n\n \
    \                                                         prime_no += 2\n    \
    \                                                      until prime_no > n\n  \
    \                                                          prime_no += 1\n   \
    \                                                         until prime_no > n\n\
    \                                                              prime_no += 2\n\
    \                                                              until prime_no\
    \ > n\n                                                                prime_no\
    \ += 1\n                                                                until\
    \ prime_no > n\n                                                             \
    \     prime_no += 2\n                                                        \
    \          until prime_no > n\n", "  return Prime(n) if n <= 3 or n % 2 == 0 or\
    \ not Prime(n).is_prime\nend", '  return n > 1 and is_prime(n % 6 and (prime_fib(n
    - 1) % 6) or prime_fib(n - 2)) end', "  if n <= 2\n    puts \"#{n} is not prime\
    \ number\"\n  else\n    puts \"#{n}th Fibonacci number is #{fib(n)}. Its a prime!\"\
    \n  end\nend", "  prime_fib.memo[n] ||= if n <= 2 then 1 else prime_fib.call(n\
    \ - 2) + prime_fib.call(n - 1) end\nend", "    return n+1 if n <= 2 else prime_fib(n-1)\
    \ + prime_fib(n-2)\n</code>\nNow, we can use these functions to implement our\
    \ recursive fibonacci function.\n<code>", "  primes = [2]\n  for i in [2,3,5]:\n\
    \    if primes.include?(i) && primes.include?(primes.last) + 1 == i\n      primes.push\
    \ i\n    end\n  end\n  primes.include?(n) ? primes.last : nil\nend", "  sieve\
    \ = Array.new(100){true}\n  sieve[0] = sieve[1] = 1\n  (2..n-1).each do |x|\n\
    \    sieve[x*x+x] = false\n  end\n  n\n  if sieve[n]\n    prime_fib.call(n-2)\n\
    \  else\n    (3..n-1).each do |x|\n      if sieve[n-x*x-x]\n        prime_fib.call(n-x*x-x)\n\
    \      end\n    end\n  end\nend\n</code>\n<code>", "  return call(\"prime_fib_#{n}\"\
    , n)\nend\nfunction prime_fib_1(n)\n  return n==1 || n==2 ? 1 : prime_fib(n-1)\
    \ + prime_fib(n-2)\nend\nfunction prime_fib_2(n)\n  return n==1 || n==2 ? 1 :\
    \ prime_fib(n-1) + prime_fib(n-2) + prime_fib(n-3)\nend\nfunction prime_fib_3(n)\n\
    \  return n==1 || n==2 ? 1 : prime_fib(n-1) + prime_fib(n-2) + prime_fib(n-3)\
    \ + prime_fib(n-4)\nend\nfunction prime_fib_4(n)\n  return n==1 || n==2 ? 1 :\
    \ prime_fib(n-1) + prime_fib(n-2) + prime_fib(n-3) + prime_fib(n-4) + prime_fib(n-5)\n\
    end\nfunction prime_fib_5(n)\n  return n==1 || n==2 ? 1 : prime_fib(n-1) + prime_fib(n-2)\
    \ + prime_fib(n-3) + prime_fib(n-4) + prime_fib(n-5) + prime_fib(n-6)\nend", "\t\
    fib = [1,1]\n\twhile fib[n] != nil\n\t\tfib = fib + fib[n]\n\t\tn += 1\n\tend\n\
    \treturn fib[n]\nend", "  return fib(n) if prime?(n) # fibonacci numbers and primes\
    \ are the same\n  a, b = 0, 1\n  while b < n\n    a, b = b, a+b\n  end\n  a\n\
    end", "  if n == 0\n    return 0\n  elsif n == 1\n    return 1\n  elsif prime_fib.call(n-1)\
    \ == 0 \n    return 0\n  else \n    return prime_fib.call(n-1) + prime_fib.call(n-2)\n\
    \  end\nend\n</code>\n<|/ a |>\n<| c |>\ni know that but i want to do that in\
    \ recursion function but i don't know how to do it\n<|/ c |>\n<| c |>\ni know\
    \ this but i don't know how to do it in recursive function.\n<|/ c |>\n<| a dscore=1\
    \ tags=ruby,fibonacci,primes,recursion |>\n<code>", "  # this code is from Primer\
    \ Hacker's HackerRank website\n  # it calculates the n-th Fibonacci number recursively\n\
    \  # using Sieve of Eratosthenes\n  # it returns the n-th Fibonacci number\n \
    \ # the complexity is O(n**2)\n  if n == 0\n    1, 1\n  else\n    fib, sum =prime_fib.call(1),\
    \ prime_fib.call(2)\n    for num in (3*fib+sum)..n\n      fib, sum = (fib+num)\
    \ % n, sum+(num*num) % n\n      yield num\n  end\nend", "    prev, prev, prev,\
    \ fib, prime = (0, 1, 0, [2, 3, 5], False)\n    while fib < n and prime: \n  \
    \      fib = prev + prev \n        prev, prev, prime = prev, fib, [p for p in\
    \ prime if p > fib]\n    return fib", "    if n <= 1\n        return n\n    else\n\
    \        prime_fib.call(n - 1) + prime_fib.call(n - 2)\n    end\nend", "    sum\
    \ = 0\n    if n == 1 or n == 2:\n        return n\n    while n > 2:\n        sum\
    \ += n\n        if sum > n:\n            return n\n        n -= 1\n    return\
    \ n\n</cell>\n<cell>\nprime_fib.call(7)\n</cell>\n<cell>", "    a, b = 0, 1\n\
    \    while b < n:\n        a, b = b, a+b\n    return a", "  a = b = 2\n  while\
    \ a < n do\n    if a > b then return b else a = b\n    a, b = b, a + b\n  end\n\
    \  return b\nend", "  prime_fib_count = 0\n  fib_count = 0\n  prime_fib_list =\
    \ [2,3]\n  fib_list = [0,1]\n  while (prime_fib_count < n) and (fib_count < n)\n\
    \    prime_fib_list.concat(prime_fib_list)\n    fib_list.concat(fib_list)\n  \
    \  prime_fib_count = prime_fib_count + 1\n    fib_count = fib_count + 1\n  \n\
    \  prime_fib_index = 0\n  fib_index = 0\n  while (prime_fib_index < prime_fib_count)\n\
    \  \n    prime_fib_num = prime_fib_list[prime_fib_index]\n    fib_num = fib_list[fib_index]\n\
    \    while (fib_num < prime_fib_num)\n      fib_index = fib_index + 1\n      prime_fib_list[prime_fib_index]\
    \ = fib_list[fib_index]\n      prime_fib_index = prime_fib_index + 1\n      fib_count\
    \ = fib_count + 1\n      fib_list[fib_index] = fib_num + fib_list[fib_index-1]\n\
    \      fib_index = fib_index + 1\n      prime_fib_count = prime_fib_count + 1\n\
    \      fib_count = fib_count + 1\n      fib_list[fib_index] = fib_num + fib_list[fib_index-1]\n\
    \      fib_index = fib_index + 1\n    \n    if (fib_num == prime_fib_num)\n  \
    \    prime_fib_count = prime_fib_count + 1\n    \n    prime_fib_list[prime_fib_index]\
    \ = fib_num + fib_list[fib_index-1]\n    \n    fib_index = fib_index + 1\n   \
    \ prime_fib_index = prime_fib_index + 1\n    \n  prime_fib_index = 0\n  fib_index\
    \ = 0\n  while (prime_fib_index < prime_fib_count)\n  \n    prime_fib_num = prime_fib_list[prime_fib_index]\n\
    \    fib_num = fib_list[fib_index]\n    while (fib_num < prime_fib_num)\n    \
    \  fib_index = fib_index + 1\n      prime_fib_list[prime_fib_index] = fib_list[fib_index]\n\
    \      prime_fib_index = prime_fib_index + 1\n      fib_count = fib_count + 1\n\
    \      fib_list[fib_index] = fib_num + fib_list[fib_index-1]\n      fib_index\
    \ = fib_index + 1\n      prime_fib_count = prime_fib_count + 1\n      fib_count\
    \ = fib_count + 1\n      fib_list[fib_index] = fib_num + fib_list[fib_index-1]\n\
    \      fib_index = fib_index + 1\n    \n    if (fib_num == prime_fib_", "    if\
    \ n < 2\n        return n\n    return prime_fib.call(n-1) + prime_fib.call(n-2)\
    \ if prime_fib.call(n) > n else n\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n\
    I like's answer, but this one is easier to understand:\n<code>", "  return 1 if\
    \ n <= 2 then 2 else fib(n-1) + fib(n-2) if n <= 4 then 2 else prime_fib(n-1)\
    \ + prime_fib(n-2)\nend", "  if n < 2\n    n\n  else\n    prime_fib.call(n - 1)\
    \ + prime_fib.call(n - 2)\n  end\nend\n</cell>\n<cell>\nprime_fib.call(1)\n</cell>\n\
    <cell>", "  if n < 2\n    next\n  else\n    prime_fib.call(n-2) + prime_fib.call(n-1)\n\
    end", "  if n < 0\n    puts \"n must be non-negative\"\n    return nil\n  elsif\
    \ n <= 1\n    puts \"n must be greater than 1\"\n    return nil\n  end\n  if primes.include?(n)\n\
    \    return n\n  end\n  i = 2\n  while i < n\n    i = i + 2\n  end\n  primes <<\
    \ n\n  return i\nend", "    if n < 2\n        return n\n    fib_n = [1, 2]\n \
    \   while fib_n[-1] <= n\n        fib_n.push(fib_n[-1] + fib_n[-2])\n    fib_n.push(n)\n\
    \    return fib_n\nend", "  if n <= 2\n    2\n  elsif n <= 3\n    3\n  elsif n\
    \ <= 5\n    prime_fib.call(n - 2) + prime_fib.call(n - 3)\n  else\n    prime_fib.call(n\
    \ - 4) + prime_fib.call(n - 6)\n  end\nend\n</cell>\n<cell>\nprime_fib.call(5)\n\
    </cell>\n<text>\nExercise 3:\nWrite a function that computes the factorial of\
    \ a number. The function should only accept positive integers, and output the\
    \ factorial as a floating point number.", "  prime_fib.counter = prime_fib.counter\
    \ || 0\n  prime_fib.counter += n\n  prime_fib.counter%2==0? prime_fib.fibs[prime_fib.counter]\
    \ = prime_fib.fibs[prime_fib.counter-1] + prime_fib.fibs[prime_fib.counter-2]:\
    \ prime_fib.fibs[prime_fib.counter] = prime_fib.fibs[prime_fib.counter-1]\n  return\
    \ prime_fib.fibs[prime_fib.counter]\nend", "  if n == 0\n    puts 0\n  elsif n\
    \ == 1\n    puts 1\n  else\n    puts (prime_fib.call(n-1) + prime_fib.call(n-2))\n\
    \  end\nend", "  if n <= 2 then\n    return n\n  end", "  fib = [1, 1]\n  while\
    \ fib[0] <= n do\n    fib[1] = fib[0] + fib[1]\n    fib[0] = fib[1]\n  end\n \
    \ fib[n]\nend", "  primes = []\n  n = 1\n  primes.push n\n  primes.push n\n  while\
    \ primes.count > 1 do\n    n = primes.shift\n    primes.push n\n    primes.push\
    \ n % primes.count + primes.shift\n  end\n  primes.push n % primes.count + primes.shift\n\
    \  primes.uniq\nend\n</code></pre>\n  </section>\n  <section id=\"section-5\"\
    >\n    <h2>Chapter 5: Object Oriented Programming</h2>\n<p>In Ruby, Ruby is an\
    \ Object Oriented Programming language.\n  It means you can use all the features\
    \ of Ruby such as inheritance, composition, mixins, metaprogramming and\n  more.\
    \ It's also the most popular programming language in the world.</p>\n<p>Ruby is\
    \ also a pure functional language with OOP features. It is based on the Smalltalk\
    \ language.</p>\n<p>Ruby OOP introduces some new concepts such as inheritance,\
    \ composition, mixins and metaprogramming.\n  You can read more about these concepts\
    \ in Chapter 4.</p>\n<p>Ruby is also a functional language and you can call Ruby\
    \ OOP as an OOP language.\n  It also has some functional features like currying.</p>\n\
    <p>Ruby supports OOP and functional at the same time.\n  However, OOP can be mixed\
    \ with functional.\n  However, Ruby OOP features does not include functional features.\n\
    \  Therefore, Ruby has some functional features as well\n  as OOP features.\n\
    \  Ruby also has some OOP features.\n  Ruby is also a functional language.\n \
    \ Therefore, Ruby supports OOP and functional at the same time.\n  You can even\
    \ mix OOP and functional features in one language.\n  Ruby supports inheritance,\
    \ mixins and metaprogramming.\n  You can read more about Ruby OOP in Chapter 4.</p>\n\
    <p>Ruby is an Object-Oriented Programming language.\n  Ruby is an object oriented\
    \ programming language. It allows you to create Objects such as Person, Car, House,\
    \ Animal,\n  and Dog.\n  In Ruby, an object is an instance of a class.</p>\n<p>Objects\
    \ such as Person, Car, House, Animal, Dog, are called Class Objects.\n  They are\
    \ also called Object Relations.\n  They are also called Class Relations.\n  They\
    \ are also called Object-Oriented Programming.\n  You can read more about object\
    \ oriented programming in Chapter 4.</p>\n<p>You can create an object ", "  if\
    \ n < 3\n    next\n  elsif n % 2 == 0\n    next\n  else\n    prime_fib.call(n-1)\
    \ + prime_fib.call(n-2)\n  end\nend\n</cell>\n<code language=julia-1.5>\nprime_fib.call(10)\n\
    </cell>\n<code language=julia-1.5>\n@time prime_fib.call(100);\n</cell>\n<text>\n\
    The same code with BenchmarkTools benchmark", "  a, b = 0, 1\n  while a <= n\n\
    \    a, b = b, a + b\n  a\nend", "  if n < 2\n    then return 2\n  else \n   \
    \ if n == 2\n      then return 3\n    else\n      if n % 2 == 0\n        then\
    \ return n\n      else\n        prime_fib.call(n / 2) + (n % 2)\n  end\nend\n\
    </code>\n<|/ a dscore=0 tags=fibonacci,ruby,primes |>\n<| c |>\nThank you for\
    \ your answer! I have another question for you: can you tell me the difference\
    \ between \"call\" and \"eval\" in Ruby? And which one should I use?\n<|/ c |>\n\
    <| c |>\nThe difference is that `call` allows you to pass arguments and execute\
    \ the block in its own scope. On the other hand, `eval` will try to evaluate the\
    \ code and pass the return value to its caller.\n<|/ c |>\n<| c |>\nThank you\
    \ for replying again! I am confused: in the first example, the block argument\
    \ is an integer, which means we can pass an integer as an argument and it will\
    \ return the Fibonacci number. But the second example, the block argument is a\
    \ block, which means we can pass an block as an argument and it will return the\
    \ Fibonacci number when the block is executed, right? Why can't we pass a block\
    \ to \"call\", too? I really need your help again and again because I am a beginner\
    \ of Ruby. Thanks in advance!\n<|/ c |>\n<| c |>\nThe difference between those\
    \ two examples is that `eval` will try to evaluate the argument in its own scope,\
    \ while `call` will execute the block and pass the return value to its caller.\n\
    <|/ c |>\n<| a |>\nTry this way,\n<code>", "  if n<2:\n    return n\n  return\
    \ prime_fib(prime_fib(n-1)) + prime_fib(prime_fib(n-2))\nprime_fib.defnarg(4,20)\n\
    </cell>\n<text>\nExercise 9.3: What is the value of prime_fib.call(4) ?\nHow many\
    \ times does the function call itself?\nDo you think it's enough to test if n\
    \ < 2 ?", "  if n < 2\n    next\n  else\n    prime_fib.call(n-1) + prime_fib.call(n-2)\n\
    \  end\nend\n</code>\nSo prime_fib returns n-th number that is a Fibonacci number\
    \ and it's also prime.\n<|/ a tags=ruby-on-rails-3,ruby-on-rails-3.2,ruby-on-rails\
    \ |>\n<| a tags=ruby-on-rails-3,ruby-on-rails-3.2,ruby-on-rails |>\n<code>", " \
    \ memo = [1, 2]\n  n1 = memo[1]\n  n2 = memo[2]\n  while n > 1\n    memo.push(n1)\n\
    \    memo.push(n2)\n    n1 = n2\n    n2 = memo.pop + memo.pop\n    n -= 1\n  memo.pop()\n\
    \  return memo[0]\nend", "  if n <= 1\n    1\n  elsif n == 2\n    2\n  elsif n\
    \ % 2 == 0\n    prime_fib(n - 1) + prime_fib(n - 2)\n  else\n    prime_fib(n -\
    \ 1) + prime_fib(n - 3) \n  end\nend\n</code>\n<|/ a tags=ruby,fibonacci,ruby-on-rails\
    \ |>\n<| a dscore=1 |>\nHere is a one line solution which can be helpful with\
    \ recursion and memoization, although it may slow down your program considerably,\
    \ specially when it comes to large n values. It also handles negative values nicely.\n\
    <code>", "  return 0 if n <= 1 then n else prime_fib.call(n - 2) + prime_fib.call(n\
    \ - 1)\nend\n</cell>\n<text>\nFunctions take input arguments and return output.\
    \ Let's define a function that takes 2 arguments and returns the sum of them.",
  "  nFib = 1\n  nPrime = 1\n  while nPrime < n\n    nPrime = nFib + 1\n    nFib =\
    \ nFib + nPrime\n  end\n  return nFib\nend", "  if n < 2\n    n\n  else\n    prime_fib.call(n\
    \ - 2) + prime_fib.call(n - 3)\n  end\nend", "  return 1 if n <= 1 \n  return\
    \ prime_fib.call(n - 1) + prime_fib.call(n - 2)\nend", "  return n if n < 2 else\
    \ prime_fib.call(n-1) + prime_fib.call(n-2)\nend", "  return n if n < 2 else prime_fib.call(n-1)\
    \ + prime_fib.call(n-2)\nend", "  a, b = 0, 1\n  while n > 0\n  \tn, a, b = b,\
    \ a + b, a\n  \treturn b\nend", "  prime_fib_number = 0\n  if n < 2\n    prime_fib_number\
    \ = 0\n  elsif n > 2\n    prime_fib_numbers = [2,3]\n    prime_fib_numbers.each\
    \ do |i|\n      if n % i == 0\n        prime_fib_number = i\n        break\n \
    \     end\n    end\n  end\n  prime_fib_number\nend", "  return 1 if n < 2 else\
    \ prime_fib.call(n-1) + prime_fib.call(n-2)\nend", "  if n < 2\n    throw :not_less_than_2\n\
    \  else\n    prime_fib.call(n-1) + prime_fib.call(n-2) if prime_fib.call(n-3)\
    \ == 0\n  end\nend", "    if n<2:\n        return n\n    a, b = 0, 1\n    while\
    \ n > 1:\n        a, b = b, a+b\n        n -= 1\n    return b", '    return fib(n)',
  "  fib = (0, 1)\n  while n > 0\n    (f1, f2) = fib\n    (fib,) = (f1 + f2, fib)\n\
    \    (f2, f1) = (f1, f2)\n    n = n - 1\n  end\n  fib\nend", "  if n < 2\n   \
    \ return n\n  else\n    # n <= 3\n    if n % 2 == 0\n      prime_fib.call(n/2)\
    \ + prime_fib.call(n/2)\n    else\n      prime_fib.call(n/2) + prime_fib.call(n/2)\
    \ - 1\n  end\nend\n</cell>\n<code language=julia-1.5>\nprime_fib.call(1)\n</cell>\n\
    <code language=julia-1.5>\nprime_fib.call(2)\n</cell>\n<code language=julia-1.5>\n\
    prime_fib.call(3)\n</cell>\n<code language=julia-1.5>\nprime_fib.call(4)\n</cell>\n\
    <code language=julia-1.5>\nprime_fib.call(5)\n</cell>\n<code language=julia-1.5>\n\
    prime_fib.call(6)\n</cell>\n<code language=julia-1.5>\nprime_fib.call(7)\n</cell>\n\
    <code language=julia-1.5>\nprime_fib.call(8)\n</cell>\n<code language=julia-1.5>\n\
    prime_fib.call(9)\n</cell>\n<code language=julia-1.5>\nprime_fib.call(10)\n</cell>\n\
    <code language=julia-1.5>\nprime_fib.call(11)\n</cell>\n<code language=julia-1.5>\n\
    prime_fib.call(12)\n</cell>\n<code language=julia-1.5>\nprime_fib.call(13)\n</cell>\n\
    <code language=julia-1.5>\nprime_fib.call(14)\n</cell>\n<code language=julia-1.5>\n\
    prime_fib.call(15)\n</cell>\n<code language=julia-1.5>\nprime_fib.call(16)\n</cell>\n\
    <code language=julia-1.5>\nprime_fib.call(17)\n</cell>\n<code language=julia-1.5>\n\
    prime_fib.call(18)\n</cell>\n<code language=julia-1.5>\nprime_fib.call(19)\n</cell>\n\
    <code language=julia-1.5>\nprime_fib.call(20)\n</cell>\n<code language=julia-1.5>\n\
    prime_fib.call(21)\n</cell>\n<code language=julia-1.5>\nprime_fib.call(22)\n</cell>\n\
    <code language=julia-1.5>\nprime_fib.call(23)\n</cell>\n<code language=julia-1.5>\n\
    prime_fib.call(24)\n</cell>\n<code language=julia-1.5>\nprime_fib.call(25)\n</cell>\n\
    <code language=julia-1.5>\nprime_fib.call(26)\n</cell>\n<code language=juli",
  "    a, b = 0, 1\n    while a < n:\n        a, b = b, a+b\n    return a\n</cell>\n\
    <cell>", "\tfibs = [1, 1]\n\tfor i in range(n - 1)\n\t\tfibs.append(fibs[-1] +\
    \ fibs[-2])\n\treturn fibs[-1]\nend", "  return if n < 2\n  if n == 2\n    3\n\
    \  else\n    if n % 2 == 0\n      prime_fib(n - 2)\n    else\n      prime_fib(n\
    \ - 1) + prime_fib(n - 2)\n  end\nend\n</cell>\n<code language=julia-1.5>\nfunction\
    \ prime_fib_seq(n)\n  result = []\n  i = 1\n  while i <= n\n    result push(i)\
    \ if prime_fib.(i) == i\n    i += 1\n  end\n  return result\nend\n</cell>\n<code\
    \ language=julia-1.5>\nprime_fib_seq(10000)\n</cell>\n<text>\nTask 4 : Fibonnaci\
    \ numbers\nThe Fibonacci sequence is defined as the sequence of integers where\n\
    each number is the sum of the two preceding ones, starting with 0,\nand each one\
    \ is the sum of two preceding ones:", "\tif n == 0 then return 1\n\tif n == 1\
    \ then return 2\n\tif n % 2 == 0 then return prime_fib(n / 2)\n\treturn prime_fib(n\
    \ - 1) + prime_fib(n - 2)\nend", "    return call(\"prime_fib\", n)\nend\n</cell>\n\
    <code language=julia-1.4>", "  return ( if n <= 2\n      n\n    else if prime_fib.call(n-1)\
    \ < n\n      prime_fib.call(n-1)\n    else\n      prime_fib.call(n-2) + prime_fib.call(n-1)\n\
    \    )\nend\n</cell>\n<cell>", "  return n < 2 ? 1 : prime_fib(n - 1) + prime_fib(n\
    \ - 2)\nend", "  prime_fib.cache[n] ||= fib(n - 2)\n  prime_fib.cache[n]\nend",
  "    if n < 2\n        return n\n    else\n        return prime_fib.call(n-2) +\
    \ prime_fib.call(n-1)\n    end\nend\n</cell>\n<cell>\nprime_fib.call(5)\n</cell>\n\
    <text>\nA Fibonacci number is a number that is the sum of the two preceding numbers,\
    \ except that the first two numbers are 1 and 2. In other words, Fn = F(n-2) +\
    \ F(n-1).", "  return n if n <= 2 else prime_fib.call(n - 1) + prime_fib.call(n\
    \ - 2)\nend", "    if n <= 1:\n        return 1\n    return prime_fib(n - 1) +\
    \ prime_fib(n - 2)\n</cell>\n<cell>\nprime_fib(50)\n</cell>\n<cell>", "  fib =\
    \ (0,1)\n  while n < 0\n    n += fib[1]\n    fib = (fib[0], fib[1] + fib[1])\n\
    \  end\n  while n > fib[1]\n    n -= fib[1]\n    fib = (fib[0] + fib[1], fib[1]\
    \ + fib[1])\n  end\n  return fib\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
