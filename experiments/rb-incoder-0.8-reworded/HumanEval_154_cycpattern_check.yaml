name: HumanEval_154_cycpattern_check
language: rb
prompt: "# You are given 2 words. You need to return true if the second word or any\
  \ of its rotations is a substring in the first word\n# >>> cycpattern_check.call(\"\
  abcd\", \"abd\")\n# false\n# >>> cycpattern_check.call(\"hello\", \"ell\")\n# true\n\
  # >>> cycpattern_check.call(\"whassup\", \"psus\")\n# false\n# >>> cycpattern_check.call(\"\
  abab\", \"baa\")\n# true\n# >>> cycpattern_check.call(\"efef\", \"eeff\")\n# false\n\
  # >>> cycpattern_check.call(\"himenss\", \"simen\")\n# true\ndef cycpattern_check(a,\
  \ b)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_cycpattern_check\n\
  \    candidate = method(:cycpattern_check)\n    assert_equal(false, candidate.call(\"\
  xyzw\", \"xyw\"))\n    assert_equal(true, candidate.call(\"yello\", \"ell\"))\n\
  \    assert_equal(false, candidate.call(\"whattup\", \"ptut\"))\n    assert_equal(true,\
  \ candidate.call(\"efef\", \"fee\"))\n    assert_equal(false, candidate.call(\"\
  abab\", \"aabb\"))\n    assert_equal(true, candidate.call(\"winemtt\", \"tinem\"\
  ))\n  end\nend\n"
completions: ["  a,b = a.downcase, b.downcase\n  return false if a.length < b.length\
    \ && a.split(//).include?(b) else true if a.length < b.length && a.split(//).include?(b.split(//).last)\n\
    end", "  a.split(\"\").each do |x|\n    b.split(\"\").each do |y|\n      if x\
    \ == y || a[-x..-1] == b[-y..-1] || a[-x, 1] == b[-y, 1]\n        return true\n\
    \      end\n    end\n  end\n  return false\nend", "  a1 = a\n  b1 = b\n  a1 =\
    \ a1.split(\"\")\n  b1 = b1.split(\"\")\n  n1 = a1.length\n  n2 = b1.length\n\
    \  for i in (0..n1-1) do\n    for j in (0..n2-1) do\n      if((a1[i] == a1[j+1])and(b1[i]==b1[j+1])and(i+1<n1)and(j+1<n2))\
    \ then\n        return true\n      elsif ((b1[i]==b1[j+1])and(i+1<n1)and(j+1<n2))\
    \ then\n        return false\n      else\n        return false\n      end\n  \
    \  end\n  end\n  return false\nend\n</code>\n<|/ a tags=string,ruby |>\n<| c |>\n\
    thanks so much. but I'm getting an error `undefined method 'split' for nil:NilClass\
    \ (NoMethodError)` when I run the code `cycpattern_check.call(\"abracadabra\"\
    , \"abracadabra\")` i tried with my original code too to test and I get the error\
    \ `undefined method 'split' for \"abracadabra\":String (NoMethodError)`\n<|/ c\
    \ |>\n<| c |>\nthanks again. I used your example and added this line to the bottom\
    \ of my code `a1.split(\"\").map { |e| e.ord }` and I didn't get the `undefined\
    \ method 'split' for nil:NilClass (NoMethodError)` error anymore. but I got a\
    \ new error. `NoMethodError: undefined method `<=' for nil:NilClass` for the code\
    \ `return (a1[i] <= a1[j]) && (b1[i] <= b1[j])`\n<|/ c |>\n<| c |>\nah, I forgot\
    \ to add those lines to the code. Now it works thanks. But when I run it with\
    \ `cycpattern_check.call(\"abracadabra\", \"abracadabra\")` I get `false` but\
    \ should be `true` as my prof gave me the solution\n<|/ c |>\n<| c |>\nYes I see\
    \ now, I just changed `(n <= m)` to `(n <= n-1)`\n<|/ c |>\n<| c |>\nthanks for\
    \ all the help, now I'm finally getting all the ruby code I need. I'm just gonna\
    \ have to learn the code now I'm in high school so I haven't learned about map\
    \ yet, I'm gonna study it now to get a better understanding of it\n<|/ c |>\n\
    <| a dscore=0 |>\nI ", "  a.split.each { |word| a.include?(word) || a.include?(word.gsub(/([a-z])/,\
    \ \"\\\\1\"))}\n  b.split.each { |word| b.include?(word) || b.include?(word.gsub(/([a-z])/,\
    \ \"\\\\1\"))}\n  true\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=string,ruby,algorithm\
    \ |>\nIf you're looking for an algorithm to identify patterns that you can then\
    \ use to perform a search, here are some links which might help you get started:\n\
    http://www.ibm.com/developerworks/search/library/ruby/\nhttp://en.wikipedia.org/wiki/N-gram\n\
    <|/ a dscore=0 |>\n<| a |>\nRuby code:\n<code>", "  a = a.downcase\n  b = b.downcase\n\
    \  return true if a =~ /^(#{b}*)#{b}$/\n  return true if a =~ /^(#{b}*)#{b}#{b}$/\n\
    \  return true if a =~ /^(#{b}*)#{b}#{b}#{b}$/\n  return true\nend\n</code>\n\
    <|/ a dscore=0 tags=ruby,string |>\n<| a tags=ruby,string dscore=0 |>\n<code>",
  "  a.downcase.split(\"\").each do |char|\n    if b.include?(char)\n      return\
    \ true\n    end\n  end\n  return false\nend", "  (a.include? b) or a.chars.any?\
    \ {|x| b.include? x}\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks. I tried\
    \ this but got stuck at `\"aaa\".include?('aaa')` because I was trying to make\
    \ it case insensitive.\n<|/ c |>\n<| c |>\n`'a'.downcase == 'a'` but `'a'.downcase!=='A'`.\
    \ You could do `b.downcase == a.downcase` to make it case insensitive.\n<|/ c\
    \ |>\n<| c |>\nI thought you were using the wrong operator in your conditional.\
    \  See the edit I just made.  You should be able to use `a.include? b` or `a.chars.any?\
    \ {|x| b.include? x}` to do it.\n<|/ c |>\n<| c |>\nThanks. `a.chars.any? {|x|\
    \ b.include? x}` works perfectly. I was trying to use that but got stuck because\
    \ I was trying to make it case insensitive.\n<|/ c |>\n<| c |>\nJust for reference,\
    \ [this question](http://stackoverflow.com/questions/3076646/in-rails-is-it-possible-to-specify-a-case-insensitive-include-or-similar-on-the-che)\
    \ explains how to do it.  It uses `downcase` as in the other comments.\n<|/ c\
    \ |>\n<| a tags=ruby,ruby-on-rails dscore=1 |>\nI figured out a way to do this\
    \ while keeping it in Ruby conventions.  This is probably not very efficient (O(n*m)),\
    \ especially when dealing with large strings, but it keeps the code a little more\
    \ readable.\n<code>", "  a += \"\\0\"\n  b += \"\\0\"\n  (a.length % a.size).times\
    \ { a += \"0\" }\n  (b.length % b.size).times { b += \"0\" }\n  a.length = (a.length\
    \ >> 1).to_i\n  b.length = (b.length >> 1).to_i\n  return a.index(b) != -1\nend",
  "    a_length = len(a) - 1\n    b_length = len(b) - 1\n    if a_length > b_length:\n\
    \        a, b = b, a\n        a_length, b_length = b_length, a_length\n    for\
    \ i in range(b_length):\n        if a[i] == b[b_length-i-1]:\n            return\
    \ cycpattern_check(b.rotate(a[b_length-i-1]), a)\n        else:\n            return\
    \ False", "  a.split('').each do |c|\n    if b.include?(c)\n      false\n    else\n\
    \      true\n    end\n  end\nend", "  a_index = nil\n  b_length = nil\n  b_rotation\
    \ = nil\n  b_word = nil\n  while (a_index != nil and b_length != nil)\n    a_index\
    \ = a_index.succ\n    b_length = b_length.to_i\n    b_rotation = b_rotation.to_i\n\
    \    b_word = b.to_s[b_length, b_rotation]\n    if (b_word != nil and b_word =~\
    \ /^\\w*$/)\n      return true\n    end\n  end\n  return false\nend", "  a.gsub!(/[^aeiou]/,\
    \ \".\")\n  b.gsub!(/[^aeiou]/, \".\")\n  a = a.downcase\n  b = b.downcase\n \
    \ a = a.split(\"\")\n  b = b.split(\"\")\n  if a.empty? or b.empty? or a.length\
    \ != b.length\n    return false\n  end\n  i = a.length\n  while i > 1\n    if\
    \ a[i - 2] == a[i - 1] and b[i - 2] == b[i - 1]\n      return false\n    end\n\
    \    i -= 1\n  end\n  i = b.length\n  while i > 1\n    if a[i - 2] == b[i - 1]\
    \ and b[i - 2] == a[i - 1]\n      return false\n    end\n    i -= 1\n  end\n \
    \ return true\nend", "  # Your code here!\nend", "  return true if a.include?(b)\
    \ || b.include?(a)\nend", "    return a.index(b) >= 0\nend", "    return a.include?(b)\
    \ || a.include?(b.upcase) || a.include?(b.downcase) || b.include?(a.upcase) ||\
    \ b.include?(a.downcase)\nend\n</code>\n<|/ a dscore=0 tags=ruby,string,arrays\
    \ |>\n<| a tags=ruby,string,arrays |>\nThe method include? will just check the\
    \ first character, you can do this:\n<code>", "  return a.split(\"\").each_cons(2).any?\
    \ { |v| b.include?(v) }\nend", "  a.each do |c|\n    b.each do |d|\n      return\
    \ false if (c === d)\n      d.each do |e|\n        return false if (c === e)\n\
    \        e.each do |f|\n          return false if (c === f)\n        end\n   \
    \   end\n    end\n  end\n  true\nend", "\treturn (a.length >= b.length and b.index(a)\
    \ == 0)\nend", "  a.downcase!\n  b.downcase!\n  return false if a.length == 0\
    \ or b.length == 0\n  a.upcase!\n  b.upcase!\n  a.index(/[^a-z]/).nil? and b.index(/[^a-z]/)\
    \ and return false\n  a.index(/[[:punct:]]/).nil? and b.index(/[[:punct:]]/) and\
    \ return false\n  a.index(/[[:cntrl:]]/).nil? and b.index(/[[:cntrl:]]/) and return\
    \ false\n  a.index(/[[:space:]]/).nil? and b.index(/[[:space:]]/) and return false\n\
    \  a.index(/[[:space:]]/).nil? and b.index(/[[:space:]]/) and return false\n \
    \ a.index(/[[:alpha:]]/).nil? and b.index(/[[:alpha:]]/) and return false\n  a.index(/[[:alnum:]]/).nil?\
    \ and b.index(/[[:alnum:]]/) and return false\n  a.index(/[^[:alpha:]]/).nil?\
    \ and b.index(/[^[:alpha:]]/) and return false\n  a.index(/[^[:alnum:]]/).nil?\
    \ and b.index(/[^[:alnum:]]/) and return false\n  a.index(/[^[:punct:]]/).nil?\
    \ and b.index(/[^[:punct:]]/) and return false\n  a.index(/[^[:cntrl:]]/).nil?\
    \ and b.index(/[^[:cntrl:]]/) and return false\n  a.index(/[^[:space:]]/).nil?\
    \ and b.index(/[^[:space:]]/) and return false\n  a.index(/[^[:alpha:]]/).nil?\
    \ and b.index(/[^[:alpha:]]/) and return false\n  a.index(/[^[:alnum:]]/).nil?\
    \ and b.index(/[^[:alnum:]]/) and return false\n  return a.length == b.length\
    \ and a.upcase.index(b.upcase)\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI like\
    \ your code. I didn't know that ruby had a downcase method.\n<|/ c |>\n<| c |>\n\
    That method will also work for strings with numbers, e.g. `'1'.downcase #=> \"\
    1\"`.\n<|/ c |>\n<| c |>\nRub", "  a.downcase!\n  b.downcase!\n  return false\
    \ if a.length==b.length && a.downcase!=b.downcase && a.include?(b) || b.include?(a)\n\
    \  c = a.length\n  for i in 0...c\n    v = a[i]\n    if i == (c-1)\n      b.gsub!(/./)\
    \ { |m| m[0]==v && m[1]==m }\n    else\n      a.gsub!(/./) { |m| m[0]==v && m[1]==m\
    \ }\n    end\n  end\n  a.length==c.to_s && b.length==c.to_s\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nThank you for your answer.  I understand that my code\
    \ works only on cases with a single rotation, so I changed my question to indicate\
    \ this.\n<|/ c |>\n<| c |>\nI edited my answer to account for multiple rotation.\n\
    <|/ c |>\n<| c |>\nThank you for your answer.  I understand that my code works\
    \ only on cases with a single rotation, so I changed my question to indicate this.\
    \  However, I still have a few questions.  I see that your algorithm works only\
    \ on strings of the same length, but how does it work when multiple rotations\
    \ occur?  It seems to me that once it gets to the second rotation, it will just\
    \ stop because there are no more letters.  Does that mean that it doesn't work\
    \ when there are 2 rotations?  Also, why does your method return true when `cycpattern_check.call(\"\
    pissimi\", \"pissim\")`?\n<|/ c |>\n<| c |>\nI edited my answer to account for\
    \ multiple rotation.  In your example, \"pissimi\" is a substring of \"pissim\"\
    .  When you pass two strings of different lengths, it will only work if the two\
    \ strings have the same number of letters.\n<|/ c |>\n<| a tags=string,ruby,ruby-on-rails\
    \ |>\nI came up with a solution that only uses regular expressions.  My code seems\
    \ to work correctly.\n<code>", "  a = a.split(//).map { |a| a.split(//) }\n  b\
    \ = b.split(//).map { |b| b.split(//) }\n  a.zip(b.map(&:size)).all? { |e,f| e.zip(f.map(&:size)).all?\
    \ { |n,p| n == p } }\nend", "  a = a.downcase\n  b = b.downcase\n  if a.length\
    \ == 0 || b.length == 0\n    return false\n  if a.length > b.length\n    return\
    \ cycpattern_check(b, a)\n  return b.include?(a)\nend", "  a_count = a.size\n\
    \  b_count = b.size\n  min_len = Math.min(a_count, b_count)\n  i = 0\n  while\
    \ i < min_len\n    if i < a_count\n      a_sub = a.slice!(i, i+1)\n    else\n\
    \      b_sub = b.slice!(i, i+1)\n    end\n    return true if a_sub.is_a? String\
    \ and b_sub.is_a? String and (b_sub[0...a_sub.length] == a_sub)\n    i += 1\n\
    \  end\n  false\nend", "  return (a.size() == b.size() and a.each_char.zip(b.each_char).all?\
    \ do |x,y|\n    if x != nil and y != nil\n      x.size == y.size and x.each_char.zip(y.each_char).all?\
    \ do |xy, yx|\n        xy[0] == yx[0]\n      end\n    else\n      true\n    end\n\
    \  end)\nend", "  return false if a.include?(b) \n  \n  # If the second word is\
    \ shorter than the first, replace the longer word's letter with any letter in\
    \ the \n  # other word until one of them is empty. \n  case b\n  when a.size<b.size\n\
    \    while a.length>0\n      a.slice!(0)\n    end\n    a\n  when b.size>a.size\n\
    \    while b.length>0\n      b.slice!(0)\n    end\n    b\n  end\nend", "  return\
    \ false if a.size <= b.size or a.size < 3 or b.size < 3 then return false\n  return\
    \ true if a.slice(1, a.size - 1).split(\"\").sort.reduce(:==, b.slice(1, b.size\
    \ - 1).split(\"\").sort) then return true\n  a.slice(1, a.size - 1).split(\"\"\
    ).sort.reduce(:==, b.slice(1, b.size - 1).split(\"\").sort) == false and a.slice(1,\
    \ a.size - 1).split(\"\").sort.reduce(:==, b.slice(1, b.size - 1).split(\"\").sort)\
    \ == true and a.slice(1, a.size - 1).split(\"\").sort.reduce(:==, b.slice(1, b.size\
    \ - 1).split(\"\").sort) == false and a.slice(1, a.size - 1).split(\"\").sort.reduce(:==,\
    \ b.slice(1, b.size - 1).split(\"\").sort) == false and a.slice(1, a.size - 1).split(\"\
    \").sort.reduce(:==, b.slice(1, b.size - 1).split(\"\").sort) == false and a.slice(1,\
    \ a.size - 1).split(\"\").sort.reduce(:==, b.slice(1, b.size - 1).split(\"\").sort)\
    \ == false and a.slice(1, a.size - 1).split(\"\").sort.reduce(:==, b.slice(1,\
    \ b.size - 1).split(\"\").sort) == false and a.slice(1, a.size - 1).split(\"\"\
    ).sort.reduce(:==, b.slice(1, b.size - 1).split(\"\").sort) == false and a.slice(1,\
    \ a.size - 1).split(\"\").sort.reduce(:==, b.slice(1, b.size - 1).split(\"\").sort)\
    \ == false and a.slice(1, a.size - 1).split(\"\").sort.reduce(:==, b.slice(1,\
    \ b.size - 1).split(\"\").sort) == false and a.slice(1, a.size - 1).split(\"\"\
    ).sort.reduce(:==, b.slice(1, b.size - 1).split(\"\").sort) == false and a.slice(1,\
    \ a.size - 1).split(\"\").sort.reduce(:==, b.slice(1, b.size - 1).split(\"\").sort)\
    \ == false\nend", '    letters = a.split', "  if a[-1] == b[-1]\n    return true\n\
    \  end\n  b = b[1..-1]\n  a.each do |i|\n    return true if i == b\n  end\n  return\
    \ false\nend", "  a[0][-1] = nil\n  a[0][0..-2] = a[0].dup\n  a[0][-3..-1] = a[0].dup\n\
    \  b.each_index { |i|\n    a[0].slice!(0...i)\n  }\n  a.each_index { |i|\n   \
    \ a[0].slice!(i...-1)\n  }\n  return (a.last =~ b)\nend", "  if a.length == 0\
    \ or b.length == 0\n    return false\n  else\n    a_words = a.split\n    b_words\
    \ = b.split\n    a_iter = a_words.each\n    b_iter = b_words.each\n    return\
    \ a_iter.all? { |x| b_iter.all? { |y| x =~ /#{Regexp.escape(y[1..-1])}/i } }\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,substring |>\n<| c |>\nA variation on this\
    \ solution is to use a Hash instead of a nested iteration. `h = {}; a.split; b.split.each\
    \ { |w| h[w[1..-1]] = true } return !h.empty?`\n<|/ c |>\n<| a |>\nMy original\
    \ answer here was for Ruby 1.8.7 or earlier which has a bug in String#scan.\n\
    I've rewritten my answer here. It has a few advantages. One is that it works for\
    \ any Ruby version from 1.8.6 to 1.9.2.\nThe second advantage is that it only\
    \ uses one loop.\nCode\n<code>", "    return (a.downcase =~ /#{b}/ or b.downcase\
    \ =~ /#{a}/)\nend\n</code>\n<|/ a tags=ruby,arrays,algorithm,string |>\n<| c |>\n\
    That worked, but it doesn't allow for repetition of the same letter. For example,\
    \ the string \"abcbc\" returns true when it should return false. My apologies\
    \ for not posting that as well.\n<|/ c |>\n<| c |>\n: Do you know why this wouldn't\
    \ work with repetition of the same letter? Because the problem I ran into when\
    \ I ran the function you gave me is when I used the string \"abcbc\".\n<|/ c |>\n\
    <| c |>\n: I just saw what you said about the repetition of the same letter. Edited\
    \ my answer to correct it!\n<|/ c |>\n<| c |>\nThank you! I appreciate the help!\n\
    <|/ c |>\n<| c |>\nHi again, could you explain your algorithm? I have a hard time\
    \ understanding it. I've been trying to implement a solution in ruby for a while\
    \ now, but I can't seem to wrap my head around it. Thank you!\n<|/ c |>\n<| a\
    \ dscore=2 |>\nThe solution using Hash class - \n<code>", "  a.split(\"\").each_with_index\
    \ { |x,i| return true if b.include?(x) } \n  true\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nYou could also use a regex instead of split. e.g. `a.match(/\\\
    b#{b}\\b/)`\n<|/ c |>\n<| c |>\n: That's probably the best way to do it, but that\
    \ doesn't solve the OP's question. :-)\n<|/ c |>\n<| c |>\nThanks guys ... I was\
    \ thinking of this problem in a different way but this one is really nice :)\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>", "  case a\n  when b.empty?\n    true\n  when\
    \ a[0] == b[0]\n    cycpattern_check(a[1..-1], b)\n  else\n    false\n  end\n\
    end", "  return a.include?(b) ||\n    b.include?(a) ||\n    a.include?(b) ||\n\
    \    b.include?(a) ||\n    a.include?(b) ||\n    b.include?(a) ||\n    a.include?(b)\
    \ ||\n    b.include?(a) ||\n    a.include?(b) ||\n    b.include?(a) ||\n    a.include?(b)\
    \ ||\n    b.include?(a) ||\n    a.include?(b) ||\n    b.include?(a) ||\n    a.include?(b)\
    \ ||\n    b.include?(a) ||\n    a.include?(b) ||\n    b.include?(a) ||\n    a.include?(b)\
    \ ||\n    b.include?(a) ||\n    a.include?(b) ||\n    b.include?(a) ||\n    a.include?(b)\
    \ ||\n    b.include?(a) ||\n    a.include?(b) ||\n    b.include?(a) ||\n    a.include?(b)\
    \ ||\n    b.include?(a) ||\n    a.include?(b) ||\n    b.include?(a)\nend", " \
    \ a = a.to_s.chars.map(&:downcase).join\n  b = b.to_s.chars.map(&:downcase).join\n\
    \  a[-b.length..-1] == b\nend", "  if a.length == 0 or b.length == 0\n    return\
    \ false\n  pattern = a[0...(b.length-1)]\n  patterns = a.chars.zip b.chars\n \
    \ patterns.all? do |pattern|\n    a.chars.each do |l|\n      if pattern.include?\
    \ l\n        false\n      end\n    end\n  end\nend", "    a.gsub!(/\\s+/, \"\"\
    ) \n    b.gsub!(/\\s+/, \"\") \n    a.each_char.each_with_index do |x, i|\n  \
    \      if b.include?(x)\n            return true\n        end\n    end\n    return\
    \ false\nend\n</code>\nEDIT\nIn response to the comments, here is a different\
    \ way of implementing it.\n<code>", "  return false if a.size != b.size || a.include?(b)\
    \ || b.include?(a) else\n    a.chars.to_set.subset?(b.chars.to_set.to_a)\nend",
  "  return a.include?(b) || b.include?(a)\nend", "  a.downcase!\n  b.downcase!\n\
    \  a.length>1 && b.length>1 ? (a[0...a.length-1], b[0...b.length-1]).each do |e|\
    \ \n    a.include?(e) || b.include?(e) ? true : false \n  end\nrescue ArgumentError\
    \ \n  false\nend", "    pattern = 0\n    while pattern == 0\n        if a.length\
    \ > b.length\n            pattern = a.length\n        else\n            pattern\
    \ = b.length\n        end\n    end\n    if pattern == 0\n        return false\n\
    \    else\n        pattern = a.length\n    end\n    i = 0\n    while i < pattern\n\
    \        if b.include? a[i..pattern]\n            return true\n        end\n \
    \       i += 1\n    end\n    return false\nend", "  return a.gsub(/[#{b}]/, \"\
    \\\\1\").gsub(/[#{a}]/, \"\\\\1\") == a\nend", "  # create empty list to store\
    \ our return value if any rotations exist\n  res = []\n  # get the number of times\
    \ a sub string appears in a word\n  substr_count = a.split(b).count(\"a\")\n \
    \ # if there are any rotations then test them\n  if substr_count > 0\n    # go\
    \ through each string one character at a time\n    a.each_byte { |c| # get each\
    \ character\n      # get the rotation of the character, if its bigger than zero\
    \ then it's a rotation\n      rot_count = c.rotate(b).length\n      # if rotated\
    \ sub string exists then add it to our return list\n      if rot_count > 0\n \
    \       res << c\n      end\n    }\n  end\n  # if we get back any rotations then\
    \ there are some\n  return res.any?\nend", "  pattern = a + \"|\" + b\n  a = a.downcase\n\
    \  b = b.downcase\n  pattern = pattern.split(\"|\")\n  a = a.split(\"|\")\n  b\
    \ = b.split(\"|\")\n  pattern = pattern.collect{|x| x.downcase}\n  a = a.collect{|x|\
    \ x.downcase}\n  b = b.collect{|x| x.downcase}\n  if(pattern == a || pattern ==\
    \ b || pattern.size == a.size || pattern.size == b.size)\n    return true\n  else\n\
    \    return false\n  end\nend", "  a.chars.sort.each do |x|\n    a.chars.sort.each\
    \ do |y|\n      return true if a.chars.include? y  if x != y && x != y && a.chars.any?\
    \ {|z| z == y || z.include? y}\n    end\n  end\n  return true\nend\n</code>\n\
    <|/ a |>\n<| a |>\nHere is a very quick solution in Ruby 1.9.2. It's a little\
    \ naive but it does the job. \n<code>", "  for i in (0...a.length)\n    if cycpattern_check_sub(a[0..i],\
    \ b[0..i]) then return true\n  end\n  return false\nend", "  a.gsub(/[^a-z]/i,\
    \ '').downcase.include?(b.gsub(/[^a-z]/i, '').downcase)\nend\n</code>\n<|/ a |>\n\
    <| c |>\nJust a reminder, Ruby has a built-in `include?` method, no need to use\
    \ `downcase` here: `'foo'.include?('FOO')` is true and `'FOO'.include?('foo')`\
    \ is true.\n<|/ c |>\n<| c |>\nYes, I know. :) It just helps me to learn Ruby\
    \ a bit better. Thanks!\n<|/ c |>\n<| c |>\nI'm sorry I misspoke, I meant to say\
    \ that you can use the `include?` method on any string object.  It is a method\
    \ on all strings.  It exists to make Ruby code more concise and readable.\n<|/\
    \ c |>\n<| c |>\nYes, you're right. I forgot about that. Thanks!\n<|/ c |>\n<|\
    \ a tags=ruby,regex |>\n<code>", "  return a.include?(b) || b.include?(a) || a.include?(b)\
    \ && b.include?(a) || a.include?(b) && b.include?(a) && a.include?(b) || a.include?(b)\
    \ && b.include?(a) && b.include?(a) && a.include?(b)\nend\n</cell>\n<cell>", " \
    \ a.downcase!\n  b.downcase!\n  a.split(\"\").each do |ch|\n    b.split(\"\").each\
    \ do |bch|\n      return true if b.start_with? ch\n      return true if b.end_with?\
    \ bch\n    end\n  end\n  false\nend", "  return a.to_s.include?(b.to_s) ||\n \
    \   a.to_s.include?(b.to_s.reverse) ||\n    a.to_s.include?(b.to_s.reverse.downcase)\
    \ ||\n    a.to_s.include?(b.to_s.reverse.downcase.gsub!(/[^a-zA-Z]/, '').upcase)\n\
    end", "  return true if b or b.chars.cycle.all? { |c| a.include? c }\n  false\n\
    end\n</code>\n<|/ a tags=string,ruby,pattern-matching dscore=3 |>\n<| a dscore=3\
    \ |>\n<code>", "  return a.include?(b) || a.include?(b.downcase) or b.include?(a.downcase)\n\
    end\n</cell>\n<cell>", "  if a.size == 0 or b.size < 2\n    false\n  end\n  if\
    \ a.size == 1 or b.size == 2\n    true\n  end\n  mid = (b.size - 1) / 2\n  if\
    \ a.chars.to_a.include? b.chars.to_a[0]\n    cycpattern_check(a[mid..-1], b[0...mid])\n\
    \  else\n    false\n  end\nend\n</code>\nAnd then you can do this:\n<code>", " \
    \ return true if (a.gsub(b, \"\") == \"\" || a.gsub(b, a) == a) else false\nend",
  "  if a == \".\" \n    puts \"true\"\n  else\n    chars = a.split('')\n    chars2\
    \ = b.split('')\n    chars3=[]\n    chars4=[]\n    chars5=[]", "  a = ''.chars.to_a\n\
    \  b = ''.chars.to_a\n  if a.include?(b[0]) or b.include?(a[0])\n    a[0] += b[0]\n\
    \    return false\n  else\n    if a.size > 1\n      a1 = a.slice!(0, a.length-1)\n\
    \      b1 = b.slice!(0, b.length-1)\n      return cycpattern_check(a1, b1) or\
    \ cycpattern_check(a1, b)\n    else\n      return true\n    end\n  end\nend\n\
    </code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3,ruby-on-rails-4,ruby-on-rails-3.2\
    \ |>\n<| c |>\nThis is great, thank you. I really like the use of slice!\n<|/\
    \ c |>\n<| c |>\nThis solution doesn't work when the first and second strings\
    \ differ in length\n<|/ c |>\n<| c |>\nIt will work for strings with same length\n\
    <|/ c |>\n<| c |>\n: it won't work for strings of different lengths. Try it with\
    \ `\"abcdefghij\"` and `\"abcde\"`.\n<|/ c |>\n<| c |>\nThe question says \"two\
    \ words\". That's not even two words. It says \"two letters\". You're correct\
    \ that it won't work for the latter case (it also doesn't work for `\"ab\"` and\
    \ `\"ab\"`). That is not the case for the former case.\n<|/ c |>\n<| a dscore=2\
    \ |>\nI wouldn't use a regular expression to do this kind of thing. As you've\
    \ noticed it's too complicated and will always fail to do what you want if the\
    \ words are too different lengths.\nA naive implementation would look like:\n\
    <code>", "  # Write your code here.\n  if a.size != b.size\n    false\n  else\n\
    \    a.each_char do |c|\n      b[a.index(c)..-1].each_char do |c2|\n        if\
    \ c == c2\n          true\n        end\n      end\n    end\n  end\nend", "  a.split(\"\
    \").each do |x|\n    b.split(\"\").each do |y|\n      return true if y.include?(x)\n\
    \    end\n  end\nend\n</code>\n<|/ a dscore=3 |>\n<| a tags=ruby |>\nI used the\
    \ code above and ran into a problem if one of the arrays is nil. My solution was\
    \ to do the following:\n<code>", "    a.downcase!\n    b.downcase!\n    a.length==b.length\
    \ && a.chars.zip(b.chars).all? {|c1,c2| c1==c2}\nend", "  first_word = a.split(\"\
    \")\n  second_word = b.split(\"\")\n  first_word.each do |el|\n    second_word.each\
    \ do |eel|\n      first_word_copy = first_word.clone\n      second_word_copy =\
    \ second_word.clone\n      if el == eel\n        # copy the array for iteration\n\
    \        first_word_copy << el\n        second_word_copy << eel\n        break\
    \ \n      end\n    end\n  end\n  false\nend", "  a_len, b_len = lengths(a), lengths(b)\n\
    \  \n  # check if both strings are same length\n  if a_len != b_len\n    return\
    \ false\n  \n  # check if both strings are same number of chars\n  if a_len ==\
    \ 0\n    return true\n  \n  # check if there is any rotation of b that is not\
    \ a substring of a\n  b_chars    = get_chars(b)\n  b_chars    = b_chars.to_a\n\
    \  a_chars    = get_chars(a)\n  a_chars    = a_chars.to_a\n  a_chars.each do |c|\n\
    \    if b_chars.include?(c)\n      return false\n    end\n  end\n  \n  return\
    \ true\nend", "  a_len = a.length\n  b_len = b.length\n  a_ptr = 0\n  b_ptr =\
    \ 0\n  \n  # Compare each character in strings to see if they are the same\n \
    \ while a_ptr < a_len and b_ptr < b_len\n    if a.at(a_ptr) == b.at(b_ptr)\n \
    \     a_ptr += 1\n      b_ptr += 1\n    else\n      if a.at(a_ptr) < b.at(b_ptr)\n\
    \        a_ptr += 1\n      else\n        b_ptr += 1\n    end\n  end\n  \n  return\
    \ a_ptr < a_len and b_ptr < b_len\nend", "  first = a[0]\n  last = a[-1]\n  mid\
    \ = a[-2]\n  if last == mid and first == mid\n    return true\n  for i in (0..(last.length\
    \ - 1)) # go through every char from middle to end of string\n    if a[-i] ==\
    \ first && a[-i - 2] == last && a[-i - 1] == mid\n      return true\n  return\
    \ false\nend", "  a, b = a.downcase, b.downcase\n  return false if a.length <\
    \ b.length || (a != b && a.include?(b)) || b.include?(a) || a.length > b.length\
    \ # return true if one is a substring of the other\nend", "  a,b = a.chars, b.chars\n\
    \  a.rotate(b.size, :right).reduce(:==)\nend", "  a.chars.each { |c|\n    b.chars.each\
    \ { |c|\n      break if c == c\n      return false if b.start_with?(c)\n    }\n\
    \  }\n  true\nend", "    a.gsub!('\\B\\w*', '', b)\n    b.gsub!('\\B\\w*', '',\
    \ a)\n    return (a==b)\nend\nend", "  a = a.downcase\n  b = b.downcase\n  return\
    \ false if a.size < b.size # return true if b contains more characters\n  a_size,\
    \ b_size = a.size, b.size\n  for i in 0..(a_size-1)\n    return true if b.start_with?(a[i],\
    \ i+1) # return true if the letter b starts with an even index in the a\n    b.slice!(i,\
    \ b_size-i) if b_size > i\n  end\n  true\nend\n</cell>\n<code language=julia-1.0>\n\
    cycpattern_check.([\"abcd\", \"abd\"], \"abd\")\n</cell>\n<code language=julia-1.0>\n\
    cycpattern_check.([\"abcd\", \"abd\"], \"efd\") # return false\n</cell>\n<code\
    \ language=julia-1.0>\ncycpattern_check.([\"abcd\", \"abd\"], \"bcde\") # return\
    \ true\n</cell>\n<code language=julia-1.0>\ncycpattern_check.([\"himenss\", \"\
    simen\"], \" simen\") # return true\n</cell>\n<code language=julia-1.0>\ncycpattern_check.([\"\
    himenss\", \"simen\"], \" mis\") # return false\n</cell>\n<code language=julia-1.0>\n\
    cycpattern_check.([\"himenss\", \"simen\"], \" m\") # return true\n</cell>\n<code\
    \ language=julia-1.0>\ncycpattern_check.([\"himenss\", \"simen\"], \" m\") # return\
    \ false\n</cell>\n<text>\nReverse String Test\nWrite a function that takes a string\
    \ and returns the string reversed.", "  a = a.split(//).map{|e| e.to_i}\n  b =\
    \ b.split(//).map{|e| e.to_i}\n  a.zip(b.rotate(-1).take_while {|e,f| f < e}).all?\
    \ do |(c,d)|\n    a.first > d || d < a.last || (a.first == d && d != c)\n  end\n\
    end\n</code>\n<|/ a dscore=0 tags=substring,arrays,ruby,sorting |>\n<| c |>\n\
    I don't think this is correct, since it fails the test `cycpattern_check.call(\"\
    efef\", \"eeff\")`\n<|/ c |>\n<| c |>\nYes, but that is a little tricky to get\
    \ right with a simple `==` operator. I'll update my answer.\n<|/ c |>\n<| c |>\n\
    That would indeed fail.\n<|/ c |>\n<| c |>\n: That's a good point. I fixed my\
    \ answer.\n<|/ c |>\n<| c |>\nThat's still wrong - it fails even `cycpattern_check.call(\"\
    himenss\", \"simen\")`\n<|/ c |>\n<| a tags=substring,arrays,ruby,sorting |>\n\
    This code doesn't require any extra space or time complexity.\n<code>", "  a1\
    \ = a.downcase\n  a2 = a1.gsub(/[aeiouy]/, '')\n  a3 = a2.gsub(/[aeiouy]/, '')\n\
    \  a4 = a3.gsub(/[aeiou]/, '')\n  a5 = a4.gsub(/[aeiou]/, '')\n  a6 = a5.gsub(/[aeiou]/,\
    \ '')\n  a7 = a6.gsub(/[aeiou]/, '')\n  a8 = a7.gsub(/[aeiou]/, '')\n  a9 = a8.gsub(/[aeiou]/,\
    \ '')\n  a10 = a9.gsub(/[aeiou]/, '')\n  a11 = a10.gsub(/[aeiou]/, '')\n  a12\
    \ = a11.gsub(/[aeiou]/, '')\n  a13 = a12.gsub(/[aeiou]/, '')\n  a14 = a13.gsub(/[aeiou]/,\
    \ '')\n  a15 = a14.gsub(/[aeiou]/, '')\n  a16 = a15.gsub(/[aeiou]/, '')\n  a17\
    \ = a16.gsub(/[aeiou]/, '')\n  a18 = a17.gsub(/[aeiou]/, '')\n  a19 = a18.gsub(/[aeiou]/,\
    \ '')\n  a20 = a19.gsub(/[aeiou]/, '')\n  a21 = a20.gsub(/[aeiou]/, '')\n  a22\
    \ = a21.gsub(/[aeiou]/, '')\n  a23 = a22.gsub(/[aeiou]/, '')\n  a24 = a23.gsub(/[aeiou]/,\
    \ '')\n  a25 = a24.gsub(/[aeiou]/, '')\n  a26 = a25.gsub(/[aeiou]/, '')\n  a27\
    \ = a26.gsub(/[aeiou]/, '')\n  a28 = a27.gsub(/[aeiou]/, '')\n  a29 = a28.gsub(/[aeiou]/,\
    \ '')\n  a30 = a29.gsub(/[aeiou]/, '')\n  a31 = a30.gsub(/[aeiou]/, '')\n  a32\
    \ = a31.gsub(/[aeiou]/, '')\n  a33 = a32.gsub(/[aeiou]/, '')\n  a34 = a33.gsub(/[aeiou]/,\
    \ '')\n  a35 = a34.gsub(/[aeiou]/, '')\n  a36 = a35.gsub(/[aeiou]/, '')\n  a37\
    \ = a36.gsub(/[aeiou]/, '')\n  a38", "  a_reversed = b.split(\"\").reverse.join\
    \ # To make it easier to find substrings\n  b_reversed = a.split(\"\").reverse.join\n\
    \  \n  a_substrings = a.split # To make it easier to find substrings\n  b_substrings\
    \ = b.split", "    lena = a.length\n    lenb = b.length\n    return lena <= lenb\
    \ and\n        (\n        (a.split(\"\").each_with_index.any? { |x, i| b[i] ===\
    \ x }) or\n        (a.split(\"\").each_with_index.any? { |x, i| b[-i..-1] ===\
    \ x })\n        )\nend\n</code>\n<|/ a dscore=3 tags=ruby,algorithm,string |>\n\
    <| c |>\nThis fails for `cycpattern_check(\"xbcd\", \"xbc\")` because \"xbc\"\
    \ does not appear in the second word \"xbcd\", but does appear in the first word\
    \ \"xbc\".\n<|/ c |>\n<| a tags=ruby,algorithm,string |>\nThis is my solution\
    \ to find out if the second string is substring of first string:\n<code>", " \
    \ result = false\n  \n  a.chars.each do |c|\n    b.chars.each do |d|\n      break\
    \ if c == d\n      result |= (b[b.size - 1] == c) | (a[a.size - 1] == d) | (c\
    \ != d)\n    end\n  end\n  \n  result\nend\n</code>\n<|/ a |>\n<| c |>\nThank\
    \ you for the answer!  It worked for me. :)\n<|/ c |>\n<| a tags=ruby,arrays |>\n\
    This is a variation that returns true if either of the two words is a substring\
    \ in the other and both words are in the same order of characters. \n<code>",
  "  a.split(\"\").each do |c|\n    b.split(\"\").each do |d|\n      if d == c or\
    \ b.include?(d) or a.include?(d)\n        return true\n      end\n    end\n  end\n\
    \  return false\nend", "    a.length\n    b.length\n    a.reverse\n    b.reverse\n\
    \    i = 0\n    j = 0\n    while i < a.length || j < b.length\n        break unless\
    \ a[i].eql? b[j]\n        i += 1\n        j += 1\n    end\n    a[i] == b[j]\n\
    end", "  return false if a.length == 0 or b.length == 0 else true if a.length\
    \ == b.length && a.include?(b) || b.include?(a) || a.include?(b) || b.include?(a)\n\
    end", "  return (a..b).include?(cycpattern(a..b))\nend", "  a = a.downcase\n \
    \ b = b.downcase\n  b.succ! if b.last == 'z'\n  b.last = 'z'\n  a[0] = a[0].chop\n\
    \  b[0] = b[0].chop\n  a.succ! if a.last == 'z'\n  a.last = 'z'\n  b.succ! if\
    \ b.last == 'z'\n  \n  a = a.succ\n  b = b.succ\n  \n  if a.length > b.length\n\
    \    true\n  elsif a.length < b.length\n    false\n  else\n    a.last = 'z'\n\
    \    b.last = 'z'\n    \n    i = 0\n    a.succ!\n    while i < a.length and b[0]\
    \ <= a[i]\n      i += 1\n    i = 0\n    b.succ!\n    while i < b.length and a[0]\
    \ <= b[i]\n      i += 1\n    if i == a.length\n      return true\n    elsif i\
    \ == b.length\n      return false\n    end\n  end\nend", "  a_length = a.size\n\
    \  b_length = b.size\n  return a_length < b_length ? false : a.chars.sort.each\
    \ do |char|\n    found = b.chars.find {|c| c == char }\n    return false if !found\n\
    \    found[0...b_length].chars.sort.each do |char2|\n      return true if char\
    \ == char2\n    end\n  end\nend", "  a.gsub!(/[^a-zA-Z]/, '')\n  b.gsub!(/[^a-zA-Z]/,\
    \ '')\n  \n  a.length >= b.length ? b[a] && a[b] && a[b] && a[b] && a[b] && a[b]\
    \ && a[b] && a[b] && a[b] && a[b] ? true : false: false\nend", "  a = a.downcase\n\
    \  b = b.downcase\n  if a == b\n    return true\n  else if a[0, b.length] == b\n\
    \    return true\n  else\n    return false\nend\n</pre>\n    </article>\n    <article\
    \ id=\"ebak3\" class=\"entry\">\n      <h2 class=\"entry-title\">ebak3</h2>\n\
    \      <pre class=\"entry-content\">", "  return b.match(a) || a.match(b)\nend",
  "\tb = b.reverse\n\ta_index = a.index(0)\n\tb_index = 0\n\tfor i in 1..a.length\n\
    \t\tif a.charAt(i) == b.charAt(0)\n\t\t\tif i == b.length\n\t\t\t\treturn true\n\
    \t\t\tb_index += 1\n\t\telsif a.charAt(i) != b.charAt(0)\n\t\t\tbreak\n\t\telse\
    \ if i == b.length\n\t\t\treturn false\n\t\telse\n\t\t\ta_index += 1\n\tend\n\t\
    return true\nend", "\treturn false\nend", "  a.to_s.split(\"\").sort.each do |x|\n\
    \    b.to_s.split(\"\").sort.each do |y|\n      return true if x =~ /#{y}/\n \
    \   end\n  end\n  return false\nend\n</code>\n<|/ a dscore=1 |>\n<| a |>\n<code>",
  "  if b.size > 0\n    i = 0\n    j = b.size - 1\n    while i < a.length\n      if\
    \ a.charAt(i) == b.charAt(j)\n        if i == j\n          return true\n     \
    \   i += 1\n        j -= 1\n      else\n        if j == 0\n          return false\n\
    \        i += 1\n      end\n    end\n  end\n  return false\nend", "  a1 = Array.new(a.length).to_a\n\
    \  a2 = Array.new(a.length).to_a\n  a1.each_index { |i| a2[i] = a[i] }\n  a2.rotate!\n\
    \  a2.each_index { |i| a1[i] = a[i] }\n  return a2[0...a1.length].include?(a1)\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis is very clever and has some nice\
    \ insights. Thanks!\n<|/ c |>\n<| c |>\nThis works on all examples above, but\
    \ as soon as the word has an odd number of characters, it gives an invalid argument\
    \ error. How can we avoid this?\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  a = a.gsub(/(?=[^a-z])/,\
    \ \"*\")\n  b = b.gsub(/(?=[^a-z])/, \"*\")\n  a = a.gsub(/(?<=[^a-z])/, \"*\"\
    ).gsub(/(?=[^a-z]*[a-z])/, \"*\")\n  b = b.gsub(/(?<=[^a-z])/, \"*\").gsub(/(?=[^a-z]*[a-z])/,\
    \ \"*\")\n  a = a.gsub(/(?<=[^a-z])/, \"*\").gsub(/(?=[^a-z]*[a-z])/, \"*\")\n\
    \  b = b.gsub(/(?<=[^a-z])/, \"*\").gsub(/(?=[^a-z]*[a-z])/, \"*\")\n  \n  a.scan(b)\
    \ { |s, e| return true if s.include? e }\n  false\nend", "  a.gsub!(/[^a-zA-Z0-9]+/,\
    \ '')\n  b.gsub!(/[^a-zA-Z0-9]+/, '')\n  word1 = a.split('')\n  word2 = b.split('')\n\
    \  if word1.length != word2.length\n    return false\n  end\n  rot1 = word1.map\
    \ { |i| word2.rotate! i }\n  rot2 = word2.map { |i| word1.rotate! i }\n  rot1\
    \ & rot2\nend\n</code>\n<|/ a dscore=1 tags=ruby,algorithm |>\n<| c |>\nThe question\
    \ is about Ruby, not Python.\n<|/ c |>\n<| a dscore=1 |>\nHere's a brute-force\
    \ solution that I wrote in Python. It has two parts: one that can find the rotated\
    \ position of a substring in another string, and a second one that can count the\
    \ number of rotations that would result in the target string. Here's an example\
    \ of the first part:\n<code>", "  return a.include?(b) || a.gsub(b, \"*\").include?(a.sub(b,\
    \ \"*\")) # check if b is a substring of a\nend", "  return a.scan(/\\w*|./).any?\
    \ { |word| b.scan(/\\w*|./).any? { |word| word.include?(word) } }\nend", "  a[0]\
    \ <=> b[0] || cycpattern_check_rots(a, b, 2) || cycpattern_check_rots(a, b, 1)\
    \ || cycpattern_check_rots(a, b, 3)\nend", "  return a.gsub(/[#{b}]/, '') =~ /b/\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\n: Thanks for that suggestion! I added\
    \ a note in the code above.\n<|/ c |>\n<| a dscore=2 tags=ruby |>\n<code>", " \
    \ a.to_s.split(//).map {|word| b.split(//).each {|w| return true if w == word}}.all?{|w|\
    \ w == true}\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "\t\
    a.gsub(/[xy]/, \"\").scan(/./) do |c|\n\t\tb = b.to_s.dup\n\t\tb.gsub(/[xy]/,\
    \ \"\").scan(/./) do |c|\n\t\t\tb.rotation.each do |x|\n\t\t\t\tb.insert(x, a.length)\n\
    \t\t\t\ta = a[0...x]\n\t\t\t\tbreak if b.index(c.join)\n\t\t\tend\n\t\t\tbreak\
    \ if b.index(c.join)\n\t\tend\n\t\tbreak if b.index(c.join)\n\tend\n\treturn a.index(b.join)\n\
    end", "\ta.split(\"\").each do |letter|\n\t\tb.split(\"\").each do |letter2|\n\
    \t\t\tbreak if letter == letter2\n\t\t\tbreak if letter == letter2.downcase\n\t\
    \tend\n\tend\n\treturn true unless b.gsub!('aeiou', '[aeiou]').gsub!('l', '[aeiou]')\n\
    \tb = b.reverse if b.size > 2\n\tb.split(\"\").each do |letter2|\n\t\tletter2\
    \ = letter2.upcase if letter2.upcase != letter2\n\t\tbreak if a == \"[#{b}]#{letter2}[#{b}]\"\
    \ || (letter2 == \"L\" && a == \"[#{b}]#{letter2}[#{b}]\")\n\tend\n\treturn false\n\
    end", "  a.downcase!\n  b.downcase!\n  a.chars.uniq.each do |char|\n    if b.include?(char)\n\
    \      true\n      next\n    end\n    break\n  end\n  false\nend", "  a.gsub(/(.)(?=(#{b}))/,\
    \ '\\1') <= b.size \nend", "  return a =~ b or a =~ b.downcase or a =~ b.upcase\
    \ or a =~ b.gsub(/[\\W_]/, \"\")\nend", "  a = a.split\n  b = b.split\n  (a.length\
    \ <= 2 ? a : a)[1..-1].each do |x|\n    (b = b.rotate).shift if b.include? x\n\
    \    next if b.nil?\n    b[a..-1].each do |y|\n      if y.start_with? x\n    \
    \    true\n      end\n    end\n  end\n  false\nend", "  (a.length != b.length)\
    \ || (a =~ b) || (b =~ a)\nend", "    a.each_char{|w|\n        if b.include? w\n\
    \            return true\n        end\n    }\n    return false\nend", "  word1,\
    \ word2 = a.split(\"\"), b.split(\"\")\n  results = []\n  for i in 1..word1.length\n\
    \    match = false\n    for j in 1..word2.length\n      if word2[j] == word1[i-1]\n\
    \        match = true\n        break\n    break if match then\n    results.push(word1.slice(i,\
    \ word1.length))\n  end\n  return false if results.size == 0\n  word = word1[1..word1.length]\n\
    \  for i in results.length\n    if word == word2[0...i]\n      return true\n \
    \   end\n  end\n  return false\nend\n</cell>\n<text>\nCyclic Patterns\nNow that\
    \ you've got the word list loaded and you're ready to do some fun tests, let's\
    \ see what you can do. The below function will take in a word and it will return\
    \ an array of all the permutations of the given word. Let's test it out.", " \
    \   a.length>0 && b.length>0 && a.length<b.length && 0..b.length-1==a.each_cons(2).to_a\n\
    end", "  a = (a + \"#\").downcase\n  b = (b + \"#\").downcase\n  (a <=> b) ==\
    \ 0 or (a.chars.any? { |x| b.include? x }) == true\nend", "  return a =~ b or\
    \ b =~ a\nend", "  a = a.split(//)\n  b = b.split(//)", "  return true if b.chars.any?\
    \ { |c| a.include?(c) }\n  false\nend", "  return false if a.size != b.size ||\
    \ a.include?(b) || b.include?(a) end\nend\n</code>\n<|/ a tags=ruby,substring,algorithm,string,arrays\
    \ |>\n<| a dscore=0 tags=ruby,substring,algorithm,string,arrays |>\nHere is another\
    \ solution that does not use any Ruby code at all:\n<code>", "  a = a.downcase\n\
    \  b = b.downcase\n  (a.length >= b.length) and (a[0...a.length-1] == b) or (a[0...b.length-1]\
    \ == b) && a[1...a.length] == b\nend\n</cell>\n<cell>", "  word1 = a.split(\"\"\
    )\n  word2 = b.split(\"\")\n  result = 0\n  for i in 0...(word1.length-1)\n  \
    \  if word1[i] == word2[i] then result += 1 else result\n  end\n  return result\
    \ == 0\nend", "    a.downcase!\n    b.downcase!\n    return (b =~ /^#{a.split(\"\
    \").each_cons(2).map(&:join)}$/) ? (a =~ /^#{b.split(\"\").each_cons(2).map(&:join)}$/)\
    \ : false\nend\n</code>\n<|/ a |>\n<| a tags=ruby |>\nI'm sure this is a terrible\
    \ idea, but here's an implementation:\n<code>", "    words = a.split(\"\").map(&:to_i)\n\
    \    words << b.split(\"\").map(&:to_i)\n    words.any? do |word|\n        !a.index(word).nil?\
    \ || !b.index(word).nil?\n    end\nend\n</code>\n<|/ a tags=ruby |>\n<| a |>\n\
    The solution is based on string substring and index check\n<code>", "  return\
    \ a.split(\"\").map{|c|c==b}.all?\nend\n</code>\n<|/ a tags=string,ruby dscore=1\
    \ |>\n<| a |>\n<code>", "  # Your code here\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nThanks! I'll try this out!\n<|/ c |>\n<| a |>\nMy solution is to loop\
    \ through each character in the string and check whether it matches any element\
    \ in the array. I've used each_char to make it easy to read the string. I'm also\
    \ using include? to check and avoid duplicate character comparisons.\n<code>",
  "  a.gsub!(/[^a-zA-Z]/, \"x\")\n  b.gsub!(/[^a-zA-Z]/, \"x\")\n  a.downcase!\n \
    \ b.downcase!", "  a.gsub!(/\\s+/, \"\") if a.size > 0\n  b.gsub!(/\\s+/, \"\"\
    ) if b.size > 0\n  if a.include? b\n    return true\n  elsif b.include? a\n  \
    \  return true\n  elsif a.include?(b.chars.reverse.first(10).join)\n    return\
    \ true\n  elsif b.include?(a.chars.reverse.first(10).join)\n    return true\n\
    \  end\n  return false\nend", "  first_word = a.gsub(/[^a-zA-Z ]+/,'').downcase\n\
    \  second_word = b.gsub(/[^a-zA-Z ]+/,'').downcase\n  return !(first_word.length==0\
    \ || second_word.length==0) && first_word.gsub(/[^a-zA-Z ]+/,'').downcase.include?(second_word.gsub(/[^a-zA-Z\
    \ ]+/,'').downcase)\nend\n</cell>\n<cell>", "  a_rev = a.reverse\n  b_rev = b.reverse\n\
    \  return a.each_char.any? do |x|\n    a.each_char.all? do |y|\n      b_rev.include?\
    \ y ? x : a_rev.include? y\n    end\n  end\nend\n</code>\nI tested the above with\
    \ some strings and it seems to work correctly.\n<|/ a |>\n<| c |>\nI like the\
    \ idea, and would like to see how it compares to other solutions. As for performance,\
    \ I ran it against both my original code and the accepted answer and found that\
    \ `cycpattern_check` is slightly faster than the other solutions. I suspect the\
    \ accepted answer is much less performant because it builds up a string for every\
    \ character in each word. In the case of my code, I use `each_char` instead of\
    \ `each` because it is slightly faster (it only needs to look up each character\
    \ once), but it makes the code even slower.\n<|/ c |>\n<| c |>\n: Interesting,\
    \ I did some quick benchmarking, and it seems that my code is much faster indeed.\
    \ I wonder why, or perhaps it's the `each` vs `each_char` that is slowing it down.\n\
    <|/ c |>\n<| a dscore=0 tags=ruby,string,substring |>\n<code>", "  if a.length\
    \ <= b.length\n    a.each_char.with_index.with_index {|c, i| return true if b[i\
    \ % b.length] == c }\n    false\n  else\n    a.each_char.with_index.with_index\
    \ {|c, i| return true if b[i % b.length] == c }\n    true\n  end\nend\n</code>\n\
    <|/ a |>\n<| a dscore=2 tags=ruby |>\n<code>", "  if a == b then return true\n\
    \  \n  if b.length == 0\n    return true\n  \n  index = 0\n  \n  while index <\
    \ a.length\n    if a.substring(index) == b.substring(0, b.length - index).to_s\
    \ then\n      return true\n    end\n    index = index + 1\n  end\n  \n  return\
    \ false\nend", "  a1 = a.split(\"\")\n  b1 = b.split(\"\")\n  if a1.length !=\
    \ b1.length\n    return false\n  b1 = b1.to_a\n  b1.reverse_each\n  b1.each_with_index{|c,i|\n\
    \    if !a1.include?(c)\n      return false\n    end\n  }\n  return true\nend",
  "\ta = a.chars\n\tb = b.chars\n\ta0 = a.length\n\tb0 = b.length\n\tfor i in 0..(a0-1)\n\
    \t\tfor j in 0..(b0-1)\n\t\t\tif a[i] == a[j]\n\t\t\t\ta[i] = nil\n\t\t\tend\n\
    \t\t\tb[j] = nil\n\t\tend\n\tend\n\tfor i in 0..(b0-1)\n\t\tif b[i] == a[i] ||\
    \ a[i] == \"*\"\n\t\t\treturn false\n\t\tend\n\tend\n\treturn true\nend", "  a\
    \ = a.split(\"\")\n  b = b.split(\"\")\n  return false if a.length != b.length\
    \ || a.zip(b).all? { |x,y| !cycpattern_check_helper(x,y) }\n  a.zip(b.rotate(a).zip(a)).all?\
    \ { |x,y,z| cycpattern_check_helper(x,y) && cycpattern_check_helper(z,y) }\nend\n\
    </code>\n<|/ a dscore=1 tags=string,ruby |>\n<| c |>\nThis is a good one, but\
    \ it might be nice to see some explanation of how it works.\n<|/ c |>\n<| c |>\n\
    Thanks, I am new to Ruby and was looking at using Regexp to solve this problem.\
    \ Will have to spend some time understanding your solution though.\n<|/ c |>\n\
    <| c |>\n, good point. I am sure that someone will come up with a better way of\
    \ doing it :)\n<|/ c |>\n<| c |>\nThis solution is pretty cool, but I wonder how\
    \ fast it is compared to something similar in other languages.\n<|/ c |>\n<| a\
    \ |>\nIn Python you could solve this using regular expressions (re).\nUsing regex\
    \ with .match() you can compare the two strings in O(n) (where n is the length\
    \ of the first string).\n<code>\nimport re", "  return a.include? b || b.include?\
    \ a || a.include? b || b.include? a\nend", "  return (a.length >= b.length) ?\
    \ a.include?(b) :\n      b.include?(a)\nend\n</cell>\n<code language=julia-0.5>",
  "  if a && a.size <= 2 && b && a.size > 0 && b && a.size > 0 && b == b[1..-1]\n\
    \    a.chars.zip(b.chars).any?{|x,y| a.include?y}\n  end\nend", "  a_size = a.length\n\
    \  b_size = b.length\n  return a_size >= b_size if b_size >= a_size && a.include?(b)\
    \ else\n    a_size <= b_size if b_size <= a_size &&\n      a.include?(b.reverse)\
    \ ||\n      b.include?(a.reverse)\nend\n</code>\n<|/ a tags=ruby,string,algorithm\
    \ dscore=1 |>\n<| c |>\nThis solution assumes both strings are the same length.\
    \ For example, `\"a\".include?(\"b\") == false`, but `\"a\".include?(\"a\") ==\
    \ true`.\n<|/ c |>\n<| c |>\nThis solution assumes both strings are the same length.\
    \ For example, `\"a\".include?(\"b\") == false`, but `\"a\".include?(\"a\") ==\
    \ true`. That should be stated in the answer, not in the comments.\n<|/ c |>\n\
    <| c |>\nI'm pretty sure that this is what was intended. Do you know a way to\
    \ avoid the problem?\n<|/ c |>\n<| c |>\nThis solution assumes both strings are\
    \ the same length. For example, `\"a\".include?(\"b\") == false`, but `\"a\".include?(\"\
    a\") == true`. That should be stated in the answer, not in the comments.\n<|/\
    \ c |>\n<| c |>\nI have added an edit that handles your example case. I believe\
    \ I explained this in the comments, but I'm adding it here for clarity.\n<|/ c\
    \ |>\n<| a |>\nI think you can do it in three lines of code with regex :\n<code>",
  "  if b.nil? || a.nil?\n    return false\n  end\n  if a.length == 0 || b.length\
    \ == 0\n    return true\n  end\n  \n  x = a.length\n  y = b.length\n  \n  for\
    \ i in 0..(x-y)\n    if a[i] == b[i]\n      continue\n    end\n    return true\n\
    \  end\n  \n  return false\nend", "    # remove any whitespace\n    a = a.gsub(/\\\
    s+/, \"\")\n    b = b.gsub(/\\s+/, \"\")\n    # split the two strings based on\
    \ whitespace\n    a = a.split(/\\s+/)\n    b = b.split(/\\s+/)\n    \n    # loop\
    \ through each character in the longer string\n    a.each do |x|\n        # if\
    \ the character is in the shorter string\n        if b.include?(x)\n         \
    \   # then return false\n            return false\n        else\n            #\
    \ otherwise, return true\n            return true\n        end\n    end\n    \n\
    \    # once we've finished looping through both strings, return false\n    return\
    \ false\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nWhat about \"baa\" and \"bab\"\
    \ ?\n<|/ c |>\n<| c |>\nYeah, sorry, didn't see those cases. I just edited the\
    \ answer.\n<|/ c |>\n<| a dscore=0 |>\nYou can make use of String class and use\
    \ each_char:\n<code>", "  a.split(\"\").each do |x|\n    if b.include?(x) || b.include?(x.reverse)\n\
    \      return true\n    end\n  end\n  return false\nend", "  a.scan(/\\w/) { |i|\
    \ puts i }\n  b.scan(/\\w/) { |i| puts i }\n  return (a.size==b.size)\nend", " \
    \ a1, a2 = a.to_a, a.to_a.length\n  b1, b2 = b.to_b, b.to_b.length\n  \n  return\
    \ a2 > 0 && a2 > b2 && a.sub(a1, a1 - a2).include?(b.to_b) || b.sub(b1, b1 - b2).include?(a.to_a)\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThank you, i appreciate your effort.\
    \ But I need a solution to do it by recursion.\n<|/ c |>\n<| c |>\nI updated my\
    \ answer with your solution using recursion.\n<|/ c |>\n<| a tags=ruby |>\nYou\
    \ could use a recursive solution for this. I chose to do this by finding the longest\
    \ common prefix first, and then working on that.\n<code>", "  a_arr = a.split(//)\n\
    \  b_arr = b.split(//)\n  return a_arr.include?(b_arr[0]) && b_arr.include?(a_arr[0])\
    \ && (a_arr.length < b_arr.length || b_arr.length < a_arr.length)\nend", "  words\
    \ = []\n  a.split(\"\").each do |x|\n    words << x if b.include?(x)\n  end\n\
    \  words.include?(b)\nend", "    a.downcase!\n    b.downcase!\n    return true\
    \ if a.length == b.length && a.include?(b) && a.include?(b.first) ? true : false\
    \ && b.include?(a) && a.include?(b.last) ? true : false\nend", "    a.downcase!\n\
    \    b.downcase!\n    a.downcase!\n    return b.include?(a) || b.include?(a.reverse)\
    \ || b.include?(a.reverse.reverse)\nend", "  return true if a.include?(b) || b.include?(a)\n\
    end", "  (a.downcase == b.downcase && a == b) || (a.downcase == b.downcase &&\
    \ a.length == b.length && a.chars.all? {|x| b.chars.include? x} && b.chars.all?\
    \ {|x| a.chars.include? x})\nend", "  a.gsub!(\"^\" + b, \"0\") # remove common\
    \ prefix b to a\n  a.gsub!(b + b, \"1\") # replace all occurrences of b with \"\
    1\", because they are substrings\n  a.gsub!(b, \"0\") # remove b\n  return a.start_with?(b)\n\
    end", "  b = b.to_s\n  a = a.to_s\n  if a == b\n    return true\n  i = -1\n  j\
    \ = (b.length) - 1\n  while (i < a.length and j >= 0)\n    return true if a[i]\
    \ == b[j]\n    if a[i] != b[j]\n      return true\n    i += 1\n    j -= 1\n  end\n\
    \  return false\nend", "  if a.empty? || b.empty?\n    return true\n  end\n  return\
    \ a.include?(b) && a[/^(?:#{b}|.)/].include?(b) || a.include?(b[/#{b}$/]) && b[/^(?:#{b}|.)/].include?(b)\
    \ || cycpattern_check(b[1..-1], b)\nend\n</code>\nThis implementation passes most\
    \ of the tests I came up with so far. Not yet all the others but I haven't tested\
    \ that much yet.\n<|/ a dscore=1 |>\n<| c |>\nI'm sorry to say that your solution\
    \ doesn't work for the examples you provided.\n<|/ c |>\n<| c |>\nIt works just\
    \ fine with my tests. Maybe I misunderstood your question?\n<|/ c |>\n<| c |>\n\
    I used your code as my base for my implementation, and it failed the \"psus\"\
    \ test case. I'm going to update my question with my implementation. Thanks for\
    \ your help so far.\n<|/ c |>\n<| c |>\nI see that my implementation is actually\
    \ incorrect for the \"whassup\" test case. I'm going to update my question to\
    \ fix that. Also, my implementation is actually incorrect for the \"himenss\"\
    \ test case. It fails on the first two characters of each test case. I feel like\
    \ I should use some kind of regex to get around that problem. Any thoughts on\
    \ that?\n<|/ c |>\n<| c |>\nI think you're right, I'll have to come up with another\
    \ way to get around the two cases. I'll probably be working on it a little more\
    \ to see if I can find a way to get around the cases where I fail. Thanks for\
    \ your help.\n<|/ c |>\n<| a dscore=1 tags=ruby |>\n<code>", "  a1, a2 = a.split('')\n\
    \  b1, b2 = b.split('')\n  \n  if a2.length > b.length\n    return false\n  end\n\
    \  \n  b_array = Array.new(b2.length)\n  \n  (0...b.length).each do |i|\n    b_array[i]\
    \ = b2[i..-1]\n  end\n  \n  (a2.length .. a2.length + a1.length).each do |i|\n\
    \    if b_array.include?(a1[i..-1])\n      return true\n    end\n  end\n  \n \
    \ return false\nend", "  b = b.downcase\n  a = a.downcase\n  \n  (a.length > 1)\
    \ && (a[0...-1] == b)\nend", "  a = a.split(\"\")\n  b = b.split(\"\")\n  length\
    \ = a.length\n  index = 0\n  while index < length\n    if a[index] == b[index]\
    \ or a[index] == b[index].downcase || a[index] == b[index].upcase\n      return\
    \ true\n    index += 1\n  end\n  return false\nend", "    return a.downcase ==\
    \ b.downcase ||\n        a.downcase.gsub(a[-1..-1], \"\") == b.downcase &&\n \
    \       a.gsub(a[-1..-1], \"\") == b.downcase\nend\n</code>\nThe last step to\
    \ solve this problem was to remove any special characters from the beginning and\
    \ end of the given string and compare it to the second string, if they match then\
    \ the given strings match.\n<|/ a |>\n<| c |>\nVery elegant! I'd be interested\
    \ to see if anyone can come up with a `String` solution to this, though.\n<|/\
    \ c |>\n<| c |>\nHaha, it's cool to see that I was able to solve it.  I guess\
    \ I was hoping for a pure string solution.\n<|/ c |>\n<| a |>\nHere is an interesting\
    \ solution based on String#scan. I'm sure that there is a more elegant way to\
    \ do it, but I did not find it. Maybe someone else can.\n<code>", "  # split a\
    \ into substrings\n  words = a.split(//)\n  # split b into substrings\n  b_splits\
    \ = b.split(//)\n  # initialize count of matches by 0\n  count = 0\n  # loop through\
    \ words array and split each string into substrings and store in b_splits\n  words.each\
    \ do |word|\n    b_splits.each do |b_split|\n      b_split = b_split.split(//)\n\
    \      if b_split.include?(word)\n        count += 1\n        break\n      end\n\
    \    end\n  end\n  count == words.length\nend", "  for i in (0..(a.length-1))\n\
    \    found = false\n    for j in (0..(b.length-1))\n      if a.chars[i].eql?(b.chars[j])\
    \ && (i || j || a.length == b.length)\n        found = true\n        break\n \
    \     if a.chars[i].eql?(b.chars[j])\n        found = true\n        break\n  \
    \  end\n    if !found\n      return false\n    end\n  end\n  true\nend", "  a\
    \ = a.downcase\n  b = b.downcase\n  a =~ /#{b}[aeiouy]+#{b}/i\n  return true if\
    \ a\n  a.scan(/[#{b}]+/).each do |x|\n    a =~ /#{x}#{b}[aeiouy]+#{b}/i\n  end\n\
    \  return a[-1] == b\nend", "  a.split('').each do |c|\n    break false unless\
    \ b.start_with?(c)\n    b.slice!(0,c.length) + b.slice!(-1,c.length)\n  end\n\
    \  true\nend\n</cell>\n<text>\nLet's try it out!", "  a = a.to_s.split(\"\").sort\n\
    \  b = b.to_s.split(\"\").sort\n  if a.size > b.size\n    return false\n  else\n\
    \    a.each_index do |i|\n      unless b.include?(a[i])\n        return false\n\
    \      end\n    end\n    return true\n  end\nend", "    a.to_s.split(\"\").each\
    \ do |word|\n        if a.include? word\n            if b.include? word\n    \
    \            return true\n            else\n                if b.include?(word)\n\
    \                    return true\n                end\n            end\n     \
    \   end\n    end\n    return false\nend", "  b.downcase!\n  if a.length == 0\n\
    \    true\n  else\n    if a.length > b.length\n      false\n    else\n      a[0].downcase!\n\
    \      a[-1] = a.last\n      b[-1].downcase!\n      a[0...-1].each_char.with_index\
    \ do |w, i|\n        a.rotate(i).each_char.with_index do |w, j|\n          b.rotate(j).each_char.with_index\
    \ do |w, k|\n            if w == b[k]\n              return true\n           \
    \ end\n          end\n        end\n      end\n      false\n    end\n  end\nend\n\
    </code>\n<|/ a |>\n<| c |>\nThanks. Just a minor mistake but its not working with\
    \ words like 'hello' and 'ello'.\n<|/ c |>\n<| c |>\n: Fixed.\n<|/ c |>\n<| a\
    \ tags=ruby |>\nYou can create an array of all possible words in a string and\
    \ then check if it contains your word (without looping).\n<|/ a dscore=0 |>\n\
    <| c |>\nNot sure how this would work given 'abc' contains 'cba', but 'abcd' contains\
    \ 'abc' but also contains 'abcde'. Unless you count the letter repetitions, this\
    \ doesn't work.\n<|/ c |>\n<| c |>\nWhat I meant was to create an array of possible\
    \ permutations (permutations of letters)\n<|/ c |>\n<| c |>\nAnd then check if\
    \ each word in the array contains your word (without looping)\n<|/ c |>\n<| c\
    \ |>\nThat's a good idea, but as I wrote, if the word \"abc\" is repeated twice,\
    \ this doesn't work. So you'll have to make sure you only count the letters once.\
    \ Also, there are a lot of repetitions, and it might take a long time to do that.\n\
    <|/ c |>\n<| a |>\nHere's a really quick solution I came up with:\n<code>", " \
    \ return b.split(a.downcase).inject(true,:<=).nil?\nend\n</code>\n<|/ a |>\n<|\
    \ c |>\nThanks a lot for your answer! Unfortunately I am not able to test it right\
    \ now, but will let you know if this worked for me.\n<|/ c |>\n<| c |>\nI managed\
    \ to test it, and it looks like it did exactly what I was looking for. The only\
    \ thing I am still confused about is the part where I convert the strings to lowercase.\
    \ How do you do that in Ruby? I understand that I can use downcase, but how would\
    \ I go about doing the same thing on all of the letters in each of the strings?\
    \ Or is that even the right approach to take?\n<|/ c |>\n<| c |>\n`a.downcase.split(b.downcase)`\
    \ would do it for the individual letters in a string. But it would be much better\
    \ to define `cycpattern_check` so that it compares the individual letters one\
    \ at a time. I'll try to update my answer to show how to do this.\n<|/ c |>\n\
    <| c |>\nThank you, I will keep trying to figure out how to do this. I think I\
    \ understand how to do it with a for loop, but I am not very familiar with inject.\
    \ Do you know of any good resources that can help me?\n<|/ c |>\n<| c |>\n`inject`\
    \ takes a block that takes two arguments. In this case, `inject` runs its block\
    \ once for each element in the array. It returns the last value from the block.\
    \ So `a.downcase.split(b.downcase).inject(false) { |a,b| a || b }`\n<|/ c |>\n\
    <| a dscore=0 |>\nI was struggling with this problem myself, this is what I came\
    \ up with:\n<code>", "  a.downcase!\n  b.downcase!\n  (cycle_word(a,b) != 0) ||\
    \ cycpattern_check(b,a)\nend", "  a = a.to_s\n  b = b.to_s\n  \n  a_reversed =\
    \ a.chars.reverse\n  b_reversed = b.chars.reverse\n  \n  b_has_sub = a_reversed.find\
    \ { |c| b_reversed.include? c }\n  \n  a_has_sub = a.find { |c| b_reversed.include?\
    \ c }\n  \n  a_has_sub\nend", "  a, b = a.downcase, b.downcase\n  return a[0,\
    \ 1].downcase == b[0, 1].downcase && a[0, 2].downcase == b[0, 2].downcase && a[1,\
    \ 1].downcase == b[1, 1].downcase && a[1, 2].downcase == b[1, 2].downcase && a[2,\
    \ 1].downcase == b[2, 1].downcase && a[2, 2].downcase == b[2, 2].downcase\nend\n\
    </pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div id=\"footer\">\n<div id=\"\
    footer-text\">\nLast updated 2019-03-20 13:43:21 UTC\n</div>\n</div>\n</body>\n\
    </html>\n</code>\n<|/ a tags=ruby,regex |>\n<| c |>\nThanks so much for that code.\
    \ I'm new to Ruby, so I appreciate all the help.\n<|/ c |>\n<| c |>\nThanks so\
    \ much for that code. I'm new to Ruby, so I appreciate all the help. However,\
    \ I did run into some problems. I modified it slightly to account for punctuation.\
    \ The original code I had was this: ```code``` def cycpattern_check(a, b) a, b\
    \ = a.downcase, b.downcase return a[0, 1].downcase == b[0, 1].downcase && a[0,\
    \ 2].downcase == b[0, 2].downcase && a[1, 1].downcase == b[1, 1].downcase && a[1,\
    \ 2].downcase == b[1, 2].downcase && a[2, 1].downcase == b[2, 1].downcase && a[2,\
    \ 2].downcase == b[2, 2].downcase end end\n<|/ c |>\n<| c |>\nIt works fine for\
    \ me. You just need to put a period before the end of the regex. I updated my\
    \ answer to reflect that. Here is a Ruby Fiddle of it working: https://rubyfiddle.com/riddles/d24f8/0\n\
    <|/ c |>\n<| c |>\nOh wow. I didn't know about Ruby fiddle. I love it. Thanks\
    \ so much for the help, it's much appreciated.\n<|/ c |>\n<| a |>\nYou might want\
    \ to consider looking into String#include?:\n<code>\n\"aab\".include? \"ab\"\n\
    </code>\n<|/ a tags=ruby,regex dscore=0 |>\n<| c |>\nThanks so much for the suggestion\
    \ - I'm new to Ruby so I appreciate the help. I tried the following, based on\
    \ what you've suggested: ```code``` def cycpattern_check(a, b) a, b = a.downcase,\
    \ b.downcase return a[0, 1].downcase == b[0, 1].downcase && a[0, 2].downcase ==\
    \ b[0, 2].down", "\treturn true if a.chars.each do |c|\n\t\tb.chars.any? { |d|\
    \ c == d }\n\tend\n\tfalse\nend", "    word1 = a.split(//)\n    word2 = b.split(//)\n\
    \    length = word1.length\n    word1.each_index do |i|\n      if word1[i] ==\
    \ word2[i]\n        return\n      else\n        i = i + length - 1\n      end\n\
    \    end\n    false\n  end\nend", "  return a.split(\"\").sort.join(\"\") == b.split(\"\
    \").sort.join(\"\")\nend", "  a.gsub!(/[^a-z]+/i, '')\n  b.gsub!(/[^a-z]+/i, '')\n\
    \  a.length == b.length && a.index(b) == a.length\nend", "  a_words = a.split(//).map(&:downcase)\n\
    \  b_words = b.split(//).map(&:downcase)\n  a_words.each do |word|\n    b_words.each\
    \ do |b_word|\n      true\n    end\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<|\
    \ a |>\nI assume you meant for the cycpattern_check method to return true/false\
    \ for the two input strings when it finds a match. In that case, you can use a\
    \ regular expression match. Here is an implementation in Ruby:\n<code>", "\ta\
    \ = a.downcase\n\tb = b.downcase\n\ts = a.scan(/\\w+/)\n\ti = b.scan(/\\w+/)\n\
    \t\n\twhile i && !s.empty?\n\t\tif i[0] == s.first\n\t\t\treturn true\n\t\tend\n\
    \t\t\n\t\ts.shift\n\t\ti.shift\n\tend\n\t\n\treturn false\nend\n</cell>\n<code\
    \ language=julia-1.0>", "  a.scan(/\\w+/) do |word|\n    b.scan(/\\w+/) do |sub_word|\n\
    \      word == sub_word || a.count(sub_word) || a.split(sub_word).length\n   \
    \ end\n  end\nend", "  return false if a.length == 0\n  return false if b.length\
    \ == 0\n  \n  # find the first rotated word in the first word (excluding first\
    \ word)\n  a_rotated_word = -1\n  \n  # find the first rotated word in the second\
    \ word (excluding first word)\n  b_rotated_word = -1\n  \n  # find where in the\
    \ first word one rotation is located\n  a_word_rotated_index = 1\n  \n  # find\
    \ where in the second word one rotation is located\n  b_word_rotated_index = 1\n\
    \  \n  # iterate over rotated word positions\n  while a_rotated_word != -1 and\
    \ b_rotated_word != -1 \n  \n    # check if position of a_rotated_word is the\
    \ same as b_rotated_word\n    if a.charCodeAt(a_word_rotated_index) == b.charCodeAt(b_word_rotated_index)\n\
    \      \n      # find the next rotated word\n      a_rotated_word = a.indexOf(a[a_word_rotated_index],\
    \ a_word_rotated_index + 1)\n      b_rotated_word = b.indexOf(b_word_rotated_index,\
    \ b_word_rotated_index + 1)\n      \n      # if both words have no rotations return\
    \ true\n      if a_rotated_word == -1 && b_rotated_word == -1\n        return\
    \ true\n      \n      else\n        # if we found a rotated word return false\n\
    \        if a_rotated_word != -1 && b_rotated_word != -1\n          return false\n\
    \      \n      end\n      \n    else\n      \n      # if the position of the rotated\
    \ word does not match return false\n      return false\n      \n    end\n    \n\
    \    # get the rotated word in the first word\n    a_rotated_word = a.indexOf(a[a_word_rotated_index],\
    \ a_word_rotated_index + 1)\n    \n    # get the rotated word in the second word\n\
    \    b_rotated_word = b.indexOf(b_word_rotated_index, b_word_rotated_index + 1)\n\
    \    \n    # increment the index\n    a_word_rotated_index += 1\n    b_word_rotated_index\
    \ += 1\n    \n  end\n  \n  # if we made it through the entire loop return false\n\
    \  return false\n  \nend", "  a.gsub!(/(.)(.)/, '\\\\2\\\\1')\n  b.gsub!(/(.)(.)/,\
    \ '\\\\1\\\\2')\n  return a.index(b.to_s) >= 0\nend", "  return b.gsub(/\\w/){|s|\
    \ a.include?(s) }\nend\n</code>\n<|/ a |>\n<| c |>\nHaven't tested it, but I believe\
    \ you can get rid of all the `!` by changing the regexp to `/\\w/` (or even `/[[:alpha:]]/`)\
    \ and then using `include?` instead of `=`.  Also, `include?` already returns\
    \ true or false, you don't need the `!`.\n<|/ c |>\n<| c |>\nThank you for pointing\
    \ this out. I updated the answer to fix it.\n<|/ c |>\n<| a |>\nI have another\
    \ solution to it.\n<code>", "  a = a.split(\"\")\n  b = b.split(\"\")\n  a.each\
    \ do |char|\n    b.each do |char2|\n      if char.include?(char2) or char2.include?(char)\
    \ or char2.include?(char) or char2.include?(char2)\n        return true\n    \
    \  end\n    end\n  end\n  return false\nend", "  return true if b.downcase ==\
    \ a.downcase.split(\"\").uniq.uniq.uniq.join(\"\") end\nend\n</pre>", "  a = a.downcase\n\
    \  b = b.downcase\n  \n  return a.include?(b) || b.include?(a) || b.include?(\"\
    #{\"+a+\"}\") || a.include?(\"#{\"+b+\"}\") || b.include?(\"#{\"+b+\"}\") || b.include?(\"\
    #{\"+a+\"}\")\nend\n</code>\n<|/ a dscore=1 |>\n<| a |>\nI tried to get your code\
    \ to work but failed. I've spent hours on this one and finally got it to work:\n\
    <code>\nrequire 'optparse'", "  return a.include? b.to_s.reverse\nend", "  return\
    \ (a.size >= b.size) ?\n    ((a.each_index {|i| return false if b.include?(a[i+a[i].size])})\
    \ rescue true) :\n    false\nend\n</code>\nEDIT\nI did a test of the function\
    \ and I think it works.\n<code>\nirb(main):058:0> cycpattern_check(\"abcdef\"\
    , \"abcde\")\n=> true\nirb(main):059:0> cycpattern_check(\"abcdef\", \"abde\"\
    )\n=> true\nirb(main):060:0> cycpattern_check(\"abcdef\", \"aabc\")\n=> true\n\
    irb(main):061:0> cycpattern_check(\"abcdef\", \"bcde\")\n=> true\nirb(main):062:0>\
    \ cycpattern_check(\"abcdef\", \"bcdc\")\n=> true\nirb(main):063:0> cycpattern_check(\"\
    abcdef\", \"bdcd\")\n=> true\nirb(main):064:0> cycpattern_check(\"abcdef\", \"\
    bcda\")\n=> true\nirb(main):065:0> cycpattern_check(\"abcdef\", \"bcdc\")\n=>\
    \ true\nirb(main):066:0> cycpattern_check(\"abcdef\", \"cdef\")\n=> true\nirb(main):067:0>\
    \ cycpattern_check(\"abcdef\", \"ccde\")\n=> true\nirb(main):068:0> cycpattern_check(\"\
    abcdef\", \"cddc\")\n=> true\nirb(main):069:0> cycpattern_check(\"abcdef\", \"\
    cdaa\")\n=> true\nirb(main):070:0> cycpattern_check(\"abcdef\", \"cdca\")\n=>\
    \ true\nirb(main):071:0> cycpattern_check(\"abcdef\", \"dabe\")\n=> true\nirb(main):072:0>\
    \ cycpattern_check(\"abcdef\", \"deaf\")\n=> true\nirb(main):073:0> cycpattern_check(\"\
    abcdef\", \"dcab\")\n=> true\nirb(main):074:0> cycpattern_check(\"abcdef\", \"\
    edba\")\n=> true\nirb(main):075:0> cycpattern_check(\"abcdef\", \"edbc\")\n=>\
    \ true\nirb(main):076:0> cycpattern_check(\"abcdef\", \"edca\")\n=> true\nirb(main):077:0>\
    \ cycpattern_check(\"abcdef\", \"edcb\")\n=> true\nirb(main):078:0> cycpattern_check(\"",
  "  if a == b\n    return true\n  a.each_char do |c|\n    next if a.length == 0\n\
    \    return false if ( b.include? c) || ( b.include?(c*3) || b.include?(c*6) )\n\
    \  end\n  true\nend\n</code>\n<|/ a tags=string,ruby dscore=0 |>\n<| c |>\nHi,\
    \ thank you very much for this. It helped me understand ruby a little better.\
    \ I will accept the answer when it lets me. Just a little confused at one point\
    \ in your code. Do you mind explaining to me what exactly it means to say `b.include?(c)`\n\
    <|/ c |>\n<| c |>\nThe `b` here is just a variable name that holds the string\
    \ that the method should search for. By calling `include?(c)` you check if the\
    \ `b` string contains the character `c` from the `a` string.\n<|/ c |>\n<| c |>\n\
    Thank you so much for this! I now understand. I've been trying to figure out a\
    \ way around this for a few hours now and you really helped me!\n<|/ c |>\n<|\
    \ c |>\nNo problem. Glad I could help out. Feel free to ask anything about the\
    \ code if you have questions.\n<|/ c |>\n<| c |>\nYeah, I got one more question.\
    \ How would I make it so if the string had a character that was also in the array,\
    \ it would return true? For example, in my original code I said 'return false\
    \ if ( b.include? c) || ( b.include?(c*3) || b.include?(c*6) )' so that any character\
    \ in the string was also included, but now if the string had the letter 's' for\
    \ example, it would still return false. I want it so any character is included\
    \ in the string, whether it is a substring or not in the string. I hope that makes\
    \ sense. I'm really sorry for being so confusing about this\n<|/ c |>\n<| a dscore=0\
    \ tags=string,ruby |>\nYou can use Array#combination to achieve this in single\
    \ pass. \n<code>", "  a.downcase!\n  b.downcase!\n  a.gsub!(/[^[:word:]]/, \"\"\
    )\n  b.gsub!(/[^[:word:]]/, \"\")\n  a.length < b.length ? false : a.chars.zip(b.chars).all?{|x,\
    \ y| x <=> y}\nend", "  \n  return a.include?(b) || b.include?(a)\nend\n</cell>\n\
    <code language=julia-1.3>\n@time begin\n  cycpattern_check(\"ab\", \"abc\")\n\
    \  cycpattern_check(\"abc\", \"abc\")\n  cycpattern_check(\"abc\", \"ab\")\n \
    \ cycpattern_check(\"abc\", \"bcd\")\n  cycpattern_check(\"ab\", \"ac\")\n  cycpattern_check(\"\
    ab\", \"bc\")\n  cycpattern_check(\"ab\", \"c\")\n  cycpattern_check(\"ab\", \"\
    d\")\n  cycpattern_check(\"ab\", \"e\")\n  cycpattern_check(\"ab\", \"f\")\n \
    \ cycpattern_check(\"ab\", \"g\")\n  cycpattern_check(\"ab\", \"h\")\n  cycpattern_check(\"\
    ab\", \"i\")\n  cycpattern_check(\"ab\", \"j\")\n  cycpattern_check(\"ab\", \"\
    k\")\n  cycpattern_check(\"ab\", \"l\")\n  cycpattern_check(\"ab\", \"m\")\n \
    \ cycpattern_check(\"ab\", \"n\")\n  cycpattern_check(\"ab\", \"o\")\n  cycpattern_check(\"\
    ab\", \"p\")\n  cycpattern_check(\"ab\", \"r\")\n  cycpattern_check(\"ab\", \"\
    s\")\n  cycpattern_check(\"ab\", \"t\")\n  cycpattern_check(\"ab\", \"u\")\n \
    \ cycpattern_check(\"ab\", \"v\")\n  cycpattern_check(\"ab\", \"w\")\n  cycpattern_check(\"\
    ab\", \"x\")\n  cycpattern_check(\"ab\", \"y\")\n  cycpattern_check(\"ab\", \"\
    z\")\n  cycpattern_check(\"ab\", \"aa\")\n  cycpattern_check(\"ab\", \"ab\")\n\
    \  cycpattern_check(\"ab\", \"ba\")\n  cycpattern_check(\"ab\", \"ca\")\n  cycpattern_check(\"\
    ab\", \"da\")\n  cycpattern_check(\"ab\", \"ea\")\n  cycpattern_check(\"ab\",\
    \ \"fa\")\n  cycpattern_check(\"ab\", \"ga\")\n  cycpattern_check(\"ab\", \"ha\"\
    )\n  cycpattern_check(\"ab\", \"ia\")\n  cycpattern_check(\"ab\", \"ja\")\n  cycpattern_check(\"\
    ab\", \"ka\")\n  cycpattern_check(\"ab\", \"la\")\n  cycpattern_check(\"ab\",\
    \ \"ma\")\n  cycpattern_check(\"ab\", \"na\")\n  cycpattern_check", "  a.downcase!\n\
    \  b.downcase!\n  a = a.split(//)\n  b = b.split(//)\n  a.each_index do |i|\n\
    \    break if i == b.length\n    b[i].length == 0 ? (return true) : (return false\
    \ if a[i] == b[i].to_s)\n  end\n  a.each_index do |i|\n    break if i == a.length\n\
    \    a[i].length == 0 ? (return true) : (return false if a[i] == b[i].to_s)\n\
    \  end\n  a.each_index do |i|\n    break if i == a.length\n    b[i].length ==\
    \ 0 ? (return true) : (return false if a[i] == b[i].to_s)\n  end\n  a.each_index\
    \ do |i|\n    break if i == a.length\n    a[i].length == 0 ? (return true) : (return\
    \ false if a[i] == b[i].to_s)\n  end\n  return true\nend", "    a.downcase!\n\
    \    b.downcase!\n    \n    a_length = a.length\n    b_length = b.length\n   \
    \ \n    b.rotate(b_length)\n    \n    if (a_length == 0)\n        return true\n\
    \    end\n    \n    if a.last() == b.first() && a.length == b.length\n       \
    \ return true\n    end\n    \n    if b_length == 0\n        return false\n   \
    \ end\n    \n    for i in (0..(a_length - b_length))\n        if (a[i + b_length]\
    \ == b[i])\n            return cycpattern_check(a[0...i], b[0...(i+1)])\n    \
    \    end\n    end\n    return false\nend", "  a.downcase!\n  b.downcase!", "\t\
    a1, a2 = a.downcase, b.downcase\n\ta1 = a1.split('')\n\ta2 = a2.split('')\n\t\
    a_len = a.length\n\tb_len = b.length\n\twhile a_len >= b_len\n\t\ta2 << a1\n\t\
    \ta1 << '_'\n\t\ta1.delete_at(a_len-1)\n\t\ta1 << '_'\n\t\ta_len -= 1\n\t\ta_len\
    \ -= 1\n\ta_len = a.length\n\twhile b_len >= a_len\n\t\ta2 << a1\n\t\ta1 << '_'\n\
    \t\ta1.delete_at(b_len-1)\n\t\ta1 << '_'\n\t\tb_len -= 1\n\t\tb_len -= 1\n\tb_len\
    \ = b.length\n\twhile a_len >= b_len\n\t\ta2 << a1\n\t\ta1 << '_'\n\t\ta1.delete_at(a_len-1)\n\
    \t\ta1 << '_'\n\t\ta_len -= 1\n\t\ta_len -= 1\n\twhile b_len >= a_len\n\t\ta2\
    \ << a1\n\t\ta1 << '_'\n\t\ta1.delete_at(b_len-1)\n\t\ta1 << '_'\n\t\tb_len -=\
    \ 1\n\t\tb_len -= 1\n\twhile a_len >= b_len\n\t\ta2 << a1\n\t\ta1 << '_'\n\t\t\
    a1.delete_at(a_len-1)\n\t\ta1 << '_'\n\t\ta_len -= 1\n\t\ta_len -= 1\n\twhile\
    \ b_len >= a_len\n\t\ta2 << a1\n\t\ta1 << '_'\n\t\ta1.delete_at(b_len-1)\n\t\t\
    a1 << '_'\n\t\tb_len -= 1\n\t\tb_len -= 1\n\t\n\ta1 = a1.join('')\n\ta2 = a2.join('')\n\
    \treturn (a1 == a2)\nend", "  return (a.length >= b.length || a == \"*\") && (b.length\
    \ >= a.length || b == \"*\") && a.include? b && a.include?(b[a.length..-1]) \n\
    end\n</cell>\n<code language=julia-0.5>", "\treturn a.chars.all? { |c| b.chars.all?\
    \ { |d| c == d } } || b.chars.all? { |d| c == d }\nend", "  a.downcase!\n  b.downcase!\n\
    \  a = a.split(//)\n  b = b.split(//)\n  a.length.times do |i|\n    b.length.times\
    \ do |j|\n      return true if a[i] == a[j] if b.include?(a[i])\n    end\n  end\n\
    \  false\nend\n</code>\n<|/ a tags=ruby,string dscore=1 |>\n<| c |>\nWhile this\
    \ code may answer the question, providing additional context regarding why and/or\
    \ how this code answers the question improves its long-term value.\n<|/ c |>\n\
    <| c |>\n, added comments to help explain the code better.\n<|/ c |>\n<| a |>\n\
    <code>\nstr = \"ab\"\nstr = \"bc\"\nstr = \"c\"", "  return false if a.size !=\
    \ b.size or b.size < 2 end\n  a_size = a.size\n  b = b.chars\n  for i in 0..(a_size-1)\n\
    \    if b[i] == a[i+1] then\n      return true\n    end\n  end\nend\n</code>\n\
    To find all permutations of size n of string:\n<code>", "  case a\n    when /^[a-zA-Z]+$/\
    \ then true\n    when /^[a-z]+$/ then a\n    when /^[0-9]+$/ then a\n    when\
    \ /^[0-9]+[a-zA-Z]+$/ then a\n    when /^[a-zA-Z]+[0-9]+$/ then a\n    when /^[a-z]+[0-9]+[a-zA-Z]+$/\
    \ then a\n    when /^[0-9]+[a-z]+[0-9]+[a-zA-Z]+$/ then a\n    when /^[a-z]+[0-9]+[a-z]+[0-9]+[a-zA-Z]+$/\
    \ then a\n    when /^[0-9]+[a-z]+[0-9]+[a-z]+[0-9]+[a-zA-Z]+$/ then a\n    when\
    \ /^[a-z]+[0-9]+[a-z]+[0-9]+[a-z]+[0-9]+[a-zA-Z]+$/ then a\n    when /^[0-9]+[a-z]+[0-9]+[a-z]+[0-9]+[a-z]+[0-9]+[a-zA-Z]+$/\
    \ then true\n    else false\n  end\nend", "  return false if a.length == 0 ||\
    \ b.length == 0 else (\n    a.include?(b) || b.include?(a)\n  )\nend", "    return\
    \ cycpattern_check_helper(a, b, Hash.new(a), Hash.new(b), Hash.new(\"\"))\nend",
  "  a.tr!('','')\n  b.tr!('','')\n  a.upcase!\n  b.upcase!\n  a.length.upcase!\n\
    \  b.length.upcase!\n  a.include?(b) || (a != b) || (cycpattern_check(b.gsub(\"\
    .\", \"\\\\0\"), a.gsub(\".\", \"\\\\0\")))\nend", "  return a.include?(b) ||\
    \ a.include?(b.rotation(1..-1)) || a.include?(b.rotation(1..b.length)) || a.include?(b.rotation(0..b.length))\
    \ || a.include?(b.rotation(0...b.length))\nend", "    return a.include?(b)\nend",
  "    if a.length != b.length\n        return false\n    for i in 0...a.length\n\
    \        if a.include?(b[i]) == false\n            return false\n    return true\n\
    end", "    a.chomp\n    b.chomp\n    a_pos = a.downcase!=\"\" ? a.downcase.index(b.downcase)\
    \ : nil\n    b_pos = b.downcase!=\"\" ? b.downcase.index(a.downcase) : nil\n \
    \   return a_pos != nil && b_pos != nil && a_pos < b_pos\nend\n</code>\n<|/ a\
    \ tags=ruby,string |>\n<| a tags=ruby,string |>\nYes, I wrote a gem to do just\
    \ that. I've written a gem that solves these kinds of problems, specifically for\
    \ DNA sequences.\nIt's called DnaString. It's available on RubyGems (see here)\
    \ and it has a handy method called dna, so here's how you use it:\n<code>\nrequire\
    \ 'dnastring'", "    first = a.split(//).sort\n    second = b.split(//).sort\n\
    \    first = first.join(\"\").gsub(/(\\W)+/, \"\").gsub(/^([a-z]+)/) {|e| e.downcase\
    \ }\n    second = second.join(\"\").gsub(/(\\W)+/, \"\").gsub(/^([a-z]+)/) {|e|\
    \ e.downcase }\n    first.length >= 2 && second.length >= 2 && first.length <=\
    \ 3 && second.length <= 3 && second.include?(first)\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThanks for your time! Unfortunately I cannot use any gems. Your answer\
    \ is very helpful anyway, thank you for taking the time to write it.\n<|/ c |>\n\
    <| c |>\nI am sorry but i think you misunderstood the requirements because if\
    \ you have a string `ab` then `cd` it returns `true` but `ab` has length 2 and\
    \ `cd` has length 3 so it should return `false`\n<|/ c |>\n<| c |>\nSorry for\
    \ not being clear. I need it to be able to match on substrings.\n<|/ c |>\n<|\
    \ a dscore=0 |>\nThis solution uses only regular expressions (and no gems). It\
    \ works exactly as you described, but only for the first occurrence of one word.\
    \ For other occurrences, it returns false. \n<code>", "  a != b and return false\n\
    \  for i in [0...a.length-1]\n    j = i\n    while j < a.length\n      if a.substring(i,\
    \ j) == b.substring(j, i)\n        return true\n      j++\n    return false\n\
    \  return true\nend\n</code>\n<|/ a |>\n<| c |>\nI tested this against a large\
    \ amount of test cases and my solution does not appear to have the potential to\
    \ take any advantage of the fact the input is sorted.\n<|/ c |>\n<| c |>\nIt also\
    \ does not handle cases where word lengths differ\n<|/ c |>\n<| c |>\nI tested\
    \ it with my own test cases and it seems to work fine. The test case I used was\
    \ a combination of a random rotation of \"baby\" and \"beygy\" and it passed all\
    \ my testcases.\n<|/ c |>\n<| c |>\nIt doesn't work correctly. You're returning\
    \ early when both `a != b` and you don't consider permutations of the letters.\
    \ In your example, `'baby' != 'beygy'` because `a` is `'baby'` and `b` is `'beygy'`\
    \ but `'baby' != 'beygy'` because `a` is `'beygy'` and `b` is `'baby'`.\n<|/ c\
    \ |>\n<| c |>\nThanks for pointing that out! I didn't test my own solution as\
    \ it wasn't a homework question and I didn't think it would be that difficult\
    \ to find my own solution through googling. I fixed my own solution by adding\
    \ a test case (I did it on my own computer so I won't post it) where I returned\
    \ early when the two strings were the same and I returned false when either or\
    \ both words contained a substring that had been rotated.\n<|/ c |>\n<| a tags=algorithm,string,ruby\
    \ |>\n<code>", "  return true\nend", "  a=a.split(\"\").sort\n  b=b.split(\"\"\
    ).sort\n  ( (a.length + b.length ) <= 2 ) and return true\n  for i in (0...a.length)\n\
    \    if a[i] != b[i] and a[i] != b[i].downcase and b[i].downcase != a[i] \n  \
    \    return false\n  return true\nend\n</code>\n<|/ a tags=string,ruby |>\n<|\
    \ a tags=string,ruby |>\nI came up with this simple solution.\n<code>", "    a.each_char.zip(b.each_char).inject(:&).all?\
    \ { |char1, char2| char1.include?(char2) }\nend", "    a.downcase!\n    b.downcase!\n\
    \    i = 0\n    a.length == b.length ? return true :\n    while i < a.length\n\
    \        c = a[i]\n        d = b[i]\n        i += 1\n        if c == '' && (d\
    \ == '' || d == '0')\n            return true\n        if c == '0' && d == ''\
    \ && (a[i] == '')\n            return true\n        if c == '' && (d == '' ||\
    \ d == '0')\n            return true\n        if c == '0' && d == '' && (a[i]\
    \ == '')\n            return true\n        if c == d || d == '' || d == '0' ||\
    \ d == '1'\n            return false\n        if c == d && a[i].downcase == b[i].downcase\n\
    \            return true\n    end\n    return false\nend", "\treturn true if a.include?(b)\
    \ || b.include?(a)\nend", "  a.split(\"\").each_with_index { |x, i| return false\
    \ if b.include? x }\n  false\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks,\
    \ this helped a lot! I was able to modify this code to also check for rotations,\
    \ like so:\n`def cycpattern_check(a, b)\n  a.split(\"\").each_with_index { |x,\
    \ i| return false if b.include? x }\n  true\nend`\n<|/ c |>\n<| a dscore=2 tags=ruby,substring,string\
    \ |>\nI know I am late to the party. But for those who are looking for the same\
    \ solution in Java. here is a solution with time complexity of O(n) using HashMap\
    \ and StringBuilder -\n<code>\nstatic boolean cycpattern_check( String a, String\
    \ b ) {\n    HashMap<Character, String> hashMap = new HashMap<>();\n    \n   \
    \ for(Character c : a.toCharArray()){\n        String temp = b.substring(a.indexOf(c)+1,\
    \ a.indexOf(c)+1);\n        hashMap.put(c, temp);\n    }\n    \n    if(a.equals(b))\n\
    \        return true;\n    \n    if(hashMap.containsKey(b.charAt(0)))\n      \
    \  if(hashMap.get(b.charAt(0)).equals(b))\n            return true;\n    \n  \
    \  return false;\n}\n</code>\n<|/ a |>\n<| a dscore=2 |>\nJust to give a Ruby\
    \ version (also O(n), but uses hashes to check all substrings instead of substrings\
    \ of a longer one):\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
