name: HumanEval_131_digits
language: rb
prompt: "# Given a positive integer n, return the product of the odd digits.\n# Return\
  \ 0 if all digits are even.\n# For example:\n# >>> digits.call(1)\n# 1\n# >>> digits.call(4)\n\
  # 0\n# >>> digits.call(235)\n# 15\ndef digits(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_digits\n\
  \    candidate = method(:digits)\n    assert_equal(5, candidate.call(5))\n    assert_equal(5,\
  \ candidate.call(54))\n    assert_equal(1, candidate.call(120))\n    assert_equal(5,\
  \ candidate.call(5014))\n    assert_equal(315, candidate.call(98765))\n    assert_equal(2625,\
  \ candidate.call(5576543))\n    assert_equal(0, candidate.call(2468))\n  end\nend\n"
completions: ["  n = n.to_i if n.is_a?(Integer) else n\n  0 if n.even? || n.odd? else\
    \ n.to_s.split('').inject(:*) * 10**(n.to_s.size - 1)\nend", '  n <=> n/10 until
    n <= 99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999',
  "  if n<0\n    return 0\n  a = n % 10\n  if a < 3\n    return a\n  b = n % 100\n\
    \  if b < 5\n    return b\n  c = n % 1000\n  if c < 7\n    return c\n  d = n %\
    \ 10000\n  if d < 9\n    return d\n  e = n % 100000\n  if e < 11\n    return e\n\
    \  f = n % 1000000\n  if f < 13\n    return f\n  g = n % 10000000\n  if g < 17\n\
    \    return g\n  h = n % 100000000\n  if h < 19\n    return h\n  i = n % 1000000000\n\
    \  if i < 21\n    return i\n  j = n % 10000000000\n  if j < 23\n    return j\n\
    \  k = n % 100000000000\n  if k < 24\n    return k\n  l = n % 1000000000000\n\
    \  if l < 27\n    return l\n  m = n % 10000000000000\n  if m < 29\n    return\
    \ m\n  n = n % 100000000000000\n  if n < 31\n    return n\n  o = n % 1000000000000000\n\
    \  if o < 33\n    return o\n  p = n % 10000000000000000\n  if p < 35\n    return\
    \ p\n  q = n % 10000000000000000\n  if q < 37\n    return q\n  r = n % 10000000000000000\n\
    \  if r < 39\n    return r\n  s = n % 10000000000000000\n  if s < 41\n    return\
    \ s\n  t = n % 10000000000000000\n  if t < 43\n    return t\n  u = n % 10000000000000000\n\
    \  if u < 45\n    return u\n  v = n % 10000000000000000\n  if v < 47\n    return\
    \ v\n  w = n % 10000000000000000\n  if w < 49\n    return w\n  x = n % 10000000000000000\n\
    \  if x < 51\n    return x\n  y = n % 10000000000000000\n  if y < 53\n    return\
    \ y\n  z = n % 10000000000000000\n  if z < 55\n    return z\n  a = n % 100000000000000000\n\
    \  if a < 57\n    return a\n  b = n % 10000000000000000\n  if b < 59\n    return\
    \ b\n  c = n % 100000000000000000\n  if c < 61\n    return c\n  d = n % 100000000000000000\n\
    \  if d < 63\n    return d\n  e = n % 100000000000000000\n  if e < 65\n    return\
    \ e\n  f = n % 100000000000000000\n  if f < 67\n    return f\n  g = n % 100000000000000000\n\
    \  if g < 69\n    return g\n  h = n % 100000000000000000\n  if h < 71\n    return\
    \ h\n  i = n % 100000000000000000\n  if i < 73\n    return i\n  j = n % 10000000000",
  "  n.to_s.split(\"\").map { |digit| digit % 2 != 0 ? digit * 2 : 0 }.inject(:*)\n\
    end", "  if n.zero?\n    0\n  else\n    n.to_s.split(\"\").each_with_object(1)\
    \ do |s, h|\n      h *= 10 if h > 10\n      h + (s.to_i & 1)\n    end\n  end\n\
    end", "  return n == 0 ? 0 : (n > 0 ? n * digits(n / 2) : 0)\nend", "  return\
    \ 0 if n <= 0 \n  result = 1\n  n.times { result *= digit }\n  result\nend", " \
    \ return n < 10 ? n * digit(n % 10, digits) : 0\nend", "  while n > 0\n    n /=\
    \ 10\n  end", "  n.to_s.length.times.map {|i| n.to_s.to_i(2)}\nend", "  \n  return\
    \ 0 if n < 10 then 1\n    else n / 10 * n % 10 * digits.call(n % 10)\nend", " \
    \ n.to_s.chars.each_with_index.map { |c,i| (n%i).zero? ? c : 0 }.inject(:*)\n\
    end", "  m = 0\n  while n > 0\n    m, n = n / 10, n % 10\n  end\n  m\nend", " \
    \ if n.odd?\n    n * digits(n.div 10)\n  else\n    n\n  end\nend", "  if n < 0\n\
    \    return 0\n  a, b = n.to_s.split('')\n  odds = b.chars.map{|d| d.to_i}.select\
    \ { |d| d.odd? }.size\n  evens = a.chars.map{|d| d.to_i}.select { |d| d.even?\
    \ }.size\n  if odds == evens\n    return 0\n  else\n    return evens ? b.chars.map{|d|\
    \ d.to_i}.product[0] : b.chars.map{|d| d.to_i}.product[1]\n  end\nend", "  r =\
    \ 0\n  i = 2\n  while i < n do\n    r *= i\n    i += 1\n  end\n  r\nend", "  (0..n).inject(:*)\
    \ / (2..n).any? ? 1 : 0\nend", "  n.to_s.split(//).map { |s| s.to_i if s.odd?\
    \ }.inject(:*)\nend\n</code>\n<|/ a tags=string,ruby,arrays,math,integer |>\n\
    <| a tags=string,ruby,arrays,math,integer |>\n<code>", "  n.to_s.chars.each_with_index.inject(0)\
    \ { |m, (_, index)| m * 2 if index % 2 == 1 }\nend\n</code>\n<|/ a dscore=2 tags=ruby,digits,recursion,factorial\
    \ |>\n<| c |>\n+1: This is what I was going to write up when I saw your answer.\n\
    <|/ c |>\n<| c |>\nAm I missing something? That code never returns `0` as the\
    \ OP requested.\n<|/ c |>\n<| c |>\n, No, I'm not; I ran my tests and the results\
    \ returned `0`.\n<|/ c |>\n<| c |>\n+1 for the answer. I'm still curious why this\
    \ wasn't accepted as an answer. Surely someone has some rationale for this choice.\n\
    <|/ c |>\n<| c |>\nYes, I realized that the OP asked for `0` when all digits are\
    \ even. But I just thought I'd post it here in case the OP had a reason for not\
    \ accepting it.\n<|/ c |>\n<| a tags=ruby,digits,recursion,factorial dscore=2\
    \ |>\n<code>", "  return n.to_s.split('').map.with_index { |d, i| i % 2 == 1 ?\
    \ d.to_i : 0} * 0\nend", "  n.to_s.split(\"\").inject(1, &:*)\nend", "  return\
    \ 0 if n < 0 else n % 2 > 0 ? ( n * digits(n / 2)) if n % 2 == 1 else n * digits(n\
    \ / 2) : 0\nend", "  n.to_s.chars.each_char.inject(1){|sum, v| sum * v mod 10\
    \ }\nend", "  product = 1\n  loop do\n    digit =\n      (n % 1000) / 100 % 10\n\
    \    product = product * digit\n    n /= 10\n  end\n  product\nend", "  return\
    \ 0 if n.to_s.size % 2 == 1 then 0 else n.to_s.reverse.scan(2).reduce(:*)\nend",
  "  n.to_s.chars.map { |c| c == '1' ? 1 : 0 }.inject :*\nend", "  return 0 if n.zero?\
    \ then 0 else n.to_s(2).scan(/\\d{2,}/).inject(:*)\nend", "  return 0 if n.zero?\
    \ || n.odd? else n.to_s.chars.inject(:*)\nend", "  sum = 0\n  while n > 0\n  \
    \  sum, n = n, sum % 10\n  end\n  sum\nend\n</code>\nThe algorithm above is simple\
    \ but not efficient if there are more than 1,000 digits. To make it efficient,\
    \ one can use Ruby's Bignum library. To convert a Bignum into a string, use the\
    \ to_s method (or to_i if your number is too big to fit in an int). For example,\
    \ here is a function to convert a Bignum into an array:\n<code>", "    product\
    \ = n * digits_odd\n    return product if product < 10 else 0\nend\n</cell>\n\
    <code language=julia-1.3>\ndigits(13)\n</cell>\n<code language=julia-1.3>", " \
    \ return 0 if (n == 0) else (n % 2) * digit_count(n) / 2\nend", "  return (n==0)?\
    \ 0: ((n%100==0)? n%10: digits(n/10)*10) + (n%10==0)\nend", "  n -= (n % 10)\n\
    \  return 0 if n % 2 == 1 else (n % 10) * 2\nend", "  n.to_s.split(//).map {|d|\
    \ d.to_i%2 == 1 ? d : 0}\nend", "\tdigits_array = n.to_s.split(//)\n\tproduct\
    \ = 1\n\ti = 0\n\t\n\twhile i < digits_array.count\n\t\tdigit = digits_array[i]\n\
    \t\tif digit.to_i > 6\n\t\t\tproduct = 0\n\t\telse\n\t\t\tproduct *= digit.to_i\n\
    \t\ti += 1\n\t\t\n\treturn product\nend", "  return 0 + (n % 2) * (n / 2)\nend",
  "    n.to_s.split(//).map { |x| x.to_i % 2 ? x * 3 : x }.inject(0, :*)\nend", " \
    \   return n.to_s.split(//).reduce(&:*)\nend", "  if n < 0\n    []\n  else\n \
    \   n % 2 == 1 ? n * digits(n / 2) : digits(n / 2)\n  end\nend", '  return 0 if
    n<10 else n modulo 10_000 and n / 10_000', "  if n < 0\n    return 0\n  n = n.to_s\n\
    \  return n.length * n[1..-1].to_i\nend", "  n.zero? && return 1\n  n.odd? &&\
    \ (n.times { |x| x % 2 != 0 ? x = 0 : x += 1 })\n  n.times {|x| x * 10}\nend",
  "  n.to_s.length >= 1 ? n.to_s.chars.map { |e| e % 2 ? e : -e }.inject(:*) : 0\n\
    end", "  if n.even? then 0\n  else\n    if n.odd? then n.to_s.reverse.inject(1){|product,\
    \ digit| product * digit.to_i}\n    else\n      n.to_s.reverse.inject(1){|product,\
    \ digit| product * digit.to_i} / 10\n    end\n  end\nend", "  n.to_s.chars.map.with_index{|d,\
    \ i| (n / (10**i) % 2).zero? ? d : 0}\nend", "  return n % 10 ? n * digits(n /\
    \ 10) : 0\nend", "  n.to_s.split(//).drop(1).inject(0) do |sum, digit|\n    sum\
    \ * 10 + digit.to_i\n  end\nend", "  return n if n.even? else 0\nend", "    digits\
    \ = (0..n).to_a\n    odd = digits.count(&:odd?)\n    even = digits.count(&:even?)\n\
    \    if odd.zero?\n        0\n    elsif even.zero?\n        0\n    else\n    \
    \    odd.to_f * (1 / even.to_f)\n    end\nend", "  n\nend", "  return 0 if n<10\
    \ else (1<<((n-1)%10))*digits((n/10).floor)\nend", "  if n.to_s.to_i > 0\n   \
    \ return n.to_s.to_i ** 2\n  else\n    return 0\n  end\nend\n</code>\nThen we\
    \ can calculate the product of odd digits in any number.\n<code>", "  return n\
    \ ? (n.to_s + n.to_i.to_s).gsub(/(\\d).(\\d)/, '\\2\\\\1*').to_i : 0\nend", " \
    \ return 1 if n.to_s.length <= 1 || n.to_s.length == 0 \n    or n % 2 == 0 \n\
    \    else n * digits(n.to_s[1..-1])\nend", "  n = n.to_i\n  return n if n < 10\
    \ else 0", "  if n >= 100\n    digits(n / 10)\n  elsif n % 10 == 0\n    return\
    \ 1\n  else\n    return 0\n  end\nend", "  return 0 unless n.to_i\n  return 1\
    \ if n<10\n  a=1\n  while n>0\n    (n,a)=(n*10+a,1)\n  end\n  a\nend", "  result\
    \ = 0\n  while n > 0 do\n    result *= n%10\n    n /= 10\n  end\n  result\nend",
  "    if n < 0\n        return 0 \n    digits = n.to_s.chars.map { |n| n % 10 }\n\
    \    if digits.all? { |d| d == 0 }\n        return 0\n    odds = digits.select\
    \ { |d| d == 1 }\n    return odds.inject(:*)\nend", "  s = 0\n  while n > 0 do\n\
    \    s *= n % 10\n    s %= 10\n    n /= 10\n  end\n  if s == 0\n    s\n  else\n\
    \    0\n  end\nend", "  factors = []\n  div = 0\n  while n > 0\n    div, n = div\
    \ + 2, n / 2\n    factors.push div\n  end\n  factors.reverse if factors.size %\
    \ 2 == 1\n  factors.last\nend", "  return 0 if n < 10 else 1 + n * digits(n %\
    \ 10)\nend", "  (n == 0) ? 0 : 1 * (n % 10) * (digits(n / 10) * 10)\nend", " \
    \ if n < 0 then\n    digits(-n)\n  else\n    digits = n % 10\n    odd = n % 2\n\
    \    if odd != 0 then\n      digits = digits * 3 + 1\n      digits(n//10)\n  \
    \  end\n    digits\n  end\nend", "  n.to_s.each_char.map { |c| c == \"0\" ? 0\
    \ : 1 }.inject(:*)\nend", "  product = 1\n  for i in n.to_s\n    product = product\
    \ * i.to_i\n  end\n  product\nend", "  n\nend\n</code>\nSo digits(0) returns 1,\
    \ but digits(1) returns 1, but digits(2) returns 2, etc.\nWe can then use reduce\
    \ to sum the digits, like this:\n<code>", "  if n==0 then return 0\n  if n==1\
    \ then return 1\n  return digits(n-1)*10+(n-1).modulo(2)\nend", "  n.to_s.split('').map(&:to_i).reduce(:*)\n\
    end", "\tn, i, x = 0, n, 1\n\twhile n > 0\n\t\tif n % 10 == 1 && n > 9\n\t\t\t\
    x += 1\n\t\t\tn -= 10\n\t\telse\n\t\t\ti += 1\n\t\t\tn = n//10\n\tend\n\tx\nend",
  "  n = n.to_s\n  n.each_char {|d| d == '0' ? return 0 : d == '1' ? 1 : 0}\n  0\n\
    end", "    sum = 0\n    if n < 0\n        puts \"invalid number of digits\"\n\
    \        return -1\n    while n > 0\n        sum += n % 10\n        n = n / 10\n\
    \    return sum % 2 == 0 ? sum : 0", "  sum = 0\n  while n > 0 do\n    sum +=\
    \ n % 10\n    n /= 10\n  end\n  return sum if sum % 2 == 0\n  0\nend", "  n.to_s.split(\"\
    \").inject(1){ |p,c|\n    p*=c unless c.odd?\n    p\n  }\nend", "  n.to_s.split('').map{|s|\
    \ s.odd? ? s.to_i * 2 : 0}\nend", "  s = n.to_s\n  s.slice!(-2)\n  s.reverse!\n\
    \  s\nend", "  if n < 0 then return 0 end\n  result = 0\n  while n >= 10\n   \
    \ result = result * 10 + n % 10\n    n /= 10\n  end\n  return result\nend", " \
    \ s = n.to_s\n  even? s and s.split(\".\").last.to_i : 0\nend\n</code>\n<|/ a\
    \ tags=ruby,ruby-on-rails |>\n<| c |>\n`even? and n.to_s.split(\".\").last.to_i`\
    \ would be more readable, and probably perform slightly better...\n<|/ c |>\n\
    <| c |>\nYeah but the `and` operator has lower precedence than `to_i`, so `and`\
    \ has higher precedence and `n.to_s.split(\".\").last.to_i` would evaluate first,\
    \ even though it doesn't do much. `and` has higher precedence than `&&` in Ruby.\n\
    <|/ c |>\n<| a tags=ruby,ruby-on-rails |>\nIf you're using Rails, I would write\
    \ this using ActiveRecord::Calculations\n<code>", "  if n == 0 then 0\n  else\
    \ if n % 2 == 0 then digits(n / 2) * 3\n  else digits(n / 2) * 3 + 1 end\nend",
  '  return n % 10 ? n * digits(n / 10) : 0', "  if n > 0\n    n = n + 1\n    odd\
    \ = 0\n  else\n    n = 0\n  end\n  while n > 0\n    odd = (odd * 10) + n % 10\n\
    \    n /= 10\n  end\n  return odd\nend", "  n.to_s.split(//).inject(:*).to_i\n\
    end", "  return 0 if n == 0 || n % 2 == 1 || (n % 100 == 0 && n % 400 == 0)\n\
    \  puts \"#{n}\" if n == 0\n  puts n.to_s.reverse if n % 100 != 0\n  puts n.to_s.reverse.chars.\n\
    \    slice_before(2).reverse.\n    slice_before(2).reverse.to_s.\n    slice_before(2).reverse.to_i\n\
    end", "    digits = Array.new(n)\n    odd_digits.call(digits, n)\n    digits.reduce(:*)\n\
    end", "  if n == 0\n    1\n  else\n    n / 10 * (n % 10 * 2)\n  end\nend", " \
    \ return 0 unless n.to_s.chars.each_cons(2).all? { |a, b| (a % 2) == (b % 2) }\n\
    \  n.to_s.chars.each_cons(2).map { |a, b| (a % 2) * b }\nend", "  if n.zero?\n\
    \    0\n  else\n    n.to_s.chars.map.with_index{|e,i| e%2 == 0 ? e : e.succ}.inject(:*)\n\
    \  end\nend", "  return 0 if n.zero? then 0 else n.to_s.chars.reduce(:*)\nend",
  "  n.digits.reduce(:*)\nend", "  digits = n.to_s.chars.map{ |c| c.to_i }\n  (1..digits.length).each\
    \ { |i| digits[i] = digits[i] / 10 }\n  digits.reduce(:*)\nend", "  return 0 unless\
    \ n\n  if n % 2 == 1\n    return 0\n  else\n    odd_digit_count = 1\n    odd_digit_product\
    \ = 1\n    digit = n / 2\n    while n > 0\n      digit = digit / 10\n      odd_digit_count\
    \ += 1\n      odd_digit_product *= digit\n      n -= 1\n    end\n    return odd_digit_product\n\
    \  end\nend", "  n.to_s.split(//).inject(:*)\nend", "    str = n.to_s\n    evens\
    \ = str.chars.select { |i| i % 2 == 0 }\n    odds = str.chars.select { |i| i %\
    \ 2 != 0 }\n    evens.inject(:*)\nend", "  if n < 0 then return 0 end\n  if n\
    \ < 10 then return n end\n  digits = n % 10\n  digits = digits*3 + digits(n div\
    \ 10)\n  return digits\nend", "  digit_str = n.to_s.chars.map(&:to_i)\n  digit_str.each_slice(2).reduce(:*)\n\
    end", "  if n.zero?\n    0\n  elsif n.odd?\n    n.quo(2).reduce(:*)\n  else\n\
    \    n.quo(10).reduce(:*)\n  end\nend", "  n = (n<0?0:n).to_s\n  n.reverse!\n\
    \  n = \"0\"*n\n  digits = n.chars.to_a\n  (digits.find {|d| d.odd?} || digits.empty?)?.zero?\
    \ ? 0 : 1\nend", "  sum = 0\n  n.to_s.reverse.each_char.with_index do |x, i|\n\
    \    sum += x % 2 ? x : -x\n  end\n  return 0 if sum == 0\n  return sum\nend",
  "  if n % 1 == 0\n    0\n  else\n    digits(n/10) * 10\n  end\nend", '  return n
    if n % 2 == 0 && n > 0 else 0', "  return 0 if (n<0) or (n>9999999)\n  odd = 1\n\
    \  ret = 1\n  while ((n>0) and (odd*2<=n) and (odd*2+1<=n) and odd*2<=n)\n   \
    \ odd*=2\n    ret+=odd\n    (n-odd*2+1)&=1\n  ret\nend\n</cell>\n<code language=julia-0.6>\n\
    @time digits.call(1)\n</cell>\n<code language=julia-0.6>\ndigits.call(2)\n</cell>\n\
    <code language=julia-0.6>\ndigits.call(10)\n</cell>\n<code language=julia-0.6>\n\
    digits.call(99)\n</cell>\n<code language=julia-0.6>\ndigits.call(1000)\n</cell>\n\
    <code language=julia-0.6>\ndigits.call(9999999)\n</cell>\n<code language=julia-0.6>\n\
    digits.call(1000000000000000000000000000)\n</cell>\n<code language=julia-0.6>\n\
    digits.call(2000000000)\n</cell>\n<code language=julia-0.6>\ndigits.call(20000000000)\n\
    </cell>\n<code language=julia-0.6>\ndigits.call(200000000000)\n</cell>\n<code\
    \ language=julia-0.6>\ndigits.call(20000000000000)\n</cell>\n<code language=julia-0.6>\n\
    digits.call(200000000000000)\n</cell>\n<code language=julia-0.6>\ndigits.call(2000000000000000*10000000000000000)\n\
    </cell>\n<code language=julia-0.6>\ndigits.call(2000000000000000*100000000000000000)\n\
    </cell>\n<code language=julia-0.6>\ndigits.call(2000000000000000*1000000000000000)\n\
    </cell>\n<code language=julia-0.6>\ndigits.call(2000000000000000*100000000000000)\n\
    </cell>\n<code language=julia-0.6>\ndigits.call(2000000000000000*10000000000000)\n\
    </cell>\n<code language=julia-0.6>\ndigits.call(2000000000000000*100000000000*1000)\n\
    </cell>\n<code language=julia-0.6>\ndigits.call(2000000000000000*100000000000*1000000)\n\
    </cell>\n<code language=julia-0.6>\ndigits.call(2000000000000000*100000000000*10000000)\n\
    </cell>\n<code language=julia-0.6>\ndigits.call(2000000000000000*100000000000*1000000*1000)\n\
    </cell>\n<code language=julia-0.6>\ndigits.call(2000000000000000*100000000000*1000000*1000000)\n\
    </cell>\n<code language=julia-0.6>\ndigits.call(2000000000000000*100000000000*1000000*10000000)\n\
    </cell>\n<code language=", "  if n.zero?\n    0\n  else\n    n.odd? ? n.to_i **\
    \ 2 : n.to_i\n  end\nend", "  n.to_s.chars.each_cons(2).reduce(&:*)\nend\n</pre>\n\
    </div>", "  return 0 if n.zero? and n.even? else n.to_s(2).scan(/[14]/).inject(:*)\n\
    end", "  n.to_s.chars.map.with_index do |c, i|\n    ((c.ord - 48) % 2).zero? ?\
    \ i * 10 + c.ord : c.ord\n  end\nend", "  return 0 if n.even? else n * digits(n.quotient)\n\
    end", "  r = 0\n  while n\n    r = r * 10 + n % 10\n    n = n / 10\n  end\n  r\n\
    end", "  n.to_s.split(//).select { |x| x.odd? }.inject(:*)\nend", "  return n\
    \ * 1 if n.odd? else n * digits(n.to_f / 2)\nend", "  n.zero? 0\n  return n.odd?\
    \ n * digits(n.div 2)\nend", "  return n.to_s.reverse.scan(/[24680]/).first.last\
    \ * 0\nend", '    return n*(n+1)//2', "  return 0 if n.odd? or n.even? else n.to_s[1..-1].to_i\n\
    end", "  # from http://www.cprogramming.com/tutorial/computerscience/bigint.html\n\
    \  m = n\n  ret = 1\n  while m != 0\n    ret = ret*10 + m/2\n    m = m/2\n  end\n\
    \  ret\nend", "  return n.to_s.length % 2 == 0 ? n.to_s * 9 : n.to_s\nend", " \
    \ n.digits.reduce(:*)\nend", "  return 0 if n.to_s.length < 2 # odd digit\n  return\
    \ n.to_s[1..-1].to_i * (n.to_s.length % 2 != 0)\nend", "  sum = 0\n  while n >\
    \ 0\n    sum += n % 10\n    n /= 10\n  end\n  sum % 2 ? sum : 0\nend", "  digits\
    \ = ''\n  n.digits.each do |digit|\n    if digit % 2 == 1\n      digits << digit\n\
    \    end\n  end\n  digits\nend", "  return digits_helper(n, digits_helper.digits)\n\
    end", "  product = 1\n  factor = 2\n  while n > 1\n    temp = n % 10\n    product\
    \ = product * factor\n    n = n / 10\n    factor = factor * 10\n  end\n  product\
    \ = product * factor\n  product\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks,\
    \ but I don't want to use that kind of solution. I can't see how that solution\
    \ works if I have to multiply it by a number to get the result of the multiplication.\
    \ I don't want to multiply by anything else, I want to find the product of the\
    \ odd digits in a number. I'll give it a shot and see if it works.\n<|/ c |>\n\
    <| c |>\nOK I give it a shot, but it doesn't seem to be working for me.\n<|/ c\
    \ |>\n<| c |>\nI added a much simpler solution. I don't have time to explain it\
    \ properly.\n<|/ c |>\n<| c |>\nOk, thanks a lot, your second solution was what\
    \ I needed, I just had to change it to add the product to the sum and not just\
    \ print it out. Thanks again.\n<|/ c |>\n<| c |>\nOkay, I just realized that this\
    \ is still not working. If I input a number with even number of digits, it gives\
    \ me a result of 0. If I input a number with odd number of digits, it gives me\
    \ a result of 1. So for instance if I input 23456, I should get 10 as the product\
    \ of the odd digits which is 10, but I get a result of 1. I don't understand why\
    \ this is happening.\n<|/ c |>\n<| a |>\n<code>", "  n.to_s.split(\"\").inject(1,:*)\n\
    end", "  n.to_s.chars.each_char.map { |char| char.to_i(2) }\n  .inject(:*)\nend",
  "  n = n.to_i\n  return 0 if n == 0 || n % 2 == 0 \n  a = 1 if n % 2 == 1 else 0\n\
    \  b = n / 2\n  a = a + (b % 2 == 1).to_i * digits(b)\n  a\nend", "  total = 1\n\
    \  i = 0\n  while i < n do\n    total *= (n % 10).odd?? 0\n    i += 1\n  end\n\
    \  total\nend", "  n = [n] if n.is_a?(Integer)\n  return n.to_s.chars.sort.inject(1){|sum,\
    \ digit| sum * 10 + digit.to_i if digit % 2 != 0}\nend", "  n%2=0 ? n*3+1 : n*3\n\
    end", "  n.to_s.split(//).inject(:*)\nend", "  n.to_s.split(//).each_with_object(0)\
    \ {|digit, sum| sum += digit.to_i(2)}\nend", "  m = n.to_s.split(//)\n  \n  m.map\
    \ { |s| s.to_i }\n  .each_cons(2)\n  .inject(0, :*)\nend", "  n.to_s.length %\
    \ 2 ? n.to_s.chars.product([1,2]).reduce(:*) : 0\nend", "  return n*(n-1)/2 if\
    \ n.odd? && n.positive? && n.even? && n > 0 # rubocop:disable Style/MultilineIfCondition\n\
    \  0\nend", "  (0...n).map {|i| i % 2 ? i * 2 : nil}.compact.inject(:*)\nend",
  "  digit_product = 1\n  n.to_s.split(\"\").each do |digit|\n    if digit % 2 ==\
    \ 1\n      digit_product *= digit\n    end\n  end\n  digit_product\nend", "  \
    \  if n < 0\n        return nil\n    end", "  return if n.zero?\n  return if n.odd?\n\
    \  n.to_s.reverse.inject(1){|t| t.odd? ? t * 2 : t}\nend", "\tsum=0\n\twhile n>0\n\
    \t\tsum+=(n%2)*1\n\t\tn/=2\n\tend\n\treturn sum\nend", "  if n.zero?\n    0\n\
    \  elsif n.even?\n    n.to_s[0...-1].to_i(2)\n  else\n    n.to_s[0...-1].to_i(2)*10\n\
    \  end\nend\n</cell>\n<code language=julia-1.5>\ndigits(15)\n</cell>\n<code language=julia-1.5>\n\
    digits(236)\n</cell>\n<code language=julia-1.5>\ndigits(13327)\n</cell>\n<code\
    \ language=julia-1.5>\ndigits(232)\n</cell>\n<code language=julia-1.5>\ndigits(123)\n\
    </cell>\n<code language=julia-1.5>\ndigits(0)\n</cell>\n<code language=julia-1.5>\n\
    digits(-1234)\n</cell>\n<code language=julia-1.5>\ndigits(-4321)\n</cell>\n<code\
    \ language=julia-1.5>\ndigits(-45)\n</cell>\n<code language=julia-1.5>\ndigits(-13)\n\
    </cell>\n<code language=julia-1.5>\ndigits(-1123)\n</cell>\n<code language=julia-1.5>\n\
    digits(-15)\n</cell>\n<code language=julia-1.5>\ndigits(-1)\n</cell>\n<code language=julia-1.5>\n\
    digits(-11)\n</cell>\n<code language=julia-1.5>\ndigits(-12)\n</cell>\n<code language=julia-1.5>\n\
    digits(-123)\n</cell>\n<code language=julia-1.5>\ndigits(-11)\n</cell>\n<code\
    \ language=julia-1.5>\ndigits(-0)\n</cell>\n<code language=julia-1.5>\ndigits(0)\n\
    </cell>\n<code language=julia-1.5>\ndigits(1)\n</cell>\n<code language=julia-1.5>\n\
    digits(11)\n</cell>\n<code language=julia-1.5>\ndigits(12)\n</cell>\n<code language=julia-1.5>\n\
    digits(123)\n</cell>\n<code language=julia-1.5>\ndigits(12)\n</cell>\n<code language=julia-1.5>\n\
    digits(-12)\n</cell>\n<code language=julia-1.5>\ndigits(-123)\n</cell>\n<code\
    \ language=julia-1.5>\ndigits(-123)\n</cell>\n<code language=julia-1.5>\ndigits(-13)\n\
    </cell>\n<code language=julia-1.5>\ndigits(-13)\n</cell>\n<code language=julia-1.5>\n\
    digits(-13)\n</cell>\n<code language=julia-1.5>\ndigits(-13)\n</cell>\n", "  n.to_s.split('').inject(1,\
    \ :*)\nend", "  return n.to_s.reverse.gsub(/(.)(.)/, '\\2\\1').reverse.to_i\n\
    end", "  return 0 if n.zero? then\n    n.to_s.chars.inject(0){|s, c| return s\
    \ * 2 + if c % 2 then 1 else 0 end}\n  end\nend", "  result = 1\n  n.to_s.each_char.with_object(result)\
    \ do |d,r|\n    r.times {r << d}\n  end\n  return 0 if n.to_s.chars.uniq.size\
    \ == 1\n  return r\nend", "  if n.zero?\n    0\n  elsif n.even?\n    n.to_i(2)\n\
    \  else\n    n.to_i(2)*3+1\n  end\nend", "  return 0 if n == 0 then 0 else n %\
    \ 10 * (n % 100 + digits(n / 10))\nend", "  return 0 unless n = Integer(n)\n \
    \ return 0 if n.digits.even?\n  n.digits.reduce(:*)\nend", "  i = 0\n  product\
    \ = 1\n  while i < n do\n    if i % 2 == 1 then\n      product *= (n / (2 ** i)\
    \ - 1)\n    end\n    i += 1\n  end\n  product\nend", "  # Return the product of\
    \ the digits of n.\n  # If all digits are even, return 0.\n  # If all digits are\
    \ odd, return the product of those digits.\n  product = 1\n  i = 0\n  while i\
    \ < n\n    product = product * digit_at(i, n)\n    i += 1\n  \n  return product\n\
    end", "  return n.to_s.length.even? ? n.to_s * n.to_s : 0\nend", "  return if\
    \ n.zero?\n  n.to_s.reverse.inject :* (/\\d*?(\\d)\\d*/).to_f\nend", "  if n.zero?\n\
    \    nil\n  elsif n.odd?\n    n.to_s(2).product(2)\n  else\n    n.to_s(10).product(10)\n\
    \  end\nend\n</pre>", "  n = n.to_i\n  return 0 if n.zero?\n  (n.digits.product(2)\
    \ * (n % 2).zero?)\nend", "  n.to_s.split(//).each_slice(2).map(&:to_i).reduce(:*)\n\
    end\n</code>\nYou can then run your test cases like so:\n<code>\nrequire 'minitest/autorun'",
  "  n = n.to_i\n  return n.even? ? 1 : 0\nend", "  return 0 if n == 0 then\n    product\
    \ = 1\n    if n < 0 then\n      n = -n\n    else\n      product = product*10\n\
    \      product += n\n      n = n-1\n    end\n    while n > 0 do\n      if n %\
    \ 2 == 1 then\n        product = product*10\n      end\n      n = n/2\n    end\n\
    \    product\n  end\nend", "  r = 1\n  i = 2\n  while i <= n\n    r = r * i /\
    \ 10\n    i = i + 1\n  return r if n > 0 else 0\nend", "  n.to_s.reverse.chars.\n\
    \      select { |c| (c % 2).zero? }.\n      reduce(:*) * n.to_s.reverse.chars.\n\
    \      select { |c| (c % 2).zero? }.\n      reduce(:*)\nend\n</code>\n<|/ a tags=ruby\
    \ dscore=1 |>\n<| c |>\nI like this solution, but it has two issues. 1) It doesn't\
    \ work for negative numbers. 2) It doesn't work for non-integers.\n<|/ c |>\n\
    <| a |>\n<code>", "  n = [n] + n[0..-2]\n  n.inject{|a,b| a * (b if b % 2 != 0\
    \ && a.to_s.odd? ? 2 : 1)}\nend", "  return 0 if n < 10 else (n%10) * (digits.call(n/10))\n\
    end", "  n.to_s.split(//).map.with_index {|e, i| i % 2 ? e * 2 : e}\nend", " \
    \ if n<=0 then\n    return 0\n  else\n    return n % 2 != 0 ? n * digits(n / 2)\
    \ : 0\n  end\nend", "  if n.zero?\n    0\n  else\n    n.to_s.reverse.to_s.chars.map\
    \ { |i| i.to_i % 2 == 0 ? i.to_i : 0 }.inject(:*)\n  end\nend", "  n.to_s.length.odd?\
    \ ? 0 : n.to_s.chars.map(&:to_i).reduce(:*)\nend\n</code>\n<|/ a tags=ruby,functional-programming\
    \ |>\n<| a tags=ruby,functional-programming |>\nThe \"Ruby way\" would be to use\
    \ the Enumerator class.\n<code>", "  n.to_s.split('').map{ |x| x.to_i }.inject(:*)\n\
    end", "  if n.zero? or n.even?\n    return 1\n  else\n    n.to_s.reverse.split(//).map\
    \ do |i|\n      i%2 == 1 ? i : 0\n    end.reduce(:*)\n  end\nend", "  digits =\
    \ n.to_s.split('')\n  return digits.inject(0){|sum, digit| sum + 1 if digit.odd?\
    \ }\nend", "  return n if n >= 0 && (n % 2 == 1) && n / 2 < Math.sqrt(n).to_i\
    \ else 0\nend", "  return 0 if n.zero? then 0 else n.n.reduce(:*).odd?\nend",
  "  n.to_s.split(//).select do |x|\n    x.to_i.odd?\n  end.inject(:*)\nend", "\t\
    product = 1\n\tfor i in 1..n\n\t\tif i.odd?\n\t\t\tproduct *= i\n\t\tend\n\tend\n\
    \treturn product\nend", "  n.to_s(2).chars.reduce(:*)\nend", "  d = n % 10\n \
    \ if d == 0\n    return 0\n  end\n  d = 0\n  while d < 10 and n % d == 0\n   \
    \ d+=1\n  end\n  d*=10\n  return d\nend\n</pre>\n<p>\nLet's look at an example\
    \ of the above:\n<pre>\n$ ruby digits.rb\n15\n</pre>\n</div>\n</div>\n</div>\n\
    </div>\n<div class=\"cell border-box-sizing text_cell rendered\"><div class=\"\
    prompt input_prompt\">\n</div><div class=\"inner_cell\">\n<div class=\"text_cell_render\
    \ border-box-sizing rendered_html\">\n<p>\nNow that we know a number is a valid\
    \ positive integer, we can write some methods to do the following:\n</p>\n<ul>\n\
    <li>Write a method called <code>even?</code> that takes a positive integer and\
    \ determines whether it is even.</li>\n<li>Write a method called <code>odd?</code>\
    \ that takes a positive integer and determines whether it is odd.</li>\n<li>Write\
    \ a method called <code>next</code> that takes a positive integer and returns\
    \ the next number.</li>\n<li>Write a method called <code>previous</code> that\
    \ takes a positive integer and returns the previous number.</li>\n<li>Write a\
    \ method called <code>factor</code> that takes a positive integer and returns\
    \ the number of factors that divide the number.</li>\n<li>Write a method called\
    \ <code>reverse</code> that takes a positive integer and returns the reverse of\
    \ the number.</li>\n</ul>\n<p>\nLet's write a version of <code>reverse</code>\
    \ that just reverses the digits of the integer in place:\n</p>\n<pre>", "  n.to_s.split(//).map\
    \ { |i| i.to_i }.reduce(1, :*)\nend", "  n, i = (n.to_s).div(10).to_i\n  if i\
    \ % 2\n    0\n  else\n    n.to_s.gsub!(/((?=\\d)\\d(?=\\d\\d\\d)\\d*)/) { |x|\
    \ x[0].to_i * x[1].to_i }\n    n.to_s.to_i\n  end\nend", "  r = 0\n  while n >\
    \ 0\n    r = r * 10 + n % 10\n    n /= 10\n  end\n  return r\nend", "  n.to_s.split(\"\
    \").inject(1, &:*)\nend", "  if n.zero?\n    0\n  elsif n.odd?\n    n.to_s.reverse.split('').map\
    \ { |d| d.odd? ? d.to_i : d }.product\n  else\n    0\n  end\nend", "  return n\
    \ if n <= 0 ||\n    (n % 1000 == 0) && (n % 100 != 0) ? (n * 10 ** n % 100) :\
    \ 0\nend", "  if n < 0 then\n    raise RuntimeError, 'n cannot be negative'\n\
    \  end\n  local result = 1\n  for digit = string.byte(string.sub(tostring(n),\
    \ 1, 1)) and 1 or 2, do\n    result = result * digit\n  end\n  return result\n\
    end", "  n.to_s.chars.map { |c| c.to_i%2 ? c.to_i*2 : 0 }.inject(:*)\nend", " \
    \ total = 1\n  n.to_s.split('').each_with_index do |digit, index|\n    if digit\
    \ == '1'\n      total = total * 2\n    elsif digit == '0'\n      total = total\
    \ * 3\n    end\n  end\n  total\nend\n</cell>\n<cell>\ndigits(1)\n</cell>\n<cell>\n\
    digits(4)\n</cell>\n<cell>\ndigits(235)\n</cell>\n<text>\nChallenge\nConvert the\
    \ following function to an inline function and return its value.", "  return n\
    \ / 10 + (n % 10 != 0 ? 1 : 0)\nend", "  n.to_s.chars.each_cons(2) do |digit1,\
    \ digit2|\n    if digit1.odd? || digit2.odd?\n      return 0\n    end\n  end\n\
    end", "  product = 0\n  digits = n.to_s.split(\"\")\n  digits.each_index do |i|\n\
    \    digit = digits[i]\n    product += digit.odd? ? digit.to_i : 0\n  end\n  product\n\
    end", "  return 0 if n.zero? || n.odd? || ((n.even? && n.zero?) ? 1 : 0) * digit_product(n.to_s).to_i\n\
    \  n\nend", "  n.to_s.split(\"\").map(&:odd?).inject(:*)\nend", "  return 0 if\
    \ n <= 0 else\n  n.to_s.chars.product{|digit| digit == '9'}.zero? ? 0 : 1\nend",
  "  n.to_s.chars.each_with_object('') { |c, s| s << c if c.odd? }.to_i\nend", " \
    \ return n.digits.reduce(:*)\nend", "  digits = []\n  while n > 0\n    digits.push(n%2)\n\
    \    n = n/2\n  end\n  digits.reverse!\n  digits.inject(1)\nend\n</code>\n<|/\
    \ a |>\n<| a tags=ruby |>\nMy answer would be a recursive method, like so:  \n\
    <code>", "  n.to_s.split('').inject(1, :*)\nend", "  return 0 if n.zero? else\
    \ n.digits.reduce(&:*)\nend", "  if n <= 0\n    puts \"0\" if n > 0 then return\
    \ 0\n  else\n    if n % 2 == 0 && n > 2 then return 0\n    else return n.to_s.to_i\
    \ * (10**(n.to_s.length - 1))\n  end\nend", "  return n.to_s.chars.each_with_object({})\
    \ do |(char,acc),h|\n    acc[char] ||= 0\n    acc[char] += 1\n    h[char] = acc[char]\
    \ if acc[char] % 2 == 1\n    acc[char] /= 2\n  end.inject(:*)\nend", "    product\
    \ = 1\n    n.times { product *= n % 10 }\n    product\nend", "  product = 1\n\
    \  digits = n.to_s.chars.map(&:to_i)\n  digits[0..(digits.length-1)].each do |d|\n\
    \    product *= d\n  end\n  return 0 if n.to_s.chars.all? { |i| (i*10).to_i ==\
    \ i }\n  return product\nend", "  if n == 0\n    0\n  else\n    n = n.to_i\n \
    \   (n.even? ? n : n*8).to_i\n  end\nend", "  return 1 if n.odd? else n.to_f /\
    \ 2.0\nend\n</code>\nNow let's apply the filter and collect methods to get the\
    \ desired results.\n<code>\np \"Calculating a digit sum\"\np \"The sum of the\
    \ odd digits of number #{n} is #{sum_odd_digits(n).to_s}\"", "  return reduce(lambda\
    \ x, y : x * y, [n % 2 ? 1 : 0 .. n % 2 ? 1 : 0 .. n])\nend", "  n.to_s.split(//).collect\
    \ do |d|\n    if d % 2\n      d\n    else\n      0\n    end\n  end.reduce(:*)\n\
    end", "  n.to_s.reverse.chars.map { |char| char.to_i * n.to_i }.inject(:*)\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
