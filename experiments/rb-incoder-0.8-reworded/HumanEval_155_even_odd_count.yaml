name: HumanEval_155_even_odd_count
language: rb
prompt: "# Given an integer. return an array that has the number of even and odd digits\
  \ respectively.\n# Example:\n# >>> even_odd_count.call(-12)\n# [1, 1]\n# >>> even_odd_count.call(123)\n\
  # [1, 2]\ndef even_odd_count(num)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_even_odd_count\n\
  \    candidate = method(:even_odd_count)\n    assert_equal([0, 1], candidate.call(7))\n\
  \    assert_equal([1, 1], candidate.call(-78))\n    assert_equal([2, 2], candidate.call(3452))\n\
  \    assert_equal([3, 3], candidate.call(346211))\n    assert_equal([3, 3], candidate.call(-345821))\n\
  \    assert_equal([1, 0], candidate.call(-2))\n    assert_equal([2, 3], candidate.call(-45347))\n\
  \    assert_equal([1, 0], candidate.call(0))\n  end\nend\n"
completions: ["  even = []\n  odd = []\n  while num != 0\n    if num % 2 == 0\n  \
    \    even << num\n    else\n      odd << num\n    end\n    num = num / 2\n  end\n\
    \  return [even, odd]\nend", "  count = 0\n  num.to_s.split(\"\").each do |x|\n\
    \    if x % 2 == 0\n      count += 1\n    end\n  end\n  [count, count + 1]\nend",
  "  even_odd = 0\n  while num > 0\n    if num % 2 == 0\n      even_odd += 1\n   \
    \   num -= 2\n    else\n      num -= 1 \n      even_odd += 2\n  end\n  even_odd.reverse\n\
    \  return even_odd\nend\n</cell>\n<text>\nQuestion 5 (5 - 12 Points)\nExplain\
    \ how and why you chose this method of solving the problem.", "  num = abs(num)\n\
    \  even = num % 2 == 0\n  odd = num % 2 != 0\n  return [even, odd]\nend", "  num\
    \ = num.to_i\n  even_count = 0\n  odd_count = 0\n  while (num > 0)\n    if (num\
    \ % 2 == 0)\n      even_count += 1\n    else\n      odd_count += 1\n    num =\
    \ num / 2\n  return [even_count, odd_count]\nend", "  even = num / 2\n  odd =\
    \ num - even\n  if even % 2 == 1\n    even += 2\n  end\n  if odd % 2 == 0\n  \
    \  odd -= 2\n  end\n  return [even, odd]\nend", "  if num < 0\n    return []\n\
    \  odd = 1\n  even = 1\n  while num != 0\n    odd = odd + (num % 10).even? : 1\n\
    \    even = even + (num % 10).odd? : 1\n    num = num / 10\n  end\n  [1, odd]\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a |>\nHere is a ruby solution:\n<code>\n def\
    \ odd_even_count_in_str(num)\n  arr = num.to_s.split(//)\n  arr.each_with_index\
    \ do |n, i|\n    if i % 2 == 0\n      if n != \"\"\n        arr[i] = nil\n   \
    \   end\n    else\n      if n != \"\"\n        arr[i] = n\n      end\n    end\n\
    \  end\n  arr\nend\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| a |>\nHere is a simple\
    \ solution:\n<code>", "  odd_count = -1\n  even_count = 0\n  while num > 0\n \
    \   odd_count += 1\n    num /= 10\n  end", "  odd_count = 0\n  even_count = 0\n\
    \  if num >= 0\n    if num % 2 == 1\n      odd_count += 1\n      num = num / 2\n\
    \    end\n    until num == 0\n    if num % 2 == 0\n      even_count += 1\n   \
    \   num = num / 2\n    end\n    until num == 0\n  end\n  return [even_count, odd_count]\n\
    end", "  even_count, odd_count = 0, 1\n  while num > 0\n    case num % 10\n  \
    \  when 0 then odd_count += 1\n    when 1 then even_count += 1\n    else break\n\
    \    num /= 10\n  end\n  [even_count, odd_count]\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nYour code is O(n^2). The `case` statement can be replaced with\
    \ `num = num / 10` and the loop can be replaced with `while num > 0`.\n<|/ c |>\n\
    <| c |>\nThe OP's original code was O(N). A change to make it O(N) would require\
    \ using an array of integers to store the even and odd digits as we go through\
    \ the digits.\n<|/ c |>\n<| c |>\nApologies, I thought it was O(nlogn) because\
    \ of the use of partition. My mistake.\n<|/ c |>\n<| a tags=ruby,arrays |>\nHere's\
    \ an O(n) solution:\n<code>", "  odd = 1\n  even = 0\n  if num < 0 \n    return\
    \ even, odd\n  while num != 0\n    if num % 2 > 0\n      even = even + 1\n   \
    \ num = num / 2\n  end\n  return even, odd\nend", "  num_digits = num.to_s.length\n\
    \  even = 0\n  odd = 0\n  i = 0\n  while i < num_digits\n    if i % 2 == 0\n \
    \     even += 1\n    else\n      odd += 1\n    i += 1\n  end\n  return [even,\
    \ odd]\nend\n</code>\nNow it's easy, you can just change your return statement\
    \ to return [even, odd, num], this will give you the even and odd numbers along\
    \ with the number.\n<code>", "  count = 1\n  while num > 0\n    if num % 2 ==\
    \ 0\n      count += 1\n    else\n      count += 2\n      num -= num / 10\n  end\n\
    \  count\nend", "  return [num.to_s.chars.map(&:to_i).count(&:even?), num.to_s.chars.map(&:to_i).count(&:odd?)]\n\
    end", "  result = []\n  while num != 0\n    result << ((num.even? ? 1 : 0) + num.odd?)\n\
    \    num /= 10\n  end\n  result\nend", "  if num < 0\n    puts 'Parameter is less\
    \ than 0!'\n  elsif num == 0\n    puts 'Parameter is 0!'\n  elsif num > 0\n  \
    \  digit = num.to_s.reverse\n    even = 0\n    odd = 0\n    while digit.length\
    \ != 0\n      if digit.to_i(10) % 2 == 0\n        even += digit.to_i(10)\n   \
    \   else\n        odd += digit.to_i(10)\n      end\n      digit = digit.to_s.reverse\n\
    \    end\n    puts [even, odd]\n  end\nend\n</code>\n<|/ a |>\n<| a tags=ruby,arrays\
    \ dscore=0 |>\n<code>", "  if num < 0\n    return []\n  else\n    even = (num\
    \ / 2).floor\n    odd = (num / 2).ceil\n    odd_count = odd.to_i\n    even_count\
    \ = (num - even).to_i\n    even_odd_count = even_count + odd_count\n    even_odd_count.zero?\
    \ ? even_odd_count : [even_odd_count, odd_count]\n  end\nend", "  if num < 0\n\
    \    puts \"You passed a negative number, please pass a non negative number\"\n\
    \  else \n    odd = 1\n    even = 0\n    i = 0\n    while i < num\n      i = i\
    \ + 1\n      if num % 2 > 0\n        even = even + 1\n      else \n        odd\
    \ = odd + 1\n    end\n    puts \"Even digits: #{even}\"\n    puts \"Odd digits:\
    \ #{odd}\"\n  end\nend", "  num.to_s.split(\"\").each_with_object([]) do |digit,\
    \ ary|\n    digit.to_i.odd? == true ? ary.push(1) : ary.push(0)\n  end\nend",
  "  return [num, num/2, num%3 == 0 ? 1 : 2]\nend", "  even_odd = [num % 2 == 0, num\
    \ % 2 != 0]\n  even_odd_count = (even_odd.inject(:+), even_odd.size)\n  return\
    \ even_odd_count\nend", "  num.zero? ? [num].flatten.map {|n| n/10}.product\n\
    \               : even_odd_count(num/10) * 10 + [num%10]\nend", "  return [num\
    \ % 2 == 0 ? 1 : num % 3 == 0 ? 2 : 0]\nend\n</code>\nThis is more complex code\
    \ so let me show you some simplification options.\n<code>", "  # Convert to string\
    \ to trim whitespace.\n  num_str = num.to_s.strip.downcase\n  # If number is negative,\
    \ flip it.\n  if num_str[0] == \"-\"\n    num_str = (num_str[1] + \"-\" + num_str[0]).to_s\n\
    \  # Split into an array of digits\n  num_arr = num_str.split(\"0\")\n  # If the\
    \ length of the array is 0, return an empty array.\n  return num_arr.empty? ?\
    \ [] : [num_arr.count { |x| x.to_i.even? }, num_arr.count { |x| x.to_i.odd? }]\n\
    end", "  digits = num.to_s.chars\n  even = []\n  odd = []\n  for i in digits\n\
    \    if i.to_i % 2 == 0\n      even.push(i)\n    else\n      odd.push(i)\n   \
    \ end\n  end\n  even.count!\n  odd.count!\n  return [even, odd]\nend", "  if num\
    \ == 0\n    []\n  else\n    (0..num).inject([]) do |odd, i|\n      if i % 2 ==\
    \ 0\n        odd << i\n      else\n        odd << i + 1\n      end\n    end\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI'm looking at your answer and it seems\
    \ like this should be the accepted answer because it uses functional programming\
    \ in a very ruby-like way.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  return [num.to_s.length\
    \ % 2 == 0 ? num.to_s.length / 2 : (num.to_s.length / 2) + 1, num.to_s.length\
    \ % 2 == 0 ? num.to_s.length / 2 + 1 : num.to_s.length / 2]\nend", "  even = 0\n\
    \  odd = 0\n  while num != 0\n    digit = num % 10\n    num = num / 10\n    if\
    \ digit % 2 == 0\n      even += 1\n    else\n      odd += 1\n  end\n  return [even,\
    \ odd]\nend", "  num.zero? ? [1, 1] :\n    even = num.quot(2).floor\n    odd =\
    \ (num - even).quot(2).floor\n    even.zero? ? odd.zero? ? [1, 0] :\n      even\
    \ == odd ? [1, 0] :\n        even.zero? ? odd.zero? ? [0, 0] :\n          even.zero?\
    \ ? [1, 2] :\n            even.zero? ? [2, 0] :\n              odd.zero? ? [1,\
    \ 1] : [2, 1]\nend", "  odd = num.to_s.reverse.gsub(/(.)\\1*/,'\\\\1').reverse\n\
    \  even_count = ((num.to_s.reverse.gsub(/(.)\\1*/,'\\\\1').reverse.count('0')).to_f\
    \ / 2.0).ceil\n  return [even_count, odd]\nend", "  digits = num.to_s\n  odd =\
    \ digits[0..digits.length-1].each_char.count {|x| x.to_i%2}\n  even = digits[0..digits.length-1].each_char.count\
    \ {|x| x.to_i==0}\n  return [even, odd]\nend", "  digits = num.to_s.split('')\n\
    \  odd_count = []\n  even_count = []\n  \n  odd_count.push 1 if digits.length\
    \ % 2 == 0 and digits[0] == '2' \n  even_count.push 0 if digits.length % 2 ==\
    \ 0 and digits[0] == '2'\n  \n  odd_count.push 1 if digits.length % 2 != 0 and\
    \ digits[0] == '2'\n  even_count.push 0 if digits.length % 2 != 0 and digits[0]\
    \ == '2'\n  \n  return [odd_count, even_count]\nend", "  even = []\n  odd = []\n\
    \  for i in 1..num\n    (num % i) == 0 ? even << i : odd << i\n  end\n  [even,\
    \ odd]\nend", "  digits = num.to_s.split(\"\").map(&:to_i)\n  even_digits = digits.select{|d|\
    \ d % 2 == 0}\n  odd_digits = digits.select{|d| d % 2 == 1}\n  [even_digits, odd_digits]\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThe OP didn't ask to find the number of even\
    \ and odd digits in a given number.\n<|/ c |>\n<| c |>\nThe question was about\
    \ how to count the numbers of even and odd digits in the number given, not the\
    \ number itself.\n<|/ c |>\n<| c |>\nI interpreted the words \"Given an integer.\
    \ return an array that has the number of even and odd digits respectively\" as\
    \ meaning \"given the number as an integer return an array that has the number\
    \ of even and odd digits respectively\". If that's not correct, I'll just delete\
    \ this answer.\n<|/ c |>\n<| c |>\nYou interpreted it correctly. This answer was\
    \ really helpful.\n<|/ c |>\n<| c |>\nI didn't vote this down, but you shouldn't\
    \ use `each_with_index`; that only works on Enumerable objects, not arrays.\n\
    <|/ c |>\n<| a |>\nYou can use a single loop with a single variable:\n<code>",
  "  odd = 1\n  even = 1", "  digits = num.to_s.reverse.split(\"\")\n  odd = []\n\
    \  even = []\n  odd.push digits[0..2]\n  even.push digits[2..-1]\n  odd.compact!\n\
    \  even.compact!\n  return [odd.count, even.count]\nend", "  return [num.to_s.split(//).length\
    \ - 1, num.to_s.split(//).length]\nend", "  result = [0, 0]\n  num = num.to_s.reverse",
  "  digits = num.to_s.split('')\n  odd_count = 0\n  even_count = 0", "  num_digits\
    \ = num.to_s.length\n  even = []\n  odd = []", "    even = []\n    odd = []\n\
    \    while (num > 0)\n        num -= 10\n        even << num\n        odd << num\
    \ % 10\n    even_count = even.count { |v| v != 0 }\n    odd_count = odd.count\
    \ { |v| v != 0 }\n    even_odd_count = [even_count, odd_count]\n    return even_odd_count\n\
    end", "  arr = num.to_s.split(//).map(&:to_i)\n  arr.each_with_index do |el, i|\n\
    \    if el % 2 == 0 then arr[i] = 1 end\n  end\nend\n</code>\n<|/ a tags=algorithm,ruby,ruby-on-rails,ruby-on-rails-4,ruby-on-rails-3\
    \ |>\n<| c |>\nI like your solution. Thank you!\n<|/ c |>\n<| a dscore=1 |>\n\
    <code>", "  odd = num.to_s.split(//).select { |x| x.to_i != x }\n  even = num.to_s.split(//).select\
    \ { |x| x.to_i == x }\n  [even, odd]\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n\
    `even` and `odd` are arrays, not strings. `even_odd_count(-12).first == -1` and\
    \ `even_odd_count(123).first == 1`.\n<|/ c |>\n<| c |>\nYou're right, of course.\
    \ I was just copying his `even_odd_count` implementation. :-)\n<|/ c |>\n<| c\
    \ |>\nNice answer with code samples. Nice!\n<|/ c |>\n<| a tags=ruby dscore=2\
    \ |>\nUsing a conditional statement (ternary) you can implement this fairly easily.\
    \ \n<code>", "    odd_count = 0\n    even_count = 0", "    i = 0\n    even = []\n\
    \    odd = []\n    while i < num\n        if num % 2 == 0\n            even.push(num)\n\
    \        else\n            odd.push(num)\n        i += 1\n    return even, odd\n\
    end", "  a = num.to_s.split(\"\").each_slice(2).to_a\n  return a.count([0,1]).inject([0,1])\
    \ {|t,n| t+n }\nend", "  evens, odds = [], []\n  (1..num.to_i).each do |i|\n \
    \   evens << i if num % i == 0\n    odds << i if num % i != 0\n  end\n  [evens,\
    \ odds]\nend\n</code>\n<|/ a |>\n<| c |>\nThe code in this answer is very difficult\
    \ to read. How about refactoring to make it a little more readable?\n<|/ c |>\n\
    <| c |>\nCan you explain what this line of code means? (1..num.to_i).each do |i|\
    \ The documentation says that \"Range.each is defined as follows:", "  odd = num.to_s.reverse.each_char.map\
    \ { |c| c == '1' ? 1 : 0 }\n  even = num.to_s.reverse.each_char.map { |c| c ==\
    \ '0' ? 1 : 0 }\n  odd.push( even.shift )\n  odd.push( even.shift )\n  odd.push(\
    \ even.shift )\n  odd.push( even.shift )\nend\n</code>\n<|/ a |>\n<| a tags=ruby,algorithm\
    \ |>\nI wrote this in Python. Hope it helps\n<code>", "\tnum = num.to_s\n\tif\
    \ num =~ /^\\-?[0-9]+$/\n\t\tnum.split(//)\n\t\tnum.each_with_index do |digit,\
    \ i|\n\t\t\tif i % 2 == 0\n\t\t\t\tdigit\n\t\t\telse\n\t\t\t\tdigit + 1\n\t\t\t\
    end\n\t\tend\n\telse\n\t\t[]\n\tend\nend", "\tdigit = num.to_s.split(\"\").map\
    \ {|x| x.to_i}\n\todd = digit.select {|x| x % 2 == 1}\n\teven = digit.select {|x|\
    \ x % 2 == 0}\n\teven.count.even? + odd.count.odd?\nend", "  num.to_s.chars.map\
    \ { |i| i.to_i%2 ? 1 : 0 }.uniq\nend", "  num.even?.map{|x| x*2}.sum.odd?\nend",
  "  even = (num / 10).floor\n  odd = (num % 10).floor", "  x = num.to_i\n  odd_count\
    \ = 0\n  even_count = 0\n  for i in x \n    \n  end\n  return even_count, odd_count\n\
    end\n</code>\n<|/ q tags=ruby,arrays,function |>\n<| c |>\nThis might help: https://stackoverflow.com/questions/15709095/ruby-counting-numbers-of-occurrences-of-each-digit\n\
    <|/ c |>\n<| c |>\nThanks for the link, I will look into it.\n<|/ c |>\n<| c |>\n\
    Thank you for the link, this is more of what I am looking for. I am having trouble\
    \ with the code though. I am still getting a wrong number of arguments error\n\
    <|/ c |>\n<| a dscore=2 |>\nThe error was raised because you were passing an array\
    \ to the function, which doesn't have an instance method length.  You need to\
    \ pass a single numeric value instead.  In Ruby, we generally use Enumerator#each_char\
    \ to perform this kind of tasks:\n<code>", "  return [1,1] if num.odd? else [1,2]\n\
    end", "  even = even = 1\n  odd = odd = 1\n  (num < 1) ? return : num %= 10\n\
    \  (num == 0) ? (even, odd) : return (odd = 1 + odd, even = 1 + even, even_odd_count(num\
    \ / 10))\nend", "  even_count = 0\n  odd_count = 0\n  while num > 0\n    if num\
    \ % 2 == 0\n      even_count = even_count + 1\n    num = num / 2\n  end\n  while\
    \ num > 0\n    if num % 2 != 0\n      odd_count = odd_count + 1\n    num = num\
    \ / 2\n  end\n  return [even_count, odd_count]\nend\n</code>\n<|/ a |>\n<| a |>\n\
    <code>", "  evens, odds = num.to_s.split('').reverse.split('').map.with_index\
    \ {|char, index| char == \"0\" ? [0,1] : [1,0]}\n  evens.length + odds.length\n\
    end", "  return [num.even? num.count, num.odd? num.count]\nend", "    even = []\n\
    \    odd = []\n    while num != 0\n        if num % 2 == 0\n            even.push(num)\n\
    \        else \n            odd.push(num)\n        num = num / 2\n    end\n  \
    \  return even, odd\nend", "  return num.to_s.chars.map(&:to_i).each_cons(2).map\
    \ { |n, o| [n, o] }\nend\n</code>\n<|/ a |>\n<| c |>\nThank you. Your answer is\
    \ correct but I chose a simpler answer for my question.\n<|/ c |>\n<| a dscore=3\
    \ |>\n<code>", "  num = [num.to_s]\n  num.map! { |x| x.to_i }\n  odd, even = 0,\
    \ 0\n  while num.any?\n    digit = num.rotate(num.index(Math.min.with_index {\
    \ |e,i| e })).first\n    odd += 1 if digit.to_i % 2 == 0\n    even += 1 if digit.to_i\
    \ & 1 == 0\n    num << digit\n  end\n  [ odd, even ]\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\nA recursive solution using regexp:\n<code>", "  res =\
    \ []\n  i = 2\n  while i <= num\n    even = i % 2 == 0\n    odd = i % 2 != 0\n\
    \    i += (even ? 1 : -1)\n    res<<(even ? 1 : -1)\n  end\n  res\nend", "  even\
    \ = [1, 1]\n  odd = [1, 0]\n  while num > 0\n    (even, odd) = (odd, [odd[0]]\
    \ + [odd[1]] + [even[0]] + num.to_s.split('').select { |x| x =~ /[13579]/ })\n\
    \    num = num / 10\n  end\n  even.reverse!\n  odd\nend", "  num.to_s.reverse.split(\"\
    \").each_cons(2).select { |e| e[0].to_i.even? && e[0].to_i.odd? }\nend", "  arr\
    \ = []\n  \n  while num != 0\n    arr << num % 10\n    num /= 10\n    \n  if arr.uniq.count\
    \ == 0\n    arr << 1\n    arr.uniq\n  else\n    arr\nend\n</code>\n<|/ a tags=algorithm,ruby\
    \ |>\n<| c |>\nI like this one. :)\n<|/ c |>\n<| a tags=algorithm,ruby |>\nHere's\
    \ another one:\n<code>", "  even, odd = 1, 1\n  if num < 0\n    num = -num\n \
    \   even, odd = 2, 0\n  end\n  num, i = num, 0\n  while num > 0\n    num, i =\
    \ num / 10, i + 2\n  end\n  even, odd = even * 10 + odd, even * 10 - odd if even\
    \ * 10 - odd\n  [even, odd]\nend\n</code>\nThis should be O(logn)\n<|/ a tags=algorithm,ruby,arrays\
    \ |>\n<| c |>\nPlease note that `count` is not an accurate way to determine number\
    \ of digits in an integer.\n<|/ c |>\n<| c |>\nI don't see the reason for that\
    \ since it only counts the number after the decimal point.\n<|/ c |>\n<| c |>\n\
    How could you possibly know how many digits you would need to print if you were\
    \ to use `#to_s`? If you could do that, would you be able to print an arbitrarily\
    \ long integer? If so, you could just use [`Integer#digits`](http://www.ruby-doc.org/core-2.1.1/Integer.html#method-i-digits)\
    \ to determine how many digits. However, `#to_s` only works in base `10`.\n<|/\
    \ c |>\n<| c |>\nI did not know about `#to_s`. And how would you determine how\
    \ long the number would be if printed out without `.to_s`?\n<|/ c |>\n<| c |>\n\
    If you had `123.456.789.10111213141516171819202122232425262728293031323334353638394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889900101102...`,\
    \ how would you count how many digits you need?\n<|/ c |>\n<| a tags=algorithm,ruby,arrays\
    \ |>\nMy initial thought was: use the % operator to get the modulus of n by 10\
    \ and then simply count the ones (and zeroes) in the result to obtain the number\
    \ of digits:\n<code>", "    even, odd = 0, 1\n    while num > 0\n        if num\
    \ % 2 == 0\n            even += 1\n        else\n            odd += 1\n      \
    \  num /= 10\n    return [even, odd]\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    I guess this would be the most efficient solution if you really just want to find\
    \ the number of even and odd digits in an integer.\n<|/ c |>\n<| c |>\nThe while\
    \ loop is unnecessary here: num = num.divmod(10); even = odd = 1.\n<|/ c |>\n\
    <| c |>\nThis solution is very inefficient as you divide by 10 twice, once in\
    \ while and again in even, odd += 1. To avoid this, you can use `num =/ 10; odd\
    \ = even = 1` instead. ", "  if num < 0\n    return []\n  num_str = '0' * (num.bit_length()-1)\n\
    \  num_str.chars.map! { |char| char.ord }\n  num_str.chars.each { |char| char.odd?\
    \ ? 0 : 1 }\nend", "  even = num.even?\n  odd = num.odd?\n  \n  result = (0...num).map\
    \ do |i|\n    even? ? i : i + 10\n  end\n  \n  return result if even\n  result\
    \ << 1 if odd\n  result\nend", "  num = num.to_s\n  even = 0\n  odd = 0", "  if\
    \ num < 0 then\n    puts \"The given number cannot be negative\"\n    return\n\
    \  end\n  num.to_s.reverse.chars.map.with_index{|char, index| \n    if char ==\
    \ \"0\" then\n      if index % 2 == 0 then\n        return [1, 0]\n      else\n\
    \        return [0, 1]\n      end\n    end\n  }.flatten.compact\nend", "\todd_count\
    \ = 0\n\teven_count = 0", "  even_count = 0\n  odd_count = 0\n  while num != 0\n\
    \    odd_count += 1\n    num = num / 10\n    \n    even_count += 1\n    num =\
    \ num % 10\n  end\n  [even_count, odd_count]\nend\n</cell>\n<cell>", "  return\
    \ [num.even? 1 : num.odd? 1 : 0, num.odd? 2 : 1]\nend", "  evens = []\n  odds\
    \ = []\n  (num.to_s.reverse().split(\"\")).each do |i|\n    if i.odd? then odds\
    \ << i else evens << i end\n  end\n  return [evens, odds]\nend", "  num = abs(num)\n\
    \  return [num / 2, num % 2].flatten.select {|x| x % 2 != 0}\nend", "  even_count\
    \  = 0\n  odd_count   = 0\n  digit       = num.to_s.split('').map(&:to_i)\n  while\
    \ digit.length > 0\n    digit.pop\n    digit.each do |i|\n      if i.odd?\n  \
    \      odd_count += 1\n      else\n        even_count += 1\n      end\n    end\n\
    \  end\n  return [even_count, odd_count]\nend", "  even = 0\n  odd = 1\n  num\
    \ = num.to_i\n  while num > 0\n    num = num / 10\n    even = even + 1 if num\
    \ % 2 == 0\n    odd = odd + 1 if num % 2 != 0\n  end\n  even, odd\nend", "  a\
    \ = num.to_s.chars.to_a\n  odd_count = (a / 2).select {|n| n % 2 == 1}.length\n\
    \  even_count = (a / 2).select {|n| n % 2 != 1}.length\n  return odd_count, even_count\n\
    end", "  even = []\n  odd = []\n  while num > 0\n    case num % 10\n      when\
    \ 0\n        even << num\n      when 1\n        odd << num\n    end\n    num =\
    \ num / 10\n  end\n  return [even, odd]\nend", "\tdigits = num.to_s.split('')\n\
    \todd = digits[2..-1]\n\teven = digits[0..-2]\n\todd.zip(even)\n\t.flatten\n\t\
    .compact\nend", "  odd_count = 0\n  even_count = 0\n  \n  while num > 0\n    if\
    \ (num % 2 == 0)\n      even_count += 1\n    else\n      odd_count += 1\n    num\
    \ = num / 2\n  \n  return [even_count, odd_count]\nend\n  ", "  num = abs(num)\n\
    \  even = 0\n  odd = 0\n  while (num != 0)\n    if num % 2 == 0\n      even +=\
    \ 1\n    else\n      odd += 1\n    num /= 2\n  [even, odd]\nend", "  arr = []\n\
    \  i = num\n  while i > 0\n    arr << i & 1\n    i = i >> 1\n  end\n  arr << i\n\
    \  arr.uniq\nend", "  ans = []\n  while num != 0\n    digit = num % 10\n    num\
    \ = num / 10\n    ans << [digit, digit % 2 == 1]\n  end\n  ans\nend", "  even\
    \ = []\n  odd = []\n  (num.to_s.length - 1).times do\n    if num % 2 == 0\n  \
    \    even << num\n      num -= 2\n    else\n      odd << num\n      num += 2\n\
    \    end\n  end\n  [even, odd]\nend\n</code>\nThe above solution is quite ugly\
    \ and repetitive, which is why I came up with the following (but I'm sure it could\
    \ be more concise):\n<code>", "  num_string = ''\n  while num > 0\n    num_string\
    \ << num % 10\n    num = num / 10\n  end\n  return num_string.chars.select.with_index{|d,\
    \ i| d % 2 == 0 && i > 0}\nend", "\tdigits = []\n\tdigit = (num / 10).to_i\n\t\
    while digit > 0\n\t\tif digit%2 == 0\n\t\t\tdigits.push(digit)\n\t\telse\n\t\t\
    \tdigits.push(digit)\n\t\tend\n\t\tdigit = (digit/10).to_i\n\tend\n\tdigits.push(digit)\n\
    \t\n\todd_count = 0\n\teven_count = 0\n\tfor i in 0...digits.length-1\n\t\tif\
    \ digits[i] != digits[i+1]\n\t\t\todd_count += 1\n\t\telse\n\t\t\teven_count +=\
    \ 1\n\t\tend\n\tend\n\tdigits.push(odd_count)\n\tdigits.push(even_count)\n\treturn\
    \ digits\nend", "  count = 0\n  while num > 0\n    count += 1\n    num /= 10\n\
    \  end", "  odd_count = 0\n  even_count = 0\n  for i in 1..num\n    if num % i\
    \ == 0\n      even_count = even_count + 1\n    else \n      odd_count = odd_count\
    \ + 1\n    end\n  end\n  return [even_count, odd_count]\nend\n</cell>\n<code language=julia-1.6>\n\
    function even_odd_count(num)\n  odd_count = 0\n  even_count = 0\n  for i in 1..num\n\
    \    if num % i == 0\n      even_count = even_count + 1\n    else \n      odd_count\
    \ = odd_count + 1\n    end\n  end\n  return [even_count, odd_count]\nend\n</cell>\n\
    <code language=julia-1.6>", "  odd_count = 0\n  even_count = 0", "  even = num.divmod(2).first\n\
    \  odd = num - even\n  [even, odd]\nend", "  count = 0\n  if num < 0 then\n  \
    \  count = count\n  else\n    num = num.to_i\n    while num > 0\n      num = num\
    \ / 10\n      count += 1\n    end\n    num = num.to_i\n    while num > 0\n   \
    \   num = num / 10\n      count += 1\n    end\n  end\n  if num > 0 then\n    count\
    \ -= 1\n  end\n  return[count, count]\nend", "  evens = []\n  odds = []\n  \n\
    \  while( num > 0 ) do\n    if num % 2 == 0 then evens << num; end\n    else if\
    \ num % 2 != 0 then odds << num; end\n    num = num / 2\n  end\n  \n  return [\
    \ evens, odds ]\nend", "  return [1, num%2 == 0 ? 1 : 2].max\nend", "  even =\
    \ []\n  odd = []\n  while num > 0\n    if num % 2 == 0\n      even << num\n  \
    \  else\n      odd << num\n    end\n    num /= 10\n  end\n  [even, odd]\nend",
  "  n = num.to_s.length\n  even_odd = 0\n  i = 0\n  while i < n\n    if num.chars[i].to_i(2)\n\
    \      even_odd += 1\n    end\n    i += 1\n  end\n  return even_odd\nend", " \
    \   even = num / 2 if num % 2 == 0 else 0\n    odd = num / 2 if num % 2 != 0 else\
    \ 0\n    return [even, odd]\nend", "  even = 0\n  odd = 0\n  for i in (num)..(num+1)\n\
    \    if i % 2 == 0\n      even += 1 # even number\n    else \n      odd += 1 #\
    \ odd number\n  end\n  return [even, odd]\nend", "  if num == 0 then return [num,\
    \ 1, 1]\n  if num <= -1 then return [-1, num, 1]\n  odd = num % 2 # Even \n  even\
    \ = num / 2 # Odd \n  count = even_odd_count(even)\n  if odd then count[1] = count[1]\
    \ + 1\n  else count[2] = count[2] + 1\n  return count\nend", "  arr = num.to_s.reverse.to_s.chars.reverse\n\
    \  even = []\n  odd = []\n  even.push arr[0]\n  odd.push arr[0]\n  while arr.length\
    \ > 0\n    even.push arr[0]\n    arr.pop\n    odd.push arr[0]\n    arr.pop\n \
    \ end\n  return [even, odd]\nend", "  if num < 0\n    return []\n  even = []\n\
    \  odd = []\n  i = 0\n  while (num > 0) and (num % 2 == 0)\n    even = even +\
    \ [num]\n    num = num / 2\n  end", "  count = []\n  i = 0\n  while i < num\n\
    \    if num % 2 == 0\n      count.push(2)\n    elsif num % 2 != 0\n      count.push(1)\n\
    \    end\n    i += 1\n  end\n  count\nend", "  num = num.to_s\n  num.count(\"\
    0\") == num.count(\"1\") + num.count(\"2\") + num.count(\"3\") + num.count(\"\
    4\") + num.count(\"5\") + num.count(\"6\") + num.count(\"7\") + num.count(\"8\"\
    ) + num.count(\"9\") ? \"odd\" : \"even\"\nend", "  even_digits = (0...num).select\
    \ { |n| n % 2 == 0 }\n  odd_digits = (0...num).select { |n| n % 2 != 0 }\n  [even_digits,\
    \ odd_digits]\nend", "  even = [0, 0 ,0]\n  odd = [1, 0 ,0]", "  # add your code\
    \ here\n  even_count = 0\n  odd_count = 0\n  remainder = 0\n  while (num > 0)\n\
    \    if (num % 2 != 0)\n      odd_count += 1 \n    num = num / 2\n  \n  while\
    \ (num > 0)\n    if (num % 2 != 0)\n      even_count += 1 \n    num = num / 2",
  '    num, num_odd, num_even = 0, 0, 1', "  even, odd = 1, 0\n  loop do\n    next\
    \ if num > 0\n    odd += 1 if num % 2 == 0\n    even += 1 if num % 2 == 1\n  \
    \  break if even == odd\n    num /= 10\n  end\n  [even, odd]\nend", "  if num\
    \ < 0\n    return nil\n  else\n    even_odd = num.to_s.chars.map { |c| c.to_i.even?\
    \ ? 0 : 1 }\n    even_odd.uniq.map { |e| even_odd.count(e) }\n  end\nend", " \
    \ arr = num.to_s.split(//)\n  arr.map!{|x| x.to_i}\n  odd, even = [], []\n  arr.each_index\
    \ do |i|\n    (i % 2 == 0).nil? ? odd << arr[i] : even << arr[i]\n  end\n  return\
    \ odd, even\nend", "  result = [0,0]\n  while num > 0\n    digit = num % 10\n\
    \    if digit % 2 == 1\n      result[0] += 1\n    else\n      result[1] += 1\n\
    \    num = (num-digit)/10\n  end\n  result\nend", "    even = []\n    odd = []\n\
    \    num = Integer(num)\n    num.to_s.each_char.with_index do |x, i|\n       \
    \ if i % 2 == 0 then\n            even << x\n        else\n            odd <<\
    \ x\n        end\n    end\n    \n    even_odd = [even, odd]\n    even_odd.flatten!\n\
    \    even_odd_count.call(even_odd_count.call(num)[0])\nend\n</cell>\n<text>\n\
    The final step is to calculate the number of digits in each of the two arrays,\
    \ and multiply them together. You'll do this by using the product method on arrays.",
  "  return [((num % 2).zero? ? 0 : 1) + (num % 2).zero? ? 1 : 0]\nend", "  if num\
    \ < 0 then\n    return nil\n  elsif num < 10 then\n    return [1], num.to_s\n\
    \  else\n    even, odd = 0, 1\n    while num > 0 do\n      num, digit = num %\
    \ 10, num / 10\n      if digit % 2 then\n        even += 1\n      else\n     \
    \   odd += 1\n      end\n    end\n    [even, odd], num.to_s\n  end\nend", "  result\
    \ = [0]\n  odd_count = 0\n  even_count = 0\n  num = abs(num) # convert number\
    \ to abs value\n  while num > 0\n    digit = num % 10 # get the last digit\n \
    \   num = num / 10 # remove the digit from the number\n    if digit % 2 == 0 #\
    \ if the digit is even\n      even_count += 1\n      result << 1\n    else\n \
    \     odd_count += 1\n      result << 1\n    end\n  end\n  return even_count,\
    \ odd_count\nend", "  \n  sum = 0 \n  sum = (num.to_s.split('').size/2) - 1\n\
    \  return sum\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>", "  return [num\
    \ % 2 == 0, num % 2 != 0]\nend\n</code>\n<|/ a dscore=0 tags=ruby,arrays |>\n\
    <| a tags=ruby,arrays dscore=0 |>\n<code>", "  digits = num.to_s.split(//).map{|i|\
    \ i.to_i} \n  odd_count = digits[1..-1].grep(/^1$/).size\n  even_count = digits[0..-2].grep(/^1$/).size\n\
    \  [even_count, odd_count]\nend\n</cell>\n<cell>", "  num = num.to_i\n  even =\
    \ num.to_s.scan(/[02468]/).map{|i| i[0]}\n  odd = num.to_s.scan(/[13579]/ ).map{|i|\
    \ i[0]}\n  even.zip(odd).map{|eod| eod[0] << 1 | (eod[1] >> 1)}\nend\n</code>\n\
    <|/ a |>\n<| a |>\n<code>", "  a = num.to_s.reverse\n  a.each do |x|\n    if x\
    \ % 2 == 0\n      a.remove(x)\n    end\n  end\n  a.each do |x|\n    if x % 2 !=\
    \ 0\n      a.remove(x)\n    end\n  end\n  a.reverse\nend", "  even = []\n  odd\
    \ = []\n  (1..num).each do |num|\n    (0..num).each do |i|\n      even.unshift\
    \ i if (num % i == 0)\n      odd.unshift num - (i * (num % i))\n    end\n  end\n\
    \  [even, odd]\nend\n</code>\n<|/ a |>\n<| c |>\nThis is an extremely interesting\
    \ solution.  Thank you for sharing!\n<|/ c |>\n<| a dscore=0 |>\nHere is a more\
    \ efficient approach which should be O(n) time complexity (O(n) memory complexity):\n\
    <code>", "  result = []\n  while num != 0\n    even = num % 2 == 0\n    odd =\
    \ num % 2 != 0\n    num = num / 2\n    if even && odd\n      result << 1\n   \
    \ else\n      result << 0\n  end\n  result\nend", "  even, odd = 1, 0\n  while\
    \ num > 0\n    even, odd = even + 1, odd if (num % 10 == 0)\n    num = num / 10\n\
    \  end\n  [even, odd]\nend", "  count = []\n  while num > 0\n    if num % 2 ==\
    \ 0\n      num /= 2\n      count.push 2\n    else\n      num /= 2\n      count.push\
    \ 1\n  end\n  count\nend", "  result = []\n  while num != 0\n    if num % 2 ==\
    \ 0\n      num /= 2\n      result << 1\n    else\n      num /= 2\n      result\
    \ << 0\n    end\n  end\n  result\nend", "  even_count = 0\n  odd_count = 0\n \
    \ if num > 0\n    temp = num\n    until temp > 0\n      even_count = even_count\
    \ + 1\n      temp = temp / 10\n    until temp <= 0\n      odd_count = odd_count\
    \ + 1\n      temp = temp / 10\n  end\n  [even_count, odd_count]\nend", "  if num\
    \ < 0\n    []\n  else\n    [2 * (num % 2 != 0), num % 2]\nend", "  even = 0\n\
    \  odd = 0\n  while num > 0\n    even = even + 1\n    num = num / 10\n  end",
  "    num = Integer(num)\n    even = num / 10\n    odd = num % 10\n    return [even,\
    \ odd]\nend", "  return [num.even? 0, num.odd? 1 : 1]\nend", "  num_str = num.to_s\n\
    \  even_count = 0\n  odd_count = 0\n  length = num_str.length\n  digit = num_str.chars[0]\n\
    \  i = 0\n  while i < length\n    if digit.to_i == 0 && digit.to_i == -1\n   \
    \   even_count = 2\n      odd_count = 0\n    elsif digit.to_i%2 == 0\n      even_count\
    \ += 1\n    else\n      odd_count += 1\n    end\n    digit = num_str.chars[i +\
    \ 1]\n    i += 2\n  end\n  [even_count, odd_count]\nend", "\tdigits_odd = Array.new\n\
    \tdigits_even = Array.new", "  return [1, (num % 2).zero?] + num.digits.map {\
    \ |digit| (digit % 2).zero? ? 2 : 1 }\nend", "  even = [1, 0]\n  odd = [0, 1]\n\
    \  count = 1\n  while num != 0\n    digit = num % 10\n    num = num / 10\n   \
    \ digit = digit % 2 ? digit * 2 : digit * 2\n    count += digit == 0 ? 0 : digit\
    \ * 2\n  end\n  return [even, odd].transpose.last\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=ruby dscore=0 |>\n<code>", "  num.to_s.reverse.split(\"\").each_with_index.map\
    \ do |num, index|\n    if index%2 == 0\n      num\n    else\n      num.next\n\
    \    end\n  end\nend", "  digit_sums = (0...num).map { |i| num / i }\n  evens\
    \ = digit_sums.select { |d| d == 0 }\n  odds = digit_sums - evens\n  [evens, odds]\n\
    end\n</code>\nWe start off with an array of digits, in reverse. Our first element\
    \ of evens is going to be the number's last digit. Our first element of odds is\
    \ going to be the sum of all the other digits. We then iterate through the array:",
  "\tnum += 0\n\t\n\tresult = []\n\t\n\twhile (num > 0)\n\t\tif (num % 2 == 0)\n\t\
    \t\tresult.push(2)\n\t\telse\n\t\t\tresult.push(1)\n\t\t\n\t\tnum -= num % 2\n\
    \t\t\n\treturn result\nend", "  a = num.to_s.split('')\n  even = []\n  odd = []\n\
    \  a.each_index do |i|\n    if a[i] == '2'\n      even << i\n    else\n      odd\
    \ << i\n    end\n  end\n  [even, odd]\nend\n</code>\n<|/ a dscore=0 tags=arrays,ruby,algorithm,ruby-on-rails\
    \ |>\n<| c |>\n`even_odd_count` is extremely inefficient -- you should only use\
    \ `each` if you need to do something with the elements in the enumerator, and\
    \ in this case, you do not.\n<|/ c |>\n<| c |>\nThat is very true and I completely\
    \ agree. However, the OP wanted something in Ruby, so I offered it, and I wasn't\
    \ sure why you mentioned efficiency.\n<|/ c |>\n<| c |>\nI appreciate your effort\
    \ but this does not address the problem as stated.\n<|/ c |>\n<| a |>\nHere is\
    \ an even faster version:\n<code>", "  sum = 0\n  even = 0\n  odd = 0\n  for i\
    \ in 0...num.length\n    if num[i] % 2 == 0\n      even = even + 1\n    else\n\
    \      odd = odd + 1 \n    sum = sum + 1\n  end\n  [even, odd]\nend", "  return\
    \ [num/2,num/2].product?\nend", "  even_count = 0\n  odd_count = 0", "  odd =\
    \ [1, 1]\n  even = [1, 2]\n  if num >= 0\n    if num >= 10\n      odd << num.to_s.count(\"\
    1\") + 1\n      even << num.to_s.count(\"2\") + 1\n    else\n      odd << num.to_s.count(\"\
    0\") \n      even << num.to_s.count(\"0\") \n    end\n  end\n  [odd, even]\nend\n\
    </code>\n<|/ a |>\n<| a |>\nHere's a non-recursive solution in Ruby that converts\
    \ the number to base 10 and counts the number of \"1\" and \"0\" digits.\n<code>",
  "  num == 0 ? nil : (even_odd_count(num / 2) + [num % 2 == 0 ? 1 : 2]).reverse\n\
    end", "  if num < 0\n    puts \"invalid input\"\n    return\n  end", "  if num\
    \ < 0\n    return []\n  even = []\n  odd = []\n  while num > 0\n    even.push(num\
    \ % 10)\n    num = num / 10\n  end\n  while num > 0\n    odd.push(num % 10)\n\
    \    num = num / 10\n  end\n  return [even, odd]\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\n`num.chars.each_with_object([]).with_index.group_by { |c,i| i %\
    \ 2 ? c : '0' }` is more concise than `even_odd_count(num)`\n<|/ c |>\n<| a |>\n\
    Using only #digits and #divmod (aka divmod) method you can write this code:\n\
    <code>", "  # We will store the number of even and odd numbers in a single list\
    \ \n  # since they will always be of the same length. \n  # We will use this list\
    \ to later form the list of odd numbers \n  even_odd_numbers = []\n  odd_numbers\
    \ = []", "    odd, even = 0, 0\n    while(num > 0)\n        num % 10 == 0 ? even\
    \ += 1 : odd += 1\n    end\n    [even, odd]\nend", "  even_count = 0\n  odd_count\
    \ = 0\n  \n  while num != 0\n    if num % 2 == 0\n      even_count = even_count\
    \ + 1\n    else\n      odd_count = odd_count + 1\n      num = num / 2\n    end\n\
    \  end\n  \n  return [even_count, odd_count]\nend", "    arr = []\n    (even,\
    \ odd) = (1, 0)\n    digit = num.to_s.reverse\n    while digit.length >= 0\n \
    \       if digit.include?(\"0\")\n            even = even * 10 + digit.index(\"\
    0\") - 1 \n        else\n            odd = odd*10 + digit.index(\"1\") - 1 \n\
    \        end\n        digit = digit.next\n    end\n    arr.push([even, odd])\n\
    \    return arr\nend", "  return (num.to_s.reverse.split('').reverse.split('').select{|i|\
    \ (i.to_i%2) == 0 }.size)\nend", "  even = odd =  num.abs.floor.step(2).to_a\n\
    \  num.zero? and [even, odd] = [odd, even]\n  even.zip(odd).map(&:sum)\nend\n\
    </code>\n<code>\n> even_odd_count(-12)\n[1, 1]\n> even_odd_count(123)\n[1, 2]\n\
    > even_odd_count(0)\n[0, 0]\n</code>\n<|/ a tags=algorithm,ruby,math |>\n<| a\
    \ tags=algorithm,ruby,math |>\n<code>", "  num.zero? ? [] : [num.to_s.reverse.split('').map(&:to_i)].each_cons(2)\
    \ do |arr|\n    arr[0] % 2 == 0 ? arr[1] += 1 : arr[1] += 0\n  end\nend", "  even_count,\
    \ odd_count = 1, 0\n  while num > 0\n    odd_count = odd_count + 1\n    num =\
    \ num / 10\n  end\n  [even_count, odd_count]\nend", "  ans = []\n  digit = num.to_s.chars\n\
    \  digit.each do |i|\n    if i % 2 == 0\n      ans << i\n    end\n  end\n  ans.concat(digit.count{|i|\
    \ i % 2 == 1})\n  ans\nend", "  a = []\n  remainder = 0\n  while num > 0\n   \
    \ remainder = num % 10\n    a.unshift(remainder)\n    num = num / 10\n  end\n\
    \  a = a.delete_at(a.count { |x| x < 2 })\n  a = a.delete_at(a.count { |x| x >\
    \ 8 })\n  a\nend", "  odd = num\n  even = num\n  odd = odd % 2 == 1 ? odd : odd+1\n\
    \  even = even % 2 == 0 ? even : even+1\n  return [even, odd]\nend", "  even =\
    \ []\n  odd = []\n  if num < 0\n    return even, odd\n  while num > 0\n    even.push(num\
    \ % 2)\n    num = num / 2\n  end\n  even.push(num)\n  while odd.length < even.length\n\
    \    odd.push(even.pop)\n  end\n  return even, odd\nend", "  result = []\n  digits\
    \ = num.to_s.split('')\n  digits.each do |digit|\n    if digit.odd?\n      result.push(1)\n\
    \    elsif digit.even?\n      result.push(2)\n    end\n  end\n  return result\n\
    end\n</cell>\n<cell>", "  num, even = 0, 1\n  \n  loop do\n    even = num % 2\
    \ == 0 ? even + 1 : even\n    num = num / 2\n    break unless num\n  end\n  \n\
    \  even\nend", "  even_count = num.to_s.split(\"\").select { |i| i.to_i.even?\
    \ }.count\n  odd_count = num.to_s.split(\"\").select { |i| i.to_i.odd? }.count\n\
    \  [even_count, odd_count]\nend", "    factors = []\n    count = 1 # 0~7\n   \
    \ temp = num\n    while temp > 0\n        factors << temp % 10\n        temp =\
    \ temp / 10\n    end\n    factors.uniq.each do |factor|\n        count += 1 if\
    \ num % factor == 0\n        count -= 1 if num % factor == 7\n    end\n    count\n\
    end\n</cell>\n<text>\nExercise 2: More Ruby solutions\nCreate a function is_prime\
    \ that takes two arguments. The first argument is the number to check if it is\
    \ a prime number. Second argument is the limit of iteration (default value is\
    \ 10). If the given number is prime then returns true, else returns false.", " \
    \ \n  return [num.to_s.length,num.to_s.length - num.to_s.reverse.length] if num\
    \ >= 0 else [num.to_s.length,num.to_s.length]\nend", "  odd = 1\n  even = 0",
  "  n = num.to_s.strip.reverse.to_i\n  even, odd = 0, 0\n  loop do\n    even += n\
    \ / 10 \n    odd += n % 10\n    n /= 10\n    break unless n > 0\n  end\n  [even,\
    \ odd]\nend", "  num = [num.to_s]\n  odd, even = [], []\n  odd = num.map { |x|\
    \ x % 2 }\n  even = num.map { |x| x % 2 != 0 }\n  even.concat(odd).uniq\nend",
  "  num.to_s.split(\"\").map { |digit| digit.to_i }.\n    reduce(:+).\n    even?.length\
    \ + (num.to_s.split(\"\").map { |digit| digit.to_i }.\n      reduce(:+).\n   \
    \   odd?.length)\nend", "  if num < 0\n    return [0, 0]\n  digits = num.to_s.reverse.to_i\n\
    \  evens = []\n  odds = []\n  (num - 1).downto(0) {|i|\n    if digits[i] % 2 ==\
    \ 0\n      evens << i\n    else\n      odds << i\n    end\n  }\n  [evens, odds]\n\
    end\n</cell>\n<text>\nIn Ruby, the reverse method reverses the given string:",
  "  count = [0,0]\n  while num != 0\n    temp = num % 10\n    count[temp % 2 == 0\
    \ ? 0 : 1] += 1\n    num = num / 10\n  end\n  count\nend", "  arr = []\n  if num\
    \ < 0\n    puts \"invalid input\"\n    return\n  end\n  while num > 0\n    arr.push(num\
    \ % 10)\n    num = num / 10\n  end\n  arr.delete_if { |x| x == 0 }\n  arr.delete_if\
    \ { |x| x < 0 }\n  arr.each_with_index { |x, i| arr[i] = i + 1 if x % 2 == 0 }\n\
    end", "  num = num.to_s\n  odd = [0 for i in 0..num.length]\n  even = [0 for _\
    \ in 0..num.length]\n  \n  even.each {|value| value += 1 if num[value] =~ /[0-9]/}\n\
    \  odd.each {|value| value += 1 if num[value] !~ /[0-9]/}\n  \n  even.zip(odd).each\
    \ {|(even, odd)| return [even, odd]}\nend\n</cell>\n<cell>", "  \n  num_str =\
    \ num.to_s.split(\"\").reverse.join(\"\")\n  odd_count = 0\n  even_count = 0\n\
    \  \n  while num_str.length > 0\n  \n    odd_count += 1\n    \n    if (num_str.length\
    \ % 2) == 0\n      even_count += 1\n      num_str.pop\n    end\n    \n  end\n\
    \  \n  [even_count, odd_count]\nend", "    even_num = 0\n    odd_num = 0\n   \
    \ \n    while(num > 0)\n        if num % 2 == 0\n            even_num += 1\n \
    \       else\n            odd_num += 1\n        num = num / 10\n    end\n    \n\
    \    return [even_num, odd_num]\nend", "  even_count = num / 2\n  odd_count =\
    \ num - (even_count*2)\n  [even_count, odd_count]\nend\n</code>\nThen, write a\
    \ function even_odd_count_sum(num) that sums up the even and odd numbers in the\
    \ array passed in.\n<code>", "  n = num.to_s\n  return n.chars.map { |x| x.to_i\
    \ }.select { |n| n % 2 == 0 }.map { |n| n % 2 == 1 }\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\nA variation on Vlad's answer, inspired by the comment\
    \ on his answer, but without having to convert to strings:\n<code>", "  digits\
    \ = num.to_s.split(//).reject(&:empty?)\n  even = digits.count{ |x| x % 2 == 0\
    \ }\n  odd = digits.count{ |x| x % 2 != 0 }\n  return [even,odd]\nend", "  if\
    \ num < 1\n    return [0, 0]\n  else\n    return [(num.modulo(2)==0), 2*(num.modulo(2)==1)]\n\
    end", "  even = 1\n  odd  = 0", "  num.to_s.chars.chunk{|e| e == '0' || e == '1'}.count{|e|\
    \ e == 1}/2.0\nend", "  count = 0\n  temp = num\n  while temp > 0\n    temp =\
    \ temp / 10\n    count += 1\n  end\n  even_odd_count = count\nend", "  even_count\
    \ = nil\n  odd_count = nil\n  num.to_s.split('').each do |i|\n    even_count,\
    \ odd_count = i.to_i.divmod(10)\n  end\n  [even_count, odd_count]\nend", "  even_odd_count_array\
    \ = num.divmod(10)\n  even_odd_count_array << 0 if even_odd_count_array[0] % 2\
    \ == 0 # Even digit.\n  even_odd_count_array << 1 if even_odd_count_array[0] %\
    \ 2 == 1 # Odd digit.\n  return even_odd_count_array\nend", "    if num < 0\n\
    \        return 0\n    num.to_s.chars.chunk{ |x| x == 0 }.count{ |x| x == 0 }\n\
    end", "  even = []\n  odd = []\n  while num > 0\n    even.push num % 10\n    num\
    \ /= 10\n  while num != 0\n    odd.push num % 10\n    num /= 10\n  return [even,odd]\n\
    end", "    if num > 0\n        odd = 1\n        even = 0\n        odd_count =\
    \ 0\n        even_count = 0\n        digits = (num.to_s.reverse).to_i(10)\n  \
    \      \n        digits.each do |digit|\n            if digit % 2 == 1\n     \
    \           even += digit\n                even_count += 1\n            else\n\
    \                odd += digit\n                odd_count += 1\n            end\n\
    \        end\n        \n        return even_count, odd_count\n    end\nend", " \
    \ even_count = 0\n  odd_count = 0", "  \n  # return evens count\n  evens = num.to_s.chars.map{|i|\
    \ i.to_i}.select {|i| i % 2 == 0}", "    even = num/10 % 2 == 0\n    odd = num\
    \ % 10 != 0\n    if even\n        [even, odd]\n    else\n        [odd, even]\n\
    \    end\nend", "  num_arr = num.to_s.split(\"\").reverse\n  odd_count = []\n\
    \  even_count = []\n  while num_arr.length > 0\n    if num_arr.length % 2 == 1\n\
    \      num_arr = num_arr[0..num_arr.length/2]\n      even_count\n    else\n  \
    \    num_arr = num_arr[1..num_arr.length/2]\n      odd_count\n    end\n  end\n\
    \  odd_count << num_arr.pop\nend", "  result = [0]*2\n  for i in num.to_s.split(\"\
    \").map(&:to_i)\n    if i % 2 == 0 then\n      result[0]+=1\n    elsif i % 2 ==\
    \ 1 then\n      result[1]+=1\n    end\n  end\n  result\nend", "  if num < 0\n\
    \    []\n  else\n    even = []\n    odd = []\n    until num == 0\n      num, rem\
    \ = divmod(num, 10)\n      even.push(rem)\n      num, rem = divmod(num, 10)\n\
    \      odd.push(rem)\n    end\n    even << num\n    odd << num\n  end\nend", " \
    \ count = num.to_s.reverse.gsub(/(.)(.)/, '\\1,\\2').split(//)\n  count.each do\
    \ |number|\n    if number == '1'\n      return [1, 0]\n    elsif number == '0'\n\
    \      return [0, 1]\n    end\n  end\nend", "  even_odd_count = 0\n  digit = num.to_s.chars.map(&:to_i)\n\
    \  digit.each do |n|\n    if n % 2 == 0\n      even_odd_count += 1\n    end\n\
    \  end\n  return [even_odd_count, (digit.size-even_odd_count)].min\nend", "  even_odd_count\
    \ = 0\n  num_digits = num.to_s.length\n  while num > 0\n    even_odd_count +=\
    \ 1 if num % 2 == 0 \n    num = num / 2\n  end\n  even_odd_count += 1 if even_odd_count\
    \ > num_digits - 1\n  even_odd_count.to_a\nend", "  even_odd = Array.new\n  for\
    \ i in 0...num\n    even = (num % 2 == 0)\n    odd = (num &~ (num >> (Integer.bit_length\
    \ - i)))\n    even_odd << even << odd\n  end\n  even_odd.reverse\nend", "  num_string\
    \ = num_to_string_s(num)\n  even = num_string.scan(/(0*)(\\d)/).last.last.map(&:to_i)\n\
    \  odd = num_string.scan(/(\\d)(0*)/).last.last.map(&:to_i)\n  [even, odd]\nend",
  "    odd = 1\n    even = 1\n    count = num.to_s.chars.map { |e| e == '0' ? even\
    \ : odd }\n    count.each do |i|\n      odd += 1 if i == 0\n      even += 1 if\
    \ i != 0\n    end\n    [ even, odd ]\nend\n</cell>\n<text>\nThe map function works\
    \ pretty much the same way as each does. map returns an array with the return\
    \ values of every call. map also takes a block. For example:", "  even = odd =\
    \ 1\n  num.to_s.reverse.split(\"\").each do |e|\n    if e == \"0\"\n      even\
    \ += 1\n    elsif e == \"1\"\n      odd += 1\n    end\n  end\n  return [even,\
    \ odd]\nend", "  num, even = 0, 0\n  while num > 0\n    even = even + (num % 2\
    \ == 0)\n    num = num / 2\n  end\n  [even, num]\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
