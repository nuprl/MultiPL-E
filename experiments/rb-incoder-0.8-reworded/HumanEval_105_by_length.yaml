name: HumanEval_105_by_length
language: rb
prompt: "# Given an array of integers, sort the integers that are between 1 and 9\
  \ inclusive,\n# reverse the resulting array, and then replace each digit by its\
  \ corresponding name from\n# \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"\
  Six\", \"Seven\", \"Eight\", \"Nine\".\n# For example:\n# >>> by_length.call([2,\
  \ 1, 1, 4, 5, 8, 2, 3])\n# [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
  Two\", \"One\", \"One\"]\n# If the array is empty, return an empty array:\n# >>>\
  \ by_length.call([])\n# []\n# If the array has any strange number ignore it:\n#\
  \ >>> by_length.call([1, -1, 55])\n# [\"One\"]\ndef by_length(arr)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_by_length\n\
  \    candidate = method(:by_length)\n    assert_equal([\"Eight\", \"Five\", \"Four\"\
  , \"Three\", \"Two\", \"Two\", \"One\", \"One\"], candidate.call([2, 1, 1, 4, 5,\
  \ 8, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([\"One\"\
  ], candidate.call([1, -1, 55]))\n    assert_equal([\"Three\", \"Two\", \"One\"],\
  \ candidate.call([1, -1, 3, 2]))\n    assert_equal([\"Nine\", \"Eight\", \"Four\"\
  ], candidate.call([9, 4, 8]))\n  end\nend\n"
completions: ["  return arr.inject([]) do |res, (v, i)|\n    name =\n      case v\n\
    \      when 1..9\n        \"One\"\n      when 10..19\n        \"Two\"\n      when\
    \ 20..29\n        \"Three\"\n      when 30..39\n        \"Four\"\n      when 40..49\n\
    \        \"Five\"\n      when 50..59\n        \"Six\"\n      when 60..69\n   \
    \     \"Seven\"\n      when 70..79\n        \"Eight\"\n      when 80..89\n   \
    \     \"Nine\"\n      else\n        \"\"\n      end\n    res << name unless name.empty?\n\
    \    res\n  end\nend", "  arr.map! {|x| x if x > 0 && x <= 9 }\n  arr.sort { |a,b|\
    \ b - a }.reverse.map { |n| \"#{n}\".downcase }\nend\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nI used this solution and it works perfectly for my needs. Thank\
    \ you\n<|/ c |>\n<| c |>\nThis solution was perfect for me - much more compact\
    \ and simple than other solutions I came across.\n<|/ c |>\n<| a dscore=3 |>\n\
    Another way to do this would be to iterate over each character in the string.\
    \ \n<code>", "    arr.sort_by!{|x| [x.first, x.last].max}\n    arr.reverse!\n\
    \    arr.map!{|x| x.first == 1 ? One.name : x.last == 9 ? Nine.name :\n      x.last\
    \ == 8 ? Seven.name : x.last == 7 ? Six.name : x.last == 6 ? Five.name :\n   \
    \   x.last == 5 ? Four.name : x.last == 4 ? Three.name : x.last == 3 ? Two.name\
    \ :\n      One.name}\n    arr\n  end\n</code>\n<|/ a tags=ruby,algorithm |>\n\
    <| c |>\nI like the use of `.map!` here - no need for mutation.\n<|/ c |>\n<|\
    \ a tags=ruby,algorithm |>\nYou could use map and slice:\n<code>\na = [1, 2, 3,\
    \ 4, 5, 6, 7, 8, 9]", "  arr.sort!\n  if arr.empty?\n    arr\n  elsif arr.find\
    \ { |x| x > 0 && x <= 9 }\n    by_length.call(arr.reverse)\n  elsif arr.find {\
    \ |x| x > 0 && x < 10 }\n    by_length.call(arr)\n  elsif arr.find { |x| x > 10\
    \ }\n    by_length.call(arr.map { |x| x.to_s.reverse.to_i })\n  else\n    by_length.call(arr.map\
    \ { |x| x.to_s.reverse })\n  end\nend", "  if arr.empty? then return []\n  first\
    \ = arr[0]\n  last_digit = first.to_s.length - 1\n  result = []\n  arr.each do\
    \ |num|\n    ones, tens, hundreds = num.divmod(1000)\n    tens_digit = tens.to_s.length\
    \ - 1\n    tens_name = ((tens == 1) ? \"One\" : \"Ten\")\n    tens_hundreds_name\
    \ = ((tens_digit == 1) ? \"One\" : \"Hundred\")\n    hundreds_name = ((hundreds\
    \ == 1) ? \"One\" : \"Hundred\")\n    result[result.length - tens_digit] << tens_name\n\
    \    result[result.length - tens_digit*2] << tens_hundreds_name\n    result[result.length\
    \ - tens_digit*2+1] << hundreds_name\n  end\n  result.reverse!\n  arr.each do\
    \ |num|\n    ones, tens, hundreds = num.divmod(1000)\n    tens_digit = tens.to_s.length\
    \ - 1\n    tens_name = ((tens == 1) ? \"One\" : \"Ten\")\n    tens_hundreds_name\
    \ = ((tens_digit == 1) ? \"One\" : \"Hundred\")\n    hundreds_name = ((hundreds\
    \ == 1) ? \"One\" : \"Hundred\")\n    result[result.length - tens_digit] << tens_name\n\
    \    result[result.length - tens_digit*2] << tens_hundreds_name\n    result[result.length\
    \ - tens_digit*2+1] << hundreds_name\n  end\n  result\nend", "  arr = arr.sort\
    \ {|x, y| y - x }\n  arr.map {|x| x >= 1 && x <= 9 ? \"#{x}\" : nil }.compact\n\
    end", "  arr.sort.reverse_each.each.map do |n|\n    numbers[n.to_s.to_i] ? numbers[n.to_s.to_i]\
    \ : n\n  end\nend\n</code>\nNow we can write the program as a method of an array\
    \ of integers:\n<code>", "  sorted_arr = arr.sort.reverse\n  sorted_arr.each {\
    \ |item| arr[arr == item] = by_length_array[item] }\n  arr\nend\nby_length_array\
    \ = [\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\",\
    \ \"Eight\", \"Nine\"\n]", "  arr.sort\n  arr.reverse\n  arr.map {|x| case x\n\
    \           when 1 then \"One\"\n           when 2 then \"Two\"\n           when\
    \ 3 then \"Three\"\n           when 4 then \"Four\"\n           when 5 then \"\
    Five\"\n           when 6 then \"Six\"\n           when 7 then \"Seven\"\n   \
    \        when 8 then \"Eight\"\n           when 9 then \"Nine\"\n           else\
    \ x\n           end\n  }\nend", "  return arr.sort.reverse.map { |n| one_nine[n\
    \ % 10] }\nend", "  if arr.size == 0\n    arr\n  else\n    by_length_reverse(arr).\n\
    \    each_with_index do |(elem, idx), i|\n      arr[i] = \"One\" if elem == 1\n\
    \      arr[i] = \"Two\" if elem == 2\n      arr[i] = \"Three\" if elem == 3\n\
    \      arr[i] = \"Four\" if elem == 4\n      arr[i] = \"Five\" if elem == 5\n\
    \      arr[i] = \"Six\" if elem == 6\n      arr[i] = \"Seven\" if elem == 7\n\
    \      arr[i] = \"Eight\" if elem == 8\n      arr[i] = \"Nine\" if elem == 9\n\
    \    end\n    arr\n  end\nend\n</code>\nAnd then use it as:\n<code>\nby_length.call(array.sort)\n\
    </code>\n<|/ a |>\n<| c |>\nI didn't use your code, but your idea works perfectly!\n\
    <|/ c |>\n<| c |>\nIt is not working, I have added an example for you in question.\n\
    <|/ c |>\n<| c |>\nHi , sorry about the inaccurate comment. I was actually trying\
    \ to test your code, but found that I cannot use your method with my array. I\
    \ was trying to test your code with my array and didn't work.\n<|/ c |>\n<| c\
    \ |>\nWhat do you mean by that? You want to sort by length and then sort each\
    \ element in the array by it's order? Do you want to sort by length for every\
    \ element?\n<|/ c |>\n<| c |>\nYes I do want to sort by length for every element!\n\
    <|/ c |>\n<| a tags=ruby dscore=0 |>\n<code>", "  arr.sort!\n  arr.sort!{ |a,\
    \ b| a.length <=> b.length }\n  arr.map!{ |a| a.to_s.reverse }\n  arr.compact!\n\
    \  arr\nend\n</code>\n<|/ a tags=sorting,ruby,arrays |>\n<| c |>\nthis doesn't\
    \ address the issue of not wanting to sort between 1-8 only.\n<|/ c |>\n<| c |>\n\
    He specifically asked for 1-8. Your answer is misleading.\n<|/ c |>\n<| a |>\n\
    I would go with something like this:\n<code>", "  if arr.size < 2 then\n    arr\n\
    \  else\n    result = []\n    i = 0\n    while i < arr.size\n      number = arr[i]\n\
    \      if number >= 1 and number <= 9 then\n        arr[i] = by_name[number]\n\
    \      end\n      i += 1\n    end\n    arr\n  end\nend", "  sorted = by_num.call(arr)\n\
    \  if sorted.length == 0\n    sorted\n  else\n    sorted.reverse!\n    sorted.map!\
    \ {|i| i <=> 1 }\n    sorted.map! {|i| i <=> 2 }\n    sorted.map! {|i| i <=> 3\
    \ }\n    sorted.map! {|i| i <=> 4 }\n    sorted.map! {|i| i <=> 5 }\n    sorted.map!\
    \ {|i| i <=> 6 }\n    sorted.map! {|i| i <=> 7 }\n    sorted.map! {|i| i <=> 8\
    \ }\n    sorted.map! {|i| i <=> 9 }\n  end\nend", "  arr.sort\n  arr.each_with_index\
    \ { |e, i| e = [(\"One\"..\"Nine\").to_a.find { |s| s == e.to_s }] ? e.to_s.capitalize\
    \ : e.to_s }\n  arr.reverse\n  arr.map { |e| e.gsub(\"One\", \"One\") }\nend",
  "  arr.sort.reverse\n  arr.each { |i| arr[i] = number_names[i] unless i.is_a?(Fixnum)\
    \ }\n  arr\nend", "  arr.each do |num|\n    if num.to_i < 1 or num.to_i > 9\n\
    \      next\n    end\n    arr.delete_at(num.to_i - 1)\n    arr[num.to_i - 1] =\
    \ \"#{num.to_i + 10}\".to_sym\n  end\n  arr\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nI didn't say this was necessarily a very clever solution. I just wanted\
    \ to give a hint on how to solve this problem. I'm sure there are a lot of things\
    \ that can go wrong in there, it's definitely not optimal nor elegant. But, if\
    \ you don't understand why this is so bad, don't be afraid to ask me for explanations.\n\
    <|/ c |>\n<| c |>\nOk, I've added some explanations in the answer. Hope that helps.\n\
    <|/ c |>\n<| c |>\n, yea I read it up and I guess it's really a clever way to\
    \ solve it. I think it's better than what I have now. Thanks much! I will use\
    \ your code and see how it performs.\n<|/ c |>\n<| a tags=ruby |>\nI have written\
    \ a function that may seem like a hack, but is actually a lot simpler than what\
    \ you've got, and I think much faster too. Here it is:\n<code>", "  arr.each do\
    \ |n|\n    n -= 1 if n >= 0 && n < 10\n    arr.replace(n, name.lookup(n % 10))\n\
    \  end\n  arr\nend", "  arr.sort!\n  result = []\n  result.replace 0, \"\"\n \
    \ result.replace 1, One\n  result.replace 2, Two\n  result.replace 3, Three\n\
    \  result.replace 4, Four\n  result.replace 5, Five\n  result.replace 6, Six\n\
    \  result.replace 7, Seven\n  result.replace 8, Eight\n  result.replace 9, Nine\n\
    \  result\nend", "  return arr if arr.any? else []\nend", "  return arr if arr.empty?\
    \ || arr.all? { |x| x.is_a?(Integer) && x >= 1 && x <= 9 }\n  arr = arr.reverse\n\
    \  arr.map { |x| x[1..-1].to_sym }.reduce(:+).map { |x| self.send(x) }\nend",
  "  arr.each do |x|\n    if x >= 1 && x <= 9\n      arr.reverse\n      arr.each do\
    \ |y|\n        arr[arr[0] == y ? 1 : 0] = by_length.name(y)\n      end\n    end\n\
    \  end\n  arr\nend", "  return arr.sort { |a, b| b - a } if arr.any?\n  []\nend",
  "  return arr.reverse if arr.length == 0 || arr.all? { |x| x.odd? } else\n  # Sort\
    \ and reverse the array to make it easy to replace.\n  arr.reverse + arr.sort_by\
    \ { |x| x.length }.reverse.map { |x| NAMES[x.to_i] }\nend\n</code>\n<|/ a dscore=5\
    \ tags=ruby,arrays |>\n<| c |>\nThis works great for sorting strings as well:\
    \ `[\"Hello\", \"Hi\", \"Hello\", \"Hi\"].sort!.map! { |x| NAMES.index(x) }.reverse`\
    \ results in `[\"Hi\", \"Hi\", \"Hello\", \"Hello\"]`\n<|/ c |>\n<| c |>\n: Your\
    \ solution is better. I'll add that to your answer.\n<|/ c |>\n<| c |>\nFor sorting\
    \ numeric strings you can use `arr.reverse + arr.sort_by { |x| x.to_i }.reverse.map\
    \ { |x| NAMES.index(x) }.reverse`\n<|/ c |>\n<| a dscore=5 tags=ruby,arrays |>\n\
    You don't need that many \"if\" conditions. Try this:\n<code>\n(1..9).map { |i|\
    \ i.to_s + NAMES[i] }\n</code>\n<|/ a |>\n<| a |>\n<code>", "  arr.empty? || arr.any?\
    \ { |num| num < 1 || num > 9 } ?\n    []\n  : arr.reverse.map { |digit| by_digit[digit]\
    \ }.join\nend\n</code>\nNow you can call this function in your program like this:\n\
    <code>", "  return arr.reduce([]) do |a, b|\n    (1..9).each do |i|\n      a <<\
    \ i if arr[i] == i\n    end\n    a\n  end\nend", "    arr.sort_by{ |x| x <= 9\
    \ ? -x : x }.reverse\n    arr.map { |x| names[x] }\nend", "  arr.each do |n|\n\
    \    next if n < 1 || n > 9\n    arr.reverse_each do |c|\n      break n if c ==\
    \ n\n    end\n  end\n  arr.map do |n|\n    if n == 8\n      \"Eight\"\n    elsif\
    \ n == 9\n      \"Nine\"\n    else\n      to_name[n]\n    end\n  end\nend", " \
    \ if arr.length == 0\n    return []\n  arr.each do |item|\n    next if item <\
    \ 0 || item > 9\n    arr[item - 1] = \"One\"\n    arr[item - 2] = \"Two\"\n  \
    \  arr[item - 3] = \"Three\"\n    arr[item - 4] = \"Four\"\n    arr[item - 5]\
    \ = \"Five\"\n    arr[item - 6] = \"Six\"\n    arr[item - 7] = \"Seven\"\n   \
    \ arr[item - 8] = \"Eight\"\n    arr[item - 9] = \"Nine\"\n  end\n  arr.sort_by\
    \ { |i| i }\n  arr.map { |i| i.to_s }\nend", "  arr.sort!\n  arr.each { |x| x\
    \ = x[/\\d/] }\n  arr.map! { |x| x.to_s } unless arr.empty?\n  arr.empty? ? []\
    \ : arr.map! { |x| x[/^[1-9]/] ? x.to_s : \"One\" }\nend", "  arr.delete_if{|x|\
    \ x.to_i < 1 and x.to_i > 9 }.sort{|a,b| b.to_i - a.to_i }.reverse\nend", "  return\
    \ arr.sort.reverse if arr.size > 0\n  arr.map!{|x| x.to_s}\n  arr.delete('0')\
    \ if arr.size > 0\n  []\nend\n</code>\n<|/ a tags=arrays,ruby |>\n<| c |>\nAwesome,\
    \ this is definitely more efficient and more elegant than the other answers. \
    \ I wish I could accept two answers :(\n<|/ c |>\n<| a tags=arrays,ruby dscore=4\
    \ |>\n<code>", "  return arr unless arr.any?\n  arr.sort_by { |e| e }.reverse.map\
    \ { |e| e.to_s[1..-1] }.compact.join(\" \")\nend", "  return arr.reduce(&:+)\n\
    end", "  length = arr.size\n  arr.each do |x|\n    if x < 1 || x > 9\n      next\n\
    \    end\n    arr[x - 1] = \"#{names[x - 1]}\"\n  end\n  arr\nend", "  arr.sort.reverse!\n\
    \  arr.map do |x| \n    if x % 10 == 1 && x % 100 != 11\n      x += 1\n      \"\
    One\"\n    elsif x % 10 == 2 && x % 100 != 12\n      x += 1\n      \"Two\"\n \
    \   elsif x % 10 == 3 && x % 100 != 13\n      x += 1\n      \"Three\"\n    elsif\
    \ x % 10 == 4 && x % 100 != 14\n      x += 1\n      \"Four\"\n    elsif x % 10\
    \ == 5 && x % 100 != 15\n      x += 1\n      \"Five\"\n    elsif x % 10 == 6 &&\
    \ x % 100 != 16\n      x += 1\n      \"Six\"\n    elsif x % 10 == 7 && x % 100\
    \ != 17\n      x += 1\n      \"Seven\"\n    elsif x % 10 == 8 && x % 100 != 18\n\
    \      x += 1\n      \"Eight\"\n    elsif x % 10 == 9 && x % 100 != 19\n     \
    \ x += 1\n      \"Nine\"\n    end\n  end\nend\n</code>\n<|/ a dscore=2 |>\n<|\
    \ c |>\nI made a more \"pythonic\" version for those who want to use it: https://gist.github.com/mnikolajc/832f33bcaf24e095abbf9f64ddea67c8\n\
    <|/ c |>\n<| a tags=algorithm,ruby,arrays |>\nHere is another one (based on 's\
    \ answer)\n<code>", "  arr = arr.sort\n  arr.delete_if{|x| x < 1 || x > 9}\n \
    \ if arr.empty?\n    []\n  else\n    arr.map!{|x| x == 1 ? One.to_sym : x == 2\
    \ ? Two.to_sym : x == 3 ? Three.to_sym : x == 4 ? Four.to_sym : x == 5 ? Five.to_sym\
    \ : x == 6 ? Six.to_sym : x == 7 ? Seven.to_sym : x == 8 ? Eight.to_sym : x ==\
    \ 9 ? Nine.to_sym : x}\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nI don't think\
    \ you understood the question. the question asks about how to write a function\
    \ that takes an array, sorts it, and returns the new array in lexicographical\
    \ order\n<|/ c |>\n<| a |>\nTo sort the array lexicographically, first use sort_by\
    \ (which sorts by the first argument, in this case integers), and then use reverse\
    \ to sort the array in reverse lexicographical order.\n<|/ a dscore=2 tags=ruby\
    \ |>\n<| a tags=ruby |>\nJust use Enumerable#sort with a block. For example,\n\
    <code>", "  arr.sort!\n  arr = arr.reverse\n  arr.map!{|x| [\"One\", \"Two\",\
    \ \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"][x]}\n\
    \  arr.compact!\n  arr\nend\n</code>\n<|/ a |>\n<| a |>\n<code>\narray = [\n \
    \ [\"One\", 1, 10, 20],\n  [\"Two\", 2, 11, 30],\n  [\"Three\", 3, 12, 40],\n\
    \  [\"Four\", 4, 13, 50],\n  [\"Five\", 5, 14, 60],\n  [\"Six\", 6, 15, 70],\n\
    \  [\"Seven\", 7, 16, 80],\n  [\"Eight\", 8, 17, 90],\n  [\"Nine\", 9, 18, 100]\n\
    ]", "  arr.sort!\n  arr.each { |i| i =~ /^1/ && arr.pop }\n  arr.reverse!\n  arr.map!\
    \ { |i| lookup(i) }\nend", "  # Write your code here\n  if arr.empty?\n    []\n\
    \  else\n    arr_sorted = arr.sort { |a, b| a.to_i <=> b.to_i }\n    arr_sorted\
    \ = arr_sorted.reverse\n    arr_sorted = arr_sorted.map do |n|\n      if n % 10\
    \ == 1\n        \"One\"\n      elsif n % 10 == 2\n        \"Two\"\n      elsif\
    \ n % 10 == 3\n        \"Three\"\n      elsif n % 10 == 4\n        \"Four\"\n\
    \      elsif n % 10 == 5\n        \"Five\"\n      elsif n % 10 == 6\n        \"\
    Six\"\n      elsif n % 10 == 7\n        \"Seven\"\n      elsif n % 10 == 8\n \
    \       \"Eight\"\n      elsif n % 10 == 9\n        \"Nine\"\n      else\n   \
    \     n\n      end\n    end\n    arr_sorted\n  end\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nYour code does not work for numbers < 10 `by_length.call([2, 1,\
    \ 1, 4, 5, 8, 2, 3])`\n<|/ c |>\n<| a tags=ruby,arrays |>\nHere's another approach\
    \ using Enumerable#each_slice:\n<code>\narr = [1,2,3,4,5,6,7,8,9,0]", "  arr.flatten!\n\
    \  arr.sort!\n  arr.each_index { |index| arr[index] = arr[index].to_s.reverse\
    \ }\n  arr.compact!\n  return arr\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\n\
    I feel obliged to point out that `sort_by` has now been deprecated. I think you\
    \ meant to use `sort_by` and not `sort`\n<|/ c |>\n<| a |>\n<code>", "  return\
    \ arr.sort { |a, b| b.to_s.length <=> a.to_s.length }.\n    map { |e| name_by_length[e]\
    \ }\nend", "  arr.map!{ |x| x <= 9 ? x.to_s.upcase : nil }\n  arr.sort!\n  arr.map!{\
    \ |x| x <= 9 ? One[x] : nil }\n  arr\nend\n</code>\n<|/ a tags=sorting,ruby,arrays\
    \ |>\n<| c |>\nThe question states \"If the array is empty, return an empty array\"\
    . This solution won't do that.\n<|/ c |>\n<| c |>\nYou're right, I didn't read\
    \ that part and I actually didn't test this one.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work for `[1, 1, 1]`. Also, it's not clear to me that it's a better solution,\
    \ since it seems like it would take a lot more processing power than the other\
    \ answers, in addition to needing more memory.\n<|/ c |>\n<| c |>\nYes, this is\
    \ a nice solution. But in my opinion it is more complicated then other solutions.\
    \ You don't need to create a `Hash` object every time you want to check if an\
    \ element already exists in the hash. Also, you need to create an array with the\
    \ original values in order to reverse it.\n<|/ c |>\n<| c |>\nYes, it is more\
    \ complicated. I'm thinking of how to improve this solution so I'll try to do\
    \ that.\n<|/ c |>\n<| a tags=sorting,ruby,arrays |>\n<code>", "  arr.dup.sort.reverse.inject([])\
    \ {|ar, el| el == 'One' ? ar.unshift \"One\" :\n          el == 'Two' ? ar.unshift\
    \ \"Two\" :\n          el == 'Three' ? ar.unshift \"Three\" :\n          el ==\
    \ 'Four' ? ar.unshift \"Four\" :\n          el == 'Five' ? ar.unshift \"Five\"\
    \ :\n          el == 'Six' ? ar.unshift \"Six\" :\n          el == 'Seven' ? ar.unshift\
    \ \"Seven\" :\n          el == 'Eight' ? ar.unshift \"Eight\" :\n          el\
    \ == 'Nine' ? ar.unshift \"Nine\" :\n          ar.unshift el }\nend", "  arr.sort.reverse.map!\
    \ {|x| get_by_number(x)}\n  arr.empty? || arr.sort\nend", "  arr.sort.reverse.map{|i|\
    \ One[i]} if arr\nend", "  return arr.reduce(:<<).sort.reverse_each.map { |n|\
    \ names(n) }\nend", "  return arr.reverse if arr.length > 0 else\n         []\n\
    end", "  return arr.sort.reverse.map { |s| s.to_s.send(@names[s.to_i]) }\nend",
  "  arr.sort.reverse\n  arr.map! do |i|\n    i = i.to_s\n    i = i.to_i if i <= 9\n\
    \    i\n  end\n  arr.empty? ? [] : arr\nend", "  arr = arr.to_a\n  arr.sort!\n\
    \  arr.each { |i| arr[i] = \"One\"    if i == 1\n           arr[i] = \"Two\" \
    \   if i == 2\n           arr[i] = \"Three\"  if i == 3\n           arr[i] = \"\
    Four\"   if i == 4\n           arr[i] = \"Five\"   if i == 5\n           arr[i]\
    \ = \"Six\"    if i == 6\n           arr[i] = \"Seven\"  if i == 7\n         \
    \  arr[i] = \"Eight\"  if i == 8\n           arr[i] = \"Nine\"   if i == 9\n \
    \          arr[i] = \"N/A\"    if i == 0 }\n  arr.reverse!\n  arr\nend", '  arr.sort!',
  "    arr = arr.sort { |a,b| a <=> b }\n    arr[1..9].map!{|i| byLength.call(i)}\n\
    \    arr[0..1]\nend", "  return [] if arr.empty? || arr.any? { |i| i.to_i == -1\
    \ }\n  arr.sort { |a, b| b - a }.reverse.map { |i| get_name(i) }\nend", "  arr.sort!\n\
    \  result = []\n  i = 0\n  while i < arr.length\n    if arr[i] > 9\n      arr[i]\
    \ = \"#{arr[i]}#{arr[i+1]}\"\n      i += 2\n    else\n      arr[i] = \"#{arr[i]}\"\
    \n    end\n    i += 1\n  end\n  result\nend\n</code>\n<|/ a tags=ruby |>\n<| c\
    \ |>\nThis solution doesn't work if `arr = [1,2,4,6,7]`. After sorting `arr =\
    \ [1,2,4,6,7,9,0]`. The result should be `[\"One\", \"One\", \"Two\", \"Two\"\
    , \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]`. Your solution\
    \ returns `\"One\"` for the number `1`.\n<|/ c |>\n<| c |>\nPlease explain why\
    \ your solution returns `[\"One\", \"One\", \"Two\", \"Two\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\"]` for `arr = [1,2,4,6,7,9,0]`.\n<|/\
    \ c |>\n<| c |>\n, you're right, let me fix it\n<|/ c |>\n<| a dscore=1 tags=ruby\
    \ |>\nThis solution uses Enumerable#sort_by:\n<code>", "  arr.each { |x| x = x.to_i\
    \ }\n  arr.sort! { |a,b| b.to_i - a.to_i }\n  arr.map { |x| arr % 10 == 0 ? \"\
    One\" : \"Two\" }\nend", "  return [] unless arr.length\n  \n  arr.sort!", " \
    \ arr.empty? ? [] : arr.sort_by{ |v| v % 10 }.map do |v|\n    v = v % 10\n   \
    \ \"One\"[v] == nil ? \"One\" : v == 0 ? \"Zero\" : v == 1 ? v = \"One\" : v =\
    \ \"Two\"[v]\n  end.compact\nend", "  arr.compact.sort_by { |x| x.to_i }.reverse.map!\
    \ { |x| x.to_s }\n  arr.compact.empty? ? [] : arr.compact.map { |x| x.to_s }\n\
    end", "  arr.sort.reverse.map{|x| x % 10 == 1 ? [\"One\", \"Two\", \"Three\",\
    \ \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"][x / 10] : x}\n\
    end", "  result = []\n  until arr.empty?\n    arr.pop.each {|i| \n      if i.between?(1,\
    \ 9) \n        result << by_length.call([i])\n      else \n        result << by_length.call([i]).to_s\
    \ + \" One\"\n      end\n    }\n  end\n  result\nend", "  if arr.empty?\n    []\n\
    \  else\n    arr.group_by { |e| e % 10 }.sort.reverse_each do |k, v|\n      k.to_s\
    \ + v.map(&:to_s).join('')\n    end\n  end\nend", "  arr = arr.sort\n  result\
    \ = []\n  until arr.empty?\n    if arr[arr.size - 1] > 10\n      result[-1] =\
    \ \"#{arr[arr.size - 1].to_s[0...1]} #{by_length.call(arr[0...arr.size - 1])}\"\
    \n    else\n      result[-1] = \"#{arr[arr.size - 1].to_s[0...1]}\"\n    end\n\
    \    arr.pop\n  end\n  result\nend", "  arr.each do |x|\n    case x\n    when\
    \ 1..9\n      rev = x.to_s\n      rev.reverse!\n      rev.gsub!(/[1-9]/) { |s|\
    \ digits[s].name }\n    when 10..99\n      rev = (x - 10).to_s\n      rev.reverse!\n\
    \      rev.gsub!(/[1-9]/) { |s| digits[s].name }\n    when 100..999\n      rev\
    \ = (x - 100).to_s\n      rev.reverse!\n      rev.gsub!(/[1-9]/) { |s| digits[s].name\
    \ }\n    when 1000..9999\n      rev = (x - 1000).to_s\n      rev.reverse!\n  \
    \    rev.gsub!(/[1-9]/) { |s| digits[s].name }\n    when 10000..99999\n      rev\
    \ = (x - 10000).to_s\n      rev.reverse!\n      rev.gsub!(/[1-9]/) { |s| digits[s].name\
    \ }\n    when 100000..999999\n      rev = (x - 100000).to_s\n      rev.reverse!\n\
    \      rev.gsub!(/[1-9]/) { |s| digits[s].name }\n    when 1000000..9999999\n\
    \      rev = (x - 1000000).to_s\n      rev.reverse!\n      rev.gsub!(/[1-9]/)\
    \ { |s| digits[s].name }\n    when 10000000..99999999\n      rev = (x - 10000000).to_s\n\
    \      rev.reverse!\n      rev.gsub!(/[1-9]/) { |s| digits[s].name }\n    when\
    \ 100000000..99999999999\n      rev = (x - 100000000).to_s\n      rev.reverse!\n\
    \      rev.gsub!(/[1-9]/) { |s| digits[s].name }\n    when 10000000000..999999999999\n\
    \      rev = (x - 10000000000).to_s\n      rev.reverse!\n      rev.gsub!(/[1-9]/)\
    \ { |s| digits[s].name }\n    when 1000000000000..999999999999999\n      rev =\
    \ (x - 1000000000000).to_s\n      rev.reverse!\n      rev.gsub!(/[1-9]/) { |s|\
    \ digits[s].name }\n    when 10000000000000..9999999999999999\n      rev = (x\
    \ - 10000000000000).to_s\n      rev.reverse!\n      rev.g", "  return arr.reverse\
    \ if arr.length < 9\n  arr.dup.sort.map { |n| names[n] }.compact\nend", "  return\
    \ arr if arr.size == 1 && !arr[0] && !arr[1] && !arr[2] && arr[1].nil? && arr[2].nil?\
    \ && arr[3].nil? && !arr[4] && !arr[5] && !arr[6] && !arr[7] && !arr[8] && !arr[9]\
    \ else arr.sort_by { |x| x.to_s.length }.reverse.to_a.map { |x| by_length.call(x)\
    \ }\nend", "  if arr.size == 0\n    []\n  else\n    arr.sort { |x, y| y <=> x\
    \ }.reverse.map { |x| by_length_digits[x] }.join(\", \")\n  end\nend", "  arr.sort!\n\
    \  if arr.empty?\n    []\n  elsif arr.length == 1\n    arr[0]\n  elsif arr.length\
    \ > 10\n    arr[arr.length / 2]\n  else\n    arr[arr.length / 2 - 1 .. -1].reverse\
    \ + arr[0]\n  end\nend", "  arr.sort!\n  arr.reverse!\n  arr.map {|i| i % 10 ==\
    \ 0 ? \"One\" : i % 10 == 1 ? \n                  \"Two\" : i % 10 == 2 ? \"Three\"\
    \ : \n                  i % 10 == 3 ? \"Four\" : \n                  i % 10 ==\
    \ 4 ? \"Five\" : \n                  i % 10 == 5 ? \"Six\" : \n              \
    \    i % 10 == 6 ? \"Seven\" : \n                  i % 10 == 7 ? \"Eight\" : \n\
    \                  i % 10 == 8 ? \"Nine\" : \n                  nil }\nend", " \
    \ arr.compact.sort.reverse.map { |n| name_for(n) }\nend", "  return arr.reverse.reduce(&:<<)\
    \ if arr.any?\n  []\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis works for\
    \ me `by_length.call([2, 1, 1, 4, 5, 8, 2, 3]).map{|x| [x.to_s[1..-1], x]}.reverse`\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "  if arr.empty?\n    arr\n  else\n    arr.sort_by\
    \ do |x|\n      x < 9 || x > 9 ? x : x - 10\n    end.reverse.map { |i| names[i]\
    \ || i }\n  end\nend", "  arr.sort.reverse.map { |i| i_to_name(i) if i.between?(1,\
    \ 9) }\nend", "  return arr.sort { |a, b| a <=> b }.empty? ? [] : arr.map { |i|\
    \ i % 10 == 0 ? 'One' : i % 10 == 1 ? 'Two' : i % 10 == 2 ? 'Three' : i % 10 ==\
    \ 3 ? 'Four' : i % 10 == 4 ? 'Five' : i % 10 == 5 ? 'Six' : i % 10 == 6 ? 'Seven'\
    \ : i % 10 == 7 ? 'Eight' : i % 10 == 8 ? 'Nine' : '???' }.reverse\nend", "  arr.sort\
    \ { |a,b| (a < b) ? -1 : 1 }\n  return arr.map do |i|\n    num = i % 10\n    (num\
    \ > 0) ? \"#{num}\" : names[num].call\n  end\nend", "  return arr.select {|el|\
    \ between?(el, 1..9) }.sort.reverse.map { |x| name[x % 10] }\nend", "  arr.sort!\n\
    \  arr.each { |i| arr[i] = \"One\" if i.to_s == i.to_i || i.to_s == i.to_i + 1\
    \ }\n  arr.empty? ? [] : arr.reverse!\nend", "  return arr.reverse.compact.map\
    \ {|e| names[e] if e < names.length }\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\n\
    I love this solution. It reminds me of using a hash table as a map to convert\
    \ numbers to strings.\n<|/ c |>\n<| c |>\nI like it.  I wish I could accept more\
    \ than just one answer.\n<|/ c |>\n<| a dscore=3 |>\nHere's a solution using only\
    \ strings and a hash table:\n<code>", "  return arr.sort_by { |x| x[/[1-9]+/].to_i\
    \ }.reverse.map { |x| x[/[1-9]+/].to_sym }.compact.flatten\nend", "  return arr.reject\
    \ { |x| x.to_i < 1 || x.to_i > 9 }.sort.map { |x| [\"One\", \"Two\", \"Three\"\
    , \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"][x.to_i - 1] } +\
    \ (arr.empty? ? [] : arr.uniq.sort.map { |x| [\"One\", \"Two\", \"Three\", \"\
    Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"][x.to_i - 1] })\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| a tags=ruby |>\nHere is a way that uses one loop\
    \ and two Array#* methods:\n<code>\narr = [\"One\", \"Two\", \"Three\", \"Four\"\
    , \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\nsorted = arr.map do |s|\n\
    \  i = s.index(s)\n  s[(i..-1).map { |i| arr[i] }.join]\nend\n</code>\nIf you\
    \ don't know a thing about Array#* you can read more about it here: http://www.ruby-doc.org/core-2.1.1/Array.html#method-i-2D\n\
    <|/ a dscore=1 |>\n<| a |>\nHere's a way that uses a while loop:\n<code>", " \
    \ arr.sort!\n  arr.reverse!\n  arr.each do |e|\n    arr[e] = names[e]\n  end\n\
    \  arr\nend", "  arr.sort { |a, b| b - a }.reverse.map { |i| self.digs.assoc(i)\
    \ }\nend", "  arr.map {|n| n.is_a?(Integer) ? get_name(n) : \"#{n}\".to_i}.reverse\n\
    end", "  return [] if arr.empty? || arr.any? { |n| n.to_i < 1 || n.to_i > 9 }\n\
    \  arr.sort_by { |n| n.to_i < 1 ? 1 : n.to_i > 9 ? -1 : n }.reverse.map(&:to_s).join(\"\
    , \")\nend", "  return [] if arr.empty? or arr.any?(&:strange?)\n  arr = arr.sort!.sort_by\
    \ { |i| [i % 10, i] }.reverse\n  arr.map { |i| name_to_digit(i) }\nend", "  return\
    \ arr.reverse if arr !~ /^\\d+$/ || arr.size <= 1 || arr.size == 9 else arr.map\
    \ { |n| numbers[n] }\nend", "  arr.sort.reverse_each(&:to_s)\n  arr.empty? ? []\
    \ : arr.map{ |s| s_by_length[s] }\nend", "  arr.sort!\n  arr.select! { |x| x >=\
    \ 1 && x <= 9 }\n  arr.map! { |x| names[x - 1] }.compact\nend", "  # Sort the\
    \ array by descending length\n  arr.sort!.reverse\n  \n  # Initialize a new array\
    \ to hold the result of the operation\n  res = []\n  \n  # Process the array in\
    \ reverse, beginning with largest values\n  while arr.any?\n    val = arr.pop\n\
    \    \n    # Remove all numbers divisible by 10\n    if val % 10 != 0\n      #\
    \ Ignore the number\n      next\n    else\n      res.append(names(val))\n    end\n\
    \  end\n  \n  return res\nend", "  arr.flatten.sort_by(&:length).reverse # reverse\
    \ the array and sort by length\n  .each { |x| x[x.length % 3] = \"#{NAMES[x]}#{x.length\
    \ % 3}\"}\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nThe accepted answer\
    \ didn't work for me (I got \"One\" repeated in the output) because I was running\
    \ it in irb rather than Rails console.  So I used the code below:\n<code>\nNAMES\
    \ = %w[One Two Three Four Five Six Seven Eight Nine]", "  if arr.length == 0\n\
    \    []\n  else\n    puts \"Sorting integers from 1 to 9...\"\n    puts \"Reversing\
    \ array...\"\n    puts \"Replacing digits...\"\n    (arr[0..-2].sort.reverse +\
    \ arr[-2..-1].map.to_s).map {|n| n.to_s.upcase }\n  end\nend", "  arr.compact.sort.reverse_each.with_index.reject{|e,\
    \ i| i == arr.length}.\n    map{|e| e == arr.first ? \"One\" : e == arr.last ?\
    \ \"Nine\" : e.to_s }.compact\nend\n</code>\n<|/ a |>\n<| c |>\nGood work, thanks\
    \ for posting this code - I have been struggling with this and you've done it\
    \ very well.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  return [] unless arr.any?\
    \ and arr.all? { |x| x >= 1 and x <= 9 }\n  sorted_arr = arr.sort\n  sorted_arr.reverse\n\
    \  sorted_arr.each_with_index do |digit, i|\n    if i < arr.size - 1\n      sorted_arr[i]\
    \ = \"#{digit}##{arr[i + 1]}\"\n    end\n  end\nend", "  arr.each do |x|\n   \
    \ x.to_i if 1 <= x.to_i && x.to_i <= 9\n  end.reverse!\n  arr.map do |x|\n   \
    \ \"One\" if x == 1\n    \"Two\" if x == 2\n    \"Three\" if x == 3\n    \"Four\"\
    \ if x == 4\n    \"Five\" if x == 5\n    \"Six\" if x == 6\n    \"Seven\" if x\
    \ == 7\n    \"Eight\" if x == 8\n    \"Nine\" if x == 9\n    x\n  end\nend\n</code>\n\
    <|/ a tags=ruby dscore=1 |>\n<| c |>\nThank you so much for the answer! This was\
    \ a great lesson.\n<|/ c |>\n<| a dscore=0 |>\nHere's another way of doing it\n\
    <code>\nnumbers = [1, 3, 6, 2, 10, 4, 7, 8, 2, 9, 6, 11, 5]", "  arr.uniq.compact!\n\
    \  arr.sort!.reverse\n  arr.reject!{|n| n < 1 || n > 9}\n  arr = arr.map{|n| n\
    \ == 1 ? \"One\" : n == 2 ? \"Two\" : n == 3 ? \"Three\" : n == 4 ? \"Four\" :\
    \ n == 5 ? \"Five\" : n == 6 ? \"Six\" : n == 7 ? \"Seven\" : n == 8 ? \"Eight\"\
    \ : n == 9 ? \"Nine\" : nil}.compact\n  arr\nend", "  # If there are no elements,\
    \ return an empty array\n  return [] if arr.empty?\n  # If there are less than\
    \ 2 elements, return an empty array\n  return [] if arr.size < 2", "  arr.each\
    \ do |a|\n    if a <= 9\n      arr[a / 10] ||= \"\"\n      arr[a % 10] = \"#{by_length.call([arr[a]])[0]}\"\
    \n    end\n  end\n  return arr\nend", "  arr = arr.dup\n  arr.sort!\n  arr.map!\
    \ { |n| n == 1 ? 1 : n == -9 ? 9 : n }\n  arr.compact!\n  arr.map! { |n| n < 0\
    \ ? nil : \"#{to_s(n)}\" }\n  arr.compact!\n  arr.compact!\n  arr\nend\n</code>\n\
    <code>\narr = [1, 9, 1, 3, 4, 8, 5, 3, 2]\nby_length(arr)\n  #=> [\"Eight\", \"\
    Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\nby_length([])\n\
    \  #=> []\nby_length([1, -1, 55])\n  #=> [\"One\"]\n</code>\n<|/ a |>\n<| c |>\n\
    `by_length.call([2, 1, 1, 4, 5, 8, 2, 3])` gives me `\"Eight\"` and not `\"Four\"\
    `.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  return [] if arr.empty? || arr.any?(&(&1.class\
    \ == Integer)\n  arr.select {|x| x.between?(1, 9) }.sort.reverse.map { |i| i.to_s\
    \ }.map { |i| to_one(i) }\nend", "  arr.sort { |a,b| b - a }.reverse\n  arr.reject\
    \ { |n| n == 0 }\nend", "  arr.each_with_index.sort\n  arr.each_with_index.inject([])\
    \ { |a,e| a << \"#{e.last}#{e.first == 1 ? \"\" : \"s}\"}\nend", "    sorted =\
    \ arr.sort\n    sorted.reverse!\n    sorted.each_with_index do |number, index|\n\
    \        number = (number % 9) + 1\n        number = (\"One\"..\"Nine\").to_a.find\
    \ { |s| s == number.to_s }\n        sorted[index] = number\n    end\n    sorted.collect!(&:to_s)\n\
    end", "  return arr[0..-1].sort_by { |num| num.divmod(10).last }.map { |x| by_digit[x]\
    \ }\nend", "  return arr.sort.reverse.reduce(:<<).to_enum.to_a.compact.uniq if\
    \ arr\nend", "  arr.sort!\n  arr.map! { |e| by_number.call(e) }\n  arr.compact!\n\
    \  arr.map! { |e| by_letter.call(e) }\n  arr\nend", "  arr.delete_if { |x| x ==\
    \ 0 }\n  arr.reverse_each(&:first)\n  arr.map { |x| x % 10 }\nend", "  arr.compact.sort\
    \ { |a, b| b <=> a }.map(&:to_s).select(&:digit?).reverse.map(&:to_sym)\nend",
  "    arr.sort! # Sort ascending\n    return arr.map { |x| x >= 0 ? name : \"\" }\n\
    end\n</code>\n<|/ a tags=arrays,ruby dscore=1 |>\n<| a dscore=1 tags=arrays,ruby\
    \ |>\nAnother approach:\n<code>", "  arr.each_with_index do |number, index|\n\
    \    if number < 1 || number > 9\n      arr[index] = nil\n    else\n      arr[index]\
    \ = name.find { |name| name =~ Regexp.new(\"^(#{number.to_s.reverse})\") } ||\
    \ number\n    end\n  end\n  arr.empty? ? [] : arr.map! { |i| i.to_s.reverse.gsub(/(?=\\\
    D)|\\z{2,}/, '') }\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>",
  "  arr.each do |i|\n    i = i.to_i\n    arr[i] = [\"One\", \"Two\", \"Three\", \"\
    Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"][i / 10] + \\\n    \
    \         [\"Zero\"][i % 10]\n  end\n  arr.compact!\n  arr\nend", "  arr.flatten.sort!\n\
    \  arr.map do |x|\n    if x.is_a? Integer\n      x = x.between? 1, 9\n    end\n\
    \    case x\n    when true\n      \"One\"\n    when false\n      \"Two\"\n   \
    \ when nil\n      \"Three\"\n    when 1\n      \"One\"\n    when 2\n      \"Two\"\
    \n    when 3\n      \"Three\"\n    when 4\n      \"Four\"\n    when 5\n      \"\
    Five\"\n    when 6\n      \"Six\"\n    when 7\n      \"Seven\"\n    when 8\n \
    \     \"Eight\"\n    when 9\n      \"Nine\"\n    else\n      \"?\"\n    end\n\
    \  end.flatten\nend", "  arr.empty? ? [] : arr.sort_by { |x| x >= 1 && x <= 9\
    \ ? x.to_s.rjust(3, '0') : x }.reverse.map { |x| ones[x.to_s.to_i] }\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThis is an interesting solution.  I haven't used `group_by`\
    \ before, so I'm going to see if I can figure out how to use it.\n<|/ c |>\n<|\
    \ c |>\nThe `group_by` method is a Ruby core method that groups an array by one\
    \ of its elements. In this case, the `group_by` method is used to separate the\
    \ different number spaces based on the number length.\n<|/ c |>\n<| c |>\nThanks\
    \ for all the help.  I appreciate it!\n<|/ c |>\n<| c |>\nIf this answer was helpful,\
    \ consider [accepting](http://stackoverflow.com/help/accepted-answer) it\n<|/\
    \ c |>\n<| a dscore=1 |>\nJust for fun, here is another possibility.  I am pretty\
    \ sure the other answer will do what you want faster, but this solution also might\
    \ be interesting if you want to learn how to use Ruby more effectively.\n<code>",
  "  # Add all the numbers in the array to a new array called \"new\" with each element\
    \ being\n  # the length of the array.\n  new_numbers = []\n  i = 0\n  while i\
    \ < arr.length\n    lenth = arr.length - i\n    number = arr[lenth]\n    i +=\
    \ 1", "  return arr.reverse if arr.is_a?(Array) else\n    (arr < 1 ? [\"One\"\
    ] : (arr < 2 ? [\"Two\"] : (arr < 3 ? [\"Three\"] : (arr < 4 ? [\"Four\"] : (arr\
    \ < 5 ? [\"Five\"] : (arr < 6 ? [\"Six\"] : (arr < 7 ? [\"Seven\"] : (arr < 8\
    \ ? [\"Eight\"] : (arr < 9 ? [\"Nine\"] : [\"Ten\"]))))))))\nend", "  arr.sort!\n\
    \  arr.map.with_index do |e, i|\n    if i % 2 == 0\n      e\n    else\n      by_length.call([e])\n\
    \    end\n  end\nend", "  arr.each { |num| num.is_a?(Integer) && num > 0 && num\
    \ < 10 && num.to_s <= \"9\" && num.to_s !~ /^0/ && num <= 9 && num >= 1 ?\n  \
    \  arr[num.to_s.size - 1] == \"One\" ? \"One\" : arr[num.to_s.size - 1] == \"\
    Two\" ? \"Two\" : arr[num.to_s.size - 1] == \"Three\" ? \"Three\" : arr[num.to_s.size\
    \ - 1] == \"Four\" ? \"Four\" : arr[num.to_s.size - 1] == \"Five\" ? \"Five\"\
    \ : arr[num.to_s.size - 1] == \"Six\" ? \"Six\" : arr[num.to_s.size - 1] == \"\
    Seven\" ? \"Seven\" : arr[num.to_s.size - 1] == \"Eight\" ? \"Eight\" : arr[num.to_s.size\
    \ - 1] == \"Nine\" ? \"Nine\" : nil :\n    arr[num.to_s.size - 1] != \"One\" &&\
    \ arr[num.to_s.size - 1] != \"Two\" && arr[num.to_s.size - 1] != \"Three\" &&\
    \ arr[num.to_s.size - 1] != \"Four\" && arr[num.to_s.size - 1] != \"Five\" &&\
    \ arr[num.to_s.size - 1] != \"Six\" && arr[num.to_s.size - 1] != \"Seven\" &&\
    \ arr[num.to_s.size - 1] != \"Eight\" && arr[num.to_s.size - 1] != \"Nine\"\n\
    \  }\nend", "  arr.sort! { |a,b| a <=> b }\n  arr.empty? ? [] : arr.map { |i|\
    \ name(i) }.reverse\nend", "  arr.map { |num| num < 10 ? \"One\" : num < 20 ?\
    \ \"Two\" : num < 30 ? \"Three\" : num < 40 ? \"Four\" : num < 50 ? \"Five\" :\
    \ num < 60 ? \"Six\" : num < 70 ? \"Seven\" : num < 80 ? \"Eight\" : num < 90\
    \ ? \"Nine\" : nil }.sort.reverse\nend", "  return arr.sort_by { |x| x.to_i }.reverse.map\
    \ { |x| to_name(x) }.compact.uniq\nend", "  return arr.reverse.map do |e|\n  \
    \  arr = e.to_s.split(//).map do |c|\n      (c.to_i >= \"1\" && c.to_i <= \"9\"\
    ) ? \"One\" :\n      (c.to_i >= \"0\" && c.to_i <= \"9\") ? \"Two\" :\n      (c.to_i\
    \ >= \"A\" && c.to_i <= \"Z\") ? \"Three\" :\n      \"Four\"\n    end\n    arr[0]\
    \ + (arr[1] ? arr[1] : \"0\")\n  end\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby,sorting,arrays\
    \ |>\n<code>", "    arr = arr.sort\n    arr.push(1)\n    arr.pop\n    return arr.reduce([])\
    \ do |result, (elt, i)|\n        if i > 1 && elt >= 10\n            result <<\
    \ by_length.call(elt)\n        else\n            result << by_length.call(elt)[i\
    \ % 10] || elt.to_s\n        end\n        result\n    end\nend", "  if arr.size\
    \ > 0\n    arr.sort.reverse\n    arr.replace \"One\", \"Two\"\n    arr.replace\
    \ \"Two\", \"Three\"\n    arr.replace \"Three\", \"Four\"\n    arr.replace \"\
    Four\", \"Five\"\n    arr.replace \"Five\", \"Six\"\n    arr.replace \"Six\",\
    \ \"Seven\"\n    arr.replace \"Seven\", \"Eight\"\n    arr.replace \"Eight\",\
    \ \"Nine\"\n    arr.replace \"Nine\", \"One\"\n  end\n  arr\nend", "  arr.each\
    \ do |i|\n    if i != -1 && i != 9 && i != 0 && i != 1\n      arr[i] = by_length(arr[i])\n\
    \    end\n  end\n  arr = arr.reverse\n  arr.map do |i|\n    if i == -1\n     \
    \ \"One\"\n    elsif i == 0\n      \"Zero\"\n    elsif i == 9\n      \"Nine\"\n\
    \    else\n      \"#{i.to_s[0..1]}\"\n    end\n  end\nend", "  arr = arr.to_a\n\
    \  return arr.sort.reverse_each.map do |num|\n    num = num.to_s\n    unless [\"\
    One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\
    \ \"Nine\"].include? num\n      num\n    end\n  end.compact.flatten\nend", " \
    \ return arr.sort.reverse.reject{|x| x.odd? }.reduce([]) unless arr.size > 0\n\
    end", "  arr.sort!\n  arr.reverse!\n  arr.each do |d|\n    next if d < 1\n   \
    \ next if d > 9\n    d -= 1\n    arr[arr.index(d) + 1] = by_num[d]\n  end\n  arr\n\
    end\n</code>\n<|/ a tags=sorting,ruby,ruby-on-rails,arrays |>\n<| c |>\nThat is\
    \ very clever! Thank you! I guess I will have to play with it a little more, but\
    \ this definitely looks interesting.\n<|/ c |>\n<| c |>\nYes, I should have clarified\
    \ that the goal was to rewrite the question as asked, rather than to refactor\
    \ the code.  I see what you mean about the goal being confusing - it's better\
    \ to think of it as refactoring rather than rewriting.  I've updated the question\
    \ to clarify.\n<|/ c |>\n<| c |>\nIt might help to know that my array is sorted,\
    \ and each number has between 1 and 9 digits.\n<|/ c |>\n<| a tags=sorting,ruby,ruby-on-rails,arrays\
    \ |>\n<code>\na = ['One','Two','Three','Four','Five','Six','Seven','Eight','Nine']\n\
    a.group_by{|x| x.to_i}.sort{|x,y| x.count<=>y.count}.map{|k,v| k[0].dup.tap{|a|\
    \ a.map{|x| a.shift }}.join}\n</code>\n<|/ a dscore=3 |>\n<| a tags=sorting,ruby,ruby-on-rails,arrays\
    \ |>\nYou could use group_by to get an array of [x,y] pairs, where each pair is\
    \ of the form [#<=> x, #<=> y].  Then sort by the first, with the second element\
    \ being a map of all the indices of the first element.  Then join the elements\
    \ of that map.\n<code>", "  return arr.reject(&:odd?).reverse.map(&:zero?) ? arr\
    \ : []\nend", "  return arr.reverse if arr.length > 0 and arr.uniq.all? { |i|\
    \ i < 10 } and arr.size == arr.uniq.size else []\nend", "  arr.compact.sort.map\
    \ do |n|\n    if n < 1 || n > 9\n      \"\"\n    else\n      name = one_to_nine[n-1]\n\
    \      one_to_nine[n-1] = name\n      name\n    end\n  end.compact\nend", "  return\
    \ arr.sort { |x,y| y - x } if arr.size > 0 &&\n    arr.each { |x| x < 1 && x >\
    \ 9 } # if all are between 1 and 9\n  # reverse the order of the numbers\n  arr.reverse.map\
    \ { |x| names.index(x) + 1 } if arr.size > 0\nend", "  return arr.reverse.map\
    \ { |n| n.to_s.upcase if by_number.call(n).any? }\nend", "    arr.sort!\n    arr.rotate!\n\
    \    arr.map! {|x| [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\",\
    \ \"Seven\", \"Eight\", \"Nine\"][x - 1]}\n    arr.rotate!\n    arr.reverse!\n\
    \    arr\nend\n</code>\n<|/ a tags=ruby,arrays,sorting |>\n<| a |>\nHere's a little\
    \ gem to do this for you: reverse_array. From the docs:\n<code>\n>> a = ['Bob',\
    \ 'Jack', 'Bob', 'Jack']\n>> reverse_array(a)\n=> [\"Jack\", \"Jack\", \"Bob\"\
    , \"Bob\"]\n</code>\n<|/ a dscore=4 tags=ruby,arrays,sorting |>\n<| c |>\n`reverse_array`\
    \ will work on the array you pass to it, so `a = ['Bob', 'Jack', 'Bob', 'Jack'];\
    \ reverse_array(a).reverse`\n<|/ c |>\n<| a dscore=2 tags=ruby,arrays,sorting\
    \ |>\nTo get the desired output try this:\n<code>\na = [1,4,2,8,9,12,6,3,15,5,7]\n\
    a.map {|x|\n  x.to_s.split(//).map {|y|\n    y.to_i\n  }\n}.transpose\n</code>\n\
    <|/ a |>\n<| a |>\nHere you go:\n<code>\na = [1,4,2,8,9,12,6,3,15,5,7]", "  arr.sort_by\
    \ { |x| x.to_s.length }.reverse!\n  arr.map { |x| x[1..-1].to_i }.compact!\nend\n\
    </code>\nThis works for arrays with any length of positive integers, except when\
    \ they contain zero or negative numbers or the strings \"One\", \"Two\", \"Three\"\
    , \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", which should be\
    \ treated as zero. I've included this case in my original code snippet to highlight\
    \ that you can simply use map! to reverse the array in place.\n<|/ a dscore=5\
    \ |>\n<| c |>\n`Array` does not have a `sort` method, and it doesn't seem to have\
    \ `sort_by` either.\n<|/ c |>\n<| c |>\nThis answer could be enhanced with explanations\
    \ of what each operation does\n<|/ c |>\n<| c |>\nGreat answer. Thank you so much\
    \ for taking the time to explain this in detail.\n<|/ c |>\n<| c |>\nI love the\
    \ way you worded the explanation, thank you!\n<|/ c |>\n<| c |>\nVery elegant!\
    \ Very easy to understand! I was about to make a custom sorting function with\
    \ my own custom logic. Nice. +1\n<|/ c |>\n<| a |>\nA more readable way to reverse\
    \ and sort is to use sort_by method with the block:\n<code>\nnumbers.sort_by {\
    \ |n| -n }\n</code>\n<|/ a dscore=5 tags=sorting,ruby,reverse,arrays |>\n<| c\
    \ |>\nI used this as a sorting function for a hash which had string keys, but\
    \ sorted the keys alphabetically. `hash = {\"a\" => 1, \"c\" => 3, \"b\" => 2}`\n\
    <|/ c |>\n<| c |>\nI like this solution because it's self-documenting. I think\
    \ it's also much more efficient, since it avoids creating an extra temporary array.\n\
    <|/ c |>\n<| c |>\nThis should be the best answer! It's more readable than other\
    \ answers. You can even use `.reverse!` on the block before sorting, to reverse\
    \ the array!\n<|/ c |>\n<| c |>\nThis is great because in Ruby 2.1.2, the block\
    \ is evaluated for sort, but not in reverse.  This is very useful in creating\
    \ an array with values from a hash of hashes.\n<|/ c |>\n<| c |>\nGood answer,\
    \ but what if I want to reverse and sort by two different attributes, say, alphabetically\
    \ by `a` but reverse ", "  return arr.sort do |a, b|\n    return a < b ? -1 :\
    \ a == b ? 0 : 1 # Ignore strange number\n  end.reverse.map do |n|\n    return\
    \ n if n.between?(1, 9)\n    \"One\" if n == 1\n    \"Two\" if n == 2\n    \"\
    Three\" if n == 3\n    \"Four\" if n == 4\n    \"Five\" if n == 5\n    \"Six\"\
    \ if n == 6\n    \"Seven\" if n == 7\n    \"Eight\" if n == 8\n    \"Nine\" if\
    \ n == 9\n    n\n  end\nend", "  arr.sort_by {|x| [x > 9 ? 9 - x : x, x]}.reverse.collect\
    \ {|x| x > 9 ? \"One\" : \"Two\"} + arr.collect {|x| x > 9 ? \"Three\" : \"Four\"\
    } + arr.collect {|x| x > 9 ? \"Five\" : \"Six\"} + arr.collect {|x| x > 9 ? \"\
    Seven\" : \"Eight\"} + arr.collect {|x| x > 9 ? \"Nine\" : \"Ten\"}\nend", " \
    \ unless arr.empty?\n    return arr.reject { |x| x <= 0 || x >= 10 }.sort_by {\
    \ |x| x.to_s.length }.map{ |x| by_length_mapping[x] }\n  end\n  []\nend", "  return\
    \ arr.reduce(:<<<, []).sort { |a,b| b <=> a }.reverse.map { |i| i.to_s.upcase\
    \ }\nend", "  arr.sort!\n  arr.map! {|x| x.to_s.split('').map{|c| [\"One\", \"\
    Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\
    ].index(c) ? c : nil}.compact.join('')}\n  arr.compact!\n  arr.compact!(&:empty?)\n\
    \  arr\nend", "  if arr.empty?\n    []\n  else\n    (arr.map {|i| i if i.between?(1,\
    \ 9)}.sort {|x, y| y <=> x}.map {|i| \n      [\"One\", \"Two\", \"Three\", \"\
    Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"][i] }) \n  end\nend",
  "  arr.sort {|a,b| a <=> b }.reverse\n  arr.map { |i| DIGITS[i]  ||= nil }\n  arr\n\
    end\n</code>\n<|/ a |>\n<| a dscore=2 tags=ruby |>\nI took Rob's code and added\
    \ some comments so it could be used for multiple arrays:\n<code>", "  return arr\
    \ unless arr.size == arr.select {|x| x.is_a?(Integer) && x >= 1 && x <= 9}\n \
    \ arr.sort.reverse\n  arr.map {|x| [\"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"][x]}\nend", "  return arr.sort{|a,\
    \ b| a <=> b} if arr.size > 0\n  return []\nend", "  if arr.empty?\n    []\n \
    \ else\n    arr.sort.reverse_each.with_index do |element, index|\n      arr[index]\
    \ = name_for(element)\n    end\n  end\nend\n</code>\n<|/ a tags=ruby,arrays |>\n\
    <| a tags=ruby,arrays |>\n<code>\nones = arr.select { |e| e == 1 }\ntens = arr.select\
    \ { |e| e >= 10 }\nones_and_tens = ones + tens\nones_and_tens.sort.reverse_each\n\
    </code>\n<|/ a dscore=2 |>\n<| a |>\nAnother one:\n<code>", "  arr.map { |e| e\
    \ if e <= 9 || e > 100 ? \"One\".dup : e.to_s.reverse }.compact\nend", "  arr.compact.sort\
    \ {|x,y| x <=> y}.dup.map {|x| x >= 1 && x <= 9 ? NAME_TO_ONE[x] : x}\nend", " \
    \ arr.sort!\n  result = []\n  result.reverse if arr.length > 0\n  arr.each { |e|\
    \ result << by_length(e).first }\n  result\nend\n</code>\n<|/ a |>\n<| c |>\n\
    The code is nice but I think it does some extra work because you sort and then\
    \ sort again. Also, `sort!` is usually a bad practice because it will change the\
    \ original array and hence `by_length.call([2, 1, 1, 4, 5, 8, 2, 3])` will return\
    \ `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]`, while it should be `[\"Eight\", \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Nine\"]`.\n<|/ c |>\n<| c |>\nI agree with you,\
    \ thanks for your comment. Do you think I should edit the answer or you think\
    \ it would be better to keep the answer?\n<|/ c |>\n<| c |>\nIt would be better\
    \ to keep the answer. I didn't want to delete it because it may still be useful\
    \ for somebody else in the future.\n<|/ c |>\n<| c |>\n: Thanks for your comment\
    \ and I agree that `sort!` would change the original array and I changed it to\
    \ `sort` which doesn't change the original array. Also the original array is not\
    \ modified; only the result array is changed.\n<|/ c |>\n<| a |>\n<code>", " \
    \ arr.sort!\n  result = []\n  arr.each_with_index do |number, index|\n    result\
    \ << [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"\
    Eight\", \"Nine\"][number]\n  end\n  result.reverse_each do |digit|\n    arr.delete(digit)\n\
    \  end\n  arr\nend", "  arr.sort { |a, b| a.to_i < b.to_i ? -1 : a.to_i > b.to_i\
    \ ? 1 : a <=> b }\n  arr.uniq.map { |x| x.to_s.split('').map { |y| y == '9' ?\
    \ 0 : y }.join }\nend", "  arr.sort!\n  arr.select! do |d|\n    (1..9).include?(d)\n\
    \  end\n  arr.select! do |d|\n    d >= 0 && d <= 9\n  end\n  arr.reverse!\n  arr.map!\
    \ do |d|\n    d.to_s\n  end\nend", "  arr.each do |item|\n    if item > 9\n  \
    \    arr.remove(item)\n      arr.unshift(item % 10)\n      arr.remove(item % 10)\n\
    \    end\n  end\n  arr\nend", "  arr.sort.each do |i|\n    break if i > 9\n  \
    \  arr[i] = \"One\" if i == 1\n    arr[i] = \"Two\" if i == 2\n    arr[i] = \"\
    Three\" if i == 3\n    arr[i] = \"Four\" if i == 4\n    arr[i] = \"Five\" if i\
    \ == 5\n    arr[i] = \"Six\" if i == 6\n    arr[i] = \"Seven\" if i == 7\n   \
    \ arr[i] = \"Eight\" if i == 8\n    arr[i] = \"Nine\" if i == 9\n  end\n  arr\n\
    end\n</code>\nThis is my solution:\n<code>", "  arr.each {|i| arr[i] = [\"One\"\
    , \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\
    ][arr[i]]}\n  arr.reverse if arr != [\"\"]\n  arr\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nThis doesn't answer the question, which was about getting `'One',\
    \ 'Two', ...`\n<|/ c |>\n<| c |>\nYeah, this answer does exactly what the question\
    \ asked. The question asked \"Given an array of integers, sort them in the order\
    \ [one, two, three, four, five, six, seven, eight, nine]\". The answer gives the\
    \ sort order. `'One'` is obviously the correct answer.\n<|/ c |>\n<| c |>\nThis\
    \ answer is not working for me in Ruby 2.3.3\n<|/ c |>\n<| c |>\nI wrote that\
    \ answer in 2013, but I'm pretty sure that I've seen this work on Ruby 2.1 or\
    \ 2.2. I don't have Ruby 2.3 installed and can't test it right now.\n<|/ c |>\n\
    <| c |>\nI see your point. I was just pointing out that there were some things\
    \ in your answer that might not be true in a newer version of Ruby.\n<|/ c |>\n\
    <| a tags=ruby |>\n<code>", "  return arr.reverse.each_with_object([]) { |num,\
    \ result|\n    if num.is_a? Integer\n      if num > 0 && num < 10\n        result\
    \ << names_by_number[num]\n      else\n        result << num.to_s\n      end\n\
    \    end\n  }.compact\nend", "  arr.map!{ |x| x >= 1 && x <= 9 ? by_length((x\
    \ - 1).to_s) : \"#{by_length(x)}\" }\n  if arr.empty?\n    []\n  elsif arr.length\
    \ == 1\n    arr.first\n  else\n    arr.reverse.first\n  end\nend", "  # sort the\
    \ array and reverse the order of the list\n  sorted_arr = arr.sort\n  sorted_arr.reverse",
  "  arr.sort!\n  arr.reverse!\n  arr.map! do |x|\n    if x.is_a? Integer\n      one\
    \ = \"One\"\n      two = \"Two\"\n      three = \"Three\"\n      four = \"Four\"\
    \n      five = \"Five\"\n      six = \"Six\"\n      seven = \"Seven\"\n      eight\
    \ = \"Eight\"\n      nine = \"Nine\"\n      if x <= 9\n        one\n      elsif\
    \ x > 9 && x <= 18\n        two\n      elsif x > 18 && x <= 27\n        three\n\
    \      elsif x > 27 && x <= 36\n        four\n      elsif x > 36 && x <= 45\n\
    \        five\n      elsif x > 45 && x <= 54\n        six\n      elsif x > 54\
    \ && x <= 63\n        seven\n      elsif x > 63 && x <= 72\n        eight\n  \
    \    elsif x > 72 && x <= 90\n        nine\n      else\n        \"Other\"\n  \
    \    end\n    else\n      x\n    end\n  end\n  arr\nend\n</code>\n<|/ a |>\n<|\
    \ c |>\nGood answer, but I think using `case` for such a simple comparison is\
    \ a bit overkill. `case x` will do just fine.\n<|/ c |>\n<| c |>\nYeah, I agree\
    \ about case expressions, it's more readable this way. Thanks for pointing that\
    \ out.\n<|/ c |>\n<| a |>\n<code>", "  arr.sort! { |a, b| a <=> b }\n  arr.map\
    \ {|n| [n < 10 ? \"One\" : \"Two\" ... \"Nine\"][n - 1] }\nend\n</code>\n<|/ a\
    \ |>\n<| a |>\n<code>", "  arr = arr.to_a\n  if arr.empty?\n    []\n  else\n \
    \   arr.sort! {|x, y| x - y }\n    len = arr.map {|x| x.to_s.length}.max\n   \
    \ arr.map {|x| x if x.to_s.length == len }.map {|x| x.to_s + \"\\n\" + by_length.call(x[1..-1])}.flatten\n\
    \  end\nend", "  return arr.reverse.map{|x| [ \"One\", \"Two\", \"Three\", \"\
    Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", x].include?(x)? \"\
    #{x}\": \"NaN\"}.compact\nend", '  return arr if arr.length > 0 else []', "  arr.sort_by{|x|\
    \ x.to_i}.reverse\nend", "  arr.sort!\n  arr.empty? ? [] : arr.map do |number|\n\
    \    number > 9 ? number - 10 : number\n  end.map(&:to_s).reverse\nend", "  arr.sort\
    \ { |a, b| a <=> b }\n  arr.empty? ? [] : arr.map! { |i| [\"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"][i] }\nend",
  "  return arr.sort{ |a,b| b.length<a.length ? -1 : b.length<a.length ? 1 : 0 }.map(&:to_s)\
    \ unless arr.empty?\n  []\nend", "  if arr.length == 0 then return [] else arr\n\
    \  arr.reverse\n  arr.each do |x|\n    if x <= 9 then arr[arr.length - x - 1]\
    \ = \"One\"\n    elsif x <= 99 then arr[arr.length - x - 1] = \"Two\"\n    elsif\
    \ x <= 999 then arr[arr.length - x - 1] = \"Three\"\n    elsif x <= 9999 then\
    \ arr[arr.length - x - 1] = \"Four\"\n    elsif x <= 9999999 then arr[arr.length\
    \ - x - 1] = \"Five\"\n    elsif x <= 999999999 then arr[arr.length - x - 1] =\
    \ \"Six\"\n    elsif x <= 99999999999 then arr[arr.length - x - 1] = \"Seven\"\
    \n    elsif x <= 999999999 then arr[arr.length - x - 1] = \"Eight\"\n    elsif\
    \ x <= 99999999999 then arr[arr.length - x - 1] = \"Nine\"\n    elsif x <= 99999999999\
    \ then arr[arr.length - x - 1] = \"Ten\"\n    else return [] end\n  end\n  arr.reverse\n\
    \  arr\nend\n</code>\n<|/ a |>\n<| a tags=ruby,arrays |>\n<code>", "  arr.sort_by!\
    \ { |i| i } # sort the elements by their value\n  arr.empty? ? [] : arr.map {\
    \ |e| lookup[e] }.compact.to_a # reverse the array, \n                       \
    \                                     # then replace each element by its \n  \
    \                                                          # corresponding name\
    \ from the list\nend\n</code>\nThe same idea can be applied for any other sorting\
    \ criteria as well. Let's apply it to a more interesting example:\n<code>", " \
    \ arr.uniq.sort_by { |e| [e, 9 - e] }.reverse.map { |e| one_digit[e] }\nend",
  "  arr.sort!\n  return arr.sort{|a, b| a <=> b}.reverse.replace \"One\", \"One\"\
    ..\"Nine\"\nend", "  return [] if arr.empty?\n  arr.sort { |a,b| b.to_s.length\
    \ <=> a.to_s.length }\n  arr.reverse!.map { |x| by_length.call(x[0]).join('')\
    \ }\nend", "  arr.sort.map do |x|\n    if x < 0 || x > 9\n      nil\n    else\n\
    \      [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"\
    Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\"\
    , \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"][x - 1]\n\
    \    end\n  end.reverse\nend\n</code>\n<|/ a tags=ruby,arrays,sorting |>\n<| c\
    \ |>\nI like this one, although it makes the code harder to read. Also, Ruby has\
    \ a tendency to throw a NoMethodError exception when calling an undefined method,\
    \ so be careful when calling it. You might want to change the last line to `arr.reverse.map\
    \ do |x|`\n<|/ c |>\n<| c |>\nThis won't work if there are any numbers *outside*\
    \ the range of 1-9 in that array. For example, try `by_length.call([0, 10, 20])`.\n\
    <|/ c |>\n<| a tags=ruby,arrays,sorting dscore=2 |>\n<code>\narr = [1, 11, 2,\
    \ 3, 20, 4, 10, 5, 8, 6, 19, 7, 9, 3, 1]", "  arr.each do |num|\n    num > 9 ?\
    \ arr.remove(num - 10) : arr.remove(1)\n  end\n  arr.push(arr.last)\n  arr.map!\
    \ { |num| \"One\"[num % 10] }\n  arr.reverse\nend\n</code>\n<|/ a |>\n<| c |>\n\
    This is clever and works, but I would consider it a hack and definitely not something\
    \ I'd advocate for readability.  It doesn't scale well to larger arrays where\
    \ the length of each slice needs to be determined at runtime.\n<|/ c |>\n<| c\
    \ |>\nI agree. My answer was very specific to the original problem and did not\
    \ mention the scale of the solution. My answer would probably not be used in production\
    \ code. The code I provided would probably be more scalable if the length of the\
    \ array was determined at runtime and there was a method that returned a range\
    \ of the array.\n<|/ c |>\n<| c |>\nThis code is more scalable than the one posted\
    \ in the answer. I'm pretty sure this won't be used in production code as is.\
    \ I'm just providing code here to help understand how it works. I agree this isn't\
    \ a very good solution.\n<|/ c |>\n<| c |>\nAgreed.  It's also a bad solution,\
    \ but I wouldn't object to its existence as a solution to the original question.\n\
    <|/ c |>\n<| a |>\nOk, I'm going to go ahead and suggest some changes:\n<code>",
  "  arr.sort { |a, b| b - a }.reverse.map { |x| by_length.name(x.to_i) }\nend", " \
    \ if arr.empty?\n    []\n  elsif arr.any?\n    arr.sort.reverse\n    arr.map!\
    \ do |x|\n      if x % 10 == 1\n        \"One\"\n      elsif x % 10 == 2\n   \
    \     \"Two\"\n      elsif x % 10 == 3\n        \"Three\"\n      elsif x % 10\
    \ == 4\n        \"Four\"\n      elsif x % 10 == 5\n        \"Five\"\n      elsif\
    \ x % 10 == 6\n        \"Six\"\n      elsif x % 10 == 7\n        \"Seven\"\n \
    \     elsif x % 10 == 8\n        \"Eight\"\n      elsif x % 10 == 9\n        \"\
    Nine\"\n      else\n        \"\"\n      end\n    end\n    arr\n  end\nend", " \
    \ return arr.sort.reverse.map do |x|\n    if x > 0\n      by_length.call([x])\n\
    \    else\n      \"Nine\"\n    end\n  end\nend", "  arr.sort do |a, b|\n    a\
    \ <=> b\n  end\n  arr.map!{|x| numbers[x.to_i] || x}\nend", "  arr.compact.sort.each\
    \ { |x| break x if x < 10 } # Sort the array\n  arr.compact.map { |x| to_name(x)\
    \ } # Reverse the array and replace each element with the name\nend", "  return\
    \ arr.select do |number|\n    number >= 1 && number <= 9\n  end.reverse.select\
    \ do |number|\n    by_lengths.has_key?(number)\n  end\nend", "  result = []\n\
    \  arr.each do |i|\n    i += 1 while i < 10\n    result[i] = \"One\" if i == 1\n\
    \    result[i] = \"Two\" if i == 2\n    result[i] = \"Three\" if i == 3\n    result[i]\
    \ = \"Four\" if i == 4\n    result[i] = \"Five\" if i == 5\n    result[i] = \"\
    Six\" if i == 6\n    result[i] = \"Seven\" if i == 7\n    result[i] = \"Eight\"\
    \ if i == 8\n    result[i] = \"Nine\" if i == 9\n  end\n  result.reverse\nend",
  "  return arr.map {|n| n < 10 ? [\"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\"][n - 1] : [n % 10, n % 10 == 1 ? nil\
    \ : (n % 10 < 4 ? [\"One\", \"Two\"][n % 10] : [\"Four\", \"Five\", \"Six\", \"\
    Seven\"][n % 10 - 4])]}\nend", "  arr.sort { |x, y| x.to_i <=> y.to_i }.reverse\n\
    \  if arr.empty?\n    []\n  elsif arr.any? { |x| x.to_i == 0 || x.to_i < 1 }\n\
    \    []\n  else\n    arr.map do |x| name(x).downcase rescue nil end.compact\n\
    \  end\nend", "  arr.map do |n|\n    case n\n    when 1..9\n      \"One\"\n  \
    \  when 10..19\n      \"Two\"\n    when 20..29\n      \"Three\"\n    when 30..39\n\
    \      \"Four\"\n    when 40..49\n      \"Five\"\n    when 50..59\n      \"Six\"\
    \n    when 60..69\n      \"Seven\"\n    when 70..79\n      \"Eight\"\n    when\
    \ 80..89\n      \"Nine\"\n    when 90..99\n      \"Ten\"\n    else\n      n\n\
    \    end\n  end.sort\nend", "  sorted_array = arr.sort\n  result = Array.new\n\
    \  length = arr.length\n  i = 0\n  while i < length\n    if sorted_array[i] ==\
    \ 1\n      result << :One\n    elsif sorted_array[i] == 2\n      result << :Two\n\
    \    elsif sorted_array[i] == 3\n      result << :Three\n    elsif sorted_array[i]\
    \ == 4\n      result << :Four\n    elsif sorted_array[i] == 5\n      result <<\
    \ :Five\n    elsif sorted_array[i] == 6\n      result << :Six\n    elsif sorted_array[i]\
    \ == 7\n      result << :Seven\n    elsif sorted_array[i] == 8\n      result <<\
    \ :Eight\n    elsif sorted_array[i] == 9\n      result << :Nine\n    else\n  \
    \    result << :Unknown\n    end\n    i += 1\n  end\n  result\nend", "  return\
    \ arr.sort do |a,b|\n    length_a = a.length\n    length_b = b.length\n    length_a\
    \ = (length_a == 0) || (length_a < 9) ? 1 : (length_a > 9) ? 9 : length_a\n  \
    \  length_b = (length_b == 0) || (length_b < 9) ? 1 : (length_b > 9) ? 9 : length_b\n\
    \    length_a - length_b\n  end.reverse.map { |digit, name| name if digit == length_a\
    \ }\nend", "  return arr.reverse if arr.count > 1 \n  return [] if arr.empty?\
    \ \n  arr.reverse_each do |i| \n    arr = arr + [\"One\", \"Two\", \"Three\",\
    \ \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"][i.to_s]\n  end\n\
    \  arr\nend\n</code>\n<|/ a tags=sorting,arrays,ruby dscore=0 |>\n<| c |>\nThis\
    \ solution takes O(nlogn) time. My solution has O(n).\n<|/ c |>\n<| c |>\nWhy\
    \ is that so? Do you have any source?\n<|/ c |>\n<| c |>\nYes. You can read it\
    \ here: http://www.amonsdesign.com/2011/01/how-to-sort-an-array-by-length-in-one-pass/\
    \ . I am not aware of a better solution.\n<|/ c |>\n<| c |>\n: This solution takes\
    \ O(n) time. You are just making a more complicated sorting method when there\
    \ are better methods that are O(n).\n<|/ c |>\n<| c |>\nThat link is great, thanks!\
    \ (I thought it was a nice algorithm, but I don't like that solution since it\
    \ uses more memory.)\n<|/ c |>\n<| a |>\nUsing Enumerable#sort:\n<code>", "  arr.sort.reverse_each\
    \ do |i|\n    puts \"One if i==1, Two if i==2, Three if i==3, Four if i==4, Five\
    \ if i==5, Six if i==6, Seven if i==7, Eight if i==8, Nine if i==9\"\n    if i==1\n\
    \      puts \"One if the number is 1, Two if the number is 2\"\n    end\n  end\n\
    end\nby_length.call([2, 1, 1, 4, 5, 8, 2, 3])\nby_length.call([-9, -4, -2, 1,\
    \ 4, 5])\nby_length.call([])\nby_length.call([1, -1, 55])", "  arr.flatten.sort!.reverse\n\
    \  arr.flatten.map {|x| return \"One\" if x == 1; return \"Two\" if x == 2; return\
    \ \"Three\" if x == 3; return \"Four\" if x == 4;\n    return \"Five\" if x ==\
    \ 5; return \"Six\" if x == 6; return \"Seven\" if x == 7; return \"Eight\" if\
    \ x == 8; return \"Nine\" if x == 9; return \"Ten\"; \n  }\nend", "  arr.sort!\n\
    \  arr.reverse!\n  arr.map!(&:to_s.to_i)\n  arr.each do |el|\n    arr[el] = One.name\
    \ if el > 9\n    arr[el] = Two.name if el > 8\n    arr[el] = Three.name if el\
    \ > 7\n    arr[el] = Four.name if el > 6\n    arr[el] = Five.name if el > 5\n\
    \    arr[el] = Six.name if el > 4\n    arr[el] = Seven.name if el > 3\n    arr[el]\
    \ = Eight.name if el > 2\n    arr[el] = Nine.name if el > 1\n  end\n  arr\nend",
  "  arr.sort.reverse_each.with_index { |(el, i)| el if i >= 1 && i <= 9 }.map {|i|\
    \ i == \"One\" ? \"One\" :\n    i == \"Two\" ? \"Two\" :\n    i == \"Three\" ?\
    \ \"Three\" :\n    i == \"Four\" ? \"Four\" :\n    i == \"Five\" ? \"Five\" :\n\
    \    i == \"Six\" ? \"Six\" :\n    i == \"Seven\" ? \"Seven\" :\n    i == \"Eight\"\
    \ ? \"Eight\" :\n    i == \"Nine\" ? \"Nine\" : i}\nend", "  if arr.size == 0\n\
    \    return []\n  arr = arr.sort\n  names = [\"One\", \"Two\", \"Three\", \"Four\"\
    , \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n  arr.size.times do |i|\n\
    \    arr[i] = names[arr.size - i - 1] if i >= 1 and i < 9\n  end\n  arr.reverse!\n\
    \  arr.collect!{|x| x % 10 == 0 ? names[x] : x}\n  return arr\nend", "  arr ||=\
    \ []\n  arr.each_with_index { |e,i| arr[i] = \"One\" if i == 0 || e <= 9 && e\
    \ > 0 }\n  arr.reverse\n  arr.map { |e| NAME_LOOKUP[e] }\nend", "  result = []\n\
    \  arr.each do |x|\n    next if x < 1 || x > 9\n    result << num2name[x]\n  end\n\
    \  result.reverse\n  result\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby dscore=1\
    \ |>\nHere is one way to do it, although it's not a particularly good one, just\
    \ demonstrating the process:\n<code>", "  # initialize result array\n  res = []\n\
    \  # check array\n  if arr.length == 0\n    res\n  else\n    # reverse array\n\
    \    arr = reverse(arr)\n    # set initial result\n    i = 0\n    while i < arr.length\n\
    \      # get current digit\n      d = arr[i]\n      # check whether is between\
    \ 1 and 9\n      if d >= 1 && d <= 9\n        # reverse digit\n        arr[i]\
    \ = 9 - d\n        # replace digit by its name from One, Two, Three, Four, Five,\
    \ Six, Seven, Eight, Nine\n        res.push(names[d - 1])\n      end\n      #\
    \ increment i\n      i += 1\n    end\n    # reverse array again\n    arr = reverse(arr)\n\
    \    # return result\n    res\n  end\nend", '  return arr.empty? ? [] : arr.sort.reverse
    - "One" - "Two" - "Three" - "Four" - "Five" - "Six" - "Seven" - "Eight" - "Nine"',
  "  # Make sure arr is a list\n  arr = [arr] if arr.kind_of?(Array) \n  return arr.sort.reverse.map\
    \ { |n| n = (1..9).map { |i| \"One\".to_sym if i.to_i < n; \"Two\".to_sym if i.to_i\
    \ < n; \"Three\".to_sym if i.to_i < n; \"Four\".to_sym if i.to_i < n; \"Five\"\
    .to_sym if i.to_i < n; \"Six\".to_sym if i.to_i < n; \"Seven\".to_sym if i.to_i\
    \ < n; \"Eight\".to_sym if i.to_i < n; \"Nine\".to_sym if i.to_i < n }; n[arr.index(n)]\
    \ || n.to_s }\nend\n</code>\nIt is a bit long, but basically it works as follows:\
    \ First, we call #sort to sort the array of numbers, and then we call #reverse\
    \ on that, to reverse the order, thus obtaining the longest values first (if we're\
    \ working with numbers, obviously it makes no difference in the end as long as\
    \ all the numbers are >= 1). Then, we loop over the sorted array, and map it to\
    \ a list of strings depending if its value is < 10, or if its in range.\n<|/ a\
    \ tags=arrays,sorting,ruby |>\n<| c |>\n`if i.to_i < n` is unnecessary because\
    \ the numbers are already in order. This can be simplified to a single `i` condition.\n\
    <|/ c |>\n<| c |>\nThat's a very good point, thanks. I added your suggestion in\
    \ my edit.\n<|/ c |>\n<| c |>\nI believe `sort_by` would be a better solution,\
    \ but that requires a more complex comparison function than is provided by the\
    \ OP.\n<|/ c |>\n<| a dscore=0 tags=arrays,sorting,ruby |>\n<code>", "  return\
    \ [] if arr.empty?\n  arr.sort_by{ |x| -x }.map(&:first)\nend", "  arr.sort\n\
    \  arr.uniq\n  arr.sort.reverse\n  arr.map { |x| x.to_s.downcase }\nend", "  return\
    \ arr if arr.size <= 9 else arr.sort{ |a, b| b - a }.reverse.map{ |n| ns[n.to_i]\
    \ }\nend", "  # Sort the array from the biggest to the smallest number\n  # Then\
    \ reverse the array\n  sorted = arr.sort { |a, b| b - a }\n  sorted.reverse",
  "  return [] unless arr\n  arr.sort_by {|x| x.to_i}.map {|x| x.to_s}.sort.reverse.map\
    \ {|x| x == \"One\" ? \"One\" : x}\nend", "  arr.each do |e|\n    arr[arr.index(e)\
    \ + 1..-1].each do |i|\n      arr[i] = \"One\" if i <= 9\n      arr[i] = \"Two\"\
    \ if i <= 99\n      arr[i] = \"Three\" if i <= 999\n      arr[i] = \"Four\" if\
    \ i <= 9999\n      arr[i] = \"Five\" if i <= 99999\n      arr[i] = \"Six\" if\
    \ i <= 999999\n      arr[i] = \"Seven\" if i <= 9999999\n      arr[i] = \"Eight\"\
    \ if i <= 999999999\n      arr[i] = \"Nine\" if i <= 99999999999\n    end\n  end\n\
    \  arr\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
