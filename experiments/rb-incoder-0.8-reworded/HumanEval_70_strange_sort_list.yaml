name: HumanEval_70_strange_sort_list
language: rb
prompt: "# Given array of integers, return array in strange order.\n# Strange sorting,\
  \ is when you start with the minimum value,\n# then maximum of the remaining integers,\
  \ then minimum and so on.\n# Examples:\n# >>> strange_sort_list.call([1, 2, 3, 4])\n\
  # [1, 4, 2, 3]\n# >>> strange_sort_list.call([5, 5, 5, 5])\n# [5, 5, 5, 5]\n# >>>\
  \ strange_sort_list.call([])\n# []\ndef strange_sort_list(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_strange_sort_list\n\
  \    candidate = method(:strange_sort_list)\n    assert_equal([1, 4, 2, 3], candidate.call([1,\
  \ 2, 3, 4]))\n    assert_equal([5, 9, 6, 8, 7], candidate.call([5, 6, 7, 8, 9]))\n\
  \    assert_equal([1, 5, 2, 4, 3], candidate.call([1, 2, 3, 4, 5]))\n    assert_equal([1,\
  \ 9, 5, 8, 6, 7], candidate.call([5, 6, 7, 8, 9, 1]))\n    assert_equal([5, 5, 5,\
  \ 5], candidate.call([5, 5, 5, 5]))\n    assert_equal([], candidate.call([]))\n\
  \    assert_equal([1, 8, 2, 7, 3, 6, 4, 5], candidate.call([1, 2, 3, 4, 5, 6, 7,\
  \ 8]))\n    assert_equal([-5, 5, -5, 5, 0, 2, 2, 2], candidate.call([0, 2, 2, 2,\
  \ 5, 5, -5, -5]))\n    assert_equal([111111], candidate.call([111111]))\n  end\n\
  end\n"
completions: ["    return lst + lst.reverse\nend\n</code>\n<|/ a dscore=3 |>\n<| c\
    \ |>\nJust to clarify, this is my solution, right?\n<|/ c |>\n<| c |>\n: nope.\
    \ it's my solution for that particular problem.\n<|/ c |>\n<| c |>\nYes, and it's\
    \ very easy to read and understand. And it works in O(n).\n<|/ c |>\n<| a tags=algorithm,ruby\
    \ |>\nIf you can guarantee that the input is sorted, you can just use an O(n)\
    \ algorithm that runs in O(log n) time. Just pick the last number in the array\
    \ and add it to the beginning of the array. Then loop through the array and swap\
    \ each item with the number you picked. This takes time O(n log n). This is because\
    \ the number of swaps needed is O(log n) for the whole algorithm to finish.\n\
    <|/ a dscore=2 |>\n<| c |>\nYour O(n) algorithm requires extra space for `pivot`\
    \ (you never actually use it), but it's still very efficient :)\n<|/ c |>\n<|\
    \ c |>\nOops, sorry, I got my variables backwards. Fixed now\n<|/ c |>\n<| c |>\n\
    You don't actually need the pivot, just the last element in the array is the pivot.\
    \ I think this is better than the accepted answer.\n<|/ c |>\n<| c |>\nThe OP\
    \ says that there will never be repeated elements in the list. Your algorithm\
    \ still requires O(n) extra space for the pivot if you don't use a pivot, and\
    \ you still have a running time of O(n log n).\n<|/ c |>\n<| c |>\nAh yeah, I\
    \ didn't think of that. Thanks!\n<|/ c |>\n<| a dscore=1 |>\nIn Python you can\
    \ do the following:\n<code>", "  # Your code here\n  # raise NotImplementedError\n\
    \  sorted_list = lst.sort do |a,b|\n    # Your code here\n    # raise NotImplementedError\n\
    \  end\n  # Your code here\n  # raise NotImplementedError\n  return sorted_list\n\
    end", "    sorted = []\n    sorted.push(lst[0])\n    for num in lst[0..-1]\n \
    \       sorted.push(num) if num < sorted[-1]\n    end\n    sorted\nend", "  strange_sort_list\
    \ ||= []\n  return sort_list(lst, strange_sort_list.dup)\nend", "  return lst.sort.reverse\n\
    end", "  lst.sort!\n  return lst\nend", "  return lst.sort{|a, b| b <=> a}\nend\n\
    </code>\n<|/ a dscore=4 tags=sorting,ruby,ruby-on-rails,arrays,algorithm |>\n\
    <| c |>\nHow is this different from my answer?\n<|/ c |>\n<| a tags=sorting,ruby,ruby-on-rails,arrays,algorithm\
    \ dscore=4 |>\n<code>\narr.sort_by{|a| -a}.reverse\n</code>\nWorks in ruby version\
    \ >= 2.1.0\n<|/ a |>\n<| c |>\nThis is a very good answer that works. But this\
    \ only works in ruby version >= 2.1.0\n<|/ c |>\n<| a |>\nAs the array size is\
    \ huge, we can use a sort with little effort as:\n<code>\narr = [9, 5, 7, 3, 12,\
    \ 5, 9, 4, 2, 9, 0, 4, 3, 5, 7, 8, 6, 10, 13, 2, 5, 7, 7, 5, 9, 5, 8, 10, 7, 5,\
    \ 12, 8, 6, 9, 4, 2, 5, 6, 9, 7, 8, 7, 8, 10, 5, 8, 8, 3, 7, 5, 6, 10, 0, 8, 4,\
    \ 2, 9, 10, 4, 2, 7, 7, 5, 7, 8, 4, 10, 9, 7, 7, 8, 13, 9, 7, 8, 10, 7, 5, 6,\
    \ 8, 6, 3, 8, 5, 6, 8, 5, 2, 7, 7, 4, 9, 10, 11, 2, 9, 10, 9, 7, 9, 11, 4, 9,\
    \ 10, 8, 5, 7, 11, 9, 7, 8, 6, 8, 9, 6, 8, 2, 7, 8, 10, 11, 5, 7, 9, 6, 8, 10,\
    \ 8, 10, 7, 8, 8, 7, 8, 11, 9, 7, 8, 5, 11, 7, 8, 7, 8, 10, 10, 9, 10, 7, 8, 4,\
    \ 6, 4, 10, 6, 8, 8, 7, 7, 8, 4, 8, 8, 11, 6, 8, 9, 4, 8, 7, 4, 7, 7, 11, 6, 8,\
    \ 8, 8, 4, 9, 4, 7, 9, 8, 7, 11, 7, 4, 6, 8, 8, 10, 10, 8, 8, 8, 7, 8, 8, 10,\
    \ 7, 8, 7, 8, 7, 11, 9, 7, 11, 4, 7, 8, 8, 10, 9, 7, 8, 7, 8, 8, 6, 9, 10, 7,\
    \ 8, 8, 8, 5, 7, 8, 8, 8, 8, 11, 7, 11, 9, 7, 11, 7, 11, 7, 7, 7, 8, 7, 8, 8,\
    \ 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 8,\
    \ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\
    \ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\
    \ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, ", " \
    \ lst.sort\nend", "  if lst.size <= 1\n    lst\n  else\n    min = lst.min\n  \
    \  rest = lst.drop(min)\n    [min, *strange_sort_list(rest)].concat rest\n  end\n\
    end\n</code>\n<|/ a |>\n<| a |>\n<code>", "  lst.sort { |a, b| a <=> b }\nend\n\
    </code>\n<|/ a |>\n<| c |>\nThank you! I have used the above to make a slight\
    \ variation that seems to work well. \n \n    def strange_sort_list(lst)\n   \
    \   lst.sort { |a, b| b <=> a }\n    end\n<|/ c |>\n<| c |>\nYou are welcome.\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>", "  sorted = []\n  sorted.push(lst[0])\n \
    \ sorted.push(lst[lst.length-1])\n  (1..lst.length-1).each do |i|\n    sorted.push(lst[i])\n\
    \    sorted.push(lst[sorted.length-1])\n  end\n  sorted\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| a tags=ruby dscore=1 |>\nFor someone who does not know what a range,\
    \ and is trying to learn loops and conditional loops, I thought I would offer\
    \ a solution that uses a while loop with the .each method. \n<code>", "    sort\
    \ = lambda x, y: x if x < y else y\n    sorted = []\n    sorted.append(lst.pop(0))\n\
    \    while lst != []:\n        minimum = minimum = lst.pop(0)\n        sorted.append(minimum)\n\
    \        while minimum < lst[0]:\n            sorted.append(lst.pop(0))\n    \
    \        minimum = minimum = lst.pop(0)\n        sorted.append(minimum)\n    \
    \    sorted.append(lst.pop(0))\n    return sorted\n</code>\n<|/ a |>\n<| c |>\n\
    I don't understand how the above works. For example, how does `sorted = []; sorted.append(lst.pop(0))`\
    \ get the first element in the list? The lst is still empty, right?\n<|/ c |>\n\
    <| c |>\nThis doesn't work for empty list. Try calling it on an empty list. You\
    \ should return an empty list.\n<|/ c |>\n<| a tags=python,sorting |>\n<code>",
  "  return lst.sort.reverse.inject { |acc, x| [acc[-1], x] }\nend", "  sorted = []\n\
    \  if !lst.is_a?(Array)\n    sorted = lst\n  else\n    sorted_array = lst\n  \
    \  sorted = []\n  end", "    sorted_list = []\n    \n    sorted_list << lst[0]\n\
    \    \n    sorted_list << lst[lst.length-1]\n    \n    for i in 1..lst.length-2\n\
    \        sorted_list << lst[i]\n        sorted_list << lst[lst.length-1-i-1]\n\
    \    end\n    \n    sorted_list << lst[lst.length-1]\n    \n    return sorted_list\n\
    end\n</cell>\n<code language=julia-1.5>\nstrange_sort_list.call(arr)\n</cell>\n\
    <code language=julia-1.5>", "  return nil if lst.empty?\n  min = lst.min\n  max\
    \ = lst.max\n  (0...lst.size).each do |i|\n    arr[i] = lst.sort_by{|x| x <=>\
    \ min} if min < arr[i]\n    arr[i] = lst.sort_by{|x| x <=> max} if max > arr[i]\n\
    \  end\n  return arr\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| a |>\n\
    Use Ruby built in sort method, and pass :downcase as the second argument to sort\
    \ by string value.\n<code>\na = [1, 4, 1, 3, 2, 3]", "  lst.sort!\n  \n  idx =\
    \ 0\n  \n  while idx < lst.count\n    current = lst[idx]\n    \n    idx = idx\
    \ + 1\n    \n    if current > lst[idx-1]\n      lst.swap(idx, idx-1)\n      idx\
    \ = idx-1\n    end\n  end\n  \n  lst\nend\n</code>\n<|/ a tags=ruby,sorting |>\n\
    <| a tags=ruby,sorting |>\nI made a simple solution to this, but I wanted to have\
    \ a more elegant solution.\n<code>", "  lst.sort!\n  i = lst.length-1\n  while\
    \ i > 0\n    j = i\n    temp = []\n    while j > 0\n      next if lst[j-1] > lst[j]\n\
    \      temp << lst[j]\n      j -= 1\n    i -= 1\n    lst.clear\n    lst << temp\n\
    \  end\n  return lst\nend\n</code>\n<|/ a tags=ruby |>\n<| a |>\n<code>\nl = [2,4,8,1]\n\
    </code>\nUsing reverse and sort:\n<code>\nl.reverse.sort", "    sorted = []\n\
    \    minimum = lst[0]\n    maximum = lst[0]", "  return lst.reverse.reduce(:+)\n\
    end", "  sorted = []\n  lst.each do |i|\n    sorted.push(i)\n    sorted.unshift(i)\n\
    \    sorted.push(i)\n  end\n  return sorted\nend", "  if lst.size == 0\n    return\
    \ lst\n  smallest = lst[0]\n  smaller = []\n  greater = []\n  for i in lst\n \
    \   smaller.push(i)\n  end\n  while smaller.size > 0\n    current = smaller.shift\n\
    \    larger = []\n    smaller.each do |el|\n      larger.push(el) if current <\
    \ el\n    end\n    greater.concat(larger)\n  end\n  greater.reverse!\n  return\
    \ greater + smallest\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThanks so much\
    \ for the help!\n<|/ c |>\n<| a dscore=3 tags=ruby,sorting |>\nThe answers provided\
    \ so far are very good. Here's another one:\n<code>", "    return lst.sort{|a,b|\
    \ a<=>b }.reverse\nend", "  new_list = []\n  \n  if lst.length > 0\n    new_list.push\
    \ lst.pop\n    \n    sorted = lst.sort\n    sorted.reverse!\n    new_list.push\
    \ sorted\n    \n    sorted = new_list.sort\n    sorted.reverse!\n    new_list.push\
    \ sorted\n    \n    sorted = new_list.sort\n    sorted.reverse!\n    new_list.push\
    \ sorted\n  else\n    new_list.push nil\n  end", "  return lst.sort_by { |x| x\
    \ }.reverse\nend", "  lst.sort!\n  return lst\nend", "  lst.sort!\n  return lst\n\
    end", "  res = []\n  sort = lambda x, y: y if x > y else x\n  reverse = lambda\
    \ x, y: y if x < y else x\n  while lst != []\n    tmp = sort.call(lst.shift, lst.first)\n\
    \    res << tmp\n    lst << reverse.call(tmp, lst.first)\n  end\n  res\nend",
  "  lst.sort!\n  i = 0\n  while i < lst.size\n    val = lst[i]\n    i = i + 1\n \
    \   j = i\n    while j > 0 and lst[j-1] > val\n      lst[j] = lst[j-1]\n     \
    \ j = j - 1\n    lst[j] = val\n  end\n  return lst\nend\n</code>\n<|/ a tags=ruby\
    \ dscore=3 |>\n<| c |>\nWhile I agree with your answer, I find the question posed\
    \ a little ambiguous. For example, consider `a = [1, 2, 3, 4, 5]`. `a.sort.uniq`\
    \ is `[1, 3, 4, 5]`. This is not what the OP intended, but neither did `a.uniq`\
    \ as I understand it.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  lst.sort_by {|x|\
    \ [x > lst[0], x < lst[-1]].min }\nend", "  return lst.sort{|a, b| a.to_i <=>\
    \ b.to_i}\nend", "  if lst.empty?\n    lst\n  else\n    sorted_list = lst.sort\n\
    \    reverse(sorted_list)\n    reverse(sorted_list)\n    sorted_list\n  end\n\
    end", "  return lst.sort.with_index { |i, _| lst.delete_at(i).min }\nend", '  lst.sort!',
  "  if lst.is_a? Integer\n    [lst]\n  elsif lst.is_a? Array\n    lst.each_with_object([Float::INFINITY])\
    \ do |i, result|\n      min = i\n      min = lst.find {|e| e > i}\n      max =\
    \ i\n      max = lst.find {|e| e < i}\n      if min == Float::INFINITY\n     \
    \   result.push(i)\n      elsif max == Float::INFINITY\n        result.push(i)\n\
    \      elsif min < max\n        result.push(i) \n      else\n        result.push(min)\
    \ \n      end\n    end\n    result\n  else\n    []\n  end\nend", "  return lst.sort.reverse\n\
    end", "  if lst.length < 2\n  then lst\n  else strange_sort_list(lst.take_first)\
    \ + strange_sort_list(lst.drop(1))\nend", "  return lst.sort {|a, b| a<=>b }\n\
    end", "  # Your code here\n  return lst\nend\n\"\"\"", "  lst.sort do |a,b| \n\
    \    \n    if a.nil? || b.nil? || a.is_a?(Numeric) && b.is_a?(Numeric) then\n\
    \      a <=> b\n    else\n      strange_sort_list(b)\n    end\n  end\n  lst\n\
    end", "    lst = lst.dup\n    \n    max = lst.max\n    min = lst.min\n    \n \
    \   arr = [min, max]\n    \n    (min..max).each do |i|\n        next if i ===\
    \ min\n        \n        arr.push i\n    end\n    \n    arr.push min\n    \n \
    \   arr\nend\n</code>\n<|/ a tags=ruby,sorting,algorithm |>\n<| a dscore=0 |>\n\
    The answer by Niklas Borzenko doesn't seem to work for negative numbers\n<code>",
  "  return lst.sort do |a, b|\n    # Compare the first elements.\n    ab = a.odd?\
    \ ? -a : a\n    bc = b.odd? ? -b : b\n    # Compare second elements.\n    ac =\
    \ a.odd? ? a : -a\n    bd = b.odd? ? b : -b", "  lst.sort!\n  i = 1\n  while i\
    \ < lst.size\n    temp = lst[i]\n    j = i\n    while j > 0 and temp > lst[j -\
    \ 1]\n      lst[j] = lst[j - 1]\n      j -= 1\n    lst[j] = temp\n    i += 1\n\
    \  end\n  lst\nend", "  return lst[(0..(lst.size - 1)).sort_by {|x| [lst[x], lst[x+1]].min\
    \ }.reverse]\nend", "  return lst.sort_by { |x| strange_sort(x) }\nend", '  sorted_list
    = []', "  index = 0\n  max = float('-inf')\n  min = float('inf')\n  while index\
    \ < lst.size\n    max = lst[index] if lst[index] > max else max\n    min = lst[index]\
    \ if lst[index] < min else min\n    index += 1\n  while index > 0\n    lst[index],\
    \ lst[index-1] = lst[index-1], lst[index]\n    index -= 1\n  index = 0\n  while\
    \ index < lst.size\n    lst[index], lst[index-1] = lst[index-1], lst[index]\n\
    \    index -= 1\n  return lst\nend", "  return lst.sort_by { |i| i.to_s }\nend",
  "  lst.sort!\n  return lst\nend", '  result = []', "  return lst.sort_by do |x|\n\
    \    if x < lst[1..-1].min\n      1\n    elsif x > lst[1..-1].max\n      -1\n\
    \    else\n      0\n    end\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    Thanks for the answer. I understand how this works, and it works for sorting numbers,\
    \ but not for string lists. For example:", "  if lst.nil?\n    return []\n  end\n\
    \  \n  lst.each_with_index do |value, index|\n    minimum, maximum = index, index\n\
    \    \n    loop do\n      break if minimum > lst.length\n      maximum -= 1\n\
    \      minimum -= 1\n    end\n    \n    return lst.values_at(*lst.indexes(minimum,\
    \ maximum))\n  end\nend", "  if lst.length == 0\n    return lst\n  sort = lst.sort\n\
    \  \n  sort.call(\n    lst[1..-1],\n    &sort.method(lambda x, y: x < y)\n  )\n\
    \  return lst\nend", "  lst.sort.map {|i| [rand(lst.size), i]}\nend", "  lst.sort\n\
    \  return lst\nend", '  lst.sort!', "  if lst.empty?\n    return lst\n  smaller\
    \ = []\n  bigger = []\n  smallest = lst.min\n  largest = lst.max\n  (0..(lst.size-1)).each\
    \ do |index|\n    if smaller == []\n      if lst.min < smallest\n        smaller\
    \ = lst.min\n        smallest = lst.min\n      elsif lst.max > largest\n     \
    \   bigger = lst.max\n        largest = lst.max\n      end\n      next\n    end\n\
    \    if lst.min < smallest\n      smaller = lst.min\n      smallest = lst.min\n\
    \    elsif lst.max > largest\n      bigger = lst.max\n      largest = lst.max\n\
    \    end\n    if index < lst.size\n      smaller << lst[index]\n      lst[index]\
    \ = nil\n    end\n  end\n  smaller += bigger + smallest\n  return smaller\nend",
  "  return lst.sort.to_enum(:call).call(lst.uniq)\nend\n</code>\n<|/ a |>\n<| c |>\n\
    Nice and clean. I'll definitely use it!\n<|/ c |>\n<| c |>\nI love this one. Really\
    \ elegant.\n<|/ c |>\n<| c |>\n, why not just use [`sort_by`](https://ruby-doc.org/core-2.5.0/Enumerable.html#method-i-sort_by)\
    \ instead? `def strange_sort_list(lst)\n  lst.sort_by(&:first).reverse\nend`.\n\
    <|/ c |>\n<| c |>\nyes that\u2019s possible, but it doesn\u2019t get rid of the\
    \ extra steps.\n<|/ c |>\n<| c |>\n, that would only work if OP was only interested\
    \ in the values from the hash, which he has stated he doesn\u2019t require.\n\
    <|/ c |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n<code>", "  return\
    \ lst.sort.map {|x| x ^ x}.sort.map {|x| x ^ x}.sort.map {|x| x ^ x}.sort\nend",
  "  lst.sort_by!(&:to_s)\n  lst\nend", "  return lst.sort{ |a, b| b <=> a }\nend",
  "  if lst.empty?\n    lst.insert(1, nil)\n    return\n  end\n  lst2 = lst.dup\n\
    \  lst2.sort! do |a, b|\n    if a == b\n      1\n    elsif a > b\n      1\n  \
    \  elsif b > a\n      -1\n    end\n  end\n  lst2\nend", "  result = []\n  minimum,\
    \ maximum = lst[0], lst[0]\n  for i in lst\n    if i < minimum\n      minimum,\
    \ maximum = i, minimum\n    elsif i > maximum\n      minimum, maximum = i, maximum\n\
    \    else\n      result.push(i)\n    end\n  end\n  result\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nI like this idea of doing it recursively. It makes my head hurt.\
    \ I also like the idea of keeping a minimum variable. It's probably going to take\
    \ me a minute to understand this.\n<|/ c |>\n<| c |>\nThis works great for numbers,\
    \ but I got stuck on trying to use it for strings. I found a great answer here\
    \ that solves this problem: http://stackoverflow.com/questions/14262418/ruby-sort-array-of-strings-numerically\n\
    <|/ c |>\n<| c |>\nI updated my answer to include a more general solution.\n<|/\
    \ c |>\n<| c |>\nThis works beautifully! I just had to change the `else` to an\
    \ `elsif` since I wanted to sort strings that had numbers in them. Thanks for\
    \ helping me with this!\n<|/ c |>\n<| a tags=arrays,ruby |>\nIf i understand you\
    \ correctly you want to sort your array in ascending order.\nFirst you need to\
    \ find the maximum:\n<code>\na = [1,2,3,4,5]\na.max\n=> 5\n</code>\nThen find\
    \ minimum using index method:\n<code>\na.index(a.max) \n=> 4\n</code>\nNow you\
    \ need to shift the elements one by one starting from index 4 and stopping when\
    \ you reach the maximum element, here it is 5:\n<code>\na = [1,2,3,4,5]\na.slice!(a.index(5))\
    \ \n=> [2,3,4,5]\n</code>\nAfter that you can just reverse the array and you get\
    \ what you want.\n<code>\na = [1,2,3,4,5]\na = a.reverse!\n=> [5,4,3,2,1]\n</code>\n\
    And here is the complete code:\n<code>\na = [1,2,3,4,5]\na.max\n=> 5\na.slice!(a.index(5))\
    \ \n=> [2,3,4,5]\na.reverse!\n=> [5,4,3,2,1]\n</code>\n<|/ a dscore=2 |>\n<| c\
    \ |>\nI think this won't work for strings, but I'm sure I could modify it for\
    \ strings too. Thanks!\n<|/ c |>\n<| a tags=arrays,ruby dscore=2 |>\nA possible\
    \ solution:\n<code>", "  if lst.empty?\n    []\n  else\n    first = lst.min\n\
    \    rest = lst.sort { |a, b| b <=> a }\n    rest.min..first\n  end\nend", " \
    \ sorted = []\n  min = lst.min\n  max = lst.max\n  sorted_min = []\n  sorted_max\
    \ = []\n  while lst.size > 0\n    if min <= lst.first\n      sorted_min << lst.first\n\
    \      lst.shift 1\n    elsif max >= lst.first\n      sorted_max << lst.first\n\
    \      lst.shift 1\n    else\n      sorted << lst.first\n      lst.shift 1\n \
    \   end\n  end\n  sorted = sorted_min + sorted.reverse + sorted_max\n  return\
    \ sorted\nend", "  return lst.sort do |a,b|\n    v = (a<b) ? b : a\n    v = (a>b)\
    \ ? a : v\n    v = (a<b) ? a : b\n    v\n  end\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=ruby,sorting |>\n<code>", "  return lst.sort{|a, b| b <=> a }\nend",
  "  lst = lst.sort.sort\n  return lst\nend\n</code>\n<|/ a dscore=1 tags=ruby,sorting\
    \ |>\n<| c |>\n`lst.sort.sort` was the key. Thank you!\n<|/ c |>\n<| c |>\nYou\
    \ can replace `lst.sort.sort` with `lst.sort`.\n<|/ c |>\n<| c |>\n: yes, you're\
    \ right. I tried to leave the original code as close to originality as possible.\n\
    <|/ c |>\n<| a dscore=1 tags=ruby,sorting |>\nAs I understand it, you're trying\
    \ to reverse the order of the elements of the array? If so, here's a way:\n<code>",
  "  return lst.sort do |a, b|\n    a <=> b\n  end\nend", "  lst.sort!\n  lst.each_with_index\
    \ do |v, i|\n    lst[i] = lst[i].to_s\n  end\n  return lst\nend", "  return (lst.sort\
    \ { |a, b| b <=> a }).reverse\nend\n</code>\n<|/ a tags=sorting,ruby,arrays |>\n\
    <| a tags=sorting,ruby,arrays |>\nAs the others already pointed out, there is\
    \ no built-in sorting method for arrays. The good news is that you can write your\
    \ own that uses the insertion sort algorithm for arrays (and other types) with\
    \ only a little extra code.\n<code>", "  return lst.sort.reverse\nend", "  if\
    \ lst.blank?\n    []\n  else\n    lst.map{|x| x.to_i}.sort.map(&:to_s).join(\"\
    \ \")\n  end\nend", "  lst = lst.sort\n  loop do yield lst.pop until lst.empty?\n\
    end\n</code>\nBenchmark\n<code>\nrequire 'benchmark'\nrequire 'pp'\nrequire 'pp'",
  "  return lst.sort { |a, b| b <=> a }\nend", "  lst.sort!\n  lst.insert(0, lst.pop)\n\
    \  lst.sort!\n  lst.insert(0, lst.pop)\nend", "  lst.sort!\n  lst.reverse!\n \
    \ lst\nend", "  lst.sort\nend", "  return lst.sort_by do |n|\n    case\n    when\
    \ n < 10 then \"#{n}#\"\n    when n < 100 then \"#{n}##\"\n    when n < 1000 then\
    \ \"#{n}###\"\n    else n.to_s.reverse\n    end\nend\n</code>\n<|/ a |>\n<| a\
    \ tags=ruby,algorithm dscore=2 |>\n<code>", "  arr = []\n  for i in lst\n    arr.push(i)\n\
    \  end\n  arr.sort!\n  \n  arr.each_index do |i|\n    lst[i] = arr[i]\n  end\n\
    end", "  return lst.sort_by!(&:to_s)\nend", "  return lst.sort.reverse!\nend",
  "  if lst.length == 0\n    []\n  else\n    arr = [lst[0]]\n    for j in lst[1..-1]\n\
    \      while arr.last.to_i < j\n        arr << arr.last\n        arr.last.succ\n\
    \      end # while arr.last.to_i < j\n      arr << j\n    end # for j in lst[1..-1]\n\
    \    arr\n  end\nend # def strange_sort_list", "  i = 0\n  len = lst.length\n\
    \  while i < len\n    min = i while lst.include?(min)\n    max = i while lst.include?(max)\n\
    \    if min < max\n      lst[min], lst[max] = lst[max], lst[min]\n      i += 1\n\
    \    end\n  end\n  lst\nend\n</code>\n<|/ a |>\n<| a dscore=1 tags=algorithm,ruby,sorting\
    \ |>\nI liked this solution, it's very readable\n<code>", "  lst.sort.with_index\
    \ do |x, i| \n    (i % 2) == 0 ? x : x\n  end\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| a tags=ruby dscore=2 |>\nAnother solution that I like the most is to first\
    \ sort the list and then reverse it.\n<code>\narr = [1, 2, 3, 5, 3, 6, 7, 8, 9,\
    \ 1]\narr.sort\narr.reverse\n</code>\n<|/ a |>\n<| a tags=ruby dscore=1 |>\nI\
    \ used the solution from Fenzo, but changed the if/else to make it a bit more\
    \ readable:\n<code>", "  lst.sort!\n  return lst\nend", "  sorted = lst.sort {\
    \ |a, b| b <=> a }\n  while sorted.first == sorted.last\n    sorted = sorted.drop\
    \ 1\n  end\n  sorted\nend", '    sort = []', "  lst.sort { |a, b| b <=> a }\n\
    end\n</code>\n<|/ a |>\n<| c |>\nYou just reimplemented `String#sort`! :)\n<|/\
    \ c |>\n<| a tags=sorting,ruby |>\nThe quicksort algorithm is relatively simple\
    \ to implement in Ruby:\n<code>", "  lst.sort\n  lst.reverse!\n  lst\nend", " \
    \ lst.sort!\n  strange_sort_list(lst.dup) if lst.size > 0\n  strange_sort_list(lst.dup.reverse)\
    \ if lst.size > 1\n  strange_sort_list(lst.dup.sort) if lst.size > 2\n  strange_sort_list(lst.dup.reverse)\
    \ if lst.size > 3\n  strange_sort_list(lst.dup.sort) if lst.size > 4\nend", " \
    \ if lst.size < 2\n    return lst\n  a = lst.first\n  b = lst.last\n  lst.rotate!\n\
    \  lst.unshift(b)\n  lst.push(a)\n  strange_sort_list(lst)\nend", "  if lst.empty?\n\
    \    lst\n  else\n    middle_index = (lst.size - 1) / 2\n    left_most_value =\
    \ lst[middle_index]\n    right_most_value = lst[middle_index + 1]\n    left_most_value_sorted\
    \ = strange_sort_list(lst.take(middle_index))\n    right_most_value_sorted = strange_sort_list(lst.take(middle_index\
    \ + 1))\n    lst += [left_most_value].concat(left_most_value_sorted)\n    lst\
    \ += [right_most_value].concat(right_most_value_sorted)\n  end\nend\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nThis is a great solution. Can you explain how it works?\
    \ I don't understand the line \"left_most_value_sorted = strange_sort_list(lst.take(middle_index))\"\
    \n<|/ c |>\n<| c |>\nIt's a recursive call. The base case is a list that has one\
    \ item. It's the same as the original list. `lst.take` gets the item at position\
    \ `middle_index` and passes the result to the recursive call. That's why we pass\
    \ `middle_index + 1` in the recursive call.\n<|/ c |>\n<| c |>\nI understand the\
    \ recursion, just don't understand why you call `left_most_value_sorted = strange_sort_list(lst.take(middle_index))`\n\
    <|/ c |>\n<| c |>\nIf you look at the code it says `left_most_value_sorted = strange_sort_list(lst.take(middle_index))`\
    \ which takes the item at `middle_index` and calls `strange_sort_list` on the\
    \ list from position `middle_index + 1` with the result as the argument. So it\
    \ goes `left_most_value_sorted = strange_sort_list(lst.take(2))` which calls `strange_sort_list(lst.take(1))`\
    \ which calls `strange_sort_list(lst.take(0))` which calls `strange_sort_list([])`\
    \ which returns `[]`.\n<|/ c |>\n<| a |>\nI wrote a solution that uses recursion:\n\
    <code>", "  lst = lst.sort\n  (0...(lst.length)).each do |i|\n    lst.insert(i,\
    \ lst.pop)\n  end\nend", "  return lst.sort.reverse\nend", "  sorted = []\n  sorted\
    \ = lst.sort\nend", "  return lst.sort do |a,b|\n    (b < a) ? -1 : (b > a) ?\
    \ 1 : 0\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nWhy do you have two sorts in\
    \ the algorithm?\n<|/ c |>\n<| c |>\n: Because the order of the elements isn't\
    \ guaranteed to be in sorted order. `sort` isn't guaranteed to be stable.\n<|/\
    \ c |>\n<| c |>\nThis code will raise a syntax error. `sort_by` and `sort` are\
    \ not the same. `sort_by` is used to sort by the return value of the block. `sort`\
    \ is used to sort the elements of the array in place.\n<|/ c |>\n<| c |>\n`sort_by`\
    \ and `sort` are not equivalent. `sort_by` will return a copy of the array sorted\
    \ by whatever you pass it.  `sort` will sort the elements in place.\n<|/ c |>\n\
    <| a |>\nYou can use Enumerable#sort_by:\n<code>\nmy_list.sort_by { |x| x <=>\
    \ 5 }\n</code>\n<|/ a tags=ruby dscore=5 |>\n<| a dscore=5 tags=ruby |>\nYou can\
    \ also use Ruby 1.9's Enumerable#sort_by:\n<code>\n[10, 5, 15, 1, 6, 7].sort_by\
    \ { |x| x }\n</code>\nResulting in:\n<code>\n[1, 5, 10, 6, 15, 7]\n</code>\n<|/\
    \ a |>\n<| c |>\n+1 because it works and it's more concise than using `sort_by`,\
    \ since that method returns a new array. Very handy, especially when sorting on\
    \ more than one attribute/value pair, e.g. `[10, 5, 15, 1, 6, 7].sort_by { |x|\
    \ x.to_s }`.\n<|/ c |>\n<| c |>\nThis also works in Ruby 1.8.7 if you pass an\
    \ explicit `block`: `[10, 5, 15, 1, 6, 7].sort_by { |x| x }`\n<|/ c |>\n<| c |>\n\
    Nice solution - I wonder how efficient it is, though.\n<|/ c |>\n<| c |>\n`sort_by`\
    \ creates a temporary array and is thus slower in that case. Depending on your\
    \ situation, it might be more efficient than `sort`.\n<|/ c |>\n<| a tags=ruby\
    \ |>\nHow about a good old fashioned sort?\n<code>", "  lst.sort_by!(&:itself)\n\
    end\n</code>\nIt sorts an array of Integers in an order that is different from\
    \ what you'd get if you sorted the array in ascending order (as suggested by another\
    \ commenter). \nI couldn't find a way to get that to work with a String, which\
    \ is a bit odd. But it does work for the Array class with Integers, not just Strings:\n\
    <code>", "  return (lst.sort.reverse.map(&:first) <<\n          lst.sort.reverse.map(&:last))\
    \ * lst.to_a\nend\n</code>\n<|/ a tags=ruby,arrays dscore=2 |>\n<| c |>\nI like\
    \ how you've written the sort method, and it works well for me. I just implemented\
    \ it here: https://gist.github.com/dreamers/6010862 . I'll be using your sort_list_method\
    \ method going forward, though. I find it easier to read, and more legible.\n\
    <|/ c |>\n<| c |>\n, thanks for the link to the Gist -- that's really helpful.\
    \ The sort_list_method method you posted is much more elegant than what I originally\
    \ posted, but it is slower in Ruby 1.8.7. Glad you like it :) I've implemented\
    \ the sort_list_method method in the Gist above for you (and for the OP as well).\n\
    <|/ c |>\n<| a tags=ruby,arrays |>\nHere's another way using sort_by.\n<code>",
  "  lst.sort\nend", "  lst.sort do |a, b| a <=> b\n  end\nend", "  lst.sort\n  lst.map\
    \ {|x| x.to_i}\nend\n</code>\nIf you want more performance and have the possibility\
    \ to run it in parallel, just use sort_by, which does this in one pass only:\n\
    <code>", "  new_list = []\n  lst.each_index do |i|\n    new_list << lst[i] if\
    \ new_list.count > i\n  end\n  return new_list\nend\n</code>\nNow you can just\
    \ call strange_sort_list\n<code>\nstrange_sort_list [1, 2, 3, 4]", "  return lst.sort\
    \ { |a,b| b <=> a }\nend\n</code>\n<|/ a tags=ruby,sorting |>\n<| c |>\nThis is\
    \ the best answer. It should be the accepted one.\n<|/ c |>\n<| c |>\nWhile `sort\
    \ { |a, b| b <=> a }` is definitely clever, it doesn't help the OP understand\
    \ how `sort { ... }` works in general.\n<|/ c |>\n<| a |>\n<code>\na = [5, 4,\
    \ 3, 2, 1]\na.sort { |a, b| b <=> a }", "  if lst.empty? or lst.nil?\n    lst\n\
    \  else\n    lst.min_by { |x| x.abs }\n      .reverse.\n      sort_by { |x| x.abs\
    \ }\n      .reverse\n  end\nend\n</code>\n<|/ a tags=sorting,ruby |>\n<| a dscore=2\
    \ |>\n<code>\narray = (1..5).to_a\narray.sort_by { |i| -i } # reverse the array\n\
    array.reverse!\n</code>\n<|/ a tags=sorting,ruby |>\n<| c |>\nAh I see I didn't\
    \ read the question correctly. I was trying to figure out the reverse of the array\
    \ and not the sorting itself. Apologies.\n<|/ c |>\n<| a tags=sorting,ruby dscore=2\
    \ |>\nI suggest sort_by\n<code>\na = [2,4,3,1]\na.sort_by { |x| x.abs }.reverse",
  "  return (lst.sort { |a, b| a <=> b }.reverse)\nend", "  return lst if lst.empty?\
    \ or lst.size == 1 else\n    ([lst[0]] + strange_sort_list(lst.drop(1)).sort\n\
    \      (by = &min)).flatten\nend\n</code>\nI like using &min to give me a reference\
    \ to the min function that is available to use inside the sort.  It keeps the\
    \ code cleaner and more readable.\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ dscore=2 |>\n<| c |>\nI don't think this sorts ascending.\n<|/ c |>\n<| c |>\n\
    : Yes, it does. I added a test case to my answer.\n<|/ c |>\n<| a |>\nHere is\
    \ my take on it:\n<code>", "  if lst.empty?\n    return []\n  minimum_number =\
    \ lst[0]\n  maximum_number = lst[0]\n  for i in 1..lst.size\n    if lst[i] < minimum_number\n\
    \      minimum_number = lst[i]\n    if lst[i] > maximum_number\n      maximum_number\
    \ = lst[i]\n  end\n  sorted_lst = []\n  i = 0\n  while i < lst.size\n    if lst[i]\
    \ > maximum_number\n      sorted_lst << maximum_number\n      maximum_number =\
    \ lst[i]\n    else\n      sorted_lst << lst[i]\n      i += 1\n    end\n  end\n\
    \  sorted_lst << minimum_number\n  return sorted_lst\nend", "  if lst.empty?\n\
    \    return []\n  minimum = lst[0]\n  maximum = minimum\n  remaining = lst.size\
    \ - 1", "  ret = []\n  arr.inject(ret, :<<)\nend", "  if lst.empty?\n    lst\n\
    \  elsif lst.size == 1\n    lst\n  else\n    pivot = lst.min\n    less = []\n\
    \    lesser = []\n    greater = []\n    greater_eq = []", "  return lst.sort{|a,\
    \ b| a <=> b}\nend", "  lst.sort!\n  lst.each_with_index do |e, i|\n    lst.swap(i,\
    \ lst.index(e) + 1)\n  end\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\nWhile this\
    \ might answer the question, it's always good to add some explanation to your\
    \ answer. This will help future readers understand why this is a good solution\
    \ to the problem.\n<|/ c |>\n<| c |>\nIt does not answer the question. The question\
    \ is \"how to do strange sorting\", and your answer does not show how to do strange\
    \ sorting. The example in your code would be `[2, 6, 4, 1]`, not `[1, 4, 2, 3]`.\n\
    <|/ c |>\n<| c |>\nI do not think this answers the question. The OP wants to sort\
    \ the array in reverse order. In the example provided, this would mean that `[2,\
    \ 6, 4, 1]` would be sorted to `[5, 4, 2, 1]`. This code would only sort the first\
    \ three elements while leaving the rest intact.\n<|/ c |>\n<| a |>\nTo sort in\
    \ reverse order you can use reverse! to sort the array in reverse order. \nFor\
    \ example:\n<code>\n a = [1, 2, 3, 4, 5]\n a.sort!\n => [5, 4, 3, 2, 1]\n a.reverse!\n\
    \ => [5, 4, 3, 2, 1]\n a\n => [5, 4, 3, 2, 1]\n</code>\nFor a custom sort criteria\
    \ you can also use sort.\n<|/ a dscore=4 tags=sorting,ruby,arrays |>\n<| c |>\n\
    Yes, that's it! Thank you! I'll accept your answer in 9 minutes.\n<|/ c |>\n<|\
    \ c |>\n`reverse!` doesn't change the original array. It returns a new array.\n\
    <|/ c |>\n<| c |>\nYes, thanks for pointing that out. I will update the answer\
    \ to make this clear.\n<|/ c |>\n<| a dscore=3 |>\n<code>\na = [1, 2, 3, 4, 5]\n\
    </code>\nYou can use reverse method\n<code>\na.reverse\n=> [5, 4, 3, 2, 1]\n</code>\n\
    <|/ a tags=sorting,ruby,arrays |>\n<| a dscore=3 |>\nYou can use Array.sort! to\
    \ sort the array in descending order and Array.reverse! to sort the array in ascending\
    \ order.\n<code>\na = [1,2,3,4,5]\na.sort!.reverse!\n</code>\n<|/ a tags=sorting,ruby,arrays\
    \ |>\n<| c |>\nThis does not answer the question. The OP wants to sort the array\
    \ in reverse order. In the example provided, this ", "  length = lst.length\n\
    \  return lst.map(&:to_s).sort\nend", "  return lst.sort{|a, b| b <=> a}\nend",
  "  if lst.blank? then return lst\n  \n  sorted_list = lst.dup\n  \n  sorted_list.sort!\
    \ do |a, b|\n    # Move items from the end of the list to the beginning of the\
    \ list.\n    if a <= b then\n      a\n    else\n      b\n    end\n  end\n  \n\
    \  sorted_list\nend\n</code>\n<|/ a dscore=1 tags=ruby,arrays |>\n<| c |>\n`@sorted\
    \ = [sorted_list.min...sorted_list.max]` is simpler since it's just an array.\n\
    <|/ c |>\n<| c |>\nYes I agree. Just wanted to make the code more clear what was\
    \ happening.\n<|/ c |>\n<| a |>\n<code>", "  return (lst.sort.reverse * lst).call(*lst)\n\
    end", "  return lst.sort do |a,b|\n    sort = []\n    a.upto(b.length) { |i| sort\
    \ << a[i] }\n    sort.sort\n  end\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\n\
    `sort_by` was the thing I was not aware of, thanks for the tip.\n<|/ c |>\n<|\
    \ c |>\nI like this solution as it's compact and does it in a single pass over\
    \ the array. I'd still like to know of any way to get this sorting to work in\
    \ Ruby 1.8.\n<|/ c |>\n<| c |>\nthis works fine in Ruby 1.8.7 and 1.9.3 but not\
    \ in 1.9.2 :(\n<|/ c |>\n<| c |>\nNote that this doesn't work for strings.  If\
    \ you try to sort strings alphabetically 'abc' comes before 'a'.\n<|/ c |>\n<|\
    \ c |>\nThis is a great solution for sorting, but I used it on a hash of hashes\
    \ and it didn't work at all... any idea how to make it work?\n<|/ c |>\n<| a dscore=4\
    \ |>\n<code>", "  lst.sort do |x, y|\n    if x > y\n      -1\n    elsif x < y\n\
    \      1\n    else\n      0\n    end\n  end\n  lst\nend", "  sorted = []\n  if\
    \ lst.empty?\n    sorted\n  else\n    sorted = lst.min\n    (lst.min + lst.max.to_a).reverse.each\
    \ { |i| sorted.push i }\n    sorted.push(lst.max)\n    sorted.reverse\n  end\n\
    end", '  return lst if lst.size <= 10 else lst.sort', "  if lst.empty?\n    return\
    \ []\n  min = lst[0]\n  max = lst[0]\n  lst.each do |value|\n    if value < min\n\
    \      min = value\n    elsif value > max\n      max = value\n    end\n  end\n\
    \  result = [min]\n  i = 0\n  while i < lst.length\n    if lst[i] > max\n    \
    \  result << max\n      max = lst[i]\n    elsif lst[i] < min\n      result <<\
    \ min\n      min = lst[i]\n    else\n      result << lst[i]\n    end\n    i +=\
    \ 1\n  end\n  result << max\n  result\nend\n</code>\n<|/ a tags=arrays,ruby |>\n\
    <| a tags=arrays,ruby dscore=2 |>\nI did a little benchmark and found that your\
    \ solution is slower than the sorting one. Here's my code:\n<code>\nmodule ArrayExtensions\n\
    \  module StrangeSort\n    def strange_sort\n      return to_enum(:strange_sort)\
    \ unless block_given?\n      ary = dup\n      ary.sort!\n      ary.reverse!\n\
    \      ary\n    end\n  end\nend\n</code>\n<code>\nrequire 'benchmark'", "  return\
    \ lst.sort do |a, b|\n    # Find minimum value first\n    min = a\n    max = b\n\
    \    until min == max\n      # If max < min, swap them\n      if max < min\n \
    \       min, max = max, min\n      end\n      # Swap max with max of the remaining\
    \ numbers\n      swap = min\n      min = min.next\n      max = max.next\n    \
    \  # And swap with min of remaining numbers\n      swap = min.next\n      min\
    \ = min\n    end\n    swap\n  end\nend\n</code>\n<|/ a tags=arrays,ruby,sorting\
    \ |>\n<| a dscore=1 |>\nRuby's sort does exactly what you want, and it's easy\
    \ and fast:\n<code>\na = [5, 6, 2, 3, 5, 4, 3, 7, 6, 9, 5, 6, 1, 1]\na.sort\n\
    => [1, 3, 5, 6, 5, 4, 6, 2, 9, 7, 6, 5, 3]\n</code>\nIt sorts the array in-place\
    \ (without creating another array), so the result is exactly what you want.\n\
    <|/ a tags=arrays,ruby,sorting |>\n<| c |>\nThis does not work if the input array\
    \ has duplicate elements.\n<|/ c |>\n<| c |>\nWell, if the question says that\
    \ duplicates should not be considered in the sort, then it's true.\n<|/ c |>\n\
    <| a tags=arrays,ruby,sorting |>\nYou don't have to do any manual sorting and\
    \ can simply use a combination of min and max to sort the array:\n<code>\na =\
    \ [5, 6, 2, 3, 5, 4, 3, 7, 6, 9, 5, 6, 1, 1]", "  sorted = []\n  minimum = nil\n\
    \  maximum = nil\n  numbers.each do |num|\n    if minimum == nil or num < minimum\n\
    \      minimum = num\n    end", "    sorted_lst = []\n    minimum = nil\n    maximum\
    \ = nil\n    i = 0", "  lst.sort!\nend", "  lst.sort_by(&:first)\nend", "  # Write\
    \ your code here.\n  lst.sort\nend", "  lst.sort! # Array sorting\n  \n  first\
    \ = lst[0]\n  last = lst[-1]", "    i = 0\n    while i < lst.length\n        j\
    \ = i + 1\n        while j < lst.length\n            if lst[j] < lst[i]\n    \
    \            swap(lst[j], lst[i])\n                j += 1\n            else\n\
    \                i += 1\n        end\n    end\nend", "  result = lst.sort.call()\n\
    \  result = result.call()\n  result = result.call()\n  result.call()\nend", " \
    \ return lst.sort.call(&:reverse)\nend\n</code>\n<|/ a |>\n<| a tags=ruby,sorting,arrays\
    \ dscore=1 |>\nI ended up using this:\n<code>", "  return lst.sort.reverse\nend",
  "  lst.sort!\n  lst\nend", "  if lst.empty?\n    lst\n  elsif lst.size == 1\n  \
    \  [lst[0]]\n  else\n    min_val = lst[0]\n    max_val = lst[-1]\n    lst[1..-1].each\
    \ do |i|\n      while i > max_val\n        max_val = max_val + 1\n        lst[max_val]\
    \ = nil\n      end\n      while i < min_val\n        min_val = min_val - 1\n \
    \       lst[min_val] = nil\n      end\n    end\n    lst\n  end\nend", "  if lst.empty?\n\
    \    []\n  else\n    minimum = lst[0]\n    maximum = minimum\n    lst = lst.drop(1)\n\
    \    lst.reverse!\n    i = 0\n    while i < lst.length\n      if minimum > maximum\n\
    \        minimum = maximum = lst[i]\n      else\n        if minimum == maximum\n\
    \          minimum = maximum = lst[i]\n          i += 1\n        else\n      \
    \    minimum = lst[i]\n          i += 1\n          maximum = lst[i]\n        end\n\
    \      end\n    end\n    [minimum, maximum]\n  end\nend\n</code>\n<|/ a tags=ruby,arrays,sorting\
    \ |>\n<| a tags=ruby,arrays,sorting |>\n<code>", "  return lst.sort do |a, b|\n\
    \    case\n    when lst.count(a) > lst.count(b) then 1\n    when lst.count(a)\
    \ < lst.count(b) then -1\n    when lst.include?(a) then -1\n    when lst.include?(b)\
    \ then 1\n    else 0\n    end\n  end\nend\n</code>\n<|/ a |>\n<| a |>\nAn alternate\
    \ way to do it: \n<code>\na = [1, 2, 3, 4, 4, 5, 6]", "  lst.sort { |a, b| (a\
    \ - b) || (b - a) }\nend", "  if lst.empty?\n    lst\n  else\n    smallest = lst[0]\n\
    \    biggest = lst.max", "  lst.sort {|a, b| b.to_i} - lst\nend", "  return lst\
    \ + lst.sort {\n    |a, b| a <=> b <=> a == b ? 0 : a <=> b\n  }\nend", '  return
    [] if lst.empty? || lst.size == 1', "  if lst.nil?\n    return lst\n  else\n \
    \   sorted = lst.sort\n    sorted_result = sorted.reverse\n    i = 0\n    j =\
    \ sorted.length\n    while i < j\n      tmp = sorted[i]\n      sorted_result[i]\
    \ = sorted[j]\n      sorted_result[j] = tmp\n      i = i + 1\n      j = j - 1\n\
    \    end\n    return sorted_result\n  end\nend\n</code>\n<|/ a tags=ruby,sorting,ruby-on-rails\
    \ |>\n<| a tags=ruby,sorting,ruby-on-rails |>\nHere you go:\n<code>", "  sorted\
    \ = []\n  i = 1\n  while lst.count > 0\n    i +=1\n    sorted.push(lst.min)\n\
    \    lst.delete_at(lst.index)\n  end\n  sorted.push(i)\n  sorted.concat(sorted.reverse)\n\
    \  return sorted\nend", "  if lst.size == 0\n    []\n  else\n    lst.sort\n  end\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>", "  lst.sort do |a,\
    \ b|\n    direction =\n      if a <= b\n        1\n      elsif a > b\n       \
    \ -1\n      else\n        0\n      end\n    [b, a].max\n  end\nend", "  if lst.blank?\n\
    \    lst\n  else\n    tmp = lst[1]\n    lst[1] = lst[-1]\n    lst[-1] = tmp\n\
    \    sorted = strange_sort_list(lst)\n    sorted.reverse!\n    sorted.concat([lst])\n\
    \    sorted\n  end\nend", "  return lst.sort do |a, b|\n    a = a ? a : a = 'Z'\n\
    \    b = b ? b : b = 'Z'", "  lst.sort\n  lst.clear\n  lst.push(*lst.reverse)\n\
    \  lst.uniq\nend", "  # This solution is not optimized.\n  # It does have complexity\
    \ of O(N log N).\n  # This can be improved by using binary search algorithm.\n\
    \  # But don't worry because it's already optimized in Sort.\n  if lst.empty?\n\
    \    lst\n  else\n    lst.sort!.reverse\n    # Recursion.\n    lst = strange_sort_list(lst.first)\n\
    \    lst.push(*lst)\n    lst.reverse!\n    lst\n  end\nend\n</code>\n<|/ a tags=ruby,arrays,sorting\
    \ |>\n<| c |>\nIt's a nice solution, though it's not clear why one should sort\
    \ twice: first to reverse a stable sort; then to reverse the reversed array.\n\
    <|/ c |>\n<| c |>\n: That is, `lst.sort!.reverse.sort!` reverses twice.\n<|/ c\
    \ |>\n<| a |>\n<code>", "  sorted_list = []\n  min_value = lst[0]\n  max_value\
    \ = lst[0]\n  for i in lst\n    # Check if i has a minimum value.\n    if i ==\
    \ min_value\n      sorted_list.insert(0, i)\n      continue", "  lst.sort!\n \
    \ strange_sort_list(lst)\nend\n</code>\nThe solution\nThe solution here will be\
    \ to create a helper method that will swap two elements in an array. Then, use\
    \ recursion to sort your array. \n<code>", "  return lst.sort do |a, b|\n    a<b\
    \ ? -1 : a>b ? 1 : 0\n  end\nend", "  return lst.sort{|a,b| a <=> b }\nend", " \
    \   sorted = []\n    sorted_min = lst.min\n    sorted_max = lst.max\n    sorted.unshift(sorted_min)\n\
    \    sorted.unshift(sorted_max)\n    lst.each do |number|\n        if sorted_min\
    \ > number\n            sorted_min = number\n        end\n        if sorted_max\
    \ < number\n            sorted_max = number\n        end\n    end\n    sorted.unshift(sorted_min)\n\
    \    sorted.unshift(sorted_max)\n    sorted\nend", "  lst.sort!\n  lst.sort_by!\n\
    end", "  result = lst.sort { |a, b| [a, b].min }\n  return result\nend", "  if\
    \ lst.empty?\n    lst\n  else\n    first = lst.min\n    last = lst.max\n    middle\
    \ = (first+last).round/2", "  return lst.sort.reverse\nend", "  return lst.sort.reverse.to_a\n\
    end\n</code>\nIn Ruby 1.8.7, you can do it this way:\n<code>", "    return lst.sort\
    \ do |a, b|\n        if a > b\n            1\n        elsif a == b\n         \
    \   0\n        else\n            -1\n        end\n    end\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nI like the second part of your answer. One thing I don't understand\
    \ is how you are getting the first two parts to sort and how to get the third\
    \ part to sort.\n<|/ c |>\n<| c |>\nI mean the code from the second part is very\
    \ interesting so I looked it up and then I learned how sorting works. The first\
    \ part is just a simple `if` statement which checks if the value is bigger than\
    \ the other and returns the `1` if the condition is true. The second part is just\
    \ checking if the values are the same and `-1` if the values are different. The\
    \ third part is just using the `sort` method and comparing which values are bigger,\
    \ bigger or smaller than each other and return that array after sorting.\n<|/\
    \ c |>\n<| a |>\nHere's one way.\n<code>", "  return lst.sort.reverse\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThe question is tagged \"ruby\" so why do you have\
    \ `def strange_sort_list(lst)`? Ruby doesn't use braces for blocks.\n<|/ c |>\n\
    <| c |>\nI guess we both are working on the same problem! Ha, just saw your tags\
    \ and updated the code accordingly. :)\n<|/ c |>\n<| c |>\nBy the way, this `[5,5,5,5].reverse`\
    \ returns a different result than `[5,5,5,5].sort`. It sorts in reverse order\n\
    <|/ c |>\n<| c |>\nYou're right, I missed that. I'll update my answer. Thanks!\n\
    <|/ c |>\n<| a tags=sorting,arrays,ruby dscore=0 |>\n<code>", "  if lst.empty?\n\
    \    lst.to_a\n  else\n    first, *rest = lst\n    first, rest = rest.partition\
    \ { |el| el < first }\n    reverse << first << rest.uniq.sort\n  end\nend", " \
    \ i = 0\n  j = 0\n  while i < lst.size do\n    while j < lst.size do\n      if\
    \ lst[i] > lst[j] then\n        lst[i], lst[j] = lst[j], lst[i]\n      end\n \
    \     j += 1\n    end\n    i += 1\n    j = 0\n  end\n  return lst\nend", "  if\
    \ lst.empty?\n    lst\n  else\n    sorted_list = lst.sort { |a, b| a <=> b }\n\
    \    strange_sort_list(sorted_list) + sorted_list\n  end\nend\n</code>\n<|/ a\
    \ dscore=4 |>\n<| c |>\nThis is great for sorting a deck of cards, but what about\
    \ sorting a deck of integers that aren't in order? The first card could easily\
    \ be the smallest integer. How would you go about sorting that?\n<|/ c |>\n<|\
    \ c |>\nIn that case you can just swap the first and the last numbers in the list.\n\
    <|/ c |>\n<| c |>\nThat sounds like it would work, but I feel like there should\
    \ be a more elegant solution.\n<|/ c |>\n<| c |>\nThere isn't. This algorithm\
    \ is so simple that I think it has to be a bug that it would be worth reporting\
    \ to the Ruby community. :)\n<|/ c |>\n<| c |>\nI agree, there should be a more\
    \ elegant solution! But I just can't find it! It seems that this is an elegant\
    \ solution :)\n<|/ c |>\n<| a tags=ruby,sorting |>\nYou can write your own comparison\
    \ function for sorting an array:\n<code>", "  if lst.empty?\n    []\n  else\n\
    \    # First sort by minimum value\n    minimum = lst.min", "  return lst.sort.reverse\n\
    end\n</cell>\n<code language=julia-0.6>", "  if lst.empty?\n    lst\n  else\n\
    \    sorted_list = []\n    min_value = lst[0]\n    sorted_list << min_value\n\
    \    lst.each do |value|\n      sorted_list << min_value if value < min_value\n\
    \      sorted_list << value if value > min_value\n    end\n    sorted_list\n \
    \ end\nend", "  lst.sort do |a, b|\n    next a if a.nil? || a.is_a?(String) ||\
    \ a.is_a?(Float)\n    next b if b.nil? || b.is_a?(String) || b.is_a?(Float)\n\
    \    next a if a.is_a?(Float) && b.is_a?(Float)\n    next a if b.is_a?(Float)\
    \ && a.is_a?(Float)\n    if a > b then 1\n    elsif a < b then -1\n    else 0\n\
    \    end\n  end\nend\n</code>\n<|/ a tags=sorting,ruby |>\n<| a tags=sorting,ruby\
    \ dscore=1 |>\n<code>", "  return lst.sort.reverse!\nend", "  return lst.sort\
    \ do |a,b|\n    if a == b then 0 else 1\n  end\nend", "  if lst.empty?\n    return\
    \ lst\n  first_value = lst[0]\n  last_value = lst[-1]\n  rest = lst.drop(1)\n\
    \  rest = strange_sort_list(rest)\n  lst.rotate(-1)\n  lst.insert(lst.find_index(last_value),\
    \ first_value)\n  lst += rest\n  lst\nend\n</code>\n<|/ a tags=ruby,sorting dscore=1\
    \ |>\n<| a dscore=1 |>\nI came up with this algorithm and it's working fine, if\
    \ you want it in pure ruby then use below code:\n<code>\narr = [4,2,5,3]\narr.sort.each_with_index{|n,i|\n\
    \  arr.insert(arr.size - 1 - i, n)\n}\n</code>\nor use other algorithm for swapping\
    \ array elements here https://stackoverflow.com/a/1584703/7155977\n<|/ a tags=ruby,sorting\
    \ |>\n<| c |>\nFor a generic `arr` this works just fine, but I doubt it works\
    \ as expected for `[4,2,3,5]` or `[4,5,3,2]`, because `insert` will shift everything\
    \ up one position. Using `index` to find the insertion point and then `insert(index,\
    \ value)` is better than `insert(arr.size - 1 - index, value)`.\n<|/ c |>\n<|\
    \ c |>\nI added your suggestions, thanks for your comment\n<|/ c |>\n<| a |>\n\
    <code>", '  lst.sort', "  return lst.sort { |a, b| \n    rand = rand(100)\n  \
    \  puts \"#{rand}\"\n    (a * rand) + b if a.odd? || b.odd?\n  }\nend", '  lst.sort',
  "    sorted.call(lst.sort)\nend", "  if lst.empty?\n    return lst\n  el = lst[0]\n\
    \  rest = strange_sort_list(lst[1..-1])\n  rest.unshift(el)\n  return rest\nend",
  "  arr = lst.sort {|a, b| a == b ? 0 : (a > b ? 1 : -1)}\n  arr.reverse\nend", " \
    \   lst = lst.sort\n    lst.each do |i|\n        i = i + 1\n        while i <\
    \ lst.size\n            lst[i] <= lst[i - 1] ? (lst[i], lst[i - 1]) : [lst[i -\
    \ 1], lst[i]]\n            i = i + 1\n        end\n    end\nend", "    sorted\
    \ = []\n    l = len(lst)\n    i = 0\n    sorted = lst\n    while i < l:\n    \
    \    if sorted[i] < sorted[i-1]:\n            sorted.insert(i, sorted[i-1])\n\
    \            i -= 1\n        elif sorted[i] > sorted[i-1]:\n            sorted.insert(i,\
    \ sorted[i-1])\n            i -= 1\n        i += 1\n    return sorted", "  sorted\
    \ = lst.sort {|a, b| a <=> b}\n  return sorted\nend", "  return lst.sort.reverse\n\
    end", "  lst.sort_by! {|x| x <=> lst.min}\nend", "  sorted_list = lst.sort\n \
    \ sorted_list.call", "  return lst if lst.is_a? Array || lst.is_a? List && !lst.nil?\
    \ &&\n                lst.count == 1 && (lst.first.is_a? Fixnum || lst.first.is_a?\
    \ Bignum || lst.first.is_a? String) &&\n                !lst.first.is_a?(TrueClass)\
    \ && !lst.first.is_a?(FalseClass) && !lst.first.is_a?(Object) &&\n           \
    \     !lst.first.is_a?(Symbol) ?\n                lst.sort.reverse :\n       \
    \         strange_sort_list(lst.first) + strange_sort_list(lst.last)\nend", " \
    \ # Sort the list in O(nlogn) time.\n  lst = lst.reverse.sort_by { |x| x }\n \
    \ lst.clear\n  lst.unshift(lst.pop)\n  lst\nend", "  return lst.sort.reverse.map(&:itself)\n\
    end\n</code>\n<|/ a tags=sorting,ruby |>\n<| c |>\nThis is probably the best solution,\
    \ but I still think it would be better to refactor the sort method to take an\
    \ optional comparison method (which would eliminate the need for the `if` statement).\n\
    <|/ c |>\n<| c |>\nYeah I agree. I was just going for the simplest approach that\
    \ would've allowed him to use `sort_by` (which apparently does require an explicit\
    \ comparison method - thanks Tom).\n<|/ c |>\n<| c |>\nAh yeah, the comparison\
    \ method thing is a lot simpler, as you said.  And it's worth noting that sort_by\
    \ doesn't always require an explicit comparison method - see my answer.\n<|/ c\
    \ |>\n<| a tags=sorting,ruby |>\nThe answer to \"how do I sort arrays of arbitrary\
    \ object in Ruby\" is to use a comparison method, like sort_by does, but without\
    \ the need for that comparison method to explicitly return 0 or -1, as you might\
    \ have in Java or C#.  So if you have a class that implements a comparison method,\
    \ the code looks something like this:\n<code>", "  lst.reverse.each do |elem|\n\
    \    return elem unless elem < lst[0]\n    lst = [elem] + lst\n  end\n  lst\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| a |>\nI think this should work:\n<code>",
  "  sorted = []\n  sorted = (lst.sort do |i|\n    case i\n    when min\n      min\n\
    \    when max\n      max\n    else\n      i\n    end\n  end)\n  return sorted\n\
    end", "  lst = lst.sort_by(&:itself)\n  lst.empty? ? [] : [lst[0]] + strange_sort_list(lst[1..-1])\n\
    end", "  sorted = []\n  min_elem = lst[0]\n  max_elem = lst[0]", '  sorted = []',
  "  lst.sort! do |i|\n    if i.odd?\n      i.to_s\n    else\n      [((i.to_s * -1).to_i).to_s,\
    \ ((i.to_s * -1).to_i).to_s, i.to_s]\n    end\n  end\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThanks for the response.  I like your solution, but I'm going to\
    \ check out my answer to see if there's a way I can make it a little shorter.\n\
    <|/ c |>\n<| a tags=sorting,arrays,ruby |>\nHere is a solution without enumerators.\n\
    <code>", "  sorted = []\n  sorted.concat lst.sort\n  sorted.concat lst.sort {\
    \ |a, b| b <=> a }\n  sorted.concat lst.sort { |a, b| a <=> b }\n  sorted.sort\n\
    end", "  return lst.sort.reverse\nend", "  res = []\n  while lst.any?\n    min\
    \ = lst.min\n    max = lst.max\n    res << min\n    res << max\n    res << min\n\
    \    lst.delete_at(lst.index(min))\n  end\n  res\nend\n</code>\n<|/ a tags=ruby,sorting\
    \ dscore=2 |>\n<| c |>\n`lst.delete_at(lst.index(min))` is unnecessary as `lst.max`\
    \ will already have returned the max value.\n<|/ c |>\n<| c |>\nNot necessarily,\
    \ it might have returned nil which would be nil.to_i\n<|/ c |>\n<| c |>\nSorry,\
    \ my mistake, I was thinking `min` was nil. Hmmm. I think the solution I posted\
    \ is less elegant than yours.\n<|/ c |>\n<| c |>\nThis answer is wrong.  It doesn't\
    \ produce the correct result.  Consider calling `strange_sort_list.call([3,5,2,1,4,6,8])`\n\
    <|/ c |>\n<| c |>\n: It does produce the correct result when run on your example\
    \ input. `[3, 5, 4, 2, 1, 6, 8]`.\n<|/ c |>\n<| a dscore=1 |>\nIf you're happy\
    \ with your original code (that is, you can just remove that loop) then you can\
    \ make use of Array#sort, and use the block to reorder as you wish.\n<code>",
  "  lst.sort { |a, b| a <=> b }\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\n+1 This\
    \ is the correct solution to this problem, but this example won't show it very\
    \ well: `strange_sort_list([5, 5, 5, 5])`.\n<|/ c |>\n<| c |>\nGood point - added\
    \ some comments to the sample code and example in the test case. Thanks!\n<|/\
    \ c |>\n<| c |>\nAh. Okay, I see where you're going with this. I definitely need\
    \ to practice with the sort method and <=>. Thanks!\n<|/ c |>\n<| c |>\nYou know,\
    \ I like your solution, though it's not nearly as elegant as mine. I wonder why\
    \ Ruby's sort method doesn't accept a block to handle this instead of requiring\
    \ you to define an explicit `sort` method. Do you know of a good reason that Ruby's\
    \ sort method doesn't allow a block for ordering?\n<|/ c |>\n<| c |>\nI guess\
    \ that Ruby's sort method could have been written to accept a block. But that's\
    \ not what this question is about. Rather, what you're asking is if you can define\
    \ the `sort` method to accept a block. My answer is about how to do this in Ruby.\n\
    <|/ c |>\n<| a dscore=1 |>\nHere's a method that uses recursion to get the sorted\
    \ list back. It's not as elegant as Strange Sort List, but it works :)\n<code>",
  "  sorted = []\n  sorted.push(lst[0])\n  sorted.push(lst[-1])\n  sorted.push(lst[0])",
  "  return lst.sort do |a, b|\n    sort = (a.class == b.class) ? 0 : 1\n    if sort\
    \ == 0 then\n      if a.class == Integer then\n        sort == b.class == Integer\
    \ ? a.to_i <=> b.to_i : a.to_s <=> b.to_s\n      else\n        sort == b.class\
    \ == Integer ? a.to_s <=> b.to_s : a.to_i <=> b.to_i\n      end\n    else\n  \
    \    sort == b.class == Integer ? a.to_i <=> b.to_i : a.to_s <=> b.to_s\n    end\n\
    \  end\nend", "  if lst.length == 0\n    return []\n  minimum = lst[0]\n  maximum\
    \ = lst[0]\n  for i in 1..lst.length\n    minimum = minimum if minimum > lst[i]\
    \ else lst[i]\n    maximum = maximum if maximum < lst[i] else lst[i]\n  end\n\
    \  result = [minimum, maximum]\n  for i in 2..lst.length\n    minimum = minimum\
    \ if minimum > lst[i] else lst[i]\n    maximum = maximum if maximum < lst[i] else\
    \ lst[i]\n    result.concat([minimum, maximum])\n  end\n  result\nend\n</code>\n\
    <|/ a tags=sorting,algorithm,ruby,arrays dscore=0 |>\n<| c |>\nI understand the\
    \ logic here, but this has a time complexity of O(n^2), and I believe there should\
    \ be a way better solution.\n<|/ c |>\n<| c |>\nIf you want a better solution\
    \ than that, you can look at: http://www.geeksforgeeks.org/insertion-sort/ and\
    \ http://www.geeksforgeeks.org/sorting-algorithms/\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
