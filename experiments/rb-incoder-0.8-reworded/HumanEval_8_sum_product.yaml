name: HumanEval_8_sum_product
language: rb
prompt: "# For a given array of integers, return an array consisting of a sum and\
  \ a product of all the integers in an array.\n# Empty sum should be equal to 0 and\
  \ empty product should be equal to 1.\n# >>> sum_product.call([])\n# [0, 1]\n# >>>\
  \ sum_product.call([1, 2, 3, 4])\n# [10, 24]\ndef sum_product(numbers)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_product\n\
  \    candidate = method(:sum_product)\n    assert_equal([0, 1], candidate.call([]))\n\
  \    assert_equal([3, 1], candidate.call([1, 1, 1]))\n    assert_equal([100, 0],\
  \ candidate.call([100, 0]))\n    assert_equal([15, 105], candidate.call([3, 5, 7]))\n\
  \    assert_equal([10, 10], candidate.call([10]))\n  end\nend\n"
completions: ["    numbers.reduce(:+)\n    numbers.reduce(:*)\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nThis solution also works with arrays of length 1\n<|/ c |>\n<|\
    \ a |>\nIn ruby 2.1+, you can use Enumerable#reduce:\n<code>", "  numbers.inject([0,\
    \ 1], :+)\nend", "  numbers.reduce(:+)\nend", "  numbers.reduce(:+).reduce(:*)\n\
    end", "  result = []\n  result.push( numbers.inject(:+) )\n  result.push( numbers.inject(:*)\
    \ ) if numbers.any?\n  result\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=0\
    \ tags=ruby |>\n<code>\nrequire 'set'", "    numbers.reduce(:+)\n    numbers.reduce(:*)\n\
    end\n</cell>\n<text>\nLet's test our helper function.", "    sum_number = 0\n\
    \    product_number = 0", "  numbers.reduce(0) { |sum, number| sum + number }\n\
    \  numbers.reduce(1) { |product, number| product * number }\nend\n</code>\n<|/\
    \ a tags=ruby |>\n<| c |>\nThis is not an answer to the question asked.\n<|/ c\
    \ |>\n<| a |>\nHere are few examples to demonstrate how it works. Also here is\
    \ the Ruby code for the solution. \n<code>", "  numbers.reduce(:+)\nend", "  numbers\
    \ = [numbers] unless numbers.respond_to?(:to_ary)\n  numbers.reduce(:+)\nend",
  "  numbers = numbers.map { |x| x.to_i }\n  return [numbers[0], numbers.inject {|sum,\
    \ element| sum + element} ]\nend", "  numbers.inject([]) do |sum, number|\n  \
    \  sum << number\n    sum * number\n  end\nend", "  sum = 0\n  product = 1\n \
    \ numbers.each do |number|\n    sum += number\n    product *= number\n  end\n\
    \  [sum, product]\nend", "  sum = numbers.reduce(:+)\n  product = numbers.reduce(:*)",
  "  numbers.inject({sum: 0, product: 1}) do |total, number|\n    total[:sum] += number\n\
    \    total[:product] *= number\n    total\n  end\nend", "  sum = nil\n  product\
    \ = nil", "  sum_array = []\n  product_array = []\n  numbers.each do |number|\n\
    \    sum_array << number\n    product_array << number * number\n  end\n  sum_array\
    \ << '0'\n  product_array << '1'\n  return sum_array, product_array\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\nThis is quite inefficient, but I like how\
    \ it is easy to understand.\n<code>", "  sum = nil\n  product = 1", "  sum = 0\n\
    \  product = 1\n  numbers.each do |num|\n    sum = sum + num\n    product = product\
    \ * num\n  end\n  [sum, product]\nend\n</code>\n<|/ a tags=arrays,ruby,algorithm\
    \ |>\n<| c |>\nYou might want to explain why you used a hash. Why are you using\
    \ the product to calculate the sum?\n<|/ c |>\n<| c |>\nYou're right, a hash would\
    \ be a better solution. I wanted to avoid using any sort of loops, but I guess\
    \ it's not possible?\n<|/ c |>\n<| a tags=arrays,ruby,algorithm |>\nI see you\
    \ already got an accepted answer, but I thought I'd share a solution which doesn't\
    \ use hashes or loops.\n<code>", "  return numbers.reduce(:+), numbers.reduce(:*)\n\
    end", "  sum = 0\n  product = 1\n  numbers.each do |number|\n    sum += number\n\
    \    product *= number\n  end\n  return [sum, product]\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=1 tags=arrays,ruby |>\n<code>\narray = [1,2,3,4,5,6]\narray.inject([0,1].zip(array))\
    \ { |a, e| a.push(a + e) }\n</code>\n<|/ a |>\n<| c |>\nYou don't need the second\
    \ parameter to `inject`. `a` and `e` are local variables inside the block.\n<|/\
    \ c |>\n<| c |>\nAh, thank you. Haven't used inject before and wasn't sure if\
    \ inject was an iterator that would return all the values from the block at the\
    \ end...\n<|/ c |>\n<| c |>\nAs a rule, yes, it does. The block gets invoked once\
    \ for each element of the array and should return the result for the element and\
    \ all previously processed elements. The return value from each invocation is\
    \ passed to the next invocation of the block (if no other values are returned),\
    \ or else the returned value is collected into an array.\n<|/ c |>\n<| c |>\n\
    I see, thank you for the clarification. One more question, what is `|a,e| a.push(a\
    \ + e)`? What is `|a,e|`?\n<|/ c |>\n<| c |>\n: `|a,e|` just defines a two argument\
    \ block that receives two arguments. The first argument is the value that is already\
    \ in the array and `e` is the current array element from the `each` loop.\n<|/\
    \ c |>\n<| a |>\nYou can get the result in a single line, as per below, \n<code>\n\
    numbers = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]", "  numbers = numbers.collect\
    \ { |x| x.to_i }\n  if numbers.empty?\n    return [0, 0]\n  else\n    sum, product\
    \ = 0, 0\n    numbers.each do |num|\n      sum += num\n      product *= num\n\
    \    end\n    return [sum, product]\n  end\nend", "  numbers.reduce(:+)\nend",
  "  numbers.reduce(:+)\nend", "  numbers = numbers.sort\n  sum, product = 0, 1\n\
    \  numbers.each do |num|\n    sum += num\n    product *= num\n  end\n  [sum, product]\n\
    end", "  sum = numbers.reduce(:+)\n  product = numbers.reduce(:*)\n  [sum, product]\n\
    end", "    sum = 0\n    product = 1\n    numbers.each { |number|\n        sum\
    \ += number\n        product *= number\n    }\n    [sum, product]\nend", "  numbers.inject([0])\
    \ do |sum, number|\n    sum = sum + number\n    [sum, sum * number]\n  end\nend",
  "  numbers.reduce(:+)\nend", "  sum, product = 0, 1\n  numbers.each { |number| sum\
    \ += number }\n  numbers.each { |number| product *= number }\n  [sum, product]\n\
    end", "  sum, product = 0, 1\n  numbers.each do |number|\n    sum += number\n\
    \    product *= number\n  end\n  [sum, product]\nend\n</code>\n<|/ a |>\n<| a\
    \ tags=ruby,functional-programming dscore=0 |>\nAnother way of doing it (although\
    \ I prefer the other solutions):\n<code>", "    i = 0\n    sum, product = numbers.reduce([0,1])\
    \ do |sum, number|\n        sum + number\n        product * number\n    end\n\
    \    return [sum, product]\nend\n</cell>\n<cell>\nsum_product([1,2,3,4])\n</cell>\n\
    <cell>\nsum_product([1,2,3])\n</cell>\n<cell>", "    sum = product = 0\n    numbers.each\
    \ {|x| sum += x; product *= x}\n    return [sum, product]\nend\n</code>\nNote\
    \ that Ruby has a built-in function called product. You can simply use that to\
    \ do the same thing:\n<code>", "  numbers.inject(:+).product\nend\n</cell>\n<code\
    \ language=julia-1.5>\nsum_product([1, 2, 3, 4])\n</cell>\n<text>\nThe reduce\
    \ function can be used to calculate the sum and product of an array in one go,\
    \ using reduce to do so sequentially.", "  sum = product = 0\n  numbers.each do\
    \ |number|\n    sum += number\n    product *= number\n  end\n  [sum, product]\n\
    end\n</code>\n<|/ a dscore=4 |>\n<| a dscore=3 |>\n<code>", "  sum = 0\n  product\
    \ = 1\n  numbers.each do |i|\n    sum += i\n    product *= i\n  end\n  [sum, product]\n\
    end\n</cell>\n<cell>", "  if numbers.empty?\n    [0, 1] \n  else\n    numbers.reduce([])\
    \ do |sum, number|\n      [sum + number, number * sum]\n    end\n  end\nend",
  "  sum = product = 0\n  numbers.each do |number|\n    sum += number\n    product\
    \ *= number\n  end\n  [sum, product]\nend", "  total = 0\n  product = 1\n  for\
    \ i in numbers\n    total = total + i\n    product = product * i\n  puts [total,product]\n\
    end\nend\n</code>\n<|/ a |>\n<| a dscore=1 tags=ruby |>\nYou can do like this:\n\
    <code>", "  if numbers.empty?\n    return [0, 0]\n  else\n    sum_product([numbers.first,\
    \ numbers.last] + numbers[1..-1].map {|n| n * numbers.last})\n  end\nend", " \
    \ sum = 0\n  product = 1\n  numbers.each do |number|\n    sum += number\n    product\
    \ *= number\n  end\n  [sum, product]\nend", "  sum = 0\n  product = 1\n  numbers.each\
    \ do |n|\n    sum = sum + n\n    product = product * n\n  end\n  [sum, product]\n\
    end", "  sum = product = 1\n  numbers.each do |number|\n    sum += number\n  \
    \  product *= number\n  end\n  [sum, product]\nend", "  return [] if numbers.empty?\
    \ # return empty array if array is empty\n  sum, product = 0, 1 # initialize sum\
    \ and product\n  numbers.each do |n|\n    sum += n # add to sum\n    product *=\
    \ n # multiply to product\n  end\n  [sum, product] # return array\nend\nputs sum_product.call(ARGV)\
    \ if ARGV.empty? # if there are no command line arguments", "  return if numbers.empty?\n\
    \  sum = numbers.reduce(0, :+)\n  product = numbers.inject(1, :*)\n  [sum, product]\n\
    end", "  numbers.reduce(0) { |sum, number| [sum, number].sum } / numbers.reduce(0)\
    \ { |sum, number| [sum, number].product }\nend", "  numbers.inject([0,1], :+)\n\
    \  numbers.inject([1],    &:*)\nend", '  numbers, product = [numbers], [1]', " \
    \ product = 1\n  sum = 0\n  numbers.each do |number|\n    sum += number\n    product\
    \ *= number\n  end\n  return [sum, product]\nend", "    sum = numbers.inject(0){|sum,\
    \ number| sum + number}\n    product = numbers.inject(1){|product, number| product\
    \ * number}\n  [sum, product]\nend", "  numbers.reduce(:+)\n  numbers.reduce(:*)\n\
    end\n</code>\n<|/ a dscore=2 tags=ruby |>\n<| a dscore=2 |>\n<code>", "    numbers.inject\
    \ {|sum, number| sum + number}\n    numbers.inject {|product, number| product\
    \ * number}\nend", "  numbers.inject {|sum, number| sum + number }\n  numbers.inject\
    \ {|product, number| product * number}\nend", "  result = [0,1]\n  numbers.each\
    \ do |number|\n    result << result[0] + number\n    result << result[1] * number\n\
    \  end\nend", "  if numbers.nil?\n    [0, 0]\n  else\n    [0, numbers.inject(:+).to_i]\n\
    \  end\nend", "  return [numbers.inject(:+), numbers.inject(:*)]\nend\n</code>\n\
    <|/ a |>\n<| a dscore=5 |>\nA simple and elegant solution:\n<code>", "  numbers.inject([0])\
    \ { |sum, number| sum + number }.inject(1) { |prod, number| prod * number }\n\
    end", '  numbers.length == 0 && (numbers = [0, 0]) or nil', "  return [numbers.sum,\
    \ numbers.reduce(:*)]\nend", "  numbers.reduce(:+,0) * numbers.reduce(:*,1)\n\
    end\n</cell>\n<code language=ruby-1.9.3-p448>\nsum_product.call([])\n</cell>\n\
    <code language=ruby-1.9.3-p448>\nsum_product.call([1, 2, 3, 4])\n</cell>\n<text>\n\
    Example: Sum of Squares II\nWrite a method sum_of_squares_ii that takes in an\
    \ array of integers and returns the sum of the squares of each integer. For example,\
    \ if your array is [4, 9, 16, 25], your method should return [54, 99, 145, 169].",
  "  numbers.reduce(0) { |sum, number| sum + number * number }\nend", "    numbers.reduce(:+)\n\
    \    numbers.reduce(:*)\nend", "  sum = numbers[0]\n  prod = numbers[0]\n  numbers.each\
    \ do |n|\n    if n > sum\n      sum = n\n    end\n    if n > prod\n      prod\
    \ = n\n    end\n  end\n  [sum, prod]\nend", "  numbers.inject do |sum, number|\n\
    \    sum += number\n    number * sum\n  end\nend", "  numbers.inject(:+)\nend",
  "  sum = numbers.inject { |sum, number| sum + number }\n  product = numbers.inject(1)\
    \ {|product, number| product * number }\n  [sum, product]\nend", "  numbers.reduce(:+)\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\nYou don't need to create a variable\
    \ to hold the sum of all integers in your example, because you can use the method\
    \ itself: `numbers.reduce(:+)`\n<|/ c |>\n<| c |>\nYes, you are right. I missed\
    \ that in his example, but I added that for clarity.\n<|/ c |>\n<| c |>\nThanks\
    \ for the detailed explanation. I did not know about the reduce method and it\
    \ seems to be what I was looking for. ", "  # TODO: use tail recursion to speed\
    \ up calculation\n  return numbers.inject([0]) do |sum,i|\n    sum += i\n    [sum,\
    \ i*i]\n  end\nend\n</code>\n<|/ a tags=ruby,arrays,algorithm |>\n<| c |>\nThanks\
    \ for your answer. I've been trying to learn about `inject`. It's been a while\
    \ since I last used Ruby, and now I'm relearning it. But I'm glad you brought\
    \ it up. I'll try to understand `inject` better. Your answer is greatly appreciated.\n\
    <|/ c |>\n<| c |>\nI wouldn't call this an efficient implementation. If it were,\
    \ the difference would go away by replacing the `sum += i` with `return [sum,\
    \ i*i]`. This would be an equivalent answer.\n<|/ c |>\n<| a tags=ruby,arrays,algorithm\
    \ dscore=4 |>\n<code>\nnumbers.inject(0){|sum, num| sum + num}\n</code>\n<|/ a\
    \ |>\n<| c |>\nThis is actually the simplest and most readable solution (imho).\
    \ It's a shame that it's not documented anywhere though (like `map` and `inject`).\n\
    <|/ c |>\n<| c |>\nYeah, I guess it isn't documented because it's not often used.\
    \  There are so many other ways to do it, though.\n<|/ c |>\n<| a |>\n<code>",
  "  # Your code here!\nend\n</cell>\n<text>\nExpected Result\nWhen you call sum_product,\
    \ the numbers parameter should be an array of integers. The output of your function\
    \ should be an array of the form [sum, product] where sum is the sum of all the\
    \ integers in the numbers array and product is the product of the integers in\
    \ the numbers array.", "  numbers.map {|x| [x, x*x]}.flatten.reduce(:+)\nend\n\
    </code>\n<|/ a |>\n<| a tags=ruby dscore=1 |>\nThe code below does not use a temporary\
    \ variable and a while loop. I assume that this is what you want:\n<code>", " \
    \ sum = numbers.inject {|sum, number| sum + number}\n  product = 1\n  numbers.each\
    \ {|number| product *= number}\n  [sum, product]\nend", "  numbers = numbers.map\
    \ { |number| number }\n  return [numbers.sum, numbers.product].max\nend", "  return\
    \ numbers.reduce(:+)\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails dscore=2 |>\n\
    <| a dscore=2 |>\n<code>", "  numbers.inject(:+, 0).inject(:*, 1)\nend", "  return\
    \ numbers.inject(\n    [0, 0]) do |(sum, product), number|\n      sum + number\
    \ unless number.nil?\n      product + 1\n    end\nend\n</cell>\n<cell>", "  sum_num\
    \ = 0\n  product_num = 1\n  numbers.each do |number|\n    sum_num += number\n\
    \    product_num *= number\n  end\n  return [sum_num, product_num]\nend", "  if\
    \ numbers.empty? then\n    [0, 1]\n  else\n    numbers = numbers.sort\n    sum_result\
    \ = numbers.inject { |sum, number| sum + number }\n    product = 1\n    numbers.each\
    \ do |number|\n      product *= number\n    end\n    [sum_result, product]\n \
    \ end\nend", "    sum_ = 0\n    product_ = 1\n    numbers.each do |n|\n      \
    \  sum_ = sum_ + n\n        product_ *= n\n    end\n    return [sum_, product_]\n\
    end\n</code>\n<|/ a |>\n<| a dscore=3 |>\nIn Ruby, the most idiomatic way to do\
    \ this would be using inject:\n<code>\nnumbers.inject(0,&:+) ", "  sum_prod =\
    \ [0, 1]\n  numbers.each do |number|\n    sum_prod << (number * sum_prod[0]) if\
    \ number\n    sum_prod << (number * sum_prod[1]) if number\n  end\n  sum_prod\n\
    end\n</pre>\n</div>", "  sum = 1\n  product = 1\n  numbers.each { |n|\n    sum\
    \ += n\n    product *= n\n  }\n  [sum, product]\nend", "  numbers.reduce(0) {|sum,\
    \ number| sum + number} * numbers.reduce(1) {|product, number| product * number}\n\
    end", "  numbers.reduce(:+)\nend", "  sum = numbers.inject { |sum, n| sum + n\
    \ }\n  product = numbers.inject { |product, n| product * n }\n  [sum, product]\n\
    end\n</cell>\n<code language=julia-1.5>\nsum_product([0, 1])\n</cell>\n<code language=julia-1.5>\n\
    sum_product([0, 2, 3])\n</cell>\n<code language=julia-1.5>\nsum_product([1, 2])\n\
    </cell>\n<code language=julia-1.5>\nsum_product([3])\n</cell>\n<code language=julia-1.5>\n\
    sum_product([1, 4, 6, 9, 11, 13])\n</cell>\n<code language=julia-1.5>\nsum_product([5,\
    \ 10, 15, 20])\n</cell>\n<code language=julia-1.5>\nsum_product([5])\n</cell>\n\
    <code language=julia-1.5>\nsum_product([9])\n</cell>\n<code language=julia-1.5>\n\
    sum_product([6, 10])\n</cell>\n<code language=julia-1.5>\nsum_product([6, 10,\
    \ 13])\n</cell>\n<code language=julia-1.5>\nsum_product([10, 20, 30])\n</cell>\n\
    <code language=julia-1.5>\nsum_product([10, 20, 30, 40])\n</cell>\n<code language=julia-1.5>\n\
    sum_product([10, 20, 30, 40, 50, 60, 70, 80, 90])\n</cell>\n<code language=julia-1.5>\n\
    sum_product([0, 2, 3, 4, 6, 8, 10, 12, 15, 18, 20, 22, 24])\n</cell>\n<code language=julia-1.5>\n\
    sum_product([0, 2, 3, 4, 5, 6, 7, 8, 9])\n</cell>\n<code language=julia-1.5>\n\
    sum_product([0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20])\n</cell>\n<code language=julia-1.5>\nsum_product([0, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25])\n</cell>\n\
    <code language=julia-1.5>\nsum_product([0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,\
    \ 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25])\n</cell>\n<code language=julia-1.5>\n\
    sum_product([0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25])\n</cell>\n<code language=julia-1.5>\nsum_product([0,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25])\n</cell>\n<code language=julia-1.5>\nsum_product([0, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11, 12, 13, ", "  return [numbers.length.to_i, numbers.reduce(:*)].transpose.to_i\n\
    end", "  # Your code here!\n  return numbers, numbers.inject(:+), numbers.inject(:*)\n\
    end", "  result = numbers.reduce(0) {|sum, number| sum + number}\n  product =\
    \ numbers.reduce(1) {|product, number| product * number}\n  [result, product]\n\
    end\n</code>\n<|/ a tags=arrays,ruby dscore=4 |>\n<| a dscore=4 tags=arrays,ruby\
    \ |>\n<code>", "  numbers = numbers.to_a\n  sum = numbers.reduce(:+)\n  product\
    \ = numbers.reduce(:*)\n  [sum, product]\nend", "  numbers.reduce(:+)\nend", " \
    \   sum_of_numbers, product_of_numbers = 0, 0\n    numbers.each do |n|\n     \
    \   sum_of_numbers += n\n        product_of_numbers *= n\n    end\n    [sum_of_numbers,\
    \ product_of_numbers]\nend", "  if numbers.empty?\n    [0, 1]\n  else\n    numbers.inject(:+)\
    \ do |sum, number|\n      sum + number\n    end,\n    numbers.inject(:*) do |product,\
    \ number|\n      product * number\n    end\n  end\nend", "  numbers.reduce(&:+)\n\
    \  numbers.reduce(:*)\nend", "  sum_product_array = Array.new\n  product_array\
    \ = Array.new\n  numbers.each do |number|\n    if number\n      sum_product_array\
    \ << number + sum_product_array.last || 0\n      product_array << number * product_array.last\
    \ || 1\n    end\n  end\n  sum_product_array\n  product_array\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nThis doesn't handle the edge case where the array has zeros in\
    \ it.\n<|/ c |>\n<| c |>\nThis doesn't handle negative numbers. You'd need to\
    \ check the first element of the array to see if it was negative or not.\n<|/\
    \ c |>\n<| c |>\nThe first element of the array is `[0]`.\n<|/ c |>\n<| c |>\n\
    This is wrong in multiple ways.", "  numbers.reduce(:+)\n  numbers.reduce(:*)\n\
    end", "    sum = 0\n    product = 1", "    sum_of_numbers = numbers.inject(0,:+)\n\
    \    product_of_numbers = numbers.inject(1,:*)\n    [sum_of_numbers, product_of_numbers]\n\
    end\n</cell>\n<cell>\n@test sum_product(@array .== [1,2,3]) == [3, 6]\n@test sum_product(@array\
    \ .== [1,2]) == [1, 4]\n@test sum_product(@array .== [2,3]) == [6, 12]\n</cell>\n\
    <text>\n3.3 Finding the minimum and maximum element of an array\nGiven an integer\
    \ array, find the minimum and maximum element. Return these elements as two integers\
    \ separated by a single space. \nIf there are no such elements, return two empty\
    \ strings.\nExample\nFor numbers = [1, 5, 10, 2, 3], the output should be\nmin_max(numbers)\
    \ = 5 2\nThe function definition should not have any parameters. \nInput/Output\n\
    [time limit] 4000ms (py3)", "  # Your code here\n  # Hint: use the sum and product\
    \ methods in the standard library.\n  numbers.reduce(:+)\nend", "  sum, product\
    \ = 0, 1\n  numbers.each do |number|\n    sum += number\n    product *= number\n\
    \  end\n  [sum, product]\nend", "  numbers.inject([0, 0], :+).product\nend", " \
    \ numbers.reduce(:+)\nend", "  numbers.reduce(:+)\nend", "  return [numbers.inject\
    \ {|sum, number| sum + number }, numbers.inject {|product, number| product * number\
    \ }]\nend", "  result = [0,0]\n  numbers.each { |number| result[0] += number }\n\
    \  numbers.each { |number| result[1] *= number }\n  result\nend", "  numbers.reduce(:+)\n\
    end", "    numbers, sum, product, counter = numbers.partition { |number| number.nil?\
    \ }\n    unless numbers.empty?\n        sum = numbers.inject(0) do |sum, number|\n\
    \            sum + number\n        end\n        product = numbers.inject(1) do\
    \ |product, number|\n            product * number\n        end\n        counter.times\
    \ do |i|\n            numbers[i] *= 2\n        end\n    end\n    sum, product\n\
    end\n</code>\n<|/ a tags=ruby,loops |>\n<| c |>\nI appreciate the comments.  However,\
    \ I am not interested in trying to understand and answer this question so I am\
    \ not going to post a comment that I am interested in trying to understand.\n\
    <|/ c |>\n<| c |>\nIt might be helpful for OP to think about each method as being\
    \ an operation that returns a value.  You could then think of the `each` and `collect`\
    \ methods as a way to apply those operations to a collection of objects and return\
    \ a new collection of objects. For example, the `each` method returns the `Enumerable`\
    \ object that was passed into it without modifying the original collection.\n\
    <|/ c |>\n<| a dscore=0 |>\nThe solution by jha is perfectly good.\nJust wanted\
    \ to add this as a possibility.\nOne can also add this to the beginning of the\
    \ code which makes it easy to add this functionality to a function which takes\
    \ array of numbers as an argument:\n<code>", "  numbers.reduce(:+)\nend\n</cell>\n\
    <cell>\n@acc function sum_product_iter(numbers)\n  numbers = iter(numbers)\n \
    \ total = numbers[0]\n  product = 1\n  while numbers.has_value?\n    total +=\
    \ numbers.pop\n    product *= numbers.pop\n  end\n  [total, product]\nend\n</cell>\n\
    <cell>\nsum_product_iter([1, 2, 3, 4])\n</cell>\n<cell>\nsum_product_iter([1,\
    \ 2, 3, 4]).to_a\n</cell>\n<text>\nArrays\nThe Array module has many methods for\
    \ processing arrays.", "    numbers.reduce(:+)\n    numbers.reduce(:*)\nend",
  "  sum = numbers.reduce(0, :+)\n  product = numbers.reduce(1, :*)\n  [sum, product]\n\
    end\n</code>\nA few notes on why this is necessary. First of all, we can call\
    \ reduce to accumulate sum and product values by summing and multiplying all elements\
    \ in the array in one operation. This is useful because Ruby arrays are immutable\
    \ and we can easily mutate them in-place using #[]= method (as you did originally,\
    \ but without the need for #reduce). To avoid needless calls to #reduce, we can\
    \ also use #map to generate a new array containing our sum and product values.\n\
    As for why the final return is [sum, product], it is because #reduce takes in\
    \ 2 arguments. The initial value we passed to #reduce is 0. We use :+ to sum up\
    \ our values in our array. The second argument is the initial value of our new\
    \ array, which we have set to 1. It takes in 1 argument and that is :*, which\
    \ gives us our product of our numbers in our array.\n<|/ a dscore=2 tags=arrays,ruby,loops\
    \ |>\n<| a tags=arrays,ruby,loops dscore=2 |>\n<code>\nrequire 'set'", "  numbers.inject(0,\
    \ &:+)\n  numbers.reduce(:*)\nend\n</cell>\n<cell>\nsum_product([]) # => [0, 1]\n\
    sum_product([1, 2, 3, 4]) # => [10, 24]\n</cell>\n<cell>", "  numbers.reduce(:+)\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| a |>\nIt can be easily solved using reduce\
    \ method:\n<code>\nnumbers = [1, 3, 5]\nnumbers.reduce(:+)\n</code>\n<|/ a tags=ruby\
    \ dscore=5 |>\n<| c |>\nThat doesn't answer the question.  It doesn't explain\
    \ how to compute the product.\n<|/ c |>\n<| a |>\nA couple of ways to get the\
    \ sum of an array using reduce (one method per array):\n<code>\nnumbers = [1,\
    \ 3, 5]\nsum = numbers.reduce('+')\nputs sum # => 6", "  sum = numbers.reduce(0,\
    \ :+)\n  product = numbers.reduce(1, :*)\n  [sum, product]\nend", "  return [numbers.inject(:+),\
    \ numbers.inject(:*)]\nend", "  numbers.reduce(:+)\n  numbers.reduce(:*)\nend",
  "  numbers.reduce(:+).reduce(:*)\nend", "  if numbers.empty?\n    [0,1]\n  else\n\
    \    sum = numbers.inject(0) {|sum,x| sum + x }\n    prod = numbers.inject(1)\
    \ {|prod,x| prod * x }\n    [sum, prod]\n  end\nend\n</cell>\n<code language=ruby-1.9.3-rc1>\n\
    sum_product.call []\n</cell>\n<code language=ruby-1.9.3-rc1>\nsum_product.call([1,2,3])\n\
    </cell>\n<code language=ruby-1.9.3-rc1>\nsum_product.call([1,2])\n</cell>\n<code\
    \ language=ruby-1.9.3-rc1>\nsum_product.call([1,3,5,7,9])\n</cell>\n<code language=ruby-1.9.3-rc1>\n\
    sum_product.call([1,4,5])\n</cell>\n<text>\nWe have made some helper methods.\
    \ But now let's use them in a way that makes our code look cleaner. Let's say\
    \ we want to calculate the sum of all the elements in an array and multiply each\
    \ element by a given number. Here are some ways that we can do this:", "  numbers.inject([0])\
    \ do |sum, number|\n    sum += number\n    sum.product([number])\n  end\nend",
  "  sum = 0\n  product = 1\n  numbers.each {|n| sum += n}\n  numbers.each {|n| product\
    \ *= n}\n  [sum, product]\nend\n</code>\n<|/ a tags=ruby,algorithm dscore=3 |>\n\
    <| c |>\nI love how it's exactly the solution I needed. I'm going to look into\
    \ using yield, it looks like a very useful tool.\n<|/ c |>\n<| c |>\nIf you're\
    \ going to use yield, you might as well just call a method named yield.\n<|/ c\
    \ |>\n<| c |>\nI see what you mean.\n<|/ c |>\n<| c |>\nI thought about adding\
    \ this as an alternate solution, but I really dislike the use of yield. It's quite\
    \ confusing to people new to ruby that it is an iterator, and it also makes it\
    \ a lot more difficult to read because it's in a block. What is happening here\
    \ is that the code is returning a pair, rather than a method call. I'd still prefer\
    \ to use yield, but at least I know I'm going to be using it in this situation\
    \ some time soon.\n<|/ c |>\n<| c |>\nI agree about yield being confusing.  If\
    \ you want a more \"rubyish\" way to return a pair, I'd recommend doing `[sum,\
    \ product]`. You could also write a method `yield_pair` or something. `yield`\
    \ makes more sense in contexts where you're passing a block to another method,\
    \ or to build up an array, or a hash, etc.\n<|/ c |>\n<| a dscore=2 |>\nYou could\
    \ use Enumerable#slice_before and Enumerable#slice_after\n<code>\narr = [1, 2,\
    \ 3, 4, 5]\narr.slice_before(2).map { |a| a.reduce(:+) }.sum\n=> 15\n</code>\n\
    <|/ a tags=ruby,algorithm |>\n<| a tags=ruby,algorithm |>\n<code>", "  sums =\
    \ numbers.reduce(:+)\n  products = numbers.reduce(:*)\n  [sums, products]\nend\n\
    \  ", "  sum = numbers.inject(:+, 0)\n  prod = numbers.inject(1, :*) #the :* operator\
    \ is shorthand for the ruby function prod, which returns the product of an array\n\
    \  [sum, prod]\nend", "  numbers.reduce([numbers.first, numbers.last]) do |sum,\
    \ number|\n    sum + number\n  end\nend", "  return numbers and [numbers.sum,\
    \ numbers.reduce(:*)] or [0, 1]\nend", "  result = [0] * numbers.size\n  numbers.each\
    \ do |number|\n    result << number + number\n    result << number * number\n\
    \  end\n  result\nend", "  numbers = numbers.sort.uniq.map { |x| x * x }\n  return\
    \ numbers.inject { |sum, number| sum + number } if numbers.length == 1\n  numbers.reduce(:+).product\
    \ if numbers.length > 1\nend", "  numbers.inject([0, 1], :+).product if numbers.any?\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| a dscore=4 tags=ruby,arrays,ruby-on-rails\
    \ |>\nHere's a pretty simple way using Enumerable#inject\n<code>\n[10, 20, 30].inject(0){|n,\
    \ i| n + i}\n</code>\nIt goes through each element of the array and add it to\
    \ the initial value. It returns the sum\n<|/ a |>\n<| a tags=ruby,arrays,ruby-on-rails\
    \ dscore=4 |>\nRuby 2.4\nA bit shorter syntax is possible:\n<code>\n[10, 20, 30].reduce(:+)\
    \ # => 30\n</code>\n<|/ a |>\n<| c |>\nIt would be interesting to see if reduce\
    \ can be used with a proc that returns a value, such as `:*`, as in [this answer](https://stackoverflow.com/a/50488635/1864167).\n\
    <|/ c |>\n<| c |>\nit also works with `:*` if you add `&:*` at the end of the\
    \ statement like this: `[10, 20, 30].reduce(:+).map(&:*)`\n<|/ c |>\n<| c |>\n\
    Oh wow, I didn't know you could pass a symbol to `reduce`. Great news, thanks!\n\
    <|/ c |>\n<| a |>\nAn interesting way to do this without iterating through the\
    \ whole array is to add the elements up recursively, and then divide the result\
    \ by the number of elements:\n<code>", "  sum_product_array = Array.new(numbers.length,\
    \ 0) \n  product_array = Array.new(numbers.length, 1)\n  for number in numbers\n\
    \    sum_product_array  += number\n    product_array      *= number\n  end\n \
    \ return sum_product_array, product_array\nend", "  numbers.reduce([]) { |sum,\
    \ number| sum.push(number * sum.last) }\nend", "  sum, product = numbers.reduce(&:+),\
    \ numbers.reduce(&:*)\n  nil if sum == 0 || product == 1\n  [sum, product]\nend",
  "  sum = []\n  product = []\n  numbers.each do |n|\n    sum << n.to_i + sum.last\
    \ if sum.length\n    product << n.to_i * product.last if product.length\n  end\n\
    \  [sum, product]\nend\n</code>\n<|/ a |>\n<| c |>\nThis is not correct. Consider\
    \ input `[1,2,3]`, output should be `[[1, 1], [2, 2], [3, 3]]`, but your code\
    \ gives `[[1, 1], [2, 3], [3, 6]]`.\n<|/ c |>\n<| c |>\nyou're right, I fixed\
    \ it. Thanks\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  sum = numbers.reduce(:+)\n\
    \  product = numbers.reduce(:*)", "  numbers.reduce(:+).reduce(:*)\nend", "  numbers.inject([])\
    \ { |sum, element| sum + element }\nend", "  return [numbers.reduce(:+), numbers.reduce(:*)]\
    \ \nend", "  result = numbers.inject(0){|sum,x| sum + x}\n  if numbers.size ==\
    \ 0\n    return [result, 1]\n  else\n    return [result, numbers[0] * result]\n\
    \  end\nend\n</cell>\n<text>\nLet's test it:", "    numbers_with_sum, numbers_with_product\
    \ = [], []\n    numbers.each do |number|\n        numbers_with_sum += [number]\n\
    \        numbers_with_product += [number * number]\n    end\n    numbers_with_sum.concat(numbers_with_product)\n\
    end", "  sum = 0\n  product = 1\n  numbers.each do |n|\n    sum += n\n    product\
    \ *= n\n  end\n  [sum, product]\nend", "  return [numbers[0], numbers[0]]\nend",
  "  numbers.reduce(:+)\n  numbers.reduce(:*)\nend", "    sum = numbers.reduce(:+)\n\
    \    product = 1\n    numbers.each do |n|\n        product = product * n\n   \
    \ end\n    [sum, product]\nend", '  result = []', "  numbers = [numbers] if numbers.is_a?\
    \ Integer\n  sum = 0\n  product = 1\n  numbers.each {|n| sum += n; product *=\
    \ n}\n  [sum, product]\nend", "  numbers.reduce(:+)\n  numbers.reduce(:*)\nend\n\
    </code>\n<|/ a dscore=2 tags=ruby |>\n<| c |>\nFor reference, `numbers.reduce(:+)`\
    \ and `numbers.reduce(:*)` are the same as `numbers.reduce(:+)` and `numbers.reduce(:*)`\
    \ - it's just the method name that is different\n<|/ c |>\n<| a tags=ruby |>\n\
    Ruby has a built-in method for that:\n<code>\n1.upto(10).to_a", "  result = [0]\
    \ * numbers.length\n  result[0] = numbers[0]\n  result[1] = numbers[0]\n  result[2]\
    \ = numbers[0]\n  numbers.each do |number|\n    result[1] += number\n    result[2]\
    \ += number\n  end\n  result\nend", "    numbers.reduce(:+).reduce(:*)\nend\n\
    </code>\n<|/ a |>\n<| c |>\nA good answer, but I'm wondering if Ruby could have\
    \ done this in a more concise way.  That is, if you had just one `reduce` method,\
    \ like `reduce(:+).reduce(:*)`, then your answer would be even better.  I wonder\
    \ if Ruby could have done something like `reduce(:+, numbers).reduce(:*)`?\n<|/\
    \ c |>\n<| c |>\n, yes, it could be done in one line. By the way, in Ruby, `reduce(:+,\
    \ numbers)` is equivalent to `numbers.reduce(:+)`. See [Enumerable#reduce](http://ruby-doc.org/core-2.2.0/Enumerable.html#method-i-reduce)\n\
    <|/ c |>\n<| c |>\nThanks for the link to Enumerable#reduce.  I was wondering\
    \ if someone could explain the differences between the two. :)\n<|/ c |>\n<| c\
    \ |>\n`reduce(:+, numbers)` is equivalent to `numbers.reduce(:+)` in Ruby, but\
    \ [Enumerable#reduce](http://ruby-doc.org/core-2.2.0/Enumerable.html#method-i-reduce)\
    \ can handle multiple arguments passed into it, so as long as you only ever pass\
    \ two arguments, the difference is irrelevant. By the way, `reduce(:+, numbers)`\
    \ is equivalent to `numbers.reduce(:+)` in Ruby, which means you don't need to\
    \ require 'enumerator' to use it.\n<|/ c |>\n<| c |>\n`reduce(:+, numbers)` is\
    \ equivalent to `numbers.reduce(:+)` in Ruby, but `Enumerable#reduce` can handle\
    \ multiple arguments passed into it, so as long as you only ever pass two arguments,\
    \ the difference is irrelevant. By the way, `reduce(:+, numbers)` is equivalent\
    \ to `numbers.reduce(:+)` in Ruby, which means you don't need to require 'enumerator'\
    \ to use it.\n<|/ c |>\n<| a |>\nAs others have said, Ruby does not have that\
    \ many different ways to do the same thing; Ruby is a very consistent language.\
    \  There is an elegant way to do it with just two methods (the others are a bit\
    \ verbose), but that involves creating an object with methods to do the sum and\
    \ product that you want, and then defining how to respond to those methods.  That's\
    \ an entirely different way to go about it.\nHere's an alternate way to do it\
    \ that doesn't involve creating an object with methods to do the sum and product:\n\
    <code>", "  numbers.each_with_object([]) do |number, obj|\n    sum, product =\
    \ *number\n    product ||= 1\n    obj.push sum * product\n  end\nend\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\n`each_with_object` has been deprecated in favor of\
    \ `inject` (or for ruby 2.2 `each_with_object`)\n<|/ c |>\n<| c |>\n, how is `inject`\
    \ deprecated? Was that introduced in Ruby 2.2 or Ruby 2.3?\n<|/ c |>\n<| c |>\n\
    It was introduced in Ruby 2.2, as per http://docs.ruby-lang.org/en/2.2.0/guides/enumerable.html\n\
    <|/ c |>\n<| c |>\n`inject` has been deprecated in favor of `each_with_object`.\n\
    <|/ c |>\n<| a |>\n<code>", "  numbers.reduce(:+).reduce(:*)\nend", "  numbers.inject([0,\
    \ 1], :+)\nend", "  numbers.inject([]) { |sum, el| sum + el * el }\nend", "  result\
    \ = numbers.reduce([0, 1])\n  result.inject {|sum, number| sum + number}\nend",
  "  result = [0, 0]\n  numbers.each do |number|\n    result.push(result[0] + number)\n\
    \    result.push(result[0] * number)\n  end\n  result\nend\n</cell>\n<cell>",
  "  numbers.reduce(:+)\n  numbers.reduce(:*)\nend", "  return numbers.inject { |sum,\
    \ number| sum + number, sum * number }\nend", '  result = [0, 0]', "    numbers.inject(0,:+).reduce(:*)\n\
    end", "    sum = numbers[0].zero?\n    product = 1\n    numbers.each do |number|\n\
    \      sum = sum + number\n      product = product * number\n    end\n    return\
    \ [sum, product]\nend\n</code>\nHope it helps!\n<|/ a dscore=1 |>\n<| c |>\nIt\
    \ does help me! Thanks mate!\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  sum, product\
    \ = 0, 1\n  numbers.each {|x| sum, product = sum + x, product * x}\n  [sum, product]\n\
    end", "  numbers.reduce(:+)\nend", "  numbers, index, sum, product = [numbers].flatten,\
    \ 0, 1, 1\n  numbers.each do |number|\n    sum = sum + number\n    product = product\
    \ * number\n  end\n  [sum, product]\nend", "  numbers.inject(:+).*(1..numbers.size).inject(0,\
    \ :*)\nend", "  total = 0\n  product = 1", "  sum, product = 0, 1\n  numbers.each\
    \ do |n|\n    sum = sum + n\n    product = product * n\n  end\n  [sum, product]\n\
    end", "  numbers.reduce(:+)\n  numbers.reduce(:*)\nend", "  sum = 0\n  product\
    \ = 1\n  numbers.each do |number|\n    sum += number\n    product *= number\n\
    \  end\n  [sum, product]\nend", "  result = numbers.reduce(0){ |sum, number| sum\
    \ + number }\n  result.nonzero? ? result.first : result\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nThanks. I like the succinctness of your solution.\n<|/ c |>\n<|\
    \ a |>\n<code>\nnumbers = [1, 2, 3]", "    numbers.reduce(:+)\nend\n</code>\n\
    <|/ a |>\n<| a tags=ruby,arrays dscore=5 |>\nHere's another approach using Enumerable#inject\
    \ that uses reduce instead of each which might be more efficient and easier to\
    \ read:\n<code>", "  return [numbers.inject(:+).to_f, numbers.inject(:*).to_f]\n\
    end\n</code>\n<|/ a tags=ruby,sum,arrays,product |>\n<| a tags=ruby,sum,arrays,product\
    \ |>\nIn Ruby we can use inject to find the sum and product of the given array.\n\
    <code>\narr = [1, 2, 3, 4, 5]", "  numbers.inject([0,1]) do |total,number|\n \
    \   total + number\n  end\nend", "  if numbers.empty?\n    [0, 0]\n  else\n  \
    \  numbers = numbers.sort\n    product = 1\n    sum = 0\n    numbers.each do |number|\n\
    \      sum += number\n      product *= number\n    end\n    [sum, product]\n \
    \ end\nend", "  sum = numbers.reduce(0, :+)\n  product = numbers.reduce(1, :*)",
  "    sum = numbers[0]\n    product = 1\n    if numbers.size > 1\n        numbers.each\
    \ do |num|\n            sum = sum + num\n            product = product * num\n\
    \        end\n    end\n    [sum, product]\nend", "  sum = 0\n  product = 1\n \
    \ numbers.each do |n|\n    sum += n\n    product *= n\n  end\n  [sum, product]\n\
    end", "  sum = 0\n  product = 1\n  numbers.each do |number|\n    sum += number\n\
    \    product *= number\n  end\n  [sum, product]\nend", "  sum = nil\n  product\
    \ = nil\n  numbers.each do |number|\n    sum += number\n    product *= number\n\
    \  end\n  [sum, product]\nend", "  sum = 0\n  product = 1\n  numbers.each do |number|\n\
    \    sum += number\n    product *= number\n  end\n  [sum, product]\nend", "  numbers.inject(:+).product\n\
    end\n</cell>\n<cell>\nsum_product(numbers)\n</cell>\n<text>\nmap and inject",
  "  sum = 0\n  product = 1", "  numbers.reduce(:+)\nend", "  total = []\n  product\
    \ = []\n  numbers.each do |number|\n    total << number + number\n    product\
    \ << number\n  end\n  total = total.reduce(0, :+)\n  product = product.reduce(1,\
    \ :*)\n  total = total - product\n  total / product\nend\n</code>\n<|/ a |>\n\
    <| a dscore=0 |>\nUsing only loops (for or each)\n<code>", "    numbers.inject([])\
    \ do |sum, number|\n        sum + number\n    end\nend", "  numbers.reduce(:+)\n\
    end", "  return numbers.reduce(:+), numbers.reduce(:*)\nend\n</code>\n<|/ a |>\n\
    <| a dscore=0 |>\nTry this\n<code>", "  return numbers.inject([0]) { |sum,number|\
    \ sum + number, sum * number}\nend", "  numbers = numbers.map{|n| n}\n  numbers.reduce\
    \ do |sum, product|\n    [sum, product * sum]\n  end\nend\n</cell>\n<text>\nNext\
    \ we write a function that will print a nice ASCII \"H\" shape with numbers separated\
    \ by spaces. Call this function and pass it the length of the array.", "    sum\
    \ = 0.0\n    product = 1.0\n    numbers.each do |number|\n        sum += number\n\
    \        product *= number\n    end\n    return [sum, product]\nend", "  numbers.reduce(:+)\n\
    \  numbers.reduce(:-)\nend", "  numbers.reduce(:+)\nend\n</cell>\n<text>\nmap:\
    \ applies a function to each element of an array\nmap takes two arguments: a function\
    \ to apply, and a collection to apply the function to (each element of the collection)\n\
    map creates a new collection\nThe function must return a collection\nmap will\
    \ iterate through each element of the collection\nmap will apply the function\
    \ to each element", "  # return [numbers.length, numbers[0]] if numbers.length\
    \ > 0\n  # return [1, numbers[0]] if numbers.length == 0\n  return [numbers.length,\
    \ numbers[0]]\nend\n</cell>\n<code language=julia-1.5>\nsum_product([])\n</cell>\n\
    <code language=julia-1.5>\nsum_product([1, 2, 3, 4])\n</cell>\n<text>\nRecursion\n\
    A recursive function calls itself. That is what makes it a recursive function",
  "    sum = 0.0\n    product = 1.0\n    numbers.each do |number|\n        sum +=\
    \ number\n        product *= number\n    end\n    return [sum, product]\nend",
  "  if numbers.empty?\n    [0, 1]\n  else\n    numbers.inject([]) do |sum, number|\n\
    \      sum << sum * number\n      sum\n    end\n  end\nend", "  sum = 0\n  product\
    \ = 1\n  numbers.each do |number|\n    sum += number\n    product *= number\n\
    \  end\n  [sum, product]\nend", "  if numbers.empty?\n    [0, 1]\n  else\n   \
    \ numbers.reduce([], :+).reduce(:*)\n  end\nend\n</pre>\n<p>\n  So this is just\
    \ a simple implementation of our first algorithm.\n</p>\n<p>\n  Let's test our\
    \ function out.\n</p>\n<pre class=\"prettyprint lang-Ruby\">\nassert_equals(sum_product.call([]),\
    \ [0,1])\nassert_equals(sum_product.call([1, 2, 3, 4]), [10, 24])\n</pre>\n<p>\n\
    \  Success!\n</p>\n<h2 id=\"a-problem-with-array-sum-and-product\">A Problem with\
    \ Array sum and product</h2>\n<p>\n  In case of an empty array, we still want\
    \ to return an array of length 1 and 0.\n</p>\n<p>\n  Let's see how we can do\
    \ this.\n</p>\n<p>\n  First, we have to define our algorithm.\n</p>\n<pre class=\"\
    prettyprint lang-ruby\">", "  sum = numbers.inject(:+).to_f\n  product = numbers.reduce(:*).to_f\n\
    \  [sum, product]\nend", "  numbers.reduce(:+)\nend\n</pre>\n      </div>\n  \
    \    <div class=\"column\">\n        <pre class=\"code\" style=\"font-size: 0.9em;\"\
    ><code id=\"code-sum-product-2\"><code id=\"code-sum-product-2\"><code id=\"code-sum-product-2\"\
    ><code id=\"code-sum-product-2\"><code id=\"code-sum-product-2\"><code id=\"code-sum-product-2\"\
    ><code id=\"code-sum-product-2\"><code id=\"code-sum-product-2\"><code id=\"code-sum-product-2\"\
    ><code id=\"code-sum-product-2\"><code id=\"code-sum-product-2\"><code id=\"code-sum-product-2\"\
    ><code id=\"code-sum-product-2\"><code id=\"code-sum-product-2\"><code id=\"code-sum-product-2\"\
    ><code id=\"code-sum-product-2\"><code id=\"code-sum-product-2\"><code id=\"code-sum-product-2\"\
    ><code id=\"code-sum-product-2\"><code id=\"code-sum-product-2\"><code id=\"code-sum-product-2\"\
    ><code id=\"code-sum-product-2\"><code id=\"code-sum-product-2\"><code id=\"code-sum-product-2\"\
    ><code id=\"code-sum-product-2\"><code id=\"code-sum-product-2\"><code id=\"code-sum-product-2\"\
    ><code id=\"code-sum-product-2\"><code id=\"code-sum-product-2\"><code id=\"code-sum-product-2\"\
    ><code id=\"code-sum-product-2\"><code id=\"code-sum-product-2\"><code id=\"code-sum-product-2\"\
    ><code id=\"code-sum-product-2\"><code id=\"code-sum-product-2\"><code id=\"code-sum-product-2\"\
    ><code id=\"code-sum-product-2\"><code id=\"code-sum-product-2\"><code id=\"code-sum-product-2\"\
    ><code id=\"code-sum-product-2\"><code id=\"code-sum-product-2\"><code id=\"code-sum-product-2\"\
    ><code id=\"code-sum-product-2\"><code id=\"code-sum-product-2\"><code id=\"code-sum-product-2\"\
    ><code id=\"code-sum-product-2\"><code id=\"code-sum-product-2\"><code id=\"code-sum-product-2\"\
    ><code id=\"code-sum-product-2\"><code id=\"code-sum-product-2\"><code id=\"code-sum-product-2\"\
    ><code id=\"code-sum-product-2\"><code id=\"code-sum-product-2\"><code id=\"code-sum-product-2\"\
    ><code ", "    numbers.reduce(:+).reduce(:*)\nend", "  numbers = numbers.reduce(:+)\n\
    \  numbers = numbers.reduce(:*)\n  [numbers, numbers]\nend", "  sum = 0\n  product\
    \ = 1\n  numbers.each { |number|\n    sum += number\n    product *= number\n \
    \ }\n  [sum, product]\nend", "  sum, product = 0, 1\n  numbers.each do |n|\n \
    \   sum = sum + n\n    product = product * n\n  end\n  [sum, product]\nend", " \
    \ numbers.inject([0, 0]) { |s, t| (s + t).to_i }.max\nend", "  sum = 0\n  product.call(0)\n\
    \  numbers.each do |number|\n    sum += number\n    product.call(sum)\n  end\n\
    \  [sum, product]\nend\n</cell>\n<cell>\nsum_product(numbers)\n</cell>\n<text>\n\
    Ruby Methods vs. Closures", "  sum, product = 0, 1\n  numbers.each { |x| sum +=\
    \ x }\n  numbers.each { |x| product *= x }\n  [sum, product]\nend", "  return\
    \ [numbers.sum, numbers.product].compact.first\nend", "  numbers.reduce(0,&:+)\n\
    \  numbers.reduce(1,&:*)\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
