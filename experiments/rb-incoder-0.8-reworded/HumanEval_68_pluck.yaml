name: HumanEval_68_pluck
language: rb
prompt: "# \"Given an array representing a branch of a tree that has non-negative\
  \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
  \ plucked node should be the node with the smallest even value.\n# If multiple nodes\
  \ with the same smallest even value are found return the node that has smallest\
  \ index.\n# The plucked node should be returned in an array, [ smalest_value, its\
  \ index ],\n# If there are no even values or the given array is empty, return [].\n\
  # Example 1:\n# >>> pluck.call([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest\
  \ even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck.call([1,\
  \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
  \ smallest index.\n# Example 3:\n# >>> pluck.call([])\n# []\n# Example 4:\n# >>>\
  \ pluck.call([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value,\
  \ but  there are two zeros,\n# so we will choose the first zero, which has the smallest\
  \ index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\n\
  def pluck(arr)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
  \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
  \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
  \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n\
  \    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
  \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
  \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
completions: ["  # Your code here\n  arr.sort!\n  even = arr[0..arr.length-1].map\
    \ { |x| x%2 == 0 ? x : 0 }\n  even.sort!\n  even.uniq.compact!\n  even.delete_if\
    \ {|e| e < 0}.uniq\n  even.compact!\n  even.delete_if {|e| e < 0}.uniq\n  even\
    \ = even.last\n  arr[0..arr.length-1].map {|x| x==0 ? x : (even.include?(x) ?\
    \ x : nil)}\nend\n</cell>\n<text>\nPractice Time (2min)\nNow that you have solved\
    \ the problem in the Practice Time section, let's see how you can solve it by\
    \ yourself.", "  min = arr[0]\n  min_idx = 0\n  evens = []\n  even_count = 0\n\
    \  arr.each_index { |i| \n    if arr[i] % 2 == 0 && arr[i] > min\n      min =\
    \ arr[i]\n      min_idx = i\n    end\n    if arr[i] % 2 == 0\n      even_count\
    \ += 1\n    end\n  }\n  if even_count == 0\n    evens = [min, 0]\n  else\n   \
    \ evens = [min, min_idx]\n  end\n  return evens\nend\n</cell>\n<cell>\npluck.call([1])\
    \ # []\npluck.call([1,1]) # []\npluck.call([1,1,0]) # [1, 0]\npluck.call([1,1,1,1])\
    \ # [1, 0]\npluck.call([2,3,5,7,9,11,13,15,17]) # [0, 3]\npluck.call([8,0,9,2,6,3,10,4,11,5])\
    \ # [2, 4]\npluck.call([1,2,4,5,8,10,11,12,13,14,15]) # [4, 5]\npluck.call([20,10,40,20,15,50])\
    \ # [20, 5] \npluck.call([21,21,21,22,22,22,23,23]) # [[21, 22], [0, 7]]\npluck.call([1,2,3,5,7,13,2110,1,2,5,7,13])\
    \ # []\npluck.call([1,2,3,5,7,13,21,21,21,21,21,21,22,22,22,22,22,22,22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,",
  "  # Your code here\n  if arr.empty?\n    return []\n  arr.each_with_index do |el,\
    \ index|\n    next unless el % 2 == 0\n    return el, index\n  end\n  []\nend",
  "  arr=arr.reverse\n  res=[]\n  min=0\n  while arr.first\n    min=arr.first.value\n\
    \    if min==arr.last.value\n      break\n    arr.pop\n  end\n  while arr.first\n\
    \    if arr.first.value % 2==0\n      if arr.first.value<min\n        min=arr.first.value\n\
    \      end\n      arr.pop\n    end\n  end\n  res=arr.collect{|x|[x.value,x.index]}\n\
    \  return res\nend", "\ti = 0\n\tpluked_val = 0\n\tpluked_index = -1\n\twhile\
    \ i < arr.length\n\t\tpluked_val, pluked_index = arr.min {|x, y| (x % 2 == 0 &&\
    \ y % 2 != 0)}\n\t\treturn [ pluked_val, pluked_index ] if arr.empty? || arr.min\
    \ {|x, y| (x % 2 == 0 && y % 2 == 0)}.nil?\n\t\ti += 1\n\tend\n\t\n\treturn nil\n\
    end", "    arr.each do |x|\n        if x.even?\n            if arr.uniq.index(x.to_i)\
    \ \n                arr[x].to_i \n            else\n                arr.uniq.index(x.to_i)\n\
    \            end\n        end\n    end\nend\n</cell>\n<text>\n5\nIn the first\
    \ lecture you learned about how a hash-table works. In this lecture you'll learn\
    \ about a hash function, and how it relates to hash tables. You will use it to\
    \ implement a hash table that can handle up to 10 keys per bucket. Let's start\
    \ with the simplest version of a hash function, which calculates the hash of a\
    \ single key, called a hash key.", "  arr.sort!\n  pluck_counter = 1\n  pluck_val\
    \ = 0\n  pluck_node = nil\n  \n  arr_length = arr.length\n  arr.each do |n|\n\
    \    if n % 2 == 0\n      arr_value = n\n      break\n    elsif n % 2 == 1 &&\
    \ arr_value < n\n      arr_value = n\n      break\n    end\n  end\n  \n  if arr_value\
    \ == nil\n    arr_value = 0\n  end\n  \n  arr_value\nend", "  arr.each do |node|\n\
    \    puts \"#{node} #{(node % 2).to_i}\"\n  end\n  return arr.select {|node| node\
    \ % 2 == 0 }.sort\nend", "    even_values = arr.select { |x| x % 2 == 0 }\n  \
    \  even_values.sort.reverse_each.min\nend", "    arr.sort!\n    min_even_index\
    \ = 0\n    min_even_value = 0\n    pluck_arr = []\n    i = 0\n    while i < arr.length\n\
    \        element = arr[i]\n        if element % 2 == 0\n            if element\
    \ < min_even_value\n                min_even_value = element\n               \
    \ min_even_index = i\n            end\n            i += 1\n        else\n    \
    \        i += 1\n        end\n    end\n    pluck_arr << min_even_value\n    pluck_arr\
    \ << min_even_index if min_even_index < arr.length\n    return pluck_arr\nend",
  "  arr.sort!\n  even = arr.each.with_index.select {|_, index| index % 2 == 0}\n\
    \  even.sort_by {|_, index| index}\n  even.first if even.length == 0\nend", " \
    \ # Your code here\n  return nil\nend", "    even_values = arr.select{|n| n %\
    \ 2 == 0}\n    even_values.min_by(&:even?).tap do | smallest_even | smallest_index\
    \ |\n        if smallest_even\n            return smallest_even, [smallest_index]\n\
    \        end\n    end\nend", "  arr.sort\n  if arr.length < 2 || arr.length ==\
    \ 1.even?\n    []\n  else\n    smallest_value = arr[0]\n    smallest_index = 1\n\
    \    smallest_value = arr[0]\n    arr.each do |val|\n      if val == smallest_value\n\
    \        smallest_index += 1\n      elsif val > smallest_value\n        smallest_value\
    \ = val\n        smallest_index = smallest_index\n      end\n    end\n    [smallest_value,\
    \ smallest_index]\n  end\nend", "  return arr.find{|e| e % 2 == 0 && e <= arr.min}\n\
    end", "  # todo\n  # arr :: []\n  # return arr :: []\nend", "    arr.each_with_index\
    \ do |value, index|\n        if value % 2 == 0\n            return value, index\n\
    \        end\n    end\nend", "  return nil\nend", "  return [] if arr.empty?\n\
    \  smallest_value = arr[0] rescue nil\n  return [ smallest_value, arr.index(smallest_value)\
    \ ]\nend", "    arr.sort!\n    even = arr.find_all {|e| e % 2 == 0}\n    even.delete_if!\
    \ { |e| e < 0 }\n    if even.empty? or even.size > 1\n      min_index = even.min\n\
    \      even.delete_at(even.index(min_index))\n      min_index\n    else\n    \
    \  even.first\n    end\nend\n</code>\n<|/ a tags=arrays,ruby,algorithm |>\n<|\
    \ a tags=arrays,ruby,algorithm dscore=1 |>\nI believe this should work:\n<code>",
  "  arr.sort\n  min = arr.first\n  min_index = -1\n  arr.delete_at(0) if arr.empty?\n\
    \  arr.delete_at(0) if arr.empty?\n  arr.delete_at(0) if arr.empty?\n  arr.delete_at(0)\
    \ if arr.empty?\n  arr.delete_at(0) if arr.empty?\n  arr.delete_at(0) if arr.empty?\n\
    \  arr.delete_at(0) if arr.empty?\n  arr.delete_at(0) if arr.empty?\n  arr.delete_at(0)\
    \ if arr.empty?\n  arr.delete_at(0) if arr.empty?\n  arr.delete_at(0) if arr.empty?\n\
    \  arr.delete_at(0) if arr.empty?\n  arr.delete_at(0) if arr.empty?\n  arr.delete_at(0)\
    \ if arr.empty?\n  arr.delete_at(0) if arr.empty?\n  arr.delete_at(0) if arr.empty?\n\
    \  arr.delete_at(0) if arr.empty?\n  arr.delete_at(0) if arr.empty?\n  arr.delete_at(0)\
    \ if arr.empty?\n  arr.delete_at(0) if arr.empty?\n  arr.delete_at(0) if arr.empty?\n\
    \  arr.delete_at(0) if arr.empty?\n  arr.delete_at(0) if arr.empty?\n  arr.delete_at(0)\
    \ if arr.empty?\n  arr.delete_at(0) if arr.empty?\n  arr.delete_at(0) if arr.empty?\n\
    \  arr.delete_at(0) if arr.empty?\n  arr.delete_at(0) if arr.empty?\n  arr.delete_at(0)\
    \ if arr.empty?\n  arr.delete_at(0) if arr.empty?\n  arr.delete_at(0) if arr.empty?\n\
    \  arr.delete_at(0) if arr.empty?\n  arr.delete_at(0) if arr.empty?\n  arr.delete_at(0)\
    \ if arr.empty?\n  arr.delete_at(0) if arr.empty?\n  arr.delete_at(0) if arr.empty?\n\
    \  arr.delete_at(0) if arr.empty?\n  arr.delete_at(0) if arr.empty?\n  arr.delete_at(0)\
    \ if arr.empty?\n  arr.delete_at(0) if arr.empty?\n  arr.delete_at(0) if arr.empty?\n\
    \  arr.delete_at(0) if arr.empty?\n  arr.delete_at(0) if arr.empty?\n  arr.delete_at(0)\
    \ if arr.empty?\n  arr.delete_at(0) if arr.empty?\n  arr.delete_at(0) if arr.empty?\n\
    \  arr.delete_at(0) if arr.empty?\n  arr.delete_at(0) if arr.empty?\n  arr.delete_at(0)\
    \ if arr.empty?\n  arr.delete_at(0) if arr.empty", "  arr.sort.each_with_index\
    \ do |value, index|\n    return [[value, index]] if value % 2 == 0\n  end", " \
    \   arr.sort!\n    return arr.min.index(arr.min.even?) - 1 if arr.min.even? &&\
    \ !arr.empty? && arr.any? {|v| v.even?} && !arr.min.zero? ? [arr.min, arr.min.index(arr.min.even?)]:\
    \ []\nend\n</cell>\n<cell>", "\treturn sort.call(arr.each_with_index.min { |a,i|\
    \ a.even? && a.zero? ? i : nil })\nend", "    arr = arr.to_a\n    arr.sort!\n\
    \    even = arr.pop\n    return even, arr[1] if arr.any? { |i| i.even? } ? arr[1]\
    \ : nil\nend", "  arr.sort.each_with_index do |node, index|\n    if node.even?\n\
    \      [node.value, index]\n    end\n  end\nend", "  even = [nil, 0]\n  arr.each_index\
    \ do |i|\n    even[0] = arr[i]\n    even[1] = i\n    return even\n  end\n  nil\n\
    end", "  # Your code here\n  return nil\nend", "  return [] if arr.empty? or arr.length\
    \ == 0 or arr.all? {|x| x.to_i != 0 }\n  arr.group_by { |x| x.to_i }.min_by {\
    \ |x, v| v }.last\nend", "  arr.each do |node|\n    next if node.even?\n    next\
    \ if node.zero?\n    smallest_even_value, smallest_even_index = nil, 0\n    arr.each_with_index\
    \ do |value, i|\n      if value == node.value\n        smallest_even_value, smallest_even_index\
    \ = value, i\n        break\n      elsif value == node.value + node.even_value\n\
    \        smallest_even_value, smallest_even_index = value, i\n        break\n\
    \      end\n    end\n    if smallest_even_value and smallest_even_index\n    \
    \  return [smallest_even_value, smallest_even_index]\n    end\n  end\n  return\
    \ []\nend\n\"\"\"\n        self.assertEqual(expected_output, pluck(test_array))",
  "  # Your code here\n  return nil\nend", "    even = arr.select { |x| x % 2 == 0\
    \ }.uniq\n    if even.length == 1\n        even = even.first\n    end\n    if\
    \ even.empty?\n        return even\n    even.sort { |x,y| x <=> y }\n    return\
    \ even.first[1], even.index even.first[1]\nend", "  arr.sort!\n  arr.map! {|x|\
    \ x.even? ? x.to_i : x}\n  arr.detect {|x| x.even?}\nend", "  arr.sort!\n  smalest_value\
    \ = arr.min\n  smaller_even_index = arr.index{|n| n % 2 == 0} if arr.any?\n  [smalest_value,\
    \ smaller_even_index] if smaller_even_index\nend", "  # Your code here\n  raise\
    \ NotImplementedError\nend", "    evens = arr.grep(-> (n){n % 2 == 0})\n    even\
    \ = evens.min\n    even = evens.find {|x| x == even}\n    return even ? [even,\
    \ evens.index(even)] : []\nend\n</cell>\n<code language=julia-0.4>\npluck.([5,\
    \ 3, 1, 4, 2])\n</cell>\n<code language=julia-0.4>\npluck.([5, 3, 1, 4, 2, 0])\n\
    </cell>\n<code language=julia-0.4>\npluck.([5, 3, 1, 4, 2])\n</cell>\n<code language=julia-0.4>\n\
    pluck.([5, 3, 1, 4, 2, 0])\n</cell>\n<code language=julia-0.4>\npluck.([5, 3,\
    \ 1, 4, 2, 9])\n</cell>\n<code language=julia-0.4>\npluck.([5, 3, 1, 4, 2, 9,\
    \ 1])\n</cell>\n<code language=julia-0.4>\npluck.([5, 3, 1, 4, 2, 9, 0])\n</cell>\n\
    <code language=julia-0.4>\npluck.([5, 3, 1, 4, 2, 9, 0, 1])\n</cell>\n<code language=julia-0.4>\n\
    pluck.([5, 3, 1, 4, 2, 9, 0, 1, 0])\n</cell>\n<code language=julia-0.4>\npluck.([5,\
    \ 3, 1, 4, 2, 9, 0, 1, 0, 1])\n</cell>\n<code language=julia-0.4>\npluck.([5,\
    \ 3, 1, 4, 2, 9, 0, 1, 0, 1, 0])\n</cell>\n<code language=julia-0.4>\npluck.([5,\
    \ 3, 1, 4, 2, 9, 0, 1, 0, 1, 0, 0])\n</cell>\n<code language=julia-0.4>\npluck.([5,\
    \ 3, 1, 4, 2, 9, 0, 1, 0, 1, 0, 0, 0])\n</cell>\n<code language=julia-0.4>\npluck.([5,\
    \ 3, 1, 4, 2, 9, 0, 1, 0, 1, 0, 0, 0, 0])\n</cell>\n<code language=julia-0.4>\n\
    pluck.([5, 3, 1, 4, 2, 9, 0, 1, 0, 1, 0, 0, 0, 0, 0])\n</cell>\n<code language=julia-0.4>\n\
    pluck.([5, 3, 1, 4, 2, 9, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0])\n</cell>\n<code language=julia-0.4>\n\
    pluck.([5, 3, 1, 4, 2, 9, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0])\n</cell>\n<code\
    \ language=julia-0.4>\npluck.([5, 3, 1, 4, 2, 9, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0])\n</cell>\n<code language=julia-0.4>\npluck.([5, 3, 1, 4, 2, 9, 0,\
    \ 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n</cell>\n<code language=julia-0.4>\n\
    pluck.([5, 3, 1, 4, 2, 9, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n</cell>\n\
    <code language=julia-0.4>\npluck.([5, 3, 1, 4, 2, 9, 0, 1, 0, 1, 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0])\n</cell>\n<code language=julia-0.", "  arr.sort!\n  return\
    \ arr.find {|x| x.even? }[1..-1] if arr.any? { |x| x.even? }\n  []\nend", "  even\
    \ = arr.select { |e| e % 2 == 0 }\n  even.sort { |a, b| a <=> b }.first\nend",
  "  arr.reduce([]) do |smalest_value, smallest_index|\n    if smalest_value.even?\n\
    \      smallest_index\n    else\n      smalest_value\n    end\n  end\nend", "\t\
    return recurse(arr, 0, arr.length-1, 0)", "    arr.sort!\n    even = arr.select\
    \ { |x| x % 2 == 0 }\n    if even.empty?\n        return nil\n    else\n     \
    \   even = even.min\n        even_index = arr.find_index(even)\n        return\
    \ even, even_index\n    end\nend", "  sorted = arr.sort\n  evens = sorted.select\
    \ {|x| x.modulo(2)==0}\n  return evens.find {|x| x.even?}\nend", "    arr.sort!\n\
    \    arr.uniq.sort_by!{|n| n.to_i}\n    even = arr.select {|n| n.even?}\n    arr.delete_if{|n|\
    \ n.even?}\n    if even.size == 0\n        return [];\n    even.delete_if{|n|\
    \ n.even?}\n    even.sort!\n    even.uniq.sort_by!{|n| n.to_i}\n    if even.size\
    \ == 0\n        return [];\n    even.last\nend\n</cell>\n<code language=julia-1.0>\n\
    @assert pluck.([4, 2, 3]) == [2, 1]\n@assert pluck.([1, 2, 3]) == [2, 1]\n@assert\
    \ pluck([]) == []\n@assert pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\n</cell>\n<text>\n\
    12. Plucking the last item from an array with duplicates", "    even = arr.select\
    \ {|n| n % 2 == 0}\n    small, index =even.min, even.index {|n| n % 2 == 0}\n\
    \    arr.delete_at(index)\n    arr << [small, index]\nend\n</cell>\n<code language=conda-env-cta-py>\n\
    arr = [1, 2, 3, 4, 5, 6]\npluck.call(arr)\n</cell>\n<text>\n5.2 Reverse a string",
  "  sorted = arr.sort\n  evens = arr.select { |e| e % 2 == 0 }\n  if evens.empty?\
    \ || evens.size == 1\n    even = evens.first\n    index = sorted.index{ |e| e\
    \ == even }\n    [sorted.first, index]\n  else\n    smallest = evens.min\n   \
    \ index = sorted.index{ |e| e == smallest }\n    [smallest, index]\n  end\nend",
  "    even_values = arr.select{|x| x%2 == 0}\n    smallest_value_index = even_values.index(arr.min)\n\
    \    if smallest_value_index == -1\n        return []\n    smallest_value, index\
    \ = even_values[smallest_value_index]\n    return [smallest_value, index]\n\"\"\
    \"\n\"\"\"", "  if arr.empty?\n    []\n  else\n    arr[0][1], arr[0].index\n \
    \ end\nend", "    even = arr.select{|n| n % 2 == 0}\n    odd = arr.select{|n|\
    \ n % 2 != 0}\n    even.min{|a, b| a}\nend", "    return arr[1], arr[1] if arr.is_a?(Array)\
    \ && arr.length > 0 && arr.all? { |x| x.even? } ? arr.min_by(&:odd) : []\nend",
  "  smallest, index = smallest_even(arr)\n  smallest_value, smallest_index = smallest_index(arr,\
    \ smallest)\n  if smallest_value == smallest_index\n    return []\n  else\n  \
    \  [smallest_value, smallest_index] = pluck(arr[smallest_index..-1])\n    return\
    \ [smallest_value] + smallest_index\nend", "  arr.sort.each_with_index { |n,i|\
    \ n%2 == 0 ? (n==0 ? i : nil) : nil}\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    It looks like you've missed the question from my answer.\n<|/ c |>\n<| c |>\n\
    No they don't. Pluck is asking for the smallest even valued node. The code is\
    \ just doing the opposite.\n<|/ c |>\n<| c |>\nYes, you're right, I misread the\
    \ question. Sorry.\n<|/ c |>\n<| c |>\nSorry, I misread it as \"Given an array\
    \ representing a branch of a tree that has non-negative integer nodes, find the\
    \ smallest even node in the tree and return it. The plucked node should be the\
    \ node with the smallest even value.\"\n<|/ c |>\n<| a |>\nMy solution in Ruby:\n\
    <code>", "  \n  return []\n    \n</cell>\n<text>\nTest Your Solution", "  a =\
    \ arr.clone\n  a.sort! # Sort it before taking the smallest\n  return a[0] if\
    \ a.length>0 && a[0]%2==0\n  nil\nend", "  ans = []\n  arr.each_with_index do\
    \ |v, i|\n    next if v % 2 == 0\n    ans << v if (ans.any? && ans.min < v) ||\
    \ !ans.any? || ans.min_by { |e| e }.nil?\n  end\n  ans\nend", "  arr.each_with_index\
    \ do |n, i| \n    if n % 2 == 0 \n      arr[i] = n\n    else \n      arr[i] =\
    \ n + 1\n    end\n  end\n  arr.min\nend", "  arr.uniq.sort!\n  arr.map! {|x| x\
    \ % 2 == 0 ? [x,arr.index(x)] : nil }\n  arr.compact.last\nend", "  # Your code\
    \ here\n  arr.sort.each_with_index do |item, index|\n    if item % 2 == 0\n  \
    \    break\n    elsif index == 0\n      puts \"index 0\"\n      puts index\n \
    \     puts \"smallest even value\"\n      puts item\n    end\n  end\nend\n</code>\n\
    <|/ a tags=arrays,ruby |>\n<| c |>\nGreat idea, but as per the OP's problem statement\
    \ \"If multiple nodes with the same smallest even value are found return the node\
    \ that has smallest index.\" is not needed - it can be assumed that an even value\
    \ is in the array before any odd value is.\n<|/ c |>\n<| c |>\nYou don't need\
    \ a break after you found a node (unless you want to find the first odd value\
    \ in an array). `each_with_index` provides the index of the element so you just\
    \ need to check for the smallest index with `<`\n<|/ c |>\n<| a dscore=1 |>\n\
    <code>", "\tmin_ind, min_ind_val = nil, 0\n\tarr.each do |x|\n\t\tunless min_ind_val\
    \ < x\n\t\t\tmin_ind_val = x\n\t\t\tmin_ind = arr.index(x)\n\t\tend\n\tend\n\t\
    return min_ind if min_ind_val == 0\n\tarr.delete_at min_ind\n\treturn min_ind,\
    \ min_ind_val\nend", "  sorted = arr.sort\n  sorted_odd = sorted.select { |x|\
    \ x.odd? }\n  if arr.length == 0\n    return []\n  smallest_value = sorted_odd.first\n\
    \  smallest_even = sorted.select { |x| x.even? }.first\n  smallest_index = sorted_odd.index(smallest_even)\n\
    \  return [ smallest_value, smallest_index ]\nend", "  smallest = nil\n  smallest_value\
    \ = nil\n  smallest_index = nil\n  arr.each do |n|\n    smallest_value ||= n\n\
    \    next unless n % 2 == 0\n    next if smallest_value == nil\n    next if smallest_value\
    \ < n\n    smallest_value = n\n    smallest_index = arr.index(n)\n  end\n  return\
    \ [smallest_value, smallest_index]\nend", "    smallest_value = arr[0]\n    smallest_index\
    \ = -1\n    even_values = 0\n    arr.each_with_index do |value, index|\n     \
    \   if ((index & 1) == 0) # even\n            if value == smallest_value\n   \
    \             even_values += 1\n            elsif even_values > 1\n          \
    \      smallest_value = value\n                smallest_index = index\n      \
    \          even_values = 1\n            end\n        else # odd\n            if\
    \ value == smallest_value\n                even_values += 1\n            end\n\
    \        end\n    end\n    return smallest_value, smallest_index if smallest_value\
    \ != 0\n    return []\nend", "  even_values.each_with_index do |value, index|\n\
    \    if arr[index].even?\n      arr[index] = value\n    end\n  end\n  if arr.empty?\n\
    \    []\n  else\n    if arr.uniq.length == 1\n      arr.uniq.first\n    else\n\
    \      arr.uniq.sort{|a,b| b.even? ? 1 : a.even? ? -1 : a <=> b}.first\n    end\n\
    \  end\nend", "  arr = arr.sort\n  return arr.first(arr.count { |x| x.even? })\n\
    end", "  arr.uniq!\n  arr.each_with_index do |n,i|\n    if n.even?\n      return\
    \ [n, i]\n    end\n  end\nend", "  # Write your code here\n  if arr.include?(0)\
    \ && arr.include?(arr.min) && arr.uniq.uniq.include?(arr.min)\n    arr.min\n \
    \ elsif arr.uniq.uniq.include?(arr.min)\n    arr.uniq.min_by{|x| x}\n  else\n\
    \    []\n  end\nend", "    arr=arr.sort\n    even=0\n    idx=0\n    arr.each_index\
    \ do |i|\n        if arr[i] % 2 == 0\n            even+=1\n        else\n    \
    \        idx=i\n            break\n        end\n    end\n    if even>0\n     \
    \   return even, idx\n    else\n        return arr[0], 0\n    end\nend", "  even_values\
    \ = arr.select { |node| node.even? }.sort\n  even_values.shift\n  return even_values.first\
    \ if even_values.length == 1\n  even_values.min_by { |node| node.index }\nend",
  "    evens = arr.select {|x| x % 2 == 0}\n    evens.sort(&:even?)\n    even = evens.first\n\
    \    if evens.empty?\n        []\n    elsif evens.length == 1\n        [even,\
    \ evens.first]\n    else\n        even, idx = evens.min\n        evens.drop(idx)\n\
    \        [even, idx]\n    end\nend", "  return arr unless arr.is_a?(Array)\n \
    \ arr.map.with_index do |element, index|\n    next unless element.even?\n    [element,\
    \ index]\n  end\n  .reject {|element| element.size == 0}\n  .sort{|a, b| a.first\
    \ <=> b.first}\n  .first\nend", "    arr.sort\n    min_value = arr[0]\n    min_index\
    \ = 0\n    arr_length = arr.length\n    for i in 0...arr_length do\n        if\
    \ arr[i] > min_value then\n            min_value = arr[i]\n            min_index\
    \ = i\n        end\n    end\n    if min_value % 2 = 0 then\n        smallest_value_index\
    \ = min_index\n    else\n        smallest_value_index = min_index + 1\n    end\n\
    \    smallest_value = arr[smallest_value_index]\n    return [smallest_value, smallest_value_index]\n\
    end", "    evens = arr.each_with_index.select { |n, i| n%2 == 0 }\n    evens.min_by\
    \ { |n| -n }\nend", "  return arr.sort.with_index.find_all { |_, i| i.even? }.first[0]\n\
    end", "  min = nil\n  min = arr[0]\n  arr[0] = 0\n  arr.each_index do |i|\n  \
    \  if arr[i] % 2 == 0 && arr[i] > min\n      min = arr[i]\n    end\n  end\n  arr[0]\
    \ = min\n  return arr\nend\n</cell>\n<cell>", "  # write your code here\n  arr.each_with_index.map\
    \ {|n,i| (n%2==0 ? n : n-1).to_i}\n  arr.sort.each_with_index.map {|n,i| (n%2==0\
    \ ? n : n-1).to_i}.first\nend", "    even_values = arr.select { |i| i.even? }.sort\n\
    \    return even_values.last if even_values.size > 1\n    arr.sort.first || []\n\
    end", "  arr.sort { |a,b| a.to_i <=> b.to_i }.uniq\nend\n</cell>\n<cell>", " \
    \   min = arr[0]\n    arr.delete_at(0)\n    arr.sort! { |x, y| x.even? ? 1 : y.even?\
    \ ? -1 : (x.to_i + y.to_i) }\n    if arr.length == 0\n        return [ ]\n   \
    \ if arr[0].even?\n        arr.shift\n    arr.each do |node|\n        if node.even?\n\
    \            min = node if min > node\n        end\n    end\n    if min == 0\n\
    \        min = arr[0]\n        arr.delete_at(0)\n        arr.sort! { |x, y| x.even?\
    \ ? 1 : y.even? ? -1 : (x.to_i + y.to_i) }\n    end\n    return [min, arr.first]\
    \ if min == 0\n    return [ min, arr.first ]\nend", "  evens = arr.map{ |e| e\
    \ % 2 == 0 ? e : nil }\n  evens.sort!.first\n  evens.empty? ? [] : [ evens.first,\
    \ evens.index(evens.first) ]\nend", "  smallest = nil\n  smallest_index = nil\n\
    \  arr.each_with_index { |x, i|\n    if i % 2 == 0\n      if smallest == nil\n\
    \        smallest = x\n        smallest_index = i\n      else\n        if x <\
    \ smallest\n          smallest = x\n          smallest_index = i\n        end\n\
    \      end\n    end\n  }\n  return [smallest, smallest_index]\nend", "    arr.each_with_index\
    \ do |node, index|\n        even = (index/2) - 1 if index%2 == 0\n        if even\
    \ < node.value\n            return even, index\n        end\n    end\n    return\
    \ []\nend", '  arr.sort!', "  min = arr.min\n  pluck.count = 0\n  pluck.even =\
    \ [min]\n  for i in 0..arr.size-1\n    if arr[i]%2 == 0\n      pluck.even.push(arr[i])\n\
    \      pluck.count += 1\n      if pluck.count == arr.size\n        return pluck.even\n\
    \    end\n  end\nend\n\"\"\"", "    sorted = arr.reduce(&:+).sort\n    index =\
    \ sorted.index(sorted[0]) if sorted.any? \n    sorted = sorted.zip(index.to_a)\n\
    \    if sorted.empty?\n        return []\n    sorted_array, sorted_index = sorted\n\
    \    return sorted_array[1], sorted_index[1]\nend", "    arr.each do |node|\n\
    \        if node.even?\n            return [ node, node.index ]\n        end\n\
    \    end\nend", '  arr = arr.reverse if arr[0] < arr[-1]', "\tarr= arr.sort\n\t\
    arr.each do |n|\n\t\treturn [n, arr.index(n) ]\n\tend\n\treturn []\nend", "  return\
    \ arr.sort.last\nend", "\treturn minimum_index(arr.select.with_index {|val, i|\
    \ val % 2 == 0})\nend", "    return arr[arr.index(arr.min)[arr.index(arr.min)[arr.index(arr.min)[arr.index(arr.min)].to_f\
    \ == arr.min].to_f].to_f]\nend", "  arr.each_with_index {|n| n =~ /\\d/ ? return\
    \ [ n, $& - 1 ] : nil }\nend", "    evens = arr.select { |val| val & 1 == 0 }\n\
    \    even = evens.min\n    evens.find { |val| val == even }.to_a\nend", "  arr.sort!\n\
    \  even, idx = nil, -1\n  arr.each do |i|\n    if i % 2 == 0\n      if even ==\
    \ nil\n        even = i\n      else\n        if even > i\n          even = i\n\
    \        end\n      end\n    end\n    idx = (idx > -1 ? idx : arr.index(i))\n\
    \  end\n  [even, idx]\nend", "  even_values = arr.map{|x| x % 2 == 0}\n  return\
    \ even_values.min.min_index if even_values.size > 0 && even_values.all?{|x| x\
    \ % 2 == 0}\n  even_values = []\n  index = 0\n  while arr.length > 0\n    v =\
    \ arr.shift\n    if v.even?\n      even_values << v\n      index += 1\n    end\n\
    \  end\n  [even_values, index]\nend\n</cell>\n<text>\nGiven an array representing\
    \ a branch of a tree that has non-negative integer nodes\nyour task is to pluck\
    \ one of the nodes and return it.\nThe plucked node should be the node with the\
    \ smallest odd value.\nIf multiple nodes with the same smallest odd value are\
    \ found return the node that has smallest index.\nThe plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\nIf there are no odd values or the\
    \ given array is empty, return [].\nExample 1:\n>>> pluck.call([4, 2, 3])\n[2,\
    \ 1]\nExplanation: 2 has the smallest odd value, and 2 has the smallest index.\n\
    Example 2:\n>>> pluck.call([1, 2, 3])\n[2, 1]\nExplanation: 2 has the smallest\
    \ odd value, and 2 has the smallest index.\nExample 3:\n>>> pluck.call([])\n[]\n\
    Example 4:\n>>> pluck.call([5, 2, 7, 3, 9, 4])\n[3, 5]\nExplanation: 3 has the\
    \ smallest odd value, and 3 has the smallest index.\nConstraints:\n* 1 <= nodes.length\
    \ <= 10000\n* 0 <= node.value\nBonus: Can you do this using a single pass?", " \
    \   arr_len = arr.size\n    i = 0\n    smallest_value = arr[0]\n    smallest_index\
    \ = -1\n    array_values = []\n    array_indexes = []", "  arr.reject!{|x| x <\
    \ 0} # removes negative numbers\n  arr.uniq.sort.reverse.to_a.find {|x| x % 2\
    \ == 0 }\nend", "  minValue = arr[0]\n  index = 1\n  arr.each do |n|\n    if n\
    \ % 2 == 0\n      if n < minValue\n        minValue = n\n        index = index\n\
    \      end\n    end\n  end\n  return [index,minValue]\nend", "  arr.sort\n  even\
    \ = arr.reject {|x| x % 2 == 0}\n  even.min\n  even.zip(even.index % 2 == 0).min\n\
    end\nputs pluck([4,2,3])", "  arr.each_with_index.reduce(:<<).group_by { |n, i|\
    \ n%2 ? i : nil }.max_by{ |_, i| i }[1]\nend", "  arr_sort = arr.sort\n  arr.sort!\n\
    \  i = 1\n  while i < arr.length\n    if arr[i] % 2 == 0\n      arr[i], arr[i-1]\
    \ = arr[i-1], arr[i]\n      i += 1\n    end\n    i += 1\n  end\n  arr_sort = nil\n\
    \  arr.sort!\n  arr\nend\nputs pluck(gets.split).join(', ')", "    return arr.sort.last.first\n\
    end", "  return arr.sort.last.first\nend\n\"\"\"", "  # Your code here\n  raise\
    \ \"Fill this in\"\nend", "  return arr[0] % 2 if arr.length == 0 || arr.uniq.all?\
    \ { |x| x % 2 == 0 }.first || arr.uniq.sort.first == 0\n  arr.uniq.sort_by { |x|\
    \ x % 2 }.reverse_each.first\nend", "  arr = arr.sort\n  return [arr.find {|x|\
    \ x.even?}, arr.find_index { |x| x.even? }]\nend", "  sorted = arr.sort\n  even\
    \ = arr.select { |e| e % 2 == 0 }\n  even.min { |a, b| a <=> b }\nend", "  return\
    \ arr\nend", "  arr.sort_by!{|n| n % 2 == 0 ? n : -n}\n  arr.min_by{|n| n % 2\
    \ == 0 ? n : -n}\nend\n</cell>\n<cell>\npluck.(@a)\n</cell>\n<cell>\n@a\n</cell>\n\
    <text>\n51. N-Queens II\nThis problem was asked by Facebook.", "    arr.sort!\n\
    \    smalest_value = nil\n    smalest_index = 0\n    even_values = false\n   \
    \ arr.each_with_index do |node, index|\n        if node.even?\n            even_values\
    \ = true\n        elsif even_values && node.value == smalest_value\n         \
    \   smalest_index = index\n            smalest_value = node.value\n        end\n\
    \    end\n    [smalest_value, smalest_index]\nend", "  arr.uniq.sort!\n  even_value_index\
    \ = []\n  even_value = nil\n  i = 0\n  while i < arr.length\n    e = arr[i]\n\
    \    unless e % 2 == 0\n      even_value_index.push i\n      even_value = e\n\
    \    end\n    i += 1\n  end\n  if even_value_index.length > 0\n    even_value\
    \ = even_value_index[0]\n    even_value_index.shift\n  end\n  return [even_value_index,\
    \ even_value]\nend", "    return arr.sort{|a,b| a.to_i%b.to_i}.first\nend\nputs\
    \ pluck([6, 1, 6, 5, 2, 5])\nputs pluck([6, 1, 6, 5, 2, 5])\nputs pluck([6, 1,\
    \ 6, 5, 2, 5])\nputs pluck([6, 1, 6, 5, 2, 5])\nputs pluck([6, 1, 6, 5, 2, 5])\n\
    puts pluck([6, 1, 6, 5, 2, 5])\nputs pluck([6, 1, 6, 5, 2, 5])\nputs pluck([6,\
    \ 1, 6, 5, 2, 5])\nputs pluck([6, 1, 6, 5, 2, 5])\nputs pluck([6, 1, 6, 5, 2,\
    \ 5])\nputs pluck([6, 1, 6, 5, 2, 5])\nputs pluck([6, 1, 6, 5, 2, 5])\nputs pluck([6,\
    \ 1, 6, 5, 2, 5])\nputs pluck([6, 1, 6, 5, 2, 5])\nputs pluck([6, 1, 6, 5, 2,\
    \ 5])\nputs pluck([6, 1, 6, 5, 2, 5])\nputs pluck([6, 1, 6, 5, 2, 5])\nputs pluck([6,\
    \ 1, 6, 5, 2, 5])\nputs pluck([6, 1, 6, 5, 2, 5])\nputs pluck([6, 1, 6, 5, 2,\
    \ 5])\nputs pluck([6, 1, 6, 5, 2, 5])\nputs pluck([6, 1, 6, 5, 2, 5])\nputs pluck([6,\
    \ 1, 6, 5, 2, 5])\nputs pluck([6, 1, 6, 5, 2, 5])\nputs pluck([6, 1, 6, 5, 2,\
    \ 5])\nputs pluck([6, 1, 6, 5, 2, 5])\nputs pluck([6, 1, 6, 5, 2, 5])\nputs pluck([6,\
    \ 1, 6, 5, 2, 5])\nputs pluck([6, 1, 6, 5, 2, 5])\nputs pluck([6, 1, 6, 5, 2,\
    \ 5])\nputs pluck([6, 1, 6, 5, 2, 5])\nputs pluck([6, 1, 6, 5, 2, 5])\nputs pluck([6,\
    \ 1, 6, 5, 2, 5])\nputs pluck([6, 1, 6, 5, 2, 5])\nputs pluck([6, 1, 6, 5, 2,\
    \ 5])\nputs pluck([6, 1, 6, 5, 2, 5])\nputs pluck([6, 1, 6, 5, 2, 5])\nputs pluck([6,\
    \ 1, 6, 5, 2, 5])\nputs pluck([6, 1, 6, 5, 2, 5])\nputs pluck([6, 1, 6, 5, 2,\
    \ 5])\nputs pluck([6, 1, 6, 5, 2, 5])\nputs pluck([6, 1, 6, 5, 2, 5])\nputs pluck([6,\
    \ 1, 6, 5, 2, 5])\nputs pluck([6, 1, 6, 5, 2, 5])\nputs pluck([6, 1, 6, 5, ",
  "  arr.sort.each_with_index do |val, idx|\n    if val % 2 == 0\n      return [val,\
    \ idx]\n    end\n  end\nend", "  # sort - smallest value first\n  # map - smallest\
    \ index first\n  # pluck - pick a single element from arr\n  return arr.sort.map\
    \ { |v| v.odd? ? [v,arr.index(v)]  : [v,0] }.flatten.first\nend", "    # write\
    \ your code here\nend", "  return arr if arr.length <= 10000 or arr.uniq.size\
    \ <= 10000 or arr.uniq.include?(0) or arr.uniq.include?(1) or arr.uniq.include?(2)\
    \ or arr.uniq.include?(3) or arr.uniq.include?(4) or arr.uniq.include?(5) or arr.uniq.include?(6)\
    \ or arr.uniq.include?(7) or arr.uniq.include?(8) or arr.uniq.include?(9) or arr.uniq.include?(10)\
    \ or arr.uniq.include?(11) or arr.uniq.include?(12) or arr.uniq.include?(13) or\
    \ arr.uniq.include?(14) or arr.uniq.include?(15) or arr.uniq.include?(16) or arr.uniq.include?(17)\
    \ or arr.uniq.include?(18) or arr.uniq.include?(19) or arr.uniq.include?(20) or\
    \ arr.uniq.include?(21) or arr.uniq.include?(22) or arr.uniq.include?(23) or arr.uniq.include?(24)\
    \ or arr.uniq.include?(25) or arr.uniq.include?(26) or arr.uniq.include?(27) or\
    \ arr.uniq.include?(28) or arr.uniq.include?(29) or arr.uniq.include?(30) or arr.uniq.include?(31)\n\
    \    elsif arr.uniq.size == 1\n      plucked_value = (arr.uniq.sort_by {|x| x}.first).first\n\
    \      return [plucked_value] if plucked_value.odd?\n      plucked_index = arr.index\
    \ { |x| x.odd? }\n      return [plucked_value, plucked_index] if plucked_index\
    \ >= 0\n      return [plucked_value, plucked_index + 1] if plucked_index >= 1\n\
    \      return [plucked_value, -1] if plucked_index < 0\n    end\n    even_values\
    \ = arr.uniq.select { |x| x.even? }\n    smallest_index = even_values.index {|x|\
    \ x.odd? }.odd? ? -1 : 0\n    return even_values[smallest_index] if smallest_index\
    \ >= 0\n    even_values[smallest_index + 1]\n  end", "    # Your code here\n \
    \   even=[]\n    smalest_value=0\n    smallest_index=-1\n    for i in arr:\n \
    \       if i%2==0:\n            even.append(i)\n        else:\n            smalest_value=i\n\
    \            smallest_index=even.index(i)\n            break\n    if smalest_value==0:\n\
    \        return [-1]\n    if smallest_index==-1:\n        return even\n    else:\n\
    \        return [smalest_value,smallest_index]\n    ", "    evens = []\n    even\
    \ = nil\n    index = 0\n    \n    even = arr.find { |n| n % 2 == 0 }", "  arr.sort!\n\
    \  even_index = []\n  even_value = []\n  even_index = even_value.zip(arr).map{\
    \ |x, y| [x, y] }.uniq.map{ |x| x[0] if x.size < 2 }\n  even_index.each do |x|\n\
    \    even_value[x] += 1\n  end\n  even_value.map!{ |x| x + 1 }\n  even_value.max\n\
    end\n</cell>\n<code language=conda-env-adventofcode-py>", "\treturn [] if arr.empty?\n\
    \tarr = arr.sort\n\tarr.first.bits % 2 == 0 ? arr.first.bits : arr.first.bits\
    \ + 1\nend", "    # Write your code here.\n    even_values = []\n    if arr.empty?\n\
    \        return []\n    else\n        arr.each do |e|\n            if e.even?\n\
    \                even_values << e\n            end\n        end\n        even_values.sort!\n\
    \        even_values.each do |e|\n            if even_values.index(e) == even_values.index(e.next)\n\
    \                return [e]\n            end\n        end\n        return []\n\
    \    end\nend", "    even = arr.select {|x| x % 2 == 0}\n    index = even.index(even.min)\n\
    \    even.min\nend", "  arr.sort!\n  result = []\n  smallest = nil\n  index =\
    \ 0\n  arr.each do |i|\n    next if smallest.nil? or i.even?\n    smallest = i\n\
    \  end\n  result << smallest\n  if smallest.even? and smallest.value % 2 == 0\n\
    \    index = 1\n    smallest.value -= 1\n  end\n  result << index\n  result\n\
    end\n</pre>\n</div>\n</div>", "  arr = arr if arr.kind_of?(Array) else\n    raise\
    \ TypeError.new(\"pluck.arr must be an Array or nil\")\n  arr.sort!\n  even =\
    \ arr.select {|x| x % 2 == 0}\n  smalest_value = even.min\n  small_index = even.index(smalest_value)\n\
    \  return [smalest_value, small_index] if smalest_value && small_index\n  even.map\
    \ { |x| [x, even.index(x)] }.to_h\nend", "  return [ arr.uniq.sort.first ].tap\
    \ { |v| v[1] = arr.index(v[0]) }\nend", "  arr.reduce(0){|x, y| x.even?(y) ? x\
    \ : y}\nend", "  even_values = arr.select.select {|x| x % 2 == 0} # return all\
    \ even values\n  even_values.sort.first              # find the smallest even\
    \ value\nend", "  return arr.minmax_by(&:even?).last\nend", "    min = nil\n \
    \   arr.each do |value|\n        next if min == nil\n        if value < min then\n\
    \            min = value\n        end\n    end\n    min = arr[0] if min.zero?\n\
    \    arr.each do |value|\n        next if value == min\n        if value.even?\
    \ then\n            return [ value, arr.index ]\n        end\n    end\n    return\
    \ []\nend\nputs pluck.call([4, 2, 3])\nputs pluck.call([1, 2, 3])\nputs pluck.call([])\n\
    puts pluck.call([5, 0, 3, 0, 4, 2])", "  even = []\n  odd = []\n  arr.each do\
    \ |x|\n    if x % 2 == 0\n      even << x\n    else\n      odd << x\n    end\n\
    \  end\n  even.each do |x|\n    i = odd.index(x)\n    odd.delete_at(i)\n    i\
    \ = even.index(x)\n    even.delete_at(i)\n    return [x] if even.length > 0\n\
    \  end\n  return [] if even.length > 0 and odd.length == 0\n  return [even.min,\
    \ even.index] if even.length > 0\n  return [odd.min, odd.index] if odd.length\
    \ > 0\nend", "  arr.sort\n  even = arr.select {|x| x % 2 == 0}\n  even.min { |a,\
    \ b| b <=> a }\nend\nputs pluck([4, 2, 3])\nputs pluck([1, 2, 3])\nputs pluck([])\n\
    puts pluck([5, 0, 3, 0, 4, 2])\nputs pluck([5, 7, 7, 7, 7])\nputs pluck([5, 7,\
    \ 7])\nputs pluck([6, 7, 7])\nputs pluck([5, 5, 5, 6, 6, 6, 7])\nputs pluck([8,\
    \ 8, 8, 8, 9, 9, 9, 9])\nputs pluck([8, 8, 8, 8, 8, 8, 8, 8, 8, 9])\nputs pluck([8,\
    \ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\
    \ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\
    \ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\
    \ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\
    \ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\
    \ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\
    \ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\
    \ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\
    \ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\
    \ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\
    \ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\
    \ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\
    \ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\
    \ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\
    \ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, ", "    arr.each_with_index {|node,\
    \ index|\n        arr[index].even? ? arr[index].even? : arr[index].odd? ? arr[index].odd?\
    \ : arr.delete_at(index) }\n    return arr\nend", "  arr = arr.sort.to_a\n  arr.each\
    \ do |v|\n    return [v] if v % 2 == 0\n  end\nend", "    return arr.reduce(:<<)\n\
    end\n</cell>\n<code language=julia-1.3>\narr=collect(0:10000)\n</cell>\n<code\
    \ language=julia-1.3>\n@code_warntype pluck(arr)\n</cell>\n<text>\n1.6 Maximum\
    \ subarray", "  return nil\nend", "  return arr\nend", "    even_values = arr.select\
    \ {|e| e % 2 == 0}\n    even_values.sort.first\nend\n</cell>\n<code language=xeus-cling-cpp14>",
  "  return [] if arr.empty? or arr.uniq.empty?\n  arr.uniq.sort do |x, y|\n    if\
    \ x.even?\n      x.to_i\n    else\n      y.to_i\n    end\n  end\nend", "    #\
    \ Your code here\n    result = []\n    even = arr.select {|a| a % 2 == 0} \n \
    \   even.each do |val| \n        if result.length > 0 && result[result.length-1][1]\
    \ < val \n            result << [ result[result.length-1][1], result.length]\n\
    \        else \n            result << [ val, result.length ]\n        end\n  \
    \  end \n    \n    return result\nend\n</cell>\n<text>\nPractice\nLet's see some\
    \ practice with pluck ...", "  arr.sort\n  smallest_value = arr[0]\n  smallest_index\
    \ = 0\n  index_of_smallest_value = 0\n  arr.each_index do |i|\n    if arr[i] ==\
    \ smallest_value\n      index_of_smallest_value = i\n    else\n      if smallest_value\
    \ % 2 == 0\n        smallest_value = arr[i]\n        smallest_index = i\n    \
    \  end\n    end\n  end\n  if index_of_smallest_value != 0\n    smallest_value\
    \ = arr[index_of_smallest_value]\n  end\n  [smallest_value, smallest_index]\n\
    end", "  return [] if arr.length < 1 || arr.length == 0 || !arr.last.is_even\n\
    \  node = nil\n  arr.each_with_index do |item, index|\n    break if item.is_even\n\
    \    node = item\n  end\n  [ node.value, index ] if node\nend\n---", "    arr.each\
    \ do |x|\n        if x.even? and arr.count > 1\n            smallest = arr[0]\n\
    \            index = -1\n            arr.each do |y|\n                if y.even?\
    \ and y.value <= smallest.value\n                    smallest = y\n          \
    \          index = arr.index(y)\n                end\n            end\n      \
    \      return [ smallest.value, index ]\n        end\n    end\nend", "    arr.sort!\n\
    \    evens = arr[0..arr.length].select { |v| v % 2 == 0 }\n    evens.min! unless\
    \ evens.empty?\n    evens.min! if evens.size > 1\n    evens.min! { |a, b| a <=>\
    \ b } if evens.size > 1\n    evens\nend", "    # first, find the smallest even\
    \ value\n    smallest_value = arr[0]\n    smallest_index = -1\n    for ele in\
    \ arr\n        if ele % 2 == 0\n            smallest_value = ele\n           \
    \ smallest_index = arr.index(ele)\n            arr = arr.delete(smallest_index)\n\
    \            break\n    end\n    # if the given array is empty, return an empty\
    \ array\n    return [] if arr.empty?\n    # otherwise, we will return the smallest\
    \ even value and the index\n    [smallest_value, smallest_index]\nend", "  return\
    \ min( arr.map { |x| [x.even? ? 0 : x.even, x.index] }, :key => &:first ).last\n\
    end", "    # Your code here\n    pluck.index = 0;\n    pluck.value = arr[0];\n\
    \    pluck.even = 0;\n    pluck.odd = 0;\n    pluck.evenIndex = 0;\n    pluck.oddIndex\
    \ = 0;\n    pluck.evenNode = [];\n    pluck.oddNode = [];\n    \n    for node\
    \ in arr\n        if node % 2 == 0\n            pluck.even++;\n            pluck.evenNode.push(node);\n\
    \            pluck.evenIndex++;\n        else if node % 2 != 0\n            pluck.odd++;\n\
    \            pluck.oddNode.push(node);\n            pluck.oddIndex++;\n    end\n\
    \    if pluck.even != 0\n        if pluck.evenIndex < pluck.evenNode.length\n\
    \            pluck.value = pluck.evenNode[pluck.evenIndex];\n        else\n  \
    \          pluck.value = pluck.evenNode[pluck.evenNode.length];\n    end\n   \
    \ if pluck.odd != 0\n        if pluck.oddIndex < pluck.oddNode.length\n      \
    \      pluck.value = pluck.oddNode[pluck.oddIndex];\n        else\n          \
    \  pluck.value = pluck.oddNode[pluck.oddNode.length];\n    end\n    return [pluck.value,\
    \ pluck.index]\nend", "  arr.sort!\n  even_index = (0...arr.length).find { |i|\
    \ arr[i] % 2 == 0 }\n  if even_index\n    [arr[even_index], even_index]\n  else\n\
    \    []\n  end\nend", "  arr.each_with_index.min.min\nend", "  plucked = []\n\
    \  arr.each do |x|\n    if x % 2 == 0\n      plucked << x\n    end\n  end\n  plucked.sort!\n\
    \  plucked\nend", "    return arr.select { |x| x % 2 == 0 }.sort[:1] if arr.length\
    \ > 0\n    []\nend", "  min, max = arr.min, arr.max\n  arr.sort {|x, y| y <=>\
    \ x} if arr.size > 0\n  arr.each do |x| return [x, arr.index(x) if x.even?] if\
    \ x.odd?\n  [min, arr.index(min)]\nend", "  min = nil\n  arr.each do |e|\n   \
    \ if min == nil or min > e\n      min = e\n    end\n  end\n  return [min, arr.index{|e|\
    \ e == min ? 0 : e}]\nend", "  arr.sort!\n  arr.uniq.sort!", "  return nil if\
    \ arr.empty?\n  smallest_value_index = nil\n  smallest_value = arr[0]\n  arr.each_with_index\
    \ { |value, index|\n    if value < smallest_value \n      smallest_value = value\
    \ \n      smallest_value_index = index\n    end\n  }\n  return [smallest_value,\
    \ smallest_value_index] if smallest_value_index\n  return [smallest_value, smallest_value_index].compact\n\
    end", "  # your solution here\nend", "    arr.sort_by{|n| n.odd? ? n.value : n}\n\
    \    even = arr.find{|n| n.odd? }\n    even? ? [ even.value, even.index ] : []\n\
    end", "    arr.each_index.sort { |a, b|\n        a <=> b } # ascending order\n\
    \    arr.each { |n|\n        even = n.even?\n        next if even && (even !=\
    \ n.value) || (even && !n.value)\n        return [n] if even\n      }\n    return\
    \ []\nend", "  arr.sort!\n  arr.each_with_index do |node,i|\n    if node.even?\n\
    \      arr.pop\n      arr[i]\n    end\n  end\nend\n</cell>\n<cell>\n@test pluck([4,\
    \ 2, 3]) == [2, 1]\n@test pluck([1, 2, 3]) == [2, 1]\n@test pluck([]) == []\n\
    @test pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\n</cell>\n<text>\n4.2.8 Pluck! (Optional)\n\
    Given an array representing a branch of a tree that has non-negative integer nodes\n\
    your task is to pluck one of the nodes and return it.\nThe plucked node should\
    \ be the node with the smallest odd value.\nIf multiple nodes with the same smallest\
    \ odd value are found return the node that has smallest index.\nThe plucked node\
    \ should be returned in an array, [ smalest_value, its index ],\nIf there are\
    \ no odd values or the given array is empty, return [].\nExample 1:\n>>> pluck.call([4,\
    \ 2, 3])\n[2, 1]\nExplanation: 2 has the smallest odd value, and 2 has the smallest\
    \ index.\nExample 2:\n>>> pluck.call([1, 2, 3])\n[2, 1]\nExplanation: 2 has the\
    \ smallest odd value, and 2 has the smallest index.\nExample 3:\n>>> pluck.call([])\n\
    []\nExample 4:\n>>> pluck.call([5, 0, 3, 0, 4, 2])\n[0, 1]\nExplanation: 0 is\
    \ the smallest value, but  there are two zeros,\nso we will choose the first zero,\
    \ which has the smallest index.\nConstraints:\n* 1 <= nodes.length <= 10000\n\
    * 0 <= node.value", "    even = []\n    smalest_value = 0\n    smallest_index\
    \ = 0", "  min_val, min_idx = nil, nil\n  arr.each_with_index do |val, idx|\n\
    \    min_val = val if val % 2 == 0\n    min_idx = idx if val == min_val\n  end\n\
    \  return min_val, min_idx if min_val and min_idx\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nYou got it wrong `[1, 0, 3, 0]` should return `[0, 2]` but your\
    \ solution returns `[0, 1]`. Correct answer would be `[0, 2]` which means `1`\
    \ is the smallest even value, while `0` is the smallest even value.\n<|/ c |>\n\
    <| c |>\nI edited my answer, check it out. Thanks for mentioning it.\n<|/ c |>\n\
    <| c |>\nI like your answer, but if you don't mind a bit of reformatting, I can\
    \ see that the goal of the question was to find the smallest even number in the\
    \ array. The first example returns `[2, 1]` but the example in the question should\
    \ return `[1, 0]` -- a number that is not even.\n<|/ c |>\n<| c |>\nYou are right,\
    \ my bad. I thought that `plucked_value` is actually the original array and `plucked_idx`\
    \ is the position of the plucked value. Thanks for the note. I'll update my answer.\n\
    <|/ c |>\n<| c |>\nI edited my answer, please take a look. Thanks for the note.\
    \ :)\n<|/ c |>\n<| a |>\nHere's one approach which utilizes Enumerable#min_by\
    \ to find and return the smallest odd value in the array:\n<code>\nrequire 'set'",
  "  # Your code here\n  arr\nend", "  arr_size = arr.size\n  if arr.nil? || arr_size\
    \ < 1\n    return []\n  end", "\tsmall, small_index = -10000, -1\n\tsmall_index\
    \ = -1\n\tarr.each do |el|\n\t\tif el % 2 == 0\n\t\t\tsmall = el\n\t\t\tsmall_index\
    \ = el\n\t\telsif el == small\n\t\t\tsmall_index = el\n\t\tend\n\tend\n\treturn\
    \ [small, small_index] if small_index != -1\n\treturn []\nend", "  arr ||= []\n\
    \  smallest_value , smallest_index , current_value = arr.min_by {|n| n.even? }\n\
    \  if current_value.even?\n    [current_value, current_index] \n  else\n    smallest_index.zero?\
    \ ? [] : [smallest_value, smallest_index]\n  end\nend", "  return nil if arr.empty?\n\
    \  smallest, index = arr.min_by { |v| v.even? }\n  smallest_value = smallest.value\n\
    \  [smallest_value, index]\nend", "    smallest_value = nil\n    smallest_index\
    \ = -1\n    arr.each_with_index do |n, i|\n        if n % 2 == 0\n           \
    \ if smallest_value.nil? || smallest_value < n\n                smallest_value\
    \ = n\n                smallest_index = i\n            end\n        end\n    end\n\
    \    if smallest_value == nil\n        return []\n    end\n    arr [smallest_value,\
    \ smallest_index]\nend\n</cell>\n<cell>", "  if arr.length == 0\n    return []\n\
    \  min_index = 0\n  smallest_value = arr[0]\n  arr.each {|v|\n    if v % 2 ==\
    \ 0\n      smallest_value = v\n      min_index = arr.reject {|v| v % 2 == 0 }.index(v)\n\
    \    end\n  }\n  [ smallest_value, min_index ]\nend", "  len = arr.length\n  if\
    \ len <= 0\n    []\n  else\n    i = 0\n    while i < len\n      node = arr[i]\n\
    \      i += 1\n      if node % 2 == 0\n        node = arr[i]\n        i += 1\n\
    \      end\n      until i > len\n    end\n  end\nend", "  return min_max(arr,\
    \ arr.min{ |n| n%2 == 0 })\nend", "    \n    # Your code here\n    return []\n\
    \    \narr = [1, 9, 5, 3, 8]\nprint (pluck(arr))\narr = [4, 2, 3]\nprint (pluck(arr))\n\
    arr = [1, 2, 3]\nprint (pluck(arr))\narr = []\nprint (pluck(arr))\narr = [5, 0,\
    \ 3, 0, 4, 2]\nprint (pluck(arr))\narr = [1, 9, 5, 3, 8]\nprint (pluck(arr))\n\
    arr = [4, 2, 3]\nprint (pluck(arr))\narr = [1, 2, 3]\nprint (pluck(arr))\narr\
    \ = []\nprint (pluck(arr))\narr = [5, 0, 3, 0, 4, 2]\nprint (pluck(arr))\narr\
    \ = [1, 9, 5, 3, 8]\nprint (pluck(arr))\narr = [4, 2, 3]\nprint (pluck(arr))\n\
    arr = [1, 2, 3]\nprint (pluck(arr))\narr = []\nprint (pluck(arr))\narr = [5, 0,\
    \ 3, 0, 4, 2]\nprint (pluck(arr))\narr = [1, 9, 5, 3, 8]\nprint (pluck(arr))\n\
    arr = [4, 2, 3]\nprint (pluck(arr))\narr = [1, 2, 3]\nprint (pluck(arr))\narr\
    \ = []\nprint (pluck(arr))\narr = [5, 0, 3, 0, 4, 2]\nprint (pluck(arr))\narr\
    \ = [1, 9, 5, 3, 8]\nprint (pluck(arr))\narr = [4, 2, 3]\nprint (pluck(arr))\n\
    arr = [1, 2, 3]\nprint (pluck(arr))\narr = []\nprint (pluck(arr))\narr = [5, 0,\
    \ 3, 0, 4, 2]\nprint (pluck(arr))\narr = [1, 9, 5, 3, 8]\nprint (pluck(arr))\n\
    arr = [4, 2, 3]\nprint (pluck(arr))\narr = [1, 2, 3]\nprint (pluck(arr))\narr\
    \ = []\nprint (pluck(arr))\narr = [5, 0, 3, 0, 4, 2]\nprint (pluck(arr))\narr\
    \ = [1, 9, 5, 3, 8]\nprint (pluck(arr))\narr = [4, 2, 3]\nprint (pluck(arr))\n\
    arr = [1, 2, 3]\nprint (pluck(arr))\narr = []\nprint (pluck(arr))\narr = [5, 0,\
    \ 3, 0, 4, 2]\nprint (pluck(arr))\narr = [1, 9, 5, 3, 8]\nprint (pluck(arr))\n\
    arr = [4, 2, 3]\nprint (pluck(arr))\narr = [1, 2, 3]\nprint (pluck(arr))\narr\
    \ = []\nprint (pluck(arr))\narr = [", "  arr.each do |x|\n    if x.is_even\n \
    \     return [x, arr.index(x.next)]\n    end\n  end\n  return []\nend", "    smallest_value\
    \ = arr.min {|a, b| (a % 2) == (b % 2)}\n    even_index = 0\n    arr.each_index\
    \ {|i| if arr[i] % 2 == 0 then even_index = i end}\n    return [smallest_value,\
    \ even_index]\nend", "  arr.sort_by{|x| x.odd?}\n  if arr.empty?\n    []\n  else\n\
    \    arr[0].even? ? [arr[0]] : arr[1..-1].map{|x| [x, arr.index(x)]}\n  end\n\
    end", "  return arr[0] if arr[0]%2==0 else arr.min_by{|x| x%2}.index+1 if arr.any?\
    \ { |x| x%2==0 }\nend", "    # initialize max\n    max_value = 0\n    # initialize\
    \ min\n    min_value = 0\n    # initialize result\n    result = []\n    # traverse\
    \ all nodes in the given array\n    for i in arr\n        # get the minimum even\
    \ value so far\n        if i & 1 == 1\n            if max_value < i\n        \
    \        max_value = i\n            else\n                # if max is also even,\
    \ update min\n                if min_value == 0\n                    min_value\
    \ = i\n                elsif min_value > i\n                    min_value = i\n\
    \            # add the current node to result\n            result.push i\n   \
    \     else # if i is odd, push it to the result and update min\n            if\
    \ min_value == 0\n                min_value = i\n            elsif min_value >\
    \ i\n                min_value = i\n            result.push i\n    end\n    #\
    \ return the result with min and max value\n    return [ min_value, max_value\
    \ ], result\nend", "  arr.group_by {|n| n % 2 == 0}.values.sort_by(&:first).last\n\
    end", "  return arr.sort.min{|a, b| b.even? ? a : b}\nend", "  minimum_value =\
    \ minimum_index(arr)\n  plucked_value = arr[minimum_value]\n  index = minimum_value\n\
    \  while minimum_value.even? && minimum_value.odd?\n    minimum_value += minimum_value.next_even\n\
    \    plucked_value = arr[minimum_value]\n    index += 1\n  end\n  return [plucked_value,\
    \ index]\nend", "    arr.sort!\n    index = arr.index(arr.min)\n    arr[index]\n\
    end", "  return arr.reduce(min_even_value, [nil, 0])[1]\nend", "  arr.sort! {\
    \ |a,b| a<b }\n  result = arr.find_all { |e| e%2 == 0 }.max\n  return result if\
    \ result.is_a?(Integer)\n  result = [result, arr.find_index {|e| e%2 == 0}]\n\
    \  result.min\nend", "  sorted = arr.sort\n  even = []\n  arr.each do |x|\n  \
    \  if x.odd?\n      even << x\n    else\n      sorted = sorted.select { |y| y.even?\
    \ }\n      if sorted.size == 0\n        even = []\n      else\n        sorted\
    \ = sorted.sort { |x, y| y.odd? ? -1 : (x.odd? ? 1 : y) }\n      end\n    end\n\
    \  end\n  if sorted.empty?\n    even = []\n  end\n  sorted = sorted.sort_by {\
    \ |x| x.odd? ? 1 : x.even? ? -1 : 0 }\n  if sorted.size == 0\n    even = []\n\
    \  end\n  return sorted[0]\nend\n</code>\n<|/ a dscore=0 tags=ruby,arrays,algorithm\
    \ |>\n<| c |>\nThis algorithm will fail if the array has multiple even values,\
    \ as it will always return the last even value. Your description indicates that\
    \ it should return the first even value, but the sample output above seems to\
    \ indicate that it should return the second even value, so I'm assuming that's\
    \ wrong?\n<|/ c |>\n<| c |>\nIf there are multiple even values, then that means\
    \ that there were zero even values before finding the first even value; that means\
    \ either `sorted.empty?` is true or that `even` is empty. Regardless, there should\
    \ never be two even values at the same index. Also, I think your logic is wrong\
    \ there; I think the sample output should be `[0, 1]` instead of `[1, 0]`. The\
    \ second value has the smallest index, but the value with the smallest index is\
    \ always even.\n<|/ c |>\n<| c |>\nI think you are right. Updated my answer.\n\
    <|/ c |>\n<| c |>\nYou probably meant `x.odd? ? 1 : x.even? ? -1 : 0` instead\
    \ of `(x.odd? ? 1 : x.even?) ? -1 : 0`.\n<|/ c |>\n<| a dscore=0 |>\n<code>",
  "    return arr[0] if arr.uniq.sort.select { |x| x % 2 == 0 }.last == arr.uniq.sort.select\
    \ { |x| x % 2 == 0 }.first\nend", "  arr.sort!\n  even_index = arr.index(arr.min)\
    \ while even_index == arr.min do even_index = arr.index(arr.min) end\n  even_value\
    \ = arr[even_index]\n  arr.delete_at(even_index)\n  return [even_value,even_index]\n\
    end", "  even = arr.select(&:even?)\n  return even.first if even.length == 1 &&\
    \ even.any?\n  even = even.sort\n  even.each_with_index { |n,i| return [n, i]}\n\
    end", "  arr.sort\n  min, idx = arr.first, arr.index {|x| x.even?}\n  if min ==\
    \ nil || arr.length == 0\n    return []\n  end\n  [min, idx]\nend\n</cell>\n<text>\n\
    \_BackTracking\nWe are given an n x n grid with elements that can have one of\
    \ 4 possible values: 1, 2, 3, or 4. If at any point, there is a 1 present, we\
    \ cannot make further moves; else, we can. Furthermore, at each location we know\
    \ if any number along the path exists or not (except for 1). Return the final\
    \ path that results from backtracking.", "  evens = arr.select {|x| x%2 == 0 }\n\
    \  evens.min_by {|x| x}\nend", "  n = arr.length\n  arr.each_with_index do |value,\
    \ index|\n    if value < 2 * n\n      arr[index] = value\n    end\n  end\n  arr.min_index\n\
    end", "  arr.sort\n  even = [0, 2, 4, 6, 8].find { |x| arr.include?(x) }\n  [even,\
    \ arr.index(even)]\nend", "  min_value = nil\n  smallest_index = nil\n  arr.each\
    \ do |x|\n    if min_value.nil? or min_value > x\n      min_value = x\n    end\n\
    \    if x == min_value and smallest_index.nil? or smallest_index > x\n      smallest_index\
    \ = x\n    end\n  end\n  [min_value, smallest_index]\nend", "    arr.each do |node|\n\
    \        arr.delete_at(arr.index(node)) if node.even? && arr.index(node) < arr.index(node.next)\n\
    \    end\nend", "    arr.sort!\n    res = []\n    arr.each { |node| res << [ node,\
    \ arr.index( node )] }\n    res.select { |node| node.first.even? }.min.last\n\
    end", "    arr.each_index do |i|\n        arr[i].even? ? return [arr[i].even_value,i]\n\
    \    end\n    return []\nend\n<|/ file source=github |>\n<| c |>\nI really like\
    \ this approach for finding the 'smallest index' of the element that has the smallest\
    \ even value. Is it possible to do this without returning an array? Could I somehow\
    \ get the indices of the minimum elements to then use them to get the minimum\
    \ of the smallest element and corresponding index? Thanks so much for your help!\n\
    <|/ c |>\n<| c |>\nYes, you could do it by finding the minimum value in an array\
    \ without returning an array or by creating a new array of the minimum values\
    \ and its index.\n<|/ c |>\n<| c |>\nSee my updated answer for one way to find\
    \ the minimum values and indexes without returning an array.\n<|/ c |>\n<| a tags=arrays,ruby\
    \ dscore=1 |>\nHere are two methods that return values with an index and without\
    \ returning an array. \n<code>", "  even_values = []\n  i = 0\n  length = arr.length\n\
    \  while (i < length)\n    if arr[i] % 2 == 0\n      even_values.push(arr[i])\n\
    \    end\n    i += 1\n  end\n  \n  if even_values.length > 0\n    even_values.sort!\n\
    \    smallest_index = even_values.length - 1\n    smallest_value = even_values[smallest_index]\n\
    \    smallest_value_index = i\n    i = 0\n    while (i < length)\n      if arr[i]\
    \ == smallest_value\n        smallest_index = i\n      end\n      i += 1\n   \
    \ end\n    \n    return [smallest_value, smallest_index]\n  end\n  \n  return\
    \ []\nend", "  min = arr[0]\n  index = 0\n  arr.each_index do |i|\n    if arr[i]\
    \ % 2 == 0\n      min = arr[i] if arr[i] < min\n    end\n  end\n  [min, index]\n\
    end", " \n    largest = arr[0]\n    smallest = arr[0]\n    smallest_index = arr[0]\n\
    \    \n    arr.each_with_index do |node,index|\n        if node.even? == true\n\
    \            if smallest > node.value\n                largest = node.value\n\
    \                smallest = node.value\n                smallest_index = index\n\
    \            end\n        end\n    end", "  puts \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n  your task is to pluck\
    \ one of the nodes and return it.\n  The plucked node should be the node with\
    \ the smallest even value.\n  If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n  The plucked node should\
    \ be returned in an array, [ smalest_value, its index ],\n  If there are no even\
    \ values or the given array is empty, return [].\n  Example 1:\n  >>> pluck.call([4,\
    \ 2, 3])\n  [2, 1]\n  Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n  Example 2:\n  >>> pluck.call([1, 2, 3])\n  [2, 1]\n  Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n  Example 3:\n\
    \  >>> pluck.call([])\n  []\n  Example 4:\n  >>> pluck.call([5, 0, 3, 0, 4, 2])\n\
    \  [0, 1]\n  Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \  so we will choose the first zero, which has the smallest index.\n  Constraints:\n\
    \  * 1 <= nodes.length <= 10000\n  * 0 <= node.value\n  \"\nend", "  return arr.sort.find\
    \ {|i| i%2 == 0} if arr.any?\n  return []\nend\n</cell>\n<cell>\npluck.([1, 2,\
    \ 3])\n</cell>\n<cell>\npluck.([4, 2, 3])\n</cell>\n<cell>\npluck.([5, 0, 3, 0,\
    \ 4, 2])\n</cell>\n<cell>\npluck.([])\n</cell>\n<cell>\npluck.([nil, nil, nil,\
    \ nil, nil])\n</cell>\n<text>\nPluck", "    arr.sort!\n    arr.each_with_index\
    \ do |node, index|\n        if index == 0\n            return node\n        end\n\
    \        node2 = arr[index-1]\n        if node % 2 == 0 && node2 % 2 == 0 && node2\
    \ < node\n            return node2\n        end\n    end\nend\n</cell>\n<code\
    \ language=julia-0.6>\nfunction pluck_solution(arr)\n    arr.sort!\n    arr.each_with_index\
    \ do |node, index|\n        if index == 0\n            return node\n        end\n\
    \        if node % 2 == 0 && arr[index-1] % 2 == 0\n            return arr[index-1]\n\
    \        end\n    end\nend\n</cell>\n<code language=julia-0.6>", "    even = arr.select\
    \ {|e| e % 2 == 0}\n    even.min\n  end", "    smallest_value = arr[0]\n    smallest_index\
    \ = 0\n    \n    arr.each do |node|\n        if(node%2 == 0)\n            smallest_value\
    \ = node\n            smallest_index = node\n        end\n    end", "  min_value\
    \ = nil\n  min_value = arr[0]\n  arr.each do |num|\n    if num == min_value %\
    \ 2 == 0\n      min_value = num\n    end\n  end\n  [ min_value, arr.index(min_value)\
    \ ]\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
