name: HumanEval_33_sort_third
language: rb
prompt: "# This function takes an array l and returns an array l' such that\n# l'\
  \ is identical to l in the indicies that are not divisible by three, while its values\
  \ at the indicies that are divisible by three are equal\n# to the values of the\
  \ corresponding indicies of l, but sorted.\n# >>> sort_third.call([1, 2, 3])\n#\
  \ [1, 2, 3]\n# >>> sort_third.call([5, 6, 3, 4, 8, 9, 2])\n# [2, 6, 3, 4, 8, 9,\
  \ 5]\ndef sort_third(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_third\n\
  \    candidate = method(:sort_third)\n    assert_equal([2, 6, 3, 4, 8, 9, 5], candidate.call([5,\
  \ 6, 3, 4, 8, 9, 2]))\n    assert_equal([2, 8, 3, 4, 6, 9, 5], candidate.call([5,\
  \ 8, 3, 4, 6, 9, 2]))\n    assert_equal([2, 6, 9, 4, 8, 3, 5], candidate.call([5,\
  \ 6, 9, 4, 8, 3, 2]))\n    assert_equal([2, 6, 3, 4, 8, 9, 5, 1], candidate.call([5,\
  \ 6, 3, 4, 8, 9, 2, 1]))\n  end\nend\n"
completions: ["\tl.each_with_index do |v, i|\n\t\tl[i] = [v, i] if i % 3 == 0\n\t\
    end\n\tl.sort\n\tl.each_with_index do |v, i|\n\t\tl[i] = l[i][0]\n\tend\n\treturn\
    \ l\nend", "  l.sort!\n  l.reject! {|x| x % 3 == 0}\n  l\nend", "  l.sort\n  new_l\
    \ = l\n  new_l.each_with_index do |e, i|\n    if (i % 3) == 0\n      new_l[i]\
    \ = e\n    end\n  end\n  return new_l\nend\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ dscore=0 |>\n<| c |>\nThank you. This worked for me. I'm new to Ruby and this\
    \ was really helpful.\n<|/ c |>\n<| a tags=ruby,sorting,arrays |>\nYou could just\
    \ use the sort_by method and pass a block to it.\n<code>\narray.sort_by{ |i| i\
    \ % 3 }\n</code>\nThe block will take each element of array and compare it to\
    \ other elements of the array. It will compare the element with each of the other\
    \ elements to find the one that remains sorted.\n<|/ a dscore=0 |>\n<| a tags=ruby,sorting,arrays\
    \ |>\nIn ruby, it is very useful to have a function which does what you want,\
    \ and which you can reuse elsewhere as well.\n<code>", "  l = l.sort\n  (0 ..\
    \ l.length).map { |i| l[i] % 3 == 0 ? l[i] : l[i..i-1].sort}.flatten\nend\n</code>\n\
    <|/ a tags=ruby,arrays,sorting |>\n<| a tags=ruby,arrays,sorting |>\nThis seems\
    \ to work:\n<code>\na = [5,6,3,4,8,9,2]\na.sort_by {|x| x % 3 == 0 }\n</code>\n\
    <|/ a dscore=2 |>\n<| a |>\n<code>\na = [5,6,3,4,8,9,2]\na.sort_by { |e| (e %\
    \ 3) ? e : a.reverse }\n</code>\n<|/ a dscore=2 tags=ruby,arrays,sorting |>\n\
    <| a dscore=1 tags=ruby,arrays,sorting |>\n<code>\na = [5,6,3,4,8,9,2]\na.sort_by{|i|\
    \ i%3==0 ? i : a.size-i}", "  return l if l.size == 3 && l[0] == l[1] == l[2]\
    \ && l[0] != l[1] && l[0] != l[2] && l[1] != l[2] || l.size < 3 || l.size == 3\
    \ && l[0] == l[1] && l[0] != l[2] || l.size == 3 && l[1] == l[2] && l[0] != l[1]\
    \ && l[0] != l[2] || l.size == 3 && l[0] == l[2] && l[0] != l[1] && l[0] != l[2]\
    \ || l.size == 3 && l[1] == l[2] && l[1] != l[2] && l[0] != l[1] && l[0] != l[2]\
    \ || l.size == 3 && l[2] != l[1] && l[0] != l[2] && l[0] != l[1] && l[0] != l[2]\
    \ || l.size == 3 && l[2] != l[2] && l[0] != l[1] && l[0] != l[1] && l[0] == l[2]\
    \ && l[1] == l[2]\nend", "  # Write your code here\n  return l\nend\n</cell>\n\
    <text>\nChallenge 12 (10 Points)\nCreate a function called sort_fourth that takes\
    \ an array l and returns an array l' such that\nl' is identical to l in the indicies\
    \ that are not divisible by four, while its values at the indicies that are divisible\
    \ by four are equal\nto the values of the corresponding indicies of l, but sorted.\n\
    >>> sort_fourth.call([1, 2, 3])\n[1, 2, 3]\n>>> sort_fourth.call([5, 6, 3, 4,\
    \ 8, 9, 2])\n[2, 3, 4, 6, 8, 9, 5]\n>>> sort_fourth.call([6, 7, 8, 9, 10, 5])\n\
    [5, 6, 7, 8, 9, 10, 6]\n>>> sort_fourth.call([1, 2, 3, 4, 5, 6, 7, 8, 9])\n[1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9]\n>>> sort_fourth.call([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])\n\
    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n>>> sort_fourth.call([10, 9, 8, 7, 6, 5, 4, 3, 2,\
    \ 1])\n[1, 2, 3, 4, 5, 6, 7, 8, 9]", "  sort_third(l).each { |i| l[i] -= 3 if\
    \ l[i] % 3 == 0 }\n  l\nend", "    l.each_with_index do |x, i|\n        if l.size\
    \ % 3 == 0\n            if l.size % 2 == 0\n                l.insert(i, l[i %\
    \ 3])\n            else\n                l.insert(i, l[i % 3])\n             \
    \   l.insert(i, l[(i - l.size % 3) % 3])\n            end\n        else\n    \
    \        if l.size % 2 == 0\n                l.insert(i, l[i % 3])\n         \
    \       l.insert(i, l[(i - l.size % 3) % 3])\n                l.insert(i, l[((i\
    \ - l.size % 3) % 3) + 1])\n            else\n                l.insert(i, l[i\
    \ % 3])\n                l.insert(i, l[(i - l.size % 3) % 3])\n            end\n\
    \        end\n    end\nend", "  l.each_with_index { |v, i| l[i] = v if v % 3 ==\
    \ 0 and (v != i or i != (i+1)) }\n  l.sort\n  l\nend", "  l.each_with_index do\
    \ |v, i|\n    if i % 3 == 0\n      l[i] = l[i/3]\n    end\n  end\nend", "\tl.sort\
    \ do |a, b|\n\t\tb % 3 ? (a % 3 ? -1 : 1) : (b % 3 ? 1 : -1)\n\tend\nend", " \
    \ l.each_with_index { |e, i|\n    divisible_by_three? i ? l[i] = e : l[i] = e\
    \ }\n  l\nend\n</code>\nThen I defined a module to hold the functionality of sorting\
    \ a collection of arrays in descending order of their third values:\n<code>\n\
    module Sort\n  extend self", "  l1 = l.clone\n  l1.delete_if { |x| x % 3 == 0\
    \ }\n  l1.sort\n  l1.each_with_index { |x, i| l1[i] = l1.find_index(&:==x).last\
    \ }\n  l1\nend\n</code>\n<|/ a |>\n<| c |>\nThis is an interesting solution, but\
    \ it doesn't actually answer the question. Sort by *values* instead of *indices*,\
    \ which is what the original poster asked for.\n<|/ c |>\n<| c |>\nI missed the\
    \ part about indices being divisible by three. I've edited my answer to include\
    \ a solution for that also.\n<|/ c |>\n<| c |>\nAwesome solution, didn't know\
    \ that `delete_if` can take two arguments.\n<|/ c |>\n<| c |>\n, `delete_if` does\
    \ take two arguments, but I see what you mean. I should have used `delete_if!`\
    \ to indicate that it modifies the original object.\n<|/ c |>\n<| c |>\nWow! Very\
    \ clever. :) I just had a quick question: What is the advantage of using `delete_if`\
    \ instead of `delete_if!`?\n<|/ c |>\n<| a dscore=1 |>\nI came up with this:\n\
    <code>", "  l.each_with_index do |e, i|\n    (i%3 == 0) && (l[i] = l[i])\n  end\n\
    \  return l\nend", "  l.reject { |x| x % 3 == 0 }.sort.each do |i|\n    l[i] <=>\
    \ l[i] <=> l[i]\n  end\nend\n</cell>\n<code language=julia-1.0>", "  l.each_with_index\
    \ do |val, index|\n    l[index] =  val if (index % 3 == 0)\n  end\n  l.sort!\n\
    \  l\nend\n</cell>\n<cell>", "    l = l.clone\n    l.sort! { |a, b| b % 3 == 0\
    \ ? a : b }\n    l.uniq!\n    l.sort_by! {|i| i / 3 }\n    l << l[0]\nend", " \
    \ l.each_with_index do |value, index|\n    divisible_by_three = index % 3 == 0\n\
    \    divisible_by_three = l[divisible_by_three] if divisible_by_three\n    value\
    \ << l[divisible_by_three] if divisible_by_three\n    next if l[index] == value\n\
    \    l[index] = value\n  end\n  l\nend\n</cell>\n<text>\nTest our sort_third function",
  "  l = l.to_a\n  l.map!{ |i| if i % 3 != 0 then i else i+1 end }\n  l.sort_by {\
    \ |i| i }\n  l\nend", "  l.sort {|a, b| b % 3 == 0 ? b : -(-b % 3)}\nend\n</code>\n\
    And if you don't want to modify the original array, you can use sort_by.\n<code>",
  "  # Initialize l to a list with empty lists\n  l = [[]] unless l\n  # Iterate through\
    \ the indicies of l, appending each element to the corresponding list of l\n \
    \ l.each do |indice_of_l|\n    l[indice_of_l] << indice_of_l unless indice_of_l\
    \ % 3 == 0\n  end\n  # Return the new sorted list\n  l\nend\n</cell>\n<cell>",
  "  l.sort {|x, y| y % 3 == 0 ? x : y}\n  l\nend", "  l.map! {|n| n % 3 != 0 ? n\
    \ : n * (n / 3)}\n  l.sort!\n  l\nend\n</code>\n<|/ a dscore=1 tags=ruby |>\n\
    <| c |>\nThanks for the help but I've just started learning Ruby so I haven't\
    \ got that far yet. But I appreciate it.\n<|/ c |>\n<| a |>\n<code>", "  l.map\
    \ { |i| l.delete_at(i) if i % 3 != 0 }.sort!\n  l\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nI didn't downvote you, but I guess it was because you did not show\
    \ any effort in finding a solution. Please read this [how-to-ask](https://stackoverflow.com/help/how-to-ask)\
    \ and follow the guidelines there to improve your question.\n<|/ c |>\n<| a tags=ruby\
    \ |>\nA very simple and efficient solution based on insertion sort:\n<code>",
  "  l = l.sort\n  l.each_with_index do |value, index|\n    if index % 3 == 0\n  \
    \    value = l[index + 1]\n    end\n    l[index] = value\n  end\n  l\nend", " \
    \ l.sort.with_index do |v, i|\n    if i % 3 == 0\n      v\n    else\n      l.delete_at(i)\n\
    \    end\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nThis is pretty neat. I'm surprised\
    \ `sort_by` doesn't have a default block to sort with though.\n<|/ c |>\n<| a\
    \ |>\n<code>\nl.chunk{|x| x % 3 == 0}\n</code>\n<|/ a tags=ruby dscore=2 |>\n\
    <| a tags=ruby |>\nAnother solution:\n<code>\nl.collect {|x| x % 3 == 0 ? x :\
    \ nil}.compact\n</code>\n<|/ a dscore=2 |>\n<| a |>\nAnother solution, with Array#delete_if:\n\
    <code>", "  l.each_with_index { |v, i| l[i] = v if (i % 3 == 0) }\n  l.sort!\n\
    end\n</code>\n<|/ a dscore=1 tags=arrays,ruby |>\n<| c |>\nYour answer is very\
    \ helpful. Thank you!\n<|/ c |>\n<| c |>\nI find your answer more readable than\
    \ the answer that uses `sort!`; I find it more readable.  I would consider your\
    \ answer to be more idiomatic.  I wonder if you have a reason for preferring `sort_third`\
    \ over `sort_by_index`?  If not, then it would be better to choose the answer\
    \ that uses `sort_third`.\n<|/ c |>\n<| c |>\nI see `sort_third` more idiomatic,\
    \ but I'm really struggling to think of a reason why `sort_by_index` is better\
    \ than `sort_third`. I'd be interested in knowing a use case. Perhaps there is\
    \ something I don't see?\n<|/ c |>\n<| c |>\nAs a corollary, I find `sort_third`\
    \ more readable because it is more natural to me, and I'm not a Ruby expert so\
    \ maybe I was doing something wrong. `sort_by_index` on the other hand is a method\
    \ whose signature I have no idea how to search for. My only guess is that it's\
    \ some weird Ruby method that I don't normally use but I've never seen it before.\n\
    <|/ c |>\n<| c |>\nI suspect your guess is accurate, though I think you might\
    \ have found a slightly weirder situation: `sort_third` takes an array of arrays\
    \ and sorts the inner arrays by their first element.  `sort_by_index` is intended\
    \ to sort a hash by its values, so I think it might be more natural to think of\
    \ `sort_third` as sorting an array of hashes, whereas `sort_by_index` is sorting\
    \ an array of arrays.  I see `sort_third` more natural for an array of hashes,\
    \ but I'd be interested to see a use case where `sort_by_index` is preferable.\n\
    <|/ c |>\n<| a |>\n<code>", "  l.sort.tap { |a| a.chunk { |x| (x % 3 == 0).tap\
    \ { |y| (y.sort!).tap { |z| (z.reduce(:+) || z) } } }\nend\n</code>\n<|/ a |>\n\
    <| a |>\nYou can do this:\n<code>\narr = [1,2,3,4,5,6]\narr.sort!\narr.rotate!\n\
    </code>\n<|/ a tags=ruby dscore=4 |>\n<| c |>\nrotating means switching the last\
    \ element with the first element, and the last element with the first element\n\
    <|/ c |>\n<| a |>\nThis code sorts odd numbers in ascending order and even numbers\
    \ in descending order. \n<code>\n def sort_odd_and_even\n    a.sort_by{|x| (x\
    \ % 2 == 0).zero? ? (-x.abs) : x.abs} #sort odd numbers in ascending order\n \
    \   a.sort_by{|x| (x % 2 != 0).zero? ? (-x.abs) : x.abs} #sort even numbers in\
    \ descending order\n end\n</code>\n<|/ a tags=ruby dscore=3 |>\n<| a dscore=3\
    \ tags=ruby |>\nRuby has this built-in already. Use Enumerable#partition which\
    \ splits the array into two arrays, the first containing odd numbers and the second\
    \ containing even numbers. \n<code>\n[1, 2, 3, 4, 5, 6, 7, 8].partition { |n|\
    \ n % 2 == 0 }", "  l.each_with_index do |e, i|\n    next unless i % 3 == 0\n\
    \    l[i] = l[i].to_i\n  end\n  l.sort!\nend\n</code>\n<|/ a |>\n<| c |>\nThanks,\
    \ this helped me understand the issue! And your solution worked for me!\n<|/ c\
    \ |>\n<| a tags=arrays,sorting,ruby,hash |>\n<code>", "  l.sort!\n  l.each_with_index\
    \ do |x, i|\n    x.zero? ? i : x.zero? && (l[i] % 3 == 0) ? l.delete_at(i) : x\n\
    \  end\n  l\nend\n</code>\n<|/ a dscore=2 |>\n<| a |>\nHere's an implementation\
    \ in Ruby 1.9.3 which preserves order.\n<code>", "  l.sort!\n  l.reject! {|i|\
    \ i % 3 == 0 }\n  l.uniq.sort\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI like\
    \ this idea, but the result is not what I expected. For example, the expected\
    \ result of `sort_third` for `[1, 2, 3]` is `[1, 1, 2, 2, 3, 3]`, but it produces\
    \ `[1, 1, 2, 2, 3, 3]`. Can you provide an example where this would not be true\
    \ for you?\n<|/ c |>\n<| c |>\nIt produces `[1, 1, 2, 2, 3, 3]` because `3` is\
    \ divisible by three, while `2` is divisible by three, but not `1`. The same is\
    \ true for `[5, 6, 3, 4, 8, 9, 2]`, where `2` is divisible by three, but not `1`.\n\
    <|/ c |>\n<| c |>\nSorry for my confusion. I guess I got confused because I thought\
    \ the question was about sorting a non-divisible by 3 list. That case doesn't\
    \ seem to apply to this question. Thanks for your answer!\n<|/ c |>\n<| c |>\n\
    You're very welcome! Since that case was unclear in the OP's question I thought\
    \ I'd share my answer anyways, just in case you needed a solution for this problem\
    \ at some point in the future.\n<|/ c |>\n<| a |>\n<code>\na = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]",
  "  l.each_with_index do |x, i|\n    l.delete(i)\n    l.insert(i, x)\n    i += 1\n\
    \  end\n  l\nend", "  l.each_with_index do |x, i|\n    if i % 3 == 0\n      l[i]\
    \ = l[i]\n    else\n      l[i] = x[1..-1]\n    end\n  end\n  l\nend\n</code>\n\
    And here's an example:\n<code>\nl = sort_third([1, 2, 3, 5, 4, 6, 7, 8, 9])\n\
    </code>\nWhich gives me:\n<code>", "  l.each_with_index {|x, i| l[i] = x if x\
    \ % 3 == 0}\n  l\nend\n</code>\n<|/ a |>\n<| c |>\nThis is great but I'm a ruby\
    \ newbie, what would the call look like if I wanted to sort the array in descending\
    \ order ?\n<|/ c |>\n<| c |>\nThanks again for the help. I used a variation on\
    \ this method to sort a hash in ascending order. How would I sort a hash in descending\
    \ order (by most recent)? Ive tried using sort_by but it doesnt seem to work.\
    \ Thanks again\n<|/ c |>\n<| a |>\n<code>\na = [4,1,5,2,3]\nb = [4,1,5,2,3]\n\
    c = [4,1,5,2,3]", "  l.sort.call\n  indexes.each {|i|\n    if l[i] % 3 == 0\n\
    \      l[i-1] = l[i]\n      l[i+1] = l[i+1]\n      l[i] = l[i-1]\n    end\n  }\n\
    \  l\nend", "  l.sort! # Sort so all indicies are divisible by three\n  \n  l.each_with_index\
    \ do |i, index|\n    if index % 3 == 0\n      l.delete_at(index)\n    end\n  end\n\
    \  \n  l\nend\n</cell>\n<cell>", "  l.sort!\n  l.each_with_index do |val, ind|\n\
    \    next if ind % 3 == 0\n    l[ind] = 3 * ind + val\n  end\n  l\nend\nsort_third.call\
    \ l", "  sorted_array = l.clone\n  third = sorted_array.index(sorted_array.size\
    \ / 3) + 1\n  while third.zero?\n    third = sorted_array.index(sorted_array.size\
    \ / 3) + 1\n  end\n  sorted_array.slice!(third)\n  while third.zero?\n    third\
    \ = sorted_array.index(sorted_array.size / 3) + 1\n  end\n  sorted_array.slice!(third)\n\
    \  sorted_array\nend", "  l3 = l.dup\n  l3.sort!\n  l3.each_with_index do |elem,\
    \ i|\n    (i%3 == 0 ? l3[i] = elem : l3.delete_at(i))\n  end\n  return l3\nend\n\
    </code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nHere's a ruby version:\n<code>",
  "  return l.sort{|a, b| b[0 .. 2] <=> a[0 .. 2] }\nend", "  return l.sort_by { |n|\
    \ (n.to_f / 3).floor }\nend", "  l.sort!\n  l.each_with_index {|x, i| l[i % 3]\
    \ = x if x % 3 == 0}\n  l\nend", "  l.sort\n  l.each_index do |i|\n    if l[i]\
    \ % 3 == 0\n      l[i] = l[i] / 3\n    end\n  end\n  l\nend", "  l.sort\n  n =\
    \ l.length\n  l'.clear\n  for i in (0...n-1)\n    k = i / 3\n    if ((k % 3) !=\
    \ 0)\n      l'.push( l[i] )\n    else\n      l'.push( l[i] )\n    end\n  end\n\
    \  l'\nend", "  third = l.div(3)\n  result = l.clone\n  result[0, 0] = l[0, 0]\n\
    \  third.each do |ind|\n    if ind % 3 == 0\n      result[ind - 1, 0] = l[ind\
    \ - 1, 0]\n    end\n  end\n  result\nend", "  l.sort do |a,b|\n    a[a % 3] !=\
    \ b[b % 3] || a <=> b # this is to ensure the case where none of the values at\
    \ indicies are divisible by three\n  end\n  l\nend\n</cell>\n<cell>\nsort_third([1,\
    \ 2, 3])\nsort_third([5, 6, 3, 4, 8, 9, 2])\n</cell>\n<text>\nPractice Problem:\
    \ Permute the elements of an array in ascending order\nComplete the function permute\
    \ to return an array of all the elements of  array in ascending order.", "  l.sort!\n\
    \  l.each_with_index do |value, index|\n    if index % 3 == 0\n      l[index]\
    \ = value\n    end\n  end\n  l\nend", "  sorted = []\n  for i in l\n    if (i.to_i\
    \ % 3 == 0)\n      sorted.push(i)\n    else\n      sorted.push([i, i])\n     \
    \ sorted.sort.reverse.each do |j|\n        sorted.shift\n        sorted.push(j[0])\n\
    \      end\n    end\n  end\n  return sorted\nend\n</code>\n<|/ a |>\n<| c |>\n\
    The `sort` method should be avoided for large lists, and here it only needs to\
    \ do one pass through the list. There are some things you could do to improve\
    \ it, like storing the indexes in an array instead of an array, and not sorting\
    \ the array if it contains more elements than it should. Also, you can just use\
    \ `each_with_index` to save a lot of time. Also, you're not sorting the list,\
    \ you're sorting each element of it.\n<|/ c |>\n<| c |>\nThanks for the comments\
    \ and feedback. I changed it to be a lot more efficient. I also changed it to\
    \ use each_with_index instead of each and pushing each element to the sorted array\
    \ and then sorting it.\n<|/ c |>\n<| c |>\nOk, I figured out how to avoid the\
    \ O(n^2) complexity and got it to work by using a for loop and an array. Here\
    \ is the code: `def sort_third(l) sorted = [] indexes = [] l.each_with_index do\
    \ |element, index| if (element.to_i % 3 == 0) index << index else index << index.first\
    \ end end for i in l index = index.sort.reverse sorted.push indexes[i] end return\
    \ sorted end`\n<|/ c |>\n<| a dscore=2 |>\n<code>\na = [1,2,3,4,5,6,7,8,9,0]\n\
    a.sort_by{|x| x.to_i}.reverse\n</code>\n<|/ a tags=sorting,ruby |>\n<| c |>\n\
    You don't need `reverse`, since that would sort numbers in descending order. Ruby's\
    \ default sorting order is ascending.\n<|/ c |>\n<| c |>\nThe question specifically\
    \ asked for descending order in his example, and it seems appropriate to provide\
    \ an answer in that form.\n<|/ c |>\n<| a dscore=2 |>\nA Ruby programmer would\
    \ use:\n<code>", "  l = sort_index(l)\n  \n  l1 = l.dup\n  l1.sort!\n  \n  for\
    \ i in 0...l1.size\n    if i %3 != 0\n      l1[i] = l1[i-3]\n    end\n  end\n\
    \  \n  return l1\nend\n</pre>\n</div>\n</div>\n</div>\n  \n<div class=\"cell border-box-sizing\
    \ text_cell rendered\"><div class=\"prompt input_prompt\">\n</div><div class=\"\
    inner_cell\">\n<div class=\"text_cell_render border-box-sizing rendered_html\"\
    >\n<p><em>Exercise</em></p>\n<ul>\n<li>Write a function that takes an array l\
    \ and returns an array l' such that\nl' is identical to l in the indicies that\
    \ are not divisible by three, while its values at the indicies that are divisible\
    \ by three are equal\nto the values of the corresponding indicies of l, but sorted.</li>\n\
    </ul>", "  l.sort\n  l.each_with_index do |num, idx|\n    l[idx] ||= 0\n  end\n\
    \  l\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby |>\nI like solving these\
    \ kind of problems recursively, because they have some advantages compared to\
    \ looping. However, I find them a bit verbose. Here is an example using recursion:\n\
    <code>", "  l.each do |n|\n    i = l.index { |m| n % 3 == m }\n    l[(i + 1) %\
    \ l.length] = n\n  end\n  l\nend", "  l.sort { |a, b| a % 3 == b ? b : (a % 3\
    \ != b) ? a : a + 1 }\nend", "  \n  # Return an unsorted copy of the passed list\n\
    \  return unsorted_copy(l)\nend", "  return [\n    l[0],\n    l[1],\n    l[2],\n\
    \  ]\nend", "\tl'.sort!\n\tl'.each_with_index do |v, i|\n\t\tunless i % 3 == 0\n\
    \t\t\tl'[i] = v\n\t\tend\n\tend\n\treturn l'\nend", "  l.sort! { |a, b| return\
    \ a == b ? 0 : a % 3 == b ? 1 : -1}\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=2\
    \ tags=ruby |>\nI used the method #sort to sort the original array and used a\
    \ helper method to determine which elements are in the correct position and which\
    \ elements are not.\n<code>", "  l.sort\n  l.each_with_index { |e, i| i % 3 ==\
    \ 0 && l[i] = l[i] }\nend", "  l = (l + [Inf, -Inf, -Inf]).sort\n  l[-1,2] = l[-2,2]\
    \ + l[-1,2]\n  l[-1,3] = l[-3,3] + l[-1,3]\n  l[-1,4] = l[-4,4] + l[-1,4]\n  l[-1,5]\
    \ = l[-5,5] + l[-1,5]\n  l[-1,6] = l[-6,6] + l[-1,6]\n  l[-1,7] = l[-7,7] + l[-1,7]\n\
    \  l[-1,8] = l[-8,8] + l[-1,8]\n  l[-1,9] = l[-9,9] + l[-1,9]\n  l[-1,10] = l[-10,10]\
    \ + l[-1,10]\n  l[-1,11] = l[-11,11] + l[-1,11]\n  l[-1,12] = l[-12,12] + l[-1,12]\n\
    \  l[-1,13] = l[-13,13] + l[-1,13]\n  l[-1,14] = l[-14,14] + l[-1,14]\n  l[-1,15]\
    \ = l[-15,15] + l[-1,15]\n  l[-1,16] = l[-16,16] + l[-1,16]\n  l[-1,17] = l[-17,17]\
    \ + l[-1,17]\n  l[-1,18] = l[-18,18] + l[-1,18]\n  l[-1,19] = l[-19,19] + l[-1,19]\n\
    \  l[-1,20] = l[-20,20] + l[-1,20]\n  l[-1,21] = l[-21,21] + l[-1,21]\n  l[-1,22]\
    \ = l[-22,22] + l[-1,22]\n  l[-1,23] = l[-23,23] + l[-1,23]\n  l[-1,24] = l[-24,24]\
    \ + l[-1,24]\n  l[-1,25] = l[-25,25] + l[-1,25]\n  l[-1,26] = l[-26,26] + l[-1,26]\n\
    \  l[-1,27] = l[-27,27] + l[-1,27]\n  l[-1,28] = l[-28,28] + l[-1,28]\n  l[-1,29]\
    \ = l[-29,29] + l[-1,29]\n  l[-1,30] = l[-30,30] + l[-1,30]\n  l[-1,31] = l[-31,31]\
    \ + ", "    three = l[3..-1]\n    three.each_with_index do |element, index|\n\
    \        l[index] = element\n    end\n    three.sort!\n    three.each_with_index\
    \ do |element, index|\n        l[index] = element\n    end\nend", "  l.sort\n\
    \  l.each_with_index do |e, i|\n    e = l[i] if e % 3 == 0\n    l[i] = e\n  end\n\
    \  l\nend", "  l.sort_by!\n  l = l % 3\n  l[0] = (l[0] + l[1]) / 2\n  l[1] = (l[0]\
    \ + l[1]) / 2\n  l[2] = (l[0] + l[1]) / 2\n  l\nend", "  result = l.clone\n  indicies\
    \ = l.each_with_index.to_a\n  indicies.each_index do |i|\n    if i <> indicies.size\
    \ - 1\n      result[i] = indicies[i + 1]\n      indicies[i + 1] = nil\n    end\n\
    \  end\n  result\nend", "  return l[1..-1].sort{|a, b| l[b] - l[a]}\nend", " \
    \ l.each_with_index do |value, index|\n    next if index % 3 != 0\n    l[index]\
    \ = l[index] if value == l[index]\n  end\n  l.sort\nend", "  l2 = l.dup\n  l2.sort!\n\
    \  l2.each_with_index { |e, i|\n    if i % 3 == 0\n      l2[i] = l2[i]\n    end\n\
    \  }\n  l2\nend\n</code>\n<|/ a |>\n<| c |>\nThis is really helpful.\n<|/ c |>\n\
    <| a dscore=1 tags=ruby |>\n<code>", "  l.sort\n  l.each_with_index do |val, index|\n\
    \    if index % 3 == 0\n      l[index] = l[index - 1]\n    end\n  end\n  l\nend\n\
    </code>\n<|/ a |>\n<| c |>\n+1 I like your solution because it's the one that\
    \ only modifies a copy of the original array. I can't believe I didn't think of\
    \ that :)\n<|/ c |>\n<| c |>\nI like your solution because of the simplicity.\
    \ I was able to use this to solve a problem that involved sorting a large array\
    \ (~8000 elements) and the program was just hanging while it did so. Great stuff!\n\
    <|/ c |>\n<| a dscore=5 |>\nHere is an alternative that takes advantage of the\
    \ fact that all elements within a certain range will be sorted in increasing order:\n\
    <code>", "  l.each_with_index { |e, i| l[i] = (i % 3) ? e : l[i] }\n  l.sort_by\
    \ { |e| e }\n  l\nend", "  l.sort\n  \n  third = (l.inject(:+) / 3) * 3\n  l =\
    \ l.select { |e| e % 3 == 0 }\n  l.each_with_index { |e, i| l[i] ||= e }\n  l\
    \ += l.select { |e| e % 3 == 0 }.uniq.sort\n  \n  third.times { l << l.pop }\n\
    \  \n  l\nend", "    l.each_with_index do |value, index|\n        if index % 3\
    \ == 0\n            l.swap(index, index + (index / 3) * 3)\n        end\n    end\n\
    \    \n    l\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis is not going to work.\
    \ It does not give the original array sorted. Try `sort_third([2,5,3,1])` You\
    \ will get `[1,3,2]`\n<|/ c |>\n<| c |>\nYes, you're right. It's only a demonstration\
    \ of how to sort one array based on the second array. I'm not going to do all\
    \ your work for you.\n<|/ c |>\n<| a |>\nI see that you have an accepted answer,\
    \ but I would suggest using sort_by instead of sort. sort returns an array in\
    \ place, and creates a new array with the sorted values. sort_by is a method that\
    \ only returns one value (like the sort method). \n<code>\narr1 = [7, 8, 10, 4,\
    \ 2]\narr2 = [1, 2, 3, 4, 5]", "  l.each_with_index do |el, ind|\n    return l\
    \ unless ind % 3 == 0\n    ind -= 3 if el != l[ind]\n    l.insert(ind, el)\n \
    \ end\n  l\nend\n</code>\n<|/ a tags=algorithm,ruby |>\n<| c |>\nThanks for your\
    \ response. This is not quite what I was looking for. I am looking for the output\
    \ to be a list with the indicies of the same value sorted together, but not necessarily\
    \ the values in the list to be sorted together as well.\n<|/ c |>\n<| c |>\nOkay,\
    \ I didn't really understand that from your question when I posted. I updated\
    \ my answer to give a better example now.\n<|/ c |>\n<| c |>\nThanks, your updated\
    \ code worked perfectly. I appreciate your help.\n<|/ c |>\n<| c |>\nActually,\
    \ this only works on the first three values in the list. I'm sure I can figure\
    \ out how to make it work for other values now.\n<|/ c |>\n<| c |>\nSorry about\
    \ that, I've updated the answer to work for the whole list. Thanks for pointing\
    \ it out.\n<|/ c |>\n<| a tags=algorithm,ruby dscore=1 |>\nIf you're looking for\
    \ a quick and dirty way to sort an array, there are a few things that you can\
    \ do to make your life a lot easier.\n<code>", "  result = l.dup\n  result.reject!\
    \ {|n| n % 3 == 0}\n  result.uniq!\nend", "    l.each_with_index do |number, index|\n\
    \        threes = l.count(number).times.map { |i| (i + index) % 3 }\n        third_number\
    \ = threes.compact.max\n        l[index] = third_number\n    end\nend", "  l.sort_by!\
    \ {|x| (x % 3).zero? ? (x % 3).to_i : x}\n  l\nend", "  l.each_with_index do |val,\
    \ index|\n    unless index % 3 == 0\n      l[index] = val\n    end\n  end\n  l\
    \ = l.sort_by{|x| x}\n  l\nend\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| c |>\n\
    Won't this be O(N^2)? `sort_by` is an `O(N log N)` operation, so you're doing\
    \ this in O(N^2) operations.\n<|/ c |>\n<| c |>\n`sort_by` is O(N*log(N)) and\
    \ has complexity O(N^2) because it uses `Enumerable#sort_by`. The sort itself\
    \ is O(N), since it is done in O(N) time and O(log(N)) memory (for an array to\
    \ hold N elements).\n<|/ c |>\n<| c |>\nMy mistake, your answer is correct. I\
    \ misread what you were saying. But my comment was a little inaccurate. I wasn't\
    \ referring to sorting, my comment was referring to your `sort_by` call. Sorry\
    \ for the confusion.\n<|/ c |>\n<| a |>\nMy solution\n<code>", "  new_list = l.clone\n\
    \  new_list.sort\n  new_list.each_with_index do |val, index|\n    if index%3 !=\
    \ 0\n      new_list[index] = val\n    end\n  end\nend", "  l.each_with_index do\
    \ |x,i|\n    next if i%3\n    l.at(i) = x\n  end\n  l\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 tags=ruby,sorting |>\n<code>\nnumbers = [1,2,3,4,5,6,7,8,9,10]\n\
    </code>\n<code>\nsorted = numbers.sort {|n1, n2| n1 <=> n2}\n</code>\n<code>\n\
    numbers[0..numbers.size/3] = []\nsorted.each_with_index do |value, index|\n  numbers[(index*3)..(index*3+3)]\
    \ << value\nend\n</code>\n<code>\nnumbers\n</code>\n<|/ a |>\n<| a dscore=0 |>\n\
    <code>", "  l.sort!\n  l.each_with_index do |value, index|\n    l[index] % 3 ==\
    \ 0 ? l[index] = value : l[index] = value + 1 if (index == 0 || value == l[index])\n\
    \  end\n  l\nend\n</cell>\n<code language=other-env>", "  l.sort\n  l.each_with_index\
    \ { |value, index|\n    next if index % 3 == 0\n    l[index] = value\n  }\n  l\n\
    end\n</code>\nI hope this helps.\n<|/ a dscore=1 |>\n<| a tags=ruby |>\nMy attempt\
    \ would be to create an Array:\n<code>", "  sort_third.times { l.reduce do |a,\
    \ b|\n    b % 3 == 0 ? a : (b % 3 == 1 ? a : a << b)\n  end }\nend\n</code>\n\
    <|/ a |>\n<| c |>\nI like the `if` instead of `unless` because it is much easier\
    \ to read. Also, I think this can be easily translated to Ruby with minimal changes,\
    \ so +1 from me.\n<|/ c |>\n<| c |>\n: You're right about the `if`, I added a\
    \ note. I'm glad to have seen this question so often.\n<|/ c |>\n<| c |>\nThis\
    \ doesn't answer the question at all, only some parts of it. Also, the last code\
    \ sample does not sort anything. It does `sort_third.call x` instead of `sort_third.call\
    \ x.sort`.\n<|/ c |>\n<| c |>\n: you're right about the last code sample not sorting\
    \ anything, I added a line to sort it using `sort_third`. Thanks for pointing\
    \ that out.\n<|/ c |>\n<| c |>\nI didn't see your edited answer until after I'd\
    \ finished writing my own. Also, I was wondering if you could comment on the performance\
    \ of these methods on large lists, as they seem to have a similar performance\
    \ to my solution: http://stackoverflow.com/questions/41069197/how-to-sort-array-elements-but-not-necessarily-alphabetically-using-ruby-and-sor\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>", "  return l[1..-1].group_by { |i| i % 3 }.map\
    \ { |i, items| items[1] }\nend", "  l.each_index do |i|\n    if l[i] % 3 == 0\n\
    \      l[i] = l[i] * 3\n    end\n  end\n  l.sort!\n  l\nend", "  l = [*l]\n  l.sort!\n\
    \  l.each_with_index do |value, index|\n    if index % 3 == 0\n      l[index]\
    \ = value.next\n    end\n  end\n  l\nend", "  l[1..-1].uniq!\n  l[0..-2].reverse_each.sort_by(&:first).zip(l)\n\
    end", "  return l.partition(&:odd?).flatten\nend", "  l.each_with_index do |value,\
    \ index|\n    if index % 3 == 0\n      l.values_at(*(index...index + 2).collect\
    \ { |i| i }).compact!\n      l.values_at(*(index...index + 2).collect { |i| i\
    \ }).sort!\n    end\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't\
    \ work. Even when `l` is `[3, 4, 1, 5]`, `sort_third.call([3, 4, 5, 1])` returns\
    \ `[1, 3, 5]`. Furthermore, it doesn't work on a sorted array. Also, please don't\
    \ use `[1..-1]` for an array that could contain negative numbers.\n<|/ c |>\n\
    <| c |>\nI realize you're probably trying to be helpful, but you're wrong. I've\
    \ edited my answer to explain how the function works. `[1..-1]` produces an array\
    \ that ends up being `[1,2,3,4,5,6,7,8,9]`, which is why I chose to use `values_at`\
    \ instead of `values_at *(index...index + 2)`.\n<|/ c |>\n<| c |>\nThat's what\
    \ I'm saying. It doesn't work on a sorted array. Also, the first part of `values_at\
    \ *(index...index + 2)` isn't very efficient. You're duplicating the array three\
    \ times instead of just once.\n<|/ c |>\n<| c |>\nThanks for catching that. I've\
    \ edited my answer to fix the problems with the original code and added the fix\
    \ to the version that preserves the ordering.\n<|/ c |>\n<| c |>\nYour first version\
    \ preserved the ordering but it added a bunch of duplicates. Did you try it on\
    \ a sorted array? You will see that `sort_third.call([3, 4, 5, 1])` gives `[1,\
    \ 3, 5]`. That doesn't work.\n<|/ c |>\n<| a dscore=0 |>\nUse a hash!\n<code>",
  "  l = l.sort\n  l.reject { |value| value % 3 == 0 }.sort\nend\n</code>\nNote that\
    \ I used the Ruby method sort instead of Array#sort. It will sort the array in\
    \ place, returning nil. By assigning that to a new variable, I can reuse that\
    \ array later without having to recreate it each time.\n<code>", "  l = l.to_a\n\
    \  l[0], l[2], l[1] = [ l[2], l[1], l[0] ].max\n  l.sort\n  l\nend", "\tl.sort_by!\
    \ do |index|\n\t\tindex % 3 == 0 ? index : index - 3\n\tend\nend", "    l = l.sort\n\
    \    l.each_with_index { |val, index| val % 3 == 0 ? l[index] << val : l[index]\
    \ << val + (val % 3 != 0 ? 1 : 0) }\nend\n</cell>\n<cell>", "  new_list = []\n\
    \  \n  for i in 0..(l.length-1)\n    if (l[i] % 3 == 0)\n      new_list << l[i]\n\
    \      new_list << l[i + 1]\n      new_list << l[i + 2]\n    else\n      new_list\
    \ << l[i]\n    end\n  end\n  \n  new_list.sort\n  new_list\nend\n</cell>\n<code\
    \ language=julia-1.5>\nfunction sort_third_2(n)\n  new_list = []\n  \n  for i\
    \ in 0..(n-1)\n    if (i % 3 == 0)\n      new_list << i\n      new_list << i +\
    \ 1\n      new_list << i + 2\n    else\n      new_list << i\n    end\n  end\n\
    \  \n  new_list.sort\n  new_list\nend\n</cell>\n<code language=julia-1.5>\nfunction\
    \ sort_third_3(n)\n  new_list = []\n  \n  for i in 0..(n-1)\n    if (i % 3 ==\
    \ 0 || i != n-1)\n      new_list << i\n    end\n  end\n  \n  new_list.sort\n \
    \ new_list\nend\n</cell>\n<code language=julia-1.5>\nsort_third.call([5, 6, 3,\
    \ 4, 8, 9, 2])\n</cell>\n<code language=julia-1.5>\nsort_third_3.call([5, 6, 3,\
    \ 4, 8, 9, 2])\n</cell>\n<code language=julia-1.5>\nsort_third_2.call([5, 6, 3,\
    \ 4, 8, 9, 2])\n</cell>\n<code language=julia-1.5>\nsort_third_3.call([5, 6, 3,\
    \ 4, 8, 9, 2])\n</cell>\n<code language=julia-1.5>\nsort_third_3.call([5, 6, 3,\
    \ 4, 8, 9, 2])\n</cell>\n<code language=julia-1.5>\nsort_third_3.call([5, 6, 3,\
    \ 4, 8, 9, 2])\n</cell>\n<code language=julia-1.5>\nsort_third_2.call([5, 6, 3,\
    \ 4, 8, 9, 2])\n</cell>\n<code language=julia-1.5>\nsort_third_3.call([5, 6, 3,\
    \ 4, 8, 9, 2])\n</cell>\n<code language=julia-1.5>\nsort_third_2.call([5, 6, 3,\
    \ 4, 8, 9, 2])\n</cell>\n<code language=julia-1.5>\nsort_third_3.call([5, 6, 3,\
    \ 4, 8, 9, 2])\n</cell>\n<code language=julia-1.5>\nsort_third_3.call([5, 6, 3,\
    \ 4, 8, 9, 2])\n</cell>\n<code language=julia-1.5>\nsort_third_3.call([5, 6, 3,\
    \ 4, 8, 9, 2])\n</cell>\n<code language=julia-1.5>\nsort_third_3.call([5, 6, 3,\
    \ 4, 8, 9, 2])\n</cell>\n<code language=julia-1.5>\nsort_third_3.call([5, 6, 3,\
    \ 4, 8, 9, 2])\n</cell>\n<code language=julia-1.5>\n", "  return [l.at(i) if i.to_f\
    \ % 3 == 0 then i else i.to_f / 3 end for i in l]\nend\n</code>\nThe call method\
    \ can be called on any list that is mutable (meaning that you can change the contents\
    \ of the list as you go along).\nThe at method will return the value at the indicies\
    \ of the given list. If the indicies are out of range, they will just be returned\
    \ as zero (0), so they will work as a special case. Converting them to float will\
    \ ensure they are floats and you will be able to do the math.\nHere is an example\
    \ of the function applied to your list:\n<code>\n> sort_third.call([5, 6, 3, 4,\
    \ 8, 9, 2])\n[2, 6, 3, 4, 8, 9, 5]\n</code>\n<|/ a |>\n<| c |>\nOk, thanks. But...\
    \ I see that `sort_third([1, 2, 3])` returns `[0, 0, 1, 2, 3, 3]`. Why is that?\n\
    <|/ c |>\n<| c |>\nYou are correct, I forgot about the 0 value. Updated answer\
    \ to reflect this. Also made a change to the return statement to use `to_f` instead\
    \ of `to_i`. That should fix it.\n<|/ c |>\n<| c |>\nYes, that fixes it. Thanks.\
    \ But then I don't understand why it is necessary. `sort_third([1, 2, 3])` returns\
    \ `[1, 2, 3]`\n<|/ c |>\n<| c |>\nUpdated my answer to give an explanation.\n\
    <|/ c |>\n<| a dscore=0 |>\nHere is a simple way to do that without using any\
    \ functions:\n<code>", "  l.sort\n  l.reduce(&:+)\nend", "  l2 = []\n  l.each_index\
    \ do |i|\n    if i % 3 != 0\n      l2.push(l[i])\n    end\n  end\n  l2.sort.reverse.each_index\
    \ do |i|\n    if i % 3 == 0\n      l[i] = l2[i]\n    end\n  end\n  l\nend", " \
    \ l.each_with_index do |e, i|\n    unless i % 3 == 0\n      l[i] = l[i]\n    end\n\
    \  end", "  l.each_with_index do |e, i|\n    if i%3 == 0\n      l[i] = l[i-1]\n\
    \    end\n  end\n  l\nend", "  a = []\n  i = 0\n  while i < l.length\n    a.push\
    \ l[i]\n    i += 1\n  end\n  i = nil\n  while i < l.length\n    i += 1\n    j\
    \ = i\n    while j < l.length\n      j += 1\n      while j < l.length\n      \
    \  if l[j] % 3 == 0\n          a.push l[j]\n          j += 1\n        else\n \
    \         break\n        end\n      end\n    end\n  end\n  a\nend", "  l.sort.call(l.each_index.partition\
    \ { |i| i.odd? }.map { |i| (l[i] + l[i+1]) / 3 })\nend", "\tl.sort\n\tl.each_with_index\
    \ do |v, i|\n\t\tl[i%3] += v\n\tend\nend", "  l.sort_by {|x| x % 3 == 0}\n  l\n\
    end", "  # sort l by l[1], then by l[2], then by l[3]\n  return l.sort_by { |e|\
    \ [e[1], e[2], e[3]] }\nend", "  l.sort_by! { |x| (x % 3) != 0 }\n  l\nend", " \
    \   l.sort!\n    l[(l.index{|e| e % 3 == 0} - l.index{|e| e % 3 == 0}) / 3] =\
    \ l[l.index{|e| e % 3 == 0}]\n    l\nend", "  sorted = nil\n  sorted_third = nil\n\
    \  l.each do |n|\n    next if n % 3 == 0\n    sorted << n\n    break if n % 3\
    \ == 0\n  end\n  sorted.each do |n|\n    sorted_third << n if sorted_third.nil?\
    \ || n != sorted_third.last\n  end\n  sorted_third.sort!\n  return sorted_third\n\
    end", "  l.each_with_index do |x, i|\n    (i / 3).zero? ? l[i] = x : l[i] = x\n\
    \  end\n  l\nend", "  return l.each_with_index.reduce(:inject).sort_by { |a,b|\
    \ a%3 <=> b%3 }.flatten.uniq\nend\n</pre>", "  l.sort.tap do |l|\n    indicies\
    \ = l.each_with_index.select { |value, index| index % 3 == 0 }\n    indicies.each\
    \ { |index| l[index] = indicies[index].first }\n  end\nend", "  l.sort!\n  l.each_with_index\
    \ { |e, i| l[i] = l[i] if i % 3 == 0 }\nend", "  sorted_l = l.sort_by{|x| x %\
    \ 3}\n  sorted_l = sorted_l.collect{|x| x + 3 if x % 3 == 0}\nend", "  l.each_with_index\
    \ do |e, i|\n    index =\n      if e.even?\n        i + 3\n      else\n      \
    \  i + 1\n      end\n    l.delete_at(i)\n    l.insert(index, e)\n  end\nend",
  "  l.each_with_index do |x, i|\n    if i % 3 == 0 && i != l.size - 1\n      l[i]\
    \ = l[i + 1]\n    end\n  end\n  return l\nend", "  l.sort!\n  l.each_with_index\
    \ do |e, i|\n    if i%3 == 0\n      l[i] = l[i+1]\n      l[i+1] = e\n    end\n\
    \  end\n  l\nend", "  l.each_with_index do |value, index|\n    if index % 3 !=\
    \ 0\n      l[index] = value\n    else\n      l[index] = l.index(index) + 1\n \
    \     break unless value <= l.last\n    end\n  end\n  l\nend", "  l.each_with_index\
    \ do |v, i|\n    if i % 3 == 0\n      l[i] = l[i/3]\n    else\n      break\n \
    \   end\n  end\n  l.sort!\nend", "  lt = []\n  count = 0\n  for i in l\n    count\
    \ += 1\n    if count % 3 == 0\n      lt.push(i)\n    else\n      lt.push (i)\n\
    \      lt.push (i)\n      lt.push (i)\n    end\n  end\n  return lt\nend\n</cell>\n\
    <code language=julia-1.5>\n@time sort_third(1:100)\n</cell>\n<code language=julia-1.5>\n\
    @time sort_third(1:100)\n</cell>\n<code language=julia-1.5>\n@time sort_third(1:100)\n\
    </cell>\n<code language=julia-1.5>\n@time sort_third(1:100)\n</cell>\n<code language=julia-1.5>\n\
    @time sort_third(1:100)\n</cell>\n<code language=julia-1.5>\n@time sort_third(1:100)\n\
    </cell>\n<code language=julia-1.5>\n@time sort_third(1:100)\n</cell>\n<code language=julia-1.5>\n\
    @time sort_third(1:100)\n</cell>\n<code language=julia-1.5>\n@time sort_third(1:100)\n\
    </cell>\n<code language=julia-1.5>\n@time sort_third(1:100)\n</cell>\n<code language=julia-1.5>\n\
    @time sort_third(1:100)\n</cell>\n<code language=julia-1.5>\n@time sort_third(1:100)\n\
    </cell>\n<code language=julia-1.5>\n@time sort_third(1:100)\n</cell>\n<code language=julia-1.5>\n\
    @time sort_third(1:100)\n</cell>\n<code language=julia-1.5>\n@time sort_third(1:100)\n\
    </cell>\n<code language=julia-1.5>\n@time sort_third(1:100)\n</cell>\n<code language=julia-1.5>\n\
    @time sort_third(1:100)\n</cell>\n<code language=julia-1.5>\n@time sort_third(1:100)\n\
    </cell>\n<code language=julia-1.5>\n@time sort_third(1:100)\n</cell>\n<code language=julia-1.5>\n\
    @time sort_third(1:100)\n</cell>\n<code language=julia-1.5>\n@time sort_third(1:100)\n\
    </cell>\n<code language=julia-1.5>\n@time sort_third(1:100)\n</cell>\n<code language=julia-1.5>\n\
    @time sort_third(1:100)\n</cell>\n<code language=julia-1.5>\n@time sort_third(1:100)\n\
    </cell>\n<code language=julia-1.5>\n@time sort_third(1:100)\n</cell>", "  l.each_with_index\
    \ do |e,i|\n    if i%3 == 0 && i > 0 && i%3 == 0 && !i.zero?\n      puts \"\\\
    n--------------- ERROR ---------------\"\n      puts \"\\nYou have already ordered\
    \ the indicies that are divisible by 3, please remove this indicies before proceeding\
    \ further\"\n      puts \"\\n-------------------------\\n\\n\\n\"\n      next\n\
    \    end\n  end", "  l2 = []\n  l.each do |i|\n    if i %3 != 0\n      l2 << i\n\
    \    elsif l2.size != 0\n      l2[l2.size - 1] = i\n    end\n  end\n  l2.sort!\n\
    \  l2.each_with_index do |v, i|\n    l[i] = v\n  end\nend", "  l3 = l.dup.sort.group_by{|i|\
    \ i % 3}.values\n  l3.zip(l).flatten(1)\nend\n</code>\n<|/ a tags=ruby dscore=3\
    \ |>\n<| c |>\nI ran the script and it gave me a warning message. `warning: already\
    \ initialized constant FizzBuzz`, so I added `FizzBuzz` module in the beginning\
    \ and the warning disappeared.\n<|/ c |>\n<| c |>\nI wonder if there's any performance\
    \ benefit (though I doubt it).\n<|/ c |>\n<| c |>\nIt's not an issue for this\
    \ case, but if you use sort_by instead of group_by, you get rid of a warning.\
    \ http://www.ruby-doc.org/core-2.1.5/Enumerable.html#method-i-sort_by\n<|/ c |>\n\
    <| c |>\nI like this. It is a little bit more verbose and requires a little extra\
    \ code, but it is clear what's happening and is pretty easy to read. Thanks! I\
    \ liked how this used the fact that `3..10` is an enumerable range.\n<|/ c |>\n\
    <| a tags=ruby |>\n<code>", "  l1 = []\n  for i in l\n    if i % 3 == 0\n    \
    \  l1.push(i)\n    end\n  end\n  l1.sort_by! { |x| l1.index x }\n  l1\nend\n</code>\n\
    <|/ a tags=sorting,ruby,arrays dscore=1 |>\n<| c |>\n`sort_third` can be simplified\
    \ to `l.sort_by(&:odd?)`\n<|/ c |>\n<| c |>\nI wasn't sure it could handle negative\
    \ numbers (which don't exist in Ruby), but it appears it does: `sort_third([-1,\
    \ 0, 1, -2])` returns `[-1, 0, -2, 1]`.\n<|/ c |>\n<| a dscore=0 |>\n<code>",
  "  l1 = []\n  l2 = []\n  l3 = []\n  l4 = l\n  while l4 != []\n    l1.push(l4.shift)\n\
    \    l2.push(l4.shift)\n    l3.push(l4.shift)\n    break if l4.empty?\n  end\n\
    \  l4 = l\n  while l4 != []\n    l3.push(l4.shift)\n    break if l4.empty?\n \
    \ end\n  l4 = l\n  while l4 != []\n    l2.push(l4.shift)\n    break if l4.empty?\n\
    \  end\n  l4 = l\n  while l4 != []\n    l1.push(l4.shift)\n    break if l4.empty?\n\
    \  end\n  l1\nend\n</code>\n<|/ a tags=ruby,arrays,sorting |>\n<| a |>\nThe question\
    \ asks to write a function which takes an array and returns a new array that is\
    \ sorted according to the condition that all elements are divisible by three.\n\
    Here's one way to do that:\n<code>", "  l.sort_by! {|x| (x % 3 == 0) ? (x + 2)\
    \ : x}\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nWhile this does produce the\
    \ expected result, it does not produce the expected results if the list already\
    \ has even or odd numbers.\n<|/ c |>\n<| c |>\nYes, I have added comments above\
    \ to reflect this fact.\n<|/ c |>\n<| a dscore=0 |>\nMy solution:\n<code>", " \
    \ l3 = l.clone\n  l3.each_with_index do |val, i|\n    puts \"i is #{i}\"\n   \
    \ puts \"val is #{val}\"\n    if i % 3 == 0\n      puts \"Moving to next value\"\
    \n      puts \"Current value is #{l3[i]}\"\n      l3.delete_at(i)\n      l3.delete_at(i)\n\
    \    end\n    puts \"New list is #{l3}\"\n  end\n  l3\nend", "  new_l = l.dup\n\
    \  new_l[0] = new_l[0] % 3\n  new_l[new_l.length-1] = new_l[new_l.length-1] %\
    \ 3\n  new_l.sort!\n  new_l\nend", "  sorted = []\n  for i in l\n    sorted.push(i)\
    \ if i%3 != 0\n  end\n  sorted.sort\nend", "  l.sort!\n  l[0]\n  result = [l[0]]\n\
    \  for i in 1..l.length\n    if l[i] % 3 == 0\n      result.push(l[i])\n    end\n\
    \  end\n  result\nend", "  return l.sort {|a, b| b % 3 == 0 ? b : ((b % 3 == 1)\
    \ ? a : (b == a ? 0 : a)) }\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 tags=ruby,sorting,arrays\
    \ |>\nYou can sort an array by its indices using sort_by\n<code>", "  return l.sort{|a,b|\
    \ a % 3 == b % 3 ? a : a % 3 > b % 3 ? 1 : -1}\nend\n</cell>\n<cell>", "  l.sort!\n\
    \  (l[0], l[1], l[2])\nend", "    l.sort!\n    return l\nend", "  l.sort!\n  return\
    \ l unless l % 3 == 0\n  l[l.size/3..-1].sort!\n  l\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\n`sort_third([...])` does not do what you think it does. You are\
    \ passing `[1,2,3]` to `sort_third` which returns `[2,3,1]`, then you are trying\
    \ to use `sort_third` with `[2,3,1]` as an argument and I expect that to return\
    \ `[1,2,3]`. That would require your `sort_third` method to return the array `[1,2,3]`,\
    \ but instead it returns the array `[2,3,1]`, which you then try to assign to\
    \ a variable. I'm not sure how you got that result, but that's not what your code\
    \ is doing.\n<|/ c |>\n<| c |>\nYou're correct in that I made a mistake in my\
    \ original answer. Your solution worked just fine.\n<|/ c |>\n<| a dscore=2 |>\n\
    To sort an array of hashes, first group by the key you want, then sort each group.\n\
    <code>\narr.group_by{|el| el[:key]}.sort_by{|k, v| k}.each do |k,v|\n  arr[k]\
    \ = v\nend\n</code>\nTo sort an array of arrays of hashes, first sort each array,\
    \ and then sort each group of arrays based on the first hash.\n<code>\narr.sort_by{|el|\
    \ el.first[:key]}.group_by{|el| el[0].first[:key]}.sort_by{|k, v| k}.each do |k,v|\n\
    \  arr[k] = v\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis only sorts by key.\
    \ I need it sorted by value within a hash key.\n<|/ c |>\n<| c |>\nI changed it\
    \ to sort by value within the hash key.\n<|/ c |>\n<| c |>\nThis would work, except\
    \ for cases where you have duplicate values in the `key` hash.  I think `group_by`\
    \ and `sort_by` could be combined to get the desired result.\n<|/ c |>\n<| c |>\n\
    I think that would work too. I went with group_by because I assumed there would\
    \ only be one value per key, but if you have more than one value per key then\
    \ you could use sort_by.\n<|/ c |>\n<| a dscore=1 tags=ruby |>\n<code>\narr =\
    \ [\n  {:name => \"a\", :size => 1},\n  {:name => \"b\", :size => 3},\n  {:name\
    \ => \"c", "  l.each_with_index { |n, i| l[i] = n if n.even? }\n  l.sort_by {\
    \ |n| [n % 3, n] }\nend", "    l = l.sort\n    l.each_with_index do |n, i|\n \
    \       if n % 3 == 0\n            l = l.reject { |x| x == i }\n            l.push\
    \ i\n        end\n    end\n    l\nend", "    l = l.to_a\n    l.each_with_index\
    \ do |val, i|\n        if i % 3 == 0\n            l[i] = l[i - 3]\n        end\n\
    \    end\n    l.sort!\n    l\nend\n</code>\n<|/ a dscore=0 tags=ruby |>\n<| c\
    \ |>\nThis is not the OP's desired result -- OP is asking for something slightly\
    \ different. His `sort_third` will sort the array in increasing order but *not*\
    \ by groups of 3.\n<|/ c |>\n<| a dscore=0 tags=ruby |>\n<code>", "  l.sort\n\
    \  l[0].times do |i|\n    l.rotate(-i) if l[i].odd?\n  end\nend\n</code>\n<code>",
  "  n = 1\n  while n < l.length\n    if l[n] != l[n-1] and l[n] % 3 == 0\n      #\
    \ remove duplicates of n\n      l.delete_at(n)\n    else\n      n += 1\n    end\n\
    \  end\nend\n</code>\nAnd here is how to apply the above:\n<code>\nar = sort_third([3,\
    \ 1, 5, 7, 2, 9, 0, 4])\nar", "  l.each_with_index do |val, index|\n    break\
    \ if index % 3 == 0\n    l.insert(index, val)\n  end\n  l\nend\n</code>\nThis\
    \ should do what you want!\n<|/ a dscore=2 |>\n<| c |>\nI think this one is good,\
    \ thanks! I still don't understand why my method doesn't work, though. :/\n<|/\
    \ c |>\n<| c |>\nHmm, I think I know why: since I sort using insert, the order\
    \ is not preserved when elements are shifted down the list. E.g., say my list\
    \ is [2,4,1,3]. Since 2 is divisible by three, it is moved to the front of my\
    \ list. After sorting this becomes [1,1,2,3]. Because sorting is based on insert,\
    \ this puts 2 in the same position as 1. This means that the values at 1 and 2\
    \ are equal. Thus, the two elements are left with their original values, instead\
    \ of being replaced by their correct values. Thoughts?\n<|/ c |>\n<| c |>\nYes,\
    \ that's exactly what's happening. If you sort the list by inserting elements\
    \ at the right side of the list, the original positions of those elements are\
    \ preserved.\n<|/ c |>\n<| c |>\nOkay, thanks for the explanation! It makes sense\
    \ now.\n<|/ c |>\n<| a tags=ruby,sorting |>\nHere is how you can do it using a\
    \ block with the sort method.\n<code>\nlist = [1, 2, 3, 4, 5]\nlist.sort do |a,\
    \ b|\n  # Swap if even.\n  ([a,b].sort & [a,b].cycle).none? { |i| i % 3 == 0 }\n\
    end\n</code>\nEDIT\nI see where your problem is. Your code doesn't work because\
    \ you're not sorting the list at the right place, you're inserting at an arbitrary\
    \ place. Since you're not swapping items if they are equal, you'll get an incorrect\
    \ sorting.\n<code>\nlist = [5, 3, 4, 8, 9, 1, 2, 6]\nlist = list.sort do |a, b|\n\
    \  # Swap if even.\n  ([a,b].sort & [a,b].cycle).none? { |i| i % 3 == 0 }\nend\n\
    </code>\nIf you just sort the list with sort, you get [1,2,3,4,5,6,8,9].\n<|/\
    \ a dscore=0 |>\n<| c |>\nI see this works, and I see where my problem is. But\
    \ I don't see any reason why my code doesn't work. :(\n<|/ c |>\n<| c |>\nHmm,\
    \ I think I know why: since I sort using insert, the order is not preserved ",
  "  l.each_with_index do |x, i|\n    if x.to_i % 3 == 0\n      l.delete_at(i)\n \
    \   else\n      l[i] = x\n    end\n  end\n  l\nend", "  l.each_with_index do |e,\
    \ i|\n    if i % 3 == 0\n      l[i] = e\n    end\n  end\n  l\nend", "  l.sort\
    \ {|a, b| b % 3 == 0 && a % 3 == 0 ? b - a : a - b}\n  l\nend", "  sorted = []\n\
    \  sorted = sorted.concat(l[0..-2]) if l.size % 3 == 0 \n  sorted = sorted.concat(l[-2..-1])\
    \ if l.size % 3 == 1 \n  sorted = sorted.concat(l[3..-1]) if l.size % 3 == 2 \n\
    \  return sorted\nend", "  l = [*l]\n  l.sort\n  l.reverse\n  l\nend", "  l.sort{|a,\
    \ b| (a % 3 == 0) ? (b > a) : (a > b)}\nend\n</code>\n<|/ a tags=ruby,arrays,sorting\
    \ |>\n<| c |>\nThat is elegant, but I'm afraid I misread your question, seeing\
    \ as how you said \"I want the array to appear sorted after each iteration, such\
    \ that all values divisible by three remain sorted\". This does not do that.\n\
    <|/ c |>\n<| c |>\nYou're right, I edited my answer.  I didn't read your question\
    \ thoroughly enough and got mixed up\n<|/ c |>\n<| a |>\n<code>", "  l.each_with_index\
    \ do |e, i|\n    if i % 3 == 0\n      l[i] = l[i + 1]\n    end\n  end\n  return\
    \ l\nend\n</code>\nAnd here's one to sort the list in-place:\n<code>", "  sorted_l\
    \ = l.sort\n  for i in 0..l.size-1\n    if i % 3 == 0\n      sorted_l[i] = sorted_l[i+1]\n\
    \    else \n      sorted_l[i] = sorted_l[i+1]\n  end\n  sorted_l\nend", "  l.reduce([])\
    \ { |l', v| l'.unshift(v); l' } # flatten the array\n  l.reverse\n  l[l/3 % l.length]\
    \ = l[l/3 % l.length].sort_by { |n| l % n } \n  l\nend", "  l.sort.call(0..l.length).tap\
    \ {|indicies| indicies.each_with_index { |indicie, index|\n    indicies << indicie\
    \ if indicie % 3 == 0 || indicie % 3 == 1\n  }}\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=ruby dscore=0 |>\nUsing Enumerable#each_cons and Array#shuffle,\
    \ it's easy to shuffle the first two elements and then shuffle the remaining elements:\n\
    <code>\na = [1, 2, 3, 4, 5, 6, 7, 8, 9]", "  l = l.sort\n  l[l.index { |x| (x\
    \ % 3 == 0) }] = (l[l.index { |x| (x % 3 == 0) }] + 1) % 3\n  l\nend", "  result\
    \ = []\n  l.each_with_index do |el, i|\n    result << el\n    if i % 3 == 0\n\
    \      result << el\n    end\n  end\n  result\nend", "    l.sort!\n    sorted_l\
    \ = []\n    l.each_with_index do |e,i|\n        if i % 3 == 0\n            sorted_l.push(e)\n\
    \        else\n            sorted_l.push([e, e])\n        end\n    end\n    sorted_l\n\
    end", "  sorted = []\n  l = l.sort\n  l = l.uniq\n  l = l.sort\n  l = l.sort\n\
    \  i = 0\n  while i < l.length\n    if l[i] % 3 == 0\n      sorted.push [l[i]]\n\
    \      i += 1\n      while i < l.length\n        if l[i] % 3 != 0\n          sorted.push\
    \ [l[i]]\n          i += 1\n        else\n          i += 1\n        end\n    \
    \  end\n    end\n  end\n  return sorted\nend\n</code>\n<|/ a dscore=2 |>\n<| a\
    \ dscore=1 tags=ruby,sorting,arrays |>\nI came up with this for sorting the array.\
    \ Hope this helps.\n<code>", "  l = l.sort.call(\n    l.map.call(\n      l.filter.call(\n\
    \        l.each_cons(3).to_a\n      ).to_a\n    ).to_a\n  )\n  l.each_with_index\
    \ do |e, i|\n    if i % 3 != 0\n      l[i] = l[i - 3]\n    end\n  end\n  l\nend",
  "  l.sort_by do |x|\n    break if x % 3 == 0\n    x\n  end\nend\n</code>\nWe can\
    \ use sort_third method now to sort the array by sorting only values divisible\
    \ by three:\n<code>\nsort_third([5, 6, 3, 4, 8, 9, 2])", "  l.each_with_index\
    \ do |e, i|\n    (i%3 == 0 ? l : [l[i-1], l[i]]).uniq.each do |val|\n      l[i]\
    \ = val\n      break\n    end\n  end\n  return l\nend", "  index = 0\n  l' =[]\n\
    \  while index < l.length\n    if (l[index] % 3 == 0)\n      l' << l[index]\n\
    \    end\n    index += 1\n  end\n  l' << l[index-1]\n  l' << l[index]\n  l'.sort!\n\
    \  return l'\nend", "  l = l.dup\n  l.sort\n  l.each_with_index { |v, i| l[i]\
    \ = l[i] unless i % (l[-1] / 3) == 0 }\n  l\nend\n</code>\n<|/ a |>\n<| c |>\n\
    This is an elegant solution, but it also sorts the original list too. `sort_third`\
    \ might not be the most efficient solution, but it does answer the question asked.\
    \ Your solution is very efficient, and it could very well be the best one. I'll\
    \ leave this one here because it is a good general answer. Though I did end up\
    \ implementing the sorting with ruby's sort method since this was all I needed.\n\
    <|/ c |>\n<| a tags=ruby |>\nThe first thing that came to mind was this:\n<code>\n\
    l.sort { |a,b| a != b ? a : b%3 ? b : a }\n</code>\nBut this works only for lists\
    \ that only contain numbers, not for lists that contain strings.\n<|/ a dscore=2\
    \ |>\n<| a |>\n<code>\nl = [6, 2, 3, 8, 1, 6, 5, 5]", "  l.each { |i| l[i] = l[i]\
    \ % 3 == 0 ? l[i] : l[i] + 1 }\n  l.sort\n  l\nend\n</code>\n<|/ a |>\n<| a dscore=0\
    \ |>\nHere's one way, assuming you can sort the list\n<code>", "  l.sort\n  l[0..2].each\
    \ { |i| l[i] % 3 == 0 ? l[i] = l[i] * 3 : l[i] = l[i] + 1 }\n  l\nend", "  l_copy\
    \ = l.clone\n  l.each_with_index do |element, index|\n    if index % 3 == 0\n\
    \      l_copy[index] = (l_copy[index] % 3) + 3\n    end\n  end\n  l_copy\nend",
  "  l.each_with_index do |x, i|\n    break if i % 3 != 0\n    l.delete_at(i)\n  \
    \  l.insert(i, x)\n  end\n  return l\nend", "  l.sort_by!{|x| x % 3}\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThis is a bit of an overkill for the problem at hand. `sort_by`\
    \ will work for this purpose and it's simpler than the other solutions I proposed.\
    \ But it requires Ruby 1.9 for which I do not yet have the necessary knowledge.\n\
    <|/ c |>\n<| c |>\nI agree with you. My solution works in 1.8.7 as well and it's\
    \ an alternative.\n<|/ c |>\n<| c |>\nYes, this is great.  It does exactly what\
    \ I asked, and it's simple.  I appreciate your help.\n<|/ c |>\n<| a tags=ruby,sorting,arrays,ruby-on-rails\
    \ |>\nNot particularly elegant but here is my solution:\n<code>\n[1,2,3,4,5,6].sort_by{|e|\
    \ e % 3}.uniq.sort{|a,b| a<=>b}\n=> [3, 4, 2, 5, 1, 6]\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nThis is just what I needed, thank you very much!  However, I decided\
    \ to go with Jamie's answer because it is simpler; thanks to you both.\n<|/ c\
    \ |>\n<| a tags=ruby,sorting,arrays,ruby-on-rails |>\n<code>\na = [1,2,3,4,5,6]\n\
    </code>\n<code>\na.sort_by{|e| e % 3 }.uniq\n</code>\n<|/ a dscore=2 |>\n<| c\
    \ |>\nThanks for your answer.  I think this does what I want, but unfortunately\
    \ it requires Ruby 1.9.\n<|/ c |>\n<| c |>\nIf `a` were `a = [1, 3, 1, 2, 4, 1]`,\
    \ the order of the elements after calling `sort_by!` would be `[1, 2, 4, 3, 1,\
    \ 3]` rather than `[1, 2, 3, 1, 4, 3]`.\n<|/ c |>\n<| a tags=ruby,sorting,arrays,ruby-on-rails\
    \ dscore=2 |>\n<code>\na = [1, 2, 3, 4, 5]\na.sort{|a, b| b<=>a }\n=> [1, 2, 3,\
    \ 4, 5]\n</code>\n<|/ a |>\n<| a dscore=2 |>\nSince Ruby 1.9 there is Array#sort_by:\n\
    <code>\n[1, 2, 3, 4, 5, 6].sort_by{|e| e % 3}.uniq\n=> [3, 4, 2, 5, 1, 6]\n</code>\n\
    <|/ a tags=ruby,sorting,arrays,rub", "  l.each do |x|\n    if x % 3 != 0\n   \
    \   l.delete_at(x)\n      l.push(x)\n    end\n  end\nend", "  sorted_l = l\n \
    \ sorted_l.sort!\n  l.each_with_index do |value, index|\n    index % 3 == 0 &&\
    \ sorted_l[index - 3..index] = sorted_l[index..index - 3]\n  end\nend", "  l.each_with_index\
    \ do |e, i|\n    if (i % 3 == 0)\n      l.delete_at(i)\n    else\n      l[i] =\
    \ e\n    end\n  end\n  l\nend\n</code>\n<|/ a dscore=3 |>\n<| a tags=ruby,sorting,arrays\
    \ |>\nI believe that if you wanted to sort in place, you would have to start at\
    \ the end of the array, then compare each number in the array to the element after\
    \ it in the sorted order, then replace the element at that position in the array\
    \ with the smallest of the two numbers, thus swapping the numbers.\n<|/ a dscore=1\
    \ |>\n<| c |>\nIt would be easier just to swap two elements of the array, like\
    \ in C if you have an array: int a[] = {10,15,8};\n<|/ c |>\n<| c |>\nI believe\
    \ this approach is more efficient for sorting an array with n elements. You would\
    \ just traverse the array once and swap a[n-1] and a[n] instead of traversing\
    \ the array twice and swapping every two elements, which is O(n^2).\n<|/ c |>\n\
    <| a dscore=1 tags=ruby,sorting,arrays |>\nUse a Schwartzian Transform\nI wrote\
    \ a solution using an implementation of the Schwartzian Transform which is implemented\
    \ in Ruby here:\nhttps://github.com/jeffkreeftmeijer/schwartzian#schwartzian-transform\n\
    I wrote a benchmark that uses Schwartzian Transform to sort an array of size 2000,\
    \ and compares this to sorting the array using bubble sort.\nUsing Schwartzian\
    \ Transform reduces the complexity to O(n log(n)), which is the expected time\
    \ complexity of the Schwartzian Transform.\n<code>\nrequire 'schwartzian'", " \
    \ l2 = []\n  count = 0\n  for i in l\n    count += 1\n    if count % 3 != 0\n\
    \      l2.push i\n    elsif i % 3 != 0\n      l2.push i\n    end\n  end\n  return\
    \ l2\nend\n</code>\n<|/ a tags=sorting,ruby |>\n<| c |>\nHi, I appreciate your\
    \ help. This is very helpful. I am going to look into this more and also try to\
    \ implement the other suggestions.\n<|/ c |>\n<| a |>\nYou can do something like\
    \ this:\n<code>", "    l.each do |i|\n        l.delete_at i\n    end\n    l.each_index\
    \ {|i| l[i] = l[i].sort}\nend", "    l = l.sort\n    l.each_with_index {|v, i|\
    \ l[i] = v if !(i % 3) == 0}\n    l\nend", "  l2 = l.dup\n  l2.each_with_index\
    \ do |e, i|\n    if i % 3 != 0\n      l2.delete_at(i)\n    end\n  end\n  return\
    \ l2\nend", "  l.each_with_index do |x, i|\n    if i%3 == 0\n      l[i] = l[i%l[0].size]\n\
    \    end\n  end\n  l\nend", "  l3 = l.sort\n  l3.each_with_index { |v, i| l3[i]\
    \ = v unless i % 3 == 0 }\n  return l3\nend", "  l.each_with_index { |e, i| l[i]\
    \ = e if i && i % 3 == 0 }\n  l.sort!\nend", "  sorted_list = []\n  index = 0\n\
    \  while index < l.length\n    index = index + 1\n    if index % 3 == 0\n    \
    \  sorted_list << l[index]\n    else \n      sorted_list << l[index] / 3\n   \
    \ end\n  end\n  return sorted_list\nend\n</cell>\n<cell>", "  l.sort!\n  l.each\
    \ do |e|\n    break if e % 3 == 0\n    l.delete_at(e)\n  end\n  l\nend\n</code>\n\
    In ruby you can use the delete method on an array element (delete e) which will\
    \ remove that element from that array.  This also makes the function a lot more\
    \ concise.\nI hope this helps!\n<|/ a dscore=0 |>\n<| c |>\nThank you for taking\
    \ the time to write this.  I will have to study it further to understand it better,\
    \ but I appreciate it.\n<|/ c |>\n<| a dscore=0 |>\nYou can do this:\n<code>",
  "  l = l.sort_by{|e| e.to_i}\n  (l.length / 3).times do |i|\n    l[i * 3, 0] = l[i\
    \ * 3 + 2, 0]\n    l[i * 3 + 2, 0] = nil\n  end\n  l\nend", "  l.each_with_index\
    \ { |e, i| l[i] = e if i % 3 == 0 }\n  l.sort.each_with_index { |e, i| l[i] =\
    \ e if i % 3 != 0 }\n  l\nend\n</code>\nHere we apply the function sort_third\
    \ on our list l and get an equivalent list l'.\nIn general we would write the\
    \ function sort_third like this:\n<code>", "  l.each_with_index do |val, i|\n\
    \    l.delete_at(i) if i % 3 != 0\n    l.insert(i, val)\n  end\n  l\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\n`l.delete_at(i) if i % 3 != 0` should be `l.delete_at(i)\
    \ if i.odd?` (`i` will be zero on indices 0, 2, 4, 6, 8...)\n<|/ c |>\n<| a tags=ruby\
    \ dscore=1 |>\nTry with group_by\n<code>", "  l.each_with_index do |e, i|\n  \
    \  next if i == 0\n    j = l.index(e, i+1)\n    l.delete_at(j)\n    l.insert(j,\
    \ e)\n  end\n  l\nend", "  result = l\n  l.size.times do |i|\n    if i % 3 ==\
    \ 0\n      result.insert i, l[i]\n    end\n  end\n  result\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nThank you for the answer. I can't understand what you meant with\
    \ \"your solution is not O(n)\".\n<|/ c |>\n<| c |>\nI meant that your solution\
    \ is not O(n). I've added an explanation of what I'm talking about.\n<|/ c |>\n\
    <| c |>\nIt's very unlikely that that code is O(n). `Array#insert` does `O(n)`\
    \ work. Since it can call `O(n)` methods for each element that is inserted, the\
    \ overall complexity is `O(n^2)`. It's much more likely that there is a better\
    \ solution to the problem than what you're proposing. For example, if you want\
    \ all values to be unique, you can use the `Set` class instead of the `Array`\
    \ class. But I can't help you solve that problem without knowing the larger context.\n\
    <|/ c |>\n<| c |>\nI see your point. Thank you for your help!\n<|/ c |>\n<| a\
    \ |>\nA possible solution in Ruby\n<code>", "  l.each_with_index { |e,i| l[i]\
    \ = l[i] if (i % 3 != 0) && (l[i] % 3 != 0) }\n  l.sort!\n  l\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nHe wants to return the sorted array. Your solution\
    \ does not return the sorted array. Also, your `sort_third` function doesn't return\
    \ anything.\n<|/ c |>\n<| c |>\nYou're right, I missed the sorting. Though this\
    \ answer is also a good solution to the problem at hand, it does not address the\
    \ OP's question which is how to return an array instead of modifying a passed\
    \ in array.\n<|/ c |>\n<| a dscore=0 |>\nThis should work for you:\n<code>", " \
    \ l.each_with_index do |elem, i|\n    if i % 3 != 0\n      l[i] = elem\n    end\n\
    \  end\n  l\nend", "  l.sort!\n  l.chunk {|e| e % 3 == 0 ? e.to_i : nil }.compact!\n\
    \  l\nend", "  third = l.each_with_index.reduce(:+).modulo(3).zip(l).uniq.sort\n\
    \  third.each_with_index { |(a, i),| (l[a] == l[i]) && (l[a] = i); l[a] }\nend",
  "  l.sort!\n  l.each_with_index do |e, index|\n    if index%3 != 0\n      l[index]\
    \ = e\n    end\n  end\n  return l\nend\n</cell>\n<cell>\nsort_third(arr)\n</cell>\n\
    <text>\nExercise 3.8\nWrite a function called sort_all that takes an array l and\
    \ returns an array l' such that\nl' is identical to l in the indicies that are\
    \ not divisible by three and all the values at the indicies that are divisible\
    \ by three are equal\nto the values of the corresponding indicies of l, but sorted.\n\
    >>> sort_all.call([1, 2, 3])\n[1, 2, 3]\n>>> sort_all.call([5, 6, 3, 4, 8, 9,\
    \ 2])\n[2, 3, 4, 6, 8, 9, 5]\n>>> sort_all.call([3, 5, 1, 1, 2, 4])\n[1, 2, 3,\
    \ 4, 3, 5]\n>>> sort_all.call([2, 3, 4, 5, 3, 1])\n[1, 2, 3, 4, 4, 3]\n>>> sort_all.call([4,\
    \ 1, 2, 3, 3])\n[3, 2, 1, 4, 3]\n>>> sort_all.call([4, 1, 2, 3, 1])\n[1, 2, 3,\
    \ 4, 3]\n>>> sort_all.call([4, 1, 2, 3, 4])\n[1, 2, 3, 4, 4]\n>>> sort_all.call([4,\
    \ 1, 2, 3, 5])\n[1, 2, 3, 4, 4]\n>>> sort_all.call([4, 1, 2, 3, 6])\n[1, 2, 3,\
    \ 4, 4]\n>>> sort_all.call([4, 1, 2, 3, 7])\n[1, 2, 3, 4, 4]\n>>> sort_all.call([4,\
    \ 1, 2, 3, 8])\n[1, 2, 3, 4, 4]\n>>> sort_all.call([4, 1, 2, 3, 9])\n[1, 2, 3,\
    \ 4, 4]\n>>> sort_all.call([4, 1, 2, 3, 10])\n[1, 2, 3, 4, 4]\n>>> sort_all.call([4,\
    \ 1, 2, 3, 11])\n[1, 2, 3, 4, 4]\n>>> sort_all.call([4, 1, 2, 3, 12])\n[1, 2,\
    \ 3, 4, 4]\n>>> sort_all.call([4, 1, 2, 3, 13])\n[1, 2, 3, 4, 4]\n>>> sort_all.call([4,\
    \ 1, 2, 3, 14])\n[1, 2, 3, 4, 4]\n>>> sort_all.call([4, 1, 2, 3, 15])\n[1, 2,\
    \ 3, 4, 4]\n>>> sort_all.call([4, 1, 2, 3, 16])\n[1, 2, 3, 4, 4]\n>>> sort_all.call([4,\
    \ 1, 2, 3, 17])\n[1, 2, 3, 4, 4]\n>>> sort_all.call([4, 1, 2, 3, 18])\n[1, 2,\
    \ 3, 4, 4]\n>>> sort_all.call([4, 1, 2, 3, 19])\n[1, 2, 3, 4, 4]\n>>> sort_all.call([4,\
    \ 1, 2, 3, 20])\n[1, 2, 3, 4, 4]\n>>> sort_all.call([4, 1, 2, 3, 21])\n[1, 2,\
    \ 3, 4, 4]\n>>> sort_all.call([4, 1, 2, 3, 22])\n[1, 2, 3, 4, 4]\n>>> sort_all.call([4,\
    \ 1, 2, 3, 23])\n[1, 2, 3, 4, 4]\n>>> sort_all.call([4, 1, 2, 3, 24])", "  l.each_with_index\
    \ do |e, i|\n    e <= l[i]\n    l[i] < e ? l[i] = e : l[i] = e\n  end\n  l\nend",
  "  l.each_with_index do |v, i|\n    i = i%3\n    v[i] = v[i]\n    v\n  end\nend",
  "    l = l.dup\n    l.sort\n    l.each_index { |i| l[i] % 3 != 0 ? l.delete_at(i)\
    \ : l[i] }\n    l\nend\n</cell>\n<cell>\nsort_third([4, 3, 9, 2])\n</cell>\n<text>",
  "  l = [1, 2, 3, 4, 5]\n  l.each_with_index do |e, i|\n    if i % 3 != 0\n     \
    \ l.delete_at(i)\n    end\n  end\n  return l\nend\n</code>\nThe function sort_third\
    \ returns the array [1, 4, 3, 5, 4, 2].\n<|/ a tags=ruby,arrays,sorting dscore=1\
    \ |>\n<| c |>\nThis solution is only valid if the numbers are always odd (otherwise\
    \ they will be sorted in reverse order) and the range from 1 to 9 (otherwise it\
    \ returns `[9, 10, 8, 7, 6]`).\n<|/ c |>\n<| c |>\nThanks for pointing that out,\
    \ I've fixed my solution\n<|/ c |>\n<| a tags=ruby,arrays,sorting dscore=1 |>\n\
    Here are my 2 cents:\n<code>", "  l.sort_by! do |x|\n    puts \"#{x} is not divisible\
    \ by three!\"\n  end\n  l\nend\n</code>\nEDIT: In response to your followup comment,\
    \ here's a way to get your desired result.\n<code>", "  a = [l[i] for i in range(0,\
    \ l.length) if i % 3 == 0]\n  b = [l[i] for i in range(0, l.length) if i % 3 ==\
    \ 1]\n  c = [l[i] for i in range(0, l.length) if i % 3 == 2]\n  l.sort_by! { |i|\
    \ a[i] <=> b[i] <=> c[i] }\nend\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n\
    <| a dscore=2 tags=ruby,ruby-on-rails |>\nYou need another array, for keeping\
    \ track of the original indices:\n<code>", "\tl - l.partition {|x| x % 3 == 0}\n\
    end", "  l.size.times do |i|\n    next if i > 0\n    if l[i] % 3 == 0\n      l[i],\
    \ l[i-1] = l[i-1], l[i]\n    end\n  end\n  return l\nend", "  l = l.sort\n  l[0\
    \ .. 2] <=> l[1 .. 0] \n      \n  l.all? { |i| i % 3 == 0 } && l.zip(l[1 .. l.size\
    \ - 1]).all? { |k, v| v % 3 == 0 } && l.zip(l[2 .. l.size - 1]).all? { |k, v|\
    \ v % 3 == 0 }\nend", "  l' =  l\n  for i in 0...l.length\n    if i%3 == 0  \n\
    \      l'.push( l[l.length-i-1] )\n      l'.push( l[i] )\n      l.length -= 2\n\
    \    elsif i != 0\n      l.length = i\n    end\n  end\n  return l'\nend\n</code>\n\
    The second function that you are trying to implement is called partition, which\
    \ takes an array l and an integer k, and returns the two indicies i and (j+1)\
    \ that are the kth smallest elements of l.  Note that these two functions do not\
    \ return any values, but rather they are used to modify the array passed in in\
    \ place.  In particular, partition(l, k) will do nothing if k is larger than l.length-1\
    \ or less than 0.\n<code>", "  l = (0..l.size-1).to_a\n  l[0]\n  l[1]\n  l[l.size-2]\
    \ || l[-1]\n  l.each do |i|\n    begin\n      j = (i + 1)%l.size\n      l[j] ==\
    \ l[i] ? l[j] = nil : l[j] = l[i]\n    rescue\n    end\n  end\n  l.sort\nend",
  "    even = l.select { |x| x % 3 == 0 }\n    odd = l.select { |x| x % 3 == 1 }\n\
    \    third_list = even.zip(odd).to_a\n    third_list.sort.map { |x, y| [x, y]\
    \ }\nend", "    l = l.clone\n    l.each_with_index do |e, i|\n        if (i %\
    \ 3 == 0)\n            l[i] = l[i-1]\n        end\n    end\n    l\nend\n</cell>\n\
    <cell>", "  l.each_with_index do |e, i|\n    puts \"Index #{i} - #{e}\"\n  end\n\
    \  l2 = l.dup\n  l2.sort!\n  l2.each_with_index do |e, i|\n    if i % 3 == 0\n\
    \      l2[i / 3] = l2[i / 3].sort.join\n    end\n  end\n  puts \"#{l2.inspect}\"\
    \n  puts l2\n  puts l.inspect\n  puts l\nend\nsort_third(l)", "  l.each_with_index\
    \ { |n, i| l[i] = l[i] if i % 3 == 0 }.sort\n  l\nend\n  ", "  return l.sort_by\
    \ { |x| x[1..-1] % 3 == 0 ? x[-2, 1] : x[-1] }\nend\n</code>\n<|/ a tags=sorting,ruby,arrays\
    \ |>\n<| c |>\nThis is nice. One small note though: I believe `sort_by` should\
    \ be `sort` (because your comparison method returns the same thing no matter what).\
    \ `sort` will compare each pair of elements, and if they don't match, it'll return\
    \ `false` and swap the elements. `sort_by` will return `true` if the comparison\
    \ returns `false` and the elements are swapped.\n<|/ c |>\n<| a tags=sorting,ruby,arrays\
    \ dscore=2 |>\n<code>\narr = [5, 6, 3, 4, 8, 9, 2]\narr.chunk {|e| e % 3 }.map\
    \ {|c,e| [*c,e] }.sort", "  l.sort{|a, b| b % 3 <=> a % 3}\nend\nputs sort_third.call([5,\
    \ 6, 3, 4, 8, 9, 2])", "  l.sort!\n  l = l.partition{ |x| (x % 3) == 0 }\n  l.collect!{\
    \ |x| (x % 3 == 0) ? x : x.to_i }\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\n\
    <code>", "  l3 = (l[2]..l[4]).to_a + (l[0]..l[3]).to_a\n  l3[0] = l[0]\n  l3[-1]\
    \ = l[-1]\n  l3.sort\n  l3\nend\n</code>\n<|/ a |>\n<| a |>\nAnother option that\
    \ would give you an Array rather than a Range (as Ranges don't have a sort! method):\n\
    <code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
