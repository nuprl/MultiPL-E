name: HumanEval_47_median
language: rb
prompt: "# Return median of elements in the array l.\n# >>> median.call([3, 1, 2,\
  \ 4, 5])\n# 3\n# >>> median.call([-10, 4, 6, 1000, 10, 20])\n# 15.0\ndef median(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_median\n\
  \    candidate = method(:median)\n    assert_equal(3, candidate.call([3, 1, 2, 4,\
  \ 5]))\n    assert_equal(8.0, candidate.call([-10, 4, 6, 1000, 10, 20]))\n    assert_equal(5,\
  \ candidate.call([5]))\n    assert_equal(5.5, candidate.call([6, 5]))\n    assert_equal(7,\
  \ candidate.call([8, 1, 3, 9, 9, 2, 7]))\n  end\nend\n"
completions: ["  return l[l.length / 2]\nend", "  return reduce(lambda x, y: x if\
    \ x % 2 == 0 else (x + y) // 2, l)\nend", "  l.sort!\n  return l[(l.length / 2)\
    \ - 1]\nend\n</cell>\n<text>\nLet's now implement median() as a method of Array\
    \ that we can use on any array of numbers.  We'll make it an instance method and\
    \ make it available to all arrays.", "  l.sort # sort the list in-place\n  m =\
    \ l.length\n  if m == 0\n    throw :Exception,\n        \"median of an empty list\"\
    \n  m / 2\nend", "  l.sort\n  l = l[l.length / 2]\n  if l.length == 1\n    l +=\
    \ 0\n  end\n  return l\nend", "  l = l.sort\n  if l.length < 2\n    throw :median\n\
    \  m = l.length / 2\n  if l == []\n    l[0]\n  else\n    l[m] < l[m - 1] ? l[m]\
    \ : l[m - 1]\n  end\nend", "  l.sort.call\n  (l.size % 2 == 0)? l[(l/2).floor]\
    \ : ((l[(l.size/2)-1] + l[(l.size/2)])/2)\nend", "  l.sort_by! { |e| e }\n  size\
    \ = l.size\n  return l[size/2] if size % 2 == 0\n  mid = size / 2\n  return (l[mid-1]\
    \ + l[mid]) / 2.0\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThe algorithm can\
    \ be improved by counting the number of elements smaller than each number and\
    \ computing the median of the smaller numbers. But the median is usually a function\
    \ of the mean of an array. So this algorithm is also wrong.\n<|/ c |>\n<| c |>\n\
    , that is a very good point. The median is the mean of the two middle elements.\
    \ I was using the median of medians algorithm where I used the mean of medians\
    \ to find the median (which is what most people mean when they say \"median\"\
    ), but that's not always the case. This algorithm is wrong for many other cases.\
    \ To find out the median of medians, I use the median of means. I will update\
    \ the algorithm to account for that case. Thank you for pointing that out.\n<|/\
    \ c |>\n<| a |>\nThis is a nice solution, although it does a lot more work than\
    \ necessary and should be optimized to run in O(n) time and space.\nThe idea is\
    \ to find the median (which is not always its mean), then find the median of its\
    \ two neighbors.\n<code>", "  return l[((l.length)/2)] if l != [] else 0\nend",
  "  l.sort!\n  if l.length % 2 == 0\n    mid = (l.length / 2).round\n    (l.length\
    \ / 2).round\n  else\n    mid = (l.length / 2).round\n  end\n  return((l[mid-1]\
    \ + l[mid]) / 2).round(2)\nend", "  l.sort\n  return l[(l.length/2).floor] if\
    \ l % 2 == 0 \n  l = l[(l.length/2).floor].to_f / 2.0\n  return l\nend", "  l.sort!\n\
    \  len = l.length\n  if len < 2\n    return l[0]\n  mid = len / 2\n  if len %\
    \ 2 == 0\n    return l[mid]\n  else\n    return (l[mid - 1] + l[mid]) / 2\nend",
  "  if l.length < 2\n    l.first\n  else\n    middle = (l.length - 1) / 2\n    l.take_while{\
    \ |x| x < middle } + l.take_while{ |x| x > middle } + middle\n  end\nend\n</code>\n\
    <|/ a dscore=0 tags=ruby,arrays |>\n<| a tags=ruby,arrays |>\n<code>\narr = [1,3,4,5]\
    \ \narr.sort.each_cons(2).last #=> [5, 5]\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    A good answer includes an explanation of how your answer works and why you chose\
    \ it as the best answer. Have a look to [answer] for more information.\n<|/ c\
    \ |>\n<| a dscore=0 |>\nA little shorter than previous answers:\n<code>", "  l.sort.with_index\
    \ do |x,i|\n    ((i+1)/2) - 1 if x.nil? || x.zero?\n  end\nend", "  l.sort { |a,\
    \ b| b.to_f <=> a.to_f }\n  l.length == 0 ? l.first : l[(l.length-1)/2].to_f +\
    \ l[l.length/2].to_f\nend", "  return l.sort {|a, b| b < a}.uniq.length / 2\n\
    end", "  l.sort!\n  size = l.size\n  if size&1\n    return l[(size-1)/2]\n  else\n\
    \    (size-1)/2\n  end\nend\n</pre>", "  l.sort # Sort the array\n  if l.length\
    \ % 2 == 0\n    return l[l.length / 2] # Return middle number\n  else\n    l.length\
    \ /= 2 # Get the average of the two numbers\n    return ((l[l.length - 1] + l[l.length\
    \ - 1]) / 2.0) # Return the middle number\nend\n</code>\n<|/ a dscore=5 |>\n<|\
    \ c |>\nIt's better not to rely on the sort order of the list. Why not just sort\
    \ the list on the go when it's first needed and then use each element to find\
    \ the median? Of course that means sorting it twice, once for the length check\
    \ and then once for the median. But then you also avoid the case where it's already\
    \ sorted.\n<|/ c |>\n<| c |>\n+1 for the median implementation. Though it's quite\
    \ easy to implement the median yourself, the median implementation I linked to\
    \ in the other answer takes much less code.\n<|/ c |>\n<| c |>\nThe median implementation\
    \ is more efficient than the one in this answer, but it doesn't work if there\
    \ are more than two elements (it returns the last element).\n<|/ c |>\n<| c |>\n\
    : Your question specifically asked for help with the average and median functions.\
    \ That is not the median function. The median function in that answer does not\
    \ work if there are more than two elements. My answer here does work if there\
    \ are more than two elements. And it has the advantage of being simpler.\n<|/\
    \ c |>\n<| c |>\nThe median function works with any list of length 2 or greater.\
    \ Your code will fail when there are 3 or more elements.\n<|/ c |>\n<| a dscore=5\
    \ tags=sorting,ruby,average |>\nYou can use the sort_by method and a block to\
    \ return the average of the values. The block can return the value directly if\
    \ it does not need an external variable or you can return the result of a block\
    \ to an external variable.\n<code>\n[1,2,3,4,5].sort_by { |i| i } # [1,2,3,4,5]\n\
    [1,2,3,4,5].sort_by { |i| i }.reduce(:+) / 5.0 # 2.5\n</code>\n<|/ a |>\n<| c\
    \ |>\nI believe you can do `[1,2,3,4,5].sort_by(&:itself)`\n<|/ c |>\n<| c |>\n\
    I believe this is an elegant and simple solution to get the median of an array.\
    \ Thank you!\n<|/ c |>\n<| c |>\n`[1,2,3,4,5].sort_by { |i| i }.reduce(:+)/5.0\
    \ #=> 2.5` doesn't work for arrays of length ", "  l.sort.sort.reverse!\n  return\
    \ l[((l.count/2).ceil -1)..-1].median\nend", "  l.sort!\n  mid = l/2\n  return\
    \ l[mid] if mid > 0 and mid < l.length else\n    (l.length / 2).round*2\nend\n\
    \  ", "  return l.sort do |a, b|\n    (a + b) / 2.0\n  end[l.size / 2]\nend",
  "  if l.empty? then nil\n  elsif l.size < 2 then\n    l[0]\n  else\n    fl = l.sort\n\
    \    fl.length/2\n  end\nend\n</code>\n<|/ a tags=ruby,methods |>\n<| a |>\nHere's\
    \ a very simple way to do it using inject.\n<code>", "  l.sort.with_index { |e,i|\
    \ i } # Sort by index\n  len = l.length\n  i = len/2\n  median = l[i]\n  while\
    \ i < len\n    median = (l[i-1] + l[i]).floor/2\n    i += 1\n  end\n  return median\n\
    end", "  l.sort!\n  return l[(l.length + 1)/2].to_f\nend\nadd_method(median, :call)",
  "  l.sort \n  n = l.length\n  if n % 2 == 0 \n    # even\n    return (l[(n+1)/2]\
    \ + l[n/2])/2\n  else \n    # odd\n    return l[(n-1)/2]\nend", "  if l.length\
    \ == 0\n    throw :error, ERR.NO_ELEMENTS\n  l.sort!\n  l.length / 2\nend", " \
    \ l.sort.reduce(l[l.length / 2], :+) if l.length / 2 > 0 else l.first\nend", " \
    \ # Get the median of all the numbers in l.\n  m = l.sort\n  p =\n  n = l.size\n\
    \  if n % 2 == 1\n    puts \"Cannot calculate the median of an array of size #{n}.\"\
    \n  else\n    # Return the average of the two middle values.\n    p + (n - 1)\
    \ / 2.0\n  end\nend", "  return l.sort.reverse.find { |x| x.odd? }.to_f / 2\n\
    end", "  sorted = l.sort\n  if sorted.empty? \n    sorted\n  else\n    sorted.last\
    \ + sorted.size / 2 if sorted.size % 2\n  end\nend", "  sorted = l.sort\n  l =\
    \ sorted.length if sorted.length < 1000 else 1000\n  if l < 10 then return sorted.last\n\
    \  midpoint = l / 2\n  if midpoint % 2 == 0 then midpoint += 1\n  sorted.each_with_index\
    \ do |x,i|\n    break if i == midpoint\n  else\n    return sorted[midpoint]\n\
    \  end\nend\n</code>\n<|/ a |>\n<| a tags=ruby,arrays dscore=4 |>\nThe simplest\
    \ way is to use the Array#median method, e.g.\n<code>", "  l.sort!\n  l/2\nend",
  "  return l.sort do |a,b|\n    a = a < 0 ? -a : a\n    b = b < 0 ? -b : b\n    a\
    \ < b ? -1 : a\n  end[l.length / 2]\nend", "  l.sort.to_a\n  ((l.last - l.first)\
    \ + 1).floor / 2\nend", "  if l.length == 0 or l.length < 2\n    return l[0]\n\
    \  m = ((l[0] + l[l.length/2 - 1]) / 2).floor\n  (l[m-1] + l[m]) / 2.0\nend",
  "  l.sort\n  len = (l.length) / 2 unless l.length.is_a? Integer\n  len.times { l.delete_at((l.length\
    \ - len).floor) }\n  l[len.to_i].is_a?(Numeric) ? l[len.to_i].to_f : median\n\
    end", "  return l.sort.inject(0.0, (l, a) do |m, v|\n    m + ((l.size - 1) / 2.0)\
    \ * (a + v) / 2.0\n  end) if l.size != 0\nend", "  return l[median_index(l)]\n\
    end", "  l.sort\n  if l.length == 0 || l.length % 2\n    l.length /= 2\n  l.length\n\
    end", "  return l.sort.last if l and l.any? and l.size % 2 == 0 ? (l[l.size/2-1]\
    \ + l[l.size/2]) / 2 : nil\nend", '  l.sort!', "  # Sort l. If l is empty, return\
    \ NaN. Else return median(l) by\n  # dividing into three groups, as explained\
    \ in the method description.\n  lsorted = (l <=> []) if l.empty?\n  lsorted =\
    \ [-lsorted] if l.size < 2\n  lsorted[1]\nend\n</cell>\n<text>\nMethods\nMethods\
    \ are callables with arity 1 (see Methods below). They can be called via obj[method_name]\
    \ or obj.method_name() syntax.", "  l = l.sort\n  l.length\n  (l.length / 2) >\
    \ 0 ? l[(l.length / 2) - 1] + l[(l.length / 2)] / 2 : 0\nend", "    l.sort\n \
    \   return l[l/2]\nend", "  l.sort!\n  n = l.size\n  p + (n/2).times {l << (l.size/2)}\n\
    end", "  l.sort.call(&:abs)\n  l.count { |x| x < l.first }.div 2\nend\n</cell>\n\
    <text>\nExercise\nWrite a method named median? that returns true if and only if\
    \ given array l contains at least half of the same values from the first half\
    \ of array l. If the array has odd number of elements, then there should be at\
    \ least one such value from the first half and one such value from the second\
    \ half. Otherwise, return false (no such values).", "  return l.sort.last/2\n\
    end", "  l.sort!\n  return l[(l.length-1)/2]\nend", "  l.sort!\n  l = l.size /\
    \ 2\n  if l % 2 == 0\n    l\n  else\n    l + 1\n  end\nend", "  return l.length?l/2.0:l.sort!.last/2\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThe downside of having the implementation details\
    \ of the language in the code isn't worth the effort in my opinion. People should\
    \ keep it out of code at all cost.\n<|/ c |>\n<| c |>\n.J.: I agree with you.\
    \ But for someone who wants to understand how a functional programming language\
    \ works it is easier than learning a foreign language and how it works.\n<|/ c\
    \ |>\n<| c |>\nI agree with that completely. I've spent most of my life learning\
    \ Lisp after seeing how bad it was to learn a new language and how bad it was\
    \ to learn a new language, while learning a new language was a good goal. Now\
    \ that I have had a decent amount of experience using Lisp I find the syntax of\
    \ Lisp much easier to comprehend than Python, Ruby, and even Javascript. Though\
    \ Ruby also looks quite different.\n<|/ c |>\n<| c |>\n.J.: Thanks for sharing\
    \ your experience. By the way, I don't know how you guys come to learn Ruby. I'd\
    \ prefer a book, not a tutorial. I'd also like to be able to explain things I\
    \ already know and which I am not aware of. That's what people like me who spend\
    \ most of my time in Lisp do.\n<|/ c |>\n<| c |>\n: I find [this book](http://shop.oreilly.com/product/0636920024344.do)\
    \ to be a good start. Also [this page](http://www.pragprog.com/titles/978/pragmatic-programming-ruby)\
    \ and [this one](http://www.pragprog.com/titles/ruby2/pragmatic-programming-ruby).\n\
    <|/ c |>\n<| a tags=ruby,programming-languages,functional-programming |>\nRuby\
    \ is not the best of functional languages, at least not if you're going to be\
    \ doing any serious functional programming. It's not so bad when you are working\
    \ on something really trivial though.\nThat said, Ruby is very easy to pick up\
    \ and write for someone who is already familiar with other functional languages.\
    \ When you get more comfortable, you can consider learning a new functional language\
    \ like Clojure, Rhino, or Scheme.\n<|/ a dscore=2 |>\n<| c |>\nI've started using\
    \ Racket and Rub", "  l.sort\n  return l[(l.size+1)/2] if l.size % 2 == 1 \n \
    \ l = l - (l[l.size/2-1] + l[l.size/2]) / 2\nend", "    l.sort\n    llen = l.length\n\
    \    return llen == 0 ? nil : (llen - 1) / 2 + l[l.length / 2]\nend", "  l.sort!\n\
    \  r = l/2\n  l > 0 ? return (r + l).floor : return  l if r == l\n  r - l > 1\
    \ ? return l + r.ceil : return r\nend", "  if l.empty?\n    l.fdiv(1)\n  else\n\
    \    m = l.sort.last\n    l.each_cons(2) do |x|\n      break if x[0] == m\n  \
    \    m = x[1]\n    end\n  end\nend", "  return l.sort(&:abs)[((l.length + 0.0)\
    \ / 2).round]\nend\n</pre>\n<pre>", "  return l.sort().inject(:+) / 2.0\nend",
  "  l.sort\n  length = (l.length) / 2\n  if length == 0 then return nil\n  median\
    \ := l[length]\n  for index in length..-1 do\n    if l[index] < median then\n\
    \      median := l[index]\n    end\n  end\n  return median\nend", "\tl.sort {\
    \ |a, b| a <=> b }\n\treturn l[(l.length / 2).floor]\nend", "  return ((l.empty?\
    \ or l.size % 2 == 0) ? nil : median(l.first(l.size / 2))) + l.last(l.size / 2)\n\
    end", "  if l.length < 2\n    raise ArgumentError, \"median requires at least\
    \ two elements\"\n  n = l.length\n  sorted = l.sort\n  half = n/2\n  sorted =\
    \ sorted.reverse.take(half)\n  if n % 2 == 0\n    sorted[n/2] = sorted[n/2-1]\
    \ + sorted[n/2]\n  end\n  return sorted[half]\nend", "  return l.sort {|a,b| a<=>b}.sort.last\
    \ if l.size % 2 == 1\n  (a+b)/2\nend\n    ", "  return l ? (l.sort.length + 0.5)\
    \ /\n              (l.length - 1) : (l + [\"\"]).length / 2.0\nend\nmedian._name\
    \ = \"median\"", "  l.sort.reverse.first\nend", "  l.sort!\n  l[-1]\nend\n  ",
  "  l.sort!\n  len = (l.size << 1) >> 1\n  len.times do\n    m = len / 2\n    l.slice!((m\
    \ * -1)...m).min\n  end\n  return l.first\nend", "  l.sort.call\n  l = l[0...(l.length/2)-1]\
    \ if l.length % 2 == 0 else l[0...(l.length-1)/2]\n  l[(l.length)/2...-1]\nend",
  "  l.sort!\n  l.size/2\n  l.size-1\nend", "  return l.sort.last if l.size > 0 else\
    \ -1\nend", "  l.sort.to_a[0..-1].find{|x| (x.length == 0 || x < l[0]).to_s}\n\
    end", "  # If there are no elements, return None.\n  raise ArgumentError if l.empty?\n\
    \  n = l.size\n  # If the array is of size 0, return None.\n  raise ArgumentError\
    \ if n < 1", "  l.sort!\n  \n  if l.size % 2 == 0\n    return l[(l.size / 2) -\
    \ 1]\n  else\n    m = l[(l.size / 2) - 1]\n    l.each { |v| if m < v then m =\
    \ v end }\n    return m\n  end\nend", "  l.sort!\n  if l.length == 0\n    return\
    \ 0\n  end\n  return l[(l.length / 2).floor]\nend", "  return l.sort[l.size/2]\n\
    end", "  return l.sort.last.median\nend", "  l.sort.with_index do |a,i|\n    if\
    \ i > 0 && l[i-1] > a then\n      l[i-1]\n    elsif i > 0 && l[i-1] == a then\n\
    \      (l[i-1]+l[i]) / 2.0\n    elsif i == 0\n      l[0]\n    else\n      l[i]\n\
    \    end\n  end\nend\n</code>\n<|/ a dscore=1 tags=ruby,arrays,ruby-on-rails-3\
    \ |>\n<| c |>\nThis fails for `[1, 1, 1, 1]`\n<|/ c |>\n<| c |>\nThis fails for\
    \ `[1, 1, 1, 1]`.\n<|/ c |>\n<| c |>\nYou probably mean `[1, 2, 3, 4, 5]` fails\
    \ `[1, 1, 1, 1]`\n<|/ c |>\n<| c |>\nYou probably mean `[1, 2, 3, 4, 5]` fails\
    \ `[1, 1, 1, 1]`\n<|/ c |>\n<| c |>\nThis fails for `[1, 1, 1, 1]`\n<|/ c |>\n\
    <| a dscore=1 |>\n<code>", "  return l.sort &\n         l.sort[-2..-1] &\n   \
    \      reduce( (a, b) -> (a + b) / 2.0, l) &\n         l.sort[0..(l.size & -2)]\
    \ &\n         last(l) if l > 0.5 ? l.size : nil\nend\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nThis is a brilliant solution to the problem!  I really like how\
    \ you separated the method from the implementation.\n<|/ c |>\n<| a dscore=3 |>\n\
    You could also use Enumerable#sum with a block\n<code>\na = [0,1,2,3].sum {|x|\
    \ x}\n</code>\n<|/ a tags=ruby,algorithm,arrays |>\n<| c |>\nThis is interesting\
    \ as it does not modify the array in place. Thanks!\n<|/ c |>\n<| c |>\nI see\
    \ that `a.sum` is deprecated and this should be replaced with `a.sum { |x| x }`.\
    \ https://apidock.com/ruby/Enumerable/sum\n<|/ c |>\n<| a |>\nFor summing up an\
    \ array without mutating it, you can also use the inject method:\n<code>", " \
    \ l = l.to_a\n  l.sort!\n  (l == [Float::NAN] ? l.shift : l[(l / 2).floor]).to_f\n\
    end", "  return l[l.length/2] if l.length%2 > 0 then\n    l[l.length/2-1] + l/2\
    \ \n  else\n    l[l.length/2-1]\n  end\nend\n</code>\n<|/ a dscore=0 tags=ruby,arrays\
    \ |>\n<| a dscore=0 |>\nThis can be done with Array#min:\n<code>\narr = [\n  \
    \  5,\n    10,\n    20,\n    30,\n    25,\n]", "  return l.sort.last(l/2).median\n\
    end", "  l.sort.with_index { |e, i| return i if i <= l.size / 2 }\n  l.length\
    \ / 2\nend", "  l.sort.with_index{|x,i| i < l.length / 2 ? (l[i/2] + l[i/2+1])\
    \ / 2 : l[l.length/2]}\nend\n</cell>\n<text>\nThe median is a number that is in\
    \ the middle of two numbers. If there are an even number of numbers in the list,\
    \ then the median is the average of the two middle numbers. If there are an odd\
    \ number of numbers, then the median is the number that is in the middle of the\
    \ two numbers that is closest to the middle number. Notice that we are sorting\
    \ our numbers before computing the median.", "  return median.call([e] for e in\
    \ l)\nend", "  # Compute the median in linear time. |l| == length of list\n  if\
    \ l.length < 2\n    l.to_i\n  else\n    l.inject(0, :+).reduce(:+) / l.length\n\
    \  end\nend", "  return median.call((l,))\nend", "  return sort.call(l).median\n\
    end", "  l.sort!\n  (l.length % 2).zero? ? l[l/2] : (l[(l/2)-1] + l[l/2]) / 2.0\n\
    end", "  if l == []\n    error('Empty list!')\n  end\n  median_value = l[l.length/2]\n\
    \  i = 0\n  while i < l.length-1\n    median_value = l[i] if l[i] < median_value\
    \ else median_value\n    i += 1\n  end\n  median_value = l[i] if l[i] > median_value\
    \ else median_value\n  return median_value\nend", "  l.sort!\n  l/2\nend", " \
    \ return reduce(lambda x, y: x if (x < y) else y, l)\nend\nfunction median(x)\n\
    \  return median(x or [])\nend", "  sorted = l.sort\n  midpoint = (sorted.length\
    \ + 1)/2\n  sorted.length <= midpoint and return sorted[midpoint-1]\n  return\
    \ sorted[midpoint] if sorted.length % 2 == 0 else (sorted[midpoint-1] + sorted[midpoint])/2\n\
    end", "  return l.sort.inject { |m,n| m + ((l.size - m) / 2.0).floor }\nend",
  "  l.sort\n  ((l + [l.first]).pop / 2).floor\nend\n</cell>\n<text>\nExercise:\n\
    Write a method called mean that takes an array and returns the mean of the numbers\
    \ in the array.", "  l.sort\n  l[l.length/2]\nend", "  l.sort\n  len = (l.length\
    \ / 2).ceil\n  len.times do |i|\n    i = len-i\n    break if i%2 == 1\n  end\n\
    \  ((l[len/2]+l[len/2+1])/2)\nend", "  return l.sort.last if l and l.size > 0\
    \ and not l.empty? and l.any? {|x| x.is_a?(Numeric)} and l.size > 1 ? ((l.first\
    \ + l.last) / 2).floor : nil\nend", '  l.sort!', "  return l.sort[l.length / 2,\
    \ 1]\nend", "  return l[((l.length + 1) / 2).downto(1).max_by { |e| l.count(e)\
    \ }\nend", "\tl = l.to_a\n\tm = l.length\n\tif m < 1\n\t\t0\n\telsif m % 2 ==\
    \ 0\n\t\t(l/2).inject(&:+).to_a[m/2-1]\n\telse\n\t\t(l/2).inject(&:+).to_a[m/2]\n\
    \tend\nend", "  return l.sort[l.length/2]\nend", "  return l.sort [l.length //\
    \ 2]\nend", "  return l.sort.last if l.count % 2 == 0 \n              else median(l.sort[-2..-1])\n\
    end\n</cell>\n<code language=julia-0.5>\nmedian([3, 1, 2, 4, 5])\n</cell>\n<code\
    \ language=julia-0.5>\nmedian([-10, 4, 6, 1000, 10, 20])\n</cell>\n<text>\nLet's\
    \ see if it's efficient:", "  l.sort!\n  mid = l.length / 2\n  return (l[mid..-1]\
    \ + l[0...mid]).median\nend\nmedian = DynProc.new(:median)", "  return l[l/2]\n\
    end", "  l = l.sort\n  l.length ? l.length / 2.0 + 1 : 0\nend", "  l.sort.sort\n\
    \  len = l.length\n  return len / 2 if len % 2 == 0 ? (l[len / 2] + l[(len / 2)\
    \ - 1]) / 2 : l[len / 2 - 1]\nend", "  median.init\n  n = length(l)\n  if n ==\
    \ 0\n    n = 1\n  else\n    sort(l)\n    half = (n+0.5) / 2.0\n    median.value\
    \ = l[(half-1)..(half-1)].median\n  end\nend", "  return l.sort { |a, b| b <=>\
    \ a }.inject(:+) / 2\nend\n</pre>\n</div>", "  l.sort!\n  if l.size==0 || l.size==1\n\
    \    return l[0]\n  mid = l.length/2\n  if l.length % 2 == 1\n    return (l[mid-1]\
    \ + l[mid]) / 2\n  else\n    return l[mid]\nend", "  if l.length < 2\n    throw\
    \ :halt, l.length\n  else\n    l.sort.last / 2\n  end\nend", "  l.sort!\n  return\
    \ l[l.length / 2]\nend", "  l.sort.map!\n  begin = (l.size - 1) / 2\n  begin.times\
    \ { yield l[begin] }\n  end.times { yield l[begin..end].sort }.first\nend", " \
    \ l.sort!\n  if l.size % 2 == 0\n    l.size / 2\n  else\n    (l.size / 2) - 1\n\
    \  end\nend", "  l.sort!\n  l/= 2\n  (l.size / 2).floor.floor if l.size % 2 ==\
    \ 0\nend\nmedian =method :median # Deprecated, use median.call instead.", "  return\
    \ l.sort.sort[-2..-1].sort.sort[0]\nend", "  l.sort\n  \n  l == l.uniq.size ?\
    \ l.first : (l[(l.size - 1) / 2] + l[l.size / 2]) / 2.0\nend\n</code>\nAs you\
    \ can see, it's a bit more complicated than the other solutions, but it has the\
    \ advantage that it works for any array. Just change the def median(l) line to\
    \ def median(arr).\n<|/ a dscore=5 |>\n<| c |>\nTo clarify the second point: This\
    \ approach works by calling `sort` on each element in the array, and then using\
    \ `uniq.size` to get the length of the array. `l.first` works because `first`\
    \ is the default enumerator for the array in Ruby 1.9; `l[0]` will fail if `l`\
    \ is empty.\n<|/ c |>\n<| c |>\nTo clarify the last point: This approach works\
    \ by calling `sort` on the entire array, and then selecting the middle element.\n\
    <|/ c |>\n<| c |>\nFor anyone interested in performance, using Ruby 1.8.7 this\
    \ code takes 3x longer than the accepted answer on average (compared to 4x on\
    \ average). I wrote a quick ruby script to test it - https://gist.github.com/4074785\n\
    <|/ c |>\n<| c |>\nFor those interested in the performance and other things you\
    \ can do to improve the performance of this solution, take a look at the following\
    \ blog post http://www.mikeperham.com/2015/01/28/ruby-array-performance/\n<|/\
    \ c |>\n<| c |>\nThe answer by is much more succinct and easier to read, and works\
    \ in both Ruby 1.8 and Ruby 1.9.\n<|/ c |>\n<| a tags=ruby |>\nJust to add a variant\
    \ with a \"faster\" method with O(log n) complexity (which is actually a lot faster\
    \ than sort+uniq methods):\n<code>", '  l.sort!', '  l.sort!', "  l.sort\n  if\
    \ l.length <= 1\n    l[0]\n  else\n    l[l.length / 2]\n  end\nend", "  l.sort!\n\
    \  return l[(l.length + 1)/2].round(2) / 2.to_f\nend", "  l.sort!\n  l[l.length\
    \ / 2]\nend", "  return sort.call(l).pop(l.length / 2)\nend", "  l=l.sort\n  l.length>1\
    \ and return l[(l.length-1)/2]\n  l.length==1 and return l[0]\n  return nil\n\
    end", "  if l.empty?\n    l.length\n  else\n    l[l.length/2].to_f if l.length%2==0\
    \ # odd length list\n  end\nend", "  return l.sort.inject(0.0, :+) / 2.0\nend\n\
    </code>\n<|/ a tags=ruby,algorithm,arrays |>\n<| c |>\nThis solution has a few\
    \ bugs. For one, you don't need to sort the array, but you do need to compute\
    \ the median. You can do that by calculating `median = l[l.length/2]`, and then\
    \ using `l[l.length/2-1]` and `l[l.length/2]` to find the other two halves of\
    \ the array.\n<|/ c |>\n<| c |>\nAlso, when you're talking about \"medians\",\
    \ you don't usually mean \"the median of the array\". Rather, you want to find\
    \ an array element *strictly* less than the median, and the median is usually\
    \ defined as the element in the middle of the array.\n<|/ c |>\n<| c |>\nThanks\
    \ for pointing that out! As for your comment about finding the median when talking\
    \ about medians, it's actually a really good way to explain what it is. I tried\
    \ to make it a bit more obvious.\n<|/ c |>\n<| a |>\nI haven't tested this in\
    \ any way, but I think that it should work.\n<code>", "    l.sort!\n    l.length\
    \ % 2 == 0 ? l.length / 2 + 1 : l.length / 2\nend", '  return l.sort & l.sort.length
    == 2 ? l[l.index((l.sort.length + 1) // 2)] : (l.sort.length + 1) // 2', "  return\
    \ l.sort[l.size/2]\nend", "  l.sort\n  l.length\n  l[(l.length / 2).floor]\nend",
  "  return l.sort[l.size/2, 0]\nend", "  l.sort\n  if l.length == 1\n    l.first\n\
    \  else\n    (l.last - l.first) / 2\n  end\nend", "  return l == nil ? nil : l.size\
    \ / 2\nend", "  l.sort!\n  l = l.length if l.length < 3 else 3\n  l.length ==\
    \ 0 ? return nil : l[(l.length/2).floor]\nend", "  return l.sort.last.nil? ? Infinity\
    \ : (l.sort.last.last + l.sort.last.first + 1) / 2.0\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThanks for the solution. Your code is also correct and easy to understand\
    \ for my level. But I still prefer Kirti Arora solution. My code was easier to\
    \ read\n<|/ c |>\n<| a dscore=0 |>\nHere's a solution I tested and works nicely.\
    \ I think it's the most compact and most readable. It doesn't use an ugly helper\
    \ function. It doesn't require any additional gems.\n<code>", "  l.sort!\n  l/2\n\
    end", "  l.sort { |x, y| y <=> x } \n  l = l.sort\n  l.length < 2 ? l[0] : (l.length\
    \ / 2).floor + (l[l.length / 2] + l[l.length / 2 - 1]) / 2.0\nend", "  l.sort!\n\
    \  length = (l[-1] - l[0] + 1).abs\n  length = length if length % 2 == 0 then\
    \ length else length-1\n  index = (length / 2).floor\n  return l[index]\nend",
  "  l.sort.sort!\n  l.length / 2.0\nend", "  return l.sort.sort.reduce(&:+) / l.size\n\
    end", "  l.sort\n  mid1 = l.length/2\n  mid2 = mid1 + 1\n  if mid1 == l.length\n\
    \    mid2 = mid1 + 1\n  end\n  if mid2 == l.length\n    mid2 = mid1 + 1\n  end\n\
    \  if mid2 < mid1\n    return l[mid1]\n  else\n    return l[mid2]\n  end\nend",
  "  l.sort!\n  (l.length+1).floor.div(2)\nend\n</code>\n<|/ a |>\n<| c |>\nYour \"\
    median\" algorithm is not the median of the array, but rather an arbitrary element\
    \ in the array.\n<|/ c |>\n<| c |>\n, yes. I'm only suggesting median as another\
    \ solution, because the other one (using `sort!`) can be quite confusing.\n<|/\
    \ c |>\n<| c |>\nThanks for the answer! What if I have to sort an array of size\
    \ n?\n<|/ c |>\n<| c |>\n, `Array#sort` already returns the median when given\
    \ an array with even number of elements. `median` works even when given an odd\
    \ number of elements. That is, if `l = [1, 2, 3, 4, 5, 6, 7, 8]; median.call l`\
    \ returns `3` instead of `4`, then you only need to change the last line of my\
    \ code (from `l.length` to `l.length-2`). [Example](http://pastie.org/1555146)\n\
    <|/ c |>\n<| c |>\nNote that `l.length-2` doesn't always work, since the median\
    \ is defined as the middle element of the sorted subarray. That's why I suggest\
    \ using `partition`\n<|/ c |>\n<| a tags=ruby,algorithm,arrays |>\nThe way I would\
    \ write your solution is as follows:\n<code>", "  l.sort!\n  (l.length * 0.5).ceil.round\n\
    end\n</cell>\n<text>\nReturning multiple values from the function\nIf the function\
    \ returns a single value, we can store it in a variable, and use it for different\
    \ tasks", "  # Sort l, breaking ties by descending order. \n  l.sort.reverse!\n\
    \  return l[l/2].to_f if l.count > l.size / 2.0 else median(l)\nend", "  l.sort.with_index\
    \ do |element, i|\n    if element == l[i-1]\n      i\n    elsif element < l[i-1]\n\
    \      i\n    elsif element > l[i-1]\n      i - 1\n    else\n      nil\n    end\n\
    \  end\nend", "  l.sort.call\n  mid = l.length / 2\n  if l.length % 2 == 0\n \
    \   left  = l[mid-1..-1]\n    right  = l[0...mid]\n    left.length < right.length\
    \ ? left : right\n  else\n    left  = l[0...mid]\n    right  = l[mid+1..-1]\n\
    \    left.length < right.length ? left : right\n  end\nend", "  # We use median\
    \ as the name because it has the potential to improve the\n  # efficiency of the\
    \ selection sort algorithm. The sorted lists are used to\n  # keep track of the\
    \ positions of the largest and smallest values we've seen\n  # so far and which\
    \ values we've seen, so we can return the median value over\n  # the entire list.\
    \ Since this is only meant to improve efficiency, the\n  # algorithm is not optimal\
    \ in all cases: in some cases it may choose an\n  # element in the list to replace\
    \ an existing element, rather than putting it\n  # in the correct place.\n  sorted.length\
    \ = 0\n  sorted.fill(median, l)\n  sorted.length += 1", "  return l.sort && l.length?\
    \ l[l.length/2]: (l.length? l[0]: nil)\nend", "  median(l, 0).call\nend", "  l.sort!\n\
    \  l = l[1..-1] if l and l.size % 2 == 1\n  lmedian = (l[l.size/2-1] + l[l.size/2])\
    \ / 2.0\n  case lmedian when Numeric::Float\n    return lmedian\n  else\n    return\
    \ -1\n  end\nend", "  l.sort!\n  return l[(l.length-1)/2]\nend", "  l.sort!\n\
    \  l = l.length if l.length < 2 else 2\n  l = (l-1) / 2 + l\n  l = l % l if l\
    \ > 2\n  l.floor\nend", "  l.sort!\n  len = (l[0].length + l[1].length + l[2].length\
    \ + l[3].length)/4\n  return (l[0] + l[1] + l[2] + l[3]).length < len ? l[0] :\
    \ l[1] < l[2] ? l[1] : l[2] < l[3] ? l[2] : l[3]\nend\n    ", "  sorted = sort(l)\n\
    \  if sorted[sorted.length / 2] == sorted[sorted.length / 2 - 1]\n    return sorted[sorted.length\
    \ / 2]\n  mid = sorted.length / 2 - 1\n  return sorted[mid] if sorted[mid] ==\
    \ sorted[mid+1] else (sorted[mid-1] + sorted[mid+1]) / 2\nend", "  return l.sort.sort.last\n\
    end", "  l.sort\n  l.length\n  l[l.length / 2]\nend", "  if l.length == 0\n  \
    \  0.0\n  else\n    l.sort!\n    l[(l.length+1)/2].to_f / 2.0\n  end\nend", " \
    \ l.sort!\n  \n  if l.empty?\n    return nil\n  end\n  \n  if l.size == 1\n  \
    \  return l.first\n  end\n  \n  mid = (l.size / 2) - 1\n  \n  if l.size - 1 ==\
    \ mid\n    return l.first\n  else\n    return (l[mid] + l[mid+1]) / 2.0\n  end\n\
    end", "  l.sort.call(l.size / 2)\nend", "  return l.sort.sort[-2] if l.sort.size\
    \ % 2 == 0 else (l.sort.sort[-1] + l.sort.sort[-2]) / 2.0\nend", "  return l.sort[l.size\
    \ / 2]\nend", "  l.sort!\n  return l[(l.length+1)/2-1] if l.length%2==0 \n  mid=l/2-1\n\
    \  \n  return l[mid] if l[mid]<l[mid+1] \n  \nend", "  l.sort!\n  if l.length\
    \ < 2\n    l[0]\n  else\n    (l.length / 2).floor\n  end\nend", "  l.sort!\n \
    \ return l[(l.length+1)/2]\nend", "  l.sort\n  return l[l.length / 2] if l.length\
    \ % 2 == 0 else (l[l.length / 2 - 1] + l[l.length / 2]) / 2\nend", "  l.sort\n\
    \  (l.length / 2).floor\nend", "  l.sort\n  l = l.take_while {|x| x < l.size /\
    \ 2}\n  l.length < 2 ? l.last : l.first\nend", "  return l.sort && l.length ?\
    \ (l[l.length / 2] || 0) : (\n    l.call(0, l.length) || 0\n  )\nend", "  l =\
    \ sort(l)\n  r = l[l.length / 2]\n  l.shift if l.length > 2 and l.length % 2 !=\
    \ 0\n  l.shift if l.length > 1 and l.length % 2 != 0\n  return r\nend", "  l.sort!\n\
    \  return l[(l.length-1)/2]\nend\n</cell>\n<text>\nNow let's use median.call again:",
  "  return l[((l.length-1)/2)] if l.length%2 == 0 else (l[((l.length-1)/2)] + l[l.length/2])\
    \ / 2.0\nend", "  l.sort!\n  return l[(l.length-1)/2]\nend", "  l.sort!\n  len\
    \ = (l.size - 1)/2\n  return len.zero? l[len] : l[len] + l[len-1]\nend", "   \
    \ l.sort!\n    (l.length * 0.5).to_i\nend", "  l.sort.each do |x|\n    return\
    \ x if x.size % 2 == 0\n    i = x.size / 2\n    if x[i] > x[i +1]\n      return\
    \ x[i]\n    else\n      return x[i +1]\n    end\n  end\n  l.sort.last\nend", '  l.sort!',
  "  l.sort.call\n  (l.size / 2).ceil.call\nend", "  l.sort.to_a\n  l.length.to_a\n\
    \  half = l.length.to_a / 2\n  l[half]\nend\n</code>\n<|/ a tags=arrays,ruby,median\
    \ |>\n<| a dscore=1 tags=arrays,ruby,median |>\nHere's a more concise Ruby way\
    \ of finding median of array. \nThe key is the nth item of array can always be\
    \ found at n/2 where n is number of items in the array. Here, I use (n+1)/2 but\
    \ (n)/2 would also work fine.\n<code>", "  if l.length <= 1\n    return l[0]\n\
    \  sorted_l = l.sort\n  midpoint = l.length / 2.0\n  return sorted_l[midpoint]\
    \ if l.length % 2 == 0 else (sorted_l[midpoint - 1] + sorted_l[midpoint]) / 2\n\
    end", "  return l.sort[l.length/2-1]\nend", "\tl = l.sort # Sort the array.\n\t\
    l = l[l.length/2]\n\tif l.length == 0 then return nil end\n\treturn l\nend", " \
    \ # If there are fewer than two elements in the array,\n  # return average of\
    \ those elements.\n  return l.inject(:+) / l.size if l.size >= 2\n  # If there\
    \ are two elements in the array,\n  # return median of those elements.\n  mid\
    \ = l.size / 2\n  a[mid] if l < a[0...mid] || l > a[mid+1..-1]\nend", "  if l.length\
    \ < 2 then\n    return 0\n  end\n  l.length.times do |i|\n    mid = l.length /\
    \ 2\n    if mid % 2 == 0 then\n      return l[mid]\n    end\n    return l[mid\
    \ - 1] if i > mid\n  end\n  l.length / 2\nend", "  return reduce(lambda x, y:\
    \ x if x<y else y, l)/2.0\nend", "  l.sort!\n  l = l.sort!\n  l.length < 2 ? nil\
    \ : l[l.length / 2]\nend", "  ls = l.sort()\n  if ls.length == 1\n    ls[0]\n\
    \  else\n    (ls[ls.length / 2 - 1] + ls[ls.length / 2]) / 2.0\n  end\nend", " \
    \ return l.sort ? l[(l.length/2).floor] : l[l.length/2]\nend", '  l.sort!', " \
    \ l.sort.sort.reduce(l[(l.size+1)/2..-1])/2\nend", "  m = l.size / 2\n  l[(l <\
    \ m) ? 1 : 2].floor\nend", "  return nil if l.length < 2\n  l = l.sort\n  l.length\n\
    \  len = l.length\n  if len % 2 == 0\n    len = len - 1\n  end\n  mid = len /\
    \ 2\n  if len % 2 == 0\n    return l[mid].to_f / 2.0 + l[mid + 1].to_f / 2.0\n\
    \  else\n    return l[mid].to_f / 2.0 + l[mid - 1].to_f / 2.0\n  end\nend", " \
    \ sorted = l.sort {|a, b| a<=>b}\n  sorted.length\n  sorted.length/2 + sorted.length%2\n\
    end", "  l.sort\n  l.length < 2\n  l.length == 2\n  l.length == 1\n  l = l[1..-1]\n\
    \  (l.length / 2).ceil\n  if l.length % 2 == 1\n    l.length / 2\n  else\n   \
    \ (l.length / 2).floor\n  end\nend", "  if l.size <= 1\n    l.first\n  else\n\
    \    q = l.size / 2\n    l.each {|v|\n      q.downto(0).each {|i|\n        if\
    \ v < l[i]\n          q.upto(i).each {|j|\n            v = v if j == i\n     \
    \     }\n          break\n        end\n      }\n    }\n    v = l.first\n    l.each\
    \ {|v|\n      if v < q\n        v = v\n      end\n    }\n    v\n  end\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nIt's really difficult to read and understand what\
    \ a ruby solution like this would actually look like when written as an extension\
    \ method rather than as a standalone function.  Do you feel it's easier to understand\
    \ an extension method than a standalone function?\n<|/ c |>\n<| c |>\nIt's not\
    \ really difficult to understand, and as long as you only use it for things like\
    \ sorting then it is definitely not an issue. Other than that it should be fairly\
    \ readable. In some ways it's more \"rubyish\" than C but it is less verbose.\n\
    <|/ c |>\n<| c |>\nThis is extremely inefficient because you're doing linear search,\
    \ `downto` and `upto` are O(N) operations. Just do `mid = (l.size+1)/2` and then\
    \ `if l[mid] <= value then l[mid] else value end`\n<|/ c |>\n<| c |>\nActually,\
    \ that's just what `Array#sort_by` does anyway, so it's not any more efficient.\
    \ I'd say it's even less efficient. :-)\n<|/ c |>\n<| a dscore=5 tags=ruby |>\n\
    The most common way I've seen this done in Ruby is with an inject:\n<code>", " \
    \ l = l.to_a\n  return (l[1]+l[-1])/2\nend", "    l.sort \n    mid = l[l.length/2].length\
    \ \n    l[mid], l[mid-1] = l[mid-1], l[mid] \n    mid-1 \nend", "  l.sort!\n \
    \ (l.length + 1.downto0).floor / 2.0\nend", "  l.sort.call(0) # Sort array in\
    \ ascending order\n  l.size % 2 == 0 ? l.last.floor : l.first.ceil # Round up\n\
    end\n</cell>\n<cell>\nmedian([3, 1, 2, 4, 5])\n</cell>\n<cell>\nmedian([-10, 4,\
    \ 6, 1000, 10, 20])\n</cell>\n<text>\nExercise: What happens if you call median\
    \ on an empty array?", "  l.sort!\n  return l[((l.length + 1) >> 1).floor]\nend\n\
    </cell>\n<text>\nScratchpad - median and mode", "  l.sort!\n  l.length and l %\
    \ 1 == 0 and return l[(l.length + 1 ) / 2]\n  l.length and l % 1 == 1 and return\
    \ l[l.length / 2 - 1]\nend", "  l.sort!\n  l[-1]\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
