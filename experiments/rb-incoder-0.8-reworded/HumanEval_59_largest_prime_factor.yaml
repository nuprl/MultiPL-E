name: HumanEval_59_largest_prime_factor
language: rb
prompt: "# Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
  # >>> largest_prime_factor.call(13195)\n# 29\n# >>> largest_prime_factor.call(2048)\n\
  # 2\ndef largest_prime_factor(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_largest_prime_factor\n\
  \    candidate = method(:largest_prime_factor)\n    assert_equal(5, candidate.call(15))\n\
  \    assert_equal(3, candidate.call(27))\n    assert_equal(7, candidate.call(63))\n\
  \    assert_equal(11, candidate.call(330))\n    assert_equal(29, candidate.call(13195))\n\
  \  end\nend\n"
completions: ["  return n if n <= 2 else factor(n)[-1]\nend", "  n.downto(2) do |m|\n\
    \    return m if m > n and n.odd? and prime?(m)\n  end\n  n\nend", "  if n ==\
    \ 0\n    []\n  elsif n == 2 || n == 3 || n % 2 == 0\n    [1]\n  else\n    largest_prime_factor(n\
    \ / 2).map { |f| n % f }.inject(:+)\n  end\nend\n</code>\nAs you can see, this\
    \ solution is much more concise than the one you proposed. In your solution you\
    \ had to call largest_prime_factor.call each time, and the map each time.\n<|/\
    \ a tags=recursion,ruby,algorithm |>\n<| c |>\nNice solution! I'll be sure to\
    \ test it out. Thank you.\n<|/ c |>\n<| c |>\nThis is an excellent solution. I\
    \ just want to add that you should not use recursion here, but iterate over the\
    \ primes instead.\n<|/ c |>\n<| c |>\n: I added a suggestion about that.\n<|/\
    \ c |>\n<| a |>\nYou can use memoization to speed this up. Add an instance variable\
    \ (@primes) to your class that stores the primes in increasing order. Then, just\
    \ check if a number is in a memoized hash before calculating it. If it is, then\
    \ just return that result. Otherwise, calculate it and put it into the memoized\
    \ hash. Something like:\n<code>", "  i = 2\n  prime_factors = []\n  while i <=\
    \ n / i\n    if n % i == 0\n      prime_factors << i\n      n /= i\n    i += 1\n\
    \    prime_factors.each_index do |idx|\n      if prime_factors[idx] > i\n    \
    \    largest_prime_factor = prime_factors[idx] # Save the largest prime factor.\n\
    \        break\n      end\n    end\n  end\n  return largest_prime_factor\nend\n\
    </code>\n<|/ a |>\n<| c |>\nWow. Thanks for the code. I'll run it through my Ruby\
    \ interpreter when I'm at my computer, but I'm wondering, how would I go about\
    \ finding the largest prime factor of a big number? Would you recommend storing\
    \ each digit as it's iterated in the loop? Would you recommend storing the numbers\
    \ as they are iterated in the loop or storing the larger prime factor at the end?\n\
    <|/ c |>\n<| c |>\nThe code in the answer below is correct, but doesn't return\
    \ the largest prime factor. You'll need to modify it to use the result of `largest_prime_factor`\
    \ instead.\n<|/ c |>\n<| c |>\nThanks for pointing that out. I've updated the\
    \ answer.\n<|/ c |>\n<| a |>\nYou can do this iteratively:\n<code>", "  if n ==\
    \ 0\n    1\n  else\n    largest_prime_factor(n % 10) + 1 if n % 10 > 3 && n %\
    \ 10 <= 19\n  end\nend", "  # Create a list from 1 to n\n  factors = Array.new(n\
    \ - 1)\n  # Initialize factors to all primes <= 2\n  factors << 2\n  factors.each_index\
    \ do |index|\n    # Find the next prime factor\n    divisor = (index * index)\
    \ + 1\n    # Skip over any divisors <= 2\n    next if divisor <= 2\n    # Add\
    \ it to the list\n    factors << divisor\n    # Look for the next non-prime factor\
    \ after this one\n    next if index == (n - 1) / 2\n    # Break out of the loop\n\
    \    break\n  end\n  factors[factors.length - 1]\nend", "  return n if n % 2 ==\
    \ 0 && (n >= 3 || !n % 1000) ? 3 : n\nend\n</cell>\n<code language=julia-1.5>\n\
    largest_prime_factor(13195)\n</cell>\n<code language=julia-1.5>\nlargest_prime_factor(2048)\n\
    </cell>\n<code language=julia-1.5>\nlargest_prime_factor(10)\n</cell>\n<code language=julia-1.5>\n\
    largest_prime_factor(100)\n</cell>\n<code language=julia-1.5>\nlargest_prime_factor(1000)\n\
    </cell>\n<code language=julia-1.5>\nlargest_prime_factor(1000000)\n</cell>\n<code\
    \ language=julia-1.5>\nlargest_prime_factor(10001)\n</cell>\n<text>\nChallenge:\
    \ Calculate Fibonacci numbers", "  return n if n.is_a?(Integer) && n.odd? && n\
    \ > 1 && n != 2 else largest_prime_factor(n % 5) + 5\nend", "  n = n.to_i\n  i\
    \ = 2\n  factors = []\n  while i * i <= n\n    if n % i == 0\n      i += 1\n \
    \     factors << i\n    end\n  end\n  factors.sort do |a, b|\n    a > b\n  end[0]\n\
    end", "    # check if n is odd\n    if n.odd?\n        # find the smallest divisor\
    \ of n\n        divisor = 2\n        while n % divisor == 0\n            divisor++\n\
    \        return n\n    # now n is prime\n    return n.prime_divisors.size\nend",
  "    return n.inject(:<<, 1).tap do |prime_factor|\n      prime_factor = prime_factor\
    \ + 1 if prime_factor < n\n      prime_factor\n    end\nend", "  max = n.to_i\n\
    \  i = 1\n  while i < max\n    if (n % i == 0)\n      max = n\n      break\n \
    \   i += 1\n  end\n  if n == max\n    max\n  else\n    largest_prime_factor(max)\n\
    \  end\nend", "  return n if n <= 1 \n  i = 1\n  m = 2\n  while i <= n and m <=\
    \ n and n % i == 0\n    m = i\n    i = i + 1\n  end\n  if i == n\n    puts \"\
    #{n} is prime\"\n    return n\n  else\n    puts \"#{n} is not a prime\"\n    return\
    \ nil\n  end\nend\nlargest_prime_factor(19)\nlargest_prime_factor(29)\nlargest_prime_factor(1024)\n\
    largest_prime_factor(13111)\nlargest_prime_factor(13113)\nlargest_prime_factor(1000000000)\n\
    largest_prime_factor(10000000000)\nlargest_prime_factor(100000000000)\nlargest_prime_factor(1000000000000)\n\
    largest_prime_factor(10000000000000)\nlargest_prime_factor(1000000000000000)\n\
    largest_prime_factor(1000000000000001)\nlargest_prime_factor(10000000000000002)\n\
    largest_prime_factor(10000000000000003)\nlargest_prime_factor(10000000000000000)\n\
    largest_prime_factor(10000000000000001)\nlargest_prime_factor(10000000000000006)\n\
    largest_prime_factor(10000000000000002)\nlargest_prime_factor(10000000000000004)\n\
    largest_prime_factor(10000000000000004)\nlargest_prime_factor(10000000000000004)\n\
    largest_prime_factor(10000000000000004)\nlargest_prime_factor(10000000000000004)\n\
    largest_prime_factor(10000000000000004)\nlargest_prime_factor(10000000000000004)\n\
    largest_prime_factor(10000000000000004)\nlargest_prime_factor(10000000000000004)\n\
    largest_prime_factor(10000000000000004)\nlargest_prime_factor(10000000000000004)\n\
    largest_prime_factor(10000000000000004)\nlargest_prime_factor(10000000000000004)\n\
    largest_prime_factor(10000000000000004)\nlargest_prime_factor(10000000000000004)\n\
    largest_prime_factor(10000000000000004)\nlargest_prime_factor(10000000000000004)\n\
    largest_prime_factor(10000000000000004)\nlargest_prime_factor(10000000000000004)\n\
    largest_prime_factor(10000000000000004)\nlargest_prime_factor(10000000000000004)\n\
    largest_prime_factor(10000000000000004)\nlargest_prime_factor(10000000000000004)\n\
    largest_prime_factor(10000000000000004)\nlargest_prime_factor(10000000000", " \
    \ n = n.to_i\n  return n if n < 2 else n % prime_number(n).to_i\nend", "    prime\
    \ = 1\n    i = 2\n    while i < n do\n        if n % i == 0 then\n           \
    \ prime += 1\n        end\n        i += 1\n    end\n    return prime\nend", " \
    \ for i in 1..n\n    if n % i == 0\n      return n\n    n /= i\n  return n\nend",
  "  result = 2\n  (2..n).each do |i|\n    prime = 1\n    (i / result).downto(1) do\
    \ |j|\n      prime *= (i - j + result) + 1\n    end\n    return result if prime\
    \ > result\n    result = prime\n  end\n  return n\nend", "  divisor = 1\n  while\
    \ n != 1\n    if n % divisor == 0\n      divisor = divisor * 2\n    else\n   \
    \   n /= divisor\n    end\n  end\n  divisor\nend\n</code>\n<|/ a tags=ruby |>\n\
    <| a dscore=1 |>\nHere is the most efficient way to get the largest prime factor\
    \ in ruby. \n<code>", "  return n.prime_division do |p|\n    return p.denominator.prime_division\
    \ do |p|\n      while p > 2\n        p -= 1\n      end\n      p\n    end\n  end\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThis takes about 2.5 times as long to complete\
    \ as `prime_division`.\n<|/ c |>\n<| c |>\n.: I guess, there needs to be some\
    \ optimization to reduce the number of divisions (maybe `lcm` instead of `prime_division`).\
    \ Also, `lcm` would give `765` instead of `780`, if that matters.\n<|/ c |>\n\
    <| c |>\n: Agreed. Using `lcm` would also help to reduce the number of `*` operations\
    \ (which would also help the algorithm).\n<|/ c |>\n<| a dscore=4 |>\nI wrote\
    \ this program last night (May 2016) which is just about as fast as your primes\
    \ method. It took about 30 seconds to run with 1,000,000 random numbers.\n<code>\n\
    require 'prime'", "  if n == 1\n    return 1\n  else\n    factors = []\n    i\
    \ = 2\n    until n%i == 0\n      i += 1\n      factors << i\n      n /= i\n  \
    \  factors << n # if n divides into more than one factor, then n > 1\n    return\
    \ factors.max\n  end\nend", "  return prime_count(n)[1]\nend", "  raise NotImplementedError\n\
    end", "  return n.prime_factors.max_by(&:prime).prime\nend", "  factors = prime_factors(n)\n\
    \  return factors.max\nend", "  factors = []\n  factor = 1\n  while n > 1\n  \
    \  if n % factor\n      n /= factor\n      factors << factor\n      factor = 1\n\
    \    else \n      factor += 1\n    end\n  end\n  factors << n if n != 1\n  factors.reverse\n\
    end\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| c |>\nYour answer does not seem\
    \ to answer the question.\n<|/ c |>\n<| c |>\nSorry, I thought the question was\
    \ obvious enough since it asked for the biggest prime factor.\n<|/ c |>\n<| a\
    \ dscore=0 tags=ruby |>\n<code>", "  n.is_a?(Fixnum) || n.is_a?(Bignum) || n.is_a?(Float)\
    \ || n.is_a?(String) || n.is_a?(Symbol) || n.is_a?(Regexp)\n  return n if n.is_a?(Fixnum)\
    \ || n.is_a?(Bignum)\n  n.to_i >= 2 && return n if (n / 2 == n) ", "  return n\
    \ if n.even? || n.odd? || n % 2 == 0 ||\n    n % 3 == 0 || n % 5 == 0 || n ==\
    \ 1", "  if n.is_a?(Integer)\n    n = n.to_i\n  end", "  nprime = prime_factors(n)\n\
    \  max = nprime[-1]\n  max.to_i\nend", "  # Only odd numbers\n  return 2 if n\
    \ & 1 else 2\n  # The prime factors of n are 2 and 3\n  return 3 if n % 2 else\
    \ n / largest_prime_factor(n / 2)\nend\n</code>\n<|/ a |>\n<| c |>\nA link to\
    \ an explanation of why the original code works is appreciated, since it gives\
    \ some intuition behind this answer. Thank you.\n<|/ c |>\n<| c |>\n: Thanks for\
    \ your feedback. I've updated the answer with an explanation.\n<|/ c |>\n<| c\
    \ |>\nThe original code works, but it's slower than the Sieve of Eratosthenes\
    \ algorithm.\n<|/ c |>\n<| c |>\nThe original code works, but it's slower than\
    \ the Sieve of Eratosthenes algorithm. Why do you say that? Is there some reason\
    \ for that? Thanks\n<|/ c |>\n<| c |>\nYour code does no error checking; that's\
    \ a great way to get yourself into trouble. For example, what happens if `n` is\
    \ negative?\n<|/ c |>\n<| a dscore=4 tags=algorithm,ruby |>\nHere's a non-iterative\
    \ Ruby implementation using recursion. Hope it helps.\n<code>", "  largest_prime_factor\
    \ = 1\n  i = 1\n  while i * i <= n\n    i += 1\n    while n % i == 0\n      n\
    \ /= i\n      largest_prime_factor = i\n    end\n  end\n  n\nend", "  n.to_s.split(//).map\
    \ do |f|\n    return 0 if f < 2\n    (2..f).each do |i|\n      return i if n %\
    \ i == 0\n    end\n  end\nend", "  factors = []\n  n = n.to_i\n  while n % 2 ==\
    \ 0\n    n /= 2\n  end\n  primes = 2\n  while primes <= n\n    primes *= 2\n \
    \   factors.push(primes)\n    while n % primes == 0\n      n /= primes\n    end\n\
    \  end\n  factors.last\nend", "  return n if n.is_a? Integer\n  factors, n = n.prime_factors,\
    \ 2\n  while n > 2\n    n, next_n = n, n + 1\n    factors.reverse_each do |f|\n\
    \      if n % f == 0\n        return f if f > next_n\n      end\n    end\n   \
    \ n += 1\n  end\nend", "  return largest_prime_factors.call(prime_count.call(n))[1]\n\
    end", "  return prime_fact(n).max\nend", "  return n if n < 2 else largest_prime_factor(n\
    \ / 2)\nend", "  max_prime = primes.max\n  p max_prime\n  i = 1\n  while i <=\
    \ n / max_prime\n    p = max_prime * i\n    i += 1\n  end\n  p i\nend\n</code>\n\
    <|/ a tags=ruby,primes |>\n<| a dscore=2 |>\nA simple Ruby solution to finding\
    \ the largest prime factor (i.e. the prime factorization) of a number n can be\
    \ implemented as follows:\n<code>", "  return if n.negative?\n  s = 2\n  while\
    \ s <= n / 2\n    s, remainder = divmod_prime(s.next, 2)\n    if remainder.zero?\n\
    \      return s\n    end\n  end\nend", "  factors = []\n  i = 1\n  while n !=\
    \ 1\n    factors << i\n    if n % i == 0\n      n /= i\n    else\n      i += 1\n\
    \    end\n  end\n  factors\nend", "  if n < 2\n    return n\n  if n % 2 == 0\n\
    \    return n\n  factor = 1\n  i = 3\n  while i < n do\n    if n % i == 0\n  \
    \    break\n    i = i + 1\n    factor = factor * i\n  end\n  return factor\nend",
  "  i = 2\n  factor = nil\n  while i <= n do\n    if n % i == 0 then\n      break\n\
    \    else\n      i += 1\n    end\n    factor = i\n  end\n  factor\nend", "  return\
    \ n > 2 ? largest_prime_factor(n % n) | 1 : n \nend", "  return prime_factors.call(n).max\n\
    end", "  primes, factors, r = nil, nil, nil\n  n = n.to_i\n  if n <= 1 \n    r\
    \ = (1..n).find { |i| n % i == 0 }\n    if r\n      r\n    else\n      n\n   \
    \ end\n  else\n    p =  2\n    i = 2\n    primes = [p]\n    factors = []\n   \
    \ loop do\n      break if primes.include?(i)\n      r = n / i\n      n -= r *\
    \ i\n      factors.push(i)\n      i = p + 1\n      p += 1\n      primes << i\n\
    \    end\n    i = primes.index(p)\n    r = n / i\n    n -= r * i\n    factors.push(i)\n\
    \    r\n  end\nend", "  m = n / 2\n  i = 1\n  while i * i <= n\n    i += 1\n \
    \   m = n / i\n  end\n  if m == 0\n    return 2\n  end\n  i = 1\n  while i * i\
    \ <= m\n    if n % i == 0\n      i += 1\n    else\n      break\n    end\n  end\n\
    \  return i\nend", "  n.to_i\n  factor = (n / 2)\n  while n.to_i >= 2\n    if\
    \ n % factor.to_i == 0\n      break\n    factor = (factor / 2)\n    n = (n % factor.to_i).to_i\n\
    \  end\n  factor\nend", "  if n <= 1 then\n    return nil\n  end\n  i, k = 1,\
    \ 2\n  while i * i <= n do\n    i += k\n    k = k * 2\n  end\n  return i\nend",
  "    n = n.to_i\n    return n if n % 2 == 0 else 3 * largest_prime_factor(n / 2)\n\
    end", "  return n if n < 2 else 3 * largest_prime_factor(n / 3) if n % 3 == 0\n\
    \  # n / 3 == 0 because no factors are divisible by 3\n  n % 3 == 0 ? n / 3 :\
    \ largest_prime_factor(n / 3)\nend", "  if n < 2\n    1\n  elsif n <= 3\n    3\n\
    \  else\n    largest_prime_factor(n % 5) + 1\n  end\nend", "  return n if n <\
    \ 2 else n % 2 == 0 ? 3 : n % 3 == 0 ? 6 : n % 5 == 0 ? 9 : 7\nend", "  return\
    \ n.primefactors.inject(:*).max\nend", "  largest_factor = 1\n  factor = 2\n \
    \ while factor <= n\n    largest_factor = factor\n    factor = factor * 2\n  \
    \  break\n  return largest_factor\nend", "  return n if n.odd? || n==1 || (n%2\
    \ == 0 && n != 2); n-1 if n%3==0 || (n%5==0 && n != 5); n+1 if n%7==0 || (n%11==0\
    \ && n != 11); return n if n==3 || n==5 || n==7 || n==9;\nend\n</code>\n<|/ a\
    \ tags=ruby |>\n<| c |>\nI made a minor edit to this function to avoid getting\
    \ caught out by large numbers. Please review to see if it's ok.\n<|/ c |>\n<|\
    \ c |>\nThanks Ethan :-) I think I was working on it for a while and I didn't\
    \ have time to tidy it up. I'll get it back in a minute and fix it.\n<|/ c |>\n\
    <| c |>\nThis code returns false if n has a prime factor, and also returns nil\
    \ if n is 1\n<|/ c |>\n<| c |>\nThis code assumes that any prime factor of n will\
    \ be the greatest factor of n. Of course, that isn't always the case. For example,\
    \ `largest_prime_factor(5)` returns `5`, but `largest_prime_factor(15)` returns\
    \ `2`.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  if n.zero? || n.odd?\n    1\n\
    \  else\n    n = n.next\n    while n.odd? && n.next.odd?\n      n = n.next\n \
    \   end\n    n\n  end\nend", "  if n.odd? || n == 1\n    1\n  else\n    largest_prime_factor(n.div(2))\
    \ + n.odd? ? 2 : 3\n  end\nend", "  n = n.to_i\n  if n == 1\n    1\n  else\n \
    \   if n % 2 == 0\n      n ** 0.5\n    else\n      i = 3\n      factor = 2\n \
    \     while i * i <= n\n        if n % i == 0\n          n /= i\n          factor\
    \ += 1\n        else\n          i += 1\n      n\n    end\n  end\nend\n</code>\n\
    <|/ a tags=ruby,primes,prime-factoring |>\n<| c |>\nAwesome! Thank you!\n<|/ c\
    \ |>\n<| a dscore=0 |>\n<code>", "  factor = 1\n  while n > 1\n    factor = (n%factor).floor\n\
    \    n = (n/factor).floor\n  end\n  return factor\nend", "  i = 2\n  while i <\
    \ n do\n    if n % i == 0 then\n      break\n    i += 1\n  end\n  return n / i\n\
    end\n</code>\n<|/ a dscore=2 tags=ruby,primes |>\n<| c |>\nThanks for this! A\
    \ couple of comments. 1) I don't have access to Ruby on Rails, 2) I was looking\
    \ for one line of code. 3) I realize that this is a very inefficient method to\
    \ find all the prime factors of an integer, but as I said, I was looking for an\
    \ efficient solution.\n<|/ c |>\n<| c |>\nRuby is on Rails now. Try this: `require\
    \ 'rubygems'; gem 'rails'; require 'rails/commands/server'; Rails::Server.new.tap\
    \ do |server| ... end`.\n<|/ c |>\n<| c |>\nOkay, I added a solution that uses\
    \ no Rails.\n<|/ c |>\n<| a |>\nThis code does not require Rails.\n<code>", " \
    \ n = n.to_i\n  i = 2\n  while i * i <= n\n    i += 1\n  i += 2\n  while n % (i\
    \ * i) == 0\n    i += 1\n  end\n  i\nend", "    i = 2\n    factors = []\n    while\
    \ i <= n / i\n        if n % i == 0\n            factors.push(i)\n           \
    \ i = i + 1\n        else\n            i = i + 1\n    end\n    factors.reverse\n\
    \    factors.last\nend\n</cell>\n<text>\nExercise 3\nWrite a function, prime_factors,\
    \ that takes in a list of numbers and returns the unique prime factors for each\
    \ number in the list. Your function should handle negative numbers correctly.\
    \ For example, prime_factors([-1, -2, 3]) should return the list [-1, 3].", " \
    \ primes = prime_candidates.to_a\n  while n % primes.last != 0\n    primes = prime_candidates.to_a\n\
    \  end\n  return primes.select {|e| n % e == 0}[0]\nend", "  result = 1\n  factor\
    \ = 2\n  while n > factor\n    n /= factor\n    result += factor\n    factor++\n\
    \  end\n  result\nend\n</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n\
    <footer class=\"footer\">\n  <p>The footline is Copyright &copy;2003&ndash;2017\
    \ <a href=\"http://www.alchemikor.com\" target=\"_blank\">Alchemikor</a>, licensed\
    \ under the\n<a rel=\"license\" href=\"http://creativecommons.org/licenses/by/4.0/\"\
    >Creative Commons Attribution 4.0 International License</a>.</p>\n  <p>The source\
    \ code for this UI is licensed under the terms of the MIT license. Alchemikor\
    \ makes no warranty whatsoever\n  about its products or services. You can\n  obtain\
    \ users directly from Alchemikor at <a href=\"mailto:removed@example.com\">removed@example.com</a>.</p>\
    \ \n</footer>\n<script type=\"text/x-mathjax-config\">\n  MathJax.Hub.Config({\n\
    \    messageStyle: \"none\",\n    showProcessingMessages: false,\n    tex2jax:\
    \ {\n      inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ],\n      displayMath:\
    \ [ ['$$','$$'], [\"\\\\[\",\"\\\\]\"] ],\n      processEscapes: true,\n    },\n\
    \    TeX: {\n      Macros: {\n        balpha: '\\\\boldsymbol{\\\\alpha}',\n \
    \       bc: '\\\\mathbf{c}',\n        be: '\\\\mathbf{e}',\n        bg: '\\\\\
    mathbf{g}',\n        bq: '\\\\mathbf{q}',\n        bu: '\\\\mathbf{u}',\n    \
    \    bv: '\\\\mathbf{v}',\n        bw: '\\\\mathbf{w}',\n        bx: '\\\\mathbf{x}',\n\
    \        by: '\\\\mathbf{y}',\n        bz: '\\\\mathbf{z}',\n        bsigma: '\\\
    \\mathbf{\\\\sigma}',\n        sign: '\\\\operatorname{sign}',\n        diag:\
    \ '\\\\operatorname{diag}',\n        real: '\\\\mathbb{R}',\n      },\n      equationNumbers:\
    \ { autoNumber: \"AMS\" },\n      TagSide: \"right\",\n      TagIndent: \".8em\"\
    ,\n      MolPad: 30\n    },\n    SVG: {\n      scale: 0.5,\n      MglyphRef: 'url(#glyphRef)',\n\
    \      MglyphglyphRef: 'url(#glyphRef)'\n    }\n  });\n  MathJax.Hub.Register.StartupHook(\"\
    TeX Jax Ready\",function () {\n    MathJax.InputJax.MathMenu.Menu.Config({\n",
  "  i = 2\n  while i < n\n    i += 1\n    if n % i == 0\n      break\n    if i ==\
    \ n\n      i += 1\n    end\n  end\n  return i\nend", "    return n if n < 2 else\
    \ largest_prime_factor(n-1) * 3 + 1\nend", "  max_factor = 1\n  i = 1\n  while\
    \ i < n do\n    while n % i == 0 do\n      max_factor = fdiv(i, max_factor)\n\
    \      n /= i\n    end\n    i += 1\n  end\n  return max_factor\nend", "  factor\
    \ = 2\n  while n < 2\n    factor++\n    n /= factor\n  end\n  factor\nend", " \
    \ if n < 2\n    return 2\n  factor = 2\n  i = 3\n  while i * factor <= n\n   \
    \ while n % i == 0\n      factor++\n      n = n / i\n    i++\n  end\n  return\
    \ factor\nend", "  return n if n % 2 == 0 or n % 3 == 0 or (n % 5 == 0 and n %\
    \ 7 == 0) else 5\nend", "  factor = 1\n  i = 1\n  while i**2 < n\n    i += 1\n\
    \    factor *= i\n  end\n  while n > 1\n    n /= factor\n    factor += 1\n  end\n\
    \  factor\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\n`factor` should be an instance\
    \ variable so that it persists across invocations.\n<|/ c |>\n<| c |>\n`factor`\
    \ should be an instance variable?? Really? I thought it would have to be a class\
    \ variable?\n<|/ c |>\n<| c |>\nI believe it should be. The only reason `factor`\
    \ needs to be a class variable is if you need to access it from multiple methods.\
    \ If you're only going to access it from one method, `factor` should just be a\
    \ local variable. As it stands, if you've ever invoked `largest_prime_factor(10)`\
    \ twice in the same method, `factor` will contain the wrong value.\n<|/ c |>\n\
    <| c |>\nThe \"largest prime factor\" code here is not correct. See [this answer](https://stackoverflow.com/a/42560828/111257)\
    \ for a working implementation, which I believe is much more efficient and correct.\n\
    <|/ c |>\n<| c |>\nThe answer I link to does **not** use that code. There's no\
    \ reason why you cannot use a class variable to store the largest prime factor.\
    \ It's the same code that's already in the answer I linked to. The reason I suggested\
    \ using a class variable is because of the use case in which the OP was trying\
    \ to use it. If you're only using this code from one method, you don't need to\
    \ store `factor` as a class variable. My code is just a slightly improved version\
    \ of the code in the answer I linked to.\n<|/ c |>\n<| a dscore=4 |>\nMy algorithm\
    \ for finding the largest prime factor of N is based on this one:\n<code>", " \
    \ i = 2\n  while i < n\n    if n % i == 0\n      return i\n    i += 1\n  end\n\
    \  return n\nend", "  primes = prime_factors(n)\n  return primes[-1] if primes.size\
    \ > 0 \n  return n if n.is_a?(Fixnum)\n  raise ArgumentError, \"must be greater\
    \ than or equal to 1\"\nend", "  divisors(n, :factor)\nend", "  return nil if\
    \ n.zero?\n  if n.odd?\n    next_divisor = n.next.div(2)\n    largest_prime_factor(next_divisor)\
    \ if (next_divisor * next_divisor) <= n\n  else\n    (2..n).find do |x|\n    \
    \  (n / x).floor == n\n    end\n  end\nend", "  factors = factor(n)\n  return\
    \ factors[0] if factors.size > 1 &&\n    n/factors.size >= 1 # factor can return\
    \ nil\nend\n</code>\n<|/ a |>\n<| c |>\nOh no. Okay let me get this straight.\
    \ factor() returns a list of factors. So the return value will be an array and\
    \ I can just pick out the first one?\n<|/ c |>\n<| c |>\nYes. `factors` is a list.\
    \ `factors.first` returns the first element. `factors.first(2)` returns two elements\
    \ starting with element 1, and so on. `factors.first(2)` is the same as `factors[1..2]`.\
    \ Read [Array](http://ruby-doc.org/core-2.1.5/Array.html) and [Array#first](http://ruby-doc.org/core-2.1.5/Array.html#method-i-first).\n\
    <|/ c |>\n<| c |>\nOkay I see. I think I understand it now. Thanks so much for\
    \ your help! :)\n<|/ c |>\n<| a tags=ruby,primes |>\nI decided to give a more\
    \ general solution:\n<code>", "  return n if n.is_prime? and n.factor? else find_largest_prime_factor(n)\n\
    end", "  n = n.to_i # ensure it is a number\n  if n < 2\n    1\n  else\n    sieve\
    \ = [2]\n    for p in sieve\n      while n % p == 0\n        p += 2\n      sieve.push(p)\n\
    \    end\n    sieve.select! {|x| x > n} # remove non-primes\n    sieve.shift\n\
    \  end\nend", "  # Write your solution here.\nend\n</cell>\n<cell>", "  prime_factors\
    \ = []\n  i = 2\n  loop do\n    prime_factors << i\n    while (n % i) == 0\n \
    \     n /= i\n      i += 1\n  end\n  if n == 2\n    prime_factors << 1\n  end\n\
    \  prime_factors.max\nend\n</code>\n<|/ a dscore=5 tags=ruby,primes,algorithm\
    \ |>\n<| c |>\nIt is not necessary to test all the numbers up to n to find the\
    \ largest prime factor.  You can stop testing after you checked factors up to\
    \ sqrt(n).\n<|/ c |>\n<| c |>\n, that won't work for large n. I've tried it for\
    \ n = 10000000000000000 and it doesn't work.\n<|/ c |>\n<| c |>\nIt works, of\
    \ course. `factorization(n)` does exactly the same thing as `largest_prime_factor`.\
    \ `factorization(n)` is more efficient, because it only needs to test up to sqrt(n).\
    \ For large numbers, `largest_prime_factor` is actually faster.\n<|/ c |>\n<|\
    \ c |>\nIn case anyone wants to use this in Rails you can just add this to your\
    \ model", "  return n if n.is_a?(Fixnum) || n.is_a?(Bignum) ? (n.to_i >= 2 ? n\
    \ : n.to_s.chars.sort.reduce(:*).to_i).to_f : \n    (n.to_i >= 2 ? n : n.to_s.chars.sort.reduce(:*).to_i).div(n)\n\
    end\n</code>\n<|/ a tags=ruby,performance,bignum |>\n<| c |>\nYour code is wrong.\
    \ The largest prime factor for 10^5 is 5, not 7. So the test should be `if n.to_i\
    \ <= 2`.\n<|/ c |>\n<| c |>\nThe largest prime factor for 10^5 is 10^5 as well.\
    \ I am not looking for largest prime factor.\n<|/ c |>\n<| c |>\nBut your comment\
    \ says \"largest prime factor\". That's the largest prime factor.\n<|/ c |>\n\
    <| c |>\nI have updated the code and comments. Please have a look.\n<|/ c |>\n\
    <| c |>\nYour code is still wrong. [This answer](http://stackoverflow.com/a/33090778/477037)\
    \ shows an easy way to find a prime factor in constant time.\n<|/ c |>\n<| a tags=ruby,performance,bignum\
    \ |>\nIf you're happy with BigInt, you could use that:\n<code>\nn = 42\nn.times.to_a.map(&:to_i).reduce(:*)",
  "  a = 1\n  i = 2\n  while i <= n\n    i = 2\n    while i * i <= n\n      i += 1\n\
    \    if n / i == i\n      a = i\n      while n / a != i\n        n /= a\n    \
    \  break\n    i += 1\n  end\n  a\nend", "  n = (n > 1) ? (n) : 2\n  i = 2\n  while\
    \ i < n\n    prime = true\n    (n / i).times do |j|\n      prime = false if n\
    \ % i == 0\n      break if prime\n    end\n    i = i + 1\n  end\n  n\nend\n</code>\n\
    The above will work for large numbers (at least 2 to the power of 32), but will\
    \ take a very long time to run for a number of the power of 2. That will be fine\
    \ for your purposes (not for larger numbers!), but just in case you ever need\
    \ it, here's the code I wrote for the case of a number of the power of 2. You'll\
    \ need to modify it for numbers less than the power of 2. This code will return\
    \ 0 if the number is a power of 2.\n<code>", "  prime_factors = []\n  i = 1\n\
    \  while i * i <= n\n    i += 1\n  while i <= n / 2\n    prime_factor = i\n  \
    \  while n % prime_factor == 0\n      n /= prime_factor\n      prime_factors <<\
    \ prime_factor\n    i += 1\n  return prime_factors.reverse\nend", "  largest_prime\
    \ = 1\n  factor = 2\n  while factor * factor <= n\n    if n % factor\n      factor\
    \ += 1\n    else\n      largest_prime *= factor\n      n /= factor\n    end\n\
    \  end\n  largest_prime *= factor\n  n\nend", "  n = fix_number(n)\n  i = 1\n\
    \  while i <= n do\n    while n % i == 0 do\n      n /= i\n      i += 1\n    end\n\
    \    i += 1\n  end\n  return n\nend", "  return 2 if n.even?\n  i = 2\n  while\
    \ i * i <= n and n % i == 0\n    i += 1\n  i\nend", "    n = convert_num(n)\n\
    \    i = 2\n    while (i < n) and (n%i == 0)\n        i = i+1\n    return i",
  "    prime = 2 # Prime number candidate\n    i = 2\n    while i * prime <= n\n \
    \       i += 1\n        if n % i == 0\n            prime = i\n    \n    if prime\
    \ == 2\n        return n\n    else\n        largest_prime_factor = i\n       \
    \ return n\nend", "  # Write your code here.\n  prime_count = n.prime_count(n)\n\
    \  if prime_count == 0\n    return n\n  prime_factors = []\n  i = 2\n  while i\
    \ <= prime_count\n    if n % i == 0\n      prime_factors << i\n      n /= i\n\
    \      break\n    else\n      i += 1\n  end\n  if n == 1\n    prime_factors <<\
    \ n\n  end\n  return prime_factors.max\nend", "  return find_largest_prime_factor(n)\n\
    end\n</pre>", "  # Write your code here.\n  i = 2\n  while i <= n / 2\n  \tif\
    \ n % i == 0\n  \t\tbreak\n  \ti += 1\n  return i\n</cell>\n<cell>", "  sieve,\
    \ factors = sievely_decomposition(n)\n  factors.each do |factor|\n    return factor\
    \ if prime?(factor) \n    n /= factor\n  end\n  n\nend", "  return prime_numbers.call(n).inject(:*)\n\
    end", "    # Make a list of primes smaller than n\n    primes = []\n    while\
    \ n > 1\n        primes.push n\n        n /= 2\n    end\n    # Sieve of Eratosthenes\
    \ - only need odd numbers, no primes <= n\n    primes = primes.reject { |x| x\
    \ <= n }\n    # Sort the primes in descending order, with the first odd prime\n\
    \    # being the smallest prime\n    primes.sort!.with_index { |a, b| b if b %\
    \ 2 != 0 }\n    primes.first\nend\n</cell>\n<code language=julia-1.5>", "  i =\
    \ 1\n  factor = 2\n  while i*factor <= n\n    i += 1\n    factor *= i\n  while\
    \ n > 1\n    i -= 1\n    factor *= n%i\n    n/=i\n  factor\nend", "  p := 1\n\
    \  while n > 0\n    # Add p to the list of factors of n.\n    # >>> largest_prime_factor.call(13195,\
    \ p)\n    # 29\n    p = p * n\n    # Divide n by p.\n    # >>> largest_prime_factor.call(2048,\
    \ p)\n    # 2\n    n /= p\n  end\n  # Return the largest prime factor of n.\n\
    \  # >>> largest_prime_factor.call(13195, p)\n  # 29\n  # >>> largest_prime_factor.call(2048,\
    \ p)\n  # 2\n  p <= 1 ? n : 1\nend", "  a = 2\n  while a <= n do\n    while n\
    \ % a != 0 do\n      n /= a\n    end\n    a += 1\n  end\n  n\nend", "  return\
    \ 2 if n < 2 else if n <= 3 then 1 end\n    ", "  if n < 2\n    1\n  else\n  \
    \  largest_prime_factor(n./ 2).call(n % 2)\n  end\nend\n</cell>\n<code language=julia-1.6>\n\
    largest_prime_factor(13195)\nlargest_prime_factor(2048)\n</cell>\n<text>\nExercise\n\
    Write a function which returns the number of prime factors of a given number n\
    \ (i.e. divide n evenly)", "  return n if n == 2 else largest_prime_factor(n./\
    \ 2)\nend", "  i = 2\n  while i * i <= n\n    i += 1\n  while n % i == 0\n   \
    \ n /= i\n    i += 1\n  return n\nend", "  if n < 2\n  then 1\n  else largest_prime_factor(n\
    \ / 2) == 2 ? n : n * (largest_prime_factor(n / 2))\nend", "  factors = 1\n  i\
    \ = 1\n  while i < n && n%i == 0\n    i += 1\n    factors += 1\n  end\n  i\nend\n\
    </pre>\n<p>Now we can see that our code does a lot more than just that. On line\
    \ 6, it checks to see if the number is prime. On line 11, it checks to see if\
    \ the number is divisible by each of the previous factors. If it is, it doesn't\
    \ need to check this factor again because it is prime. On line 15, it checks to\
    \ see if the number is divisible by all of the previous factors except itself.\
    \ If it is, it doesn't need to check this factor again because it is prime. On\
    \ line 19, it checks to see if the number is divisible by all of the previous\
    \ factors except itself. If it is, it doesn't need to check this factor again\
    \ because it is prime. And so on.</p>\n<p>\nLooking at these two functions, we\
    \ can see that they do much more than just checking to see if they are prime numbers.\
    \ We can even see what that means.\n</p>", "  factors = []\n  factor = 1\n  while\
    \ n != 1\n    factor = (n % factor).call(0)\n    factors.push(factor)\n    n =\
    \ (n / factor).call(0)\n  end\n  factors.push(1) if n != 1\n  factors.inject(:+)\n\
    end", "    factors = 1\n    i = 2\n    while i <= n\n        if n % i == 0\n \
    \           factors = factors + 1\n            n = n/i\n        else\n       \
    \     i += 1\n    end\n    return factors\nend\n</code>\n<|/ a dscore=2 |>\n<|\
    \ c |>\nWhile this link may answer the question, it is better to include the essential\
    \ parts of the answer here and provide the link for reference.  Link-only answers\
    \ can become invalid if the linked page changes.\n<|/ c |>\n<| c |>\nOk, I added\
    \ the code from the answer here.\n<|/ c |>\n<| c |>\nThanks for posting the code.\
    \  I agree with your assessment, but your answer is quite long and has several\
    \ redundant lines.  I believe a code block is preferred.\n<|/ c |>\n<| c |>\n\
    Sorry, I don't get what are you trying to say with redundant lines. Please post\
    \ the code here, so I can see what I'm talking about!\n<|/ c |>\n<| c |>\nI think\
    \ OP was referring to the extra lines in his original answer, i.e. `i` and `n\
    \ = n/i`.\n<|/ c |>\n<| a tags=ruby dscore=2 |>\nHere is a function that returns\
    \ the largest prime factor of a number in Ruby. It can be easily modified to return\
    \ any prime factor:\n<code>", "    return n.prime_factor if n.is_prime then n.prime_factor\
    \ else n.prime_factors.reduce(&:+).max\nend", "  primes = primes_up_to_n(n)\n\
    \  prime = primes[-1]\n  if prime > n\n    prime\n  else\n    primes.each do |prime|\n\
    \      if n % prime == 0\n        break prime\n      end\n    end\n  end\nend",
  "  return n if n <= 1 or n % 1 == 0 else largest_prime_factor(n % ::gcd(n)) \nend",
  "  return n.reduce(:lcm) ? n : largest_prime_factor(n.abs) end\nend", "  factors\
    \ = [2,n]\n  factor = 0\n  while n > 1\n    if n % 2 == 0\n      n /= 2\n    \
    \  factor += 1\n    else\n      n -= 1\n      factors.unshift(n) # unshift means\
    \ insert at front\n    end\n  end\n  factor\nend", "  n.to_s.split(//).reduce([n],\
    \ :lcm).reduce(:*)\nend", "  return n.primefactor(n.bit_length) if n.bit_length\
    \ > 0 and\n    n.prime? else 1\nend", "    n.to_s.chars.map do |c|\n      if primes?(c)\n\
    \        n / prime_digit(c) #=> integer division\n      end\n    end.max\n  end\n\
    \  \n  \n  \n  \n  # Return the smallest prime factor of n. Assume n > 1 and is\
    \ not a prime.\n  # >>> smallest_prime_factor.call(13195)\n  # 5\n  # >>> smallest_prime_factor.call(2048)\n\
    \  # 2\n  def smallest_prime_factor(n)\n    n.to_s.chars.map do |c|\n      if\
    \ primes?(c)\n        n / prime_digit(c) #=> integer division\n      end\n   \
    \ end.min\n  end\n  \n  # Return the greatest product of n and m. Assume n > m\
    \ and m > 1.\n  # >>> largest_product_factor.call(10, 5)\n  # 120\n  # >>> largest_product_factor.call(10,\
    \ 2)\n  # 40\n  def largest_product_factor(n, m)\n    n.to_s.chars.map do |c|\n\
    \      m.to_s.chars.map do |d|\n        if products?(c, d)\n          n * m /\
    \ product(c, d)\n        end\n      end.max\n    end\n  end\n  \n  # Return the\
    \ smallest product of n and m. Assume n > m and m > 1.\n  # >>> smallest_product_factor.call(10,\
    \ 5)\n  # 10\n  # >>> smallest_product_factor.call(10, 2)\n  # 2\n  def smallest_product_factor(n,\
    \ m)\n    n.to_s.chars.map do |c|\n      m.to_s.chars.map do |d|\n        if products?(c,\
    \ d)\n          n * m / product(c, d)\n        end\n      end.min\n    end\n \
    \ end\n  \n  # The prime factors of n are defined as follows: if p is a\n  # prime\
    \ factor of n, then n = p \xD7 n where n is a nonnegative integer.\n  # \n  #\
    \ Return an array of prime factors of n. Assume n > 1.\n  # \n  # >>> prime_factors.call(5)\n\
    \  # [5, 1]\n  # >>> prime_factors.call(19)\n  # [3, 9, 19]\n  # >>> prime_factors.call(20)\n\
    \  # [2]\n  def prime_factors(n)\n    n.to_s.chars.map do |c|\n      if primes?(c)\n\
    \        [c / prime_digit(c), c]\n      end\n    end\n  end\n  \n  \n  # The prime\
    \ factors of n are defined as follows: if p is a\n  # prime factor of n, then\
    \ n = p \xD7 n where n is a nonnegative integer.\n  # \n  # Return an array of\
    \ prime factors of n. Assume n > ", "  n.prime? ? n : largest_prime_factor(n.abs).prime?\
    \ ? n : n.to_i\nend", "  i = 2\n  while i * i <= n\n  i = i * i\n  i\nend\n</cell>\n\
    <code language=julia-1.6>", "  # Use sieve of Eratosthenes algorithm to find all\
    \ prime factors.\n  primes = sieve [n]\n  factors = []\n  factor = 1", "  return\
    \ n if n.prime == 0 else (n % 2 == 0 ? n : largest_prime_factor(n.half))\nend",
  "    primeFactors(n)\n    largest = 1\n    largestFactor = 1\n    i = 2\n    while\
    \ i < n.length do\n        if n%i == 0 then\n            largest = i\n       \
    \     largestFactor = n\n        end\n        i += 1\n    end\n    return largestFactor\n\
    end", "  factor = 2\n  while n > 1\n    if n % factor == 0\n      break\n    factor\
    \ = factor + 1\n    n       = n / factor\n  end\n  factor\nend", "  i = 2\n  while\
    \ i < n do\n    while n % i == 0 do\n      n /= i\n      i += 1\n    end\n   \
    \ i += 1\n  end\n  n\nend\n</code>\nAnd here's a version of the above that uses\
    \ recursion to find the largest prime factor of the number n:\n<code>", "  result\
    \ = 2\n  i = 1\n  while i <= n do\n    if n % i == 0 then\n      result = i\n\
    \      break\n    i += 1\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,primes,algorithm\
    \ |>\n<| c |>\nThis is my favorite solution. It is the simplest one and returns\
    \ the largest prime factor of `n`.\n<|/ c |>\n<| a tags=ruby,primes,algorithm\
    \ |>\nMy solution is quite simple, but it does require a little bit of extra work.\
    \ The idea is to make a table of all primes you have, and when you get a new number\
    \ from your input, you check if it is in the table. If it is not, then it isn't\
    \ prime. Otherwise, you find the smallest index in the table that is less than\
    \ or equal to the current number, and that is the prime you're looking for.\n\
    You will also have to keep track of some additional information, such as which\
    \ primes have been used so far, and whether or not the number has been primed\
    \ already. This will make it so that you can determine whether any new numbers\
    \ you have are primes.\nPseudocode (assuming number is positive):\n<code>\nprimes\
    \ = []\nprimes.push 2\nprimes.push 3", "  sieve = Array.new(n) {|i| false }\n\
    \  primes = Array.new(n) {|i| true }\n  (2..n).each do |i|\n    primes.delete_if{|j|\
    \ sieve[j] && j != i}\n    sieve[i] = ((i-1).to_i).prime?\n  end\n  primes.delete_if{|j|\
    \ !sieve[j]}\n  primes.min\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nYou might\
    \ want to rewrite this as a method with a more generic name.\n<|/ c |>\n<| c |>\n\
    This can be done with dynamic programming and O(1) space complexity. I don't know\
    \ whether this is useful to anyone, but here's a link to a solution in Ruby: http://stackoverflow.com/a/17607981/817644\n\
    <|/ c |>\n<| c |>\nNice solution. I had to fix some bugs, though (I replaced `sieve.delete_if\
    \ { |i| i != i }` by `sieve.delete_if { |i| !(i & i).zero? }` and `sieve[i] =\
    \ ((i-1).to_i).prime?` by `sieve[i] = ((i-1).to_i).prime? && sieve[i / 2]`. And\
    \ I used `n` instead of `n-1` in the `largest_prime_factor` method. Works great.\n\
    <|/ c |>\n<| c |>\nIt would be nice if you would add some explanations to your\
    \ answer, because this would make it even better :)\n<|/ c |>\n<| c |>\nJust add\
    \ \"def largest_prime_factor(n)\"\n<|/ c |>\n<| a dscore=2 |>\nHere is my solution\
    \ in Ruby. Its runs in O(n) time and O(1) space:\n<code>", "  if n <= 1\n    return\
    \ n\n  elsif n % 2 == 1\n    return 2\n  elsif n % 3 == 1\n    return 3\n  elsif\
    \ n % 5 == 1\n    return 5\n  elsif n % 7 == 1\n    return 7\n  elsif n % 11 ==\
    \ 1\n    return 11\n  elsif n % 13 == 1\n    return 13\n  else\n    return find_largest_prime_factor(n/2)\n\
    \  end\nend", "  divisors = getPrimeFactors(n)\n  divisors.each do |d|\n    if\
    \ n % d == 0\n      return d\n    end\n  end\n  raise \"n must be greater than\
    \ one\" unless n > 1\n  1\nend", "  i = 2\n  while i <= n and n % i == 0\n   \
    \ i += 1\n  \n  return n if i == n and n > 2 else i\nend", "  n.to_s.scan(/^\\\
    S+$/) do |prime|\n    if n % prime\n      prime\n    else\n      prime_factors\
    \ = prime_factors.keys.select do |k|\n        k != n\n      end\n      break\n\
    \    end\n  end\n  prime_factors[n.to_i]\nend", "  return n if n < 2 else n %\
    \ 113\nend", "  primes = prime_factors(n)\n  primes.max_by{|a| a}\nend", "  largest\
    \ = 1\n  factor = 1\n  for i in 2...n\n    factor = factor * ((n / i).to_i)\n\
    \    i = 2\n    largest = factor.to_i if factor.to_i >= largest else largest\n\
    \  end\n  return largest\nend", "  factors = []\n  i = 1\n  while i * i <= n\n\
    \    factors.push(i)\n    i += 2\n  i = 1\n  while i * i <= n\n    if n % i ==\
    \ 0\n      i += 1\n    else\n      break\n  factors << n\n  while factors.size\
    \ > 0\n    factor = factors.shift\n    factors.shift while factors.size > factor\n\
    \    factors.shift factor\n  end\nend", '  i, s, p = nil, nil, nil', "  # Write\
    \ your code here.\nend\n</cell>\n<text>\nExercise #4\nIn the cell below, write\
    \ a function that accepts a natural number and returns the sum of the squares\
    \ of its factors.", "  primes = [2,3]\n  i = 3\n  while i <= Math.sqrt(n).ceil\n\
    \    if n % primes[i] == 0\n      primes << primes[i]\n      n /= primes[i]\n\
    \    else\n      i += 2\n    end\n  end\n  if n > 1\n    primes << n\n  end\n\
    \  p =  primes.max\n  if p == 2\n    return p\n  end\n  return largest_prime_factor(p)\n\
    end\n  ", "    i = 2\n    while i * i <= n\n        i += 1\n    return i if n\
    \ % i == 0 then return n end\n    return 2\nend", "  return n.to_i ** n.to_i.to_i\n\
    end", "    return prime_factors.call(n)\nend", "  primes = [2,3]\n  while n %\
    \ primes[-1] != 0\n    primes << 1\n    primes[-1] += 1\n  end\n  primes.each\
    \ do |prime|\n    while n % prime != 0\n      n /= prime\n    end\n  end\n  return\
    \ n if n != 1\n  2\nend", "  i = 1\n  factors = []\n  while i * i <= n && n %\
    \ i == 0\n    i += 1\n    factors << i\n  i = 2\n  while i * i <= n\n    while\
    \ n % i == 0\n      i += 1\n    factors << i\n    i += 1\n  factors.max\nend\n\
    </code>\nThe function largest_prime_factor_call is simply a wrapper around largest_prime_factor,\
    \ so we could have also written largest_prime_factor.call instead (note that largest_prime_factor\
    \ does not need any arguments).\nFinally, we can write a procedure that computes\
    \ the n-th Fibonacci number by using a combination of largest_prime_factor_call\
    \ and fibonacci -- note that we can use a lambda function as the parameter to\
    \ largest_prime_factor because the function largest_prime_factor expects a number\
    \ as a parameter, not an array, and largest_prime_factor does not need to return\
    \ an array -- so largest_prime_factor could have been defined as a function taking\
    \ a single argument, a number, and returning the largest prime factor of n. The\
    \ procedure below takes the Fibonacci number as an argument.\n<code>", "  return\
    \ n if n == 1 || n % 2 == 0 and n > 2 else (largest_prime_factor(n / 2) if n %\
    \ 2 == 0 else n / 2)\nend", "  prime_divisors(n).max\nend", "  return if n.is_a?\
    \ Integer\n  i = 1\n  while i * i <= n\n    i += 1\n  i = 2\n  while i * i <=\
    \ n\n    if n % i == 0\n      i /= 2\n    else\n      break\n  end\n  n\nend",
  "  return n.prime_factors.reduce(:<<).to_f\nend", "  prime = 2\n  i = 1\n  loop\
    \ do\n    i = i + 1\n    prime = prime * i\n    if n % prime == 0\n      break\n\
    \    end\n  end\n  largest_prime_factor = prime\nend", "  prime_checker = PrimeChecker\n\
    \  \n  if prime_checker.prime?(n)\n    return n\n  \n  max_factor = 1\n  i = 1\n\
    \  while i * i <= n\n    i += 1\n  \n  begin = i\n  i += 2\n  while i <= n\n \
    \   i += 1\n    \n    factor_count = begin\n    \n    while i * i <= n\n     \
    \ i += 1\n      \n      factor_count += i - begin\n      begin = i\n      i +=\
    \ 2\n    \n    if n % i == 0\n      factor_count = i + 1\n    \n    if factor_count\
    \ > max_factor\n      max_factor = factor_count\n    end\n  end\n  \n  if max_factor\
    \ != 1\n    p =\n      Prime.new # Create a new Prime instance\n      \n    while\
    \ n % max_factor == 0\n      p += 1\n      n /= max_factor\n    end\n    \n  \
    \  if n > 1\n      p -= 1\n    end\n    \n    if p == 0\n      max_factor += 1\n\
    \    end\n  else\n    max_factor = 1\n  end\n  \n  return max_factor\nend\n</cell>\n\
    <code language=julia-1.0>\nlargest_prime_factor(50)\n</cell>\n<code language=julia-1.0>",
  "  n = n.to_i\n  i = 1\n  while i * i <= n\n    i += 1\n  while n % i == 0\n   \
    \ n /= i\n  return n\nend\nend", "  n = n.to_i\n  factor = 1\n  while n % factor\
    \ == 0\n    factor += 1\n  end\n  factor\nend", "  n = Bignum.new(n)\n  return\
    \ n.send(:next_prime).send(:prime_division, n)\nend", "  i = 2\n  factor = 1\n\
    \  while i * i <= n\n  begin\n    i += 1\n    factor *= i\n  end\n  while n %\
    \ i == 0\n  begin\n    n /= i\n  end\n  factor\nend", "  return prime_factors(n).max\n\
    end\n</pre>", "  primes = factors(n)\n  primes.last.size.times do |i|\n    if\
    \ primes[i] <= 2 && (n % primes[i]) == 0\n      return primes[i]\n    end\n  end\n\
    \  return nil\nend\n</code>\n<|/ a dscore=5 tags=primes,ruby,algorithm |>\n<|\
    \ c |>\nThis was a great answer. Thanks so much.\n<|/ c |>\n<| c |>\nWhat about\
    \ `largest_prime_factor(2**1000)`?\n<|/ c |>\n<| c |>\n.: 2**1000 is **not** a\
    \ prime, since it exceeds the maximum value of an `Integer` of 263 - 1, which\
    \ is 2**31-1.\n<|/ c |>\n<| c |>\n.: Actually, 2**1000 exceeds the maximum value\
    \ of an `Integer` of 2**31 - 1 by 1. If `largest_prime_factor` returned `2**1000`,\
    \ then that meant that the value returned by `largest_prime_factor` was not the\
    \ largest prime factor of **2**1000**. Since 2**1000 exceeds the maximum value\
    \ of an `Integer`, it is not a prime number.\n<|/ c |>\n<| c |>\n.: That is correct\
    \ (although I didn't see that when I first wrote the comment), but how does `largest_prime_factor(2**1000)`\
    \ return 2? Shouldn't it return 2**1000?\n<|/ c |>\n<| a |>\nThis seems to work\
    \ for me:\n<code>", "  if n <= 1\n    1\n  else\n    # See wikipedia on prime\
    \ numbers\n    (n % 2 == 0 and\n     n % 3 != 0 and\n     n % 5 != 0 and\n   \
    \  n % 7 != 0) or\n    largest_prime_factor(n / 2)\n  end\nend", "  sieve =  \
    \ [2,3,5,7,11,13,17,19,23,29,31,37]\n  primes = [2,3]\n  i = 1\n  while i <= sievelength\n\
    \    if sieve[i]\n      prime = primes.shift\n      j = (i + prime) / 2\n    \
    \  sieve << j if (n % prime) == 0\n    else\n      i = i + 1\n  end\n  return\
    \ primes.last\nend", "  # Return the largest prime factor of n. Assume n > 1 and\
    \ is not a prime.\n  if n <= 2\n    1\n  else\n    largest_prime_factor_helper(n,\
    \ 2)\n  end\nend", "  return largest_prime_factors(n).max\nend", "  largest_prime\
    \ = 1\n  i = 1\n  while i * i <= n\n    i += 2\n    largest_prime = n if n % i\
    \ == 0 and i > n / largest_prime\n  end\n  return largest_prime\nend", "  return\
    \ prime_numbers(n).max_by { |i| i.prime ? 1 : i }\nend", "  return n if n < 2\
    \ else largest_prime_factor(n % 2) == 2 ? n : largest_prime_factor(n % prime_divisors_n[n\
    \ % prime_divisors_n.length - 1]).call(n/prime_divisors_n[n % prime_divisors_n.length\
    \ - 1])\nend", "  while n > 2\n    prime = 1\n    while prime * prime <= n\n \
    \     prime += 1\n      n /= prime\n    prime\n  end\n  n\nend", "  return n >\
    \ 1 and n and n.is_a?(Integer)? n % 2 == 0 ? 2 : (n % 2 == 1 ? 3 : n % 3 > 2 ?\
    \ 2 : 3)\nend\n</code>\n<|/ a |>\n<| c |>\nThis is very helpful. Thanks!\n<|/\
    \ c |>\n<| a |>\nHere's a solution in Ruby. I've added some comments to clarify\
    \ what it is doing. It's basically an algorithmic version of the Sieve of Eratosthenes,\
    \ with a few tweaks. I've used a prime array instead of an array, but this works\
    \ with an array.\n<code>", "    factors = []\n    i = 1\n    while n % i == 0\n\
    \        factors << i\n        i += 1\n    factors.max { |a, b| a < b ? a : b\
    \ }\nend\n</code>\n<|/ a |>\n<| c |>\nWhy do you think `prime?` doesn't work with\
    \ prime numbers?\n<|/ c |>\n<| c |>\nThat's a good point, that would indeed break\
    \ the algorithm.  I'll fix it.  Thanks.\n<|/ c |>\n<| c |>\nYes, prime numbers\
    \ aren't prime.\n<|/ c |>\n<| c |>\nPrimes aren't prime because they're neither\
    \ prime factor of another number nor are they composites. In fact, they can't\
    \ be prime because a prime number has exactly one and only one factor. That's\
    \ why I rephrased the statement \"The biggest prime factor of n\" to \"The largest\
    \ prime factor of n\" in the title.  That's how I interpret what a prime factor\
    \ means.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,algorithm,primes,factors |>\n\
    <code>\n def prime?(number)\n  return true if (number==1) || (number==0)\n  primes\
    \ = []\n  (2..Math.sqrt(number)).each do |i|\n    primes << i\n    break if number\
    \ % i == 0\n  end\n  primes.each { |i| return false if number % i == 0 }\n  true\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 tags=ruby,ruby-on-rails,algorithm,primes,factors\
    \ |>\n<code>\n  def prime?(number)\n    return true if number == 1 or number ==\
    \ 0\n    primes = []\n    (2..Math.sqrt(number)).each do |i|\n      primes <<\
    \ i\n      break if number % i == 0\n    end\n    primes.each { |i| return false\
    \ if number % i == 0 }\n    true\n  end\n</code>\n<|/ a |>\n<| c |>\nHow is this\
    \ different from [the other answer](https://stackoverflow.com/a/6249927/1579667)?\
    \ Can you please provide some explanation how and why this works?\n<|/ c |>\n\
    <| a dscore=1 |>\nAnother Ruby way:\n<code>", "    prime_facs = nil\n    factors\
    \ = []\n    prime_factors = 2\n    while n > 1\n        factors = factors + [prime_factors]\n\
    \        prime_factors = prime_factors * prime\n        n = n / prime_factors\n\
    \    end\n    factors.each {|factor| return factor}\nend", "  return nil if n\
    \ < 2\n  a = [2, 3]\n  for i in (1..n)\n    a = a.product(2..i).grep(%i{1 3}).map(&:last).flatten.compact.min\n\
    \  end\n  a\nend", "  i = 2\n  while i * i <= n\n  i += 2\n  i -= 1\n  while i\
    \ <= n\n    prime = 1\n    n /= i\n    while n % i == 0\n      n /= i\n      prime\
    \ *= i\n    i = 2\n    if n == 1\n      break\n    if prime > n\n      break\n\
    \    end\n    i = i + 1\n  end\n  i\nend", "  i = 1\n  while i*i <= n and n %\
    \ i == 0\n    i += 1\n  end\n  if i >= i\n    i\n  else\n    largest_prime_factor(i\
    \ * i)\n  end\nend", "  return n if n <= 2 else n % [2, 3, 5][n.floor == 1 ? 1\
    \ : -1]\nend", "  primes = prime_finder.primes(n)\n  if primes.nil? then return\
    \ nil end\n  primes.each_cons(2).find { |a, b| n.to_f**a > n.to_f**b }[0]\nend\n\
    </code>\n<|/ a tags=primes,ruby |>\n<| a dscore=3 tags=primes,ruby |>\nHere's\
    \ a more Ruby-like way:\n<code>", "  primes = [2,3]\n  factors = []\n  while n\
    \ != 1 do\n    if n%primes.last == 0 then\n      factors.push(primes.last)\n \
    \     n /= primes.last\n      primes.push(primes.last*primes.last)\n    else\n\
    \      primes.push(primes.last*primes.last+2)\n    end\n  end\n  return factors.last\n\
    end\n</cell>\n<code language=julia-1.0>\nlargest_prime_factor(13195)\n</cell>\n\
    <code language=julia-1.0>\nlargest_prime_factor(2048)\n</cell>\n<text>\nExercises\n\
    Exercise 1:\nThe numbers $5$, $3$ and $7$ have the property $5^2 + 3^2 = 27$.\
    \ Find this value using Julia.", "  largest_prime_factor_proc = proc { |n|\n \
    \   loop do\n      i = 1\n      begin\n        while i * i <= n\n          i +=\
    \ 2\n        end\n        break i\n      end while not isprime(i)\n    end\n \
    \ }\n  n.times.with_object({}) { |i,h|\n    i = isprime(i) ? i : largest_prime_factor_proc.call(n\
    \ - i)\n    h[i] = i unless h[i].nil?\n  }\n  largest_prime_factor_proc.call(n)\n\
    end", "  return n if n % 2 == 0 and n > 2 else largest_prime_factor(n / 2)\nend",
  "  factors = prime_factors(n)\n  factors.delete_if { |f| n == f}\n  factors.max\n\
    end", "  n = n.to_i\n  i = 2\n  factors = []\n  while i * i <= n\n    i = i +\
    \ 2\n  while i * i <= n\n    i = i + 1\n    while i * i <= n\n      if n % i ==\
    \ 0\n        break\n      i = i + 1\n    end\n    if i == n\n      factors.push\
    \ i\n    end\n  end\n  factors.sort!\n  if factors.count > 1\n    factors[-1]\n\
    \  else\n    factors.first\n  end\nend", "  # Initialize largest prime factor\
    \ to 2.\n  max_factor = 2", "  factors = []\n  factor = 1\n  i = 1\n  j = 1\n\
    \  while factor*i <= n\n    factor = factors + i\n    i += 1\n  end\n  while j*j\
    \ <= factor\n    j = factors + j\n    j += 1\n  end\n  factors.max\nend", "  \
    \  largest_factor = 1\n    factor = 2\n    while factor < n do\n        if n %\
    \ factor == 0 do\n            n = n / factor\n            largest_factor = factor\n\
    \        factor = factor + 1\n    end\n    return largest_factor\nend", "  i =\
    \ 2\n  while i <= Math.sqrt(n)\n    i += 1\n    if n % i == 0\n      n = n / i\n\
    \      break\n    end\n  end\n  i\nend\n</code>\n<|/ a tags=ruby,primes,algorithm\
    \ |>\n<| a |>\nI like Oscar's answer, but a little faster (about 70% faster) would\
    \ be to start at 3 and factorize only up to the square root of n. Also, I noticed\
    \ that he started at 3 and factorized up to sqrt(n), but I don't see why you would\
    \ do that. Starting at 3 would just give you the highest prime factor by order,\
    \ which isn't what you want.\n<code>", "  factors = []\n  i = 2\n  factor = 2\n\
    \  while i <= n\n    j = i\n    while j <= n and n % j == 0\n      j += 1\n  \
    \  if j > n\n      break\n    while j <= n and n % i == 0\n      factors.push\
    \ i\n      n /= i\n    i += 1\n    factor = largest factor\n  return factor\n\
    end", "    prime_factors = []\n    i = 2\n    \n    # loop while i divides n\n\
    \    while i % n != 0 \n        \n        # add the prime factors of i to our\
    \ list\n        prime_factors.push i", "  prime_numbers = []\n  i = 2\n  while\
    \ i <= n do\n    prime_numbers.push(2i)\n    i = i * 2\n  end\n  i = 2\n  while\
    \ i <= n do\n    prime_numbers.push(n / i)\n    i = i * 2\n  end\n  prime_numbers.sort\n\
    \  prime_numbers.last\nend", "  i = 2\n  factor = 2\n  while i * factor <= n\n\
    \    i += 1\n    factor *= i\n  factor\nend", "  n = n.to_i\n  return n if n <=\
    \ 2 else n % prime_power(2, n)\nend", "    prime_divisors = (2,3,5)\n    max_divisor\
    \ = 1\n    divisor_found = False\n    while not divisor_found and max_divisor\
    \ < n:\n        if n % max_divisor == 0:\n            divisor_found = True\n \
    \       else:\n            max_divisor += 1\n            if max_divisor > n:\n\
    \                max_divisor = n", '  return nil if not n or n.odd? or n % 2 ==
    0 or n % 3 == 0', "  return if n.zero?\n  largest = 1\n  n.times do |i|\n    largest\
    \ = 1 if largest == 1\n    next unless n % i == 0\n    largest = i if largest\
    \ > i\n  end\n  largest\nend", "  factor = 1\n  while n > 1\n    factor += 1\n\
    \    while n % factor\n      factor += 1\n    n /= factor\n  end\n  factor\nend",
  "    # check if n is a prime\n    if n == 2 || n == 3\n        return n\n    \n\
    \    # check if n is a prime and 2\n    if (n%2) == 0 && (n%3) == 0\n        return\
    \ n\n    \n    # check if n is a prime and 3\n    if (n%2 == 0) && (n%3 == 0)\n\
    \        return n\n    \n    # check if n is a prime and 4\n    if (n%2 == 0)\
    \ && (n%4 == 0)\n        return n\n    \n    # check if n is a prime and 5\n \
    \   if (n%2 == 0) && (n%5 == 0)\n        return n\n    \n    # Check if n is a\
    \ prime and 6\n    if (n%2 == 0) && (n%6 == 0)\n        return n\n    \n    #\
    \ Check if n is a prime and 7\n    if (n%2 == 0) && (n%7 == 0)\n        return\
    \ n\n    \n    # Check if n is a prime and 8\n    if (n%2 == 0) && (n%8 == 0)\n\
    \        return n\n    \n    # Check if n is a prime and 9\n    if (n%2 == 0)\
    \ && (n%9 == 0)\n        return n\n    \n    # Check if n is a prime and 10\n\
    \    if (n%2 == 0) && (n%10 == 0)\n        return n\n    \n    # Check if n is\
    \ a prime and 11\n    if (n%2 == 0) && (n%11 == 0)\n        return n\n    \n \
    \   # Check if n is a prime and 12\n    if (n%2 == 0) && (n%12 == 0)\n       \
    \ return n\n    \n    # Check if n is a prime and 13\n    if (n%2 == 0) && (n%13\
    \ == 0)\n        return n\n    \n    # Check if n is a prime and 14\n    if (n%2\
    \ == 0) && (n%14 == 0)\n        return n\n    \n    # Check if n is a prime and\
    \ 15\n    if (n%2 == 0) && (n%15 == 0)\n        return n\n    \n    # Check if\
    \ n is a prime and 16\n    if (n%2 == 0) && (n%16 == 0)\n        return n\n  \
    \  \n    # Check if n is a prime and 17\n    if (n%2 == 0) && (n%17 == 0)\n  \
    \      return n\n    \n    # Check if n is a prime and 18\n    if (n%2 == 0) &&\
    \ (n%18 == 0)\n        return n\n    \n    # Check if n is a prime and 19\n  \
    \  if (n%2 == 0) && (n%19 == 0)\n        return n\n    \n    # Check if n is a\
    \ prime and 20\n    if (n%2 == 0) && (n%20 == 0)\n        return n\n    \n   \
    \ # Check if n is a prime and 21\n    if (n%2 == 0) && (n%21 == 0)\n        return ",
  "  n -= 2\n  prime_max = 4\n  result = 1\n  while prime_max < n do\n    if n % prime_max\
    \ == 0 then\n      result = prime_max\n      break\n    prime_max = prime_max\
    \ * 2\n  end\n  result\nend", "  i = 1\n  while n % i != 0\n    i += 1\n    n/i\n\
    \  end\n  n\nend", "  result = 0\n  (2..n).each do |i|\n    prime = true\n   \
    \ (3..i).each do |j|\n      if i % j == 0 then\n        prime = false\n      \
    \  break\n      end\n    end\n    result =\n      if prime then\n        i\n \
    \     else\n        result\n      end\n  end\nend\n</code>\n<|/ a tags=ruby |>\n\
    <| c |>\nThank you! This was a great answer. I'm glad you posted it here as well.\n\
    <|/ c |>\n<| a tags=ruby |>\nI came across this problem just today in Ruby when\
    \ I was trying to find my way through the book \"Hacker's Delight\". I found this\
    \ solution online and it works well for me:\n<code>", "  # Return the largest\
    \ prime factor of n. Assume n > 1 and is not a prime.\n  if n <= 1\n    nil\n\
    \  elsif n % 2 == 0\n    n / 2\n  elsif n % 3 == 0\n    n / 3\n  else\n    if\
    \ n > 3\n      a = n / 4\n      while a % 2 == 0\n        a /= 2\n      while\
    \ a % 3 == 0\n        a /= 3\n      while a % 5 == 0\n        a /= 5\n      while\
    \ a % 7 == 0\n        a /= 7\n      a\n    else\n      while n % 2 == 0\n    \
    \    n /= 2\n      while n % 3 == 0\n        n /= 3\n      while n % 5 == 0\n\
    \        n /= 5\n      while n % 7 == 0\n        n /= 7\n      n\n    end\n  end\n\
    end", "  i = 2\n  factor = 1\n  while i * i <= n\n    i += 1\n    if n % i ==\
    \ 0\n      break\n    factor = i\n  factor\nend\n</code>\nThe first time we run\
    \ it on a number we already know is not a prime, we'll get an infinite loop:\n\
    <code>\nLargest_prime_factor.call(42)\n=> nil\n</code>\nThe second time we run\
    \ the loop:\n<code>\nLargest_prime_factor.call(42)\n=> 4\n</code>\nIn Ruby, the\
    \ loop is expressed using the do ... end syntax. As long as you have a loop body,\
    \ you need a do ... end block to keep the code inside the loop from being executed\
    \ more than once.\nTo make your function return nil when n is not a prime, we\
    \ just add the do ... end block, and nil at the end of the function:\n<code>",
  "  if n <= 1\n    1\n  else\n    largest_prime_factor(n % 2)\n  end\nend", "  return\
    \ n.factors.reduce(:<=>).max\nend\n</code>\n<|/ a |>\n<| a |>\nThis doesn't require\
    \ any extra modules.\n<code>", "  if n <= 1\n  1\n  else\n    return n % largest_prime_factor(n\
    \ / 2) if n > 2 else 2\n  end\nend", "  factors = []\n  factor = 1\n  i = 1\n\
    \  while factor * i < n\n    factor = factor * i\n    i += 1\n    factors << factor\n\
    \    factor = 1\n  end\n  factors << factor\n  factors.uniq.max\nend\nputs largest_prime_factor.call(1024)",
  "  primes = prime_numbers(n)\n  largest = primes[0]\n  factor = 1\n  prime_numbers(n)\n\
    \  primes.each do |prime|\n    factor <= prime ? (largest == prime ? largest :\
    \ factor) = prime : factor = 1\n  end\n  return factor\nend", "  prime_counter\
    \ = 1\n  largest_prime_factor = 1\n  if n.odd? # Check if n is odd\n    n.times\
    \ {\n      prime_counter.times do\n        if n % prime_counter == 0 \n      \
    \    break\n        end\n      end\n      if prime_counter == 1\n        largest_prime_factor\
    \ = n\n      end\n      prime_counter = prime_counter + 1\n    }\n  else\n   \
    \ n.times do\n      prime_counter = prime_counter + 1\n    end\n    prime_counter.times\
    \ do\n      largest_prime_factor = largest_prime_factor * prime_counter\n    end\n\
    \  end\n  return largest_prime_factor\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    `largest_prime_factor = largest_prime_factor * prime_counter` will give you a\
    \ runtime error if largest_prime_factor is 1.\n<|/ c |>\n<| a dscore=0 tags=primes,ruby\
    \ |>\n<code>", "  if n < 2\n    return 2\n  elsif n <= 1\n    return n\n  end\n\
    \  prime = nil\n  i = 2\n  until prime == nil and i <= n do\n    if n % i == 0\n\
    \      prime = i\n    end\n    i += 1\n  end\n  if prime == nil\n    prime = n\n\
    \  end\n  return prime\nend", "    return n > 1 \\\n        and all([n % p for\
    \ p in factors(n)[:k]])\nend", "  largest_prime = 1\n  factor = 1\n  while n >\
    \ largest_prime\n    largest_prime = largest_prime * 2\n    factor = 1\n    factor\
    \ = 1\n    while n < largest_prime\n      n = n / largest_prime\n      factor\
    \ = factor * largest_prime\n      largest_prime = largest_prime * 2\n    end\n\
    \  end\n  factor\nend\n</cell>\n<code language=julia-1.4>\nlargest_prime_factor(13195)\n\
    </cell>\n<code language=julia-1.4>\nlargest_prime_factor(2048)\n</cell>\n<text>\n\
    Exercise 3\nA palindromic number reads the same both ways. The largest palindrome\
    \ made from the product of two 2-digit numbers is 9009 = 91 \xD7 99."]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
