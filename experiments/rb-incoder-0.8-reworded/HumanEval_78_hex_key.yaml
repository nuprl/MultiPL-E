name: HumanEval_78_hex_key
language: rb
prompt: "# You have been tasked to write a function that receives \n# a hexadecimal\
  \ number as a string and counts the number of hexadecimal \n# digits that are primes\
  \ (prime number, or a prime, is a natural number \n# greater than 1 that is not\
  \ a product of two smaller natural numbers).\n# Hexadecimal digits are 0, 1, 2,\
  \ 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n# Prime numbers are 2, 3, 5, 7, 11, 13,\
  \ 17,...\n# So you have to determine a number of the following digits: 2, 3, 5,\
  \ 7, \n# B (=decimal 11), D (=decimal 13).\n# Note: you may assume the input is\
  \ always correct or empty string, \n# and symbols A,B,C,D,E,F are always uppercase.\n\
  # Examples:\n# >>> hex_key.call(\"AB\")\n# 1\n# >>> hex_key.call(\"1077E\")\n# 2\n\
  # >>> hex_key.call(\"ABED1A33\")\n# 4\n# >>> hex_key.call(\"123456789ABCDEF0\")\n\
  # 6\n# >>> hex_key.call(\"2020\")\n# 2\ndef hex_key(num)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_hex_key\n\
  \    candidate = method(:hex_key)\n    assert_equal(1, candidate.call(\"AB\"))\n\
  \    assert_equal(2, candidate.call(\"1077E\"))\n    assert_equal(4, candidate.call(\"\
  ABED1A33\"))\n    assert_equal(2, candidate.call(\"2020\"))\n    assert_equal(6,\
  \ candidate.call(\"123456789ABCDEF0\"))\n    assert_equal(12, candidate.call(\"\
  112233445566778899AABBCCDDEEFF00\"))\n  end\nend\n"
completions: ["  digits = num.to_s.split(//)\n  num_digits = digits.length\n  if num_digits\
    \ < 2\n    puts \"Usage: hex_key(hexadecimal number as string)\"\n    exit\n \
    \ end\n  if num_digits == 1\n    puts \"Usage: hex_key(hexadecimal number as string)\"\
    \n    exit\n  end\n  result = 0\n  for i in 0..num_digits-2\n    if i == 0\n \
    \     result << 16\n    elsif digits[i] == \"0\"\n      next\n    elsif digits[i]\
    \ == \"1\"\n      result << 2\n    elsif digits[i] == \"A\"\n      result << 10\n\
    \    elsif digits[i] == \"B\"\n      result << 11\n    elsif digits[i] == \"C\"\
    \n      result << 12\n    elsif digits[i] == \"D\"\n      result << 13\n    elsif\
    \ digits[i] == \"E\"\n      result << 14\n    elsif digits[i] == \"F\"\n     \
    \ result << 15\n    else\n      puts \"Usage: hex_key(hexadecimal number as string)\"\
    \n      exit\n    end\n  end\n  puts \"#{result}\"\nend\n</code>\n<|/ a |>\n<|\
    \ c |>\nThanks for help, I appreciate your time. The above code works fine for\
    \ most cases but when it encounters cases like \"ABED1A33\" I get the wrong result.\n\
    <|/ c |>\n<| c |>\nI tested your code with many cases and it works fine for all\
    \ of them. Did you check the examples you provided?\n<|/ c |>\n<| c |>\nYes, I\
    \ tested all of your cases and it works fine for them. However, the case I posted\
    \ in the example code fails.\n<|/ c |>\n<| c |>\nThat is weird, it should work.\
    \ If you are not sure why something does not work, try putting in some debug prints\
    \ like `p digits` just before you try to check for each digit and see what it\
    \ actually contains there.\n<|/ c |>\n<| c |>\nThanks for your help, I appreciate\
    \ your time. I did what you said and the digits array had the entire string in\
    \ it no matter the case. The weird thing is that the same case that I posted in\
    \ the example code, works fine for you. I will try it again and will let you know\n\
    <|/ c |>\n<| a dscore=1 |>\nHere's a solution using recursion that works just\
    \ fine for this problem:\n<code>", "  num = num.to_s\n  count = 0\n  while num.length\
    \ > 0\n    if num.length % 2 == 0\n      if num[num.length/2].to_i == 9\n    \
    \    count += 2\n      else\n        count += 1\n    end\n    num = num.slice(1,\
    \ num.length - 1)\n  end\n  count\nend", "  num = num.strip\n  result = 0\n  for\
    \ i in num\n    if i.to_s.match(/[A-F]/)\n      result += 1\n    end\n  end\n\
    \  return result\nend", '  return num.to_i(16).to_s(16).count(num[/[a-fA-F]/])',
  "  # Your code here\n  n = []\n  n.each do |x|\n    if x[0].is_a? String\n     \
    \ s = x[0]\n    else \n      s = \"0\"\n    end\n    i = s.to_i\n  end\nend\n\
    </code>\n<|/ q dscore=0 |>\n<| c |>\nWhen you say \"I get the following errors\"\
    , what error do you get? What have you tried?\n<|/ c |>\n<| c |>\n\"I get the\
    \ following errors\"?  What errors?  What have you tried?  Have you tried to debug\
    \ this code?  Can you find out where it's going wrong?  Can you narrow down what\
    \ exactly it's going wrong?  Where are you getting stuck?\n<|/ c |>\n<| c |>\n\
    I do not have an error message in my ruby program. But the program is giving me\
    \ the wrong output.\n<|/ c |>\n<| c |>\nDo you get an error message?  What output\
    \ do you get?  What output do you expect?  Please be more precise.\n<|/ c |>\n\
    <| c |>\nYour `hex_key` method is poorly indented, please fix.\n<|/ c |>\n<| a\
    \ |>\nI believe you are looking for this: \n<code>", "  num = num.to_s.chomp.to_i\n\
    \  if num < 2\n    return 0\n  else \n    primes = 0\n    for j in 2..num\n  \
    \    if num % j == 0\n        primes += 1\n        break\n    end\n    num -=\
    \ primes\n    primes = 0\n    for j in 2..num\n      if num % j == 0 && j != primes\n\
    \        primes += 1\n        break\n    end\n    num -= primes\n    return primes\n\
    end", "  num = num.to_s\n  key = num.count(\"A\") - num.count(\"B\") - num.count(\"\
    C\") - num.count(\"D\") - num.count(\"E\") - num.count(\"F\")\n  if key.zero?\n\
    \    return 0\n  end\n  return key\nend", "  num = num.to_s\n  prime_digits =\
    \ 0\n  prime_digits.upto(9) do |d|\n    if (num.include?(d)) then\n      prime_digits\
    \ += 1\n    end\n  end\n  return prime_digits - 2\nend", "  # your code here\n\
    \  if num == \"\" or num.upcase == nil \n    return 0\n  end\n  digit_num = \"\
    \"\n  i = 2\n  while i <= num.length do\n    digit_num += num.slice(i,i+1).to_i\n\
    \    i += 1\n  end\n  digit_num = digit_num.to_i\n  num = digit_num.to_s # converting\
    \ back to string\n  digit_count = 0\n  prime_number = 2\n  while num > 1 do\n\
    \    if digit_num % prime_number == 0 \n      digit_count += 1\n      prime_number\
    \ += 1\n    end\n    digit_num = digit_num.to_i\n    num = digit_num.to_s\n  end\n\
    \  return digit_count\nend\n</code>\nFor your second problem, you can use a very\
    \ similar approach.\n<|/ a dscore=0 |>\n<| c |>\nYeah your solution is definitely\
    \ better, I missed the part about the input being correct. I have updated my solution\
    \ to support both types of input.\n<|/ c |>\n<| c |>\n, if the answer works for\
    \ you, can you accept it? Thanks!\n<|/ c |>\n<| a tags=ruby,math,primes,hex |>\n\
    Just for the fun of it:\n<code>", "  if num.length <= 0\n    return 0\n  sum =\
    \ 0\n  hex_dec = num.upcase\n  hex_dec.each_char do |c| \n    hex_dec = hex_dec.gsub(/[a-f]/i,\
    \ \"-\")\n    hex_dec.gsub!(\"0\", \"\")\n    hex_dec.gsub!(\"1\", \"\")\n   \
    \ hex_dec.gsub!(\"2\", \"\")\n    hex_dec.gsub!(\"3\", \"\")\n    hex_dec.gsub!(\"\
    4\", \"\")\n    hex_dec.gsub!(\"5\", \"\")\n    hex_dec.gsub!(\"6\", \"\")\n \
    \   hex_dec.gsub!(\"7\", \"\")\n    hex_dec.gsub!(\"8\", \"\")\n    hex_dec.gsub!(\"\
    9\", \"\")\n    hex_dec.gsub!(\"A\", \"\")\n    hex_dec.gsub!(\"B\", \"\")\n \
    \   hex_dec.gsub!(\"C\", \"\")\n    hex_dec.gsub!(\"D\", \"\")\n    hex_dec.gsub!(\"\
    E\", \"\")\n    hex_dec.gsub!(\"F\", \"\")\n    hex_dec.gsub!(\"a\", \"\")\n \
    \   hex_dec.gsub!(\"b\", \"\")\n    hex_dec.gsub!(\"c\", \"\")\n    hex_dec.gsub!(\"\
    d\", \"\")\n    hex_dec.gsub!(\"e\", \"\")\n    hex_dec.gsub!(\"f\", \"\")\n \
    \   hex_dec.gsub!(\"e\", \"\")\n    hex_dec.gsub!(\"d\", \"\")\n    hex_dec.gsub!(\"\
    c\", \"\")\n    hex_dec.gsub!(\"b\", \"\")\n    hex_dec.gsub!(\"a\", \"\")\n \
    \   hex_dec.gsub!(\"8\", \"\")\n    hex_dec.gsub!(\"7\", \"\")\n    hex_dec.gsub!(\"\
    6\", \"\")\n    hex_dec.gsub!(\"5\", \"\")\n    hex_dec.gsub!(\"4\", \"\")\n \
    \   hex_dec.gsub!(\"3\", \"\")\n    hex_dec.gsub!(\"2\", \"\")\n    hex_dec.gsub!(\"\
    1\", \"\")\n    hex_dec.gsub!(\"0\", \"\")\n  end\n  hex_dec = hex_dec.scan(/./)\n\
    \  hex_dec.each do |hex|\n    hex = hex.to_i\n    sum += hex\n  end\n  return\
    \ sum\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI am not looking for prime numbers.\
    \  I am looking to determine ", "  # Write your code here\n  return 0\nend", " \
    \   digit_count = ''\n    digits = num.to_s.split('')\n    digits.each do |i|\n\
    \        if i % 2 != 0 && i.to_s.to_i > 'A'\n            digit_count = digit_count.to_i\
    \ + i.to_s.to_i\n        end\n    end\n    digit_count\nend", "  num = num.downcase\
    \ # make input all uppercase\n  hex_digits = \"0123456789ABCDEF\"\n  prime = 0\
    \ # initialize count with 0\n  num.split(\"\").each do |char|\n    if hex_digits.include?\
    \ char\n      prime += 1 if char == num[-1]\n    end\n  end\n  prime # return\
    \ number\nend\n</pre>\n<p>\n  Next, write a function that returns True if num\
    \ is a prime number (\n  a natural number greater than 1 that is not a product\
    \ of two smaller \n  natural numbers), or False otherwise.\n  Write your solution\
    \ in the cell below. \n  Feel free to use the function above if you need to.\n\
    \  Hint: you will need at least one more function for this exercise. \n  Write\
    \ your function in the cell below.\n</p>\n<pre class=\"ruby\">", "  return sum(((num.each_char.map{|x|\
    \ x.to_i(16)}).collect{|x| x.is_a?(Integer) ? x : x.to_i(16)}.compact).count(2))\n\
    end\n</code>\n<|/ a |>\n<| c |>\nYou don't need to convert integers to strings\
    \ with `to_s` - `each_char` yields characters one by one.\n<|/ c |>\n<| c |>\n\
    `count` method of Array is available in Ruby 2.0+ only, not Ruby 1.9.3. And `is_a?`\
    \ method of object returns false on integers, so no need for checking if `is_a?`\
    \ returns true.\n<|/ c |>\n<| c |>\nThanks for pointing that out.  I didn't realize\
    \ that was a change...  I'll update the code to reflect that.\n<|/ c |>\n<| a\
    \ |>\nThis may be the most Pythonic solution:\n<code>", "  return 0 \nend", " \
    \ num_list = num.to_s.split(\"\").map{|x| x.to_i}\n  num_list.each do |n|\n  \
    \  if n % 2 == 0\n      puts \"#{n} is even\"\n    elsif n % 3 == 0\n      puts\
    \ \"#{n} is divisible by 3\"\n    elsif n % 5 == 0\n      puts \"#{n} is divisible\
    \ by 5\"\n    elsif n % 7 == 0\n      puts \"#{n} is divisible by 7\"\n    elsif\
    \ n % 11 == 0\n      puts \"#{n} is divisible by 11\"\n    elsif n % 13 == 0\n\
    \      puts \"#{n} is divisible by 13\"\n    elsif n % 17 == 0\n      puts \"\
    #{n} is divisible by 17\"\n    elsif n % 19 == 0\n      puts \"#{n} is divisible\
    \ by 19\"\n    elsif n % 23 == 0\n      puts \"#{n} is divisible by 23\"\n   \
    \ end\n  end\nend", "    # Your code here\n    # Your code here\n    # Your code\
    \ here\n    # Your code here\n    # Your code here\n    # Your code here\n   \
    \ # Your code here\n    # Your code here\n    # Your code here\n    # Your code\
    \ here\n    # Your code here\n    # Your code here\n    # Your code here\n   \
    \ # Your code here\n    # Your code here\n    # Your code here\n    # Your code\
    \ here\n    # Your code here\n    # Your code here\n    # Your code here\n   \
    \ # Your code here\n    # Your code here\n    # Your code here\n    # Your code\
    \ here\n    # Your code here\n    # Your code here\n    # Your code here\n   \
    \ # Your code here\n    # Your code here\n    # Your code here\n    # Your code\
    \ here\n    # Your code here\n    # Your code here\n    # Your code here\n   \
    \ # Your code here\n    # Your code here\n    # Your code here\n    # Your code\
    \ here\n    # Your code here\n    # Your code here\n    # Your code here\n   \
    \ # Your code here\n    # Your code here\n    # Your code here\n    # Your code\
    \ here\n    # Your code here\n    # Your code here\n    # Your code here\n   \
    \ # Your code here\n    # Your code here\n    # Your code here\n    # Your code\
    \ here\n    # Your code here\n    # Your code here\n    # Your code here\n   \
    \ # Your code here\n    # Your code here\n    # Your code here\n    # Your code\
    \ here\n    # Your code here\n    # Your code here\n    # Your code here\n   \
    \ # Your code here\n    # Your code here\n    # Your code here\n    # Your code\
    \ here\n    # Your code here\n    # Your code here\n    # Your code here\n   \
    \ # Your code here\n    # Your code here\n    # Your code here\n    # Your code\
    \ here\n    # Your code here\n    # Your code here\n    # Your code here\n   \
    \ # Your code here\n    # Your code here\n    # Your code here\n    # Your code\
    \ here\n    # Your code here\n    # Your code here\n    # Your code here\n   \
    \ # Your code here\n    # Your code here\n    # Your code here\n    # Your code\
    \ here\n    # Your code here\n    # Your code here\n    # Your code here\n   \
    \ # Your code here\n    # Your code here\n    # Your code here\n    # Your code\
    \ here\n    # Your code here\n    # Your code here\n    # Your code here\n   \
    \ # Your code here\n    # Your code here\n    # Your code here\n    # Your code\
    \ here\n    # Your code here\n    # Your ", "    prime = 0\n    \n    # Write\
    \ your code here\n    \n    return prime\n    \nhex_key.call(\"AB\")\n</cell>\n\
    <text>\nE\nWrite a function called hex_divisible_key which receives two arguments:\
    \ a string containing a hexadecimal number and a number between 0 and 15 (inclusive).\
    \ The function must return the number of hexadecimal digits which are prime numbers\
    \ between 0 and 15 (inclusive). Remember that hexadecimal numbers are always between\
    \ 0 and 15 (inclusive). You can assume that the second argument is a valid hex\
    \ number (i.e. the second argument does not start with a '0' or a 'F' or any other\
    \ symbol).", "  num_to_arr(num)\n  if num.size > 4\n    puts num_to_arr(num)\n\
    \  end\n  \n  prime_num = 0\n  prime_digits = 0\n  \n  for i in 1..(size-1)\n\
    \    \n    if num_to_arr(num)[i] > 4\n      if num_to_arr(num)[i] == prime_digits\n\
    \        prime_num += 1\n      end\n      prime_digits += 1\n    end\n    \n \
    \ end\n  \n  if prime_num > prime_digits\n    puts prime_num\n  else\n    puts\
    \ prime_digits\n  end\n  \n  \nend", "    return 1\nend", "  # Write your code\
    \ here.\n  num.count(\"A\") + num.count(\"B\") + num.count(\"C\") + num.count(\"\
    D\") + num.count(\"E\") + num.count(\"F\")\n  i = 2\n  while i <= num.length\n\
    \    prime = num.slice(i..i+1)\n    if prime == [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]\n\
    \      i += 2\n    else\n      prime = false\n      i += 3\n    end\n  end\n \
    \ i\nend\n</cell>\n<code language=julia-1.0>\nfunction hex_key(num)\n  # Write\
    \ your code here.\n  num.count(\"A\") + num.count(\"B\") + num.count(\"C\") +\
    \ num.count(\"D\") + num.count(\"E\") + num.count(\"F\")\n  i = 2\n  while i <=\
    \ num.length\n    prime = num.slice(i..i+1)\n    if prime == [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]\n\
    \      i += 2\n    else\n      prime = false\n      i += 3\n    end\n  end\n \
    \ i\nend\n</cell>\n<text>\nExercise 9\nWrite a function which receives a string\
    \ as a parameter and returns the number of characters of that string that are\
    \ not hexadecimal digits (0-9, A-F, a-f).", "  num_arr = num.to_s.split(\"\").map(&:hex).reject(&:odd?)\n\
    \  num_arr.sort.uniq.count\nend", "  num.upcase!\n  count = num.length\n  for\
    \ i in (0..count-1).step(2..-1)\n    if num[i] == 'A' && num[i+1] == 'B'\n   \
    \   count += 1\n    elsif num[i] == 'B' && num[i+1] == 'D'\n      count += 1\n\
    \    elsif num[i] == 'C' && num[i+1] == 'F'\n      count += 1\n    elsif num[i]\
    \ == 'D' && num[i+1] == 'E'\n      count += 1\n    elsif num[i] == 'E' && num[i+1]\
    \ == 'F'\n      count += 1\n    elsif num[i] == 'F' && num[i+1] == 'A'\n     \
    \ count += 1\n    elsif num[i] == 'F' && num[i+1] == 'B'\n      count += 1\n \
    \ end\n  return count\nend", "  num.each do |value|\n    prime_number = false\n\
    \    hex_value = value.to_s.split(//).map{|i| i.to_i.to_s(16)}.join(\"\")\n  \
    \  hex_value.each_char{|c| prime_number |= ((c >= \"2\") & (c <= \"F\")) | ((c\
    \ >= \"3\") & (c <= \"E\"))}\n    prime_number |= ((hex_value.index(hex_value.chars.reverse.first)\
    \ == hex_value.length - 1) & (hex_value.index(hex_value.chars.reverse.last) ==\
    \ 0))\n    return prime_number\n  end\n  return 0\nend", "  num_string = num.to_s.upcase\n\
    \  hex_digit_count = {}\n  decimal_digit_count = {}", "  count = 0\n  i = 2 #\
    \ hexadecimal digit\n  while i < num.length\n    hex = num.slice(i,i+1) # hexadecimal\
    \ digit\n    hex.to_i\n    if hex == hex.to_i && hex <= 16\n      count += 1\n\
    \      i += 2\n    else\n      i += 1 # skip one hexadecimal digit\n    end\n\
    \  end\n  count\nend\n</cell>\n<code language=julia-1.6>", "  digits = num.to_s.chars\n\
    \  num_prime = 0\n  \n  if digits[0] == 'A' or digits[0] == 'B'\n    num_prime\
    \ = 2\n  elsif digits[0] == 'C' or digits[0] == 'D'\n    num_prime = 3\n  elsif\
    \ digits[0] == 'E' or digits[0] == 'F'\n    num_prime = 7\n  end", "  digits =\
    \ num.split(\"\")\n  n = digits.length\n  \n  counter = 2\n  \n  # first pass:\
    \ determine how many hexadecimal digits are primes\n  primes_count = 0\n  primes\
    \ = []\n  while counter < n\n    if digits[counter] == digits[counter + 1]\n \
    \     counter += 1\n    elsif digits[counter] == digits[counter + 1]\n      primes_count\
    \ += 1\n      counter += 1\n    else\n      primes_count += 1\n      counter -=\
    \ 1\n    end\n  end\n  \n  # second pass: determine how many prime numbers there\
    \ are\n  while counter < primes_count\n    primes << counter\n    counter += 1\n\
    \  end\n  \n  # third pass: count the prime numbers and output them\n  primes_count\
    \ = primes.size\n  primes.each do |prime|\n    count = 0\n    while prime <= primes_count\n\
    \      prime += primes_count\n      count += 1\n    end\n    prime_count = count\n\
    \  end\n  \n  primes_count += 2 # +2 because the first and last prime are themselves\n\
    \  \n  primes_count.times do |prime_index|\n    prime << digits[prime_index]\n\
    \  end\n  \n  primes_count += 1 # +1 because the first and last prime are themselves\n\
    \  \n  primes.each do |prime|\n    puts prime\n  end\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThank you very much! This is exactly what I needed! I didn't know that\
    \ `digits[counter] == digits[counter + 1]` was possible. Now I know why `digits[counter]\
    \ == digits[counter - 1]` doesn't work.\n<|/ c |>\n<| c |>\n, no problem. Sometimes\
    \ it helps to think of it this way: if I put in a number `\"123456789ABCDEF0\"\
    `, I'll iterate through `[1,2,3,4,5,6,7,8,9,A,B,C,D,E,F]` and see if `digits[counter]\
    \ == digits[counter + 1]` evaluates to true or not. Since we can't check `digits[counter\
    \ + 1] == digits[counter]`, then that means `digits[counter]` must be `digits[counter\
    \ - 1]`. So `digits[counter] == digits[counter - 1]` will evaluate to true in\
    \ all cases in my example.\n<|/ c |>\n<| c |>\n, also you can up-vote my answer\
    \ if it helped you.\n<|/ c |>\n<| c |>\nThank you for the tip, I didn't know that,\
    \ I always up-vote answers I like but didn't think of checking the other answers\
    \ first. :D", "  if num.length < 2 then return 0\n  if num.length % 2 == 0 then\
    \ return 0", "  \n  number = num.split(//)\n  \n  number.each do |i|\n    if i.to_s.chars.uniq.count\
    \ == 2 # A == 1 and B == 2, etc \n      next \n    end \n    if i.to_s.chars.uniq.count\
    \ == 3 # B = 3, C = 5, etc\n      number.delete(num) \n      break\n    end \n\
    \  end \n  \n  number.count\nend", "  num, *remainder = num.split(//)\n  num.each_byte\
    \ { |n| n > 10 ? return false : count[n.hex % 10] += 1}\n  remainder.each_byte\
    \ { |n| count[n % 10] += 1 }\n  count.max # returns the highest value\nend", " \
    \ # Your code goes here\n  if num==\"\"\n    return 0\n  hex_key=0\n  hex_key=num.to_i(16).to_s(16).count(\"\
    A\".to_i(16).to_s(16))+num.to_i(16).to_s(16).count(\"B\".to_i(16).to_s(16))\n\
    \  hex_key=hex_key+num.to_i(16).to_s(16).count(\"C\".to_i(16).to_s(16))+num.to_i(16).to_s(16).count(\"\
    D\".to_i(16).to_s(16))\n  return hex_key\n  ", "  num.downcase!\n  primes = (0..9).to_a\n\
    \  primes.delete_if {|i| (num.to_i(16).modulo(i) == 0)}\n  if primes.empty?\n\
    \    return 0\n  else\n    return primes.find {|i| (num.to_i(16).modulo(i) ==\
    \ 0)}.to_i\n  end\nend\n</code>\nI hope this helps someone.\n<|/ a tags=ruby,primes,algorithm\
    \ |>\n<| c |>\nThis is very nice, thank you. Here's another version using only\
    \ Ruby core methods: https://gist.github.com/anonymous/b88b8b7e4bb1ed5edc88\n\
    <|/ c |>\n<| a tags=ruby,primes,algorithm |>\n<code>", "  hex_num = num.unpack(\"\
    H*\")[0]\n  return hex_num.length.times do |i|\n    if (num.slice(i*2, i*2+2)\
    \ == hex_num.slice(i*2, i*2+2)) {\n      return i\n    }\n  end\nend", "  digits\
    \ = []\n  digit = nil\n  for i in 1..num.length\n    digit = num.slice(i,i+1)\n\
    \    digits.push digit.to_i(16)\n  end\n  primes = 0\n  for i in 1..num.length\n\
    \    digit = num.slice(i,i+1)\n    if digits.include? digit\n      primes += digits.length\n\
    \    end\n  end\n  primes\nend\n</code>\n<|/ a dscore=0 tags=ruby |>\n<| c |>\n\
    This seems good but it still doesn't work for me when I pass in `hex_key(\"ABED1A33\"\
    )` or `hex_key(\"123456789ABCDEF0\")`. Instead it returns 0 for both.\n<|/ c |>\n\
    <| c |>\nSorry about that, I have fixed it.\n<|/ c |>\n<| c |>\nI actually need\
    \ to call `hex_key.call(\"2020\")` but your code returns 2.\n<|/ c |>\n<| c |>\n\
    Thanks, that works great! Could you please explain what this code does? I'm not\
    \ sure I understand how it works.\n<|/ c |>\n<| c |>\nI have updated the answer\
    \ so you can understand the code better. If it helps, don't forget to accept the\
    \ answer.\n<|/ c |>\n<| a tags=ruby |>\nHere's a solution that doesn't use recursion.\n\
    <code>", "  return 0\nend", "  num = num.to_s.upcase\n  if num =~ /^(....)*(.)(..)*(....)*(.)(..)*(....)*$/\n\
    \    hex = num.scan(/^(....)*(.)(..)*(....)*(.)(..)*(....)*$/).first.last\n  \
    \  hex.count(\"A\") + hex.count(\"B\") + hex.count(\"C\") + hex.count(\"D\") +\
    \ hex.count(\"E\") + hex.count(\"F\")\n  else\n    0\n  end\nend", "  return hex_digits(num).inject(0)\
    \ do |sum, digit|\n    return 0 if digit == 'F'\n    return sum + 1 if digit ==\
    \ 'F'\n    sum + 1 if digit == 'B' and num.length > 1\n    sum + 1 if digit ==\
    \ 'D' and num.length > 1\n  end\nend", "  h = 0\n  n = num.to_s\n  for i in 0..(n-1)\n\
    \    j = hex_to_int(n[i])\n    h += 1\n    if j == 2\n      break\n    elsif j\
    \ > 2\n      continue\n    elsif j == 3\n      break\n    elsif j == 5\n     \
    \ break\n    elsif j == 7\n      break\n    elsif j == 11\n      break\n    elsif\
    \ j == 13\n      break\n    end\n  end\n  return h\nend\n</code>\n<|/ a tags=ruby,primes\
    \ |>\n<| a |>\nFor my own learning purposes I wanted to implement this in a more\
    \ Ruby way than the other posts. I didn't want to create a class or extend a String\
    \ class so here is my solution (I know it's long and repetitive but it is very\
    \ simple)\n<code>", "  hex.countHexDigits(num)\nend", '    num.scan(/(^([0-9A-F])([0-9A-F])([0-9A-F])$|^([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])',
  "  prime_counter = 1\n  while prime_counter < 10 do\n    if num.match?(/[A-F]\\\
    d/) then\n      break\n    end\n    prime_counter = prime_counter + 1\n  end\n\
    \  if prime_counter == 10 then\n    return 1\n  end\n  if num.length == prime_counter\
    \ then\n    return 1\n  end\n  return 2\nend\n</cell>\n<cell>", "    total = 0\n\
    \    digits = num.to_s.split(\"\")\n    \n    digits.each do |digit|\n       \
    \ prime = true\n        2.upto(digit.length) do |n|\n            if digit.chars.to_set.subset?((\"\
    0\"..\"9\").to_set).include?(digit[n])\n                prime = false\n      \
    \          break\n            end\n        end\n        if prime == true\n   \
    \         total += 1\n        end\n    end\n    return total\nend\n</cell>\n<cell>",
  "    num.scan(/^([A-F])(\\d+)$/)\n    digit = num.captures.captures.to_i\n    if\
    \ digit > 15\n        digit = 16\n    end\n    if digit < 2\n        digit = 2\n\
    \    end\n    if digit == 0\n        return 0\n    end\n    \n    num.scan(/^([A-F])(\\\
    d+)$/)\n    hexa_decimal = num.captures.captures.to_i\n    if hexa_decimal > 15\n\
    \        hexa_decimal = 16\n    end\n    if hexa_decimal < 2\n        hexa_decimal\
    \ = 2\n    end\n    \n    hexa_decimal -= 16\n    \n    if hexa_decimal <= 2\n\
    \        hexa_decimal += 2\n    end\n    \n    prime_number = 0\n    \n    for\
    \ digit in 2..hexa_decimal - 1\n        prime_number += 1\n        \n        if\
    \ hexa_decimal % digit == 0\n            break\n        end\n    end\n    \n \
    \   return prime_number\nend", "\tkey.call(\"0123456789ABCDEF\", num)\nend", " \
    \   hex_digits = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\"\
    , \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"]\n    sum_digit_list = []\n\
    \    \n    # Calculate the sum of digits in the number\n    for index in range(0,\
    \ len(num)):\n        sum_digit_list.append(int(num[index], 16))\n    \n    #\
    \ Calculate the prime numbers in the list\n    for index in range(0, len(sum_digit_list)):\n\
    \        if sum_digit_list[index] >= 11:\n            sum_digit_list[index] =\
    \ 0\n            break\n    \n    for index in range(1, len(sum_digit_list)):\n\
    \        if sum_digit_list[index] % sum_digit_list[index - 1] == 0 and sum_digit_list[index\
    \ - 1] != 0:\n            sum_digit_list[index] = 0\n            break", "   \
    \ if num.length == 0\n        return \"\"\n    if num.length == 1\n        letter\
    \ = num.upcase\n        if letter in (\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"\
    )\n            return 1\n        return 0\n    sum = 0\n    factor = 2\n    idx\
    \ = 0\n    while idx < num.length\n        idx = idx + 1\n        letter = num[idx]\n\
    \        if letter in(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\")\n            sum\
    \ = sum + factor\n            factor = 1\n        elif letter in(\"0\",\"1\")\n\
    \            factor = factor * 2\n        elsif letter in(\"2\")\n           \
    \ factor = factor * 3\n        elsif letter in(\"3\")\n            factor = factor\
    \ * 5\n        elsif letter in(\"4\")\n            factor = factor * 7\n     \
    \   elsif letter in(\"5\")\n            factor = factor * 11\n        elsif letter\
    \ in(\"6\")\n            factor = factor * 13\n        elsif letter in(\"7\")\n\
    \            factor = factor * 17\n        elsif letter in(\"8\")\n          \
    \  factor = factor * 19\n        elsif letter in(\"9\")\n            factor =\
    \ factor * 31\n        elsif letter in(\"A\")\n            factor = factor * 41\n\
    \        elsif letter in(\"B\")\n            factor = factor * 61\n        elsif\
    \ letter in(\"C\")\n            factor = factor * 71\n        elsif letter in(\"\
    D\")\n            factor = factor * 91\n        elsif letter in(\"E\")\n     \
    \       factor = factor * 101\n        elsif letter in(\"F\")\n            factor\
    \ = factor * 107\n        end\n    end\n    return sum\nend", "  n = num.length\n\
    \  \n  digits = (\"123456789ABCDEF0\").split(\"\")\n  \n  count = 0\n  \n  for\
    \ i in 0...n\n    \n    if digits[i] == \"0\" or digits[i] == \"1\" or digits[i]\
    \ == \"2\" \n       or digits[i] == \"3\" or digits[i] == \"4\" \n       or digits[i]\
    \ == \"5\" or digits[i] == \"6\" \n       or digits[i] == \"7\" or digits[i] ==\
    \ \"8\" \n       or digits[i] == \"9\"\n       \n      count += 1 if digits[i]\
    \ == \"B\" or digits[i] == \"D\" \n    end\n    \n    if count >= 2\n      return\
    \ count\n    end\n    \n    count = 0\n  end\n  \n  return 0\nend\n</cell>\n<code\
    \ language=julia-1.5>\nhex_key(\"1077E\")\n</cell>\n<code language=julia-1.5>",
  "    primes = []\n    prime_digits = []\n    prime_digits = [2,3,5,7,11,13,17]",
  "  return num.to_s.length if num.to_s.length < 12 else num.to_s.length - 12\nend",
  "    key.call(num)\nend", "  return num.length if num.length != 0 else hex_key(num.split(\"\
    \")[0]).length + \n    hex_key(num.split(\"\")[1]).length if num.split(\"\")[1].to_s.length\
    \ != 0\n  return num.split(\"\").length if num.length != 0 else \n    hex_key(num.split(\"\
    \")[0]).length + hex_key(num.split(\"\")[1]).length if \n    hex_key(num.split(\"\
    \")[0]).length != 0\n  return num.split(\"\").length if num.length != 0\n  return\
    \ 1\nend", "    num = num.split(\"\")\n    len_num = len(num)", "  hex_digits\
    \ = num.to_s(16).split(//).to_a\n  hex_digits.reverse.each_with_index do |digit,\
    \ i|\n    primes = (2..9).to_a + (0..2).to_a\n    digit = digit.to_i\n    primes.each\
    \ { |p| prime_check(p, digit, hex_digits[i]) }\n  end\n  hex_digits.reverse.count\
    \ { |i| i }\nend", "  str.split(num, \"\").count { |i| i.to_i(16).odd? }\nend",
  '  return num.count("A") + num.count("B") + num.count("C") + num.count("D") + num.count("E")
    + num.count("F")', "  n = num.size\n  \n  hex.each do |hex|\n    next if hex.size\
    \ == 0 || hex.upcase != hex\n    \n    digits = hex.to_i(16)\n    \n    if n %\
    \ 4 == 0\n      digit = digits[0, 3]\n      \n      next if digit == 2 and digits[1,\
    \ 3] == 1\n      \n      n -= hex.length\n      \n      hex.slice!\n      \n \
    \     digits -= digits[0, 3]\n      \n      hex << digit\n    end\n    \n    hex.slice!\n\
    \    \n    digits -= digits[0, 3]\n    \n    if digits == 0\n      hex << digits[1,\
    \ 3]\n      \n      hex.slice!\n      \n      hex.slice!\n    end\n  end\n  \n\
    \  n\nend\n</code>\n<|/ a tags=ruby,hex,loops dscore=0 |>\n<| c |>\nThanks for\
    \ your answer, but the question is to count the number of hexadecimal digits that\
    \ are primes _from 00 to FF_ and from _00 to 0F_. I think there is a misunderstanding\
    \ about the meaning of \"prime\".\n<|/ c |>\n<| c |>\nOh, yes, you're right, sorry.\
    \ I was focusing on what you've written. I'll think about it a little more. I'll\
    \ try to come up with an answer.\n<|/ c |>\n<| c |>\nI edited my answer, see if\
    \ this is what you want.\n<|/ c |>\n<| c |>\nThanks, this is really great! I only\
    \ have one question: how does hex.each do its work without passing a block into\
    \ it? Is this the same as saying hex.each {|hex| ... }?\n<|/ c |>\n<| c |>\n`each`\
    \ doesn't have a block passed in, it's just that `each` itself is a method on\
    \ `Array` class and that method has a block passed in. See this: https://stackoverflow.com/questions/1196501/what-is-the-difference-between-map-and-each-in-ruby\
    \ for the difference between `map` and `each`.\n<|/ c |>\n<| a |>\nHow about this?\n\
    <code>\nhex = hex_key(\"00112233445566778899AABBCCDDEEFF\")\nhex_digits = hex.map(&:to_i)",
  "  num_str = (num.to_s.split('A..F')[0].to_i(16)).to_s\n  num_str.gsub!(/A...?/,'0')\n\
    \  num_str.gsub!(/B...?/,'1')\n  num_str.gsub!(/C...?/,'2')\n  num_str.gsub!(/D...?/,'3')\n\
    \  num_str.gsub!(/E...?/,'4')\n  num_str.gsub!(/F...?/,'5')\n  num_str.gsub!(/0..?/,'0')\n\
    \  num_str.gsub!(/1...?/,'1')\n  num_str.gsub!(/2...?/,'2')\n  num_str.gsub!(/3...?/,'3')\n\
    \  num_str.gsub!(/4...?/,'4')\n  num_str.gsub!(/5...?/,'5')\n  num_str.gsub!(/7...?/,'7')\n\
    \  num_str.gsub!(/9...?/,'9')\n  num_str.gsub!(/0..?/,'0')\n  num_str.gsub!(/1...?/,'1')\n\
    \  num_str.gsub!(/2...?/,'2')\n  num_str.gsub!(/3...?/,'3')\n  num_str.gsub!(/4...?/,'4')\n\
    \  num_str.gsub!(/5...?/,'5')\n  num_str.gsub!(/7...?/,'7')\n  num_str.gsub!(/9...?/,'9')\n\
    \  num_str.gsub!(/A...?/,'0')\n  num_str.gsub!(/B...?/,'1')\n  num_str.gsub!(/C...?/,'2')\n\
    \  num_str.gsub!(/D...?/,'3')\n  num_str.gsub!(/E...?/,'4')\n  num_str.gsub!(/F...?/,'5')\n\
    \  num_str.gsub!(/0..?/,'0')\n  num_str.gsub!(/1...?/,'1')\n  num_str.gsub!(/2...?/,'2')\n\
    \  num_str.gsub!(/3...?/,'3')\n  num_str.gsub!(/4...?/,'4')\n  num_str.gsub!(/5...?/,'5')\n\
    \  num_str.gsub!(/7...?/,'7')\n  num_str.gsub", "    hex = num.scan(/([A-Z0-9])/)\n\
    \    hex.each do |x|\n        if x.include?('F')\n            digits_count = x.count.to_i\n\
    \            hex.each do |y|\n                if y.include?('C')\n           \
    \         digits_count += y.count.to_i\n                    hex.each do |z|\n\
    \                        if z.include?('B')\n                            digits_count\
    \ += z.count.to_i\n                            hex.each do |a|\n             \
    \                   if a.include?('D')\n                                    digits_count\
    \ += a.count.to_i\n                                    hex.each do |b|\n     \
    \                                   if b.include?('E')\n                     \
    \                       digits_count += b.count.to_i\n                       \
    \                     hex.each do |c|\n                                      \
    \          if c.include?('F')\n                                              \
    \      digits_count += c.count.to_i\n                                        \
    \            return digits_count\n                                           \
    \     end\n                                            end\n                 \
    \                       end\n                                    end\n       \
    \                         end\n                            end\n             \
    \           end\n                    end\n                end\n            end\n\
    \        end\n    end\nend", "  str_num = num.to_s.split(\"\").map do |i| \n \
    \   i.to_i\n  end\n  str_num.each do |i|\n    str_num.each do |j|\n      return\
    \ i + j if i % j == 0\n    end\n  end\n  return -1\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nI guess I didn't really understand what exactly the function was\
    \ supposed to do. Thought it was pretty obvious. Nevertheless, your answer was\
    \ very helpful for me to understand the function and for my future work. Thanks!\n\
    <|/ c |>\n<| c |>\nYou're welcome :-) Yeah, it is pretty obvious, but it took\
    \ me a while to figure out what exactly it was supposed to do (because I am not\
    \ a pro). So it's great to hear it helped you, and don't forget to mark the question\
    \ as answered.\n<|/ c |>\n<| c |>\nI have upvoted your answer. However, I have\
    \ been trying to understand it for the past few days and I just don't get it.\
    \ Could you explain what each line of your code is doing? And perhaps include\
    \ some explanations as to how it works?\n<|/ c |>\n<| c |>\nYou have to figure\
    \ out what each line of your code is doing. I guess the easiest way is to start\
    \ a blank piece of paper, and step through each line. Do you understand the `return`\
    \ keyword? What does it do? When does it return something? In which cases will\
    \ it return something? Do you understand the `if` statement? When and how does\
    \ it execute? What does it do? Do you understand the `each` method? What does\
    \ it do? When and how does it execute? What does it do? Do you understand what\
    \ a `map` method does?\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  n = num.length\n\
    \  digits = 0\n  digits_set = false\n  \n  while n > 0\n    if num[n] >= 48 &&\
    \ num[n] <= 57\n      digits += 1\n      digits_set = true\n      n -= 1\n   \
    \ elsif num[n] >= 65 && num[n] <= 70\n      digits += 1\n      digits_set = true\n\
    \      n -= 1\n    elsif num[n] >= 97 && num[n] <= 102\n      digits += 1\n  \
    \    digits_set = true\n      n -= 1\n    elsif num[n] >= 55 && num[n] <= 57\n\
    \      digits += 1\n      digits_set = true\n      n -= 1\n    end\n  end\n  \n\
    \  if digits == 0\n    if num.length == 0 || num.length == 1\n      digits = 1\n\
    \    else\n      return 0\n    end\n  end\n  \n  if digits_set\n    digits\n \
    \ else\n    return 0\n  end\nend", "  n = num.count(\"A\") + num.count(\"B\")\
    \ + num.count(\"C\") + num.count(\"D\") + num.count(\"E\") + num.count(\"F\")\n\
    \  if num.empty?\n    n\n  else\n    if n > 19\n      n = 19\n    elsif n <= 2\n\
    \      n\n    elsif n % 2 == 1\n      n\n    else\n      n = n*3\n      n.upto(19)\
    \ do |i|\n        if num.slice(i..i).to_s.split(\"A\").count == 1\n          n\n\
    \        end\n      end\n    end\n  end\nend", "  # your code here\n  hex_digits\
    \ = \"0123456789ABCDEF\"\n  prime = 0\n  for i in range(0, int(num), 2)\n    if\
    \ num[i] in hex_digits and num[i+1] in hex_digits:\n      prime+=1\n  return prime\n\
    </cell>\n<text>\nExercise 2: Defining primes upto a given number\nWrite a function\
    \ that receives two positive integers, N and K, and returns the number of primes\
    \ up to N.\nThe function should return 0 if N is less than 1.\nThe function should\
    \ return 1 if N is greater than or equal to 1 and K is equal to 2.\nThe function\
    \ should return N if K is greater than or equal to 2 and N is not greater than\
    \ or equal to 3.\nNote: Primes can be listed in any order.\nExamples:\n>>> primes.call(10,\
    \ 2)\n3\n>>> primes.call(10, 3)\n2\n>>> primes.call(10, 4)\n1\n>>> primes.call(10,\
    \ 5)\n0\n>>> primes.call(11, 2)\n5\n>>> primes.call(11, 3)\n1\n>>> primes.call(11,\
    \ 4)\n1\n>>> primes.call(11, 5)\n0\n>>> primes.call(12, 2)\n0\n>>> primes.call(12,\
    \ 3)\n0\n>>> primes.call(12, 4)\n0\n>>> primes.call(12, 5)\n0\n>>> primes.call(13,\
    \ 2)\n4\n>>> primes.call(13, 3)\n3\n>>> primes.call(13, 4)\n3\n>>> primes.call(13,\
    \ 5)\n1\n>>> primes.call(14, 2)\n4\n>>> primes.call(14, 3)\n3\n>>> primes.call(14,\
    \ 4)\n3\n>>> primes.call(14, 5)\n0\n>>> primes.call(15, 2)\n4\n>>> primes.call(15,\
    \ 3)\n3\n>>> primes.call(15, 4)\n3\n>>> primes.call(15, 5)\n0\n>>> primes.call(16,\
    \ 2)\n5\n>>> primes.call(16, 3)\n3\n>>> primes.call(16, 4)\n3\n>>> primes.call(16,\
    \ 5)\n0\n>>> primes.call(17, 2)\n5\n>>> primes.call(17, 3)\n3\n>>> primes.call(17,\
    \ 4)\n3\n>>> primes.call(17, 5)\n0\n>>> primes.call(18, 2)\n5\n>>> primes.call(18,\
    \ 3)\n3\n>>> primes.call(18, 4)\n3\n>>> primes.call(18, 5)\n0\n>>> primes.call(19,\
    \ 2)\n5\n>>> primes.call(19, 3)\n3\n>>> primes.call(19, 4)\n3\n>>> primes.call(19,\
    \ 5)\n0\n>>> primes.call(20, 2)\n5\n>>> prime", "  number_key = \"\"\n  for i\
    \ in num\n  number_key = number_key + i\n  if number_key.to_i(16).to_s(16).size\
    \ <= 3\n  number_key = number_key.to_i(16).to_s(16).size\n  end\n  return number_key.to_i(16).to_s(16).count(\"\
    2\")+number_key.to_i(16).to_s(16).count(\"3\")+number_key.to_i(16).to_s(16).count(\"\
    5\")+number_key.to_i(16).to_s(16).count(\"7\")\nend", "  sum = 0\n  num_list =\
    \ (num.to_s.split('').map{|x| x.to_i})\n  num_list.reverse!\n  num_list.each do\
    \ |x|\n    sum += (x%11) + ((x%13)? 2 : 0)\n  end\n  return sum\nend", "    count\
    \ = 0\n    length = num.length\n    \n    # Convert number to string and remove\
    \ leading zeros.\n    num = num.downcase\n    num = num.gsub(/0+/, \"\")\n   \
    \ num = num.gsub(/0+$/, \"\")\n    \n    # Count all hexadecimal digits.\n   \
    \ i = 0\n    while i < length\n        hex = num[i]\n        if hex.to_i == 0\n\
    \            hex = \"0\"\n        if hex.to_i % 2 == 0\n            count += 1\n\
    \        i += 1\n    return count\nend", "  result = 0\n  for i in (num.to_i(16)).to_s(16).split(\"\
    \")\n    result += (2 ** (4*(hex_key.digits[(i.to_i(16)).to_s(16).to_i(16)-1].to_i(16)))).to_i\n\
    \  return result\nend\nhex_key.digits = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]",
  "  num = num.to_s\n  num = num.upcase.to_s\n  sum = 0\n  for i in range(1,(hex_key.digits.length)-1)\n\
    \    sum = sum + (hex_key.digits[i].to_s.hex==num[i])\n  return sum\nend\nhex_key.digits\
    \ = [1,2,3,4,5,6,7,8,9,A,B,C,D,E,F]", "  return num_digits(num, 0) * 2\nend",
  "  hex_digits = num.to_s.split(//)\n  \n  hex_digits_str = hex_digits.map{|n| n.to_s(16).upcase}",
  "  # Write your code here\n  return\nend", "\tstr.split(num)\n\tnum = num.upcase\n\
    \tnum = num.insert(2,0)\n\tnum = num.insert(5,0)\n\tnum = num.insert(7,0)\n\t\
    num = num.insert(11,0)\n\tnum = num.insert(13,0)\n\tnum = num.insert(17,0)\n\t\
    num = num.insert(19,0)\n\tnum = num.insert(23,0)\n\tnum = num.insert(29,0)\n\t\
    num = num.insert(37,0)\n\tnum = num.insert(43,0)\n\tnum = num.insert(49,0)\n\t\
    num = num.insert(55,0)\n\tnum = num.insert(61,0)\n\tnum = num.insert(67,0)\n\t\
    num = num.insert(73,0)\n\tnum = num.insert(79,0)\n\tnum = num.insert(85,0)\n\t\
    num = num.insert(91,0)\n\tnum = num.insert(97,0)\n\tnum = num.insert(103,0)\n\t\
    num = num.insert(109,0)\n\tnum = num.insert(115,0)\n\tnum = num.insert(121,0)\n\
    \tnum = num.insert(127,0)\n\tnum = num.insert(133,0)\n\tnum = num.insert(139,0)\n\
    \tnum = num.insert(145,0)\n\tnum = num.insert(151,0)\n\tnum = num.insert(157,0)\n\
    \tnum = num.insert(163,0)\n\tnum = num.insert(169,0)\n\tnum = num.insert(175,0)\n\
    \tnum = num.insert(181,0)\n\tnum = num.insert(187,0)\n\tnum = num.insert(193,0)\n\
    \tnum = num.insert(199,0)\n\tnum = num.insert(205,0)\n\tnum = num.insert(211,0)\n\
    \tnum = num.insert(217,0)\n\tnum = num.insert(223,0)\n\tnum = num.insert(229,0)\n\
    \tnum = num.insert(235,0)\n\tnum = num.insert(241,0)\n\tnum = num.insert(247,0)\n\
    \tnum = num.insert(253,0)\n\tnum = num.insert(259,0)\n\tnum = num.insert(265,0)\n\
    \tnum = num.insert(271,0)\n\tnum = num.insert(277,0)\n\tnum = num.insert(283,0)\n\
    \tnum = num.insert(289,0)\n\tnum = num.insert(295,0)\n\tnum = num.insert(301,0)\n\
    \tnum = num.insert(307,0)\n\tnum = num.insert(313,0)\n\tnum = num.insert(317,",
  "  num_list = num.split(\"\")\n  num_list.remove('A') # Remove 'A' from the list.\n\
    \  num_list.remove('B') # Remove 'B' from the list.\n  num_list.remove('C') #\
    \ Remove 'C' from the list.\n  num_list.remove('D') # Remove 'D' from the list.\n\
    \  num_list.remove('E') # Remove 'E' from the list.\n  num_list.remove('F') #\
    \ Remove 'F' from the list.\n  num_list.remove('0') # Remove '0' from the list.\n\
    \  num_list.remove('1') # Remove '1' from the list.\n  num_list.remove('2') #\
    \ Remove '2' from the list.\n  num_list.remove('3') # Remove '3' from the list.\n\
    \  num_list.remove('4') # Remove '4' from the list.\n  num_list.remove('5') #\
    \ Remove '5' from the list.\n  num_list.remove('6') # Remove '6' from the list.\n\
    \  num_list.remove('7') # Remove '7' from the list.\n  num_list.remove('8') #\
    \ Remove '8' from the list.\n  num_list.remove('9') # Remove '9' from the list.\n\
    \  num_list.remove('A') # Remove 'A' from the list.\n  num_list.remove('B') #\
    \ Remove 'B' from the list.\n  num_list.remove('C') # Remove 'C' from the list.\n\
    \  num_list.remove('D') # Remove 'D' from the list.\n  num_list.remove('E') #\
    \ Remove 'E' from the list.\n  num_list.remove('F') # Remove 'F' from the list.\n\
    \  num_list.remove('0') # Remove '0' from the list.\n  num_list.remove('1') #\
    \ Remove '1' from the list.\n  num_list.remove('2') # Remove '2' from the list.\n\
    \  num_list.remove('3') # Remove '3' from the list.\n  num_list.remove('4') #\
    \ Remove '4' from the list.\n  num_list.remove('5') # Remove '5' from the list.\n\
    \  num_list.remove('6') # Remove '6' from the list.\n  num_list.remove('7') #\
    \ Remove '7' from the list.\n  num_list.remove('8') # Remove '8' from the list.\n\
    \  num_list.remove('9') # Remove '9' from the list.\n  num_list.each do |digit|\n\
    \    # Check if the digit is a hexadecimal digit.\n    if digit.to_i.to_s == digit.to_s\n\
    \      # Check if the digit is a prime number.\n      if digit_is_prime?(digit.to_i)\n\
    \        answer = digit.to_i\n        break\n      end\n    end\n  end\n  answer\n\
    end", "  num = num.downcase\n  if num.length == 2\n    hex_key = (num.match(/[a-fA-F\\\
    d]/) ? 1 : 0)\n  else\n    hex_key = (num.match(/[a-fA-F\\d]/) ? 2 : (num.match(/[\\\
    d]\\d/) ? 3 : 4))\n  end\n  return hex_key\nend\n</code>\nThe above is a simple\
    \ version that does not check for prime numbers, only the number of digits. If\
    \ you need to check whether it is a prime number, then you have to consider some\
    \ special cases. I leave you the problem of checking whether it is a prime number.\n\
    <|/ a dscore=0 |>\n<| a tags=algorithm,ruby |>\nAnother answer:\n<code>", "  count=0\n\
    \  num.downcase!\n  for i in 0...num.length\n    if ((num[i]==\"a\") || (num[i]==\"\
    b\") || (num[i]==\"c\") || (num[i]==\"d\") || (num[i]==\"e\") || (num[i]==\"f\"\
    )) && (num[i+1].to_i==num[i+1].to_i)\n      count+=1\n    end\n  end\n  return\
    \ count\nend", "  n = num.length\n  num.upcase!\n  count = 0\n  (0..n).each do\
    \ |i|\n    if i%2 == 0\n      count = count + 1\n      break\n    end\n    if\
    \ num.slice(i).upcase == 'A' || num.slice(i).upcase == 'B'\n      count = count\
    \ + 1\n      break\n    end\n    if num.slice(i).upcase == 'C' || num.slice(i).upcase\
    \ == 'D'\n      count = count + 1\n      break\n    end\n    if num.slice(i).upcase\
    \ == 'E' || num.slice(i).upcase == 'F'\n      count = count + 1\n      break\n\
    \    end\n  end\n  count\nend", "  num = num.upcase\n  num = num.to_s.gsub(/[^0-9a-fA-F]/,'')\n\
    \  num = num.to_i\n  num = num.to_s(2)\n  num = num.to_i(16)\n  count = 0\n  i\
    \ = 2\n  while i <= num\n    count = count + 1\n    if i**2 == num\n      break\n\
    \    i += 1\n  return(count)\nend", "  hex_key = num.each_char.with_index.with_object([])\
    \ do |char, arr|\n    arr.push(arr.empty? ? 0 : arr.last.to_i * 16 + char.to_i(16))\n\
    \  end.select { |n| n <= (Math.sqrt(num.to_i) + 1).to_i }\n  hex_key && hex_key.length\
    \ && hex_key.count { |n| hex_key.count(n) == 1 }\nend", "    primes = []\n   \
    \ digits = []\n    rest = []\n    \n    # Separate string into digits and rest\n\
    \    for n in num.to_s.split(//)\n        digits.push n[0]\n        rest.push\
    \ n[1..-1]\n    end\n    \n    # Count number of digits that are primes\n    digits\
    \ = digits.join().split(//)\n    digits.each do |n|\n        primes.push 3\n \
    \       \n        # Skip each digit after checking that it is divisible by 2\n\
    \        rest.each do |r|\n            if n % r == 0\n                primes.push\
    \ 5\n                break\n            end\n        end\n    end\n    \n    #\
    \ Return sum of primes\n    primes.inject(:+)\nend\n</cell>\n<cell>", "  hex_digits\
    \ = \"0123456789ABCDEF\"\n  count = 1 \n  while num !~ /#{hex_digits}/ \n    num\
    \ = num[1..-1]\n    count += 1\n  end\n  hex_digits = hex_digits.reverse \n  hex_digits[0..(count-1)]\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI don't think this works, at least not\
    \ with the example `ABED1A33`.  You would get wrong results for `ABED1A33` when\
    \ looking for `AEDB113` because the character `E` would be the prime character\
    \ for that number.\n<|/ c |>\n<| c |>\nThis is an example where the prime algorithm\
    \ does not work. I will add an explanation to the answer.\n<|/ c |>\n<| c |>\n\
    I understand that part of `A -> B, B -> C, C -> D, D -> E`.  What I don't understand\
    \ is how you get that same `AEDB113` example to give the correct result of 4 with\
    \ the `AEDB113` input.\n<|/ c |>\n<| c |>\nYes, you are right. My mistake. I corrected\
    \ the algorithm. Thank you for pointing it out.\n<|/ c |>\n<| c |>\nNow your algorithm\
    \ doesn't give the correct answer; it returns 6 instead of 4 on the example `AEDB113`.\n\
    <|/ c |>\n<| a tags=ruby,primes |>\nThe simplest way to check if a number is a\
    \ prime is to use Euler's test (the number 2 must be a factor of every number\
    \ up to n).  This can be done in constant time by only checking up to square root\
    \ of the number.\n<code>", "  # Your code here\n  result = 0\n  while num.length\
    \ > 0\n    digit = num.slice!(0, 1).toupper()\n    num = num.slice!(1)\n    if\
    \ digit == 'A' or digit == 'B' or digit == 'C' or digit == 'D' or digit == 'E'\
    \ or digit == 'F'\n      result += 1\n    end\n  end\n  result \nend\n</code>\n\
    <|/ q dscore=1 |>\n<| c |>\n`def prime_count(hex_string)`\n<|/ c |>\n<| c |>\n\
    Sorry, I've edited the question because I made a mistake\n<|/ c |>\n<| c |>\n\
    Are you allowed to use a library such as [prime](https://github.com/sirbose/prime)?\
    \ It has a lot of nice methods to help you with this, e.g. [prime_check](https://rubygems.org/gems/prime/versions/1.0.0/#prime_check).\n\
    <|/ c |>\n<| c |>\nYes, it must use that library\n<|/ c |>\n<| c |>\nIt's not\
    \ really clear whether you intend to use prime numbers or hexadecimal digits.\
    \ If you want to count the prime numbers, a prime number is a natural number greater\
    \ than 1 that is not a product of two smaller natural numbers. If you just want\
    \ to count the digits of a hexadecimal number, you can do that with `str.length`\n\
    <|/ c |>\n<| a |>\nHere's a solution that uses recursion and a prime number library.\n\
    <code>\nrequire \"prime\"", "  num, num = num.to_s.downcase, num.to_s.gsub(/[A-E]/,\
    \ \"\")\n  num = num.to_i(16)\n  num = (num - 1) if num > 0 else 0\n  \n  # count\
    \ digits\n  count = 0\n  while num > 0\n    count += 1\n    num /= 10\n  \n  #\
    \ print primes\n  puts count if (count % 2 != 0 or count == 6)\nend", "  # Solution\
    \ using only base 10 arithmetic and modulo operator\n  digits = num.split(\"\"\
    )\n  primes = []\n  prime = 2 # prime starts at 2\n  while prime <= 65535\n  \
    \  if num[prime] == digits[prime]\n      primes.push(prime)\n      prime += 1\n\
    \    else\n      prime = num.index(digits[prime], prime)\n  end\n  return primes.length\n\
    end", "  # Implement me!\nend\n</code></pre>\n<p>Implement the function <code>hex_key</code>\
    \ above.</p>\n<h2>Exercise</h2>\n<p>Let's try a few more numbers:</p>\n<ul>\n\
    <li>1077E</li>\n<li>ABED1A33</li>\n<li>123456789ABCDEF0</li>\n<li>2020</li>\n\
    </ul>\n<p>Write the function <code>hex_key</code> below so that it returns the\
    \ correct answer.</p>\n<pre><code class=\"lang-erlang\"># You have been tasked\
    \ to write a function that receives ", "  key = false\n  if num.size > 0\n   \
    \ if num.chars.all? { |x| x.upcase >= \"A\" && x.upcase <= \"F\" }\n      num\
    \ = num.upcase\n    else\n      num = num.downcase\n    end\n    if num.to_s.length\
    \ >= 1\n      num = num.to_s.each_char.map { |x| x.to_i.to_s }.join(\",\")\n \
    \     num = num.split(\",\")\n      num = num.map do |a|\n        if a.to_s.length\
    \ >= 1\n          a = a.to_s.each_char.map { |x| x.to_i.to_s }.join(\",\")\n \
    \         a = a.split(\",\")\n          a.map do |b|\n            if b.to_s.length\
    \ >= 1\n              b = b.to_s.each_char.map { |x| x.to_i.to_s }.join(\",\"\
    )\n              b = b.split(\",\")\n              b.map do |c|\n            \
    \    if c.to_s.length >= 1\n                  c = c.to_s.each_char.map { |x| x.to_i.to_s\
    \ }.join(\",\")\n                  c = c.split(\",\")\n                  c.map\
    \ do |d|\n                    if d.to_s.length >= 1\n                      d =\
    \ d.to_s.each_char.map { |x| x.to_i.to_s }.join(\",\")\n                     \
    \ d = d.split(\",\")\n                      d.map do |e|\n                   \
    \     if e.to_s.length >= 1\n                          e = e.to_s.each_char.map\
    \ { |x| x.to_i.to_s }.join(\",\")\n                          e = e.split(\",\"\
    )\n                          e.map do |f|\n                            if f.to_s.length\
    \ >= 1\n                              f = f.to_s.each_char.map { |x| x.to_i.to_s\
    \ }.join(\",\")\n                              f = f.split(\",\")\n          \
    \                    f.map do |g|\n                                if g.to_s.length\
    \ >= 1\n                                  g = g.to_s.each_char.map { |x| x.to_i.to_s\
    \ }.join(\",\")\n                                  g = g.split(\",\")\n      \
    \                            g.map do |h|\n                                  \
    \  if h.to_s.length >= 1\n                                      h = h.to_s.each_char.map\
    \ { |x| x.to_i.to_s }.join(\",\")\n                                      h = h.split(\"\
    ,\")\n                                      h.map do |i|\n                   \
    \                     if(i.to_s.length >= 1)\n                               \
    \           i = i.to_s.each_char.map { |x| x.to_i.to_s }.join(\",\")\n       \
    \                                   i = i.split(\",\")\n                     \
    \                     i.map do |j|\n                                         \
    \   if j.to_s.length >= 1\n                                              j = j.to_s.each_char.map\
    \ { |x| x.to_i.to_s }.join(\",\")\n                                          \
    \    j = ", "  \n  # Your code here\n  hex_string = num.to_s.upcase\n  prime_count\
    \ = hex_string.count('F')\n  if prime_count == 0\n    prime_count = hex_string.count('A')\n\
    \  hex_string.slice!(1..prime_count)\n  hex_digits = hex_string.each_char.map\
    \ {|x| x.hex}\n  hex_digits.each do |x|\n    if x % 2 == 0\n      hex_string.slice!(x..2)\n\
    \    end\n  end\n  return hex_string.count('F')\nend\n</cell>\n<cell>", "    return\
    \ hex_decode(num).count(\"B\")\n</cell>\n<text>\nP.S. - If you wish to see more\
    \ examples of hexadecimal prime number counting, please check out these websites:",
  "  # num - \"ABED1A33\" - example\n  digit_number = num.count(\"A\") + num.count(\"\
    B\") + num.count(\"C\") + num.count(\"D\") + num.count(\"E\") + num.count(\"F\"\
    )\n  if digit_number % 2 != 0 or digit_number < 11:\n    return digit_number\n\
    \  else:\n    digit_number2 = num.count(\"A\") + num.count(\"B\") + num.count(\"\
    C\") + num.count(\"D\") + num.count(\"E\") + num.count(\"F\")\n    if digit_number2\
    \ % 2 != 0:\n      return digit_number2\n    else:\n      digit_number3 = num.count(\"\
    A\") + num.count(\"B\") + num.count(\"C\") + num.count(\"D\") + num.count(\"E\"\
    ) + num.count(\"F\")\n      if digit_number3 % 2 != 0 or digit_number3 < 13:\n\
    \        return digit_number3\n      else:\n        digit_number4 = num.count(\"\
    A\") + num.count(\"B\") + num.count(\"C\") + num.count(\"D\") + num.count(\"E\"\
    ) + num.count(\"F\")\n        if digit_number4 % 2 != 0 or digit_number4 < 17:\n\
    \          return digit_number4\n        else:\n          digit_number5 = num.count(\"\
    A\") + num.count(\"B\") + num.count(\"C\") + num.count(\"D\") + num.count(\"E\"\
    ) + num.count(\"F\")\n          if digit_number5 % 2 != 0 or digit_number5 < 19:\n\
    \            return digit_number5\n          else:\n            digit_number6\
    \ = num.count(\"A\") + num.count(\"B\") + num.count(\"C\") + num.count(\"D\")\
    \ + num.count(\"E\") + num.count(\"F\")\n            if digit_number6 % 2 != 0\
    \ or digit_number6 < 21:\n              return digit_number6\n            else:\n\
    \              digit_number7 = num.count(\"A\") + num.count(\"B\") + num.count(\"\
    C\") + num.count(\"D\") + num.count(\"E\") + num.count(\"F\")\n              if\
    \ digit_number7 % 2 != 0 or digit_number7 < 23:\n                return digit_number7\n\
    \              else:\n                digit_number8 = num.count(\"A\") + num.count(\"\
    B\") + num.count(\"C\") + num.count(\"D\") + num.count(\"E\") + ", "  digits =\
    \ num.to_s.split(\"\").map { |c| c.to_i(16) }\n  result = digits.length\n  if\
    \ digits.length == 0\n    return 0\n  else\n    digits.each do |num|\n      prime\
    \ = 2 # 2 does not count.\n      prime_digits = 0\n      loop do\n        prime_digits\
    \ += 1\n        if num % prime == 0\n          break\n        end\n        prime\
    \ += 1\n      end\n      result -= prime_digits\n    end\n  end\n  return result\n\
    end\n</code>\nEDIT: I added the loop part to the code\n<|/ a dscore=1 |>\n<| a\
    \ tags=ruby,ruby-on-rails,hex |>\n<code>", "    str = num\n    prime = 0\n   \
    \ str_len = len(str)\n    hex_list = [0]*16\n    hex_list[0] = 0\n    hex_list[1]\
    \ = 0\n    hex_list[2] = 0\n    hex_list[3] = 0\n    hex_list[4] = 0\n    hex_list[5]\
    \ = 0\n    hex_list[6] = 0\n    hex_list[7] = 0\n    hex_list[8]  = 0\n    hex_list[9]\
    \  = 0\n    hex_list[10]  = 0\n    hex_list[11] = 0\n    hex_list[12] = 0\n  \
    \  hex_list[13] = 0\n    hex_list[14] = 0\n    hex_list[15] = 0\n    \n    hex_digits\
    \ = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"\
    A\", \"B\", \"C\", \"D\", \"E\", \"F\"]\n    \n    while str != \"\":\n      \
    \  str = str[-2:]\n        str_len = len(str)\n        \n        if str == \"\"\
    : \n            break\n        \n        if str[0] in hex_digits:\n          \
    \  hex_list[hex_digits.index(str[0])] += 1\n        \n        str = str[1:]\n\
    \        \n        for index in range(1, 16):\n            hex_digit_val = hex_list[index]\n\
    \            if index > str_len: \n                break\n            \n     \
    \       if hex_digit_val <= 1:\n                break\n            \n        \
    \    prime_check = (hex_digit_val == (str_len + index))\n            \n      \
    \      if prime_check:\n                prime = 1\n                break\n   \
    \ \n    return prime", "  number_to_count = 0\n  \n  digit_count = num.length\n\
    \  \n  while digit_count > 0\n    digit_count = digit_count - 1\n    \n    if\
    \ num.chars[digit_count] == A\n      number_to_count += 1\n    \n    if num.chars[digit_count]\
    \ == B\n      number_to_count += 1\n    \n    if num.chars[digit_count] == C\n\
    \      number_to_count += 1\n    \n    if num.chars[digit_count] == D\n      number_to_count\
    \ += 1\n    \n    if num.chars[digit_count] == E\n      number_to_count += 1\n\
    \    \n    if num.chars[digit_count] == F\n      number_to_count += 1\n  \n  return\
    \ number_to_count\n  ", "  if num =~ /^[a-fA-F0-9]+$/\n    num = num.upcase\n\
    \    count = 2\n    hex = num.to_s.reverse\n    while hex.length <= 3\n      if\
    \ hex =~ /^[a-fA-F0-9]{2}$/\n        hex = hex.upcase\n      else\n        hex\
    \ = hex.upcase\n      end\n      if hex =~ /^[a-fA-F0-9]{2}$/\n        hex = hex.upcase\n\
    \      else\n        break\n      end\n    end\n    hex = hex.scan(/../).join(\"\
    \").reverse\n    hex.to_i\n  end\nend\n</code>\nThe program above does the following\
    \ steps:", "    # your code goes here\n    num.upcase!\n    digits=[]\n    letters=[\"\
    A\",\"B\",\"C\",\"D\",\"E\",\"F\"]\n    i=3\n    while i>=1\n        i=i/2\n \
    \       digits[i]=0\n    end\n    digits[2]=1\n    letters.each do |char|\n  \
    \      if num.include?(char)\n            digits[num.index(char)]+=1\n       \
    \ end\n    end\n    digits.each do |digit|\n        next if digit==0\n       \
    \ i=2\n        while i<digit\n            i=i*2\n        end\n        if digit==i\n\
    \            return digit\n        end\n    end\n    return -1\nend", "  num =\
    \ num.chomp\n  return 0 if num.empty? or num.length % 2 is 0 \n  return 0 if (num.length\
    \ % 8) is 0\n  a = num.chars.to_a\n  for i in 0...num.length / 2\n    b = [a[i],\
    \ a[i + 1], a[i + 2], a[i + 3], a[i + 4], a[i + 5]]\n    if b.all? {|x| x.is_a?\
    \ Integer}\n      break\n    end\n  end\n  return b.count{|x| x > 1}\nend\n</cell>\n\
    <cell>", "    hex_keys = num.split(//)\n    hex_keys.each do |x|\n        if x\
    \ == x.hex\n            if x.hex.to_i(16) == x.hex.to_i(16).to_i\n           \
    \     if x > 1\n                    if x % 2 == 1\n                        if\
    \ x % 3 == 0\n                            if x % 5 == 0\n                    \
    \            if x % 7 == 0\n                                    if x % 11 == 0\n\
    \                                        if x % 13 == 0\n                    \
    \                        puts x.hex.to_i(16)\n                               \
    \         end\n                                    end\n                     \
    \           end\n                            end\n                        end\n\
    \                    end\n                end\n            end\n        end\n\
    \    end\nend\n</code>\n<|/ q dscore=0 |>\n<| c |>\nWhat is your question? What\
    \ are you having trouble with?\n<|/ c |>\n<| c |>\nWhy are you testing `x % 7\
    \ == 0` twice for `x = 2`?\n<|/ c |>\n<| c |>\nYou seem to be looking for [this](http://stackoverflow.com/questions/3720893/how-can-i-determine-if-a-number-is-a-prime-number).\n\
    <|/ c |>\n<| c |>\nI'm having trouble with trying to determine a number of the\
    \ following digits: 2, 3, 5, 7, B (=decimal 11), D (=decimal 13). Can you please\
    \ help me with this? I'm new to Ruby and I don't understand why I'm having the\
    \ problem. Thanks!\n<|/ c |>\n<| c |>\nThanks for pointing that out. I fixed it.\n\
    <|/ c |>\n<| a tags=ruby |>\nYou need to determine prime numbers first, and then\
    \ determine those numbers you are looking for:\n<code>", "  num = num.upcase #\
    \ Convert to uppercase.\n  prime_count = 0\n  prime_count = Primes(num)\n  prime_count\
    \ = Primes(num)\n  puts \"Primes count: \" + prime_count\nend", "    sum = 0\n\
    \    for i in num\n        if i % 16 == 0 or i == \"A\" \n            sum += 2\n\
    \        else if i % 8 == 0 \n            sum += 3\n        else if i % 4 == 0\
    \ \n            sum += 5\n        else if i % 2 == 0 \n            sum += 7\n\
    \        elsif i % 1 == 0 \n            sum += 11\n        elsif i == \"B\"\n\
    \            sum += 11\n        elsif i == \"D\"\n            sum += 13\n    \
    \    else\n            sum += 0\n    end\n    return sum\nend\n</cell>\n<code\
    \ language=julia-1.6>", "  hex_digits = \"0123456789ABCDEF\"\n  count = 1\n  while\
    \ count <= 16 do\n    if num =~ /^#{hex_digits}#{count}/ then\n      return count\n\
    \    end\n    count += 1\n  end\n  puts \"Unrecognized input: #{num}\"\n  exit\n\
    end\n</cell>\n<cell>", "  num = num.to_s.upcase\n  return 0 unless num.match(/^0x[0-9A-F]+$/i)\n\
    \  hex = num.slice(0,2)\n  dec = num.to_i(2)\n  return 2 if hex == '00' \n   \
    \ elsif hex == '01'\n      3\n    elsif hex == '02'\n      4\n    elsif hex ==\
    \ '03'\n      5\n    elsif hex == '04'\n      6\n    elsif hex == '05'\n     \
    \ 7\n    elsif hex == '06'\n      8\n    elsif hex == '07'\n      9\n    elsif\
    \ hex == '08'\n      10\n    elsif hex == '09'\n      11\n    elsif hex == '10'\n\
    \      12\n    elsif hex == '11'\n      13\n    elsif hex == '12'\n      14\n\
    \    elsif hex == '13'\n      15\n    elsif hex == '14'\n      16\n    elsif hex\
    \ == '15'\n      17\n    elsif hex == '16'\n      18\n    elsif hex == '17'\n\
    \      19\n    elsif hex == '18'\n      20\n    elsif hex == '19'\n      21\n\
    \    elsif hex == '20'\n      22\n    elsif hex == '21'\n      23\n    elsif hex\
    \ == '22'\n      24\n    elsif hex == '23'\n      25\n    elsif hex == '24'\n\
    \      26\n    elsif hex == '25'\n      27\n    elsif hex == '26'\n      28\n\
    \    elsif hex == '27'\n      29\n    elsif hex == '28'\n      30\n    elsif hex\
    \ == '29'\n      31\n    elsif hex == '30'\n      32\n    elsif hex == '31'\n\
    \      33\n    elsif hex == '32'\n      34\n    elsif hex == '33'\n      35\n\
    \    elsif hex == '34'\n      36\n    elsif hex == '35'\n      37\n    elsif hex\
    \ == '36'\n      38\n    elsif hex == '37'\n      39\n    elsif hex == '38'\n\
    \      40\n    elsif hex == '39'\n      ", "  n = num.to_s(16)\n  ln = n.length\n\
    \  primes = 0\n  \n  if ln == 0 then\n    return 0\n  \n  if ln == 1 then\n  \
    \  if n % 16 == 1 then\n      primes = 1\n    end\n    return primes\n  end\n\
    \  \n  if ln == 2 then\n    if n % 16 == 2 then\n      primes = 1\n    end\n \
    \   return primes\n  end\n  \n  if ln == 3 then\n    if n % 16 == 3 then\n   \
    \   primes = 1\n    end\n    return primes\n  end\n  \n  if ln == 4 then\n   \
    \ if n % 16 == 4 then\n      primes = 1\n    end\n    return primes\n  end\n \
    \ \n  if ln == 5 then\n    if n % 16 == 5 then\n      primes = 1\n    end\n  \
    \  return primes\n  end\n  \n  if ln == 6 then\n    if n % 16 == 6 then\n    \
    \  primes = 1\n    end\n    return primes\n  end\n  \n  if ln == 7 then\n    if\
    \ n % 16 == 7 then\n      primes = 1\n    end\n    return primes\n  end\n  \n\
    \  if ln == 8 then\n    if n % 16 == 8 then\n      primes = 1\n    end\n    return\
    \ primes\n  end\n  \n  if ln == 9 then\n    if n % 16 == 9 then\n      primes\
    \ = 1\n    end\n    return primes\n  end\n  \n  if ln == 10 then\n    if n % 16\
    \ == 10 then\n      primes = 1\n    end\n    return primes\n  end\n  \n  if ln\
    \ == 11 then\n    if n % 16 == 11 then\n      primes = 1\n    end\n    return\
    \ primes\n  end\n  \n  if ln == 12 then\n    if n % 16 == 12 then\n      primes\
    \ = 1\n    end\n    return primes\n  end\n  \n  if ln == 13 then\n    if n % 16\
    \ == 13 then\n      primes = 1\n    end\n    return primes\n  end\n  \n  if ln\
    \ == 14 then\n    if n % 16 == 14 then\n      primes = 1\n    end\n    return\
    \ primes\n  end\n  \n  if ln == 15 then\n    if n % 16 == 15 then\n      primes\
    \ = 1\n    end\n    return primes\n  end\n  \n  puts \"Error! Given input has\
    \ a length greater than 14.\" \nend", "  num.upcase!\n  return hex_digits(num.scan(/^[0-9A-F]+$/)).count{|n|\
    \ \n    primes(n.to_i(16).to_s).length <= 2 \n  }\nend", "  num_to_hex = num.to_s.split(\"\
    \")\n  num_to_hex.map!{|digit| digit.to_i}\n  num_to_hex.map!{|digit| 0 if digit\
    \ == 10 || digit == 13 || digit == 17 || digit == 19 }\n  num_to_hex.map!{|digit|\
    \ digit if digit.is_a?(Fixnum) && digit.is_a?(Fixnum) && digit != 13 && digit\
    \ != 17 && digit != 19 && digit != 3 && digit != 7 && digit != 11 }\n  num_to_hex.map!{|digit|\
    \ 0 if digit == 16 || digit == 18 }\n  num_to_hex.map!{|digit| digit if digit.is_a?(Fixnum)\
    \ && digit.is_a?(Fixnum) && digit != 16 && digit != 18 }\n  num_to_hex.map!{|digit|\
    \ digit.to_i}\n  num_to_hex.map!{|digit| 0 if digit == 2 || digit == 3 || digit\
    \ == 5 || digit == 7 || digit == 11 || digit == 13 || digit == 17 }\n  num_to_hex.map!{|digit|\
    \ digit if digit.is_a?(Fixnum) && digit.is_a?(Fixnum) && digit != 13 && digit\
    \ != 17 }\n  num_to_hex.map!{|digit| 0 if digit == 4 || digit == 6 || digit ==\
    \ 8 || digit == 10 || digit == 12 || digit == 14 || digit == 16 || digit == 18\
    \ }\n  num_to_hex.map!{|digit| digit if digit.is_a?(Fixnum) && digit.is_a?(Fixnum)\
    \ && digit != 14 && digit != 16 && digit != 18 }\n  num_to_hex.map!{|digit| digit.to_i}\n\
    \  num_to_hex.map!{|digit| 0 if digit == 10 || digit == 13 || digit == 17 }\n\
    \  num_to_hex.map!{|digit| digit if digit.is_a?(Fixnum) && digit.is_a?(Fixnum)\
    \ && digit != 13 && digit != 17 }\n  num_to_hex.map!{|digit| digit.to_i}\n  num_to_hex.map!{|digit|\
    \ 0 if digit == 19 || digit == 3 || digit == 7 || digit == 11 }\n  num_to_hex.map!{|digit|\
    \ digit if digit.is_a?(Fixnum) && digit.is_a?(Fixnum) && digit != 3 && digit !=\
    \ 7 && ", "  return 0 unless num\n  \n  primes = [2,3,5,7,11,13,17,19]\n  digits\
    \ = num.to_s[0..num.length-1]\n  primes.each {|d| return 0 unless digits.count(d.to_i)}\n\
    \  digits.length\nend", "    digits = num.split(//)\n    return 0 if digits ==\
    \ [] else digits.count(digits[3], digits[5], digits[7], digits[11], digits[13])\
    \ #digits\n    #return 0 if num == \"\" else digits[3], digits[5], digits[7],\
    \ digits[11], digits[13]\n    ", "  num = num.upcase if num.is_a?(String) else\
    \ num.to_s\n  return num_digits(num).inject(0) do |acc, d|\n    prime_digits =\
    \ prime_digits(d)\n    prime_digits.reduce(acc) do |primes, p|\n      primes <<\
    \ p if primes.include?(p)\n    end\n  end\nend", "  digits = num.to_s.split(\"\
    \")\n  hex_count = digits.length\n  i = 0\n  while i < hex_count\n    hex_string\
    \ = digits[i].to_s\n    if hex_string.length == 2 && hex_string.to_i % 2 == 0\
    \ && hex_string.upcase != hex_string.downcase\n      i += 1\n    else \n     \
    \ break\n  end\n  return hex_count-i\nend\n</cell>\n<code language=conda-env-Anaconda3-py>",
  '    return countHex(num)', "  num = num.upcase\n  count = num.size / 2\n  hex_decimal_array\
    \ = [ 'A', 'B', 'C', 'D', 'E', 'F' ]\n  for i in (2..count)\n    if hex_decimal_array[i.to_s]\n\
    \      return num.to_i\n    end\n  end\nend", "  return 1 if num.length == 0 else\
    \ num.chars.select {|c| c.upcase >= 'A' && c.upcase <= 'F' || c.upcase >= '0'\
    \ && c.upcase <= '9'}.count {|c| c.to_i.odd?}\nend", "  if num.nil? \n    puts\
    \ \"invalid input.\"\n  elsif !num.respond_to?(:empty?) \n    puts \"invalid input.\"\
    \n  elsif num.empty?\n    puts \"invalid input.\"\n  else\n    num = num.to_i\n\
    \    hex = num.hex\n    puts hex.length\n    puts hex.count(hex.first(2).to_i)\n\
    \    puts hex.count(hex.first(3).to_i)\n    puts hex.count(hex.first(4).to_i)\n\
    \    puts hex.count(hex.first(5).to_i)\n    puts hex.count(hex.first(6).to_i)\n\
    \    puts hex.count(hex.first(7).to_i)\n    puts hex.count(hex.first(8).to_i)\n\
    \    puts hex.count(hex.first(9).to_i)\n    puts hex.count(hex.first(10).to_i)\n\
    \    puts hex.count(hex.first(11).to_i)\n    puts hex.count(hex.first(12).to_i)\n\
    \    puts hex.count(hex.first(13).to_i)\n    puts hex.count(hex.first(14).to_i)\n\
    \    puts hex.count(hex.first(15).to_i)\n    puts hex.count(hex.first(16).to_i)\n\
    \    puts hex.count(hex.first(17).to_i)\n    puts hex.count(hex.first(18).to_i)\n\
    \    puts hex.count(hex.first(19).to_i)\n    puts hex.count(hex.first(20).to_i)\n\
    \    puts hex.count(hex.first(21).to_i)\n    puts hex.count(hex.first(22).to_i)\n\
    \    puts hex.count(hex.first(23).to_i)\n    puts hex.count(hex.first(24).to_i)\n\
    \    puts hex.count(hex.first(25).to_i)\n    puts hex.count(hex.first(26).to_i)\n\
    \    puts hex.count(hex.first(27).to_i)\n    puts hex.count(hex.first(28).to_i)\n\
    \    puts hex.count(hex.first(29).to_i)\n    puts hex.count(hex.first(30).to_i)\n\
    \    puts hex.count(", "    num = num.to_s.upcase\n    \n    count = 0\n    \n\
    \    while num.length > 0\n        \n        hexadecimal = num.chars.first\n \
    \       if hexadecimal.length == 0\n            break\n        \n        hex_digit\
    \ = hexadecimal.to_i(16)\n        \n        hexadecimal = num.chars.drop(1).first\n\
    \        if hexadecimal.length == 0\n            break\n        \n        hex_digit2\
    \ = hexadecimal.to_i(16)\n        \n        if hex_digit == hex_digit2\n     \
    \       count += 1\n        else\n            break\n    \n        num = num.chars.drop(2).first\n\
    \    end\n    \n    return count\nend\n</code>\n<|/ a tags=ruby,count,hex,loops\
    \ |>\n<| c |>\nThank you so much! The code worked perfectly! I really appreciate\
    \ it!\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  \n  # If the string length is less\
    \ than one character long, or if the first \n  # character is other than hexadecimal\
    \ digit, the return value is 0.\n  if num.length < 2 || num.first(0) !~ /^[a-f0-9]$/\n\
    \    0\n  \n  # The first character of the string should be a hexadecimal digit.\n\
    \  else\n    # Calculate the decimal value of the first hexadecimal digit.\n \
    \   hex_digit_1 = num.first(2).to_i(16)\n  \n    # The decimal value of the second\
    \ hexadecimal digit must be even. \n    unless hex_digit_1 % 2 == 0\n      raise\
    \ RuntimeError, \"A hexadecimal number has odd decimal digits: #{num}.\"\n   \
    \ \n    # The value of the next hexadecimal digit must be even. \n    unless hex_digit_2\
    \ % 2 == 0\n      raise RuntimeError, \"A hexadecimal number has odd decimal digits:\
    \ #{num}.\"\n    end\n    \n    # If the decimal value of the next hexadecimal\
    \ digit divides \n    # two numbers that are both odd, it means that it is a prime\
    \ number.\n    if hex_digit_2.to_i(16) % 2 == 1\n      # Calculate a hexadecimal\
    \ number that equals to the string concatenation.\n      hex_digit_3 = num.first(3).to_i(16)\
    \ + num.first(4).to_i(16)\n    \n      # Calculate a hexadecimal number that equals\
    \ to the string concatenation.\n      hex_digit_4 = num.first(5).to_i(16) + num.first(6).to_i(16)\n\
    \    \n      # Calculate the hexadecimal number of the concatenation.\n      hex_digit_5\
    \ = hex_digit_3 + hex_digit_4\n    \n      # Calculate the hexadecimal number\
    \ of the concatenation.\n      hex_digit_6 = hex_digit_5 + num.first(7).to_i(16)\n\
    \    \n      # Calculate the hexadecimal number of the concatenation.\n      hex_digit_7\
    \ = hex_digit_6 + num.first(8).to_i(16)\n    \n      # Calculate the hexadecimal\
    \ number of the concatenation.\n      hex_digit_8 = hex_digit_7 + num.first(9).to_i(16)\n\
    \    \n      # Calculate the hexadecimal number of the concatenation.\n      hex_digit_9\
    \ = hex_digit_8 + num.first(10).to_i(16)\n    \n      # Calculate the hexadecimal\
    \ number of the concatenation.\n      hex_digit_10 = hex_digit_9 + num.first(11).to_i(16)\n\
    \    \n      # Calculate the hexadecimal number of the concatenation.\n      hex_digit_11\
    \ = hex_digit_10 + num.first(12).to_i(16)\n    \n      # Calculate the hexadecimal\
    \ number of the concatenation.\n      hex_digit_12 = hex_digit_11 + num.", " \
    \ num = num.to_s\n  prime_chars = (\"2\", \"3\", \"5\", \"7\", \"11\", \"13\"\
    , \"17\", \"19\", \"31\", \"37\", \"41\", \"43\", \"47\", \"53\", \"59\", \"61\"\
    , \"67\", \"71\")\n  prime_chars.each do |prime_char|\n    count = 0\n    num\
    \ = num.split(prime_char).join\n    num.split('').each do |letter|\n      letter\
    \ = letter.to_i\n      if letter > 48 && letter < 58\n        if letter % 16 ==\
    \ 0\n          count = count + 1\n        end\n      end\n    end\n    if count\
    \ < 2\n      return prime_char.to_i\n    end\n  end\n  nil\nend", "  num_str =\
    \ num.to_s.upcase\n  num_str.gsub!(/[^0ABCDEFABCDEF]/, \"0\")\n  num_str.gsub!(/[^01234567]/,\
    \ \"1\")\n  num_str.gsub!(/[^01234567AB]/, \"2\")\n  num_str.gsub!(/[^01234567ABED1A33]/,\
    \ \"3\")\n  num_str.gsub!(/[^01234567ABED1A33F]/, \"4\")\n  num_str.gsub!(/[^01234567ABED1A33FED2]/,\
    \ \"5\")\n  num_str.gsub!(/[^01234567ABED1A33FED2C]/, \"6\")\n  num_str.gsub!(/[^01234567ABED1A33FED2CED1]/,\
    \ \"7\")\n  num_str.gsub!(/[^01234567ABED1A33FED2CED1C]/, \"8\")\n  num_str.gsub!(/[^01234567ABED1A33FED2CED1CED1]/,\
    \ \"9\")\n  num_str.gsub!(/[^01234567ABED1A33FED2CED1CED1F]/, \"A\")\n  num_str.gsub!(/[^01234567ABED1A33FED2CED1CED1FF]/,\
    \ \"B\")\n  num_str.gsub!(/[^01234567ABED1A33FED2CED1CED1FAB]/, \"C\")\n  num_str.gsub!(/[^01234567ABED1A33FED2CED1CED1FABC]/,\
    \ \"D\")\n  num_str.gsub!(/[^01234567ABED1A33FED2CED1CED1FABCDE]/, \"E\")\n  num_str.gsub!(/[^01234567ABED1A33FED2CED1CED1FABCDEF]/,\
    \ \"F\")\n  num_str.gsub!(/[^01234567ABED1A33FED2CED1CED1FABCDEFG]/, \"G\")\n\
    \  num_str.gsub!(/[^01234567ABED1A33FED2CED1CED1FABCDEFGH]/, \"H\")\n  num_str.gsub!(/[^01234567ABED1A33FED2CED1CED1FABCDEFGHI]/,\
    \ \"I\")\n  num_str.gsub!(/[^01234567ABED1A33FED2CED1CED1FABCDEFGHIJ]/, \"J\"\
    )\n  num_", "  prime_chars = string.chars(16).select { |c| (c>='0') && (c<='9')\
    \ }\n  prime_chars.each do |c|\n    if num.to_i.to_s(c) == num.to_s\n      puts\
    \ c\n    end\n  end\nend", "  hex = num.to_s.split(\"\").map(&:hex).join('')\n\
    \  hex_digits = (0..9).to_a\n  hex_digits.select{ |d| hex.include?(d) }.count\n\
    end", "    count = 0\n    prime_digits = ['2', '3', '5', '7', 'B', 'D']\n    #\
    \ Convert string num to integer and call recursively\n    count = hex_key(to_int(num))\n\
    \    # If the string has only one digit, return it\n    if count == 1:\n     \
    \   return count\n    # If the string has more then one digit, calculate how many\
    \ \n    # digits are primes\n    if count == 2:\n        for i in range(0, len(prime_digits)):\n\
    \            prime_num = to_int(num) % 11\n            if prime_num == 0:\n  \
    \              count += 1\n                return count\n    # If the string has\
    \ more than 2 digits and contains prime digits, \n    # return it\n    if count\
    \ > 2:\n        for i in range(0, len(prime_digits)):\n            prime_num =\
    \ to_int(num) % 11\n            if prime_num == 0:\n                count += 1\n\
    \                return count\n    # If the string has more than 2 digits and\
    \ doesnt contain any prime \n    # digits, count the hexadecimal digits that are\
    \ divisible by primes\n    for i in range(0, len(prime_digits)):\n        prime_num\
    \ = to_int(num) % 11\n        if prime_num == 0:\n            count += 1\n   \
    \ return count", "    if num == nil or num == \"\" then \n        return nil \n\
    \    end\n    return prime_check(num, hex_key.primes, hex_key.composites)\nend",
  "  num.to_s.split(\"\").each_with_index do |char, i|\n    primes = Primes[char.to_i]\n\
    \    return primes[i - 1] if primes.any?\n  end\n  return nil\nend", "  num =\
    \ num.to_s\n  hex = num.to_i(16).to_s(16) # hexadecimal conversion\n  count =\
    \ []\n  # A prime number, or prime is a natural number greater than 1 that \n\
    \  # is not a product of two smaller natural numbers.\n  i = 2\n  while hex.length\
    \ < (hex.length / i) && hex.length < (hex.length + (hex.length / i).to_f) do\n\
    \    count << hex.length\n    i += 1 \n  end\n  count.shift\n  count.shift\n \
    \ count = 0\n  for i in count\n    count += hex.index(i).to_i\n  end\n  count.reduce(:+)\n\
    end", "  digits = num.to_s.split('')\n  prime = 0\n  prime_digits = []\n  prime_digits.push(digits.length)\n\
    \  for i in 0...digits.length\n    next_prime_digits = []\n    \n    prime_digits.push(digits.length)\n\
    \    next_prime_digits.push(digits.length)\n    \n    # find how many digits are\
    \ in a prime number\n    prime_digits.push(digits.length)\n    next_prime_digits.push(digits.length)\n\
    \    \n    # find how many digits are in a prime number\n    prime_digits.push(digits.length)\n\
    \    next_prime_digits.push(digits.length)\n    \n    # find how many digits are\
    \ in a prime number\n    prime_digits.push(digits.length)\n    next_prime_digits.push(digits.length)\n\
    \    \n    # find how many digits are in a prime number\n    prime_digits.push(digits.length)\n\
    \    next_prime_digits.push(digits.length)\n    \n    # find how many digits are\
    \ in a prime number\n    prime_digits.push(digits.length)\n    next_prime_digits.push(digits.length)\n\
    \    \n    # find how many digits are in a prime number\n    prime_digits.push(digits.length)\n\
    \    next_prime_digits.push(digits.length)\n    \n    next_prime_digits.push(digits.length)\n\
    \    \n    # find how many digits are in a prime number\n    prime_digits.push(digits.length)\n\
    \    next_prime_digits.push(digits.length)\n    \n    # find how many digits are\
    \ in a prime number\n    prime_digits.push(digits.length)\n    next_prime_digits.push(digits.length)\n\
    \    \n    prime_digits.push(digits.length)\n    next_prime_digits.push(digits.length)\n\
    \    \n    prime_digits.push(digits.length)\n    next_prime_digits.push(digits.length)\n\
    \    \n    prime_digits.push(digits.length)\n    next_prime_digits.push(digits.length)\n\
    \    \n    prime_digits.push(digits.length)\n    next_prime_digits.push(digits.length)\n\
    \    \n    prime_digits.push(digits.length)\n    next_prime_digits.push(digits.length)\n\
    \    \n    prime_digits.push(digits.length)\n    next_prime_digits.push(digits.length)\n\
    \    \n    prime_digits.push(digits.length)\n    next_prime_digits.push(digits.length)\n\
    \    \n    prime_digits.push(digits.length)\n    next_prime_digits.push(digits.length)\n\
    \    \n    prime_digits.push(digits.length)\n    next_prime_digits.push(digits.length)\n\
    \    \n    prime_digits.push(digit", "  num = num.upcase \n  return 0 if (num.length\
    \ == 0) || (num.match(/^[A-Fa-f0-9]+$/) == nil)\n  hex_num = 0\n  digits = num.split(\"\
    \")\n  num_digits = digits.length\n  for digit in digits\n    hex_num += 1\n \
    \   hex_num %= 16\n    if digit.to_i(2)  % 2 == 0 \n      break\n  end\n  if num_digits\
    \ == 0\n    hex_num\n  else\n    hex_num * 16 - num_digits\n  end\nend\n</code>\n\
    <|/ a tags=ruby dscore=0 |>\n<| a dscore=0 |>\nI believe that the following code\
    \ works. \n<code>", "  \n  if num == \"\"\n    return 0\n  \n  key_digits = num.to_s.split(\"\
    \")\n  key_digits.map! { |d| d.to_i(16).to_s(16) }", "\tnum = num.upcase\n\treturn\
    \ hex_key.dig(hex_key.dig(num,3,17), hex_key.dig(hex_key.dig(num,1,9),3,17), hex_key.dig(hex_key.dig(num,1,9),1,17))\n\
    end", "  prime_num = num.chars.each_with_index.reduce(0){ |sum, (i, index)| \n\
    \    # Iterate over the digits in string and find if it's a prime number\n   \
    \ return i if (i.to_i(16).to_s == num && prime_digit?(i).to_i)\n  }\n  return\
    \ prime_num\nend", "  hex_list = num.split(\"\")\n  prime_count = 0\n  prime_list\
    \ = []\n  for i in hex_list\n    if i.upcase == \"A\" or i.upcase == \"B\" or\
    \ i.upcase == \"C\" or i.upcase == \"D\" or i.upcase == \"E\" or i.upcase == \"\
    F\"\n      if prime_list.include?(i)\n        prime_count += 1\n      else\n \
    \       prime_list.push(i)\n    end\n  end\n  return prime_count\nend", "  return\
    \ nil unless num\n  num.split('').reverse.map { |c| c.to_i(16) }.count { |x| x\
    \ == 2 || x == 3 || x == 5 || x == 7 || x == 11 ||\n    x ==13 || x == 17 || x\
    \ == 19 || x == 23}\nend\n</code>\n<|/ q tags=ruby |>\n<| c |>\nYour code does\
    \ not seem to pass any tests, at least for the examples you provide (all return\
    \ 1). You also don't seem to have a \"primality test\", which is not entirely\
    \ necessary for finding the number of valid prime numbers in a string. Are you\
    \ looking for help with that or just looking for a general solution that will\
    \ work with any string?\n<|/ c |>\n<| c |>\ni think its better to have a general\
    \ solution to count the primes. But if i would have the primality test i could\
    \ do it with my own way.\n<|/ c |>\n<| c |>\nI edited my answer to make it more\
    \ general, as requested, but I'm still not sure it is what you are looking for.\
    \ Does it return any output and how?\n<|/ c |>\n<| c |>\nit return 1 if the input\
    \ is \"AB\", and 2 if the input is \"1077E\". And it should not return anything\
    \ if the input is \"ABED1A33\" or \"123456789ABCDEF0\"\n<|/ c |>\n<| c |>\nOk,\
    \ now I see. Are you looking for a solution to this particular problem? Or are\
    \ you looking for a general solution for finding prime numbers in a string? That\
    \ is unclear in your question.\n<|/ c |>\n<| a |>\nHere's a slightly different\
    \ solution:\n<code>", "  num = num.call if num.is_a?(Proc)? num.call(\"\") : num\n\
    \  num.downcase!\n  num.split(\"\").each_with_index do |char, index|\n    next\
    \ if char.in?(\"123456789ABCDEF\")\n    next if char == \"0\"\n    next if char\
    \ == \"A\"\n    next if char == \"B\"\n    next if char == \"C\"\n    next if\
    \ char == \"D\"\n    next if char == \"E\"\n    next if char == \"F\"\n    next\
    \ if index == 0\n    num = index\n  end\n  return num\nend", '    return sum(
    [ ( 1 if d%x==0 and not ( d%x==x ) ) else 0 for x in [2,3,5,7,11,13,17,19] ] )',
  "  hex = Integer(num)\n  hex_digits = hex.to_s.split(\"\")\n  primes = 0\n  hex_digits.each\
    \ do |hex_digit|\n    hex_digit = hex_digit.upcase\n    hex_digit = hex_digit.to_i(16)\n\
    \    primes += 1 if hex_digit == 11 || hex_digit == 13\n  end\n  hex_digits <<\
    \ primes\n  hex_digits.join(\"\")\nend\n</cell>\n<cell>", "  num = num.upcase\n\
    \  hex_values = (0..255).to_a\n  prime_number = 2\n  prime_digit_index = 0\n \
    \ prime_digit_count = 0", "  num.upcase!\n  primes = [2]\n  primes.concat(2..(num.length/2)).each\
    \ do |num|\n    if num.digits.product(primes).all?{|a| a.zero?}\n      primes.push(num)\n\
    \    end\n  end\n  primes\nend\n</code>\nThe other possibility is to have 2 iterators,\
    \ the first one increments 1 by 1 and the second increments by 2 each time, and\
    \ you increment both of them until you find a prime number that works, like so:\n\
    <code>", "  num.upcase!\n  num.chars.each do |digit|\n    # I tried to create\
    \ a list containing the possible values of the digit \n    # and check against\
    \ the digits in it\n    # But that wouldn't work since I need to compare the number\
    \ and the list\n    # and that would require me to convert the list to a string.\n\
    \    # So I had to take this approach\n    digit.upcase!\n    possible_digits\
    \ = (0..9).to_a\n    digit_str = digit.to_s\n    possible_digits.each do |possible_digit|\n\
    \      possible_digit_str = possible_digit.to_s\n      digit_str.upcase!\n   \
    \   digit_str.gsub!(possible_digit_str, '').gsub!(possible_digit, '')\n      break\
    \ if digit_str.length == 0\n    end\n    # I couldn't find a better way to compare\
    \ the list with the number\n    # than by comparing the number of digits to the\
    \ digits' length\n    break if digit_str.length == digit.length\n  end\n  return\
    \ digit.length\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n`num.upcase!` seems\
    \ unnecessary here.\n<|/ c |>\n<| c |>\n: It was there for debugging. :-)\n<|/\
    \ c |>\n<| c |>\nI meant you removed it, not that it was unnecessary.\n<|/ c |>\n\
    <| a tags=ruby |>\nI took you guys' suggestions and created this little gem of\
    \ mine. Maybe it will help someone out someday!\n<code>\nrequire 'set'\nrequire\
    \ 'prime'\nrequire 'prime/factorization'", '  prime_digits = []', "  num.length.times\
    \ do |i|\n    next if num[i].upcase != \"A\" && num[i].upcase != \"B\" && num[i].upcase\
    \ != \"C\" && num[i].upcase != \"D\" && num[i].upcase != \"E\" && num[i].upcase\
    \ != \"F\"\n    next if num[i].downcase == \"0\"\n    next if num[i].downcase\
    \ == \"1\"\n    next if num[i].downcase == \"2\"\n    next if num[i].downcase\
    \ == \"3\"\n    next if num[i].downcase == \"4\"\n    next if num[i].downcase\
    \ == \"5\"\n    next if num[i].downcase == \"6\"\n    next if num[i].downcase\
    \ == \"7\"\n    next if num[i].downcase == \"8\"\n    next if num[i].downcase\
    \ == \"9\"\n    next if num[i].downcase == \"A\" || num[i].downcase == \"B\" ||\
    \ num[i].downcase == \"C\" || num[i].downcase == \"D\" || num[i].downcase == \"\
    E\" || num[i].downcase == \"F\"\n    next if num[i].downcase == \"P\"\n    next\
    \ if num[i].downcase == \"Q\"\n    next if num[i].downcase == \"R\"\n    next\
    \ if num[i].downcase == \"S\"\n    next if num[i].downcase == \"T\"\n    next\
    \ if num[i].downcase == \"U\"\n    next if num[i].downcase == \"V\"\n    next\
    \ if num[i].downcase == \"W\"\n    next if num[i].downcase == \"X\"\n    next\
    \ if num[i].downcase == \"Y\"\n    next if num[i].downcase == \"Z\"\n    next\
    \ if num[i].downcase == \"0\"\n    next if num[i].downcase == \"1\"\n    next\
    \ if num[i].downcase == \"2\"\n    next if num[i].downcase == \"3\"\n    next\
    \ if num[i].downcase == \"4\"\n    next if num[i].downcase == \"5\"\n    next\
    \ if num[i].downcase == \"6\"\n    next if num[i].downcase == \"7\"\n    next\
    \ if num[i].downcase == \"8\"\n    next if num[i].downcase == \"9\"\n    next\
    \ if num[i].downcase == \"A\"\n    next if num[i].downcase == \"B\"\n    next\
    \ if num[i].downcase == \"C\"\n    next if num[i].downcase == \"D\"\n    next\
    \ if num[i].downcase == \"E\"\n    next if num[i].downcase == \"F\"\n    next\
    \ if num[i].downcase == \"P\"\n    next if ", "  count = 2\n  n = num.to_s.split(\"\
    \")\n  n.map! { |i| i.to_i(16) }\n  n.each do |i|\n    while i > 0\n      count\
    \ += 1 if i.to_s(2) != i.to_s(2).reverse\n      i >>= 1\n    end\n  end\n  count\n\
    end", "  num = num.chars.to_a\n  count = 0\n  digits = []\n  while num.length\
    \ != 0\n    count += 1\n    next if num.first == '0'\n    next if num.last.downcase\
    \ != \"A\"\n    next if num.last.downcase != \"B\"\n    next if num.last.downcase\
    \ != \"C\"\n    next if num.last.downcase != \"D\"\n    next if num.last.downcase\
    \ != \"E\"\n    next if num.last.downcase != \"F\"\n    digits.push(num.first)\n\
    \    num = num[1..-1]\n  end\n  prime = digits.each_cons(2).detect { |x, y| hex_key(x).even?\
    \ }.length\n  prime\nend", "    num = num.to_s\n    num = num.upcase\n    hex\
    \ = num.to_i(16)\n    count = 0\n    hex.times do |i|\n      if hex % i == 0\n\
    \        count += 1\n      end\n    end\n    count\nend\n</cell>\n<cell>", " \
    \ key_count = 0\n  n = num.to_i(16)\n  if n == 0\n    0\n  elsif n != 0\n    key_count\
    \ = n\n    n = n / 4\n    while n > 0\n      key_count += n\n      n = n / 16\n\
    \    end\n  end\n  return key_count\nend", "  return num.count(\"A\") + num.count(\"\
    B\") + num.count(\"C\") + num.count(\"D\") + num.count(\"E\") + num.count(\"F\"\
    )\nend", "    key = num.count(\"A\") + 1\n    key += num.count(\"B\") + 1\n  \
    \  key += num.count(\"C\") + 1\n    key += num.count(\"D\") + 1\n    key += num.count(\"\
    E\") + 1\n    key += num.count(\"F\") + 1\n    key = key * 3\n    return key",
  "    num.count(\"A\") + num.count(\"B\") + num.count(\"C\") + num.count(\"D\") +\
    \ num.count(\"E\") + num.count(\"F\")\nend", "  num_chars = num.to_s.length\n\
    \  if num_chars == 0\n    return 0\n  num_digits = num.to_s.length.to_i\n  num_hex_digits\
    \ = num_digits / 2\n  num_prime = 1\n  num_product = 1\n  num_prime_multiplier\
    \ = 2\n  num_product_multiplier = 2\n  num_prime_product = 1\n  num_product_product\
    \ = 1\n  while num_hex_digits > 0\n    num_product = num_product * num_product_multiplier\n\
    \    num_prime = num_prime * num_prime_multiplier\n    num_product *= num_product_multiplier\n\
    \    num_prime *= num_prime_multiplier\n    num_product = num_product.to_i\n \
    \   num_prime = num_prime.to_i\n    if num_product == num_prime\n      num_prime_product\
    \ *= num_product\n      num_product_product *= num_product\n    else\n      num_prime_product\
    \ += num_product * num_product\n      num_product_product += num_product * num_product\n\
    \      num_prime_product *= num_product\n      num_product_product *= num_product\n\
    \    end\n    prime_checker(num_prime)\n    product_checker(num_product)\n   \
    \ num_hex_digits -= 1\n  end\n  if num_prime_product == num_product_product \n\
    \    return num_prime_product \n  else\n    return num_product_product\n  end\n\
    end", "    count=0\n    length=len(num)\n    temp=num\n    temp=temp.upper()\n\
    \    for i in (0...length-1)\n        if temp[i]==\"A\"\n            count+=1\n\
    \        end\n        if temp[i]==\"B\"\n            count+=1\n        end\n \
    \       if temp[i]==\"C\"\n            count+=1\n        end\n        if temp[i]==\"\
    D\"\n            count+=1\n        end\n        if temp[i]==\"E\"\n          \
    \  count+=1\n        end\n        if temp[i]==\"F\"\n            count+=1\n  \
    \      end\n        if temp[i]==\"0\"\n            count+=1\n        end\n   \
    \     if temp[i]==\"1\"\n            count+=1\n        end\n        if temp[i]==\"\
    2\"\n            count+=1\n        end\n        if temp[i]==\"3\"\n          \
    \  count+=1\n        end\n        if temp[i]==\"4\"\n            count+=1\n  \
    \      end\n        if temp[i]==\"5\"\n            count+=1\n        end\n   \
    \     if temp[i]==\"6\"\n            count+=1\n        end\n        if temp[i]==\"\
    7\"\n            count+=1\n        end\n        if temp[i]==\"8\"\n          \
    \  count+=1\n        end\n        if temp[i]==\"9\"\n            count+=1\n  \
    \      end\n    end\n    return count\nend\n</cell>\n<code language=julia-1.5>\n\
    hex_key(\"AB\")\n</cell>\n<code language=julia-1.5>\nhex_key(\"1077E\")\n</cell>\n\
    <code language=julia-1.5>\nhex_key(\"ABED1A33\")\n</cell>\n<code language=julia-1.5>\n\
    hex_key(\"123456789ABCDEF0\")\n</cell>\n<code language=julia-1.5>\nhex_key(\"\
    2020\")\n</cell>\n<code language=julia-1.5>\nhex_key(\"\")\n</cell>\n<code language=julia-1.5>",
  "  str_num = num.to_s.to_s\n  digits = str_num.to_i(2)\n  result = nil\n  if digits\
    \ == 0\n    result = 1\n  elsif digits > 0 && digits < 9\n    result = 0\n  elsif\
    \ digits == 2\n    result = 1\n  elsif digits == 3\n    result = 2\n  elsif digits\
    \ == 5\n    result = 3\n  elsif digits == 7\n    result = 5\n  elsif digits ==\
    \ 11\n    result = 7\n  elsif digits == 13\n    result = 11\n  end\n  return result\n\
    end", "  num = num.upcase\n  count = 2\n  while num.length > 0\n    digit = num.slice!(0,1)\n\
    \    num = num.slice!(1,2)\n    if digit == 'A' || digit == 'B'\n      count +=\
    \ 1\n    else\n      count = 7\n    break\n  end\n  count\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nthanks very much for such an answer. I thought I was going crazy\n\
    <|/ c |>\n<| a tags=ruby,regex dscore=0 |>\n<code>", "  # Write your solution\
    \ here\n  hex_count = 0\n  a = num.split(\"\")\n  a.each { |s| hex_count+=1 if\
    \ s.to_i(16).odd? }\n  return hex_count\nend", "  num_arr = num.split(\"\")\n\
    \  num_arr.delete('')\n  count = 0\n  for i in num_arr\n    if i.between?(0,9)\
    \ && i.in?(\"ABCDEF0\",\"0\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\")\n      count\
    \ = count + 1\n    end\n  end\n  count\nend\n</code>\nAnd then we add two new\
    \ functions to the class (let's call it hex_count), which does the work of hex_key,\
    \ but also returns the count of prime numbers:\n<code>", "  digits = num.split('').map\
    \ {|s| s.to_i}\n  count = 2\n  while count < digits.length\n    if digits[count]\
    \ == 2\n      count += 1\n      continue\n    \n    digit = digits[count]\n  \
    \  \n    i = count + 1\n    while i < digits.length && digits[i] == digit\n  \
    \    i += 1\n      \n    digits[count] = i\n    \n    i += 1\n    while i < digits.length\
    \ && digits[i] == digit\n      i += 1\n    \n    digits[count] = i\n    \n   \
    \ i += 1\n    while i < digits.length && digits[i] == digit\n      i += 1\n  \
    \  \n    digits[count] = i\n    count += 1\n  end\n  \n  count = 2 # reset\n \
    \ digits = digits[0..digits.length-1]\n  digits.each do |digit|\n    if digit\
    \ % 2 != 0\n      count += 1\n      continue\n    end\n    \n    i += 2\n    while\
    \ i < digits.length && digits[i] == digit\n      i += 1\n    end\n    \n    count\
    \ += i\n  end\n  \n  count\nend", "  return num.to_s.split(//).map{|x| x.to_i(16).to_s(16)}\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\n`hex_key.call('0')` returns `0`, not\
    \ `2`.\n<|/ c |>\n<| c |>\nThanks for pointing it out. I updated the answer to\
    \ return `0` instead of `2`\n<|/ c |>\n<| c |>\nI updated my answer to include\
    \ the base cases (even though it doesn't seem useful to me).\n<|/ c |>\n<| a dscore=0\
    \ tags=ruby |>\nAnother solution would be this one\n<code>", "  return nat_to_int(num,\
    \ [:hex_key], nat_to_int, 1, 2)\nend", "  num = num.upcase\n  count = 3\n  for\
    \ i in 0..num.length-1\n    if num[i] == \"A\"\n      count += 1\n      if count\
    \ > 6\n        return count\n    end\n    if num[i] == \"B\"\n      count -= 1\n\
    \      if count > 6\n        return count\n    end\n    if num[i] == \"C\"\n \
    \     count += 1\n      if count > 6\n        return count\n    end\n    if num[i]\
    \ == \"D\"\n      count -= 1\n      if count > 6\n        return count\n    end\n\
    \    if num[i] == \"E\"\n      count += 1\n      if count > 6\n        return\
    \ count\n    end\n    if num[i] == \"F\"\n      count -= 1\n      if count > 6\n\
    \        return count\n    end\n  end\n  count = 2\n  if num.length <= 6\n   \
    \ return count\n  end\n  return nil\nend", "    i = 0\n    primes = []\n    while\
    \ i < num.length\n        if num[i] != \"A\" and num[i] != \"B\" and num[i] !=\
    \ \"C\" and num[i] != \"D\" and num[i] != \"E\" and num[i] != \"F\"\n        \
    \    i = i + 1\n        else\n            primes.push(num[i])\n            i =\
    \ i + 1\n    end\n    return primes.length\nend", "  hex_key_count = 0\n  num\
    \ = num.upcase\n  num = num.scan(/[0-9A-F]/)\n  num = num.map {|d| d.to_i}\n \
    \ num = num.map {|d| [d] * d}.flatten\n  num.each do |d|\n    if Prime.take(2).detect\
    \ {|p| d.product(p).to_i == d}\n      hex_key_count += 1\n    end\n  end\n  hex_key_count\n\
    end\n</code>\n<|/ a dscore=2 tags=ruby |>\n<| c |>\nI see that some of these solutions\
    \ are still quite slow in some cases.  It may be an interesting exercise to try\
    \ to make it run faster.\n<|/ c |>\n<| a dscore=1 |>\nThis looks like an algorithm\
    \ to count the number of primes up to an arbitrary length, and to find out if\
    \ the number is a prime, and to find out which of the two numbers is prime.\n\
    I'd say that the first two problems are easy: just count the prime numbers until\
    \ you get a number that's not prime, and then see if that number is prime. You'll\
    \ need to implement this function in Ruby. In pseudocode:\n<code>\ncountPrimes(numToTest):\n\
    \  result = 1\n  numToTest += 1\n  while not isPrime(numToTest):\n    numToTest\
    \ += 1\n    result += 1\n  end\n  return result\n</code>\nNow to find out which\
    \ number is the prime: there are lots of ways to do this, but since it looks like\
    \ you're not allowed to use any Ruby methods, and since you aren't allowed to\
    \ use any Ruby methods that aren't defined in Ruby, the simplest would be something\
    \ like this:\n<code>\nif countPrimes(numToTest) == 3\n  print \"#{numToTest} is\
    \ the prime\"\nelsif countPrimes(numToTest) == 2\n  print \"#{numToTest} is the\
    \ prime\"\n  print \"#{numToTest+1} is the prime\"\nelse\n  print \"#{numToTest}\
    \ is the prime\"\n  print \"#{numToTest+1} is the prime\"\n  print \"#{numToTest+2}\
    \ is the prime\"\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n\"simplest\"? I mean,\
    \ that's how it works. ;) It doesn't seem so simple to me, though.\n<|/ c |>\n\
    <| c |>\nI mean simplest for somebody who's never done something like this before.\
    \ I think that's probably more a property of Ruby than of \"simplest\".\n<|/ c\
    \ |>\n<| c |>\n", "  if num == \"\"\n    puts \"error\"\n  else\n    numbers =\
    \ (2, 3, 5, 7, 11, 13, 17, 19)\n    \n    digits = (num.to_s.split(\"\").map{|char|\
    \ \n      digits.include?(char) ? numbers.include?((char.to_i - 48).to_i) ? char.to_i\
    \ : 0\n      : 0\n    }).sum", "  num.downcase!\n  digits = num.to_s.split('')\n\
    \  count = 0\n  for i in 0...digits.length\n    if i == 0 or digits[digits.length-i-1].to_i\
    \ != digits[digits.length-i-i-1].to_i\n      count+=1\n    end\n  end\n  return\
    \ count\nend", "  primes = []\n  str_num = \"#{num}\"\n  str_num.each_char { |c|\n\
    \    if c.to_i == 16\n      primes << c\n    elsif (c == \"A\") || (c == \"B\"\
    ) || (c == \"C\") || (c == \"D\") || (c == \"E\")\n      primes << c.hex.to_i\n\
    \    end\n  }\n  primes.uniq.count\nend\n</code>\n<|/ a tags=ruby dscore=2 |>\n\
    <| c |>\nThank you. This was very helpful.\n<|/ c |>\n<| c |>\nYou are welcome.\
    \ Let me know if you need any help with the solution.\n<|/ c |>\n<| a dscore=1\
    \ |>\nYou can create an array of all possible prime numbers of length n using\
    \ sieve of Eratosthenes. Here's a way to do it using Ruby's prime library:\n<code>\n\
    require 'prime'", "    \n    # Write your code here\n    \n    lenNum = len(num)\n\
    \    \n    if lenNum == 1:\n        \n        hexNum = ord(num)\n        \n  \
    \      if hexNum in primes:\n            \n            return primes[hexNum]\n\
    \        \n        elif hexNum == 0 or hexNum == 1 or hexNum == 2:\n         \
    \   \n            return 1\n        \n        else:\n            \n          \
    \  return 0\n    \n    else:\n        \n        hexNum = ord(num[0])*16 + ord(num[1])\n\
    \        \n        if hexNum in primes:\n            \n            return primes[hexNum]\n\
    \        \n        elif hexNum == 0 or hexNum == 1 or hexNum == 2:\n         \
    \   \n            return 1\n        \n        else:\n            \n          \
    \  return 0\n    ", "  num = num.split(\"\")\n  count = 0\n  for i in num\n  \
    \  if i.is_a? Integer && i.odd? && i.even?\n      count += 1\n    end\n  end\n\
    \  return count\nend", "    sum = 0\n    # Your code here\n    arr = num.to_s.split(\"\
    \").map {|c| c.to_i(16)}\n    arr.each {|n| sum+=n}\n    return sum % 8\nend",
  "  digits = num.to_s.split(\"\").map(&:hex).join\n  digits.each_cons(2).select {\
    \ |x, y| x > y }.size\nend", "  n = num.to_s.to_i\n  a = 2\n  b = 2\n  c = 2\n\
    \  d = 2\n  e = 2\n  f = 2\n  primes = 3\n  while n != 0\n    n -= 1\n    a =\
    \ 3*a+b\n    b = 3*b+c\n    c = 3*c+d\n    d = 3*d+e\n    e = 3*e+f\n    f = 3*f\n\
    \    primes += 1\n  end\n  prime\nend", "  num = num.chomp # remove leading and\
    \ trailing whitespace.\n  num = num.downcase # convert to uppercase.\n  num =\
    \ num.split(\"\") # split string into array characters.\n  prime_numbers = 0\n\
    \  for i in 0..(num.length-1)\n    if num[i] == 2 || num[i] == 3\n      prime_numbers\
    \ += 1\n    else if num[i] == 5\n      prime_numbers += 1\n    end\n  end\n  return\
    \ prime_numbers\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby dscore=0 |>\n\
    <code>", "    num.each_index do |i|\n        if num[i] == \"A\" or num[i] == \"\
    B\" or num[i] == \"C\" or num[i] == \"D\" or num[i] == \"E\" or num[i] == \"F\"\
    \n            puts 1\n            exit 0\n        end\n    end\n    puts 0\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| a tags=ruby |>\n<code>\n def count_hex_digits(str)\n\
    \    str.each_char { |c| return 0 if c != ?A && c != ?B && c != ?C && c != ?D\
    \ && c != ?E && c != ?F }\n    str.size.times{ yield str.size - 1 }\n    str.size\n\
    \ end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis is O(n^2) if str is large. This\
    \ can be improved.\n<|/ c |>\n<| c |>\n: Actually, `str.size` doesn't have to\
    \ be called twice in this case.\n<|/ c |>\n<| c |>\nI assume you mean `str.size`\
    \ instead of `str.length`. I don't think it's O(n^2), but it's O(n) since `String#size`\
    \ is O(1). That's probably true for the most common implementations, but it might\
    \ not be true for other implementations such as JRuby or IronRuby.\n<|/ c |>\n\
    <| a tags=ruby |>\nI took the time to learn some Ruby and made a Ruby implementation\
    \ based on Jimmy Fien's code (so far it is in its infancy, and I don't know Ruby).\
    \ It is a lot longer than Jimmy's but it is also much easier to understand and\
    \ modify (if you know Ruby, and you can learn Ruby, this is very useful). It is\
    \ a little longer because the algorithm is more complex, so I decided to write\
    \ the code as a separate function:\n<code>", "  num.downcase!\n  result = 0\n\
    \  if num.length > 0\n    num.split(\"\").each do |digit|\n      if digit.include?\
    \ \"A\"\n        result += 1\n      end\n    end\n  else\n    return 0\n  end\n\
    \  return result\nend\n</cell>\n<text>\nSolution:\nRun the cell below to see if\
    \ your solution matches our expectations.", "    digits = [2,3,5,7,11,13,17,19]\n\
    \    return digits[num.count(2)]\n    \n</cell>\n<cell>", "  num.upcase!\n  return\
    \ ((0...16).inject(0){|n,i| n*Math.pow(16,i) + num.slice(i..i+1).to_i(16) } ==\
    \ 1)\nend", "    count = 0\n    count = 0\n    i = 0\n    while i < num.length\n\
    \        if num.char(i) == \"A\"\n        elsif num.char(i) == \"B\"\n       \
    \ elsif num.char(i) == \"C\"\n        elsif num.char(i) == \"D\"\n        elsif\
    \ num.char(i) == \"E\"\n        elsif num.char(i) == \"F\"\n        elsif num.char(i)\
    \ == \"0\"\n        elsif num.char(i) == \"1\"\n        elsif num.char(i) == \"\
    2\"\n        elsif num.char(i) == \"3\"\n        elsif num.char(i) == \"4\"\n\
    \        elsif num.char(i) == \"5\"\n        elsif num.char(i) == \"6\"\n    \
    \    elsif num.char(i) == \"7\"\n        elsif num.char(i) == \"8\"\n        elsif\
    \ num.char(i) == \"9\"\n        elsif num.char(i) == \"A\"\n        elsif num.char(i)\
    \ == \"B\"\n        elsif num.char(i) == \"C\"\n        elsif num.char(i) == \"\
    D\"\n        elsif num.char(i) == \"E\"\n        elsif num.char(i) == \"F\"\n\
    \        elsif num.char(i) == \"0\"\n        elsif num.char(i) == \"1\"\n    \
    \    elsif num.char(i) == \"2\"\n        elsif num.char(i) == \"3\"\n        elsif\
    \ num.char(i) == \"4\"\n        elsif num.char(i) == \"5\"\n        elsif num.char(i)\
    \ == \"6\"\n        elsif num.char(i) == \"7\"\n        elsif num.char(i) == \"\
    8\"\n        elsif num.char(i) == \"9\"\n        end\n        if num.char(i) ==\
    \ \"0\"\n        elsif num.char(i) == \"1\"\n        elsif num.char(i) == \"2\"\
    \n        elsif num.char(i) == \"3\"\n        elsif num.char(i) == \"4\"\n   \
    \     elsif num.char(i) == \"5\"\n        elsif num.char(i) == \"6\"\n       \
    \ elsif num.char(i) == \"7\"\n        elsif num.char(i) == \"8\"\n        elsif\
    \ num.char(i) == \"9\"\n        elsif num.char(i) == \"A\"\n        ", "  key_digits\
    \ = num.to_s.split('').map(&:to_i).map(&:to_s)\n  key_digits.sort.reverse.each\
    \ do |digit|\n    if digit.first == 'B' and digit.last == 'D'\n      return digit.last\
    \ + key_digits.find { |digit| digit.first == 'C' }\n    end\n  end\n  0\nend",
  "  hex_num = \"\"\n  for i in num\n    hex_num = hex_num + i.to_s(16)\n  hex_num\
    \ = hex_num.to_i(16)\n  \n  prime_hex = 2\n  while hex_num > 1\n    hex_num =\
    \ hex_num / 10\n    prime_hex = prime_hex * 10\n  end\n  \n  return prime_hex.to_i\n\
    end", "  n = num.to_i\n  a = 2\n  while a <= n do\n    if n % a == 0 then\n  \
    \    a = 2\n      while a <= n do\n        if n % a == 0 then\n          a = 2\n\
    \        end\n        a = a + 1\n      end\n      break\n    end\n    a = a +\
    \ 1\n  end\n  return a\nend", "    hex_value = num.to_s.hex\n    hex_value.each_char\
    \ do |char|\n        if char.to_i >= 10 and char.to_i <= 19\n            count\
    \ = 2\n        elsif char.to_i >= 20 and char.to_i <= 39\n            count =\
    \ 3\n        elsif char.to_i >= 40 and char.to_i <= 59\n            count = 5\n\
    \        elsif char.to_i >= 60 and char.to_i <= 79\n            count = 7\n  \
    \      elsif char.to_i >= 80 and char.to_i <= 89\n            count = 11\n   \
    \     elsif char.to_i >= 90 and char.to_i <= 119\n            count = 13\n   \
    \     end\n    end\n    \n    return count\nend", "    str.split(num).each_with_index\
    \ do |digit, index|\n        str.split(digit).each_with_index do |hex_digit, index2|\n\
    \            hex_digit = hex_digit.to_i\n            if hex_digit == 0\n     \
    \           return 1\n            else\n                if ((hex_digit % 2 ==\
    \ 0) != (index2 % 2 == 0)) \n                    return 0\n                else\n\
    \                    return 1\n                end\n            end\n        end\n\
    \    end\nend\n</code>\n<|/ a tags=ruby,hex,primes |>\n<| c |>\nThanks for the\
    \ help! I forgot to mention one detail. Hex numbers cannot have zeros because\
    \ they don't represent natural numbers. So, zeros shouldn't be counted. This is\
    \ a requirement from my assignment, but I suppose the question should have been\
    \ more specific about it.\n<|/ c |>\n<| c |>\nThis is why I started from 97, and\
    \ subtracted 97 from every hex digit. Since 97, and 10 are both primes, this works\
    \ because 97, 98, 99 and 10 are all hex digits, and a hex digit can't be prime\
    \ with another hex digit.\n<|/ c |>\n<| a tags=ruby,hex,primes |>\nI like some\
    \ of the other answers, but they don't work correctly for input like \"911\" which\
    \ should output 2.\nHere is a simple recursive algorithm that works for these\
    \ cases, using Ruby's built-in regex capabilities. \n<code>", "    num.each_byte\
    \ {|b| prime += 1 if b.to_s(16).chars.all? {|c| c == ?A..?F}}\n    return prime\
    \ + 1\nend", "  return num.count(\"0\") + (num.count(\"A\") + num.count(\"B\"\
    )) + (num.count(\"C\") + num.count(\"D\")) + (num.count(\"E\") + num.count(\"\
    F\"))\nend\n</cell>\n<text>\nExercise 6\nFor this exercise you need to write a\
    \ function that receives a string and returns the number of \"uppercase letters\"\
    \ in the string.\nExamples:\n>>> uppercase(\"ABC\")\n3\n>>> uppercase(\"def\"\
    )\n1", "  hex_num.call(nil,num)\nend", "    prime = 2 \n    counter = 2\n    chars\
    \ = \"ABCDEF\"\n    hex_list = []\n    while counter < num.length do\n       \
    \ digit = chars.chars.index(num[counter]) + 1\n        if digit % 2 == 1 then\n\
    \            if prime == 2 then\n                prime = 5\n            end\n\
    \            if prime == 5 then\n                prime = 7\n            end\n\
    \            if prime == 7 then\n                prime = 10\n            end\n\
    \        end\n        if prime == 7 then\n            prime = 10\n        end\n\
    \        if prime == 10 then\n            prime = 13\n        end\n        if\
    \ prime == 13 then\n            prime = 17\n        end\n        if prime == 17\
    \ then\n            prime = 19\n        end\n        if prime == 19 then\n   \
    \         prime = 23\n        end\n        if prime == 23 then\n            prime\
    \ = 29\n        end\n        if prime == 29 then\n            prime = 34\n   \
    \     end\n        if prime == 34 then\n            prime = 39\n        end\n\
    \        if prime == 39 then\n            prime = 43\n        end\n        if\
    \ prime == 43 then\n            prime = 47\n        end\n        if prime == 47\
    \ then\n            prime = 53\n        end\n        if prime == 53 then\n   \
    \         prime = 59\n        end\n        if prime == 59 then\n            prime\
    \ = 65\n        end\n        if prime == 65 then\n            prime = 71\n   \
    \     end\n        if prime == 71 then\n            prime = 78\n        end\n\
    \        if prime == 78 then\n            prime = 83\n        end\n        if\
    \ prime == 83 then\n            prime = 89\n        end\n        if prime == 89\
    \ then\n            prime = 97\n        end\n        if prime == 97 then\n   \
    \         prime = 112\n        end\n        hex_list.push digit\n        counter\
    \ += 1\n    end\n    return hex_list.count\nend", "    # Write your code here\n\
    \    count = 0\n    if num == \"\"\n        return 0\n    \n    digits = num.split(\"\
    \")\n    \n    for digit in digits:\n        if digit == \"0\"\n            return\
    \ 0\n        \n        if digit == \"1\"\n            count += 1\n        \n \
    \       if digit in \"23456789ABCDEF\"\n            count += 1\n    \n    return\
    \ count", "  number_list = num.split(\"\")\n  num_len = len(num)\n  counter =\
    \ 1 # counts the number of '2' digits in the number list\n  hex_key = 0\n  while\
    \ counter <= num_len do\n    # checks if the next hex digit is a prime number\n\
    \    # and if it is not we append it to the hex_key\n    if number_list[counter]\
    \ == 2 and (number_list[counter - 1] % 2 == 0) do\n      hex_key += number_list[counter]\n\
    \      counter += 1 # counts the number of '2' digits in the number list\n   \
    \ end\n    counter += 1 # counts the number of '2' digits in the number list\n\
    \  end\n  return hex_key\nend", "  # Your code here\n  \nend", "    prime = 0\n\
    \    hex_key = {}\n    hex_key[num[0]] = 2\n    hex_key[num[1]] = 2\n    hex_key[num[2]]\
    \ = 3\n    hex_key[num[3]] = 3\n    hex_key[num[4]] = 5\n    hex_key[num[5]] =\
    \ 5\n    hex_key[num[6]] = 7\n    hex_key[num[7]] = 7\n    hex_key[num[8]] = 3\n\
    \    hex_key[num[9]] = 3\n    hex_key[num[10]] = 5\n    hex_key[num[11]] = 5\n\
    \    hex_key[num[12]] = 7\n    hex_key[num[13]] = 7\n    hex_key[num[14]] = 7\n\
    \    hex_key[num[15]] = 7\n    for i in hex_key\n        temp = hex_key[i]\n \
    \       if temp > 1\n            temp = temp - 1\n            hex_key[i] = temp\n\
    \            i = i\n            if i > hex_key[hex_key[i]]\n                i\
    \ = hex_key[i]\n            if i > hex_key[hex_key[i]]\n                i = hex_key[i]\n\
    \            if i > hex_key[hex_key[i]]\n                i = hex_key[i]\n    \
    \        if i > hex_key[hex_key[i]]\n                i = hex_key[i]\n        \
    \    if i > hex_key[hex_key[i]]\n                i = hex_key[i]\n            if\
    \ i > hex_key[hex_key[i]]\n                i = hex_key[i]\n            if i >\
    \ hex_key[hex_key[i]]\n                i = hex_key[i]\n            if i > hex_key[hex_key[i]]\n\
    \                i = hex_key[i]\n            if i > hex_key[hex_key[i]]\n    \
    \            i = hex_key[i]\n            if i > hex_key[hex_key[i]]\n        \
    \        i = hex_key[i]\n            if i > hex_key[hex_key[i]]\n            \
    \    i = hex_key[i]\n            if i > hex_key[hex_key[i]]\n                i\
    \ = hex_key[i]\n            if i > hex_key[hex_key[i]]\n                i = hex_key[i]\n\
    \            if i > hex_key[hex_key[i]]\n                i = hex_key[i]\n    \
    \        if i > hex_key[hex_key[i]]\n                i = hex_key[i]\n        \
    \    if i > hex_key[hex_key[i]]\n                i = hex_key[i]\n            if\
    \ i > hex_key[hex_key[i]]\n                i = hex_key[i]\n            if i >\
    \ hex_key[hex_key[i]]\n                i = hex_key[i]\n            if i > hex_key[hex_key[i]]\n\
    \                i = hex_key[i]\n            if i > hex_key[hex_key[i]]\n    \
    \            i = hex_key[i]\n            if i > hex_key[", "  if num == \"\"\n\
    \    return 0\n  a = num.to_i(16)\n  \n  digits = (\"\", \"2\", \"3\", \"5\",\
    \ \"7\", \"B\", \"D\")\n  digits_count = {}\n  \n  for i in digits\n    if i.chr(a).eql?\
    \ \"A\"\n      digits_count[i] = 0\n    else if i.chr(a).eql? \"B\"\n      digits_count[i]\
    \ = 1\n    else if i.chr(a).eql? \"C\"\n      digits_count[i] = 2\n    else if\
    \ i.chr(a).eql? \"D\"\n      digits_count[i] = 3\n    else if i.chr(a).eql? \"\
    E\"\n      digits_count[i] = 4\n    else if i.chr(a).eql? \"F\"\n      digits_count[i]\
    \ = 5\n    else\n      digits_count[i] = 0\n    end\n  end\n  \n  sum = 0\n  for\
    \ i in digits\n    sum = sum + digits_count[i]\n  end\n  \n  return sum\nend\n\
    </cell>\n<text>\nFor this problem, we will be using Ruby syntax to build the function.",
  "    primes=[]\n    for n in num.to_s.split(//)\n        if n.to_i==n.to_i && n[n.length-1].to_i==\"\
    B\"\n            primes << n.to_i\n        elsif n.to_i==n.to_i && n[n.length-1].to_i==\"\
    D\"\n            primes << n.to_i\n        elsif n.to_i==n.to_i && n[n.length-1].to_i==\"\
    A\"\n            primes << n.to_i\n        end\n    end\n    primes.count\nend",
  "  num_str = num.call\n  if num_str.empty?\n    1\n  elsif num_str.match(\"[a-f]\"\
    )\n    hex_to_dec(num_str)\n  else\n    1\n  end\nend", "  case num.downcase\n\
    \  when 'a'..'f'\n    digits = [num.to_i]\n  when '0'..'9'\n    digits = num.to_i(16).to_s(16).split(//).map(&:to_i)\n\
    \  when '2'..'7'\n    digits = num.to_i(16).to_s(16).split(//).map(&:to_i)\n \
    \   digits.each_with_index.select do |d, i|\n      if i % 2 == 0\n        next\
    \ if d % 2 == 0\n      else\n        next if d % 3 == 0\n      end\n      digits.delete_at(i)\n\
    \      true\n    end.length == digits.length\n  end\nend\n</code>\nAnd here is\
    \ another implementation using regular expressions:\n<code>", "  key = num.scan(/../).map{|x|\
    \ x.to_i }\n  if key.include? 2\n    key.delete_at(1..-1)\n  else\n    key.delete_at(2..-1)\n\
    \  end\n  if key.include? 3\n    key.delete_at(1..-1)\n  end\n  if key.include?\
    \ 5\n    key.delete_at(1..-1)\n  end\n  if key.include? 7\n    key.delete_at(1..-1)\n\
    \  end\n  if key.include? 11\n    key.delete_at(1..-1)\n  end\n  if key.include?\
    \ 13\n    key.delete_at(1..-1)\n  end\n  if key.include? 17\n    key.delete_at(1..-1)\n\
    \  end\n  key.count\nend\n</code>\nTest\n<code>", "    num = num.to_s.upcase\n\
    \    count = 0\n    digits = num.to_s(16).chars.to_a\n    digits.each do |digit|\n\
    \        if digit.to_i==digit.to_i+1 then\n            count += 1\n        end\n\
    \    end\n    count\nend", "  if num == \"\"\n    puts \"The number is empty!\"\
    \n  else\n    num = num.upcase\n    hexa = num.split(\"\")\n    hexa.each do |x|\n\
    \      if x == \"A\"\n        hexa.shift\n      elsif x == \"B\"\n        hexa.shift\n\
    \        hexa.shift\n      elsif x == \"C\"\n        hexa.shift\n        hexa.shift\n\
    \        hexa.shift\n      elsif x == \"D\"\n        hexa.shift\n        hexa.shift\n\
    \        hexa.shift\n        hexa.shift\n      elsif x == \"E\"\n        hexa.shift\n\
    \        hexa.shift\n        hexa.shift\n        hexa.shift\n        hexa.shift\n\
    \      elsif x == \"F\"\n        hexa.shift\n        hexa.shift\n        hexa.shift\n\
    \        hexa.shift\n        hexa.shift\n        hexa.shift\n      elsif x ==\
    \ \"0\"\n        hexa.shift\n        hexa.shift\n        hexa.shift\n        hexa.shift\n\
    \        hexa.shift\n        hexa.shift\n      elsif x.to_i >= 2\n        hexa.shift\n\
    \      elsif x.to_i == 3\n        hexa.shift\n        hexa.shift\n        hexa.shift\n\
    \      elsif x.to_i == 5\n        hexa.shift\n        hexa.shift\n        hexa.shift\n\
    \        hexa.shift\n        hexa.shift\n        hexa.shift\n      elsif x.to_i\
    \ == 7\n        hexa.shift\n        hexa.shift\n        hexa.shift\n        hexa.shift\n\
    \        hexa.shift\n        hexa.shift\n        hexa.shift\n      elsif x.to_i\
    \ == 11\n        hexa.shift\n        hexa.shift\n        hexa.shift\n        hexa.shift\n\
    \        hexa.shift\n        hexa.shift\n        hexa.shift\n      elsif x.to_i\
    \ == 13\n        hexa.shift\n        hexa.shift\n        hexa.shift\n        hexa.shift\n\
    \        hexa.shift\n        hexa.shift\n        hexa.shift\n        hexa.shift\n\
    \      end\n    end\n    puts hexa.length\n  end\nend", "  num = num.delete(\"\
    ^*\")\n  if num.size == 0\n    return 0\n  hex_list = []\n  hex_key = 0\n  for\
    \ i in 0..(2**16)-1\n    hex_key = (hex_key*16 + num.chars[i]).to_i\n    if hex_key\
    \ > 255\n      break\n    hex_list.push(hex_key)\n  end\n  hex_arr.clear\n  hex_list.each_with_index\
    \ do |hex, idx|\n    hex_arr.push(hex)\n  end\n  hex_arr.size.downto(0) do |idx|\n\
    \    hex_arr.unshift(0)\n  end\n  hex_arr.each_with_index do |hex, idx|\n    if\
    \ idx == 2\n      if hex == 2 || hex == 3 || hex == 5 || hex == 7\n        hex_arr[idx]\
    \ = 2\n      else\n        if hex == 2 || hex == 3 || hex == 5 || hex == 7\n \
    \         hex_arr[idx] = hex\n        else\n          hex_arr[idx] = hex + 2\n\
    \        end\n      end\n    elsif idx > 2 && (hex == 2 || hex == 3 || hex ==\
    \ 5 || hex == 7) && hex == hex_list[idx-2]\n      hex_arr[idx] = hex_list[idx-2]\
    \ + 2\n    end\n  end\n  hex_arr.each_with_index do |hex, idx|\n    if hex ==\
    \ 2 || hex == 3 || hex == 5 || hex == 7\n      hex_arr[idx] = hex\n    else\n\
    \      hex_arr[idx] = hex + 2\n    end\n  end\n  hex_arr.size.downto(0) do |idx|\n\
    \    hex_arr.unshift(0)\n  end\n  hex_arr.each_with_index do |hex, idx|\n    if\
    \ idx == 2\n      if hex == 2 || hex == 3 || hex == 5 || hex == 7\n        hex_arr[idx]\
    \ = 2\n      else\n        if hex == 2 || hex == 3 || hex == 5 || hex == 7\n \
    \         hex_arr[idx] = hex\n        else\n          hex_arr[idx] = hex + 2\n\
    \        end\n      end\n    elsif idx > 2 && (hex == 2 || hex == 3 || hex ==\
    \ 5 || hex == 7) && hex == hex_list[idx-2]\n      hex_arr[idx] = hex_list[idx-2]\
    \ + 2\n    end\n  end\n  hex_arr.each_with_index do |hex, idx|\n    if idx ==\
    \ 2\n      if hex == 2 || hex == 3 || hex == 5 || hex == 7\n        hex_arr[idx]\
    \ = 2\n      else\n        if hex == 2 || hex == 3 || hex == 5 || hex == 7\n \
    \         hex_arr[idx] = hex\n        else\n          hex_arr[idx] = hex + 2\n\
    \        end\n      end\n    elsif idx > 2 && (hex == 2 || hex == 3 || hex", " \
    \ num = num.to_s.upcase\n  num.each do |c|\n    next if c =~ /^(\\d*)$/\n    d.times\
    \ do\n      if c % d == 0\n        return c if c < 17\n      end\n    end\n  end\n\
    \  return 0\nend", "  # The variable hex_key has been created for you, and should\
    \ be assigned \n  # the value of the desired return value for this problem (an\
    \ integer that \n  # indicates the number of hexadecimal digits of the number\
    \ given that each \n  # of the digits in the hexadecimal number are prime).\n\
    \  # The function should return the value assigned to hex_key, or \n  # throw\
    \ an Exception if an Exception is thrown.\n  num.upcase!\n  hex_digits = num.split(//).map(&:to_i)\n\
    \  prime_digits = [2..hex_digits.length].select do |d|\n    prime_num = hex_digits.product(*([d.upcase])).any?\
    \ do |i|\n      i.to_s.gsub(/^./,\"\") == d.upcase && i.to_s.gsub(/^./,\"\").length\
    \ == d.length\n    end\n    !prime_num\n  end\n  return prime_digits.length\n\
    end", "  # TODO: Complete the function\n  # Return the number of hexadecimal digits\
    \ that are primes (prime \n  # number, or a prime, is a natural number greater\
    \ than 1 that is not a \n  # product of two smaller natural numbers).\n  # Hexadecimal\
    \ digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n  # Prime numbers\
    \ are 2, 3, 5, 7, 11, 13, 17,...\n  # So you have to determine a number of the\
    \ following digits: 2, 3, 5, 7, \n  # B (=decimal 11), D (=decimal 13).\n  # Note:\
    \ you may assume the input is always correct or empty string, \n  # and symbols\
    \ A,B,C,D,E,F are always uppercase.\n  # Examples:\n  # >>> hex_key.call(\"AB\"\
    )\n  # 1\n  # >>> hex_key.call(\"1077E\")\n  # 2\n  # >>> hex_key.call(\"ABED1A33\"\
    )\n  # 4\n  # >>> hex_key.call(\"123456789ABCDEF0\")\n  # 6\n  # >>> hex_key.call(\"\
    2020\")\n  # 2\n  hex_digits = (0...9).to_a\n  hex_digits.uniq.each do |hex_digit|\n\
    \    hex_digit_pow = (hex_digit.to_i)**3\n    hex_digit_pow.times do |hex_digit_pow_times|\n\
    \      hex_digit_pow_times < hex_digits.size &&\n        hex_digits.sample.to_i**hex_digit_pow\
    \ < hex_digits.size &&\n        hex_digit_pow_times * hex_digit_pow <= hex_digits.size\n\
    \    end\n  end\n  hex_digits.uniq.size\nend\n</code>\n<|/ a dscore=0 tags=hex,math,ruby\
    \ |>\n<| a |>\nHere is another version. \n<code>", "    count = 0\n    temp =\
    \ num\n    while temp > 0\n        if temp % 2 == 0\n            count += 2\n\
    \            temp = temp / 2\n        else\n            if temp % 3 == 0\n   \
    \             count += 2\n                temp = temp / 3\n            else\n\
    \                if temp % 5 == 0\n                    count += 2\n          \
    \          temp = temp / 5\n                else\n                    if temp\
    \ % 7 == 0\n                        count += 2\n                        temp =\
    \ temp / 7\n                    else\n                        if temp % 11 ==\
    \ 0\n                            count += 2\n                            temp\
    \ = temp / 11\n                        else\n                            if temp\
    \ % 13 == 0\n                                count += 2\n                    \
    \            temp = temp / 13\n                            else\n            \
    \                    if temp % 17 == 0\n                                    count\
    \ += 2\n                                    temp = temp / 17\n               \
    \                 else\n                                    if temp % 19 == 0\n\
    \                                        count += 2\n                        \
    \                temp = temp / 19\n                                    else\n\
    \                                        if temp % 23 == 0\n                 \
    \                           count += 2\n                                     \
    \       temp = temp / 23\n                                        else\n     \
    \                       if temp % 29 == 0\n                                count\
    \ += 2\n                                temp = temp / 29\n                   \
    \         else\n                                if temp % 31 == 0\n          \
    \                          count += 2\n                                    temp\
    \ = temp / 31\n                                else\n                        \
    \            if temp % 37 == 0\n                                        count\
    \ += 2\n                                        temp = temp / 37\n           \
    \                         else\n                                        if temp\
    \ % 43 == 0\n                                            count += 2\n        \
    \                                    temp = temp / 43\n                      \
    \                  else\n                                            if temp %\
    \ 49 == 0\n                                                count += 2\n      \
    \                                          temp = temp / 49\n                \
    \                            else\n                                          \
    \      if temp % 59 == 0\n                                                   \
    \ count += 2\n                                                    temp = temp\
    \ / 59\n                                                else\n               \
    \                                     if temp % 71 == 0\n                    \
    \                                    count += 2\n                            \
    \                            temp = temp / 71\n                              \
    \                      else\n                                                \
    \        if temp % 79 == 0\n                                                 \
    \           count += 2\n                                                     \
    \       temp = temp / 79\n                                                   \
    \     else\n                                                            if temp\
    \ % 97 == 0\n                                                                count\
    \ += 2\n                                                                temp =\
    \ temp / 97\n                                                            else\n\
    \                                                                if temp % 111\
    \ == 0\n                                                                    count\
    \ += 2\n                                                                    temp\
    \ = temp / 111\n                                                             \
    \       break\n    return count\n        ", "  # TODO: replace with regex\n  hex\
    \ = num.to_s.split(\"\").map{|x| x.hex}.join\n  \n  count = 0\n  primes = 2\n\
    \  digits = \"0123456ABCDEF\"\n  \n  hex.each_char do |c|\n    if digits == hex.scan(/./).map{|x|\
    \ x.to_i}\n      count += 1\n      primes += 1 if (primes.to_i % c == 0)\n   \
    \ end\n  end", "  num_str = num.to_s.upcase\n  return num_str.scan(/[0-9A-F]{2}/).count.to_i\n\
    end\n</code>\n<|/ a |>\n<| c |>\nCan you explain the algorithm for how to determine\
    \ the number of digits that are prime in a string? And I don't know how to get\
    \ the hexadecimal digits. I tried ```num.to_s.scan(/[0-9A-F]{2}/)``` in Ruby.\
    \ But it didn't give me the digits I needed.\n<|/ c |>\n<| c |>\nFor the first\
    \ one, I need to know if my string is a hexadecimal number (hence the ```is_a?```\
    \ condition), then get the first two digits. So I just need to find the first\
    \ character in the string, and then subtract that from the length of the string\
    \ to get two digits. So my function will return an integer with the number of\
    \ hexadecimal digits in the string.\n<|/ c |>\n<| c |>\nFor your second one, I\
    \ need to figure out if the string is a hexadecimal number, and then get the first\
    \ two digits. But I don't think ```is_a?``` will work because it returns true\
    \ or false. So, I need a conditional statement to see if it's a hexadecimal number\
    \ or not. And then get the first two characters. And then determine if those characters\
    \ are prime or not.\n<|/ c |>\n<| c |>\nI edited my answer to include a function\
    \ that returns the number of digits in a given number.\n<|/ c |>\n<| c |>\nThank\
    \ you! I really appreciate your help. I will give this a try.\n<|/ c |>\n<| a\
    \ |>\nI wrote a method that is similar to what you were asking.\n<code>", "  \
    \  num.downcase!\n    if num.empty?\n        return 0\n    count = (1..9).count(num[0])\n\
    \    count += 2\n    digits = num.to_s.chars.map { |n| n.to_i(16) }\n    digits.each\
    \ { |n| count += 1 if n % 6 == 0 }\n    count\nend", "  num = num.upcase.to_s\
    \ # convert input string to uppercase\n  count = 0\n  digits = num.split(\"\"\
    ) # split input string into array\n  # loop to check the digits and count the\
    \ digits\n  (0...digits.length).each do |i|\n    if digits[i] == \"A\"\n     \
    \ count += 2\n    elsif digits[i] == \"B\"\n      count += 3\n    elsif digits[i]\
    \ == \"C\"\n      count += 5\n    elsif digits[i] == \"D\"\n      count += 7\n\
    \    elsif digits[i] == \"E\"\n      count += 11\n    elsif digits[i] == \"F\"\
    \n      count += 13\n    else\n      next # skip other symbols such as 0,1,2,...\n\
    \    end\n  end\n  count\nend\n</code>\n<|/ a |>\n<| c |>\nThank you for helping!\
    \ I tried to implement this but I'm getting errors. I updated my code above, would\
    \ you mind taking a look and seeing what I'm doing wrong? Thanks again.\n<|/ c\
    \ |>\n<| a tags=ruby |>\nYou have the right idea, but the approach is wrong. You\
    \ want to use the remainder of the modulo operation to determine if a given number\
    \ is prime, which will reduce the number of cases you need to check, as well as\
    \ reduce the number of iterations that need to be performed.\nIn pseudocode:\n\
    <code>", "  digits = num.split(//)\n  return digits.length <= 5 ? 0 : 1 + digits.length\
    \ % 4 if digits.length <= 6 ? 2 : (digits.length <= 9 ? 4 : 6)\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| a dscore=0 |>\nThe shortest code I have come up with\n\
    <code>\nputs ('2'..'f').count { |c| hex_key(c.to_s) } if hex_key?(\"2\")\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\n\"shortest code\" is a good way of putting it\n<|/\
    \ c |>\n<| a dscore=0 |>\n<code>", "  # Your code here\n  \n  # return result\
    \ - number of digits in hexadecimal string equal to \n  # number of primes\n \
    \ return len(num)\n  ", "  hex_key = 0\n  i = 0\n  while hex_key.to_s.length <=\
    \ num.to_s.length\n    if num.to_s.length - i == 8\n      if num.to_s[i].to_s\
    \ == hex_key.to_s\n        hex_key += 1\n      end\n    elsif num.to_s.length\
    \ - i == 6\n      if num.to_s[i].to_s == hex_key.to_s\n        hex_key += 1\n\
    \      end\n    elsif num.to_s.length - i == 4\n      if num.to_s[i].to_s == hex_key.to_s\n\
    \        hex_key += 1\n      end\n    elsif num.to_s.length - i == 2\n      if\
    \ num.to_s[i].to_s == hex_key.to_s\n        hex_key += 1\n      end\n    elsif\
    \ num.to_s.length - i == 2\n      if num.to_s[i].to_s == hex_key.to_s\n      \
    \  hex_key += 1\n      end\n    end\n    i += 1\n  end\n  hex_key\nend\n</cell>\n\
    <cell>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
