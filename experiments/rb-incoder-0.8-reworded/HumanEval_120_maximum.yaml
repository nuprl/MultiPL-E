name: HumanEval_120_maximum
language: rb
prompt: "# Given an array arr of integers and a positive integer k, return a sorted\
  \ array \n# of length k with the maximum k numbers in arr.\n# Example 1:\n# >>>\
  \ maximum.call([-3, -4, 5], 3)\n# [-4, -3, 5]\n# Example 2:\n# >>> maximum.call([4,\
  \ -4, 4], 2)\n# [4, 4]\n# Example 3:\n# >>> maximum.call([-3, 2, 1, 2, -1, -2, 1],\
  \ 1)\n# [2]\n# Note:\n# 1. The length of the array will be in the range of [1, 1000].\n\
  # 2. The elements in the array will be in the range of [-1000, 1000].\n# 3. 0 <=\
  \ k <= len(arr)\ndef maximum(arr, k)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_maximum\n\
  \    candidate = method(:maximum)\n    assert_equal([-4, -3, 5], candidate.call([-3,\
  \ -4, 5], 3))\n    assert_equal([4, 4], candidate.call([4, -4, 4], 2))\n    assert_equal([2],\
  \ candidate.call([-3, 2, 1, 2, -1, -2, 1], 1))\n    assert_equal([2, 20, 123], candidate.call([123,\
  \ -123, 20, 0, 1, 2, -3], 3))\n    assert_equal([0, 1, 2, 20], candidate.call([-123,\
  \ 20, 0, 1, 2, -3], 4))\n    assert_equal([-13, -8, 0, 0, 3, 5, 15], candidate.call([5,\
  \ 15, 0, 3, -13, -8, 0], 7))\n    assert_equal([3, 5], candidate.call([-1, 0, 2,\
  \ 5, 3, -10], 2))\n    assert_equal([5], candidate.call([1, 0, 5, -7], 1))\n   \
  \ assert_equal([-4, 4], candidate.call([4, -4], 2))\n    assert_equal([-10, 10],\
  \ candidate.call([-10, 10], 2))\n    assert_equal([], candidate.call([1, 2, 3, -23,\
  \ 243, -400, 0], 0))\n  end\nend\n"
completions: ["  return arr.reduce(:<)\nend", "  result = arr.dup.sort\n  return result[k..-1]\
    \ if result and k > 0 \n  result\nend", "  arr.sort!\n  k\nend", "  sorted = []\n\
    \  arr.each do |x|\n    sorted.push(x)\n  end", "    arr.sort!\n    l = arr.size\n\
    \    result = []\n    for i in 0...l\n        result << arr[i...l] if l - i >=k\
    \ \n    end\n    result\nend\n</cell>\n<code language=julia-0.4>\nmaximum(maximum(maximum(maximum([4,\
    \ -4, 4], 2), 3), 5), 3)\n</cell>\n<code language=julia-0.4>\nmaximum(maximum(maximum([4,\
    \ -4, 4], 2), 3), 0)\n</cell>\n<code language=julia-0.4>\nmaximum(maximum(maximum([4,\
    \ -4, 4], 2), 3), 2)\n</cell>\n<code language=julia-0.4>\nmaximum(maximum(maximum([4,\
    \ -4, 4], 2), 3), 1)\n</cell>\n<code language=julia-0.4>\nmaximum(maximum(maximum([4,\
    \ -4, 4], 2), 3), 4)\n</cell>\n<text>\nmaximum.call \u6700\u5927\u503C \u7684\u51FD\
    \u6570 maximum.call \u6700\u5927\u503C \u7684\u51FD\u6570 \u6700\u5927\u503C \u7684\
    \u51FD\u6570 \u6700\u5927\u503C \u7684\u51FD\u6570 \u6700\u5927\u503C \u7684\u51FD\
    \u6570 \u6700\u5927\u503C \u7684\u51FD\u6570 \u6700\u5927\u503C \u7684\u51FD\u6570\
    \ \u6700\u5927\u503C \u7684\u51FD\u6570 \u6700\u5927\u503C \u7684\u51FD\u6570\
    \ \u6700\u5927\u503C \u7684\u51FD\u6570 \u6700\u5927\u503C \u7684\u51FD\u6570\
    \ \u6700\u5927\u503C \u7684\u51FD\u6570 \u6700\u5927\u503C \u7684\u51FD\u6570\
    \ \u6700\u5927\u503C \u7684\u51FD\u6570 \u6700\u5927\u503C \u7684\u51FD\u6570\
    \ \u6700\u5927\u503C \u7684\u51FD\u6570 \u6700\u5927\u503C \u7684\u51FD\u6570\
    \ \u6700\u5927\u503C \u7684\u51FD\u6570 \u6700\u5927\u503C \u7684\u51FD\u6570\
    \ \u6700\u5927\u503C \u7684\u51FD\u6570 \u6700\u5927\u503C \u7684\u51FD\u6570\
    \ \u6700\u5927\u503C \u7684\u51FD\u6570 \u6700\u5927\u503C \u7684\u51FD\u6570\
    \ \u6700\u5927\u503C \u7684\u51FD\u6570 \u6700\u5927\u503C \u7684\u51FD\u6570\
    \ \u6700\u5927\u503C \u7684\u51FD\u6570 \u6700\u5927\u503C \u7684\u51FD\u6570\
    \ \u6700\u5927\u503C \u7684\u51FD\u6570 \u6700\u5927\u503C \u7684\u51FD\u6570\
    \ \u6700\u5927\u503C \u7684\u51FD\u6570 \u6700\u5927\u503C \u7684\u51FD\u6570\
    \ \u6700\u5927\u503C \u7684\u51FD\u6570 \u6700\u5927\u503C \u7684\u51FD\u6570\
    \ \u6700\u5927\u503C \u7684\u51FD\u6570 \u6700\u5927\u503C \u7684\u51FD\u6570\
    \ \u6700\u5927\u503C \u7684\u51FD\u6570 \u6700\u5927\u503C \u7684\u51FD\u6570\
    \ \u6700\u5927\u503C \u7684\u51FD\u6570 \u6700\u5927\u503C \u7684\u51FD\u6570\
    \ \u6700\u5927\u503C \u7684\u51FD\u6570 \u6700\u5927\u503C \u7684\u51FD\u6570\
    \ \u6700\u5927\u503C \u7684\u51FD\u6570 \u6700\u5927\u503C \u7684\u51FD\u6570\
    \ \u6700\u5927\u503C \u7684\u51FD\u6570 \u6700\u5927\u503C \u7684\u51FD\u6570\
    \ \u6700\u5927\u503C \u7684\u51FD\u6570 \u6700\u5927\u503C \u7684\u51FD\u6570\
    \ \u6700\u5927\u503C \u7684\u51FD\u6570 \u6700\u5927\u503C \u7684\u51FD\u6570\
    \ \u6700\u5927\u503C \u7684\u51FD\u6570 ", "    l = k\n    for i in arr\n    \
    \    l =\n        arr\n        ", "  # write your code here\n  max_arr = []\n\
    \  i = 0\n  while i < k\n    max_arr << arr[i]\n    i += 1\n  end", "    arr.sort.reverse\n\
    \    arr.slice!(0, k+1)\n    arr.sort\n    arr\nend", "    arr.sort!\n    arr.length\
    \ == k? arr : arr[1..k-1]\nend", "    arr.sort!\n    return arr[0...k] if k <=\
    \ arr.length else arr\nend", "  return arr.sort.take_while { |x| x <  k }.concat(arr.sort.take_while\
    \ { |x| x > k })\nend", "  arr.sort!\n  arr.length.times { arr.pop }\n  return\
    \ arr[0...k]\nend", "  return arr.sort_by { |x| x.to_i }.take(k)\nend\n</cell>\n\
    <cell>", "  return arr.sort[-k]\nend\n</cell>\n<code language=julia-1.0>\n@test\
    \ maximum([-3, -4, 5], 3) == [-4, -3, 5]\n@test maximum([4, -4, 4], 2) == [4,\
    \ 4]\n@test maximum([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n</cell>\n<code language=julia-1.0>\n\
    maximum([-3, -4, 5], 3)\nmaximum([4, -4, 4], 2)\nmaximum([-3, 2, 1, 2, -1, -2,\
    \ 1], 1)\n</cell>\n<text>\nminimum", "  arr.sort!\n  arr.delete_at(k - 1)\n  arr\n\
    end", "  # Write your code here\n  return arr[-k..-1] if arr.size >= k && k >\
    \ 0 else  arr\nend", "  return nil if arr.size < 1 || k <= 0\n  return arr if\
    \ k == 1\n  \n  sorted_arr = arr.sort\n  \n  max_val = nil\n  max_idx = -1\n \
    \ \n  (0...arr.size).each do |i|\n    if i == 0\n      max_val = sorted_arr[i]\n\
    \      max_idx = i\n    elsif max_val < sorted_arr[i]\n      max_val = sorted_arr[i]\n\
    \      max_idx = i\n    end\n  end\n  \n  return sorted_arr[max_idx + 1 .. k]\
    \ if max_idx == -1\n  return sorted_arr[0...max_idx] if k == max_idx\nend", " \
    \ return arr.reduce(:<<) << (arr.length - (k - 1))\nend", "  arr.sort!\n  return\
    \ arr[0..k] if k <= arr.size && arr[0..k].max == arr[0..k].min end\nend", "  arr.sort!\n\
    \  return arr[0...k] \nend", "  arr << 0\n  i <<0\n  j <<0\n  max_number <<0\n\
    \  while i < k\n    max_number << arr[i]\n    i <<+ 1\n    j <<+ 1\n    i <<<\
    \ arr.length\n    j <<< arr.length\n    i <<< arr.length\n    j <<< arr.length\n\
    \    arr <<< arr.length\n  end while\n  arr.sort {|a, b| b <=> a}\n  return arr[0...k]\n\
    end", "    return arr\nend", "  result = [0] * (k+1)\n  arr.each_with_index do\
    \ |num, index|\n    maximum[index] = result if maximum[index] < num\n    result[index]\
    \ = num if num > result[index]\n  end\n  result\nend", "  if arr.size == 0\n \
    \   raise \"The length of arr is 0\"\n  if k < 1 or k > arr.size\n    raise \"\
    Invalid k\"\n  if k >= arr.size\n    return arr\n  arr_new = []\n  max_idx = -1\n\
    \  for i in (arr.length() - 1) downto 1 by -1\n    if arr[i].max < arr[i - 1].max\n\
    \      arr_new.push arr[i - 1].max\n      max_idx = i\n    end\n  end\n  if arr_new.size\
    \ < k\n    arr_new.push arr[max_idx].max\n  end\n  return arr_new\nend", "  return\
    \ k ? arr.sort_by{ |x| -x }.first(-k..-1).reverse : arr\nend\n</cell>\n<code language=conda-env-adventofcode-py>",
  "  arr.sort\n  return arr[0...k]\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\nI solved\
    \ this problem using recursion\n<code>", "  arr.sort!\n  return arr[0...k] if\
    \ arr.size >= k and k <= arr.size\nend", "  return arr.sort[1..k]\nend", "   \
    \ return arr.sort[-k]\nend", "  max_arr = [0]*k\n  arr.sort\n  max_arr[0] = arr[0]\n\
    \  max_arr[1] = arr[1]\n  arr.size.times do |i|\n    max_arr[i] = max_arr[i-1]\
    \ if i < k\n  end\n  max_arr\nend", "  arr.sort!\n  result = []\n  (1..k).each\
    \ do |i|\n    if arr[i-1] < arr[i]\n      result << arr[i-1]\n      arr.delete_at(i\
    \ - 1)\n    else\n      result << arr[i]\n      arr.delete_at(i)\n    end\n  end\n\
    \  result + arr\nend", "  max = arr.dup\n  for i in 0..k-1\n    max.delete_at(0)\n\
    \  for i in 0..k-1\n    max[i] = max[i-1] if i < k-1 else max[i]\n  max\nend\n\
    </cell>\n<code language=julia-0.6>\nmaximum(arr, 3)\n</cell>\n<code language=julia-0.6>\n\
    maximum(arr, 2)\n</cell>\n<code language=julia-0.6>\nmaximum(arr, 1)\n</cell>\n\
    <text>\nImplement the maximumBy macro\nImplement the maximumBy macro that will\
    \ take two arguments:", "  if k < 1 or k > len(arr)\n    throw \"Invalid input\"\
    \n  end\n  max_list = Array.new(k+1)\n  max_list[0] = arr[0]\n  i = 1\n  while\
    \ i < k\n    if arr[i] > max_list[0]\n      max_list[0] = arr[i]\n    end\n  \
    \  i += 1\n  end\n  return max_list\nend", "  return arr[0..k].sort\nend", "\t\
    arr.sort!\n\treturn arr[0..k-2]\nend", "    arr.sort!\n    \n    result = []\n\
    \    arr.take(k)\n    \n    return result\nend", "    return arr[0,k-1] if k >\
    \ 0 and k <= length(arr) else\n           arr\nend", "  return arr.max_by { |x|\
    \ x[k] }\nend", "  arr.sort!\n  return arr.take(k).sort\nend\n</code>\n<|/ a tags=ruby\
    \ dscore=2 |>\n<| c |>\nThis is O(n^2) when n is the size of the array. Not a\
    \ good answer.\n<|/ c |>\n<| c |>\nIt's O(n * log n) which is better than O(n^2).\n\
    <|/ c |>\n<| c |>\n, O(n * log n) does not mean it's better than O(n^2), it means\
    \ it's better for large n. The question specifically asks for the highest k numbers\
    \ in the array and you only get O(n) time complexity from sort.\n<|/ c |>\n<|\
    \ c |>\n- I stand corrected. However, the question asks for an algorithm. Sorting\
    \ the array is O(n*log n) whereas getting the maximum is O(n).\n<|/ c |>\n<| a\
    \ dscore=1 |>\nHere's a solution without having to sort all n numbers:\n<code>",
  "    # write your code here\n    arr.sort\n    return arr[k-1] if k > 0 else arr\n\
    end\n</cell>\n<code language=julia-1.5>\nmaximum(maximum(maximum(maximum(maximum(maximum(maximum(maximum([-3,-4,5]),\n\
    \                               maximum([-4,-4,4]),\n                        \
    \       maximum([5,4,-3]),\n                               maximum([-5,5,-5])),\
    \ 3), 2), 2), 1),2),1),1)\n</cell>\n<code language=julia-1.5>\nmaximum(maximum(maximum(maximum(maximum(maximum(maximum(maximum(maximum([-3,2,1,2,-1,-2,1]),\n\
    \                               maximum([4,-4,4]),\n                         \
    \      maximum([-5,5,-5]),\n                               maximum([-5,5,-5])))\n\
    \                               ), 3), 2), 2), 1),2),1),1)\n</cell>\n<code language=julia-1.5>\n\
    maximum(maximum(maximum(maximum(maximum(maximum(maximum(maximum(maximum(maximum([4,-4,4]),\n\
    \                               maximum([-5,5,-5]),\n                        \
    \       maximum([-5,5,-5]),\n                               maximum([-5,5,-5]),\n\
    \                               maximum([-5,5,-5]),\n                        \
    \       maximum([-5,5,-5]),\n                               maximum([-5,5,-5]),\n\
    \                               maximum([-5,5,-5])), 3), 2), 2), 1), 2),1),1),1),1)\n\
    </cell>\n<code language=julia-1.5>\nmaximum(maximum(maximum(maximum(maximum(maximum(maximum(maximum(maximum([4,-4,4]),\n\
    \                               maximum([-5,5,-5]),\n                        \
    \       maximum([-5,5,-5]),\n                               maximum([-5,5,-5]),\n\
    \                               maximum([-5,5,-5]),\n                        \
    \       maximum([-5,5,-5]),\n                               maximum([-5,5,-5]),\n\
    \                               maximum([-5,5,-5]),\n                        \
    \       maximum([-5,5,-5]),\n                               maximum([-5,5,-5])),\
    \ 3), 2), 2), 2), 1), 2),1),1),1),1)\n</cell>\n<code language=julia-1.5>\nmaximum(maximum(maximum(maximum(maximum(maximum(maximum(maximum([4,-4,4]),\n\
    \                               maximum([-5,5,-5]),\n                        \
    \       maximum([-5,5,-5]),\n                               maximum([-5,5,-5]),\n\
    \                               maximum([-5,5,-5]),\n                        \
    \       maximum([-5,5,-5]),\n                               maximum([-5,5,-5]),\n\
    \                               maximum([-5,5,-5]),\n                        \
    \       maximum([-5,5,-5]),\n                               maximum([-5,5,-5]),\n\
    \                               maximum([-5,5,-5])), 3), 2), 2), 2), 1), 2),",
  "    max = arr[0]\n    i = 1\n    while i < k and i < arr.length\n        if max\
    \ < arr[i]\n            max = arr[i]\n        end\n        i += 1\n    end\n \
    \   if i < k\n        max += arr[i..k]\n    end\n    max\nend", "  array.sort(arr)\n\
    \  return arr[-k..-1]\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| a tags=ruby,sorting,arrays\
    \ dscore=4 |>\nHere is a solution in Ruby using inject:\n<code>", "  \n  # Initialize\
    \ a temporary array whose size is k\n  temp_arr = []", "  return arr.sort.last(k).reverse.first(k)\
    \ if k > 0\n  arr.sort.last(k).reverse.first(k) if k == 0\n  []\nend", "    \n\
    \    # Write your code here.\n    arr.sort\n    if k > len(arr):\n        return\
    \ arr\n    else:\n        return arr[-k:]\n        \n</cell>\n<cell>\nmaximum([1,\
    \ 2, 3, 4], 2)\n</cell>\n<text>\n4. For a given array, arr, of size n, return\
    \ the product of its elements arr[0] to arr[n-1].\nExample 1:", "  arr = arr.sort\n\
    \  arr.length == k\n  return arr\nend\n</cell>\n<text>\n13. Find First Set Bit",
  "  arr = arr.sort\n  arr.delete_if { |x| x < -999 || x > 999 }\n  return arr[-k]\n\
    end", "\tresult = [0] * k\n\tcount = 0\n\tfor i in arr\n\t\tresult[i] = max\n\t\
    for i in result\n\t\tcount += 1\n\treturn result", "    answer = []\n    while\
    \ k <= length(arr) do\n        answer.push(arr.pop)\n        k -= 1\n    end\n\
    \    answer.reverse\nend\n</cell>\n<cell>\nmaximum(arr, 2)\n</cell>\n<text>\n\
    7. Subarray\nGiven an integer array nums and an integer index, return the sum\
    \ of all numbers in the subarray from nums[index] to nums[index + 1].", "  arr\
    \ = arr.sort\n  arr[0..(arr.length - k)].max\nend\n</code>\n<|/ a |>\n<| c |>\n\
    Thank you for providing a solution that does work.  Can you explain what you mean\
    \ by the following in your code (I'm still trying to wrap my head around this):\
    \  arr = arr.sort\n  arr[0..(arr.length - k)].max\n<|/ c |>\n<| c |>\nIn Ruby\
    \ `sort` sorts the array and returns it. When you say `arr[0..(arr.length - k)].max`,\
    \ you are getting the maximum of the first k elements in `arr`. What is confusing\
    \ you about that?\n<|/ c |>\n<| c |>\nI'm still confused about why this would\
    \ work, but I see it makes sense now.  Thanks for the explanation.\n<|/ c |>\n\
    <| c |>\nThis algorithm is very inefficient. Sorting takes O(n log n), and the\
    \ `max` takes O(n). A better approach would be to find the maximum of the first\
    \ k elements (without sorting), then repeatedly find a new maximum of the next\
    \ k elements, and so on. Then, all you would need is `arr[k..-1].max`.\n<|/ c\
    \ |>\n<| a |>\nHere is my solution: \n<code>", "    return arr[0...k].sort {|x,y|\
    \ x > y ? 1 : x > y ? -1 : 0}[0...k]\nend", "\tmax_val = arr[0]\n\tfor i in 0..k-1\n\
    \t\tif arr[i] > max_val\n\t\t\tmax_val = arr[i]\n\t\tend\n\tend\n\tmax_arr = []\n\
    \tfor i in 0..k-1\n\t\tmax_arr[i] = max_val\n\tend\n\treturn max_arr\nend", " \
    \ return arr.reduce do |memo, element|\n    memo << (memo.length >= k ? memo[k]\
    \ : element)\n    memo\n  end\nend\n</cell>\n<cell>\nmaximum(arr, k)\n</cell>\n\
    <cell>", "  (0..k).map { |i| arr[i] }.sort\nend", "    # write your code here\n\
    \    maximum = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] > maximum:\n\
    \            maximum = arr[i]\n    if k == len(arr):\n        ans = [maximum]\n\
    \    elif k == 1:\n        ans = [maximum]\n    else:\n        ans = []\n    \
    \    for i in range(len(arr)):\n            index = i\n            for j in range(len(arr)\
    \ - 1, i, -1):\n                if arr[j - 1] > arr[index]:\n                \
    \    index = j\n            ans.append(arr[index])\n    return ans\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis algorithm will take O(N^2) time. Can we do it\
    \ with O(N) time complexity ?\n<|/ c |>\n<| c |>\nIt can be done with O(N) time\
    \ complexity using the same idea.\n<|/ c |>\n<| a |>\n<code>\npublic static void\
    \ main(String args[]){", "    \n    arr = arr[0..k-1]\n    arr.sort!\n    \n \
    \   arr.inject do |memo, num| \n        if memo > num then memo \n        else\
    \ num\n        end\n    end\nend", "  # Get the minimum length\n  length = arr.length\n\
    \  \n  # Sort the array in descending order\n  arr.sort(reverse=True)\n  \n  #\
    \ Get a range from the minimum length array to the maximum length array\n  range\
    \ = arr[length-k..length]\n  \n  # Return the range of array with the maximum\
    \ k numbers\n  return range\nend", "  result = []\n  if arr.length < k then\n\
    \    arr = arr.reverse\n    result = [arr[0]] * k\n  else\n    arr.each do |x|\n\
    \      max = -1\n      i = k\n      while i >= 1 and x < array[i]\n        i =\
    \ i - 1\n      end\n      if i >= 1 then\n        result.push(array[i])\n    \
    \  end\n    end\n  end\n  result.reverse\nend", "  arr.sort!\n  res = []\n  (arr.length\
    \ - 1).downto(k) do |i|\n    res.push(arr[i])\n  end\n  res\nend\n</code>\n<|/\
    \ a dscore=0 |>\n<| a tags=sorting,ruby |>\nHere is another way to achieve the\
    \ same.\n<code>", "  result = arr.dup\n  result.length = k", "  arr.sort!\n  return\
    \ arr[0,k]\nend", "    # Write your code here.\n    max = arr[0]\n    for x in\
    \ range(1, k):\n        if arr[x] > max:\n            max = arr[x]\n    for i\
    \ in range(k):\n        arr[i] = max", "  return max_by_k(arr, k)\nend", "  arr.sort!\n\
    \  return arr[0..(arr.length-k)]\nend\n</code>\n<|/ a tags=ruby,arrays dscore=1\
    \ |>\n<| a dscore=1 |>\nThe simplest way in Ruby is to simply reverse the array:\n\
    <code>\narray.reverse\n</code>\n<|/ a tags=ruby,arrays |>\n<| a |>\nHere is another\
    \ solution using Enumerable#max:\n<code>", "    arr.sort\n    maxArr = []\n  \
    \  (maxArr.length = k)\n    (maxArr << arr.take_while {|x| x < 0})\n    maxArr\n\
    end\n</cell>\n<code language=julia-0.6>\nmaximum(arr, k)\n</cell>\n<text>\n\u6700\
    \u5C0F\u503C", "  return arr.reduce(:+)\nend", "  if k > length(arr) or k == 0\n\
    \    return arr\n  else\n    return maximum(maximum(arr, k-1), k)\n  end\nend",
  "  # Write your code here.\n  return arr.max(n)", "  return arr.reverse if k ==\
    \ arr.length || k < 0 || k > arr.length else arr.\nend", "    len = arr.length\n\
    \    if k > len\n        return arr\n    \n    arr.sort!\n    arr.slice(0, k).each\
    \ do |i|\n        if i == arr[k]\n            arr.delete(k)\n            break\n\
    \        end\n    end\n    arr\nend", "  arr.sort! \n  (0...k).to_a.select { |i|\
    \ arr[i] >= arr[-i] }\nend\n</cell>\n<cell>\narr = [-10, -9, -8, -7, -6, -5, -4,\
    \ -3, -2, -1]\nk = 3\nmaximum(arr, k)\n</cell>\n<cell>\narr = [-10, -9, -8, -7,\
    \ -6, -5, -4, -3, -2, -1]\nk = 4\nmaximum(arr, k)\n</cell>\n<cell>\narr = [-3,\
    \ -4, 5]\nk = 3\nmaximum(arr, k)\n</cell>\n<cell>\narr = [4, -4, 4]\nk = 2\nmaximum(arr,\
    \ k)\n</cell>\n<cell>\narr = [-3, 2, 1, 2, -1, -2, 1]\nk = 1\nmaximum(arr, k)\n\
    </cell>\n<text>\nGiven two arrays nums1 and nums2, return the product of nums1.",
  "  arr.sort!\n  max_len = k\n  max_len.times do\n    if max_len == 0 then\n    \
    \  break\n    elsif max_len == 1 then\n      return arr\n    end\n    break if\
    \ arr[k-1] > arr[k]\n    max_len = max_len - 1\n  end\n  arr[0...max_len, k-1]\n\
    end\n</pre>\n</div>\n</div>\n</div>\n</div>\n<div id='actions'>\n<h2>Solution</h2>\n\
    <pre>", "  result = arr.dup\n  (0...k).each do |i|\n    result.sort!.last = (i\
    \ < (result.length - 1)) ? result[i+1..-1].max : result.max\n  end\n  result\n\
    end", "  \n  # Sort the array in descending order\n  arr.sort { |a, b| b - a } ",
  "    arr.sort! \n    arr.slice!(0, k)\nend\n</cell>\n<cell>\nmaximum(arr, k)\n</cell>\n\
    <cell>", "  sorted = arr.sort\n  max_elements = nil\n  maximums = []\n  i = 0\n\
    \  while i < k \n    max_elements = sorted[i]\n    i += 1\n    if i >= k\n   \
    \   maximums << max_elements\n    end\n  end\n  maximums\nend", "  # Write your\
    \ code here\n  sorted = []\n  m = arr.size\n  if k > m\n    sorted = arr\n  elsif\
    \ k < m\n    sorted = [arr[m-1]]\n  elsif k == m\n    sorted = arr\n  else\n \
    \   max_i = 0\n    max_j = m-1\n    while max_i < max_j\n      mid = (max_i +\
    \ max_j) // 2\n      if arr[mid] >= k\n        max_i = mid + 1\n      else\n \
    \       max_j = mid\n      end\n    end\n    sorted = arr[max_i..m]\n  end\n \
    \ \n  sorted = sorted.sort\n  \n  return sorted.reverse\nend", "  # Write your\
    \ code here\n  result = nil\n  \n  arr = [arr[0]] + arr[k] if k <= 0\n  arr.sort.reverse_each\
    \ do |value|\n    result ||= []\n    result << value if result.size < k\n  end\n\
    \  result\nend\n</cell>\n<cell>", "    max = arr[0]\n    l = -1\n    r = k\n \
    \   while r <= len(arr)\n        min = arr[r]\n        while r > l\n         \
    \   diff = arr[l] - min\n            if diff > max\n                max = diff\n\
    \            l += 1\n        while l > r\n            diff = min - arr[l - 1]\n\
    \            if diff > max\n                max = diff\n            r -= 1\n \
    \       l += 1\n        r -= 1\n    return arr", "    max = nil\n    arr.each\
    \ do |i|\n        if i > max\n            max = i\n        end\n    end\n    return\
    \ max\nend", "  \n    # write your code here\n  \nend", "  maximums =  [ ]\n \
    \ i = 0\n  while i < k\n    maximums << Math.max(arr[i], maximums[i])\n    i +=\
    \ 1\n  end\n  return maximums\nend", "  \n  # Fill this in.\n  max = []\n  \n\
    \  # Fill this in.\n  i = 0\n  \n  while i < k\n    # Fill this in.\n    max =\
    \ arr[i] if arr[i] < max[i - 1] else max[i - 1]\n    i += 1\n  \n  return max\n\
    end", "  return arr.sort[-k..-1]\nend", "  a = arr.sort\n  p =\nend\n</cell>\n\
    <text>\nmaxmin\nQuestion:\nDefine a Ruby function maxmin that takes as input two\
    \ sorted arrays of integers and returns two sorted arrays of integers. The first\
    \ array contains all of the elements from the first array that appears in the\
    \ second array. The second array contains all of the elements from the second\
    \ array that appears in the first array. The elements that are common between\
    \ the two arrays appear as common elements in the two arrays.\nExample 1:\n>>>\
    \ maxmin.call([4, -4, 4], [-4, 4])\n[[-4, 4], [4]]\nExample 2:\n>>> maxmin.call([5,\
    \ -4, 4], [-4, 5])\n[[-4, 4], [5]]\nExample 3:\n>>> maxmin.call([4, -4, -4], [-4,\
    \ 4])\n[[-4, 4], [-4]]\nNote:\nThe length of the arrays will be in the range of\
    \ [1, 1000].\nThe elements in the arrays will be in the range of [-1000, 1000].\n\
    0 <= len(arr1) <= len(arr2)\n0 <= arr1[i] < arr2[i]\nSolution:", "  puts arr\n\
    \  puts k\n  puts arr.length\n  if k > arr.length\n    puts k\n    puts arr.length\n\
    \    puts arr\n    return []\n  end\n  result = []\n  for i in 0..(arr.length-k)\n\
    \    result[i] = arr.slice(i,i+k)\n  end\n  result.sort!\n  puts result\n  return\
    \ result\nend", "  arr_length = arr.length\n  arr.sort!\n  maximum_list = []",
  "  # Your code here\n  arr.sort\n  \n  result = []\n  i = 0\n  while i < k\n   \
    \ result << arr[i]\n    i += 1\n  end\n  \n  result\nend", "  arr.sort!\n  ret\
    \ = []\n  arr.each do |val|\n    break val if k == 0 || (k == 0 && val > 0)\n\
    \    k -= 1\n  end\n  ret\nend", "  arr.sort\n  arr.take_while{|x| x > 0}\nend",
  "  arr.sort!\n  (arr.length >= k) ? arr[0..k] : []\nend", "  p =arr.length\n  arr.sort!\n\
    \  (k>p?0:k).times do |x|\n    arr[x]=arr[x-1] if x>0\n    arr[x]=arr[x] if x<p\n\
    \    p -= 1\n  end\n  arr\nend\nend", "  arr.sort!\n  ret = []\n  i = 0\n  while\
    \ i < k && i < arr.length\n    max = arr[i]\n    if max - arr[i-1] > ret[-1]\n\
    \      ret << max - arr[i-1]\n      arr[i-1] = max\n    end\n    i += 1\n  end\n\
    \  ret << arr.max\n  arr.pop\n  ret\nend", "  arr.sort! \n  arr[0...k-1]\nend",
  "    puts arr\n    puts k\n    arr.sort {|x, y| (y > x) ? (x > y ? -1 : 1) : (x\
    \ > y ? 1 : -1)}\n    if k == 1\n        return arr\n    end\n    maximum.call([arr[0..k-1]],\
    \ k-1) if k > 1\n    return arr\nend", "  arr.each_with_index.select { |v, i|\
    \ v > arr[k - i + 1] } \nend", "    arr_size = arr.size\n    if arr_size <= 1\n\
    \        return [arr]\n    max_array = []\n    max_value = arr[0]\n    index =\
    \ arr_size\n    i = arr_size\n    while i > 0\n        max_value = arr[i]\n  \
    \      index = index - 1\n        i -= 1\n        if index == 0\n            max_array\
    \ << max_value\n            index = arr_size\n        end\n    end\n    max_array\
    \ << max_value\n    i = arr_size\n    while k > 1\n        i -= 1\n        max_value\
    \ = arr[i]\n        max_array << max_value\n        k -= 1\n    end\n    return\
    \ max_array\nend", "  arr ||= []\n  k ||= 0\n  arr.length.times do |i|\n    if\
    \ arr[i] > arr[i+1]\n      arr[i], arr[i+1] = arr[i+1], arr[i]\n    end\n  end\n\
    \  arr\nend", "    arr.sort!\n    arr = arr[0...k]\n    return arr\nend", "  max\
    \ = arr[0]\n  i = 0\n  while i + 1 < k and arr[i] < arr[i + 1]\n    i += 1\n \
    \ while i < k\n    max = max > arr[i] ? max : arr[i]\n    i += 1\n  arr[k - i\
    \ - 1] = max\nend", "  return arr.sort.take_while{|x| x <= arr.last}.take(k).reverse\n\
    end", "    if k < 1 or k > length(arr)\n        raise ArgumentError\n    result\
    \ = []\n    arr.each do |x|\n        if x > result[-1]\n            result <<\
    \ x\n        end\n    end\n    result\nend", "  max = arr[0]\n  for i in arr[0..k-1]\n\
    \    if i > max\n      max = i\n  arr[0..k-1] = arr[0..k-1].sort { |a, b| a <=>\
    \ b }\n  arr[0..k-1]\nend", "  k = k % arr.size\n  max_array = []\n  for i in\
    \ 0...k\n    max_array << arr.sort{|a, b| (a <=> b) <=> 0}[i]\n  end\n  max_array\n\
    end", "  return sort.call(arr, k) if k == 1 || k == length(arr) \n  # otherwise,\
    \ get the max element and remove the k largest elements from the array\n  max_element\
    \ = arr[0]\n  max_index = 0\n  \n  # iterate over the array\n  arr.each do |i|\n\
    \    if i > max_element\n      max_element = i\n      max_index = arr.index(i)\n\
    \    end\n  end\n  \n  # remove k largest elements \n  arr[max_index + 1 .. k].each\
    \ do |i|\n    arr[i] = arr[i].max\n  end\n  \n  arr\nend", "  # code here\n  maximum\
    \ = []\n  i = 0\n  while i < k\n    max_element = arr[i]\n    max_index = 0\n\
    \    flag = True\n    for j in arr\n      if(j < max_element)\n        flag =\
    \ False\n        break\n      end\n    end\n    if(flag)\n      maximum.push(max_element)\n\
    \    end\n    i += 1\n  end\n  return maximum\nend", "    arr.sort!\n    i = 0\n\
    \    \n    # return empty array when k is not in the range of [1, arr.length]\n\
    \    # return arr when k is in the range of [1, arr.length]\n    if k < 1 || k\
    \ >= arr.length\n        return arr\n    end\n    \n    # return the maximum of\
    \ two elements if k == 2\n    if k == 2\n        return arr[0] if arr[0] > arr[1]\n\
    \        return arr[1] if arr[0] < arr[1]\n    end\n    \n    # return the maximum\
    \ of three elements if k == 3\n    if k == 3\n        return arr[0] if arr[0]\
    \ > arr[1] && arr[0] > arr[2]\n        return arr[1] if arr[0] > arr[1] && arr[1]\
    \ > arr[2]\n        return arr[2] if arr[0] > arr[1] && arr[1] < arr[2]\n    \
    \    return arr[0] if arr[0] < arr[1] && arr[0] < arr[2]\n        return arr[1]\
    \ if arr[1] > arr[0] && arr[1] < arr[2]\n        return arr[2] if arr[1] > arr[0]\
    \ && arr[1] > arr[2]\n    end\n    \n    # return the maximum of four elements\
    \ if k == 4\n    if k == 4\n        return arr[0] if arr[0] > arr[1] && arr[0]\
    \ > arr[2] && arr[0] > arr[3]\n        return arr[1] if arr[0] > arr[1] && arr[1]\
    \ > arr[2] && arr[1] > arr[3]\n        return arr[2] if arr[0] > arr[1] && arr[1]\
    \ > arr[2] && arr[1] < arr[3]\n        return arr[3] if arr[0] > arr[1] && arr[2]\
    \ > arr[1] && arr[2] < arr[3]\n        return arr[0] if arr[0] < arr[1] && arr[0]\
    \ < arr[2] && arr[0] < arr[3]\n        return arr[1] if arr[1] > arr[0] && arr[1]\
    \ > arr[2] && arr[1] > arr[3]\n        return arr[2] if arr[1] > arr[0] && arr[1]\
    \ > arr[2] && arr[1] < arr[3]\n        return arr[3] if arr[1] > arr[0] && arr[2]\
    \ > arr[0] && arr[2] > arr[3]\n        return arr[4] if arr[2] > arr[0] && arr[2]\
    \ > arr[1] && arr[2] > arr[3]\n    end\n    \n    # return the maximum of five\
    \ elements if k == 5\n    if k == 5\n        return arr[0] if arr[0] > arr[1]\
    \ && arr[0] > arr[2] && arr[0] > arr[3] && arr[0] > arr[4]\n        return arr[1]\
    \ if arr[0] > arr[1] && arr[1] > arr[2] && arr[1] > arr[3] && arr[1] > arr[4]\n\
    \        return arr[2] if arr[0] > arr[1] && arr[1] > arr[2] && arr[1] > arr",
  "  arr.sort!\n  return arr[0...k]\nend", "  return arr.reduce {|memo, num| memo.last\
    \ > num ? memo : [num] << memo}[0..k-1]\nend", "  arr = arr.sort{|a, b| b <=>\
    \ a} if k <= arr.length \n  arr.last(k) if k <= arr.length\nend\n</cell>\n<text>\n\
    \U0001F3C6 Challenge 3", "  return arr[0, k]\nend", "  if k == 0 then return arr\n\
    \  m = nil\n  for i in 0...k\n    if mnil? m then m = arr[i]\n    else if arr[i]\
    \ > m then m = arr[i]\n    end\n  end\n  return m\nend", "  result = arr.dup\n\
    \  if k > 0\n    result.sort!\n    result.rotate!(k)\n  elsif k == 0\n    result\n\
    \  else\n    result.reverse!\n    result.reduce!{|x, y| y if x < y ? x : y}.reverse!\n\
    \    result\n  end\nend", "\tl = nil\n\tn = arr.count\n\tfor i in 0...n\n\t\t\
    puts i\n\tend\nend", "  if k > length(arr) or k == 0 then return []\n  max_element\
    \ = arr[0]\n  max_index = 0\n  for i in 1...k\n    if arr[i] > max_element then\n\
    \      max_element = arr[i]\n      max_index = i\n  end\n  for i in 1...k\n  \
    \  if arr[i] > max_element then\n      max_element = arr[i]\n      max_index =\
    \ i\n    end\n  end\n  for i in 1...k\n    if arr[i] > max_element then\n    \
    \  max_element = arr[i]\n      max_index = i\n    end\n  end\n  return arr[1...k-1]\n\
    end", "    p =[]\n    while k > 0 and arr[0] != 0\n        p << arr[0]\n     \
    \   arr.shift\n        k -= 1\n    p << arr[0]\n    return p\nend", "  # Your\
    \ code here\n  maximum = arr.dup\n  maximum.sort\n  maximum.slice!(0, k)\n  maximum\n\
    end", "  # Your code here\n  return arr\nend", "    i = j = 0\n    size = arr.size\n\
    \    max = arr[0]\n    while i < size && j < k\n        if arr[i] > max\n    \
    \        max = arr[i]\n            j = i + 1\n        elsif arr[j] > max\n   \
    \         max = arr[j]\n            i += 1\n        else\n            j += 1\n\
    \    end\n    arr[0..i-1].push(max) unless i == size and arr.size == 1\n    arr\n\
    end\n</cell>\n<code language=julia-1.2>\nmaximum(@benchmark maximum(@benchmark\
    \ maximum(@benchmark maximum(@benchmark maximum(@benchmark maximum(@benchmark\
    \ maximum(@benchmark maximum(@benchmark maximum(@benchmark maximum(@benchmark\
    \ maximum(@benchmark maximum(@benchmark maximum(@benchmark maximum(@benchmark\
    \ maximum(@benchmark maximum(@benchmark maximum(@benchmark maximum(@benchmark\
    \ maximum(@benchmark maximum(@benchmark maximum(@benchmark maximum(@benchmark\
    \ maximum(@benchmark maximum(@benchmark maximum(@benchmark maximum(@benchmark\
    \ maximum(@benchmark maximum(@benchmark maximum(@benchmark maximum(@benchmark\
    \ maximum(@benchmark maximum(@benchmark maximum(@benchmark maximum(@benchmark\
    \ maximum(@benchmark maximum(@benchmark maximum(@benchmark maximum(@benchmark\
    \ maximum(@benchmark maximum(@benchmark maximum(@benchmark maximum(@benchmark\
    \ maximum(@benchmark maximum(@benchmark maximum(@benchmark maximum(@benchmark\
    \ maximum(@benchmark maximum(@benchmark maximum(@benchmark maximum(@benchmark\
    \ maximum(@benchmark maximum(@benchmark maximum(@benchmark maximum(@benchmark\
    \ maximum(@benchmark maximum(@benchmark maximum(@benchmark maximum(@benchmark\
    \ maximum(@benchmark maximum(@benchmark maximum(@benchmark maximum(@benchmark\
    \ maximum(@benchmark maximum(@benchmark maximum(@benchmark maximum(@benchmark\
    \ maximum(@benchmark maximum(@benchmark maximum(@benchmark maximum(@benchmark\
    \ maximum(@benchmark maximum(@benchmark maximum(@benchmark maximum(@benchmark\
    \ maximum(@benchmark maximum(@benchmark maximum(@benchmark maximum(@benchmark\
    \ maximum(@benchmark maximum(@benchmark maximum(@benchmark maximum(@benchmark\
    \ maximum(@benchmark maximum(@benchmark maximum(@benchmark maximum(@benchmark\
    \ maximum(@benchmark maximum(@benchmark maximum(@benchmark maximum(@benchmark\
    \ maximum(@benchmark maximum(@benchmark maximum(@benchmark maximum(@benchmark\
    \ maximum(@benchmark maximum(@benchmark maximum(@benchmark maximum(@benchmark\
    \ maximum(@benchmark maximum(@benchmark maximum(@benchmark maximum(@benchmark\
    \ maximum(@benchmark maximum(@benchmark maximum(@benchmark", "  max = arr[0]\n\
    \  arr.each { |x| if x > max then max = x end }\n  arr.sort_by { |x| -x }\n  arr.take_while\
    \ { |x| x <= max }.to_a\nend", "  new_arr = Array.new(k) { arr[0] }\n  arr.each\
    \ { |x| new_arr[k] = x if x > new_arr[k] }\n  new_arr\nend", "  return arr.max_by\
    \ {|i| k}\nend", "  max = arr[0]\n  max_count = 0\n  for i in 1..k\n    temp_max\
    \ = max(arr[i], max)\n    if temp_max > max\n      max = temp_max\n      max_count\
    \ = i\n    else\n      break\n  max_count = k if max_count == k else max_count\n\
    \  arr.delete_at(max_count)\n  arr\nend", "  # write your code in Ruby\n  arr.sort!.reverse\n\
    \  arr[0...k-1]\nend", "  arr.sort! \n  arr.first k \nend", "    maximums = [0]\
    \ * k\n    maximums[0] = arr[0]\n    maximums.each_with_index do |cur, index|\n\
    \        max = cur\n        arr.each do |num|\n            if num > max\n    \
    \            max = num\n            end\n        end\n        maximums[index]\
    \ = max\n    end\n    return maximums\nend", "  # sort arr into ascending order\n\
    \  sorted_arr = arr.sort\n  # k must be in the range of [0, len(arr))]\n  return\
    \ sorted_arr[0...k]\nend", "  arr.sort.reverse!\n  arr.length.times do |i|\n \
    \   if i > k || arr[i] <= arr[i-1]\n      arr[i] = arr[i-1]\n    end\n  end\n\
    \  arr\nend", "  arr = arr.sort\n  return arr[0...k] if arr.size == k else arr\n\
    end", "  # Write your code here.\n  maximum = [0] * k\n  arr.each do |i|\n   \
    \ if maximum.size < i\n      maximum.push i\n    elsif maximum.size == i\n   \
    \   maximum.push i\n    end\n  end\n  maximum.sort\nend", "    arr.sort\n    return\
    \ arr[k..]\nend", "  return arr.reduce(:+)[0..k-1]\nend", "    \n    max = arr[0]\n\
    \    max_count = 0\n    \n    for num in arr:\n        if num > max:\n       \
    \     max = num\n        elif num == max:\n            max_count += 1\n      \
    \      \n    if k == 1:\n        max_count = arr.count(max)\n    elif k > 1:\n\
    \        max_count = k\n    \n    return max * max_count * -1", "  arr.sort\n\
    \  k, max_k, min_k = k, arr[0], arr[0]\n  for i in arr \n    while k > 0\n   \
    \   min_k = k if i > min_k else min_k\n      max_k = k if i < max_k else max_k\n\
    \      k -= 1\n    k += 1\n  end\n  return max_k\nend", "  max_nums = []\n  for\
    \ i in 0...k\n    max_num = arr[0]\n    for i in 0...k\n      if arr[i] > max_num\n\
    \        max_num = arr[i]\n    end\n    max_nums << max_num\n  end\n  max_nums\n\
    end", "  max_arr = arr.dup\n  max_arr.sort!\n  return max_arr.take(k).to_a if\
    \ k > 0 && k <= max_arr.length \n  max_arr.sort!\n  return max_arr.take(max_arr.length\
    \ - k).to_a\nend", "  # Get the first k numbers\n  result = arr[k..-1]\n  # Reverse\
    \ the array\n  result.reverse\n  # Find the largest number\n  result.max\nend",
  "  arr.sort!\n  arr[0..k-1]\nend", "    arr_max = arr.sort\n    arr_max.reverse\n\
    \    return arr_max[k]\n    ", "    length_arr = arr.size\n    length_max = length_arr\
    \ > k and length_arr > 0 and k > 0\n    arr = arr.sort!\n    arr.reverse!\n  \
    \  arr[k] = arr[k - 1] if length_max and length_arr > k and k > 0\n    arr\nend",
  "    arr.sort!\n    maximum = []\n    i = 0\n    if k == 0 or k > arr.size\n   \
    \     maximum.push(arr[i])\n        i += 1\n        while i < arr.size\n     \
    \       if arr[i] > maximum[-1]\n                maximum.push(arr[i])\n      \
    \      i += 1\n        return maximum\n    end\n    i = 0\n    while i < k\n \
    \       if arr[i] > maximum[-1]\n            maximum.push(arr[i])\n        i +=\
    \ 1\n    return maximum\nend\n</cell>\n<code language=julia-0.4>\nmaximum.([1,\
    \ 2, 3, 4], 3)\n</cell>\n<code language=julia-0.4>\nmaximum.([1, 2, 3, 4], 4)\n\
    </cell>\n<code language=julia-0.4>\nmaximum.([1, 2, 3, 4], 3)\n</cell>\n<code\
    \ language=julia-0.4>\nmaximum.([1, 2, 3, 4], 4)\n</cell>\n<code language=julia-0.4>\n\
    maximum.([1, 2, 3, 4], 5)\n</cell>\n<code language=julia-0.4>\nmaximum.([1, 2,\
    \ 3, 4], 6)\n</cell>\n<code language=julia-0.4>\nmaximum.([1, 2, 3, 4], 7)\n</cell>\n\
    <code language=julia-0.4>\nmaximum.([1, 2, 3, 4], 8)\n</cell>\n<code language=julia-0.4>\n\
    maximum.([1, 2, 3, 4], 10)\n</cell>\n<code language=julia-0.4>\nmaximum.([1, 2,\
    \ 3, 4], 11)\n</cell>\n<code language=julia-0.4>\nmaximum.([1, 2, 3, 4], 12)\n\
    </cell>\n<code language=julia-0.4>\nmaximum.([1, 2, 3, 4], 13)\n</cell>\n<code\
    \ language=julia-0.4>\nmaximum.([1, 2, 3, 4], 14)\n</cell>\n<code language=julia-0.4>\n\
    maximum.([1, 2, 3, 4], 15)\n</cell>\n<code language=julia-0.4>\nmaximum.([1, 2,\
    \ 3, 4], 16)\n</cell>\n<code language=julia-0.4>\nmaximum.([1, 2, 3, 4], 17)\n\
    </cell>\n<code language=julia-0.4>\nmaximum.([1, 2, 3, 4], 18)\n</cell>\n<code\
    \ language=julia-0.4>\nmaximum.([1, 2, 3, 4], 19)\n</cell>\n<code language=julia-0.4>\n\
    maximum.([1, 2, 3, 4], 20)\n</cell>\n<code language=julia-0.4>\nmaximum.([1, 2,\
    \ 3, 4], 21)\n</cell>\n<code language=julia-0.4>\nmaximum.([1, 2, 3, 4], 22)\n\
    </cell>\n<code language=julia-0.4>\nmaximum.([1, 2, 3, 4], 23)\n</cell>\n<code\
    \ language=julia-0.4>\nmaximum.([1, 2, 3, 4], 24)\n</cell>\n<code language=julia-0.4>\n\
    maximum.([1, 2, 3, 4], 25)\n</cell>\n<code language=julia-0.4>\nmaximum.([1, 2,\
    \ 3, 4], ", "  \n  max_arr = []\n  max_num = arr[0]\n  max_index = 0\n  \n  for\
    \ num in arr\n    if num > max_num\n      max_num = num\n      max_index = arr.index(num)\n\
    \    end\n  end\n  \n  for i in 0...k\n    max_arr[i] = arr[max_index]\n    max_index\
    \ += 1 if max_index < arr.length else -1\n  end\n  \n  return max_arr\nend", " \
    \   arr.sort!\n    arr.slice!(0, k)\n    return arr\nend", "  arr = Array(arr)\n\
    \  k = k % arr.length\n  arr = arr.sort { |x, y| y > x }\n  arr.slice!(0, k)\n\
    end", "  arr.sort!\n  return arr[-k..-1] if arr.size > k \n  \nend", "  return\
    \ arr.reject {|x| x > 0}\nend", "  arr.sort { |a,b| b <=> a }\n  arr.select {\
    \ |x| x ==  k }\nend", "  m = arr.map {|e| -Float::INFINITY if e < 0}.max\n  i\
    \ = -1\n  new_arr = arr.map do |e|\n    if e == m\n      m -= 1\n      e -= 1\n\
    \    end\n    i += 1\n    e\n  end\n  new_arr[-k..-1]\nend", "  arr.sort.reverse.take_while{|x|\
    \ x > 0}.reverse\nend", "  arr = arr.reverse \n  arr.length.times do\n    if arr[0]\
    \ != 0\n      arr.shift\n    else\n      break\n    end\n  end\n  arr.shift\n\
    \  arr.reverse\n  arr.unshift(0)\n  result = arr.take(k)\n  result\nend\n</code>\n\
    <|/ a |>\n<| a |>\nThe solution I have found using Ruby 1.9's sorting algorithms\
    \ and its Array class:\n<code>", "    if k > length(arr) || k < 1\n        return\
    \ arr\n    maximum = arr[0]\n    for i in 1 .. k - 1\n        if maximum > arr[i]\n\
    \            maximum = arr[i]\n        end\n    end\n    return maximum\nend",
  "    # write your code here\n    size = arr.length\n    if size == 0\n        return\
    \ arr\n    if size == 1\n        return arr\n    if k > size\n        return arr\n\
    \    mid = size/k\n    if k == mid\n        return arr[0...k]\n    \n    return\
    \ maximum(arr[0...mid], k) + maximum(arr[mid+1..size], k)", "    return arr[0]...\n\
    end", "  result = arr[0]\n  arr.each do |item|\n    if item > result\n      result\
    \ = item\n    end\n  end\n  result\nend", "  arr.sort\n  arr.size\n  return arr[0..k]\n\
    end\n</cell>\n<code language=julia-1.6>\nmaximum([-3, 2, 1, 2, -1, -2, 1], 1)\n\
    </cell>\n<code language=julia-1.6>\nmaximum([-3, 2, 1, 2, -1, -2, 1], 2)\n</cell>\n\
    <code language=julia-1.6>\nmaximum([-3, 2, 1, 2, -1, -2, 1], 3)\n</cell>\n<code\
    \ language=julia-1.6>\nmaximum(maximum(maximum([-3, 2, 1, 2, -1, -2, 1], 3), maximum(maximum([-3,\
    \ 2, 1, 2, -1, -2, 1], 2), 1)))\n</cell>\n<text>\n@inbounds", "  return arr.sort[-k..-1]\n\
    end", "  arr.sort!\n  return arr[0,k]\nend", "    arr.sort\n    k = k-1\n    if\
    \ k > arr.length\n        k = arr.length\n    arr[0...k]\nend\n</code>\n<|/ a\
    \ dscore=0 |>\n<| c |>\nThis is wrong! See [this](https://ideone.com/YZ7Z9B) for\
    \ a sample of test case that return wrong results.\n<|/ c |>\n<| c |>\n- You are\
    \ right, I missed the edge case for k=1. This should be fixed now.\n<|/ c |>\n\
    <| c |>\nThat fixes it!\n<|/ c |>\n<| c |>\n- Thanks for your feedback.\n<|/ c\
    \ |>\n<| a dscore=0 tags=arrays,ruby,sorting,algorithm |>\nYou want to find an\
    \ array with the greatest k values. So start with the first element. Sort only\
    \ those elements whose value is not greater than the previous value. If there\
    \ are less than k elements in the array, you are done. Otherwise take the largest\
    \ of these k and the current element and move to the next element. This continues\
    \ until all elements in the array have been considered.\nSince you are sorting\
    \ only those elements that do not exceed the previous value, you cannot find a\
    \ situation where there is less than k elements, in which case you do not have\
    \ to consider any elements at all. For this reason there is no need to sort the\
    \ entire array at all.\n<code>", "    return arr[(arr.size-k+1):k].max\nend",
  "    return arr[-k]\n    ", "    # write your code here\n    ans = arr\n    while\
    \ k > len(ans):\n        ans = ans + [arr[k]]\n        k -= 1\n    return ans\n\
    </cell>\n<cell>\narr = [-3, 2, 1, 2, -1, -2, 1]\nk = 2\nmaximum(arr, k)\n</cell>\n\
    <text>\n6. Range Minimum Query\nGiven an array of integers and a positive integer\
    \ k, return the k elements in the array that \nhave range minimum k.\nExample:\n\
    Given arr = [1, 3, 6, 5, 7] and k = 3,\nreturn [5, 7].\nExplanation:\nThe range\
    \ minimum is 1 and\nthe range maximum 7 is [1, 2, 3].\nThe range minimum is 3\
    \ and\nthe range maximum 7 is [3, 6, 5].\nThe range minimum is 6 and\nthe range\
    \ maximum 7 is [5, 7].", "  sorted = []\n  index = 0\n  while index < k\n    sorted\
    \ = arr.select { |x| x < sorted }.max\n    index = index + 1\n  end\n  sorted\n\
    end\n</code>\n<|/ a tags=ruby,arrays |>\n<| a dscore=0 |>\n<code>", "  arr.sort!\n\
    \  (0...k).map { |i| arr[i] }\nend\n</code>\n<|/ a |>\n<| c |>\nHi, thanks for\
    \ your answer. Is there any performance difference between using `sort` and `inject`\
    \ ?\n<|/ c |>\n<| c |>\nHi, I tried to run this program on JRuby 1.7.2, and I\
    \ noticed that `sort` and `inject` have the same speed on average. But I think\
    \ `sort` is faster, because `sort` doesn't need to create extra array and `inject`\
    \ can use native method\n<|/ c |>\n<| c |>\nYes, `sort` is slower, because it\
    \ needs to create a new array in memory for the result, which is done in linear\
    \ time.\n<|/ c |>\n<| c |>\nI think I misunderstood your question, by `sort` I\
    \ mean `arr = [1,2,3]`, `arr.sort!` , now the array is sorted, and we get `[1,2,3]`\n\
    <|/ c |>\n<| c |>\nI wonder if in Ruby 1.9.2, `inject` will actually be slower\
    \ compared to `sort`?\n<|/ c |>\n<| a tags=ruby,algorithm,ruby-on-rails,sorting,ruby-on-rails-3\
    \ |>\nThe answer depends on what exactly is your goal. If you are looking for\
    \ a way to sort your array in place using Ruby only, here is a simple solution:\n\
    <code>\narr.sort!\n</code>\nBut if you are looking for an O(n log(n)) algorithm,\
    \ please take a look at this answer.\n<|/ a dscore=4 |>\n<| c |>\nHi, thanks for\
    \ your answer. I need to sort an array of size 10 million. I was hoping that sort\
    \ would be the fastest way. Can you please suggest another faster way?\n<|/ c\
    \ |>\n<| c |>\nYour array is just too big. Try something like this: `arr = rand(1..999999);\
    \ arr.sort!`\n<|/ c |>\n<| c |>\nHi, I tried to run this program on JRuby 1.7.2,\
    \ and I noticed that `sort` and `inject` have the same speed on average. But I\
    \ think `sort` is faster, because `sort` doesn't need to create extra array and\
    \ `inject` can use native method\n<|/ c |>\n<| c |>\nThis answer says \"Ruby only\"\
    \ but also says \"O(n log(n))\" which is contradictory\n<|/ c |>\n<| c |>\nWell,\
    \ O(n log(n)) is just O", "    min = arr[0]\n    max = []\n    for i in arr\n\
    \        if i > max[-1]\n            max[-1] = i\n        elif i < min\n     \
    \       min[i] = i\n    max += min[k..-1]\n    return max\nend", "  return arr\
    \ if k <= 0 || k > arr.length ? arr : arr.slice(-k)\nend", "  # Your code here\n\
    \  maximum = 0\n  for i in arr\n    if maximum < i \n      maximum = i\n  end\n\
    \  maximum = maximum - k\n  maximum = maximum + k\n  for i in arr\n    if maximum\
    \ > i \n      maximum = i\n    end\n  end\n  return arr\nend\n</code>\n<|/ a dscore=1\
    \ tags=ruby,bubble-sort,algorithm |>\n<| c |>\nThis answer does not meet the criteria\
    \ of #2 of the question.  It does not sort a subrange of the array, only the whole\
    \ array.  Please read my answer carefully.\n<|/ c |>\n<| c |>\n- Your answer meets\
    \ the criteria of #2, but it does not sort a subrange of the array. The whole\
    \ array is sorted, and only a subrange of the array is sorted within the range\
    \ of the subrange. This is not what the question stated at the time I wrote the\
    \ answer. Your answer does not meet the criteria of #2 of the question, and therefore\
    \ it does not meet the criteria of the question, so it is not an answer to this\
    \ question.\n<|/ c |>\n<| c |>\nI didn't say your answer does not meet the criteria.\
    \  I met them, and that's what matters.  Your answer does meet the criteria. \
    \ You did not read the question carefully enough.  Read the question carefully,\
    \ then read my answer carefully.\n<|/ c |>\n<| c |>\n- I read your answer carefully.\
    \  It meets the criteria of #2 of the question.  It sorts a subrange of the array.\
    \ It does not meet the criteria of the question.  I stated that my answer does\
    \ not meet the criteria of the question at the time I wrote the answer, and I\
    \ explicitly stated that this answer does not meet the criteria of the question.\
    \  If you do not read the question carefully, you will never get a good answer\
    \ from StackOverflow, and this is what makes StackOverflow great for programming.\n\
    <|/ c |>\n<| a tags=ruby,bubble-sort,algorithm |>\nAn alternate method using Ruby's\
    \ Enumerable#sort_by method to sort the array using comparison on the first k\
    \ elements of each subrange:\n<code>", "  # write your code here\n  if k == 0\
    \ or k > len(arr)\n    arr\n  else\n    maxArr = arr\n    i = 0\n    while i <\
    \ k\n      maxArr[i] = max( maxArr[i] , arr[i])\n      i += 1\n    arr\n  end\n\
    end\n</cell>\n<code language=julia-0.4>\nmaximum(arr, k)\n</cell>\n<text>\n5.\
    \ The minimum\nThe minimum function returns the minimum value of the array. If\
    \ the input array is empty then it returns Inf. The function must satisfy the\
    \ requirements below:", "    max = arr[0]\n    max_idx = 0\n    \n    for i in\
    \ range(1, len(arr))\n        if arr[i] > max and max_idx < k - 1\n          \
    \  max = arr[i]\n            max_idx = i\n        end if\n    end for", "    arr.sort!\n\
    \    return arr[-k..-1]\nend", "  arr.sort\n  return arr[-k..-1]\nend", "    arr.sort!\n\
    \    arr.each_cons(k).map!{|x| x.max}\nend", "  k = k if k <= arr.length else\
    \ arr.length\n  sorted = arr.sort\n  return sorted[0...k]\nend", "    arr.sort\n\
    \    arr.slice(1..k+1)\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nYour solution\
    \ also works with Ruby: `arr = [-3, 2, 1, 2, -1, -2, 1]; k = 1`.\n<|/ c |>\n<|\
    \ a dscore=3 tags=sorting,ruby |>\nFor people finding this question from a more\
    \ general perspective, I think some of the answers here are wrong.\nFor instance,\
    \ the correct answer to this question should be [-3, -2, -1, 1, 2]. This problem\
    \ can be solved much easier using the .sort method as suggested by many people.\
    \ It was made for sorting arrays of objects, not of numbers. \nHere's how you\
    \ can solve this problem using .sort:\n<code>", "  arr = sort(arr)\n  return arr[k..-1]\n\
    end", "  a = arr.sort\n  a.length == k\nend", "  sorted = arr.sort\n  return k\
    \ ? sorted.reverse.take(k) : sorted\nend", "  arr = arr.sort\n  puts arr.length\
    \ unless k == 0\n  arr = arr[0..k-1] if k > 0 && k <= arr.length # arr[0..k-1]\
    \ is enough for k > 0\n  return arr\nend", "  n = arr.length\n  max_arr = Array.new(k)\
    \ \n  arr.each do |x|\n    max_arr[k] = x if x > max_arr[k]\n  end\n  return max_arr\n\
    end", "  sorted = []\n  arr.each_index do |i|\n    sorted << arr[i] if k <= arr.length\n\
    \  end\n  sorted.max\nend", "    sorted_arr = nil\n    max_arr = []\n    if k\
    \ < 1 || k > arr.length then return nil\n    i = 0\n    while i < k\n        if\
    \ arr[i] > sorted_arr[i]\n            sorted_arr[i] = arr[i]\n            max_arr[i]\
    \ = arr[i]\n            i += 1\n        else\n            i += 1\n    end\n  \
    \  while i < arr.length\n        if arr[i] > sorted_arr[i]\n            sorted_arr[i]\
    \ = arr[i]\n            max_arr[i] = arr[i]\n            i += 1\n        else\n\
    \            i += 1\n        end\n    end\n    sorted_arr\nend", "  sorted = arr.sort\n\
    \  max_elements = sorted.reverse\n  result = []\n  i = 0\n  while i < k\n    result[i]\
    \ = max_elements.pop\n    i += 1\n  result\nend", "  return arr[-k..-1].max\n\
    end", "  arr.sort!\n  maximum_value = arr[k]\n  for i in (0..arr.length-1).step(arr.length-k)\n\
    \    if arr[i] > maximum_value\n      maximum_value = arr[i]\n    end\n  end\n\
    \  return arr\nend", "  max_num = arr[0]\n  max_idx = -1\n  for i in 0...k\n \
    \   if arr[i] > max_num\n      max_num = arr[i]\n      max_idx = i\n    end\n\
    \  end", "\tresult = []\n\tfor i in arr\n\t\tif result.length < k\n\t\t\tresult.push(i)\n\
    \t\telsif result.length > k\n\t\t\tresult.push(result[0])\n\t\telsif i > result[0]\n\
    \t\t\tresult.shift\n\t\t\tresult.push(i)\n\t\telsif i == result[0]\n\t\t\tresult.shift\n\
    \t\tend\n\tend\n\tresult\nend", "  arr.sort_by {|i| -arr[i] }[0...k]\nend", " \
    \   if k < 1 or k > length(arr)\n        return nil\n    \n    i = 0\n    max\
    \ = arr[0]\n    max = arr[0]\n    while i < k\n        if arr[i] > max\n     \
    \       max = arr[i]\n        end\n        i += 1\n    end\n    \n    return arr[0..i-1]\n\
    end", "  result = arr.dup.sort\n  result[-k..-1] = nil if k < arr.length\n  result\n\
    end", "  max_arr = []\n  i = 0\n  while i < k\n    if arr[i] > max_arr[-1]\n \
    \     max_arr.push arr[i]\n      i += 1\n    else if arr[i] == max_arr[-1]\n \
    \     i += 1\n    end\n  end\n  max_arr\nend", "    return arr[-k..-1]\nend\n\
    </cell>\n<code language=julia-0.6>\nmaximum(arr, 3)\n</cell>\n<text>\n\uC704\uC758\
    \ 3\uAC00\uC9C0\uB97C \uC0B4\uD3B4\uBCF4\uBA74, \uCCAB\uBC88\uC9F8\uC758 k\uAC12\
    \uC774 \uB0A8\uC2B5\uB2C8\uB2E4.", "  new_array = []\n  for i in 0..(arr.length-1)\n\
    \    new_array.push(arr[i])\n    new_array.push(arr[i])\n  end\n  new_array.sort_by!\
    \ {|i| i }\n  new_array.last(k+1)\nend", "\tarr.sort!\n\tresult = []\n\twhile\
    \ arr.size < k\n\t\tarr << arr.shift\n\tend \n\tresult << arr\n\tresult\nend\n\
    </cell>\n<cell>", "  arr.sort!\n  arr[0...k-1]\nend\n</cell>\n<code language=julia-1.0>\n\
    maximum([-3, -4, 5], 3)\n</cell>\n<code language=julia-1.0>\nmaximum(arr, k)\n\
    </cell>\n<code language=julia-1.0>\nmaximum(arr, k)\n</cell>\n<code language=julia-1.0>\n\
    maximum(arr, k)\n</cell>\n<code language=julia-1.0>\nmaximum(arr, k)\n</cell>\n\
    <code language=julia-1.0>\nmaximum(arr, k)\n</cell>\n<code language=julia-1.0>\n\
    maximum(arr, k)\n</cell>\n<code language=julia-1.0>\nmaximum(arr, k)\n</cell>\n\
    <code language=julia-1.0>\nmaximum(arr, k)\n</cell>\n<code language=julia-1.0>\n\
    maximum(arr, k)\n</cell>\n<code language=julia-1.0>\nmaximum(arr, k)\n</cell>\n\
    <code language=julia-1.0>\nmaximum(arr, k)\n</cell>\n<code language=julia-1.0>\n\
    maximum(arr, k)\n</cell>\n<code language=julia-1.0>\nmaximum(arr, k)\n</cell>\n\
    <code language=julia-1.0>\nmaximum(arr, k)\n</cell>\n<code language=julia-1.0>\n\
    maximum(arr, k)\n</cell>\n<code language=julia-1.0>\nmaximum(arr, k)\n</cell>\n\
    <code language=julia-1.0>\nmaximum(arr, k)\n</cell>\n<code language=julia-1.0>\n\
    maximum(arr, k)\n</cell>\n<code language=julia-1.0>\nmaximum(arr, k)\n</cell>\n\
    <code language=julia-1.0>\nmaximum(arr, k)\n</cell>\n<code language=julia-1.0>\n\
    maximum(arr, k)\n</cell>\n<code language=julia-1.0>\nmaximum(arr, k)\n</cell>\n\
    <code language=julia-1.0>\nmaximum(arr, k)\n</cell>\n<code language=julia-1.0>\n\
    maximum(arr, k)\n</cell>\n<code language=julia-1.0>\nmaximum(arr, k)\n</cell>\n\
    <code language=julia-1.0>\nmaximum(arr, k)\n</cell>\n<code language=julia-1.0>\n\
    maximum(arr, k)\n</cell>\n<code language=julia-1.0>\nmaximum(arr, k)\n</cell>\n\
    <code language=julia-1.0>\nmaximum(arr, k)\n</cell>\n<code language=julia-1.0>\n\
    maximum(arr, k)\n</cell>\n<code language=julia-1.0>\nmaximum(arr, k)\n</cell>\n\
    <code language=julia-1.0>\nmaximum(arr, k)\n</cell>\n<code language=julia-1.0>\n\
    maximum(arr, k)\n</cell>\n<code language=julia-1.0>\nmaximum(arr, k)\n</cell>\n",
  "  arr.sort\n  arr.pop(k - 1)\n  return arr\nend", "    # \u65B9\u6CD5\u4E00\uFF1A\
    \ \u4E8C\u5206\u67E5\u627E\n    # def findmax(A, k, lo, hi):\n    #     if lo\
    \ >= hi: return lo\n    #     mid = lo + (hi - lo) // 2\n    #     if A[mid] >\
    \ A[mid+1]:\n    #         return findmax(A, k, lo, mid - 1)\n    #     else:\n\
    \    #         return findmax(A, k, mid + 1, hi)\n    # return findmax(A, k, 0,\
    \ len(A)-1)\n    \n    # \u65B9\u6CD5\u4E8C\uFF1A\u52A8\u6001\u89C4\u5212\n  \
    \  def findmax(A, k, lo, hi):\n        if lo >= hi: return lo\n        mid = lo\
    \ + (hi - lo) // 2\n        if A[mid] > A[mid+1]:\n            findmax(A, k, lo,\
    \ mid - 1)\n        else:\n            findmax(A, k, mid + 1, hi)\n    \n    findmax(arr,\
    \ k, 0, len(arr)-1)\n    return arr", "  return arr.sort.take_while { |v| v <=\
    \ arr.last }[1..k]\nend", "  result = []\n  size = arr.size\n  result[0] = arr[0]\n\
    \  maximum.call(arr, size - 1, k, result)\n  result\nend", "  return if k >= arr.length\
    \ then arr else if k < 1 then nil else arr.max.to_a.tap{ |arr| maximum.call(arr,\
    \ arr.length - k) }\nend", "  return arr.select {|x| x > arr.max}[0...k]\nend\n\
    </cell>\n<code language=julia-1.1>\nmaximum(arr, 3)\n</cell>\n<code language=julia-1.1>\n\
    maximum(arr, 2)\n</cell>\n<code language=julia-1.1>\nmaximum(arr, 1)\n</cell>\n\
    <code language=julia-1.1>\nmaximum(arr, 4)\n</cell>\n<code language=julia-1.1>\n\
    maximum(arr, 10)\n</cell>\n<code language=julia-1.1>\nmaximum(arr, 100)\n</cell>\n\
    <code language=julia-1.1>\nmaximum(arr, 1000)\n</cell>\n<text>\nminimum", "  max_arr\
    \ = arr.sort {|a, b| a > b ? -1 : a <  b ? 1 : (a <  b) ? -1 : a > b ? 1 : 0}\n\
    \  max_arr.size == k ? max_arr : max_arr + [k]\nend\n</code>\n<|/ a dscore=3 |>\n\
    <| c |>\nWhat about a Ruby version which can sort in place?\n<|/ c |>\n<| c |>\n\
    To sort in place: `max_arr = max_arr.sort`\n<|/ c |>\n<| a dscore=3 |>\nFor a\
    \ Ruby version which can sort in place:\n<code>\na = [-6, -5, -4, -3, 3, 5, 6]"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
