name: HumanEval_29_filter_by_prefix
language: rb
prompt: "# Filter an input array of strings only for ones that start with a given\
  \ prefix.\n# >>> filter_by_prefix.call([], \"a\")\n# []\n# >>> filter_by_prefix.call([\"\
  abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n# [\"abc\", \"array\"]\ndef filter_by_prefix(strings,\
  \ prefix)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_filter_by_prefix\n\
  \    candidate = method(:filter_by_prefix)\n    assert_equal([], candidate.call([],\
  \ \"john\"))\n    assert_equal([\"xxx\", \"xxxAAA\", \"xxx\"], candidate.call([\"\
  xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\"))\n  end\n\
  end\n"
completions: ["  strings.select { |s| s.start_with? prefix }\nend", "  return strings.select\
    \ do |string|\n    string =~ /^#{prefix}(\\W|$)/i\n  end\nend", "  return strings.select\
    \ { |s| s.start_with?(prefix) }\nend", "  strings.select { |string| string[0,prefix.length]\
    \ == prefix }\nend", "  strings.select do |string|\n    string.start_with?(prefix)\n\
    \  end\nend", "  strings.select{|s| s.starts_with? prefix}\nend", "  strings.select\
    \ do |string|\n    string.start_with?(prefix)\n  end\nend", "  strings.select\
    \ { |s| s[0..prefix.is_a?(String) ? prefix.length : -1] == prefix }\nend", " \
    \ return strings.select do |string|\n    string.start_with?(prefix)\n  end\nend",
  "  return strings.select { |s| s.starts_with? prefix }\nend", "  strings.select\
    \ { |s| s.start_with?(prefix) }\nend\n</code>\nFiltering out strings that don't\
    \ start with prefix\nTo filter out strings that don't start with a given prefix,\
    \ use the filter_by_prefix function and negate it:\n<code>", "  strings.select\
    \ { |string| string.start_with?(prefix) }\nend", "  strings.select { |s| s.starts_with?(prefix)\
    \ }\nend", "  strings.select{ |s| s.start_with?(prefix) }\nend", "  strings.grep(/^#{prefix}/)\n\
    end", "  strings.select { |s| s.start_with?(prefix) }\nend", "  strings.select\
    \ {|s| s.starts_with?(prefix) }\nend", "  strings.select { |s| s.start_with?(prefix)\
    \ }\nend", "  strings.grep(/^#{prefix}/)\nend", "  strings.select { |string| string[0,\
    \ prefix.length] == prefix }\nend", "  return strings[prefix..-1] if prefix &&\
    \ strings.first.starts_with(prefix) else\n    strings\nend", "  strings.grep(/^#{prefix}.*$/)\n\
    end", "  strings.select { |s| s.start_with?(prefix) }\nend", "  strings.select\
    \ { |s| s[0,prefix.length] == prefix }\nend", "  return strings.select { |str|\
    \ str.starts_with?(prefix) }\nend", "  strings.select { |s| s.starts_with(prefix)\
    \ }\nend", "  strings.select do |s|\n    s =~ /^#{prefix}/\n  end\nend\n</code></pre>\n\
    <p>Now you can call <code>filter_by_prefix</code> and have the filtered array\
    \ passed as the result to the <code>find_by_prefix</code> instance method (or\
    \ whatever your method is called):</p>\n<pre><code>filter = Foobar.find_by_prefix(\"\
    a\")\nfilter.first", "  return [string for string in strings if string.starts_with(prefix)]\n\
    end", "  strings.select do |string|\n    string[0,prefix.length] == prefix\n \
    \ end\nend", "  strings.select { |s| s.starts_with?(prefix) }\nend", "  return\
    \ strings.select { |s| s.starts_with?(prefix) }\nend", "  strings.select { |x|\
    \ x.start_with?(prefix) }\nend", "  strings.select do |string|\n    string.start_with?(prefix)\n\
    \  end\nend", "  strings.grep(/^#{prefix}/)\nend", "  strings.select { |e| e.start_with?(prefix)\
    \ }\nend", "  strings.select { |s| s.start_with?(prefix) }\nend", "  strings.select\
    \ do |string|\n    string.start_with?(prefix)\n  end\nend", "    strings.select{|string|\
    \ string.start_with?(prefix)}\nend", "  strings.select! { |s| s.starts_with?(prefix)\
    \ }\n  strings\nend", "  strings.select do |string|\n    string.start_with?(prefix)\n\
    \  end\nend", "  # TODO: Implement this function\nend", "  strings.grep(/^#{prefix}.*$/)\n\
    end", "  strings.select{|str| str[0, prefix.length] == prefix }\nend", "  strings.select\
    \ { |s| s.starts_with(prefix) }\nend", "  strings.select do |string|\n    string\
    \ =~ /^#{prefix}/\n  end\nend", "  strings.select do |string|\n    string.start_with?(prefix)\n\
    \  end\nend", "  strings.select do |string|\n    string.start_with?(prefix)\n\
    \  end\nend", "  strings = Array(strings)\n  prefix = prefix.to_s\n  return strings.select\
    \ { |s| s[0] == prefix }\nend", "  strings.grep(/^#{prefix}/)\nend", "  strings.select\
    \ { |s| s.start_with?(prefix) }\nend", "  strings.select{|s| s.start_with?(prefix)}\n\
    end", "  return strings.select do |str|\n    str.starts_with(prefix)\n  end\n\
    end", "  strings.select { |s| s[0] == prefix }\nend", "  strings.grep(/^#{prefix}/)\n\
    end", "  strings.grep(/^#{prefix}/)\nend", "  strings.select do |string|\n   \
    \ string.start_with?(prefix)\n  end\nend", "  strings.select { |str| str.starts_with?(prefix)\
    \ }\nend\n</code>\n<code>", "  # Gather the indexes of all strings that begin\
    \ with the given prefix.\n  indexes = strings.map { |s| s.index(prefix) }", " \
    \ return strings[0, strings.index(prefix)]\nend", "  strings[0, prefix.length]\
    \ = prefix\n  strings.slice(1, strings.length)\nend", "  return strings.select\
    \ do |string|\n    string.start_with?(prefix)\n  end\nend", "  strings.select\
    \ do |string|\n    prefix === string && (!string.end_with?(\"*\") || string =~\
    \ /[*\\[\\]]/)\n  end\nend", "  strings.select { |str| str =~ /^#{prefix}/ }\n\
    end", "  return strings[0, prefix-1] if strings.size >= prefix else strings\n\
    end", "  strings.reject { |s| s.start_with?(prefix) }\nend", "  strings.select{\
    \ |s| s.index(prefix) == 0 }\nend", "  # Return original list or strings that\
    \ don't start with the prefix.\n  strings.reject { |str| str.start_with?(prefix)\
    \ }\nend", "  strings.select{|s| s[0,prefix.length] == prefix}\nend", "  strings.select\
    \ do |string|\n    string.start_with?(prefix)\n  end\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nI love how you used `start_with?` instead of `=~`.\n<|/ c |>\n\
    <| a dscore=2 |>\nIf you need the result to not include the prefix but to include\
    \ the word you can do:\n<code>", "  strings.select { |s| s.starts_with?(prefix)\
    \ }\nend", "  strings.select { |str| str.start_with?(prefix) }\nend", "  strings.select\
    \ { |s| s.start_with?(prefix) }\nend", "  strings.select{ |s| s.start_with?(prefix)\
    \ }\nend", "  return [string for string in strings\n          if string.start_with?\
    \ prefix]\nend\n</code>\nNow we can do this:\n<code>", "  strings.select { |string|\
    \ string.starts_with(prefix) }\nend", "  strings.select { |s| s.start_with?(prefix)\
    \ }\nend\n</code>\n<|/ a tags=ruby,arrays dscore=5 |>\n<| c |>\nWas looking for\
    \ this. Thanks.\n<|/ c |>\n<| a tags=ruby,arrays |>\nA little late to the party,\
    \ but I think I found a better solution for my particular situation, which turned\
    \ out to be what I wanted. I wanted a quick way to filter an array of hashes based\
    \ on a key in the hash. My hashes were not all that different, so I wrote a quick\
    \ and easy method to do it:\n<code>", "  return objects.filter(strings__startswith=prefix)\n\
    end\n  ", "  strings.select { |s| s.starts_with?(prefix) }\nend", "  return strings.select\
    \ { |s| s.start_with? prefix }\nend", "  strings.select {|s| s.start_with?(prefix)}\n\
    end", "  strings.select { |s| s.start_with? prefix }\nend\n</pre>\n</div>", " \
    \ strings.select { |s| s.start_with?(prefix) }\nend\n</code>\n<|/ a dscore=3 |>\n\
    <| a dscore=1 |>\nYou don't have to do much to filter on that one, the only thing\
    \ that changes is the regular expression. You just use that to specify how you'd\
    \ like to match your strings:\n<code>\nregex = /[a-zA-Z]+|\\w+/", "  strings.select{|s|\
    \ s[0,prefix.length] == prefix }\nend", "  strings.select do |string|\n    string.start_with?(prefix)\n\
    \  end\nend", "  strings.select { |s| s[0, prefix.length] == prefix }\nend", " \
    \ return strings.select { |string| string.start_with?(prefix) }\nend", "  strings.select\
    \ { |s| s.starts_with? prefix }\nend", "  strings.select { |s| s.start_with?(prefix)\
    \ }\nend\nRSpec::Support.define_negated_matcher_method(:filter_by_prefix, filter_by_prefix)",
  "  return strings.select { |str| str.start_with?(prefix) }\nend", "  strings.select\
    \ { |s| s =~ /^#{prefix}/ }\nend\n</code>\n<|/ a tags=arrays,ruby,string |>\n\
    <| c |>\nThe `if` statements can be avoided by just using `strings`.\n<|/ c |>\n\
    <| a |>\nHere is a simple one line solution:\n<code>\n[\"one\", \"two\", \"three\"\
    , \"four\"].grep(/t/)\n</code>\nThis returns:\n<code>\n[\"two\", \"three\", \"\
    four\"]\n</code>\n<|/ a tags=arrays,ruby,string dscore=5 |>\n<| c |>\nThis answer\
    \ has a small flaw in that it returns an array with an empty string in it if the\
    \ matching string is not found. It should return an array with an empty string\
    \ in it if the match is found.\n<|/ c |>\n<| a |>\nA short and simple solution:\n\
    <code>\n[\"a\", \"b\", \"c\", \"d\"].grep(/a/)\n</code>\n<|/ a tags=arrays,ruby,string\
    \ dscore=5 |>\n<| c |>\nThis answer has a small flaw in that it returns an array\
    \ with an empty string in it if the matching string is not found. It should return\
    \ an array with an empty string in it if the match is found.\n<|/ c |>\n<| a dscore=5\
    \ |>\nThe best and simplest solution I found is:\n<code>\n>> arr = [\"one\", \"\
    two\", \"three\", \"four\"]\n>> arr.grep(/^t/)\n=> [\"two\", \"three\", \"four\"\
    ]\n</code>\n<|/ a tags=arrays,ruby,string |>\n<| c |>\nThe best solution I found\
    \ for this situation.\n<|/ c |>\n<| c |>\nI like this solution best because it\
    \ doesn't require a separate variable. Also the example uses `arr`, so you know\
    \ that `grep` applies to the `arr` variable.\n<|/ c |>\n<| a tags=arrays,ruby,string\
    \ |>\nI needed to do this on multiple arrays, so I combined them into one using\
    \ inject.\n<code>", "  strings.select do |str|\n    str.start_with?(prefix)\n\
    \  end\nend", "  # Easier to read and understand with an example:\n  # >>> filter_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n  # [\"abc\", \"array\"]", "  strings.select\
    \ { |string| string.start_with?(prefix) }\nend", "  return strings.select { |s|\
    \ s[0] == prefix }\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails dscore=1 |>\n\
    <| a |>\nThis answer is similar to Dave Peck's answer, but it works with a string\
    \ array and doesn't require any additional gems.\n<code>", "  strings.map { |string|\
    \ string if string.start_with?(prefix) }\nend", "  strings.select! {|str| str.start_with?(prefix)}\n\
    end", "  strings.select do |string|\n    string =~ /^#{prefix}/ ? true : false\n\
    \  end\nend", "  strings.select { |string|\n    string.start_with?(prefix)\n \
    \ }\nend", "  strings.select { |s| s.starts_with?(prefix) }\nend", "  return strings.select\
    \ do |string|\n    string =~ /^#{prefix}/ ? true : false\n  end\nend", "  strings.select\
    \ { |s| s.start_with?(prefix) }\nend", "  strings.select do |string|\n    string\
    \ =~ /^#{prefix}/\n  end\nend", "  strings.select { |string| string.start_with?(prefix)\
    \ }\nend", "  strings.select do |string|\n    string.start_with?(prefix)\n  end\n\
    end", "  return strings.select do |s|\n    s[0] != prefix\n  end\nend\n</cell>\n\
    <cell>", "  strings = strings.to_a\n  return strings.select { |s| s.start_with?(prefix)\
    \ }\nend", "  strings.select { |s| s =~ /^#{prefix}/ }\nend", "  strings.select!{\
    \ |string| string =~ Regexp.new('^'+prefix+'(.*)?') }\nend", "  strings.select\
    \ do |str|\n    str.start_with?(prefix)\n  end\nend\n</code>\n<|/ a dscore=4 |>\n\
    <| a tags=ruby dscore=3 |>\nIn ruby 1.9.2 the Enumerable#chunk method supports\
    \ this:\n<code>\n'foo bar baz'.split(' ').chunk{|x| x.size == 1 }", "  # Create\
    \ an empty array and fill it with the strings that have a prefix.\n  strings_was_empty\
    \ = strings.length == 0\n  strings_prefixed = strings.grep(/^#{prefix}/)\n  strings_without\
    \ = strings.reject(/^#{prefix}/)", "  strings.select { |s| s[0, prefix.is_a?(String)\
    \ ? prefix.length : prefix.length] \n== prefix }\nend", "  strings.grep(/^#{prefix}./)\n\
    end", "  strings.grep(/^#{prefix}/)\nend", "  return filter(string.starts_with?,\
    \ strings) do |string|\n    string.start_with?(prefix)\n  end\nend", "  strings.map\
    \ {|s| s.split(prefix).last}\nend", "  return strings.select { |s| s.start_with?(prefix)\
    \ }\nend", "  strings.select { |s| s.start_with? prefix }\nend\n</code>\nThis\
    \ should cover most common usages, and is easy to understand:\n<code>", "  strings.select\
    \ do |string|\n    string.start_with?(prefix)\n  end\nend", "  strings.select\
    \ do |string|\n    string.starts_with(prefix)\n  end\nend", "  strings.select\
    \ { |s| s.start_with?(prefix) }\nend\n</pre>", "  return strings.select { |s|\
    \ s.start_with? prefix }\nend", "  strings.select{ |s| s[0] == prefix }\nend",
  "  return strings.select do |string|\n    string.starts_with?(prefix)\n  end\nend\n\
    </pre>", "  strings.select do |string|\n    string.start_with?(prefix)\n  end\n\
    end", "  return strings.select { |s| s.start_with?(prefix) }\nend", "  strings.select\
    \ { |s| s.start_with?(prefix) }\nend", "  strings = strings.select do |s|\n  \
    \  s[0]..=s[0]+1 # Convert string to array index\n    s[0..prefix.length] == prefix\
    \ # Filter by prefix\n  end\n  strings\nend", "  strings.select { |s| s.starts_with?\
    \ prefix }\nend", "  strings.select do |str|\n    str.starts_with?(prefix)\n \
    \ end\nend\n</code>\nIf you have a lot of these filters to be run, consider creating\
    \ a class to contain the filters.  You could also have your filters use lambdas\
    \ instead of blocks.\n<code>", "  strings.select do |string|\n    string =~ /^#{prefix}(.+)$/\n\
    \  end\nend", "  # Use String#[].\n  strings.grep(/^#{prefix}/)\nend", "    strings.reject\
    \ {|s| !s.starts_with?(prefix)}\nend", "  strings.select { |string| string[0,\
    \ prefix.length] == prefix }\nend", "  strings.select do |string|\n    string.start_with?(prefix)\n\
    \  end\nend", "  strings.select{ |s| s.starts_with?(prefix) }\nend", "  strings.select\
    \ do |string|\n    string.starts_with(prefix)\n  end\nend", "  strings.select\
    \ do |string|\n    string =~ /^#{prefix}(.*)/\n  end\nend", "  return [s for s\
    \ in strings if s.starts_with(prefix)]\nend", "  strings.select { |string| string[0,\
    \ prefix.length] == prefix }\nend", "  strings.select{|s| s.start_with?(prefix)}\n\
    end", "  strings.select {|s| s.start_with?(prefix)}\nend", "  return strings[0..strings.index(prefix)]\
    \ if strings.index(prefix) != nil then strings[0..strings.index(prefix)+1] end\n\
    end", "  return filter_by_prefix_nocase(strings, prefix, false)\nend", "  strings.select\
    \ do |string|\n    string.start_with?(prefix)\n  end\nend", "  return strings.select\
    \ { |s| s.start_with?(prefix) }\nend", "  strings.select { |str| str.start_with?(prefix)\
    \ }\nend", "  return strings.select do |string|\n    string.starts_with?(prefix)\n\
    \  end\nend", "  strings.select { |string| string.starts_with(prefix) }\nend",
  "  strings.select do |string|\n    string.start_with?(prefix)\n  end\nend", "  strings.select\
    \ { |string| string.start_with?(prefix) }\nend", "  strings.select {|s| s.start_with?(prefix)}\n\
    end", "  return strings.select{ |s| s.start_with?(prefix) }\nend", "  return strings.select\
    \ { |string| string.start_with?(prefix) }\nend", "  strings.select{|s| s[0,prefix.length]\
    \ == prefix }\nend", "  strings.select { |string| string.start_with?(prefix) }\n\
    end", "  # Create a copy of the array to prevent the original from being modified.\n\
    \  strings = strings.clone", "  # Return any strings starting with prefix.\n \
    \ strings.select {|str| str.start_with?(prefix)}\nend", "  strings.select do |string|\n\
    \    string.starts_with?(prefix)\n  end\nend", "  strings.select{ |s| s.start_with?(prefix)\
    \ }\nend", "  strings.select { |s| s.start_with? prefix }\nend", "  return strings.select\
    \ { |s| s.start_with?(prefix) }\nend", "  strings.select do |string|\n    string.start_with?(prefix)\n\
    \  end\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis is the approach that I\
    \ have been using (with a modified version) in the past.  I thought it would be\
    \ better to use `each_line` rather than `each_line` in the main loop to improve\
    \ performance (though I haven't tested it yet).  Also, since `each_line` is lazy,\
    \ the performance impact should be negligible.  Thanks for sharing!\n<|/ c |>\n\
    <| a |>\nYou could use a regex to match only strings that start with 'a'.\n<code>\n\
    strings = ['abd', 'abe', 'abc', 'abcde']\npattern = /^a/\nstrings.select{|str|\
    \ str.match(pattern)}", "  strings.select { |x| x.start_with?(prefix) }\nend\n\
    </code>\nFor Ruby versions that don't support the String#start_with? method, you\
    \ can do this:\n<code>", "  strings.grep(/^#{prefix}/)\nend", "  strings.select\
    \ do |string|\n    string.start_with?(prefix)\n  end\nend\n</pre>", "    strings\
    \ = strings or []\n    prefix = prefix or \"\"\n    return strings & [s[len(prefix):]\
    \ for s in strings if s.startswith(prefix)]\nend", "  strings.select { |s| s[0..prefix.length]\
    \ == prefix }\nend", "  strings.select {|s| s[0] == prefix }\nend", "  strings.select\
    \ do |string|\n    string.start_with?(prefix)\n  end\nend", "  strings.select\
    \ { |s| s.starts_with? prefix }\nend", "  strings.select { |str| str.start_with?(prefix)\
    \ }\nend", "  return [string for string in strings if string.start_with?(prefix)]\n\
    end", "  strings.select { |e| e.starts_with(prefix) }\nend", "  strings = strings.select\
    \ do |string|\n    string.start_with?(prefix)\n  end\n  strings\nend", "  strings.select\
    \ { |str| str.start_with?(prefix) }\nend", "  strings.select { |string| string.start_with?\
    \ prefix }\nend\n</cell>\n<cell>", "  strings.select { |s| s.start_with?(prefix)\
    \ }\nend", "  strings.select { |s| s[0] == prefix }\nend", "  strings.select{|str|\
    \ str.start_with?(prefix)}\nend\n</code>\nfilter_by_prefix\n<code>", "  strings.select\
    \ { |s| s.start_with? prefix }\nend", "  strings.select do |string|\n    string.start_with?(prefix)\n\
    \  end\nend", '  return [string for string in strings if string.startswith(prefix)]',
  "  strings.select { |x| x.start_with?(prefix) }\nend", "  return strings.select\
    \ { |s| s.start_with?(prefix) }\nend", "  strings.select { |s| s.start_with?(prefix)\
    \ }\nend", "  return strings.select { |s| s.starts_with(prefix) }\nend", "  strings.select\
    \ { |s| s.start_with?(prefix) }\nend", "  strings.select { |s| s.starts_with?(prefix)\
    \ }\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThe `select` method doesn't return\
    \ an array, it returns a `Proc` object. If you want to return the array just call\
    \ `select` on it. `select` returns a new array containing all items that matched\
    \ the criteria. `keep_if` returns a new array containing all items from `strings`\
    \ that matched the criteria. If you'd like to keep the old array and filter out\
    \ the items that don't match, use `reject`.\n<|/ c |>\n<| c |>\nAhh, nice catch.\
    \ That's a great point. I'll update my answer to use `reject` instead.\n<|/ c\
    \ |>\n<| c |>\nI like that it's concise but still readable and understandable\n\
    <|/ c |>\n<| a tags=ruby |>\nAn option with one loop\n<code>", "  strings.select\
    \ { |s| s[0, prefix.length] == prefix }\nend", "  return strings.select do |string|\n\
    \    string.start_with?(prefix)\n  end\nend", "  strings.select { |str| str.start_with?\
    \ prefix }\nend", "  strings.select { |s| s.start_with?(prefix) }\nend", "  strings.select!\
    \ {|s| s.start_with?(prefix)}\n  strings\nend", "  strings.select { |s| s.start_with?\
    \ prefix }\nend", "  return strings.select { |s| s[0...prefix.length] == prefix\
    \ }\nend", "  strings.grep(/^#{prefix}/)\nend", "  return strings.select { |string|\
    \ string.start_with?(prefix) }\nend", "  strings.select { |s| s.start_with?(prefix)\
    \ }\nend", "  return if prefix.nil?\n  strings = strings.map { |string| string.start_with?(prefix)\
    \ ? string : nil }\n  strings = strings.compact.uniq\n  strings = strings.select\
    \ do |string|\n    string != nil\n  end\nend", "  strings.select { |s| s.starts_with?\
    \ prefix }\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
