name: HumanEval_85_add
language: rb
prompt: "# Given a non-empty array of integers lst. add the even elements that are\
  \ at odd indices..\n# Examples:\n# >>> add.call([4, 2, 6, 7])\n# 2\ndef add(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_add\n\
  \    candidate = method(:add)\n    assert_equal(88, candidate.call([4, 88]))\n \
  \   assert_equal(122, candidate.call([4, 5, 6, 7, 2, 122]))\n    assert_equal(0,\
  \ candidate.call([4, 0, 6, 7]))\n    assert_equal(12, candidate.call([4, 4, 6, 8]))\n\
  \  end\nend\n"
completions: ["  even = 0\n  odd =  0\n  lst.each {|x| odd += x} \n  lst.each {|x|\
    \ even += x if x % 2 == 1} \n  even + odd\nend", "  lst.reverse!\n  even_index\
    \ = 0\n  odd_index = 0\n  while even_index < lst.size && odd_index < lst.size\n\
    \    if lst[even_index] % 2 != 0 && lst[odd_index] % 2 == 0\n      lst[even_index]\
    \ = lst[even_index] + lst[odd_index]\n      even_index += 1\n      odd_index +=\
    \ 1\n    else odd_index += 1\n  end\n  lst.reverse!\n  even_index = 0\n  while\
    \ even_index < lst.size\n    if lst[even_index] % 2 == 0\n      lst[even_index]\
    \ = 0\n      even_index += 1\n    end\n  end\n  lst\nend", "  len = length(lst)\n\
    \  if len == 0\n    0\n  elsif len == 1\n    lst[0]\n  elsif len == 2\n    lst[0]+lst[1]\n\
    \  elsif len > 2\n    add(add(lst[0..2]))\n  end\nend", "  return lst.inject(0){|sum,\
    \ el| sum + el if el % 2 == 1}\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis\
    \ doesn't answer the question, which specifically asked for a non-`Array#each`\
    \ solution\n<|/ c |>\n<| c |>\n: Yeah, I realized that after I posted, then went\
    \ to post an updated answer... I'll leave it up for the next guy though\n<|/ c\
    \ |>\n<| a tags=ruby,arrays |>\n<code>", "  sum = 0\n  (0...lst.length).each do\
    \ |i|\n    if i % 2 == 1\n      sum += lst[i]\n    end\n  end\n  sum\nend\n</cell>\n\
    <code language=julia-1.4>\nadd([4, 2, 6, 7])\n</cell>\n<code language=julia-1.4>",
  "  even = 0\n  odd = 0\n  for i in 0..length(lst) - 1 do\n    if i % 2 == 0 then\n\
    \      even += lst[i]\n    elsif i % 2 == 1 then\n      odd += lst[i]\n    end\n\
    \  end\n  even + odd\nend\n</code>\n<|/ a tags=ruby,arrays dscore=1 |>\n<| c |>\n\
    Can you add a link to the original paper, please? Also, what is the point of `length`\
    \ in your example?\n<|/ c |>\n<| c |>\nAdded a link. Thanks.\n<|/ c |>\n<| c |>\n\
    This solution looks great except for `Array#length`.  It has been available since\
    \ Ruby 1.9.\n<|/ c |>\n<| a dscore=1 tags=ruby,arrays |>\nYou can do this with\
    \ one line of code:\n<code>\narr = [\"a\", \"b\", \"c\", \"d\", \"e\"]\narr =\
    \ arr.each_with_index.map {|value, index| index % 2 == 0 ? value : nil}.compact\n\
    arr.flatten\n</code>\nExplanation:", "  return lst.inject { |sum, el| sum + el\
    \ if el % 2 == 1 }\nend\n  ", "    evens = evens.nil? ? 0 : evens \n    evens\
    \ += lst[1..lst.size].select {|i| i % 2 == 0}\nend\n</code>\n<|/ a |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ |>\nThis is a method I put together. \n<code>", "  even = lst[0..lst.size /\
    \ 2]\n  odd  = lst[lst.size / 2..end]\n  result = even.inject { |sum, e| sum +\
    \ e } + odd.inject { |sum, e| sum + e }\n  result if even.empty? and odd.empty?\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThanks for your detailed explanation.\n<|/ c\
    \ |>\n<| a tags=ruby,algorithm |>\n<code>", "  return sum(lst[1::2])\nend", " \
    \ return if lst.empty? || lst.size == 1\n  return lst.pop + lst.pop if lst.size\
    \ % 2 == 0\n  lst.pop + lst.pop + add(lst[1..-1])\nend", "  return lst[0] + lst[1]\
    \ * 2\nend", "  if lst.empty?\n    0\n  elsif lst.size == 1\n    lst[0]\n  else\n\
    \    odd_index = 0\n    even_index = 1\n    even = lst[even_index]\n    odd =\
    \ lst[odd_index]\n    \n    if even_index < lst.size \n      lst[odd_index] =\
    \ (even + lst[even_index])\n      even_index += 1\n      odd += even\n    elsif\
    \ odd_index < lst.size\n      lst[even_index] = (odd + lst[odd_index])\n     \
    \ odd_index += 1\n      even += odd\n    else\n      lst[even_index] = even\n\
    \      odd_index += 1\n    end\n    \n    add lst \n  end\nend", "  return lst.inject(0)\
    \ { |sum, el| sum + el if el.odd? }\nend", "  even.each_with_index do |e, i| +=\
    \ e if i%2 == 1 end \nend", "  # +++your code here+++\n  return lst.inject { |sum,\
    \ e| sum + e if e.odd? }\nend", "  evens = []\n  odd = []\n  for i in lst\n  \
    \  if i.even?\n      evens << i\n    else odds << i\n  end\n  evens.inject(0)\
    \ {|sum, e| sum + e}\n  odd.inject(0) {|sum, e| sum + e}\nend\n</cell>\n<cell>",
  "    even = lst.select {|e| e % 2 == 0}\n    odd = lst.select {|e| e % 2 == 1}\n\
    \    even.inject(0) {|sum, e| sum + e}\nend", "  return lst.inject(0) {|sum,i|\
    \ sum + i} if lst.length.is_even\n  sum = 0\n  for i in 0...lst.length\n    sum\
    \ += lst[i]\n    lst[i] = sum\n  end\n  return sum\nend\n</cell>\n<cell>\nadd(lst)\n\
    </cell>\n<cell>\nadd(lst)\n</cell>\n<cell>\nadd(lst)\n</cell>\n<cell>\nadd(lst)\n\
    </cell>\n<cell>\nadd(lst)\n</cell>\n<cell>\nadd(lst)\n</cell>\n<cell>\nadd(lst)\n\
    </cell>\n<cell>\nadd(lst)\n</cell>\n<cell>\nadd(lst)\n</cell>\n<cell>\nadd(lst)\n\
    </cell>\n<cell>\nadd(lst)\n</cell>\n<cell>\nadd(lst)\n</cell>\n<cell>\nadd(lst)\n\
    </cell>\n<cell>\nadd(lst)\n</cell>\n<cell>\nadd(lst)\n</cell>\n<cell>\nadd(lst)\n\
    </cell>\n<cell>\nadd(lst)\n</cell>\n<cell>\nadd(lst)\n</cell>\n<cell>\nadd(lst)\n\
    </cell>\n<cell>\nadd(lst)\n</cell>\n<cell>\nadd(lst)\n</cell>\n<cell>\nadd(lst)\n\
    </cell>\n<cell>\nadd(lst)\n</cell>\n<cell>\nadd(lst)\n</cell>\n<cell>\nadd(lst)\n\
    </cell>\n<cell>\nadd(lst)\n</cell>\n<cell>\nadd(lst)\n</cell>\n<cell>\nadd(lst)\n\
    </cell>\n<cell>\nadd(lst)\n</cell>\n<cell>\nadd(lst)\n</cell>\n<cell>\nadd(lst)\n\
    </cell>\n<cell>\nadd(lst)\n</cell>\n<cell>\nadd(lst)\n</cell>\n<cell>\nadd(lst)\n\
    </cell>\n<cell>\nadd(lst)\n</cell>\n<cell>\nadd(lst)\n</cell>\n<cell>\nadd(lst)\n\
    </cell>\n<cell>\nadd(lst)\n</cell>\n<cell>", "  even = lst.select {|x| x % 2 ==\
    \ 0}\n  even.inject {|sum, x| sum += x}\nend", "  sum = 0\n  for i in 0..(lst.length\
    \ - 1)\n    sum += lst[i] * i + (lst[i + 1] if i + 1 < lst.length else 0)\n  return\
    \ sum\nend", "  return lst.reduce(:+)\nend", "  evens.reduce(lst, :+)\nend\n</cell>\n\
    <cell>", "    even_index = lst.select{|x| (x % 2 == 0) }\n    odd_index = lst.select{|x|\
    \ (x % 2 != 0) }\n    even_index + odd_index\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ dscore=1 |>\n<| c |>\nThis looks like a great answer, but I don't think the\
    \ OP wants just the sum of all the even elements, but rather the sum of all the\
    \ even elements that are located at the same indices as their neighbors.\n<|/\
    \ c |>\n<| c |>\n: good catch. Updated.\n<|/ c |>\n<| a dscore=1 tags=ruby,arrays\
    \ |>\n<code>\narr = [4, 2, 6, 7]", "  even = []\n  odd  = []\n  for i in lst\n\
    \    if i.even?\n      even << i\n    else\n      odd << i\n    end\n  end\n \
    \ even.zip(odd).inject(0){|x, y| x + y}\nend", "  # Your code here\n  return 0",
  "    even = lst[1..(lst.length-1)]\n    return even.inject(:+) if even.any?\nend\n\
    </cell>\n<code language=julia-0.4>\nadd(lst)\n</cell>\n<code language=julia-0.4>\n\
    function even_sums(lst)\n    evens = filter(n -> n % 2 == 0, lst)\n    return\
    \ sum(evens)\nend", "  even = 0\n  odd = 0\n  evens = false\n  odd = 1", "   \
    \ even = lst.find_all{|i| i % 2 == 0}\n    odd = lst.find_all{|i| i % 2 != 0}\n\
    \    even.each do |i|\n        if lst.count(i) <= 1\n            return nil\n\
    \        end\n        lst << i\n    end\n    odd.each do |i|\n        if lst.count(i)\
    \ <= 1\n            return nil\n        end\n        lst.delete(i)\n    end\n\
    \    lst.count\nend\n</cell>\n<code language=other-env>", "  even = 0\n  odd =\
    \ 1\n  for i in lst do\n    if i % 2 != 0\n      even += i\n    else\n      odd\
    \ += i\n  end\n  even\nend\n</cell>\n<code language=julia-0.5>\nadd(lst)\n</cell>\n\
    <text>\nWhat happens if you pass this array in as the argument to a function that\
    \ expects a vector?", "  even_indexes.each_with_index { |e,i| lst[i..-1].include?(e)\
    \ ? lst.reduce(:+) : nil }\nend", "    evens = evens(lst)\n    odd = odd(lst)\n\
    \    evens.reduce(:+)\n    odd.reduce(:+)\nend\n</cell>\n<cell>\nadd(arr)\n</cell>\n\
    <cell>", "  lst.each_with_index do |e, i|\n    i += 1 if i % 2 == 1\n    lst[i]\
    \ = e + lst[i - 1] if i > 1\n  end\n  lst[0]\nend", "  even_index = lst.index\
    \ { |x| x % 2 == 0 }\n  even_index.zip(lst.drop(even_index))\n              .map\
    \ { |x, y| x + y }\n              .reduce(:+)\nend", "  return lst.inject {|a,\
    \ b| a + b}\nend", "  return sum( lst[1..] & lst[2..] )\nend", "  lst.each_with_index\
    \ { |x, i| if i.odd? then x + lst[i] else x}\nend", "  even = []\n  odd = []\n\
    \  for x in lst\n    if x.is_even?\n      even << x\n    else\n      odd << x\n\
    \    end\n  end\n  even.inject(0){|sum,x| sum + x}\nend\n</cell>\n<cell>", " \
    \ even = 0\n  odd = 1\n  for i in 0...lst.size\n    if i mod 2 = 0\n      even\
    \ = even+lst[i]\n    else\n      odd += lst[i]\n  end\n  return even+odd\nend\n\
    </code>\nThen I realized that in Ruby, it would be much easier to use a combination\
    \ of #map (which maps a function onto an array) and #reduce (which reduces an\
    \ array to a single value)\n<code>", "  even = lst[1..-1]\n  odd = lst[2..-1]\n\
    \  even.inject(0) do |sum, value|\n    sum + value\n  end\nend", "  even = 0\n\
    \  odd = 1\n  for i in lst\n    even = even + i\n    odd = odd + i\n  even\nend\n\
    </cell>\n<cell>", "  even = lst.each_with_index do |e, i|\n    if i % 2 == 0\n\
    \      e + lst[i+1]\n    end\n  end\n  even.inject(&:+)\nend\n</cell>\n<code language=conda-env-adventofcode-py>\n\
    %matplotlib inline\n</cell>\n<code language=conda-env-adventofcode-py>\nadd([4,\
    \ 2, 6, 7])\n</cell>\n<code language=conda-env-adventofcode-py>\nadd([4, 2, 6,\
    \ 3, 7, 0, 1])\n</cell>\n<code language=conda-env-adventofcode-py>\nadd([4, 2,\
    \ 6, 3, 7, 0, 1, 0, 0, 0])\n</cell>\n<text>\nProblem 7\nWrite a function that\
    \ returns true or false depending on whether a number is prime or not. \nA prime\
    \ number is a natural number greater than 1 that has no positive divisors other\
    \ than 1 and itself.", "  # +++your code here+++\n  return sum( [ lst[i] for i\
    \ in range(len(lst)) if i % 2 == 1 ] )\nend", "  return lst.inject(:+)\nend\n\
    </cell>\n<cell>", "  return lst[0] + lst[1] if (lst.length % 2 == 0) else lst[0]\
    \ + lst[1]\nend", "  even_indexes = lst.select { |x| x % 2 == 0 }\n  odd_indexes\
    \ = lst.select { |x| x % 2 == 1 }\n  even_indexes + odd_indexes\nend", "    even\
    \ = 0\n    odd = 0\n    for i in lst\n        if i.even?\n            even = even\
    \ + i\n        else \n            odd = odd + i\n    return even, odd\nend\n</cell>\n\
    <code language=julia-1.5>\nadd([4, 2, 6, 7])\n</cell>\n<text>\nExercise: Given\
    \ an array of integers lst and a positive integer p, where l is the length of\
    \ lst, return the sum of the first l elements such that \nl[i] + l[i+1] + ...\
    \ + l[l-1] = p.", "    even = even.call([lst[n] | n <- [1..(length lst)], n %\
    \ 2 == 0])\n    odd = odd.call(lst[1..])\n    even + odd\nend", '  return 0',
  "  lst.map! {|e| e if e.odd? && e % 2 == 0}\n  lst\nend\n</cell>\n<code language=julia-1.0>\n\
    function add.call(a)\n    println(add(a))\nend\n</cell>\n<code language=julia-1.0>",
  "  even = 0\n  odd = 1\n  for i in lst do\n    even = even + i\n    odd = even +\
    \ odd\n  end\n  return odd\nend\n</cell>\n<code language=julia-1.4>\nusing Test\n\
    </cell>\n<code language=julia-1.4>\nfunction add_tests(n, list)\n  answer = add(list)\n\
    \  @test answer == n\nend", "  sum = 0\n  lst.each_with_index do |e, i|\n    sum\
    \ +=  if i % 2 == 0\n             e\n           else\n             0\n       \
    \    end\n  end\n  sum\nend", "  return nil unless lst\n  even = even(lst, 0)\n\
    \  even.empty? ? nil : even[0]\nend", "  return lst.inject(0) { |sum, val| sum\
    \ + val if val % 2 == 1 }\nend", "    # your code here\n    return 0", "  return\
    \ 0\nend", "  return lst.inject(:+)\nend", "  sum = 0\n  sum = 0\n  for i in 0...lst.length-1\n\
    \    if lst[i] % 2\n      sum += lst[i]\n    end\n  end\n  sum\nend", "\tlst.each_with_index\
    \ do |e, i|\n\t\tlst[i] += 1 if i % 2 == 0\n\tend\nend", "  lst.inject(0){|sum,x|\
    \ sum+=x if x % 2 == 1}\nend", "    even = []\n    odd = []\n    for i in lst\n\
    \        if i.odd?\n            odd << i\n        else\n            even << i\n\
    \        end\n    end\n    even.inject(:+)\nend\n</code>\n<|/ a tags=ruby,arrays,loops\
    \ dscore=1 |>\n<| a |>\nA more \"Rubyish\" approach is to use Enumerable#partition\
    \ along with Enumerable#map:\n<code>\nary = [1, 2, 3, 4, 5]\nary, *_ = (ary +\
    \ ary).partition { |i| i.odd? }", "  even = 0\n  odd = 0\n  for i in lst\n   \
    \ if i % 2 == 0\n      even += i\n    else\n      odd += i\n  end\n  return even,\
    \ odd\nend", "  return lst.inject(0){|sum,el| sum + el % 2 }\nend\nputs add(ARGV)",
  "    return lst.inject(:+)\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n+1 for showing\
    \ how `inject` is more concise and less obfuscated than `map`/`collect`.\n<|/\
    \ c |>\n<| c |>\nIf you're looking for brevity, it's worth noting that the [Ruby\
    \ documentation](http://ruby-doc.org/core/classes/Enumerable.html#M000950) states\
    \ \"[As with map, collect! and select, collect and detect](http://ruby-doc.org/core/classes/Enumerable.html#M000950)\
    \ can iterate over arrays more efficiently and often provide a better performance\
    \ boost than map/collect/select.\" The [benchmark](http://stackoverflow.com/a/34102820/128400)\
    \ proves this. Also, you can write `return lst.inject(:+).to_i` to get the integer\
    \ value from the array.\n<|/ c |>\n<| c |>\n`map` and `collect` are more concise,\
    \ `inject` has a more general purpose. It does not require enumerable to be an\
    \ array.\n<|/ c |>\n<| a dscore=5 |>\nYou want to be using the map function, which\
    \ will create a new array of values with the modified values from the original\
    \ array. This is the same as:\n<code>\nevenNumbers = [2, 4, 6, 8]\noddNumbers\
    \ = [1, 3, 5, 7]", "  even = lst[1..-1]\n  odd = lst[2..-1]\n  even.inject {|sum,\
    \ value| sum + value if value % 2 == 1} + even.sum\nend\n</cell>\n<cell>\nadd.call([4,\
    \ 2, 6, 7])\n</cell>\n<text>\n6. map", "  even_index = 0 \n  even_sum = 0\n  odd_index\
    \ = 0 \n  odd_sum = 0\n  for i in lst\n    if i % 2 == 0\n      even_sum += i\n\
    \      even_index += 1\n    else\n      odd_sum += i\n      odd_index += 1\n \
    \ end\n  return even_sum + odd_sum\nend", "  even = lst[0,1,3,5,7,9] #the even\
    \ elements\n  odd = lst[2,4,6,8,10]  # the odd elements\n  even.inject { |sum,\
    \ e| sum + e } # inject will add elements into an array\n  odd.inject { |sum,\
    \ e| sum + e }\nend\n</cell>\n<cell>", "  # Your code here\n  return 0\nend\n\
    </cell>\n<text>\nProblem 11\nImplement the function even_at_odd that takes as\
    \ input a list of integers and returns the sum of only the even values at odd\
    \ indices.", "  even = []\n  odd = []\n  index = 0", "  i = 0\n  even = 0\n  while\
    \ i < lst.length\n    if (lst.at(i) %2 != 0)\n      even = even + lst.at(i)\n\
    \    end\n    i = i + 1\n  end\n  return even\nend", "  even = []\n  odd = []\n\
    \  for i in lst\n    if i % 2 == 0\n      even << i\n    else\n      odd << i\n\
    \    end\n  end\n  even.zip(odd).inject(&:+)\nend", "    ev = lst.inject(0) do\
    \ |acc, el|\n        acc + (el % 2 == 0 ? el : 0)\n    end\nend", "  even = []\n\
    \  odd = []\n  even.each {|el| odd << lst.delete(el)}\n  even.each {|el| even\
    \ << el}\n  even.each {|el| lst << el}\n  even.sort\nend\nadd([4, 2, 6, 7])",
  "  return lst.length if lst.length==0 then 0 else lst[lst.length-1] + add(lst[0...lst.length-2])\n\
    end", "  even = lst.select { |x| x % 2 == 0 }\n  even.inject(0) { |sum, element|\
    \ sum + element }\nend\n</pre>", "  even = lst.find {|x| x % 2 == 0}\n  if even.nil?\n\
    \    lst.sum\n  else\n    even + lst.find {|x| x % 2 == 1}\n  end\nend\n</cell>\n\
    <code language=julia-1.6>\nadd(lst)\n</cell>\n<code language=julia-1.6>", "  result\
    \ = 0\n  even_indices = []\n  odd_indices = []\n  for i in 0...lst.size\n    if\
    \ i % 2 == 0\n      even_indices.push(i)\n    else \n      odd_indices.push(i)\n\
    \    end if\n  end\n  even_indices.each do |i|\n    result += lst[i]\n  end\n\
    \  odd_indices.each do |i|\n    result += lst[i]\n  end\n  return result\nend",
  "  even = lst.select { |e| e % 2 == 1 }\n  return even.inject(0) { |sum, i| sum\
    \ + i }\nend", "  even = []\n  odd = []\n  for i in 0..(lst.length - 1)\n    if\
    \ i % 2 == 0\n      even.push(lst[i])\n    else\n      odd << lst[i]\n    end\n\
    \  end", "  even.size += lst.size.odd? ? 0 : lst.size.even? ? 1 : 0\nend", " \
    \   even = []\n    odd = []\n    for e in lst\n        if e % 2 == 0\n       \
    \     even << e\n        else\n            odd << e\n    end\n    # Do whatever\
    \ you want.\n    # Return something\nend\n</cell>\n<cell>\nadd(lst)\n</cell>\n\
    <text>\n2. Write a function that takes a number n and returns the sum of all odd\
    \ integers.", "  if lst.size <= 0\n    return 0\n  \n  sum = 0\n  i = 0\n  \n\
    \  while i < lst.size\n    if i % 2 != 0\n      sum += lst[i]\n    end\n    i\
    \ += 1\n  end\n  \n  return sum\nend\n</cell>\n<code language=julia-1.0>\n@assert\
    \ add.([4, 2, 6, 7]) == 6\n</cell>\n<code language=julia-1.0>", "\tsum = 0\n\t\
    for i in (0..lst.size)\n\t\tsum += lst[i]\n\tfor i in (0..(lst.size-2))\n\t\t\
    if lst[i] % 2 != 0\n\t\t\tsum += lst[i]\n\treturn sum\nend", "  # +++your code\
    \ here+++\n  if lst.empty?\n    0\n  elsif lst.size % 2\n    lst[l/2 + 1] + lst[l*2-1]\n\
    \  else\n    lst[l/2] + lst[l*2-1]\n  end\nend", "  return lst.length % 2 == 1\
    \ ? lst.length + lst.select {|x| x % 2 == 0 }.length : 0\nend\n</cell>\n<cell>",
  "  return sum(lst[1..-1][1..-1].take_while {|x| x%2 == 0})\nend\n</cell>\n<code\
    \ language=julia-0.6>", "  even = lst.select { |e| e.odd? }\n  even.inject(0)\
    \ { |sum, e| sum + e }\nend", "  # +++your code here+++\n  if lst.length < 2\n\
    \    return 0\n  el = lst.length - 1\n  while el > 0\n    return el + add(lst[el])\
    \ if el % 2 == 1 then return el + add(lst[el]) else el\n  end\nend", "    return\
    \ lst.reduce(:+)\nend", "  even = @[]\n  odd = @[]", "  lst.inject(0) do |sum,\
    \ e|\n    if e.odd?\n      sum + e\n    else\n      sum\n    end\n  end\nend",
  "  return lst.sum { |i| i % 2 == 1 }\nend", "  if lst.size == 0\n    return 0\n\
    \  even_index = lst.find{|n| n % 2 == 0}\n  odd_index = lst.find{|n| n % 2 !=\
    \ 0}\n  \n  if even_index != nil\n    return even_index + odd_index\n  else\n\
    \    return nil\n  end\nend", "  even.call([1, 3, 5]) # 1 + 3\n  even.call([0,\
    \ 4, 6]) # 0 + 4\n  even.call([2, 4, 6]) # 2 + 4\n  even.call([0, 2, 6]) # 0 +\
    \ 2\n  even.call([2, 6, 7]) -> 6\n  even.call([3, 5, 7]) -> 6", "  even = 0\n\
    \  odd = 0\n  for number in lst\n    if number % 2 == 0\n      even = even + number\n\
    \    else\n      odd = odd + number\n    end\n  end\n  return even\nend", "  \
    \  i = 0\n    while i < lst.length\n        if lst[i] % 2 == 1\n            lst[lst.length]\
    \ += lst[i]\n            i += 1\n        end\n    end\n    return lst\nend", " \
    \ return lst.inject(0){|sum,e| sum + (e % 2 == 0 ? e : 0)}\nend", "  even = lst.length\
    \ % 2 == 0\n  return even.inject(0) do |sum, val| sum += val if even\nend", " \
    \ even = []\n  odd = []", "  even = 0\n  odd = 0\n  for i in lst.each_index do\n\
    \    if i%2 == 0\n      even += lst[i]\n    else\n      odd += lst[i]\n  end\n\
    \  return even+odd\nend\n</code>\n<|/ a tags=ruby,methods,arrays |>\n<| c |>\n\
    Nice job, although you can replace that `each_index` with `each_with_index` for\
    \ the first method, or `each_with_index` in the second method if you prefer.\n\
    <|/ c |>\n<| c |>\nThe third method (which should probably be the fourth?) also\
    \ has the advantage that it returns the result as a `Hash` instead of an `Array`,\
    \ which means you don't have to sum up all the elements to get the sum.\n<|/ c\
    \ |>\n<| c |>\nOh, and you shouldn't use global variables (`even` and `odd`) inside\
    \ methods. Pass them in as parameters.\n<|/ c |>\n<| a tags=ruby,methods,arrays\
    \ |>\nThis solution is similar to's solution but doesn't require the use of a\
    \ global variable:\n<code>", "  even = []\n  odd = []\n  even.concat(lst[0...even.count])\n\
    \  odd.concat(lst[2...odd.count])\n  even.inject(0){|sum, e| sum + e}\n  odd.inject(0){|sum,\
    \ o| sum + o}\nend\n</code>\n<|/ a tags=ruby dscore=1 |>\n<| a tags=ruby |>\n\
    <code>\na = [4, 2, 6, 7]", "  even = []\n  odd = []\n  for elem in lst\n    if\
    \ elem.odd? \n      odd << elem\n    else\n      even << elem\n    end\n  end\n\
    \  even.inject(0) do |result, elem|\n    result + elem\n  end\nend\n</cell>\n\
    <cell>", "    even = []\n    odd = []\n    l = lst.count\n    until l == 0\n \
    \       return even.count + odd.count\n        even.push(lst.pop)\n        odd.push(lst.pop)\n\
    \    end\nend\n        ", "  lst.map! {|e| e if e % 2 == 0}\n  lst\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nCan you add some context to the `add` method? Why\
    \ use `.map!` and why not `+=`?\n<|/ c |>\n<| c |>\nTo be honest, I am just trying\
    \ to learn Ruby and the map method was the first thing that came to mind.\n<|/\
    \ c |>\n<| c |>\nAh ok, no problem, I was just curious. I thought that `map` would\
    \ be a good place for it :P Anyway, +1 for the solution!\n<|/ c |>\n<| c |>\n\
    I should mention: I think you should use `map!` since you're mutating the array\
    \ and calling `map` returns a new array.\n<|/ c |>\n<| c |>\n`map!` mutates the\
    \ array and returns its new value. So yes, `map!` would be the more appropriate\
    \ choice. Thank you.\n<|/ c |>\n<| a tags=ruby |>\nA general solution (not limited\
    \ to arrays):\n<code>", "    even = []\n    odd = []\n    even.push(lst[0])\n\
    \    odd.push(lst[1])\n    if lst.length > 2\n        for i in 2..lst.length\n\
    \            even.push(lst[i])\n            odd.push(lst[i - 1])\n    even.sort\n\
    \    odd.sort\n    even.inject{|sum,x| sum + (x % 2 == 0 ? x : 0)}\n    odd.inject{|sum,x|\
    \ sum + (x % 2 == 1 ? x : 0)}\n    even.inject{|sum,x| sum + x}\n    odd.inject{|sum,x|\
    \ sum + x}\nend", "  return lst[1..-1].inject(:+)\nend", "  # Write your code\
    \ here\n  \n  # If the list has a length of 0 return 0\n  return 0\nend", "  result\
    \ = lst[0]\n  for x in lst[1..-1]\n    result += x\n  end\n  result\nend", " \
    \   even = []\n    odd = []\n    even.concat(lst[1..-1][1..])\n    odd.concat(lst[2..-1][1..])\n\
    \    even.inject(:+).to_i\n    odd.inject(:+).to_i\nend", "  return lst.inject(0){\
    \ |sum, e| sum + e % 2 }\nend", "  sum = 0\n  sum = 0\n  for n in lst\n    if\
    \ n % 2 == 0\n      sum = sum + n\n  end\n  puts sum\nend", "    even = []\n \
    \   odd = []\n    even = 0\n    odd = 1\n    \n    for i in lst\n        if i\
    \ % 2 == 0\n            even << i\n        else\n            odd << i\n      \
    \  end\n    end\n    \n    even.inject(0, :+).to_s\nend", "  return lst.inject(0)\
    \ { |sum, num| sum + num if num % 2 == 1 }\nend", "  even = []\n  even.concat(lst[0..(lst.length/2-1)])\n\
    \  even.concat(lst[(lst.length/2+1):(lst.length-1)])\n  return even.inject(:+)\n\
    end\n</code>\nThis works, but the inject function looks weird to me. I'm not sure\
    \ if it's the most efficient way to do it.\n<|/ a dscore=0 tags=ruby,arrays |>\n\
    <| c |>\nA simpler way would be `lst.each_cons(2).map(&:first).reduce(:+)`\n<|/\
    \ c |>\n<| c |>\nI wouldn't say it's simpler, I'd say it's more ruby-like. :)\n\
    <|/ c |>\n<| c |>\nAlso, your solution doesn't actually do anything other than\
    \ add the elements. But thanks anyways. Your solution is very smart, although\
    \ I'm not sure how it would compare in terms of efficiency. I'm going to stick\
    \ to my solution though. Thanks again.\n<|/ c |>\n<| a |>\nHere is a solution\
    \ that doesn't require the use of inject, which I think makes it more readable:\n\
    <code>", "  result = 1\n  for i in 0..(lst.size - 1) \n    if lst[i] % 2 == 1\n\
    \      result += lst[i]\n    end\n  end\n  result\nend", "  return lst.inject(0)\
    \ { |result, el| result + el if el & 1 }\nend\n</code>\n<|/ a dscore=0 |>\n<|\
    \ a |>\nI prefer using 'inject' method like this:\n<code>", "  lst.each do |el|\n\
    \    el if el %2 == 0\n  end\nend", "  even = []\n  odd = []", "  even = []\n\
    \  odd = []\n  even.push(*lst[0..lst.length-2])\n  even.push(*lst[2..lst.length-1])\n\
    \  odd.push(*lst[0..lst.length-1])\n  odd.push(*lst[2..lst.length-2])\n  even.push(*lst[0..lst.length-1])\n\
    \  even.push(*lst[1..lst.length-2])\n  odd.push(*lst[1..lst.length-2])\n  odd.push(*lst[0..lst.length-2])\n\
    \  even.push(*lst[2..lst.length-1])\n  even.push(*lst[0..lst.length-2])\n  even.push(*lst[1..lst.length-1])\n\
    \  odd.push(*lst[1..lst.length-2])\n  odd.push(*lst[1..lst.length-1])\n  even.push(*lst[2..lst.length-1])\n\
    \  even.push(*lst[2..lst.length-1])\n  even.push(*lst[0..lst.length-1])\n  odd.push(*lst[1..lst.length-1])\n\
    \  odd.push(*lst[1..lst.length-2])\n  odd.push(*lst[0..lst.length-2])\n  even.push(*lst[1..lst.length-1])\n\
    \  even.push(*lst[1..lst.length-1])\n  even.push(*lst[0..lst.length-1])\n  even.push(*lst[1..lst.length-2])\n\
    \  odd.push(*lst[1..lst.length-2])\n  odd.push(*lst[1..lst.length-1])\n  odd.push(*lst[0..lst.length-2])\n\
    \  odd.push(*lst[1..lst.length-2])\n  even.push(*lst[1..lst.length-2])\n  even.push(*lst[1..lst.length-1])\n\
    \  odd.push(*lst[0..lst.length-2])\n  odd.push(*lst[1..lst.length-2])\n  odd.push(*lst[1..lst.length-1])\n\
    \  even.push(*lst[0..lst.length-1])\n  even.push(*lst[0..lst.length-2])\n  odd.push(*lst[0..lst.length-2])\n\
    \  odd.push(*lst[0..lst.length-1])\n  even.push(*lst[1..lst.length-2])\n  even.push(*lst[1..lst.length-2])\n\
    \  even.push(*lst[1..", "  if lst.empty?\n    0\n  else\n    lst.detect { |x|\
    \ (x % 2).zero? ? (lst.pop + x) : x}\n  end\nend", "  return lst.inject(:+)\n\
    end", "    # Write your code here.\n    even = lst[0::2]\n    odd = lst[1::2]\n\
    \    even.each do |el|\n        el += odd\n    end\n    even.uniq.compact!\n \
    \   even.uniq.compact!\n    even.uniq!\n    even\nend\n</code>\n<|/ a |>\n<| a\
    \ dscore=2 |>\n<code>", "  return lst.inject(:+)\nend", "  even = 0\n  odd = 1\n\
    \  even = even.+(lst[even]*(lst[odd]))\n  return even\nend", "  for i in 0...lst.size\n\
    \    lst[i] = (lst[i] + lst[(i+1)..lst.size]).to_f\nend", "  return lst.inject(0)\
    \ { |sum, e| sum + e if e.odd? }\nend", "  even = lst.select{|x| x%2 == 1}\n \
    \ odd = lst.select{|x| x%2 == 0}\n  even.inject(0) do |sum, val|\n    sum + val\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,lambda,functional-programming |>\n<| a |>\n\
    To answer the question \"How do I write this as a functional style?\", one solution\
    \ is to think of it in terms of the \"map\" function and how that is related to\
    \ the function you want to create.\n\"map\" takes a function and applies it to\
    \ every element of an array and returns a new array with the results.\nFor example,\
    \ imagine we have a function\n<code>", "  lst.each_with_index { |n,i| n+=2*lst[(i+1)%lst.size]\
    \ if i%2==0 }\n  lst\nend", "  sum = 0\n  for i in lst\n    if i % 2 == 1\n  \
    \    sum += i\n    end\n  end\n  return sum\nend\n</cell>\n<cell>\nadd.call([4,\
    \ 2, 6, 7])\n</cell>\n<cell>", "  lst.each_with_index { |element, index| element\
    \ += 2*index }\n  lst.sum\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<|\
    \ a dscore=1 tags=ruby,ruby-on-rails |>\n<code>", "  count = 0\n  arr.each_index\
    \ do |i|\n    if i%2 != 0\n      arr[i] += count\n      count += 1\n    end\n\
    \  end\n  return arr\nend", "  i = 0\n  evenSum = 0", "    even = lst[1..-1].select\
    \ { |x| x % 2 == 0 }\n    even.inject(0) { |sum, x| sum + x }\nend\n</code>\n\
    <code>", "  return lst.inject(0) { |sum, el| sum + el if el % 2 == 1 }\nend",
  "  evens, odds = [], []\n  evens.push lst.shift\n  while lst != []\n    evens.push(lst.shift)\n\
    \    odds.push lst.shift\n  evens.inject(:+)\nend", "  sum = 0\n  for i in 0..length(lst)\n\
    \    if i % 2 = 0\n      sum += lst[i]\n    end\n  end\n  return sum\nend", " \
    \ evens = lst.select { |i| i.even? }\n  evens.inject(0) { |total, num| total +\
    \ num }\nend", "    # lst = [4, 2, 6, 7]\n    even = []\n    odd = []\n    size\
    \ = lst.length\n    while size > 0 do\n        if lst.length == 0 then\n     \
    \       return even.length\n        else if lst.length == 1 then\n           \
    \ return odd\n        else\n            lst.each_with_index { |n, i| odd.push(n)\
    \ if i % 2 == 1 }\n            lst.each_with_index { |n, i| even.push(n) if i\
    \ % 2 == 0 }\n            size = size - 1\n        end\n    end\n    even.length\n\
    end\nputs add([4, 2, 6, 7])", "    even = 1\n    odd = 0\n    even.call([lst[even-1],\
    \ lst[even]])\n    odd.call([lst[odd-1], lst[odd]])\n    sum = 0\n    sum = even.value\
    \ + odd.value\n    return sum", "    even, odd = 0, 0\n    even, odd = lst[1],\
    \ lst[2] if lst[2] < lst[1] else lst[1]", "  return lst.inject(0) { |total, n|\
    \ total + n if (n % 2) == 1 }\nend", "  return lst.inject(:+)\nend", "  result\
    \ = 0\n  for i in 0...(lst.size-1)\n    if lst[i] % 2 == 1\n      result += lst[i]\n\
    \    end\n  end\n  result\nend", "  lst.select {|i| i.odd?}.inject(0) {|a,e| a+e\
    \ }\nend\n</cell>\n<cell>\nadd(arr)\n</cell>\n<cell>", "  lst.inject(0, :+)\n\
    end", "  lst.inject(0) { |memo, item| memo + item % 2 }\nend", "  return 0 if\
    \ lst.length == 0 || !lst.isEmpty && lst.all?{|x| x % 2 == 0} && lst.count { |x|\
    \ x % 2 != 0 }.zero? \n  lst[0] += lst[lst.index{|x| x % 2 != 0} + 1].to_i\n \
    \ add.recur(lst[1..-1]).call\nend", '  return sum((lst[ev] for ev in (ev for ev
    in ev if ev % 2 != 0)))', "  even.each_with_index do |e,i|\n    lst[i] += e if\
    \ i % 2 == 0\n  end\n  lst\nend\n</cell>\n<code language=conda-env-cs362-py>\n\
    add(lst)\n</cell>\n<code language=conda-env-cs362-py>\nlst\n</cell>\n<code language=conda-env-cs362-py>",
  "  evens = evens.call\n  even_sum = even_sum.call\n  even_sum = 0\n  i = 0\n  while\
    \ i < lst.length\n    if i <evens.length\n      even_sum = even_sum + even_sums.call(evens,\
    \ i)\n      i = i + 1\n      end\n    if i < (evens.length + 2)\n      even_sum\
    \ = even_sum + lst[i]\n      i = i + 1\n      end\n    end\n  end\n  return even_sum\n\
    end", "  even.map { |x| lst[x] }\nend", "  even = []\n  odd = []\n  for x in lst\n\
    \    if x % 2 == 0\n      even << x\n    else\n      odd << x\n    end\n  end\n\
    \  even.inject { |a,b| a + b }\nend\n</cell>\n<cell>", "  # Your code here\n \
    \ return nil\nend\n</code>\nThis would be the second part. After you have this\
    \ code running, go ahead and write another module called sub that does the same\
    \ thing with sub. These two modules will both call add and return the value stored\
    \ in add's local variable in each instance.\n<code>", "  even, odd = 0, 1\n  even,\
    \ odd = 0, 1", "  return lst.reduce(:+)\nend", "    even = lst[1..-1].select {|e|\
    \ e.even?}\n    even.inject {|sum, i| sum + i}\nend\n</cell>\n<text>\nNow we can\
    \ use the add function as a callback to each() on arr:", "  even = []\n  odd =\
    \ []\n  for i in lst\n    if i % 2 == 0\n      even << i\n    else\n      odd\
    \ << i\n    end\n  end\n  even.inject(:+)\nend\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a dscore=1 |>\n<code>\na = [1,2,3,4,5,6,7,8]\n</code>", "  result = 0.0;\n \
    \ for i in 0...lst.length-1\n    result += lst[i];\n    if lst[i]%2 != 0\n   \
    \   result += lst[i/2];\n  end\n  return result;\nend", "  even.call (lst, lst.size)\n\
    end", "  return lst.inject(0) { |sum, el| sum + el if el % 2 != 0 }\nend", " \
    \   even_indexes = []\n    odd_indexes = []\n    for i in lst\n        if i %\
    \ 2 == 0\n            even_indexes << i\n        else\n            odd_indexes\
    \ << i\n    end\n    even_indexes.inject { |sum, e| sum + e }\n    odd_indexes.inject\
    \ { |sum, e| sum + e }\nend\n</cell>\n<code language=ruby-1.9>", "  return sum(\
    \ lst[ ::2 ] )\nend", "  sum = 0\n  for i in lst \n    if i%2 == 1\n      sum\
    \ += i\n  return sum\nend\n</cell>\n<code language=julia-0.5>\nadd(lst)\n</cell>\n\
    <code language=julia-0.5>", '  return nil if lst.size <= 0', "  sum = 0\n  for\
    \ i in lst\n    sum += i\n    if i&1 != 0\n      sum += 2*i\n  end\n  return sum\n\
    end", "  return lst.inject(0) { |sum, e| sum + (e % 2 == 0 ? e : 0) }\nend", " \
    \ even = []\n  odd = []\n  for x in lst\n    even.push(x) if x % 2 == 0\n    odd.push(x)\
    \ if x % 2 != 0\n  even.inject(0){|sum, x| sum + x}\n  odd.inject(0){|sum, x|\
    \ sum + x}\nend\n</cell>\n<code language=ruby-1.9.3-p194>", "  sum = 0\n  i =\
    \ 0\n  while i < lst.length\n    sum += lst[i]\n    i += 2\n  end\n  return sum\n\
    end", "  return sum( lst[2::2] ) if lst != [] else 0\nend", "  even = [lst[0..1]]\n\
    \  odd = [lst[2..-1]]\n  (even, odd).reduce(:+)\nend\n</cell>\n<text>\nNow let's\
    \ try it out. First, let's call the function with a couple of test cases:", " \
    \ sum = 0\n  even = []\n  odd = []\n  for i in 0...lst.size\n    if i % 2 = 0\n\
    \      even << lst[i]\n    else\n      odd << lst[i]\n    end\n  end\n  even.inject(&:+)\n\
    end", "  even = even.call( lst )\n  result = even.call( lst.call( lst.call( even\
    \ ) ) )\n  return result\nend", "  sum = 0\n  (0..lst.length-2).each do |i|\n\
    \    sum += lst[i] + lst[i+1] if i % 2 == 0\n  end\n  return sum\nend", "  return\
    \ lst.inject(:+)\nend", "  return nil if lst.empty?\n  even =  lst.map { |e| e\
    \ % 2 == 0 }\n  odd =  lst.map { |e| e % 2 != 0 }\n  even + odd\nend\n</code>\n\
    <|/ a tags=ruby,algorithm |>\n<| a dscore=0 |>\nI suggest using the inject method:\n\
    <code>", "  return lst.inject(0){ |sum, el| sum + el if el % 2 == 1 }\nend", " \
    \ return lst[1] + lst[2] if lst.length % 2 == 1 else lst[2] + lst[3]\nend", " \
    \ # Your code here\n  sum = 0\n  arr.each_index do |i|\n    if i%2 == 0\n    \
    \  sum += lst[i]\n    end\n  end\n  sum\nend\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nThank you for this, it looks very helpful. I'll play around with it. :)\n\
    <|/ c |>\n<| c |>\nI'm sorry to bother you again but I'm running into another\
    \ issue. I've been able to get the code to work for the most part, but it's spitting\
    \ out a weird number. If I input [4, 2, 6, 7] I get the right answer of 2 but\
    \ if I input [4, 2, 6] I get 3. I've been trying to figure this out for awhile,\
    \ but I'm completely stuck. I think I'm going to have to start a new question\
    \ since the code is getting a little longer than I expected.\n<|/ c |>\n<| c |>\n\
    I think I've figured out what's going on. I'm not sure why this is, exactly, but\
    \ it's because of the way I'm handling the index. It's being handed back the index\
    \ of the array, and then it's adding to the index. So, if the array is [4, 2,\
    \ 6] it's being handed back (1, 2), and adding that to the number at the 0th index.\
    \ I'm just not sure how to fix it though.\n<|/ c |>\n<| c |>\nOkay, now the issue\
    \ is fixed, I believe. The issue now is that it's adding +1 to the even indexes,\
    \ even though it's doing that on the odd indexes. For example, if the array is\
    \ [4, 2, 6], it's adding 2+1 = 3, instead of adding 3. I'm guessing it's because\
    \ the loop is counting from the beginning of the array (0) to the end, so it's\
    \ counting [4, 2, 6] as [4, 2, 6, 0], so it's adding +1 to the first even index.\
    \ How can I get it to add it to the odd indexes?\n<|/ c |>\n<| a |>\n<code>",
  "  i = 0\n  while i < lst.length\n    if i % 2 == 0\n      lst[i] = lst[i] + lst[i\
    \ + 1]\n      i += 1\n    end\n    i += 1\n  end\n  lst.length\nend", "  return\
    \ lst.inject(0) { |t,i| t + (lst[i].even? ? 0 : 1) }\nend\n</code>\n<|/ a |>\n\
    <| a dscore=0 |>\nI solved it like this:\n<code>", "  # Your code here\n  even_index\
    \ = 0\n  odd_index = 0\n  sum = 0\n  while (even_index < len(lst)) and (odd_index\
    \ < len(lst)):\n    if (lst[even_index]%2 == 0):\n      sum += lst[even_index]\n\
    \      even_index += 1\n    if (lst[odd_index]%2 != 0):\n      sum += lst[odd_index]\n\
    \      odd_index += 1\n  return sum", "  sum = 0\n  i = 0\n  while i < lst.length\n\
    \    if lst[i].even? and lst[i].odd?\n      sum += lst[i]\n    end\n    i += 1\n\
    \  end\n  sum\nend\n</cell>\n<cell>", "  even = []\n  odd = []\n  for i in lst\n\
    \    if i.even?\n      even << i\n    else\n      odd << i\n    end\n  end\n \
    \ even.inject { |sum, el| sum + el } + odd.inject { |sum, el| sum + el }\nend\n\
    </cell>\n<text>\nNow try it!", "  sum = 0\n  for i in 1..lst.length\n    if lst[i]\
    \ % 2 != 0\n      sum += lst[i]\n    end\n  end\n  sum\nend", "  even = []\n \
    \ odd = []\n  for e in lst\n    odd << e\n    even << e if e % 2 == 0\n  even.inject(0)\
    \ {|sum, e| sum + e}\nend", "  even_index = lst.each_with_index.map {|e, i| if\
    \ i % 2 != 0 then i end}\n  new_list = even_index + lst.drop(even_index.first)\n\
    \  return new_list.sum\nend\n</code>\n<|/ a |>\n<| c |>\nI like this solution,\
    \ but you might also want to consider the use of the modulo operator here; something\
    \ like: `lst.each_with_index.map { |e, i| i % 2 != 0 ? i : nil }.compact`.\n<|/\
    \ c |>\n<| a |>\nThe second answer using map method is the right answer but its\
    \ time complexity is not the best. I would suggest you to try this solution which\
    \ is in O(n) time complexity:\n<code>", "  return nil if lst.size <= 1\n  even\
    \ = lst.select { |x| x % 2 == 0 }\n  even.inject(0, :+)\nend", "  return (lst.each_with_index.map{|n,\
    \ i| n if i % 2 != 0}.inject(:+))\nend", "    even = nil\n    odd = nil\n    even\
    \ = even+lst[0]\n    odd = odd+lst[1]\n    even = even+lst[2]\n    odd = odd+lst[3]\n\
    \    even = even+lst[4]\n    odd = odd+lst[5]\n    return even+odd\nend", "  evens\
    \ = lst.select { |x| (x % 2).zero? }\n  evens.inject(0) { |m, x| m + x }\nend",
  "  even_index = lst.each_with_index.reduce(0) { |sum, (elem, i)| sum + elem*2+i\
    \ }\n  lst.size.times do |i|\n    lst[i] += lst[even_index]\n    even_index =\
    \ (even_index + lst[even_index] + i) % lst.length\n  end\n  lst\nend\n</cell>\n\
    <cell>", "  even = lst[1..-1]\n  odd = lst[0..-2]\n  even_sum = 0\n  odd_sum =\
    \ 0\n  for item in even\n    even_sum += item\n  end\n  for item in odd\n    odd_sum\
    \ += item\n  end\n  return even_sum + odd_sum\nend\nadd([1, 3, 2])\n</cell>\n\
    <code language=julia-1.0>", "  return [lst[0], lst[1]]\nend\n</cell>\n<code language=julia-1.0>",
  "  return lst.inject(0) { |sum, e| sum + e if odd e }\nend", "  lst.inject(0, :+)\n\
    end", "  even, odds = 0, 0\n  lst.each_with_index do |n, i|\n    if i % 2 == 0\n\
    \      even += n\n    else\n      odds += n\n    end\n  end\n  even += odds\n\
    \  return even\nend", "    even = []\n    for e in lst\n        if e % 2 == 0\n\
    \            even << e\n        end\n    end\n    return even.join\nend", "  return\
    \ lst.inject(:+)\nend", "  even = (lst - .even?) + .even?\n  odd = (lst - .odd?)\
    \ + .odd?\n  even.zero? ? odd.zero? ? nil : odd : even\nend", "    sum = lst[0]\n\
    \    lst.each_with_index do |n, i|\n        if i % 2 == 0\n            sum +=\
    \ n\n        end\n    end\n    return sum\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
