name: HumanEval_121_solution
language: rb
prompt: "# Given a non-empty array of integers, return the sum of all of the odd elements\
  \ that are in even positions.\n# Examples\n# >>> solution.call([5, 8, 7, 1])\n#\
  \ 12\n# >>> solution.call([3, 3, 3, 3, 3])\n# 9\n# >>> solution.call([30, 13, 24,\
  \ 321])\n# 0\ndef solution(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solution\n\
  \    candidate = method(:solution)\n    assert_equal(12, candidate.call([5, 8, 7,\
  \ 1]))\n    assert_equal(9, candidate.call([3, 3, 3, 3, 3]))\n    assert_equal(0,\
  \ candidate.call([30, 13, 24, 321]))\n    assert_equal(5, candidate.call([5, 9]))\n\
  \    assert_equal(0, candidate.call([2, 4, 8]))\n    assert_equal(23, candidate.call([30,\
  \ 13, 23, 32]))\n    assert_equal(3, candidate.call([3, 13, 2, 9]))\n  end\nend\n"
completions: ["  lst.each_with_index do |e, i|\n    return e unless i % 2 == 0\n \
    \ end\n  lst.sum\nend\n</cell>\n<cell>\n%q/", "  return lst.sum { |i| (lst[i]\
    \ % 2).zero? }\nend", "  lst.each_with_index {|x, i| return i + i + x if x % 2\
    \ == 1}\nend", "  evens, odds = lst.partition {|v| v & 1 == 0}\n  evens.reduce(:+)\
    \ + odds.reduce(:+)\nend", "    odd_even = (0 .. lst.size - 1).select { |index|\
    \ index % 2 == 1 }\n    lst.size - odd_even.size - odd_even.min\nend", "    even\
    \ = lst.select { |i| i % 2 == 0 }\n    odd = lst.select { |i| i % 2 != 0 }\n \
    \   even.inject(0) { |sum, e| sum + e }\nend\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nThanks for the answer! Can you please explain in words what you did in your\
    \ solution?\n<|/ c |>\n<| a dscore=0 |>\nRuby has a map method for Arrays. So\
    \ let's say you have a list of numbers. You want to add up the numbers that are\
    \ divisible by 2. If you're familiar with what map does, it essentially goes through\
    \ each element and applies a block to it.\nFor example:\n<code>\n[1, 2, 3].map\
    \ { |x| x * x }", "    sum = nil\n    evens = lst.select.with_index { |_, i| i\
    \ % 2 == 1 }\n    odd = lst.select { |x| x % 2 == 0 }\n    evens.each { |x| sum\
    \ += x }\n    sum + odd.inject(0, &:+)\nend", "  even = lst.each_with_index.map\
    \ { |n, i| n if i.even? }\n  even.sum\nend", "  return lst.sum{|x| x % 2 > 0}\n\
    end", "  return lst.inject(0){ |sum, i| sum + i * 2 % 2 }\nend", "  even.inject(0,\
    \ :+)\nend", "  return lst.map { |x| x+1 if x%2 == 1 }.sum\nend\n</code>\n<|/\
    \ a tags=ruby,ruby-on-rails-3 |>\n<| a tags=ruby,ruby-on-rails-3 |>\nHere is a\
    \ simple way using Array#reduce:\n<code>", "  return lst.select{ |x| x % 2 ==\
    \ 1 }.sum\nend\n</code>\nThe code above is O(n) and is very efficient.\nThe other\
    \ approach, using the .each_with_index method, and calculating the index within\
    \ the block based on a modulo calculation, is O(n), but slightly less efficient.\n\
    <|/ a tags=ruby dscore=0 |>\n<| c |>\nThe last one is the most efficient and easy\
    \ to understand\n<|/ c |>\n<| c |>\nI agree, it's quite easy to understand. However,\
    \ the second example is even less efficient than the first one, since `each_with_index`\
    \ requires that you know the index.\n<|/ c |>\n<| c |>\nThe second one is inefficient,\
    \ but the first one is very efficient and elegant. Why do you say that it is less\
    \ efficient?\n<|/ c |>\n<| c |>\nI said it was less efficient because you don't\
    \ have to know the index when calling `each_with_index`. It's not efficient, per\
    \ se, because it requires you to iterate twice over the array, but it's more efficient\
    \ because you don't have to call `sum` on every element.\n<|/ c |>\n<| c |>\n\
    I got your point. I just added it to my answer.\n<|/ c |>\n<| a tags=ruby |>\n\
    <code>", "  lst.each_with_index { |val, i| val + (i > 0 && lst[i - 1] % 2 == 0\
    \ ? lst[i - 1] : 0) }\nend\n</code>\n<|/ a tags=arrays,ruby,loops |>\n<| a |>\n\
    <code>", "  return lst.inject(:+)\nend", "  lst.each_with_index.reduce(0) { |sum,\
    \ (_, i)| sum + lst[i] % 2 == 1 ? sum : nil }\nend", "  even = lst.select { |x|\
    \ x % 2 == 0 }\n  odd = lst.select { |x| x % 2 != 0 }\n  even.inject(0) { |sum,\
    \ e| sum + e }\nend", "    return sum((lst[idx::2] for idx in range(len(lst))\
    \ if idx % 2 != 0))\nend", "  sum = 0\n  for i in 0...lst.size\n    sum += lst[i%lst.size]\
    \ if lst[i] % 2 == 1 else  0\n  sum\nend", "  return lst.select { |x| x % 2 ==\
    \ 1 }.inject(:+)\nend", "  lst.each { |n| n += 1 if n.odd? }\n  lst.find { |n|\
    \ n.even? } || 0\nend\n</code>\n<|/ a tags=ruby,arrays,algorithm dscore=2 |>\n\
    <| c |>\nI like this answer because it doesn't rely on anything that's not part\
    \ of standard ruby. I don't know if this is the most efficient way of solving\
    \ the problem, but it seems very clear and simple.\n<|/ c |>\n<| c |>\nThis code\
    \ may give wrong answer if the array is sorted.\n<|/ c |>\n<| c |>\n- Yes, it\
    \ does give a wrong answer if the array is sorted. But the OP explicitly states\
    \ that he only wants to sum all odd elements, not whether they're in the array.\
    \ Sure, it doesn't make a difference whether the array is sorted or not.\n<|/\
    \ c |>\n<| a |>\n<code>\narray.select { |i| i.odd? }.reduce(:+)\n</code>\n<|/\
    \ a dscore=2 tags=ruby,arrays,algorithm |>\n<| c |>\nI believe reduce is O(n),\
    \ but it's clever, and it can be condensed to a single statement. Nice!\n<|/ c\
    \ |>\n<| c |>\nThis is definitely the most concise answer, and certainly deserves\
    \ upvoting.\n<|/ c |>\n<| a tags=ruby,arrays,algorithm |>\nA simple loop that\
    \ adds the odd numbers to a total:\n<code>", "  lst.each_with_index do |n, i|\n\
    \    if i % 2 == 1\n      lst.delete_at(i)\n    end\n  end\n  return lst.inject(:+)\n\
    end", "  # TODO: Write your solution here.\n  result = arr.select { |x| x % 2\
    \ == 0 }.inject(:+)\n  puts result\nend", "  lst.inject(0) {|sum,element| sum+=element\
    \ if element.odd? }\nend", "  return lst.inject {|sum,x| sum + x if x.odd? } if\
    \ lst.empty? \n  sum = 0\n  lst.each_with_index do |val,i|\n    sum += val if\
    \ val.odd?\n  end\n  sum\nend\n</code>\n<|/ a dscore=3 tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nThe `sum` variable is not needed.\n<|/ c |>\n<| c |>\nNot for Ruby\
    \ 2.2+ or Rails 4.1+.\n<|/ c |>\n<| a |>\n<code>", "  lst.each do |i|\n    (i\
    \ % 2).zero? ? sum += i : sum\n  end\n  sum\nend", "    odd_elements = lst.select\
    \ { |x| x % 2 != 0 }\n    odd_elements.reduce(:+)\nend", "  return lst.select\
    \ { |x| x % 2 == 1 }.inject { |sum, x| sum + x }\nend", "  sum = lst.select {\
    \ |x| x % 2 == 1 }.sum\n  sum -= lst.select { |x| x % 2 == 0 }.sum\n  sum\nend",
  "  return lst.inject(:+) do |s, el|\n    if el%2 == 0 then s + el else s end\n \
    \ end\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\nYou can use each_with_index to\
    \ get the indexes for each element, then add up the indexes and use the modulo\
    \ operator to determine whether the current number is even or not.\n<code>\neven_indices\
    \ = arr.each_with_index.map { |e,i| i if e%2 == 0 }.compact\narr.size - even_indices.sum\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\nI think you have a typo. The first line\
    \ should be `even_indices = arr.each_with_index.map { |e,i| i if e%2 == 0 }.compact`\n\
    <|/ c |>\n<| a |>\nHere is another solution using inject :\n<code>", "  return\
    \ lst.find_all { |i| i % 2 != 0 }.inject(0) { |sum, i| sum + i }\nend", "  sum\
    \ = 0\n  i = 0\n  while i < lst.size\n    if lst[i] % 2 == 1\n      sum += lst[i]\n\
    \      i += 1\n    else\n      i += 1\n    end\n  end\n  return sum\nend", " \
    \ return lst.inject{|sum, el| sum+el if el % 2 == 1}\nend", "  sum = 0\n  odd\
    \ = lst.select { |e| (e % 2 == 1) }\n  even = lst.select { |e| (e % 2 == 0) }",
  "  lst.each_with_index.with_object([]) { |(val, idx), acc|\n    acc << (idx % 2\
    \ == 1 ? val : 0)\n  }.inject(0, :+)\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| a dscore=0 tags=ruby,ruby-on-rails |>\nHere's another approach:\n<code>\n\
    a = [5, 8, 7, 1]", "  lst.each { |i| i.odd? && i.even? && i+1 }\n  lst.find {\
    \ |i| i.odd? }.nil? ? lst.sum : 0\nend", "  return lst.inject(:+).to_f % 2\nend",
  "  lst = lst.sort\n  sum = 0\n  even = []\n  odd = []\n  arr.each do |i|\n    even\
    \ << i if i%2 == 0\n    odd << i if i%2 != 0\n  end\n  even.each do |i|\n    sum\
    \ += i if arr.index(i) < odd.index(arr.index(i))\n  end\n  sum\nend\n</code>\n\
    <|/ a dscore=0 tags=arrays,ruby,ruby-on-rails |>\n<| a |>\nI did a little more\
    \ thinking and here is another way to do it:\n<code>\narray1 = [5, 8, 7, 1]\n\
    array2 = [3, 3, 3, 3, 3]\narray3 = [30, 13, 24, 321]", "  \nend", "    return\
    \ lst.select{|x| (x % 2).zero?}.inject{|sum, x| sum + x}\nend", "  return lst.group_by\
    \ { |i| i & 1 }.inject(:+)\nend", "  if lst.empty?\n    0\n  else\n    sum_even\
    \ = lst.sum { |x| x % 2 == 0 }\n    sum_odd = lst.sum { |x| x % 2 != 0 }\n   \
    \ sum_even\n  end\nend", "  odd = (0...lst.size).select { |i| (lst[i] % 2).zero?\
    \ }\n  odd.inject(0) { |acc, e| acc + e }\nend", "  return lst.inject{|sum, i|\
    \ sum + i if i.odd? } if lst\nend", "  odd = lst.select { |x| (x % 2).zero? }\n\
    \  even = lst.select { |x| (x % 2).zero? ? 0 : x }\n  even.inject {|sum, e| sum\
    \ + e }\nend", "    even = lst.select { |x| x % 2 == 0 }\n    odd = lst.select\
    \ { |x| x % 2 != 0 }\n    even.inject(0) { |sum, v| sum + odd.count(v) }\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| a |>\nA bit late to the party, but I came across\
    \ this question while trying to solve a question for which I needed a solution\
    \ for Ruby 2.0 and came up with this simple solution which uses #each_cons:\n\
    <code>", "    return sum( lst[1::2] for _,x in enumerate(lst) if x%2==0 )\nend",
  "  return sum(lst[i % 2] | i * 2 for i, _ in enumerate(lst))\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\n\
    \U0001F9E0 Exercises", "  even = (lst.inject(:+) * 2).to_i % 2 != 0\n  odds =\
    \ lst.each_with_index.select { |x,i| x % 2 == 1 }\n  evens = lst.each_with_index.select\
    \ { |x,i| x % 2 == 0 }\n  (evens.inject(:+) - odds).abs\nend\n</code>\n<|/ a dscore=0\
    \ tags=algorithm,ruby |>\n<| c |>\nWhat does the `%` do there?\n<|/ c |>\n<| c\
    \ |>\nI guess you meant `even = lst.inject(:+).to_i % 2 != 0`.\n<|/ c |>\n<| c\
    \ |>\nI meant `even = lst.inject(:+).to_i % 2 != 0` but I guess `even = lst.inject(:+).to_i\
    \ % 2 == 1` will do. Thanks.\n<|/ c |>\n<| c |>\n, yes. That will work.  I guess\
    \ the OP was wondering why the `%` was necessary. He was using `even = (lst.inject(:+)\
    \ * 2).to_i % 2 != 0` which is unnecessary.\n<|/ c |>\n<| c |>\nYou mean I should\
    \ change the `even` assignment to `even = lst.inject(:+).to_i % 2 == 1`?\n<|/\
    \ c |>\n<| a dscore=0 |>\n<code>", "  sum = 0\n  lst.each_index do |i|\n    if\
    \ i % 2 == 1\n      sum += lst[i]\n    end\n  end\n  return sum\nend", "  sum\
    \ = 0\n  even = lst.select { |n| n % 2 == 0 }\n  even.each { |n| sum += n }\n\
    \  sum\nend", "  return lst.count(lst[1...-1].select(&:odd?).inject(:+)) if lst.count\
    \ != 0\n  0\nend", "  lst.each_with_index.inject(0) do |acc, (k, i)|\n    acc\
    \ += k if (i % 2 == 1)\n    acc\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nthanks\
    \ alot, i understood the inject and each_with_index methods now. Just started\
    \ learning ruby, I got this question online and i got the solution but i was curious\
    \ how it worked. I tried some methods and i understood that i was passing the\
    \ first element in the list in the block but i was unable to grasp the second\
    \ part of your code, i mean the acc += k part and how exactly the block is evaluated\n\
    <|/ c |>\n<| c |>\nThanks alot, i understood the inject and each_with_index methods\
    \ now. Just started learning ruby, I got this question online and i got the solution\
    \ but i was curious how it worked. I tried some methods and i understood that\
    \ i was passing the first element in the list in the block but i was unable to\
    \ grasp the second part of your code, i mean the acc += k part and how exactly\
    \ the block is evaluated.\n<|/ c |>\n<| c |>\nIt is the same as `acc += k if i\
    \ % 2 == 1`\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  return lst.inject(0) { |sum,\
    \ item| sum + item % 2 != 0 ? sum : sum + item}\nend", "    even = lst.select\
    \ {|x| x.odd?}\n    odd = lst.select {|x| !x.odd?}\n    (even.sum & odd.sum).to_i\n\
    end", "  return lst.inject(:+).select { |i| i % 2 == 1 }.max\nend", "    sum =\
    \ 0\n    even = 0", "  arr.inject(:+) do |s, i|\n    if i%2 == 1\n      s + lst[i]\n\
    \    end\n  end\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI think your solution\
    \ is more elegant than the accepted answer, but you should mention it here for\
    \ future visitors.\n<|/ c |>\n<| c |>\nAgreed! I added a note at the top.\n<|/\
    \ c |>\n<| a tags=ruby,arrays dscore=2 |>\n<code>", "  lst.each_with_index.map\
    \ {|e, i| e % 2 == 0 ? e : nil}.compact.reduce(:+)\nend\n</code>\n<|/ a dscore=2\
    \ tags=ruby,ruby-on-rails |>\n<| c |>\nIt's not an elegant solution, it's very\
    \ confusing for me. I'm learning Ruby. I would like to find a solution without\
    \ using 'each_with_index'.\n<|/ c |>\n<| c |>\nIt's worth reading the answers\
    \ to [this question](http://stackoverflow.com/questions/1292863/why-does-ruby-iterate-over-the-elements-in-1-6-times-as-opposed-to-each-element-in),\
    \ particularly [this one](http://stackoverflow.com/questions/4151780/explain-why-each-with-ruby-is-faster-than-each/4179048#4179048).\
    \ The second link shows that using each_with_index is not only much more elegant\
    \ than using `each`, it's also the only way to do this without using side-effects.\n\
    <|/ c |>\n<| c |>\nIf performance is critical, you might also want to consider\
    \ [this answer](http://stackoverflow.com/a/4151810/477037) from the same question,\
    \ which is better than using `each_with_index` (although it's longer), but still\
    \ uses `each`.\n<|/ c |>\n<| c |>\nI really appreciate your solution, but I was\
    \ asked to solve it without the use of each_with_index. Thank you anyways.\n<|/\
    \ c |>\n<| c |>\n, I don't see the point in that. Either the solution uses `each_with_index`\
    \ or it doesn't use it. You'll need to explain to whoever asked you to solve it\
    \ that it doesn't use `each_with_index` because otherwise, it's not going to work.\
    \ That's like saying \"Here's my requirements, but I can't use anything but your\
    \ brain\". You'll have to explain to whoever asked you to solve it that it doesn't\
    \ work. Also, `each_with_index` doesn't use any methods that would be slow for\
    \ that solution, so why not use it for yourself?\n<|/ c |>\n<| a dscore=1 tags=ruby,ruby-on-rails\
    \ |>\nYour solution is not very readable for me (it's Ruby). But here is my solution.\n\
    <code>", "    return lst.each_cons(2).map(&:sum).reduce(:+)\nend", "  lst.each_with_index\
    \ { |e, i| return e if i%2==0 }.reduce(0, :+)\nend", "  lst.each_with_index.inject(0)\
    \ { |acc, (i1, i2)| acc + i1 % 2 ? i1 + i2 : 0 }\nend", "  lst.sort\n  even_sum\
    \ = 0\n  odd_sum = 0\n  even_idx = nil\n  odd_idx = nil\n  for i in 0 ... lst.count-1\n\
    \    if i % 2 == 0\n      even_sum += lst[i]\n      even_idx << i\n    else\n\
    \      odd_sum += lst[i]\n      odd_idx << i\n    end\n  end\n  return even_sum\
    \ - odd_sum if even_sum > odd_sum\n  return(even_sum + odd_sum) if even_sum <\
    \ odd_sum\n  return(even_sum + odd_sum) if (even_sum == odd_sum) and (even_sum\
    \ > 0)\nend", "  even = lst.select { |x| x % 2 == 0 }\n  sum = even.inject(0)\
    \ { |sum, x| sum + x }\n  sum.odd? ? 0 : sum\nend\n</code>\n<|/ a |>\n<| a |>\n\
    Here is my Ruby solution\n<code>\nsum = 0\nnums = [1, 2, 3, 10, 12, 14]\nnums.each_index{|i|\
    \ sum += nums[i]}\n</code>\n<|/ a tags=ruby,arrays,sum dscore=2 |>\n<| c |>\n\
    This is more efficient than using inject.\n<|/ c |>\n<| c |>\nThis is clearly\
    \ the fastest solution by far.  In fact, this is the most succinct solution I've\
    \ seen so far.\n<|/ c |>\n<| a dscore=1 tags=ruby,arrays,sum |>\nThis is what\
    \ I usually do.\n<code>", "  evens_sum = 0\n  i = 0\n  while i < lst.size\n  \
    \  if i % 2 == 0\n      evens_sum += lst[i]\n      i += 1\n    else\n      i +=\
    \ 1\n    end\n  end\n  return evens_sum\nend", "  evenSum = 0\n  lst.each_index\
    \ do |i|\n    if (i % 2) == 0\n      evenSum += lst[i]\n    end\n  end\n  evenSum\n\
    end", "  sum = 0\n  for i in 0 .. lst.size - 1\n    if lst[i] % 2 == 1\n     \
    \ sum += lst[i]\n    end\n  end\n  return sum\nend", "  # Write your code in Ruby\n\
    \  lst.sort.reverse!\n  lst.each_with_index do |n, i|\n    if i % 2 == 0\n   \
    \   sum += n\n    end\n  end\n  sum\nend", "  lst.each_with_index do |num, i|\n\
    \    if i % 2 == 0\n      sum = sum + num\n    end\n  end\n  return sum\nend\n\
    </code>\nAs you can see in the comment, each_with_index makes it easy to iterate\
    \ over an array with indexes.\n<|/ a tags=ruby |>\n<| c |>\nThis is a great answer\
    \ and I appreciate the explanation. I accepted the other answer just because I\
    \ was curious about how my code could be cleaned up using Enumerable methods,\
    \ but I definitely prefer this solution. Also, thank you for the tips on how to\
    \ better phrase my questions.\n<|/ c |>\n<| c |>\nNo worries :) Well I'm glad\
    \ you chose the other answer because it uses Enumerable methods which is definitely\
    \ the way to go.\n<|/ c |>\n<| a dscore=1 tags=ruby |>\nThe problem is your if\
    \ condition. You want to check if the number is odd or even. \n<code>", "  sum\
    \ = 0 \n  even.each do |x|\n    sum += lst.find { |y| y == x && y % 2 == 1 }\n\
    \  end\n  sum\nend\n</code>\n<|/ a dscore=0 tags=ruby |>\n<| c |>\nThat's definitely\
    \ going to work. But I wonder about performance.\n<|/ c |>\n<| c |>\n, did you\
    \ give it a try?\n<|/ c |>\n<| c |>\nI did. I'm going to benchmark it.\n<|/ c\
    \ |>\n<| c |>\n, added the benchmarking results. Still fairly efficient, but still\
    \ slower than the other answers.\n<|/ c |>\n<| a dscore=0 tags=ruby |>\n<code>",
  "    evens = 0\n    for i in lst\n        if i.even?\n            evens += i\n \
    \       end\n    end\n    evens\nend\n</cell>\n<text>\n\U0001F47D\U0001F47E\U0001F47D\
    \U0001F47E", "  return lst.inject(0) { |sum, i| sum + lst[i...(i+2).any? { |j|\
    \ (j % 2 == 1) } ? 0 : 1 ]}\nend\n</code>\n<|/ a dscore=0 tags=ruby |>\n<| a |>\n\
    Here's a one-liner:\n<code>\n[1,2,3,4,5].inject(0) { |sum,x| sum + (x.odd? ? 0\
    \ : 1)}\n</code>\n<|/ a dscore=0 tags=ruby |>\n<| a tags=ruby |>\n<code>\narray\
    \ = [1,2,3,4,5,6,7,8,9,10]\narray.map { |x| x.odd? ? 0 : 1}.inject(:+)\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nYou don't need the block for `map`, just do: `array.map\
    \ { |x| x.odd? ? 0 : 1 }.inject(:+)`\n<|/ c |>\n<| a dscore=0 |>\nAn alternate\
    \ method using inject\n<code>", "    odd_elements = []\n    even = []", "  lst.each_with_index\
    \ do |element, index|\n    odd = index % 2 != 0\n    if odd\n      element + lst[index\
    \ + 1]\n    end\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis was my\
    \ first solution that came to my mind after I asked this question and it works\
    \ fine. I'm glad that I asked this question in hopes of finding a better solution.\
    \ Thanks.\n<|/ c |>\n<| c |>\nI'm happy to help. I also just thought of another\
    \ one. I'll edit my answer.\n<|/ c |>\n<| a tags=ruby,algorithm |>\n<code>", " \
    \ lst.sort.reduce(:+).select { |x| x % 2 != 0 }\nend", "  odd_sum = 0\n  even_sum\
    \ = 0\n  for i in lst\n    if i % 2 == 1\n      even_sum += i\n    else\n    \
    \  odd_sum += i\n  return odd_sum + even_sum\nend", "  return lst.inject(0){ |sum,\
    \ n| sum + n % 2 }\nend", "  arr = lst.to_a\n  arr.each_with_index do |item, index|\n\
    \    if index%2 == 0 \n      arr[index] += 1\n    end\n  end\n  arr.sum\nend\n\
    </code>\n<|/ a dscore=0 tags=arrays,ruby |>\n<| c |>\nThanks for your help. While\
    \ your code was very helpful, my problem was in how to determine \"even\".\n<|/\
    \ c |>\n<| c |>\nYour code can be made even more concise by doing: `arr.each_with_index.reduce(0)\
    \ { |s,(i1,i2)| i1+i2 if i1 % 2 == 1 }`. Ruby is an OO language so you don't need\
    \ to do things like `x = []; x = x.push...; x.sum`. Just do `x = []; x.push...;\
    \ x.sum`\n<|/ c |>\n<| a dscore=0 tags=arrays,ruby |>\nYou can do it with a single\
    \ pass by using a hash to track the values that you've already seen. \n<code>\n\
    require 'set'", "  lst.each_with_index.reduce(0) { |total, item| total + (lst.find_index(item\
    \ & 1).nil? ? 0 : 1) }\nend", "  new_lst = lst.clone\n  new_lst.reject!{|x| x\
    \ % 2 == 1}\n  new_lst.sort!\n  new_lst.each_index{|i| new_lst[i] += (new_lst[i+1]\
    \ if new_lst.include?(new_lst[i+1]) })\n  new_lst\nend", "  # sort list\n  lst.sort\n\
    \  # initialize sum\n  sum = 0\n  lst.each do |x|\n    sum = sum + x if x % 2\
    \ == 1\n  end\n  sum\nend", "  arr.inject(0) { |acc, e| acc += e if e % 2 == 1\
    \ }\nend", "  return lst.select{|x| x % 2 == 0}.inject(:+)\nend\n</code>\n<|/\
    \ a tags=ruby,arrays,ruby-on-rails,ruby-on-rails-3 dscore=2 |>\n<| a |>\nThis\
    \ answer is an extension of answers above.\n<code>", "    odd = even = 0\n   \
    \ odd_index = 0\n    even_index = 0\n    lst.each_with_index do |x,i|\n      \
    \  if i % 2 == 0\n            even += x\n            even_index += 1\n       \
    \ else\n            odd += x\n            odd_index += 1\n        end\n    end\n\
    \    even += lst.drop(even_index).sum\n    odd += lst.drop(odd_index).sum\n  \
    \  even += odd.to_f\n    odd = odd.to_f\n    even -= odd\n    even /= 2\n    return\
    \ even\nend\n</code>\n<|/ a tags=algorithm,ruby,ruby-on-rails dscore=1 |>\n<|\
    \ a dscore=0 |>\nHere's a more readable version of the above solutions:\n<code>",
  "  lst.each_with_index do |x, i|\n    if i % 2 == 0\n      sum + x\n    end\n  end\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,arrays |>\nYou could use a hash\
    \ to keep track of the totals. \n<code>\narr = [2,3,4,5,6,7,8,9,10,11,12]", " \
    \   even = 0\n    odd = 1\n    sum = 0\n    even_index = 0", "  lst.each_with_index\
    \ do |num, index|\n    num < index ? (num + lst[index - 1]) : (num + lst[index\
    \ + 1])\n  end\nend\n</cell>\n<text>\nQuestion 7", "    sum = 0\n    odd_idx =\
    \ lst.find{ |x| x.odd? }\n    even_idx = lst.find{ |x| x.even? }\n    \n    while\
    \ even_idx.nil? && odd_idx.nil?\n      sum += lst[odd_idx]\n      odd_idx += 1\n\
    \      even_idx = lst.find{ |x| x.even? }\n    end\n    \n    sum += lst[odd_idx]\
    \ if odd_idx.nil?\n    sum += even_idx if even_idx.nil?\n    sum\n  end\nend\n\
    </cell>\n<cell>\nsolution([3, 5, -5, 8, 7])\n</cell>\n<cell>\nsolution([3, 3,\
    \ 3, 3, 3])\n</cell>\n<cell>\nsolution([30, 13, 24, 321])\n</cell>\n<text>\n\U0001F47D\
    \U0001F47E\U0001F47D\U0001F47E\U0001F47D\U0001F47E", "  # write your code in Ruby\n\
    \  lst.each_with_index do |v, i|\n    i % 2 != 0\n    v.odd? ? v + 1 : v\n  end\n\
    end", "  return lst.inject(0) { |result, el| el % 2 == 0 ? result + el : result\
    \ }\nend\n</cell>\n<code language=julia-1.5>", "    evens = lst.select { |x| (x\
    \ % 2).zero? }\n    sum = evens.reduce(:+)\n    \n    return sum % 2 != 0\nend\n\
    </cell>\n<code language=julia-0.5>\n@test solution([10, 50, 20, 30, 70])\n</cell>\n\
    <code language=julia-0.5>\n@test solution([30, 13, 24, 321])\n</cell>\n<code language=julia-0.5>\n\
    @test solution([3, 6, 9, 10, 22, 33, 44, 88])\n</cell>\n<code language=julia-0.5>\n\
    @test solution([5, 8, 7, 1])\n</cell>\n<code language=julia-0.5>\n@test solution([3,\
    \ 3, 3, 3, 3])\n</cell>\n<code language=julia-0.5>\n@test solution([2, 3, 2, 2,\
    \ 2])\n</cell>\n<code language=julia-0.5>\n@test solution([4, 3, 2])\n</cell>\n\
    <code language=julia-0.5>\n@test solution([2, 1, 2, 2, 1])\n</cell>\n<code language=julia-0.5>\n\
    @test solution([2, 3, 2, 3, 1, 3])\n</cell>\n<code language=julia-0.5>\n@test\
    \ solution([2, 4, 2, 4])\n</cell>\n<code language=julia-0.5>\n@test solution([3,\
    \ 2, 2, 3, 3])\n</cell>\n<code language=julia-0.5>\n@test solution([4, 3, 4, 4,\
    \ 2])\n</cell>\n<code language=julia-0.5>\n@test solution([10, 50, 20, 30, 70])\n\
    </cell>\n<code language=julia-0.5>\n@test solution([3, 6, 9, 10, 22, 33, 44, 88])\n\
    </cell>\n<code language=julia-0.5>\n@test solution([5, 8, 7, 1])\n</cell>\n<code\
    \ language=julia-0.5>\n@test solution([3, 3, 3, 3, 3])\n</cell>\n<code language=julia-0.5>\n\
    @test solution([2, 3, 2, 2, 2])\n</cell>\n<code language=julia-0.5>\n@test solution([4,\
    \ 3, 2])\n</cell>\n<code language=julia-0.5>\n@test solution([2, 1, 2, 2, 1])\n\
    </cell>\n<code language=julia-0.5>\n@test solution([2, 3, 2, 3, 1, 3])\n</cell>\n\
    <code language=julia-0.5>\n@test solution([2, 4, 2, 4])\n</cell>\n<code language=julia-0.5>\n\
    @test solution([3, 2, 2, 3, 3])\n</cell>\n<code language=julia-0.5>\n@test solution([4,\
    \ 3, 4, 4, 2])\n</cell>\n<code language=julia-0.5>\n@test solution([10, 50, 20,\
    \ 30, 70])\n</cell>\n<code language=julia-0.5>\n@", "  return sum [lst[pos] %\
    \ 2 == 0 for pos in 0..(length(lst) - 2)]\nend", "  return lst.inject(:+).to_i\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis would be more appropriate as a\
    \ comment on Sean's answer.\n<|/ c |>\n<| c |>\n, thank you! I have changed the\
    \ answer.\n<|/ c |>\n<| a dscore=2 |>\nYou could also use inject with a lambda:\n\
    <code>\narr = [1,2,3,4,5,6,7,8,9,10]\narr.reduce(:+).to_i", "  sum = 0\n  (0...lst.size).each\
    \ do |i|\n    if lst[i] % 2 == 1\n      sum = sum + lst[i]\n    end\n  end\n \
    \ sum\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis fails in case of an empty\
    \ array or a list of ones or twos or more than twenty elements. Your algorithm\
    \ should never fail in such scenario\n<|/ c |>\n<| c |>\nI realized this shortly\
    \ after posting and fixed it. Thanks for pointing it out!\n<|/ c |>\n<| a dscore=1\
    \ |>\nA simple one liner solution could be:\n<code>", "  even.inject(0) do |acc,\
    \ el|\n    acc += el if el % 2 == 0\n    acc += el if el % 2 == 1\n    acc\n \
    \ end\nend\n</code>\nThis code works by keeping track of the accumulated sum (acc)\
    \ and the even indices (even). We can then simply add the values that we haven't\
    \ seen yet in both arrays (sum and even), which gives us the correct result.\n\
    <|/ a tags=ruby |>\n<| c |>\n`even.inject(0){|acc,el| acc+el if el%2==0; acc+el\
    \ if el%2==1;acc}`. No need to use `inject` here.\n<|/ c |>\n<| c |>\nThis was\
    \ the best solution I could find. Thank you!\n<|/ c |>\n<| a |>\n<code>\neven.inject(0){\
    \ |sum, e| sum + e if e % 2 == 0; }\n</code>\n<|/ a dscore=2 tags=ruby |>\n<|\
    \ a |>\nHere's another way:\n<code>\neven.sum.times.reduce(0) do |sum, idx|\n\
    \  sum + (idx & 1)\nend\n</code>\n<|/ a tags=ruby dscore=2 |>\n<| a tags=ruby\
    \ |>\n<code>\neven.inject(0) do |sum, e| \n  sum + e*(e & 1)\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| a dscore=1 |>\nHere are a couple of ways of doing it:\n<code>\n\
    even.inject(0, :+)\n</code>\nor\n<code>\neven.inject(0) { |sum, el| sum + el if\
    \ el % 2 == 0; sum + el if el % 2 == 1 }\n</code>\n<|/ a tags=ruby |>\n<| a dscore=1\
    \ tags=ruby |>\n<code>\neven.map(&:to_i).inject(:+)\n</code>\n<|/ a |>\n<| c |>\n\
    This is the most compact and readable solution, but it is less efficient than\
    \ the other solutions.\n<|/ c |>\n<| c |>\n- That is why I said \"efficient\"\
    \ in my answer.\n<|/ c |>\n<| c |>\nNo, it is not. Your solution is actually slower\
    \ for large arrays than mine, because it needs to convert strings to integers\
    \ first. That is costly in both time and memory. Think of what happens when a\
    \ number like \"123\" is encountered: it needs to be converted, then \"123\" gets\
    \ converted to an integer, and then ", "  lst.each_with_index.map {|number, index|\
    \ index % 2 != 0 ? number : nil}.compact.inject {|sum, num| sum + num}.to_i\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,algorithm |>\n<code>", "  lst.sort\n\
    \  sum = 0\n  for i in (0..lst.count/2)-1 do\n    sum += 2*lst[i] + 3*lst[i+1]\n\
    \  end\n  sum -= lst[lst.count/2]\n  return sum\nend", "  even = []\n  odd = []\n\
    \  \n  lst.each do |n|\n    even.push(n) if n % 2 == 0\n    odd.push(n) if n %\
    \ 2 != 0\n  end\n  \n  odd.sum - even.sum\nend", "  return lst.inject{|sum, el|\
    \ sum + el % 2 == 0 ? sum : 0}\nend\n</cell>\n<code language=julia-1.5>\n@time\
    \ solution.([i for i in 1:1000000]);\n</cell>\n<text>\nNow you know more about\
    \ Julia's Arrays, you can do some more exercises!", "  odd_numbers = lst.select\
    \ { |x| x % 2 == 1 }\n  odd_numbers.reduce(:+)\nend", "  sum = 0\n  for i in 0..lst.size\
    \ - 1\n    if lst[i] == lst[i+1]\n      sum += lst[i]\n    end\n  end\n  return\
    \ sum\nend", "  return (lst.select{|x| x % 2 == 1}.sum)\nend", "  even = lst.select\
    \ {|x| x % 2 == 0}\n  odd = lst.select {|x| x % 2 == 1}\n  even.inject {|sum,\
    \ val| sum + val}\nend", "  return lst.inject(0) {|sum, num| sum + num if num\
    \ % 2 == 1}\nend", "  lst.each_with_index.\n    select {|v| v & 1 == 1}.\n   \
    \ sum\nend", "  even.zip(odd).inject(0) { |t,(a,b)| t + a if b == true }\nend\n\
    </code>\n<|/ a tags=ruby,arrays dscore=1 |>\n<| c |>\nWhile I appreciate that\
    \ solution works, please try to avoid code only answers as this doesn't help the\
    \ original asker understand how it works. Thanks!\n<|/ c |>\n<| c |>\nThis is\
    \ actually not necessarily a code only answer. I added some explanation just in\
    \ case he does not know how inject works.\n<|/ c |>\n<| c |>\nThanks so much!\n\
    <|/ c |>\n<| c |>\nI like how you reminded me that inject would work here. Very\
    \ elegant solution.\n<|/ c |>\n<| c |>\nThanks. I updated the answer with a bit\
    \ more details and example output.\n<|/ c |>\n<| a |>\nI wanted to provide an\
    \ answer to your question but you seem to have forgotten the question and just\
    \ want to get your question out there for others to see and benefit from.\nSo\
    \ here's the question you ask: Given an array, how can I find the sum of all the\
    \ odd numbers in that array?\n<code>\narr = [1,2,3,4,5,6,7,8,9]\n</code>\nIn Ruby,\
    \ you can do this:\n<code>\narr.inject(0) { |sum, num| sum + num % 2 }\n</code>\n\
    This code will give the result 15 because 1+2+3+4+5+6+7+8+9%2=15.\n<|/ a tags=ruby,arrays\
    \ dscore=0 |>\n<| a |>\nAs I understand your question, you have the array [10,\
    \ 20, 30, 40].\nYou have two sub-arrays, one containing numbers divisible by 2\
    \ and the other containing numbers divisible by 3.\nIf you know Ruby, you can\
    \ do this:\n<code>\narr = [10,20,30,40]\ndivisors = arr.each_slice(2).map(&:first).zip(arr.each_slice(2).map(&:last))",
  "  sum = 0\n  arr.each do |i|\n    if i.odd? && i.even?\n      sum += i\n    end\n\
    \  end\n  sum\nend", "  return lst.each_with_index.reduce(0) do |memo, (i, j)|\n\
    \    memo + j.odd? ? j : 0\n  end\nend\n</code>\n<|/ a tags=ruby,arrays,ruby-on-rails\
    \ |>\n<| c |>\nWhy are you using `each_with_index`?\n<|/ c |>\n<| c |>\nBecause\
    \ the OP specified that they wanted the sum of odd elements\n<|/ c |>\n<| c |>\n\
    You don't need `each_with_index` here. `arr.reduce(0) do |memo, (i, j)| memo +\
    \ (j.odd? ? j : 0) end`\n<|/ c |>\n<| a tags=ruby,arrays,ruby-on-rails |>\nYou\
    \ can do this with map and sum\n<code>\narr = [5, 8, 7, 1]\narr.map { |x| x.odd?\
    \ ? x : 0 }.sum\n</code>\n<|/ a dscore=3 |>\n<| a dscore=2 |>\nThis can be done\
    \ with Enumerable#sum and Array#select.\n<code>\n[5, 8, 7, 1].select(&:odd?).sum\n\
    </code>\n<|/ a tags=ruby,arrays,ruby-on-rails |>\n<| c |>\n`[5, 8, 7, 1].select(&:odd?).reduce(:+)`\
    \ :)\n<|/ c |>\n<| a dscore=1 tags=ruby,arrays,ruby-on-rails |>\n<code>\n[5, 8,\
    \ 7, 1].sum {|i| i.odd?}\n</code>\n<|/ a |>\n<| c |>\nThis solution has O(n^2)\
    \ complexity and is not ideal\n<|/ c |>\n<| a |>\nUse inject and each_with_object:\n\
    <code>\narr = [5, 8, 7, 1]\narr.each_with_object(0) do |number, memo|\n  memo\
    \ + number.odd?\nend\n</code>\neach_with_object is a handy tool for building memoizing\
    \ callbacks.\n<|/ a tags=ruby,arrays,ruby-on-rails dscore=1 |>\n<| c |>\nThis\
    \ solution has O(n^2) complexity and is not ideal\n<|/ c |>\n<| c |>\nCan you\
    \ explain why?\n<|/ c |>\n<| c |>\n`memo` is passed into the block. The block\
    \ will run `memo + number.odd?` for each number in the `arr` array. Each time\
    \ it is run, `memo` is equal to what it was last time, and `number.odd?` is calculated\
    \ for the number that was passed into the block. So this solution has O", "  sum\
    \ = 0\n  (0...lst.size).each do |i|\n    sum += (lst[i+1..lst.size].select { |e|\
    \ e % 2 == 1 }).sum\n  end\n  sum\nend", "  return (lst.select { |e| e % 2 !=\
    \ 0 }).reduce(:+)\nend", "  return lst.count(lst[1]) - lst.count(lst[2])\nend",
  '    evenSum = 0', "  sum = 0\n  for i in (0..(lst.length-1))\n    sum += lst[i]*((i==(lst.length-1))\
    \ ? 1 : 0)\n  sum\nend", "  even = (0..(lst.size-2)).select { |i| lst[i] % 2 ==\
    \ 0 }\n  odd = (0..(lst.size-1)).select { |i| lst[i] % 2 != 0 }\n  even.inject(0)\
    \ { |sum, i| sum + lst[i..].sum }\nend", "  odd = lst.select{|e| e.odd? }\n  even\
    \ = lst.select{|e| e.even? }\n  odd.inject(:+) + even.inject(:+)\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThe performance of that solution depends on the size of the\
    \ array.  `lst.select{|e| e.odd? }` will perform very poorly on large arrays.\
    \  For a large array, you'd be better off using `lst.find_all {|e| e.odd?}` to\
    \ perform an in-place filtering.\n<|/ c |>\n<| a tags=ruby |>\n<code>\nsum = 0\n\
    array.each_with_index do |x, i|\n  if i % 2 != 0\n    sum += x\n  end\nend\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nIt should be `if i%2 != 0`\n<|/ c |>\n<| a dscore=4\
    \ tags=ruby |>\nThis is how I'd do it: \n<code>", "  return lst.inject(:+).find_all\
    \ { |x| x % 2 == 1 }.inject(:+)\nend", "  lst.each_with_index do |e, i|\n    (i\
    \ % 2).zero? ? e += lst.size : e += 0\n  end\nend\n</code>\n<|/ a |>\n<| a tags=ruby,arrays\
    \ |>\nOne way to do it without using any loop\n<code>\na = [1, 2, 3, 4, 5, 6]\n\
    a.zip(a).to_enum.with_index.find { |_, i| i % 2 == 1 }[1]", "  # sort array in\
    \ place\n  lst.sort!\n  sum = 0\n  for i in 0...lst.size\n    if i % 2 == 0\n\
    \      sum += lst[i]\n    end\n  end\n  sum\nend", "  sum = 0\n  i = 0\n  while\
    \ i < lst.size do\n    if lst[i] % 2 != 0\n      sum += lst[i]\n      i += 1\n\
    \    else\n      i += 1\n  end\n  sum\nend", "    even = lst.select{ |x| (x %\
    \ 2) == 0  }\n    odd = lst.select{ |x| (x % 2) == 1  }\n    even.sum + odd.sum\n\
    end", "  sum = 0\n  suml = 0\n  for i in 0 ... lst.count - 2\n    suml = (suml\
    \ + lst[i] * i)\n  end\n  sum = suml * 2\n  return sum if suml % 2 == 0\n  return\
    \ sum / 2\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=ruby,loops |>\n\
    Another way to do it: \n<code>", "  lst.each_with_index do |num,i|\n    next if\
    \ i.odd? && num.even?\n    num+num[i.even? ? i.to_i-1 : 1]\n  end\nend\n</code>\n\
    <|/ a tags=arrays,ruby,algorithm dscore=0 |>\n<| c |>\nThis answer doesn't work\
    \ for an array like `[7, 4, 9, 2, 3, 5, 8]`.\n<|/ c |>\n<| c |>\n: You're right.\
    \  I missed that.  I updated my answer.\n<|/ c |>\n<| c |>\nYou are not allowed\
    \ to use anything but built in methods. `each_with_index` and `map`.\n<|/ c |>\n\
    <| c |>\n: I revised my answer.  It's pretty ugly, but works.\n<|/ c |>\n<| a\
    \ dscore=0 |>\nHere's a solution that uses Enumerable#chunk with a bit of recursion:\n\
    <code>", "    odd_even = 0\n    odd_odd = lst[0]\n    odd_index = lst.index odd_odd\n\
    \    odd_index = nil if odd_index == nil\n    even_index = lst.index even\n  \
    \  even_index = nil if even_index == nil\n    while even_index != nil\n      odd_even\
    \ += odd_odd\n      odd_odd += lst[even_index]\n      even_index -= 1\n      odd_index\
    \ += 1\n      odd_index += 1\n    end\n    odd_even += odd_odd\n    odd_odd +=\
    \ lst[-1]\n    return odd_even\nend", "  return lst.reduce(:+)\nend", "  even.each\
    \ { |i| arr << i }\n  sum(arr)\nend", "  sum = 0\n  for i in 0...lst.size\n  \
    \  if lst[i] % 2 == 1\n      sum += lst[i]\n    end\n  end\n  sum\nend", "  #\
    \ TODO: Write your Ruby code here.\n  sum = 0\n  lst.each_with_index do |i, index|\n\
    \    if index%2==0\n      sum+=i\n    end\n  end\n  sum\nend", "  odd, even =\
    \ 0, 0\n  lst.each_with_index do |x, i|\n    if i % 2\n      even += x\n    else\n\
    \      odd += x\n    end\n  end\n  return odd - (even * 2)\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nThat looks like a great solution! But I am a bit confused on\
    \ how you got from O(n) to O(n\xB2). Would you mind explaining what it is doing?\n\
    <|/ c |>\n<| c |>\nThe code above is O(n) because the code is not iterating over\
    \ each element in the array, which is what `each_with_index` does. The `each_with_index`\
    \ method works by iterating over the array, and then passing the index of the\
    \ element as the first argument to the block, and the element itself as the second\
    \ argument. In this case, `i` is the index of the current element in the loop,\
    \ and `x` is the value of the current element in the loop.\n<|/ c |>\n<| a |>\n\
    <code>", "  evens = lst.select { |x| x % 2 == 0 }\n  evens.reduce(0) { |acc, x|\
    \ acc + x }\nend", "  # Write your code here.\n  evens = even = []\n  odd = odd\
    \ = 0\n  for x in lst\n    if x % 2 == 0 then\n      evens << x\n      else\n\
    \      odd << x\n    end\n  end\n  evens.reduce(:+)\nend\n</code>\nAnd this works\
    \ fine\n<code>\nsolution([3, 5, 8, 7, 1])", "  lst.inject(0) do |sum, element|\n\
    \    if element.even?\n      sum + element\n    end\n  end\nend\n</code>\n<|/\
    \ a dscore=0 |>\n<| a dscore=0 tags=ruby,arrays,algorithm |>\nHere is my solution:\n\
    <code>", "  even = (0..lst.count).select { |i| lst[i] % 2 == 0 }.join\n  even.to_i\n\
    end", "  sum = 0\n  for i in (0...(lst.length-1)).step(2) do\n    if lst[i] %\
    \ 2 != 0\n      sum += lst[i]\n    end\n  end\n  return sum\nend", "  lst.each_with_index.inject(0)\
    \ {|sum, (value, idx)| sum + value if idx % 2 == 1}\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nthanks man! I just wanna ask if it's possible to use the `inject`\
    \ method to solve this problem? I always thought it could be used only with loops\
    \ or recursion.\n<|/ c |>\n<| c |>\n, no. You cannot use inject to solve this\
    \ problem. There are no loops, only recursion.\n<|/ c |>\n<| c |>\nI see, thanks\
    \ again. I think I should study more on recursion.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ dscore=2 |>\nThe first argument to inject is the value to return when all elements\
    \ are done. So:\n<code>", "  lst.each_with_index {|val, i| return val if i%2 !=\
    \ 0 }\nend", "  odd_sum = lst.sum\n  even_indexes = []\n  even_indexes.push 0\
    \ until lst.count is even\n  even_indexes.push lst.count - 1 until lst.count is\
    \ even\n  odd_sum -= lst[even_indexes[1]] + lst[even_indexes[lst.count - 1]]\n\
    \  even_indexes[1].push 0 until lst.count is even\n  even_indexes[lst.count -\
    \ 1].push lst.count - 1 until lst.count is even\n  even_indexes[0].push 1 until\
    \ lst.count is even\n  even_indexes[lst.count].push lst.count - 1 until lst.count\
    \ is even\n  return odd_sum\nend", "  if lst.empty?\n    0\n  else\n    sum =\
    \ lst.sum\n    even_index = lst.each_with_index.reject {|(_, index), _| index%2\
    \ == 1}\n    odd_index = lst.each_with_index.reject {|(_, index), _| index%2 !=\
    \ 1}\n    sum = even_index.inject(sum) {|sum, (element, _)| sum + element} + odd_index.inject(sum)\
    \ {|sum, (element, _)| sum + element}\n    sum\n  end\nend\n</code>\n<|/ a dscore=1\
    \ tags=ruby |>\n<| c |>\nThis answer is great because it is simple, yet effective.\n\
    <|/ c |>\n<| a tags=ruby dscore=1 |>\nHere is an interesting way using Enumerable#each_cons:\n\
    <code>", "  sum = 0\n  \n  for i in 0...lst.size\n    sum = (sum + lst[i] - lst[i..-1])\
    \ % 2\n  end", "  lst.each_with_index do |e, i|\n    if i % 2 != 0\n      e +\
    \ lst[i..-1].sum & e.to_i\n    end\n  end\nend\n</code>\n<|/ a |>\n<| a tags=ruby,algorithm,sum,arrays\
    \ dscore=0 |>\nI came up with a more efficient solution using each_cons and each_with_index\
    \ and an inject accumulator. Still not very Rubyish but at least it's concise.\n\
    <code>", "  lst.inject(0) do |sum, e| sum + (e.odd? ? 0 : e)\nend\n</code>\nAnd\
    \ for completeness, here's my other solution which has more or less the same complexity\
    \ but different style:\n<code>", "  lst.sort.each_with_index { |e, i| return e\
    \ if i % 2 == 1 }\n  0\nend", "  return sum( lst[0 .. 2].inject(:+) ) if lst.size\
    \ % 2 == 0 \n  \nend\n</cell>\n<cell>\nsolution(lst)\n</cell>\n<cell>", "  evens\
    \ = lst.select { |x| x.odd? }\n  evens.inject { |sum, el| sum + el.even } if evens.any?\n\
    end", "    return lst.each_cons(2).map { |v| v.reduce(:+) }.max\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nYes, I know. Just trying to show a more concise way\
    \ of writing it.\n<|/ c |>\n<| a dscore=0 |>\nWe can do\n<code>", "  sum = 0\n\
    \  even_index = lst.index { |v| v % 2 == 1 }\n  even_index.each { |v| sum += v}\n\
    \  sum\nend", "  lst.sort.select { |x| x % 2 == 1 }.reduce(:+) rescue 0\nend",
  "  sum = 0\n  arr.each do |el|\n    if el % 2 == 0\n      sum += el\n    end\n \
    \ end\n  sum\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis solution\
    \ is good but it's very inefficient because it creates a new array (by calling\
    \ `map` with a block). I'd be tempted to do something like this instead `lst.inject(0,\
    \ :+).to_i`. See my answer for an explanation of the differences.\n<|/ c |>\n\
    <| c |>\nThe `map` method is not \"inefficient\". The `reduce` method is not \"\
    inefficient\", but more idiomatic. Also, using `map` with an array (as opposed\
    \ to an enumerator) makes it more idiomatic, because you don't need to explicitly\
    \ call `to_i` on the result of the `map` method. `inject` is the idiomatic way\
    \ of doing it in this case.\n<|/ c |>\n<| c |>\nThis does not answer the question.\
    \ It is an improvement but not the answer to the question.\n<|/ c |>\n<| c |>\n\
    : It does answer the question. OP has a specification and stated what the algorithm\
    \ should do.\n<|/ c |>\n<| c |>\nThe OP stated that the algorithm should \"return\
    \ the sum of all of the odd elements that are in even positions\". The accepted\
    \ answer does not do that. It returns a value if the element at an even position\
    \ exists and zero if it does not. I think you should read the question again.\
    \ I would say that your answer does not do what the OP wants either. It only returns\
    \ the number of odd elements in the array. This is not the same thing as the sum\
    \ of the odd elements.\n<|/ c |>\n<| a dscore=5 |>\n<code>\n[2,4,5,7,9,4,3,5,4].delete_at(2).reduce(:+)\
    \ #=> 21\n[2,4,5,7,9,4,3,5,4].delete_at(1).reduce(:+) #=> 7\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nThis should be the accepted answer. Especially since it has the\
    \ advantage of being idiomatic: `lst.delete_at(2).reduce(:+)` instead of `lst.map\
    \ {|x| x-2 }.sum`.\n<|/ c |>\n<| c |>\nThanks for this - it really helped me as\
    \ i couldn't find a way to do the same thing without creating a new array. +1\
    \ for simplicity\n<|/ c |>\n<| c |>\nTo get \"sum of odd elements\" you can use\
    \ `lst.delete_at(1).reduce(:+)`.\n<|/ ", "  even, odd, total = [], 0, 0\n  arr.each\
    \ do |e|\n    odd += 0 if e.odd?\n    even += 1 if e.even?\n    total += e if\
    \ e.odd? && e.even?\n  end\n  return total if even > 0 || odd > 0\n  return 0\n\
    end", "  return lst.inject(0) { |sum, value| sum + 1 if value % 2 == 1 }\nend\n\
    </code>\n<|/ a dscore=3 tags=ruby |>\n<| a dscore=2 tags=ruby |>\n<code>", " \
    \ even = []\n  odd = []\n  for i in 0...lst.length\n    if lst[i] % 2 == 0 then\n\
    \      even << lst[i]\n    else\n      odd << lst[i]\n    end\n  end\n  even.inject\
    \ { |total, i| total + i }\nend\n</code>\n<|/ a tags=algorithm,ruby |>\n<| c |>\n\
    Why are you using `inject`? It doesn't seem like it's needed, `each` should be\
    \ fine.\n<|/ c |>\n<| c |>\nThat would work, but I didn't want to rewrite the\
    \ OP's code from scratch so I added an answer that uses the `inject` method.\n\
    <|/ c |>\n<| a dscore=2 |>\nHere's a solution using Ruby's enumerator and take_while\
    \ methods:\n<code>", "  sum = 0\n  i = 0\n  while i < lst.size\n    if i % 2\n\
    \      sum += lst[i]\n    end\n    i += 1\n  end\n  return sum\nend", "  sum =\
    \ 0\n  even = 0\n  odd = 1\n  arr.each do |num|\n    if num % 2 == 0\n      even\
    \ += num\n    else\n      sum += odd\n      odd += 1\n    end\n  end\n  sum -=\
    \ even\n  sum\nend\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| c |>\n`arr.inject{\
    \ |sum,e| sum+e%2==0 ? (sum+e) : sum }`\n<|/ c |>\n<| c |>\nThanks!\n<|/ c |>\n\
    <| c |>\nWhy not `arr.inject(:+)`?\n<|/ c |>\n<| a dscore=1 |>\nA solution that\
    \ uses a single loop:\n<code>", "  lst.each_with_index {|v, i| return v if i %\
    \ 2 == 1}\n  nil\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby dscore=0 |>\n\
    <code>", "  return lst.select { |x| x % 2 == 0 }.inject(0) { |acc, x| acc + x\
    \ }\nend", "  if lst.blank?\n    return 0\n  else\n    odd_sum = sum((lst - [lst[0],\
    \ lst[1], lst[2]]) % 2 == 0)\n    return odd_sum if odd_sum == 0 then 0 else odd_sum\
    \ - 2 end\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=0 |>\nHere's a\
    \ solution that uses two passes:\n<code>", "  sum = 0\n  lst.each do |num|\n \
    \   if num % 2 == 1\n      sum += num\n    end\n  end\n  return sum\nend", " \
    \   evens_sum = 0\n    evens_count = 0\n    odds_sum = 0\n    odds_count = 0",
  "  lst.each_with_index do |e, i|\n    if i % 2 == 0\n      e += lst[(i - 1) / 2]\n\
    \    end\n  end\n  lst.sum\nend\n</code>\n<|/ a tags=ruby,algorithm,ruby-on-rails\
    \ |>\n<| a tags=ruby,algorithm,ruby-on-rails |>\nA Ruby solution (similar to what\
    \ others have posted, but with some improvements):\n<code>", "  result = 0\n \
    \ index = 0\n  while index < lst.size\n    if index % 2 == 0\n      result +=\
    \ lst[index]\n      index += 1\n    else\n      index += 1\n    end\n  end\n \
    \ return result\nend\n</code>\n<|/ a dscore=1 tags=arrays,ruby |>\n<| a tags=arrays,ruby\
    \ |>\nHere's a slightly modified version of your code, with some inline comments\
    \ to illustrate what is happening. \n<code>", "  lst.each_with_index.reduce(0)\
    \ { |sum, i| sum + i[1] % 2 }\nend", "  sum = 0\n  lst.each.with_index(1) do |e,\
    \ i|\n    if (i % 2 == 0)\n      sum += e\n    end\n  end\n  return sum\nend\n\
    </code>\n<|/ a |>\n<| c |>\nThis is the perfect solution. I don't know why I didn't\
    \ think of this.\n<|/ c |>\n<| a dscore=1 |>\nIn Ruby 1.9+ you can do:\n<code>\n\
    arr = [1,2,3,4,5,6,7,8,9,10]\narr.values_at(0...arr.size/2).inject(:+)", "  lst.each_with_index.inject(0)\
    \ { |sum, (n, i)| sum + (n % 2 == 0 && lst[i+1]) ? n : 0}\nend", "  even = even\
    \ = 0\n  even2 = even2 = 0\n  even3 = even3 = 0\n  even4 = even4 = 0\n  even5\
    \ = even5 = 0\n  even6 = even6 = 0\n  even7 = even7 = 0\n  even8 = even8 = 0\n\
    \  even9 = even9 = 0", "  sum = 0\n  i = lst.index(lst[0]) / 2\n  while i < lst.count\n\
    \    sum += lst[i]\n    i += 1\n  end\n  sum\nend\n</code>\nThis algorithm is\
    \ O(n) time and O(n) space. The algorithm above is not the best, because it's\
    \ O(n^2). If you're interested in learning how to make this better than O(n),\
    \ I suggest you go through my solution to this problem.\n<|/ a |>\n<| a tags=arrays,ruby\
    \ dscore=0 |>\nIn Ruby, the idiomatic way to do this is with Enumerable#sum:\n\
    <code>\n> a = [5,8,7,1]\n> a.sum {|x| x%2 == 1}\n12\n> a = [3,3,3,3]\n> a.sum\
    \ {|x| x%2 == 1}\n9\n> a = [30,13,24,321]\n> a.sum {|x| x%2 == 1}\n0\n</code>\n\
    <|/ a |>\n<| c |>\nI think he meant \"array\" not \"arrays\" :)\n<|/ c |>\n<|\
    \ c |>\nThe term `array` has a specific meaning in Ruby. The term `arrays` has\
    \ a specific meaning in English. The term `list` has a specific meaning in English.\
    \ The term `arrays` has a specific meaning in mathematics. In programming we always\
    \ use the term `array`.\n<|/ c |>\n<| c |>\nI see, thanks for the explanation.\
    \ I was wondering why the OP accepted my answer, but I guess I misunderstood :)\n\
    <|/ c |>\n<| c |>\nthank you for the help guys :)\n<|/ c |>\n<| a dscore=0 tags=arrays,ruby\
    \ |>\nO(n) solution without using any built-in function.\n<code>\narray = [1,2,3,4,5,6,7]",
  "  sum = 0\n  for i in 0...lst.size\n    sum += (lst[i..lst].find{|i| i % 2 == 1}.reduce(:+))\n\
    \  end\n  sum\nend", "  lst.inject(0) { |sum, i| sum + 2 * lst[i] if i % 2 !=\
    \ 0 }\nend\n</cell>\n<code language=julia-0.5>\narr = [1, 2, 3, 3, 3]\n</cell>\n\
    <code language=julia-0.5>\nlst_sum = sum( lst[ i] for i \u2208 eachindex(arr)\
    \ ) if arr.size != 0 else 0\n</cell>\n<code language=julia-0.5>\n@assert lst_sum\
    \ == 12\n</cell>\n<code language=julia-0.5>\narr = [ 30, 13, 24, 321]\n</cell>\n\
    <code language=julia-0.5>\n@assert lst_sum == 0\n</cell>\n<text>\nExercise 2\n\
    Write a function that returns an array of all elements up to and including the\
    \ Nth element (without duplicates). For example,\nif N is 4, the function should\
    \ return [1, 2, 3, 4]. If N is greater than the length of the array, then the\
    \ function should return an empty array.", "  lst.each_with_index {|e, i| return\
    \ i if i % 2 == 1 && e % 2 != 0}\n  lst.sum\nend", "  lst.each_with_index do |n,\
    \ i|\n    return n if i % 2 != 0\n  end\nend", "  lst.inject(0) { |acc, x| acc\
    \ + x if (x % 2).zero? }\nend", "  # Your code here\n  count = 0\n  odd = 0\n\
    \  even = 0\n  for i in lst\n    if i % 2 == 1\n      count += 1\n      even +=\
    \ i\n    elsif i % 2 != 0\n      odd += i\n  return even + odd", "  lst.inject\
    \ { |sum, e| (sum + e) % 2 == 0 ? e : sum }\nend", "  odd = lst.select { |i| (i.odd?)\
    \ }.sum\n  even = lst.select { |i| (i.even?) }.sum - odd\n  odd + (even * 2)\n\
    end", "  sum = 0\n  arr.each do |x|\n    if x.odd?\n      sum += x.even?\n   \
    \ end\n  end\n  return sum\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nIt would\
    \ be more natural to name the variable `sum` rather than `sum1`.\n<|/ c |>\n<|\
    \ c |>\n- I think `sum1` is more appropriate than `sum`, but that's your choice.\n\
    <|/ c |>\n<| c |>\nI agree with your assessment. I just wanted to point out that\
    \ it's a very common convention in Ruby to name the variable that you are creating\
    \ (here `sum`) as the name of the method that is going to perform the calculation\
    \ (here `sum1`). You then also need to know that `sum` does not create a new object.\n\
    <|/ c |>\n<| a tags=ruby |>\n<code>\nl=[1,2,3,4,5,6]\nl.each_with_index { |n,i|\
    \ l.delete_at(i) if n%2 }\nl.inject(:+)\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2\
    \ |>\n<code>\nl = [1, 2, 3, 4, 5, 6]\nl.map {|i| i if i.odd? }.inject(:+)\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nThis is not very efficient, because you traverse\
    \ the list twice. You should use `each_with_object` instead of `map`.\n<|/ c |>\n\
    <| a dscore=2 tags=ruby |>\n<code>\n[1,2,3,4,5,6].inject(0) { |sum, el| el if\
    \ el % 2 == 0 and (sum ||= 0) }\n</code>\n<|/ a |>\n<| a dscore=2 |>\n<code>\n\
    [1,2,3,4,5,6].each_with_index.inject(:+) do |sum, (element, index)|\n  sum + element\
    \ if index%2 == 1\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby |>\n<code>",
  "    even = lst.find {|x| x % 2 == 0} #returns index of the first even number in\
    \ lst\n    odd = lst.find {|x| x % 2 != 0} #returns index of the first odd number\
    \ in lst\n    sum = odd ? (lst[even] - lst[odd] + lst[even+1]) : 0\n    return\
    \ sum\nend", "  sum = 0\n  arr.each_with_index do |e, i|\n    sum +=  if i % 2\
    \ == 0 then e else 0\n  end\n  sum\nend\n</code>\n<|/ a |>\n<| c |>\nNice solution\
    \ but this answer was flagged as low quality. Would you mind adding some comments\
    \ to explain how you arrived at these solutions? It would help to understand why\
    \ you came to the conclusions you did.\n<|/ c |>\n<| c |>\nI added some comments\
    \ to the code. I think I explained the algorithm well enough. Hopefully it will\
    \ help people in the future.\n<|/ c |>\n<| a tags=ruby,arrays |>\nUsing Enumerable#sum\
    \ with a block you can sum the array by passing the value to an instance method\
    \ defined on the class of self:\n<code>", "  # Write your code here.\n  sum =\
    \ 0\n  for i in 0...(lst.length-1)\n    if lst[i] % 2 == 1 and lst[i + 1] % 2\
    \ == 0\n      sum = sum + lst[i]\n  end\n  return sum\nend", "  return lst.inject(:+)\n\
    end", "  lst.each_with_index do |x, i|\n    next if i%2 != 0\n    x.to_s.to_i\n\
    \  end\nend\n</code>\n<|/ a |>\n<| c |>\nThis code is not optimized at all. it\
    \ iterates each element two times. Using `each_with_index` will increase the time\
    \ complexity to `O(n^2)`\n<|/ c |>\n<| c |>\nI thought it wasn't optimized because\
    \ I had to read it... but then I tested it and it's `O(n)`.  Yes, I read it and\
    \ it looked like it was `O(n^2)`, but in fact, `each_with_index` uses `each_with_index`.\
    \  It doesn't use an `each_with_index`, but rather a normal `each_with_index`,\
    \ so it isn't `O(n^2)`.\n<|/ c |>\n<| c |>\nThe OP specifically mentioned in the\
    \ question that they are trying to improve their solution so that it runs in `O(n)`.\n\
    <|/ c |>\n<| a |>\nHere's a solution that uses only a single loop:\n<code>", " \
    \ sum = 0\n  even = lst.select{ |e| e % 2 == 0 }\n  odd = lst.select{ |e| e %\
    \ 2 != 0 }\n  even.zip(odd).each{ |pair| sum += pair[0] }\n  return sum\nend",
  "  return lst.inject(0) do |sum, el|\n    sum + 1 if el % 2 != 0\n  end\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\n`inject(0)` is the most obvious way to perform this\
    \ in Ruby. I'd also note that `sum + el` isn't really \"rubyish\" as it's an anti-idiomatic\
    \ Ruby idiom. In Ruby `map`, `inject` and `filter` are idiomatic ways of applying\
    \ a transformation to every element of an enumerable collection.\n<|/ c |>\n<|\
    \ c |>\nThe idiomatic `inject` method is `reduce` which accepts a default value:\
    \ `arr.reduce(0) { |sum, el| sum + el if el % 2 != 0 }`.\n<|/ c |>\n<| c |>\n\
    Or you can just use `[5,8,7,1].reduce(0) { |sum, el| sum + el if el % 2 != 0 }`\n\
    <|/ c |>\n<| c |>\n`inject` can be applied to a single array by giving a default\
    \ value. `arr.reduce(0) { |sum, el| sum + el if el % 2 != 0 }` returns the sum\
    \ of all odd elements in the array if `arr` is `[5,8,7,1]`. See [Enumerable#inject](http://ruby-doc.org/core-2.2.2/Enumerable.html#method-i-inject)\n\
    <|/ c |>\n<| a tags=ruby |>\nHere is a solution that uses Hash to track what has\
    \ already accumulated and what has not:\n<code>", "  return 0 if lst.empty? then\
    \ 0 else lst.first.to_i + lst.last.to_i\nend\n</cell>\n<cell>\nTest.assertEquals(solution([1,\
    \ 2, 3, 4, 5]), 12, \"First\");\nTest.assertEquals(solution([5, 5, 5, 5, 5]),\
    \ 0, \"First\");\nTest.assertEquals(solution([30, 13, 24, 321]), 0, \"First\"\
    );\n</cell>\n<text>\nPart 4 (1 point)\nWe have used a lot of elementary operations,\
    \ so we might as well go ahead and take advantage of them.", "  lst.sort.each_with_index\
    \ do |e, i|\n    if i % 2 == 0\n      lst.select { |j| j == e }.sum\n    end\n\
    \  end\nend", "  return lst.inject(:+).select {|x| x % 2 == 1}.sum\nend\n</code>\n\
    <|/ a dscore=1 tags=ruby,arrays |>\n<| c |>\nThis is more complicated than it\
    \ needs to be. `lst.each_cons(2).map {|a,b| a+b}.inject(:+)` will do the same\
    \ thing in one line.\n<|/ c |>\n<| c |>\nAhh, good point. `lst.each_cons(2).map\
    \ {|a,b| a+b}.inject(:+).select {|x| x % 2 == 1}` will do it...but now I'm reminded\
    \ of a `each_with_object` method I'll need to look up. Never had that one in my\
    \ toolbox before.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  return lst.sum\
    \ { |x| x%2 == 1 }\nend", "  sum = 0\n  lst.each do |i|\n    if (i % 2 == 0)\n\
    \      sum += i\n    end\n  end\n  return sum\nend", "  lst.each_with_index.inject(0)\
    \ { |sum, (n, i) | sum + n * (i%2 == 1 ? 1 : -1) }\nend", "  return lst.sum( &:odd\
    \ ).reduce(:+)\nend", "  return 0 if lst.empty? or lst.size == 1 || (lst.size\
    \ > 1 and (lst[1] % 2 != 0)) else (lst[0] + lst[lst.size - 1]).even?(lst)\nend",
  "  return (lst.find { |x| (x % 2).zero? } * 2).to_i\nend\n</code>\n<|/ a |>\n<|\
    \ c |>\nYou might want to use `to_i`, otherwise you will get an error.\n<|/ c\
    \ |>\n<| a dscore=5 tags=ruby,algorithm |>\nIn Ruby, you can use inject:\n<code>\n\
    array = [1,2,3,4]\nsum = 0\narray.inject(sum) do |sum, n|\n  sum += n % 2 == 0\
    \ ? n : 0\nend\n</code>\n<|/ a |>\n<| c |>\nWhy not just `array.inject(0) { |sum,\
    \ n| sum + n % 2 == 0 ? n : 0 }`?\n<|/ c |>\n<| c |>\nBecause it can have surprising\
    \ behaviour if your element is a string\n<|/ c |>\n<| c |>\n, that can happen\
    \ if `array = [1,2]` and `sum = '3'`\n<|/ c |>\n<| c |>\n, indeed, that happens.\n\
    <|/ c |>\n<| c |>\n, yes, that happened (as I wrote). I just wanted to point out\
    \ that using inject is more idiomatic than using +.\n<|/ c |>\n<| a dscore=4 |>\n\
    Another way to do it is to use the Enumerable#inject method.\n<code>\narr = [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10]\narr.inject(0) { |s, e| s + e if e % 2 == 0 }\n\
    </code>\n<|/ a tags=ruby,algorithm |>\n<| c |>\nIf you don't want the leading\
    \ 0 you could do `arr.inject(0) { |s, e| s + e % 2 }`.\n<|/ c |>\n<| a dscore=4\
    \ |>\nThe shortest one that I found is:\n<code>\nsum = (0..arr.length).reduce(0)\
    \ { |t,i| t+=arr[i] }\n</code>\n<|/ a tags=ruby,algorithm |>\n<| c |>\nYou mean\
    \ `(arr.length-1..0)`\n<|/ c |>\n<| c |>\nThis one is shorter. Sadly, the other\
    \ answers use `.inject` which is not as concise. It also doesn't work with strings.\
    \ `[\"a\", \"b\", \"c\"].inject(0) { |t,i| t+=i }` returns `\"abc\"` instead of\
    \ `\"123\"`\n<|/ c |>\n<| a dscore=4 |>\nI took the code from https://stackoverflow.com/a/3929743/7339717\
    \ and made it work with strings and arrays:\n<code>", "  return lst.select { |i|\
    \ i%2 != 0 }.inject(:+)\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=0 |>\n\
    <code>", "  return lst.sum{|n| n&1 }\nend", "  return lst.count(lst[0]) * lst.count(lst[-1])\
    \ * lst.count(lst[-1] + lst[-2])\nend", "  lst.each do |x|\n    if (x % 2 == 0)\n\
    \      x = x * 3\n    end\n    sum = x\n  end\n  return sum\nend", "  return lst.select{\
    \ |x| x % 2 == 1 }.sum\nend\n</code>\n<|/ a |>\n<| a dscore=2 |>\nThis problem\
    \ can be solved in O(log n) time.\n<code>", "  return lst.sum { |e| e % 2 != 0\
    \ ? e : 0\nend", "  even = []\n  odd = []", "  if lst.empty?\n    0\n  else\n\
    \    even = lst.select { |e| e&1 == 0 }\n    odd = lst.select { |e| e&1 == 1 }\n\
    \    sum(even) + sum(odd)\n  end\nend\n</code>\n<|/ a dscore=4 tags=ruby |>\n\
    <| c |>\nThanks for the answer. I think you missed out on one point. I am not\
    \ interested in any gems or libraries. I am looking for a solution to the problem.\
    \ I think there can be some better approach than iterating over whole array twice.\n\
    <|/ c |>\n<| c |>\nThis approach is O(N^2). O(N) is impossible.\n<|/ c |>\n<|\
    \ c |>\nThe best solution IMO would be to first find the odd positions and then\
    \ find the even positions. That would give you O(N).\n<|/ c |>\n<| a tags=ruby\
    \ |>\nI think this can be solved in O(n), if you use a hash to store the odd indices\
    \ and increment the odd counter, after that you can calculate the sum of each\
    \ odd position. \n<code>", "    even = lst.map { |x| x % 2 }.compact\n    return\
    \ even.inject(:+) if even.any?\n  end\nend", "  sum = 0\n  arr.each_with_index\
    \ do |element, index|\n    if index % 2 == 1 \n      sum += element\n    end \n\
    \  end\n  sum\nend", "  return lst.inject(0) { |sum, element| sum + element %\
    \ 2 }\nend\n</code>\n<|/ a |>\n<| c |>\nUsing inject for what seems like a simple\
    \ problem seems unnecessary.\n<|/ c |>\n<| c |>\n: Why would it not be necessary?\
    \ He explicitly stated that he wants to return the sum of all of the odd elements\
    \ that are in even positions.\n<|/ c |>\n<| c |>\nIt does not return what he expects.\n\
    <|/ c |>\n<| c |>\n: It does return `9` as he requested.\n<|/ c |>\n<| c |>\n\
    : This code does return `9`, as requested in the original question. Your comment\
    \ on the question was in response to me saying that you were returning `7` instead\
    \ of `9`, which was incorrect. `sum` returns the sum of the elements currently\
    \ in the collection. Since he said he wanted the sum of all of the odd elements\
    \ that are in even positions, `sum` returns `9`.\n<|/ c |>\n<| a tags=ruby dscore=3\
    \ |>\nIn case you need to add only even positions, you can just use:\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
