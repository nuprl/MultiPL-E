name: HumanEval_104_unique_digits
language: rb
prompt: "# Given an array of positive integers x. return a sorted array of all \n\
  # elements that hasn't any even digit.\n# Note: Returned array should be sorted\
  \ in increasing order.\n# For example:\n# >>> unique_digits.call([15, 33, 1422,\
  \ 1])\n# [1, 15, 33]\n# >>> unique_digits.call([152, 323, 1422, 10])\n# []\ndef\
  \ unique_digits(x)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_unique_digits\n\
  \    candidate = method(:unique_digits)\n    assert_equal([1, 15, 33], candidate.call([15,\
  \ 33, 1422, 1]))\n    assert_equal([], candidate.call([152, 323, 1422, 10]))\n \
  \   assert_equal([111, 151], candidate.call([12345, 2033, 111, 151]))\n    assert_equal([31,\
  \ 135], candidate.call([135, 103, 31]))\n  end\nend\n"
completions: ["  x.each_with_index.inject([]) do |acc, x|\n    acc << x if x.to_s.chars.uniq.size\
    \ != x.to_s.size\n    acc\n  end\nend", "  result = x.sort.map { |e| e % 10 }\n\
    \  result = result.uniq.sort\nend", "  x.each_with_object([]).inject([]) do |output,\
    \ e|\n    output << e unless e.to_i.to_s % 2 == 0\n  end\nend", "  unique = {}\n\
    \  for x in x\n    unique[x.to_s.split(//).map(&:to_i).sort] = x\n  unique.values.sort\n\
    end", "  arr = x.dup\n  arr.sort!\n  arr.map!{|num| num.to_s.split(//).uniq}\n\
    \  arr\nend", "  result = []\n  x.each do |i|\n    i =~ /^(\\d)$/\n    result\
    \ << $1\n  end\n  result.sort\nend", "  x.uniq\nend", "  x.sort.with_index do\
    \ |e, i|\n    e % 2 == 0 && e**2 % 2 == 0 ? x << i : x\n  end\nend", "  x.sort!\n\
    \  result = []\n  for i in 0...x.size\n    if x[i] % 2 == 0\n      result << x[i]\n\
    \      x.delete(i)\n    end\n  end\n  result\nend", "  x.uniq!\n  y = []\n  x.each\
    \ do |i|\n    if i % 2 == 0\n      y << i\n    end\n  end\n  y.sort!\n  return\
    \ y\nend\n</pre>\n</div>\n</div>", "  x.each_with_index do |element, index|\n\
    \    next\n    if element == 0\n      next\n    elsif element % 2 == 0\n     \
    \ elements[index] = 0\n    end\n  end\nend", "  x.map { |n| n % 10}.sort.uniq.map\
    \ { |n| n }\nend", "  x.sort!\n  result = []\n  x.each do |item|\n    if item.to_i.even?\
    \ then\n      result << item\n    end\n  end\n  result\nend", "    x.sort!\n \
    \   x.delete_if {|y| y % 10 == 0} \n    x \nend\n</code>\n<|/ a |>\n<| a tags=algorithm,ruby,arrays,ruby-on-rails,sorting\
    \ dscore=1 |>\n<code>", "  x.sort.uniq { |item| item % 10 }\nend", "  x.sort.uniq\n\
    end", "  x.each_index do |i|\n    if x.at(i) % 2 != 0\n      x.delete_at(i)\n\
    \    end\n  end\n  x\nend", "  x.map!{|y| y % 10}.uniq\nend", "  unique_digits\
    \ = []\n  x.each do |i|\n    break if i%2 == 0\n    unique_digits << i\n  end\n\
    \  unique_digits.sort!\n  unique_digits\nend", "  \n  x.sort!\n  ret = []\n  \n\
    \  x.each do |i|\n    next if i.to_s.chars.all? { |c| c == '0' || c == '1' }\n\
    \    \n    if i > 0 && i / 10 % 2 == 0\n      ret << i if i / 10 % 2 != 0\n  \
    \  else\n      ret << i\n    end\n  end\n  \n  ret\nend\n</cell>\n<code language=julia-1.0>\n\
    @assert unique_digits([15, 33, 1422, 1]) == [1, 15, 33]\n@assert unique_digits([152,\
    \ 323, 1422, 10]) == []\n</cell>\n<code language=julia-1.0>", "  x.each do |i|\n\
    \    digit = i.to_s\n    if digit.length % 2 == 0\n      digit_set = Set.new([digit])\n\
    \      x.delete_if do |j|\n        digit_set.include?(j.to_s)\n      end\n   \
    \ end\n  end\n  x\nend", "    x.each_with_index.inject([]) do |result, number|\n\
    \        next if number.to_s !~ /^[013579]$/\n        if result[-1].to_s == \"\
    0\" \n            result.push(number)\n        else\n            result[-1] <<\
    \ number\n        end\n        result\n    end\nend\n</code>\nAs you can see,\
    \ this code is very similar to the first one, which I wrote just before you mentioned\
    \ your teacher. I've used each_with_index to get each number in pairs and then\
    \ I've used inject to append each number to the array if it's not the last.\n\
    If you want your second solution to be as efficient as first one you could use\
    \ each_cons method instead of each_with_index and to eliminate the last number\
    \ if it doesn't contain even digits you could use each method. It could look like\
    \ this:\n<code>", "  # Write your code here.\n  result=[]\n  x.each do |y|\n \
    \   begin\n      if y.to_s.split(/\\D/).uniq.include?(y.to_s.split(/\\D/).last.to_i)\n\
    \        result<< y\n      end\n    rescue\n    end\n  end\n  result\nend", " \
    \ return x.select { |i| i.modulo(10).zero? }\nend", "    x.sort!\n    result =\
    \ x.select{|i| i % 2 == 0}\n    result.empty? ? result : [result, x.find_index{|i|\
    \ i % 2 == 0}].sort\nend", "  x.sort!\n  \n  x.each_index do |i|\n    x.delete_at(i)\
    \ if x[i].to_i.to_s % 2 == 0\n  end\n  \n  x\nend", "  x.sort! # O(nlogn)\n  uniques\
    \ = []\n  unique_index = 0\n  x.each do |i|\n    while x[i] != 0 and x[i] % 10\
    \ == 0 and unique_index != i\n      uniques[unique_index] = x[i]\n      unique_index\
    \ += 1\n    end\n  end\n  uniques\nend", "  x.each do |i|\n    puts i.to_s if\
    \ i.to_s.index(\"0\").nil?\n  end\nend", "    x.sort!\n    even = []\n    odd\
    \ = []\n    n.times do |i|\n        if (i % 2 == 0)\n            even << x[i]\n\
    \        else\n            odd << x[i]\n        end\n    end\n    even.uniq.concat(odd)\n\
    end\n</cell>\n<code language=conda-root-py>\n%%html\n<div style=\"margin-left:\
    \ 35px; margin-bottom: 3px\">\n<p style=\"font-size: 20px\">Ruby solution</p>\n\
    </div>\n<p style=\"color:green\">\n    <b> Time Complexity </b>\n    - O(n)\n\
    </p>\n<p style=\"color:red\">\n    <b> Space Complexity </b>\n    - O(n)\n</p>\n\
    <p style=\"color:red\">\n    <b> Readability </b>\n    - O(n)\n</p>\n<p style=\"\
    color:green\">\n    <b> Precondition </b>\n    - x is an array.\n    - x is sorted.\n\
    </p>\n<p style=\"color:red\">\n    <b> Inplace </b>\n    - No\n</p>\n<p style=\"\
    color:green\">\n    <b> Example </b>\n    - unique_digits.call([15, 33, 1422,\
    \ 1])\n    - [1, 15, 33]\n</p>\n<p style=\"color:red\">\n    <b> Output </b>\n\
    \    - Array with unique digits.\n</p>\n</cell>\n<code language=conda-root-py>",
  "  x.uniq!.sort!\nend\n</code>\n<|/ a |>\n<| c |>\nThis would be a lot cleaner if\
    \ it were `x.uniq.sort` instead of the `x.uniq!.sort!`. It would be even better\
    \ if it could be done in one line.\n<|/ c |>\n<| c |>\nThis should be the best\
    \ answer. Using `uniq` instead of `uniq!` makes this method O(n).\n<|/ c |>\n\
    <| a tags=ruby,arrays |>\nI think you can use inject\n<code>", "  x.sort.reject{\
    \ |i| i.to_s.chars.uniq.empty? }\nend", "  x.sort!\n  result = []\n  x.each do\
    \ |e|\n    if e % 2 == 0\n      result << e\n    end\n  end\n  result\nend\n</cell>\n\
    <cell>", "  x.sort!\n  i = 0\n  while i < x.size - 1\n    puts x[i] if x[i] %\
    \ 2 == 0\n    i += 1\n  end\nend", "  x.uniq\nend", "  x.sort!\n  x.each do |e|\n\
    \    if e % 2 == 0\n      x.delete_at(0)\n      break\n    end\n  end\n  return\
    \ x\nend", "    \n    x.sort!\n    \n    even = []\n    odd = []\n    \n    x.each\
    \ do |i|\n        if i.to_s.length % 2 == 0\n            even << i\n        else\n\
    \            odd << i\n        end\n    end\n    \n    even.each do |e|\n    \
    \    odd -= e.to_s\n    end\n    \n    odd.sort\nend\n</cell>\n<cell>\nunique_digits([12,\
    \ 9, 2, 14, 3, 19])\n</cell>\n<cell>\nunique_digits([10, 11, 19, 13])\n</cell>\n\
    <cell>\nunique_digits([12])\n</cell>\n<text>\n4.6 Find Duplicates\nGiven an array\
    \ with repeated elements, find all occurrences of a given repeated element.",
  "    seen = {}\n    unique_result = []\n    for n in x\n        if seen[n]\n   \
    \         unique_result.append(n)\n            seen[n] = False\n        else\n\
    \            seen[n] = True\n            unique_result.append(n)\n    return unique_result\n\
    end", "  return x.group_by {|i| i % 10 }.values.sort.map {|i| i }\nend", "  x.sort!\n\
    \  result = []\n  x.each_with_index { |i, index| result << i if i.odd? && !result.include?(i)\
    \ }\n  result\nend", "  x.uniq!\n  x.sort!\n  x.group_by{|x| x.modulo(10)}\n \
    \ x\nend", "  x.uniq.sort!\n  x.select{|i| i.modulo(10).zero?}.sort!\nend\n</code>\n\
    <|/ a |>\n<| a tags=sorting,ruby,algorithm,arrays |>\nThe best way to do this\
    \ is using the each_cons method in Ruby. Consing to add two arrays together, rather\
    \ than adding them in one step using +. The difference between the two methods\
    \ is that using + will make Ruby run through the array twice. On the other hand,\
    \ using each_cons will just add each element to the new array without having to\
    \ go through the whole array again. This is most useful if you are working with\
    \ very large arrays and you only need the final result.\n<code>", "  x.sort!\n\
    \  result = []\n  i = nil\n  x.each do |i|\n    result << i\n    break if i.to_s.scan(/\\\
    d/).length == 0\n  end\n  return result\nend", "  x.sort!\n  x.uniq!\nend", " \
    \ x.sort! \n  result = []\n  x.each do |d| \n    if d % 2 == 0\n      result <<\
    \ d\n    end\n  end\n  result\nend", "  x.sort!\n  res = []\n  x.each do |n|\n\
    \    while n.to_s.rindex(\"0\") != nil\n      res += n.to_s.rindex(\"0\").to_i\n\
    \      n = n.to_s.delete(\"0\")\n    end\n    res += n.to_i\n  end\n  res\nend",
  "    x.sort!\n    result = []\n    current = nil\n    x.each do |x|\n        if\
    \ x.to_s.split(\"\").uniq.size >= 2\n            current = x.to_s.split(\"\").uniq.first\n\
    \            result << x\n        end\n    end\n    return result\nend", "   \
    \ \n    x.sort!\n    res = []\n    \n    x.each do |num|\n        if num.to_s.chars.map(&:to_i).uniq.count\
    \ == 1\n            res.push(num)\n        end\n    end\n    \n    res\nend",
  "  x.each do |i|\n    i.to_s.chars.uniq.each do |char|\n      unless x.include?\
    \ char\n        x.push char\n      end\n    end\n  end\n  x.sort\nend", "  x.sort!\n\
    \  x.select! { |i| i % 2 == 0 }\n  x\nend", "  x.each_index { |i| x[i] = x[i].to_s.length\
    \ }\n  x.delete_if { |x| x%10 == 0 }\n  x.sort\nend", "  result = []\n  x.each\
    \ do |x|\n    if x.modulo(10).zero?\n      result << x\n    end\n  end\n  result.sort\n\
    end", "    # Write your code here.\n    \n    # Your code here\n    n = len(x)\n\
    \    \n    # Sort the list.\n    x.sort()\n    \n    # Declare a result list\n\
    \    result = []\n    \n    # Iterate through the original array\n    for i in\
    \ xrange(0, n):\n        \n        # Increment index if odd digit\n        if\
    \ i%2 != 0:\n            i += 1\n            \n        # Check if the element\
    \ exists in the result list\n        if result[i] == None:\n            result.append(x[i])\n\
    \        \n    return result", "  x.sort\n  result = []\n  x.each_with_index do\
    \ |i, index|\n    i = i.to_i\n    result << i if i % 10 == 0\n  end\n  result.uniq\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nYour solution is not efficient, because\
    \ you sort the whole array just to get the unique digits. Also you just get one\
    \ single digit, so the code would have to be adapted to get the right result.\n\
    <|/ c |>\n<| c |>\nYou are right,. I'll try to fix the code. Thanks for the feedback.\n\
    <|/ c |>\n<| c |>\nI added a new solution which I think is more efficient, thanks\
    \ to the help of other answers and comments.\n<|/ c |>\n<| a tags=ruby,arrays,hashmap,algorithm,unique\
    \ |>\nThis should do the trick:\n<code>", "  return x.select {|i| i % 10 == 0}.sort_by\
    \ {|i| i}\nend\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| a tags=ruby |>\nYou can\
    \ do it with the following code:\n<code>\nnums.sort.uniq.inject([]){|acc, i| i\
    \ % 2 == 0 ? acc << i : acc}\n</code>\nIf you want your result to be sorted, you\
    \ can sort it before calling inject:\n<code>\nnums.sort.uniq.sort_by(&:odd).inject([]){|acc,\
    \ i| i % 2 == 0 ? acc << i : acc}\n</code>\n<|/ a dscore=0 |>\n<| a |>\nHere is\
    \ an answer that uses an intermediate array, but has O(n) complexity:\n<code>",
  "  x.sort!\n  result = x.select{|n| n % 2 == 0}\n  result.sort\nend", "  x.sort.uniq\n\
    end\n</code></pre>\n</div>\n</div>\n</div>\n<div class=\"cell border-box-sizing\
    \ text_cell rendered\"><div class=\"prompt input_prompt\">\n</div><div class=\"\
    inner_cell\">\n<div class=\"text_cell_render border-box-sizing rendered_html\"\
    >\n<h2 id=\"What-is-the-difference-between-%2a-and-%2a-in-ruby?\">What is the\
    \ difference between <code>-a</code> and <code>-a</code> in Ruby?<a class=\"anchor-link\"\
    \ href=\"#What-is-the-difference-between-%2a-and-%2a-in-ruby?\">&#182;</a></h2><p>Ruby's\
    \ <code>-&gt;</code> operator is a shortcut for <code>&amp;&amp;</code>.</p>",
  "  x.sort! \n  result = []\n  x.each do |i| \n    if i.to_s.chars.map{|c| c}.uniq.empty?\n\
    \      result << i\n    end\n  end\n  result.sort\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ dscore=1 |>\n<| a tags=ruby,arrays |>\nHere's one approach:\n<code>\nrequire\
    \ 'set'", "  x.sort!\n  result = []\n  x.each do |n|\n    if n % 2 == 0\n    \
    \  result << n\n    end\n  end\n  result\nend\n</code>\n<|/ a dscore=2 tags=sorting,ruby\
    \ |>\n<| c |>\nIf `x` is an array of `[3,34,2,3,4]` then `x.sort!` sorts the array\
    \ in place and returns `nil`.  (If `x` has only two elements, then it returns\
    \ `nil` because `x.sort` returns `nil` when its array has only one element.) \
    \ See http://ruby-doc.org/core-2.0.0/Array.html#method-i-sort-2\n<|/ c |>\n<|\
    \ c |>\nyes, your answer is right, but it doesn't return sorted array but `nil`\
    \ because `sort!` returns `nil`\n<|/ c |>\n<| a |>\nHere is a short solution in\
    \ Ruby:\n<code>", "  x.each do |item|\n    if item.to_s.split('').uniq.count !=\
    \ 0\n      next\n    else\n      result << item\n    end\n  end\n  result\nend",
  "  x.sort.each do |e| \n    return e if e % 2 == 0\n  end\n  nil\nend", "  x.each_index\
    \ do |i|\n    if i % 2 == 0 && x[i] > x[i+1]\n      x[i], x[i+1] = x[i+1], x[i]\n\
    \    end\n  end\n  x.sort!\n  x.uniq!\n  x\nend", "  unique_digitss = []\n  \n\
    \  x.each do |v|\n    if v.to_s.chars.map(&:to_i).uniq.length == 0\n      unique_digitss.push(v)\n\
    \    end\n  end\n  \n  unique_digitss.sort!\n  \n  return unique_digits\nend",
  "  \nend", "  # write your code here\n  result = []\n  x.each_index do |i|\n   \
    \ if x[i] % 2 == 0\n      result << x[i]\n    end\n  end\n  x.sort!\n  result\n\
    end", "  unique = []\n  x.each do |n|\n    next if n.to_s.reverse.gsub!(/0+/,\
    \ '').include?('0')\n    next if n.to_s.reverse.gsub!(/1/, '').include?('1')\n\
    \    next if n.to_s.reverse.gsub!(/2+/, '').include?('2')\n    next if n.to_s.reverse.gsub!(/3/,\
    \ '').include?('3')\n    next if n.to_s.reverse.gsub!(/4+/, '').include?('4')\n\
    \    next if n.to_s.reverse.gsub!(/5+/, '').include?('5')\n    next if n.to_s.reverse.gsub!(/6+/,\
    \ '').include?('6')\n    next if n.to_s.reverse.gsub!(/7+/, '').include?('7')\n\
    \    next if n.to_s.reverse.gsub!(/8+/, '').include?('8')\n    next if n.to_s.reverse.gsub!(/9+/,\
    \ '').include?('9')\n    next if n.to_s.reverse.gsub!(/0+$/, '').include?('0')\n\
    \    next if n.to_s.reverse.gsub!(/0+$/, '').include?('0')\n    next if n.to_s.reverse.gsub!(/1+$/,\
    \ '').include?('1')\n    next if n.to_s.reverse.gsub!(/2+$/, '').include?('2')\n\
    \    next if n.to_s.reverse.gsub!(/3+$/, '').include?('3')\n    next if n.to_s.reverse.gsub!(/4+$/,\
    \ '').include?('4')\n    next if n.to_s.reverse.gsub!(/5+$/, '').include?('5')\n\
    \    next if n.to_s.reverse.gsub!(/6+$/, '').include?('6')\n    next if n.to_s.reverse.gsub!(/7+$/,\
    \ '').include?('7')\n    next if n.to_s.reverse.gsub!(/8+$/, '').include?('8')\n\
    \    next if n.to_s.reverse.gsub!(/9+$/, '').include?('9')\n    next if n.to_s.reverse.gsub!(/0+$/,\
    \ '').include?('0')\n    next if n.to_s.reverse.gsub!(/0+$/, '').include?('0')\n\
    \    next if n.to_s.reverse.gsub!(/1+$/, '').include?('1')\n    next if n.to_s.reverse.gsub!(/2+$/",
  "  x.sort!\n  new_xs = []\n  x.each do |i|\n    new_xs += [x[i..-1]].select { |j|\
    \ j % 2 != 0 }\n  end\n  new_xs\nend\n</pre>", "  unique = []\n  x.each do |x|\n\
    \    if x.to_s.split(\"\").uniq.length == 0\n      unique.push x\n    end\n  end\n\
    \  return unique\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 tags=arrays,ruby,algorithm\
    \ |>\nHere's another approach:\n<code>", "  x.sort!\n  res = x.dup\n  res.select\
    \ {|i| i[0] % 2 != 0}.flatten!\n  res\nend\n</cell>\n<text>\nLet's try it out:",
  "  x.sort.each_with_index do |e, i|\n    next\n  end if x.empty?", "  x.sort!\n\
    \  x.each_with_index do |num, i|\n    return [] if num % 2 != 0\n  end\n  x\n\
    end", "\tret = []\n\tn = x.size\n\tfor i in 0 .. (n - 1)\n\t\tj = i\n\t\twhile\
    \ j > 0 and x[j] != x[j - 1]\n\t\t\tj >>= 1\n\t\tif j > 0\n\t\t\tret[i] = x[j]\n\
    \t\t\tj -= 1\n\t\tend\n\tend\n\tret\nend", "  x.sort.uniq\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nThe first function will fail if the array is `[2,3,2,1]`\n<|/ c\
    \ |>\n<| c |>\nWhat if i want to return array in same order as it is like `[2,3,2,1]`\n\
    <|/ c |>\n<| c |>\nThe second function can be written as `x.uniq.sort.freeze`\n\
    <|/ c |>\n<| a |>\nI like to use the 'each' method for such problems. \n<code>\n\
    x = [1, 2, 3, 10, 4, 1]\nx.each do |e|\n    puts e.to_s unless e.to_s.to_i.rem(2).zero?\n\
    end\n</code>\n<|/ a dscore=3 tags=ruby,arrays |>\n<| c |>\nWhat about `[10, 4,\
    \ 1, 3]`?\n<|/ c |>\n<| c |>\nI misread the question. I've corrected my answer.\
    \ I think the problem that has already been pointed out is that some elements\
    \ are being rejected due to the order in which they are being compared.\n<|/ c\
    \ |>\n<| a |>\nA simple solution could be:\n<code>\na.select { |i| i%2 == 0 }\n\
    </code>\n<|/ a dscore=3 tags=ruby,arrays |>\n<| c |>\nThis is actually the simplest\
    \ solution, since it relies on `Enumerable#select`'s block form of iteration to\
    \ do the filtering.\n<|/ c |>\n<| a |>\n<code>", "    return x.select { |i| (i\
    \ & 1) == 0 }\nend", "    x.sort!\n    uniques = []\n    unique_index = 0\n  \
    \  \n    while unique_index < x.length\n        if x[unique_index].to_s.chars.uniq.size\
    \ == 1\n            uniques << x[unique_index]\n            unique_index += 1\n\
    \        end\n    end", "  # write your code here\n  return x\nend\n</code>\n\
    <|/ a tags=ruby,arrays,algorithm,string |>\n<| a |>\n<code>\narr = ['10','20','30','40']",
  "  x.sort.map { |y| y % 10 }.uniq\nend", "  x.sort.uniq \nend\n</cell>\n<cell>\n\
    unique_digits([15, 33, 1422, 1])\n</cell>\n<cell>\nunique_digits([152, 323, 1422,\
    \ 10])\n</cell>\n<cell>", "  \n  result = []\n  \n  x.each do |e|\n    result\
    \ << e  if e.to_s.split(\"\").uniq.count == 1\n  end\n  \n  result\nend", "  result\
    \ = []\n  x.each do |x|\n    if (x.to_s.chars.map(&:to_i).uniq.size != x.to_s.chars.size)\
    \ || x.to_s.chars.map(&:to_i).uniq.size == 1\n      result << x\n    end\n  end\n\
    \  return result\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nThis problem\
    \ can also be solved via sorting and grouping. Here is the code\n<code>", "  x.sort\
    \ {|a, b| a <=> b}\n  i = 0\n  result = []\n  while i < x.length\n    j = i +\
    \ 1\n    while j < x.length\n      result = x[i..j] unless result[-1].include?(x[i])\n\
    \      j += 1\n    end\n    i += 1\n  end\n  result\nend\n</cell>\n<code language=julia-0.5>\n\
    unique_digits([152, 323, 1422, 10])\n</cell>\n<code language=julia-0.5>", "  return\
    \ x.select { |e| e % 10 == 0 }\nend", "  x.sort!\n  result = []\n  result+=(x[0..1])\
    \ if x[0]%2 == 0\n  result+=(x[1..2]) if x[1]%2 == 0\n  result+=(x[2..3]) if x[2]%2\
    \ == 0\n  result+=(x[3..4]) if x[3]%2 == 0\n  result+=(x[4..5]) if x[4]%2 == 0\n\
    \  result+=(x[5..6]) if x[5]%2 == 0\n  result+=(x[6..7]) if x[6]%2 == 0\n  result+=(x[7..8])\
    \ if x[7]%2 == 0\n  result+=(x[8..9]) if x[8]%2 == 0\n  result+=(x[9..10]) if\
    \ x[9]%2 == 0\n  result+=(x[1..10]) if x[10]%2 == 0\n  result+=(x[2..11]) if x[11]%2\
    \ == 0\n  result+=(x[3..12]) if x[12]%2 == 0\n  result+=(x[4..13]) if x[13]%2\
    \ == 0\n  result+=(x[5..14]) if x[14]%2 == 0\n  result+=(x[6..15]) if x[15]%2\
    \ == 0\n  result+=(x[7..16]) if x[16]%2 == 0\n  result+=(x[8..17]) if x[17]%2\
    \ == 0\n  result+=(x[9..18]) if x[18]%2 == 0\n  result+=(x[10..19]) if x[19]%2\
    \ == 0\n  result+=(x[11..20]) if x[20]%2 == 0\n  result+=(x[12..21]) if x[21]%2\
    \ == 0\n  result+=(x[13..22]) if x[22]%2 == 0\n  result+=(x[14..23]) if x[23]%2\
    \ == 0\n  result+=(x[15..24]) if x[24]%2 == 0\n  result+=(x[16..25]) if x[25]%2\
    \ == 0\n  result+=(x[17..26]) if x[26]%2 == 0\n  result+=(x[18..27]) if x[27]%2\
    \ == 0\n  result+=(x[19..28]) if x[28]%2 == 0\n  result+=(x[20..29]) if x[29]%2\
    \ == 0\n  result+=(x[21..30]) if x[30]%2 == 0\n  result+=(x[22..31]) if x[31]%2\
    \ == 0\n", "  x = x.sort_by { |x| x.to_i }\n  result = []\n  x.each do |y|\n \
    \   if y.to_i.to_s.reverse.chars.uniq.count != 0\n      result << y\n    end\n\
    \  end\n  result\nend", "  x.uniq!\n  x.uniq!(&:even?)\n  x.sort\nend", "    \n\
    \    # write your code here\n    return sorted(set(x)) ", "    x.sort!\n    arr\
    \ = []\n    arr.push(x[0])\n    x.shift\n    x.each_index do |i|\n        if arr\
    \ !~ /^0*/\n            if x[i].to_s !~ /^0*/\n                arr.push(x[i])\n\
    \            end\n        end\n    end\n    return arr\nend", "  x.sort!\n  x.each\
    \ do |n|\n    n -= n % 10 \n  end \n  x\nend", "  return x.group_by_to_a.select\
    \ { |e| \n    e.to_i.to_s == e.to_s.reverse && (e % 2 == 0)\n  }.sort_by { |e|\
    \ e }\nend", "  x.sort!\n  result = []\n  digits = x.map(&:to_i).uniq.map { |x|\
    \ x.to_s }\n  digits.each do |digit|\n    result << x.select { |a| a.to_i == digit\
    \ } << digit\n  end\n  result\nend", "  x.sort.each_with_index {|e,i| return x\
    \ if i % 2 != 0}\nend", "\tresult=[]\n\tx.each_with_index do |x,index|\n\t\tif\
    \ index % 2 == 0\n\t\t\tif x != x.to_s\n\t\t\t\tresult<< x\n\t\t\tend\n\t\tend\n\
    \tend\n\treturn result\nend", "  x.sort!\n  result = x.select { |n| n % 2 == 0\
    \ }\n  result.push \"0\"\n  result.sort\nend", "  x = x.sort\n  x.shift!(0)\n\
    \  x.each do |x|\n    if x.to_s.reverse.to_i.even? \n      puts x if x.to_s !=\
    \ \"\"\n    end\n  end\nend", "  x.sort! # sort in increasing order\n  x.uniq!\
    \ # remove duplicate digit\n  return x \nend\n</cell>\n<code language=julia-1.0>",
  "  x.sort.uniq.map { |d| d / 10 }.select { |d| d % 10 == 0 }.sort\nend", "  return\
    \ x.sort { |a,b| a == b ? a : (b <=> a) }.uniq\nend", "  x.sort!\n  result = []\n\
    \  \n  x.each do |item|\n    loop do\n      break unless item == (item/10)\n \
    \     result << item\n    end\n  end\n  \n  result\nend", "  x.uniq!\n  x.sort!\n\
    \  x.reject! { |x| x.to_s.length % 2 == 0 }\nend", "  x.sort.each do |e|\n   \
    \ return [] unless e % 2 != 0\n  end\n  return x\nend", "  x.sort!\n  unique =\
    \ []\n  x.each do |number|\n    next if number.to_s.split(\"\").uniq.size == 1\n\
    \    unique << number\n  end\n  unique\nend", "  x.sort.each do |n|\n    puts\
    \ \"Processing #{n}\"\n    if n =~ /[^0-9]/ and n % 2 != 0\n      puts \"#{n}\
    \ is even digit!\"\n      x.delete_at(x)\n    end\n  end\n  x\nend", "    x.sort!\n\
    \    ret = x.select{|x| (x % 10).zero?}\n    ret.sort!\n    ret\nend", "  x.sort\n\
    \  result = []\n  x.each do |i|\n    break if i.odd?\n    result << i\n  end\n\
    \  result\nend", "  \n  x.sort.uniq.map { |v| v }\nend", "    \n    x.sort!\n\
    \    \n    result = []\n    \n    x.each do |x| \n        if x.to_s.include? \"\
    0\"\n            return result\n        end\n        \n        result << x\n \
    \   end\n    \n    result\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI believe\
    \ that my algorithm doesn't work and I should implement a hash instead. Can you\
    \ please help me with that?\n<|/ c |>\n<| c |>\nI think you misunderstood me,\
    \ my algorithm is different from yours, I want the solution with out using hash\
    \ I do not have much time to spend on this.\n<|/ c |>\n<| a tags=ruby,arrays |>\n\
    Here's a solution that uses a hash and a block:\n<code>", "  x.sort_by!{ |num|\
    \ num % 10 }\n  i = 0\n  result = []\n  while i < x.length\n    if x[i] % 2 !=\
    \ 0\n      result << x[i]\n      i += 1\n    end\n  end\n  result\nend", "  arr\
    \ = x.dup\n  arr.delete(arr.find {|i| i.to_s.chars.reduce(:&).to_i %2 == 0} )\n\
    \  arr\nend", "  sorted = x.sort\n  return sorted.select do |number|\n    number.to_s.gsub(/^0+/,\"\
    \").chars.map(&:to_i).uniq.length == 0\n  end\nend\n</code>\nOutput:\n<code>\n\
    puts unique_digits(x)\n=> [1, 15, 33, 1422]\n</code>\n<|/ a tags=ruby,algorithm\
    \ dscore=3 |>\n<| c |>\nI got this error when running your code: `SystemStackError:\
    \ stack level too deep`\n<|/ c |>\n<| a tags=ruby,algorithm |>\nThe easiest way\
    \ is using #sort and #select:\n<code>\nx = [1, 4, 9, 3, 12, 2, 5]\nx.sort.select{\
    \ |num| num.to_s.split('').grep(/\\d/).empty? }", "  x.sort!\n  \n  result = []\n\
    \  \n  x.each do |x|\n    if x % 2 == 0\n      result << x\n    end\n  end\n \
    \ \n  result.uniq!\n  \n  result\nend", "  return x.select{ |e| e % 10 != 0 }\n\
    end", "\tx.sort!\n\tresult = []\n\tdigit = 1\n\twhile digit <= x.count\n\t  #\
    \ If digit doesn't have even digit, skip it.\n\t  if x[digit] % 2 != 0\n\t   \
    \ # Store digit into result list.\n\t    result << x[digit]\n\t    # Increment\
    \ digit by 1.\n\t    digit += 1\n\t  else\n\t    # Decrement digit by 1.\n\t \
    \   digit -= 1\n\t  end\n\tend\n\treturn result\nend", "  x.sort!\n  ret = []\n\
    \  x.each_with_index do |num, i|\n    break if i > 0\n    if num % 2 == 0\n  \
    \    ret << num\n    end\n  end\n  ret\nend\n</cell>\n<code language=julia-0.4>",
  "  x.sort!\n  unique_digits = x\n  unique_digits = unique_digits.select { |e| e\
    \ % 10 != 0 }\n  unique_digits.sort!\nend", "  \n  x.sort.uniq\nend", "  x.sort.reverse\n\
    \  result = []\n  x.each do |y|\n    if y % 2 != 0\n      result << y\n    end\n\
    \  end\n  result\nend", "  x.each do |x|\n    (1..x).each do |y|\n      if (x\
    \ % y == 0)\n        x.slice!(y..-1)\n      end\n    end\n  end\n  x\nend", " \
    \ x.sort\n  result = []\n  result.reject{ |x| x.modulo(10).zero? }\n  result\n\
    end", "  x.sort!\n  result = []\n  x.each_index do |index|\n    if x[index].modulo(10).zero?\n\
    \      result << x[index]\n      x.delete_at(index)\n    end\n  end\n  result\n\
    end", "    numbers_with_odd_digits = []\n    for element in x\n        if element\
    \ % 2 == 1\n            numbers_with_odd_digits << element\n    end\n    numbers_with_odd_digits.sort\n\
    end\n</code>\nThe first loop will gather all even elements. We know that every\
    \ element of the array is odd if the first digit is odd. So we only have to test\
    \ elements that are evenly divisible by 2.\nThe second loop will then sort this\
    \ array, and remove any even elements that now are odd. This is done because we\
    \ know that every even element will have an even digit in front of it, that we\
    \ need to keep. So if we remove an even element, the only thing that changes is\
    \ that one digit.\n<|/ a dscore=0 |>\n<| c |>\nThanks so much for the answer,\
    \ but the problem is that I can't use loops, only conditionals, assignments, and\
    \ basic functions like sort.  I was able to get it working with two for loops,\
    \ one that goes through every even number, and the other that goes through every\
    \ odd number, but I can't seem to put them together.\n<|/ c |>\n<| a dscore=0\
    \ tags=ruby |>\n<code>\narr = [15,33,1422,1]\narr.group_by{|x| x % 2 != 0}.map{|k,v|\
    \ v.sort}.flatten.compact\n</code>\n<|/ a |>\n<| c |>\nThanks so much for the\
    \ answer, but the problem is that I can't use loops, only conditionals, assignments,\
    \ and basic functions like sort.  I was able to get it working with two for loops,\
    \ one that goes through every even number, and the other that goes through every\
    \ odd number, but I can't seem to put them together.\n<|/ c |>\n<| a tags=ruby\
    \ |>\n<code>", "  return x.group_by {|x| x.to_s.split(//).uniq.size}\nend", " \
    \ \n  # Write your code in Ruby here\n  \nend\n</cell>\n<text>\nNow let's run\
    \ it with the test cases. Note that these test cases should return sorted arrays.\
    \ For example:", "  return x.sort { |a, b| b % 100 > a % 100 }\nend", "  return\
    \ x.select { |e| e % 10 == 0 }.sort \nend", "    x.each do |x|\n        if x %\
    \ 10 == 0\n            x.to_i \n        else\n            x.to_i\n        end\n\
    \    end\nend", "\tarr=x.clone\n\tarr.sort!\n\tarr=[]\n\tx.each_index do |i|\n\
    \t\tif arr !~ x[i] \n\t\t\tarr << x[i]\n\t\tend\n\tend\n\treturn arr\nend", " \
    \ x.sort_by!(&:to_i) # sort\n  result = []\n  x.each_index do |i|\n    break if\
    \ x[i].to_i % 2 != 0\n    result << x[i]\n  end\n  result\nend\n</code>\nIn Ruby\
    \ you can implement this in a few lines without using a helper method:\n<code>",
  "    x.sort!\n    x.reverse!\n    x.map { |i| i if i.to_s.scan(/\\d/).length ==\
    \ 0 }\nend\n</code>\n<|/ a |>\n<| c |>\nYou shouldn't use `x.sort!`. It could\
    \ have unintended side effects.\n<|/ c |>\n<| c |>\nWhy? The array is already\
    \ sorted, right? I added `x.sort!` to make it clearer that that was an assumption,\
    \ but you seem to be right - it works just fine.\n<|/ c |>\n<| c |>\nIt's not\
    \ as obvious. It's an implementation detail of Ruby that shouldn't be relied on\
    \ to maintain behavior across versions. In fact, I've had issues with this in\
    \ the past that would render my code unusable on different Ruby implementations.\n\
    <|/ c |>\n<| c |>\nI understand that it's an implementation detail, but I don't\
    \ understand why you think that it's \"unusable\" across different Ruby implementations\
    \ - it's perfectly usable on Ruby 1.9.2 and 1.93, or Ruby 1.8.7 and 1.8.6 or Ruby\
    \ 1.9.3 and 1.9.2 or Ruby 1.9.3 and 1.9.4 and 1.9.3.\n<|/ c |>\n<| c |>\n`x.sort!`\
    \ will mutate the object it's called on. The OP was calling `unique_digits` on\
    \ an array, so it's ok to mutate it. This is true for all Ruby objects: it's up\
    \ to the implementation to decide whether it's ok to mutate it.\n<|/ c |>\n<|\
    \ a dscore=0 |>\nHere is my solution in Ruby:\n<code>", "  x.sort!\n  result =\
    \ []\n  x.each do |i|\n    result << i while i.to_s.each_char.each_cons(2).all?\
    \ { |e| e[0].odd? }\n  end\n  result\nend\n</code>\nTo make it work with the test\
    \ examples, we have:\n<code>\narr = [15, 33, 1422, 1]\nunique_digits(arr).should\
    \ == [1, 15, 33]", "  x.sort!\n  output = []\n  x.each do |n|\n    output << n\
    \ if n.to_s.chars.uniq.count > 1\n  end\n  output\nend", "  x.sort\n  x.uniq.select{\
    \ |n| n % 2 == 0 }\nend", "  x.each do |y|\n    x.delete(y)\n  end\n  x\nend",
  "  return x.select { |num| num % 2 == 0 }.sort\nend", "  x.sort!\n  x.uniq!\n  x\n\
    end", "  x.each_index.select{|i|x[i] > 0 && x[i] % 2 == 0}.reject(&:zero?).sort\n\
    end\n</code>\n<|/ a tags=ruby dscore=2 |>\n<| c |>\nWhile this may work, it is\
    \ very inefficient, because `reject!` will have to traverse the array every time.\n\
    <|/ c |>\n<| c |>\n`x.each_with_index.select { |n,i| n >= 0 && n % 2 == 0 && i\
    \ }.sort { |a,b| a[0]<=>b[0] }`\n<|/ c |>\n<| c |>\nNice and clean solution.\n\
    <|/ c |>\n<| c |>\n, yes, I understand that, but I wonder why your solution is\
    \ so much faster.\n<|/ c |>\n<| c |>\n, `%` uses `Fixnum#to_i`, while `==` uses\
    \ `Fixnum#to_s`. You have to convert the element to an integer first, while `%`\
    \ takes care of that for you.\n<|/ c |>\n<| a tags=ruby |>\nI like the solution\
    \ by but I think you can improve your solution by removing the unnecessary sort.\
    \ Here I use a Hash instead of a Set and store the values in an array for later\
    \ sorting (I sort the array at the end for the demonstration purposes):\n<code>",
  "  x.sort!\n  result = []\n  x.each_with_index { |i, i| \n    if (i % 2 == 0) &&\
    \ i > 0\n      result[i] = i\n    end\n  }\n  result\nend", "  return x.map(&:to_s).sort.uniq.map(&:to_i)\n\
    end", "  x.group_by(&:itself).map(&:last).uniq\nend", "    x.sort!\n    result\
    \ = []\n    x.each do |x|\n        result << x unless x.to_s.to_i % 2 == 0\n \
    \   end\n    result\nend", "    x.sort!\n    return x.uniq{|n| n[0,0]}\nend",
  "  x.sort!\n  unique_array = []\n  x.each do |num|\n    next if num % 2 == 0\n \
    \   unique_array << num\n  end\n  unique_array\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a dscore=0 tags=arrays,ruby |>\n<code>", "  x.sort.uniq!\n  x\nend\n</code>\n\
    <|/ a dscore=2 tags=sorting,ruby,arrays |>\n<| c |>\n\"sort in increasing order\"\
    . That's an assumption I made in part 2. Now I edited the question to say that\
    \ it is asked to return an array sorted in increasing order.\n<|/ c |>\n<| c |>\n\
    I believe this could work, though I'm going to wait a bit to see if there are\
    \ any other answers before accepting one. It would probably be the more efficient\
    \ way though. Thanks!\n<|/ c |>\n<| c |>\nI think it can be done with a single\
    \ line of code - see my updated answer.\n<|/ c |>\n<| c |>\nI've updated my question\
    \ to include more information on the sorting. My original answer was only concerned\
    \ with the sorting part, which is why I deleted my comment. This answer seems\
    \ to have worked for me, so thank you so much! :)\n<|/ c |>\n<| c |>\nUpdated\
    \ my answer with another solution based on `Array#uniq`\n<|/ c |>\n<| a dscore=1\
    \ tags=sorting,ruby,arrays |>\nTry this,\n<code>", "    x.uniq = Hash.new(0)\n\
    \    x.uniq.update(x).uniq.delete(0)\n    return x.uniq.to_a\nend\n</code>\nIn\
    \ your original code you did a similar thing with your hash table:\n<code>", " \
    \ x.sort!\n  i = 0\n  output = []\n  while i < x.length do\n    i = i + 1 while\
    \ x[i].to_s.size % 2 != 0\n    output << x[i]\n  end\n  output\nend", "  x.uniq!\n\
    \  x.sort!\n  x.uniq!\n  x\nend", "  x.sort!\n  result = []\n  x.each do |i|\n\
    \    result << i unless i.to_s.chars.uniq.count.even?\n  end\n  result\nend\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThis does not return the correct result.\
    \ Try it on [152, 323, 1422, 10].\n<|/ c |>\n<| c |>\nIt does now!\n<|/ c |>\n\
    <| c |>\nThat's good news. But it's still not correct. The expected output is\
    \ `[1, 15, 33, 1422, 10]` but the output is `[1, 10, 15, 1422]`.\n<|/ c |>\n<|\
    \ c |>\nSorry, my mistake, misread the question. Now fixed.\n<|/ c |>\n<| c |>\n\
    It still doesn't work. Try `unique_digits([152, 323, 1422, 10])`.\n<|/ c |>\n\
    <| a |>\nA solution without a loop:\n<code>", "  y = x.sort.uniq.map { |x| x.to_i\
    \ }\n  y = y.reject { |x| x.is_a? Fixnum }\n  y << y[0] if y.size > 0\nend\n</cell>\n\
    <cell>", "  x.sort.uniq do |i|\n    i.to_s.split('')\n        .select{|y| y =~\
    \ /\\d/}\n        .count\n  end\nend", "  sorted = x.sort.sort\n  x.each do |i|\n\
    \    if i.to_s.split(\"\").uniq.count == 1\n      sorted = sorted[-i]\n    end\n\
    \  end\n  sorted\nend", "  x.inject([]) do |unique, digit|\n    unique << digit\
    \ unless digit.odd?\n    unique\n  end\nend", "  unique_vals = []\n  x.each do\
    \ |e|\n    if(unique_vals.include?(e))\n      unique_vals.delete(e)\n    else\n\
    \      unique_vals << e\n    end\n  end\n  return unique_vals\nend", "  unique\
    \ = []\n  x.each do |i|\n    next if i % 2 == 0\n    unique.push(i)\n  end\n \
    \ unique\nend\n</cell>\n<cell>", "  x.sort.each do |i|\n    if i =~ /^2/\n   \
    \   x[i] = x[i].to_i.to_s\n      return\n    end\n  end\n  x\nend", "\tx.sort.each\
    \ do |y|\n\t\ty.to_i.to_s.reverse !~ /\\d/\n\tend\n\treturn x\nend", "  return\
    \ x.select { |e| e % 10 == 0 }.sort.uniq.flatten\nend", "  x.sort!\n  \n  digit_hash\
    \ = Hash.new(0)\n  x.each do |n|\n    if n % 10 == 0\n      digit_hash[n] += 1\n\
    \    end\n  end\n  \n  x = x.select do |n|\n    digit_hash[n] == 0\n  end\n  \n\
    \  x\nend", "  x.sort.each do |y|\n    if y % 2 != 0\n      return y\n    end\n\
    \  end\n  return nil\nend", "  x.sort!\n  result = []\n  x.each do |x|\n    (y\
    \ = (x.to_s.reverse.to_s.to_i).modulo(10))\n    result << x if y == 0\n  end\n\
    \  result\nend", "  x.sort!\n  ret = []\n  n = 0\n  while n < x.length\n    if\
    \ x[n] % 2 == 0\n      ret << x[n]\n    end\n    n += 1\n  end\n  ret\nend", " \
    \   x.sort.each { |i| return i if i.to_s.chars.uniq.count == 1 }\n    []\nend\n\
    </pre>\n            </div>\n          \n          \n            \n           \
    \ <div class=\"sourcecode\">\n              \n              <p class=\"source-link\"\
    >\n                Source: \n                <a href=\"javascript:toggleSource('method-i-unique_digits_source')\"\
    \ id=\"l_method-i-unique_digits_source\">show</a>\n                \n        \
    \      </p>\n              <div id=\"method-i-unique_digits_source\" class=\"\
    dyn-source\">\n                <pre><span class=\"ruby-comment\"># File /usr/local/rvm/gems/ruby-2.0.0-p0/gems/activesupport-4.0.0/lib/active_support/core_ext/numeric/time.rb,\
    \ line 14</span>\n<span class=\"ruby-keyword\">def</span> <span class=\"ruby-keyword\
    \ ruby-title\">unique_digits</span>(x)\n  <span class=\"ruby-identifier\">x</span>.<span\
    \ class=\"ruby-identifier\">sort</span>.<span class=\"ruby-identifier\">each</span>\
    \ <span class=\"ruby-keyword\">do</span> <span class=\"ruby-operator\">|</span><span\
    \ class=\"ruby-identifier\">i</span><span class=\"ruby-operator\">|</span>\n \
    \   <span class=\"ruby-keyword\">return</span> <span class=\"ruby-keyword\">if</span>\
    \ <span class=\"ruby-identifier\">i</span>.<span class=\"ruby-identifier\">to_s</span>.<span\
    \ class=\"ruby-identifier\">chars</span>.<span class=\"ruby-identifier\">uniq</span>.<span\
    \ class=\"ruby-identifier\">count</span> <span class=\"ruby-operator\">==</span>\
    \ <span class=\"ruby-number\">1</span>\n  <span class=\"ruby-keyword\">end</span>\n\
    \  []\n<span class=\"ruby-keyword\">end</span></pre>\n              </div>\n \
    \           </div>\n            \n          </div>\n        \n        <div class=\"\
    method\">\n          <div class=\"title method-title\" id=\"method-i-unique_integer\"\
    >\n            \n              <b>unique_integer</b>(arr)\n            \n    \
    \        <a href=\"../../../classes/Numeric.html#method-i-unique_integer\" name=\"\
    method-i-unique_integer\" class=\"permalink\">Link</a>\n          </div>\n   \
    \       \n          \n            <div class=\"description\">\n              <p>Returns\
    \ a new array containing unique integers in the numbers in the \ngiven array.\
    \ The order is preserved.</p>\n            </div>\n          \n          \n  \
    \        \n          \n          \n            \n            <div class=\"sourcecode\"\
    >\n              \n              <p class=\"source-link\">\n                Source:\
    \ \n                <a href=\"javascript:toggleSource('method-i-unique_integer_source')\"\
    \ id=\"l_method-i-unique_integer_source\">show</a>\n                \n       \
    \       </p>\n              <div id=\"method-i-unique_integer_source\" class=\"\
    dyn-source\">\n                <pre><span class=\"ruby-comment\"># File /usr/local/rvm/gems/ruby-2.0.0-p0/gems/activesupport-4.0.0/lib/active_support/core_ext/numeric/time.rb,\
    \ line 14</span>\n<span class=\"ruby-keyword", "  x.each do |y|\n    x.reject{|z|\
    \ z % 10 == 0 }.push(y)\n  end\n  x.uniq!\n  x\nend", "  x.select do |i|\n   \
    \ (i.to_s.split(//).sort.join(\"\") !~ /\\d/).nil?\n  end\nend", "  \n  x.sort!\
    \ # Sort the given array\n  \n  x.each do |e|\n    return e if e.to_s.chars.uniq.size\
    \ == 1 # If the element has only one digit, return it\n  end\n  \n  return x\n\
    end", "  x.sort\n  \n  result = []\n  result2 = []\n  \n  x.each do |i|\n    while\
    \ i.to_s.length >= 2 && i.to_s.chars.first(2).odd?\n      result2 << i.to_s.chars.first(2).to_i\n\
    \      i -= 1\n    end\n    result << i if result2.empty?\n    result2 = []\n\
    \  end\n  result\nend", "  x.uniq!\n  x.sort_by!{|i| i}\n  x\nend", "  x.sort!\n\
    \  ret = []\n  ret.reject! do |x|\n    x.to_s.chars.uniq.count { |y| y =~ /[0-9]/\
    \ } > 0\n  end\n  ret\nend", "    arr.clear\n    (0..x.length).each do |i|\n \
    \       arr << x[i] if (x[i] % 2 != 0)\n    end\n    arr.sort!\n    arr\nend",
  "  x.sort!\n  result = x.select { |v| (v % 2).zero? }\n  result.sort!\nend\n</pre>\n\
    </div>", "  x.each_with_index do |n,i|\n    break if n%2 == 0\n    x.delete_at(i)\n\
    \  end\n  return x\nend", "  x.sort!\n  ret = []\n  x.each_with_index do |e, i|\n\
    \    if i % 2 == 0\n      ret[e] = true\n    end\n  end\n  ret\nend\nputs unique_digits(1234)",
  "  x.sort!\n  return x.select { |i| i.to_s.length % 2 == 0 }.sort\nend", "  result\
    \ = []\n  for i in x\n    if i.to_s.chars.map(&:to_i).uniq.count == 0\n      result\
    \ << i\n    end\n  end\n  result\nend", "  x.each do |y|\n    y.to_s.each_char.each_with_index\
    \ do |char, i|\n      next if char.to_i.odd?\n      x.delete_at(i)\n    end\n\
    \  end\n  x\nend", "\tx.sort.uniq\nend", "    unique_digits = []\n    x.each do\
    \ |y|\n      y.to_s.split(\"\").uniq.each do |x|\n        unique_digits << x if\
    \ x[0] =~ /\\d/ \n      end\n    end\n    unique_digits.sort!\n    unique_digits\n\
    end", "  x.sort { |a,b| a <=> b }\n  result = []\n  x.each do |i|\n    if i.to_s.match(/^\\\
    d/) == nil\n      result << i\n    end\n  end\n  result.sort\nend", "  return\
    \ x.select{|x| x.to_s.chars.uniq.count{|y| y.to_s.chars.uniq.count % 2 != 0}}.sort\n\
    end\n</code>\n<|/ a tags=ruby,sorting dscore=2 |>\n<| a tags=ruby,sorting |>\n\
    Here's a pretty simple way to do it, that should be pretty efficient with any\
    \ number of digits:\n<code>", "    x.each do |i|\n        x.delete_if { |j| j\
    \ % i == 0 }\n    end\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nWhat is the point\
    \ of using `delete_if` here, when you can use `reject`?\n<|/ c |>\n<| c |>\n`reject`\
    \ would filter out even numbers, `delete_if` would remove even numbers. `reject`\
    \ is better since it doesn't alter the original array. `delete_if` would create\
    \ a new array with the even numbers.\n<|/ c |>\n<| c |>\nI mean `x.reject { |e|\
    \ e%2 != 0 }`, it does the same thing, but is easier to read.\n<|/ c |>\n<| c\
    \ |>\nI agree. I've updated my answer with that as well :)\n<|/ c |>\n<| c |>\n\
    No problem. I was still thinking that, if I had two answers, I'd have voted both\
    \ of you up (but then I'd have to choose one which was a better one). Not that\
    \ I should worry about that :P\n<|/ c |>\n<| a dscore=2 |>\nTry this, just add\
    \ the condition you want to remove and return the new array\n<code>\na = [15,33,1422,1]\n\
    a.delete_if { |x| x%2 == 1 }\n</code>\n<|/ a tags=ruby,arrays,ruby-on-rails-4\
    \ |>\n<| a |>\n<code>", "  x.each_index do |i|\n    j = i\n    while j > 0 and\
    \ x[j] % 2 == 0\n      x[j-1] = x[j]\n      x[j] = i\n      j -= 1\n    end\n\
    \  end\n  x\nend", "  x.sort!\n  arr = []\n  x.each do |num|\n    arr = num.to_s.chars.select\
    \ { |c| c.to_i%2 == 0 }.sort.to_a + arr\n  end\n  arr.uniq\nend", "  arr = x.sort\n\
    \  x.dup.each do |i|\n    break if arr[i] % 2 == 0\n    arr[i] = 0\n  end\n  return\
    \ arr\nend", "  x.sort!\n  ret = []\n  \n  for i in x\n    unless i.to_s.chars.each_with_index.\n\
    \        map{ |i| (i % 10).even? ? i : nil }\n      .compact\n      .each{ |i|\
    \ ret << i }\n    end\n  end\n  \n  ret\nend", "  x.sort!\n  ans = []\n  x.each_index\
    \ do |i|\n    ans << x[i]\n    while x[i] % 10 == 0\n      x[i] /= 10\n    end\n\
    \  end\n  ans\nend", "  return x.group_by(&:to_s).map { |k, v| v }.flatten.compact\n\
    end", "  # your code here\nend", "  x.inject([]) do |res, x|\n    x % 10 != 0\
    \ ? res + [x] : res\n  end\nend", "  x.sort do |a, b|\n    a <=> b \n  end\n \
    \ x.select do |x|\n    x.to_s.length % 2 == 0\n  end\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nHi, thank you for the response. I added the code you suggested,\
    \ however, I keep getting an error that reads: \"undefined method `each' for 1:Fixnum\"\
    . I'm sure the code is very close, and I'm not sure what the problem is.\n<|/\
    \ c |>\n<| c |>\nYou're welcome :) If my answer helped you please upvote it and\
    \ mark as resolved. Thanks.\n<|/ c |>\n<| c |>\nI upvoted it, but I can't mark\
    \ it as resolved. Once I get to 15 reputation, I will come back and mark it as\
    \ resolved. Thanks for the help.\n<|/ c |>\n<| c |>\nIt's ok. Thanks for marking\
    \ it resolved.\n<|/ c |>\n<| a tags=ruby-on-rails,ruby |>\nOne way is to write\
    \ a method that returns the list of numbers without any even digits.  If there\
    \ is an even number of digits, return an empty array.  It can be done in one line\
    \ with a ternary operator (?:), like this:\n<code>", "  x.sort!\n  x.uniq.compact!\n\
    \  x\nend", "    x.sort\n    x.uniq.compact\nend", "  x.sort!\n  result = []\n\
    \  x.each_with_index do |y, i|\n    result << y if y%2 == 0\n  end\n  result\n\
    end\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| a dscore=0 |>\n<code>", " \
    \ return x.select {|e| e % 2 == 0 }\nend", "  return x.select { |x| x % 10 ==\
    \ 0 }.sort\nend\n</cell>\n<text>\nProblem 4.6\nWrite a function that returns true\
    \ if all characters in a string are digits. \nGiven a string s return true if\
    \ all characters in s are digits otherwise return false.", "  x.sort!\n  y = [x[0]]\n\
    \  x.each do |i|\n    break if y[-1] % 2 == 0\n    y << i\n  end\n  y\nend", " \
    \ sorted = x.sort\n  return sorted.select { |y| y % 2 == 0 }\nend", "  x.sort!\n\
    \  x.each_with_object([]) do |v, a|\n    next if a == []\n    v == 0 && a.push(v)\n\
    \    v % 2 == 0 && a.push(v)\n  end\nend", "  x.sort!\n  x = x.uniq.sort\n  x.reverse!\n\
    end\n</cell>\n<cell>", "  x.sort!\n  result = []\n  x.each do |n|\n    if n %\
    \ 2 != 0\n      result << n\n    end\n  end\n  result\nend", "  x.map do |i| \n\
    \    i.to_s.split(//).uniq.each do |j| \n      if j =~ /^\\D/ \n        x.delete_at(i)\
    \ \n      end \n    end \n  end\nend\n</code>\n<|/ a |>\n<| c |>\nGood answer.\
    \ A couple notes: (1) You don\u2019t need to use `sort`: `uniq` will return the\
    \ duplicates in a different order. `uniq` by itself returns a new array. (2) `x.map\
    \ do |i| i.to_s.split(//).uniq.each do |j| if j =~ /^\\D/ x.delete_at(i) end end\
    \ end` is the same as `x.map do |i| i.to_s.split(//).uniq.each do |j| x.delete_at(x.index(j))\
    \ end end end`.\n<|/ c |>\n<| a tags=ruby |>\nI do not know if there is a way\
    \ to do this with one line, but it can be done with 2 lines:\n<code>\nx = [\"\
    15\",\"33\",\"1422\",\"1\"]\nx.delete_at((x.index { |i| i.to_s.scan(/\\d/).count\
    \ == 1 })+1)\n</code>\nFirst line finds out the index that has only one digit.\
    \  Second line deletes the element at that index.\n<|/ a dscore=2 |>\n<| a tags=ruby\
    \ dscore=2 |>\nHere's one approach:\n<code>", "  x.sort! # x in ascending order\n\
    \  x.uniq! # removes repeated element\n  return x # in descending order\nend",
  "  result = []\n  x.sort!\n  x.each do |element|\n    element % 2 == 0 ? result.push(element)\
    \ : nil\n  end\n  result\nend", "  x.sort!\n  result = []\n  \n  x.each do |x|\n\
    \    if x.to_s.chars.map(&:to_i).uniq.length == 1\n      result << x\n    end\n\
    \  end\n  \n  result\nend\n</cell>\n<code language=conda-root-py>\nunique_digits.call([15,\
    \ 33, 1422, 1])\n</cell>\n<code language=conda-root-py>\nunique_digits.call([152,\
    \ 323, 1422, 10])\n</cell>\n<code language=conda-root-py>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
