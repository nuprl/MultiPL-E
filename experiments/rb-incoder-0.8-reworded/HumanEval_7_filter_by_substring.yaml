name: HumanEval_7_filter_by_substring
language: rb
prompt: "# Filter an input array of strings only for ones that contain given substring\n\
  # >>> filter_by_substring.call([], \"a\")\n# []\n# >>> filter_by_substring.call([\"\
  abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n# [\"abc\", \"bacd\", \"array\"]\n\
  def filter_by_substring(strings, substring)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_filter_by_substring\n\
  \    candidate = method(:filter_by_substring)\n    assert_equal([], candidate.call([],\
  \ \"john\"))\n    assert_equal([\"xxx\", \"xxxAAA\", \"xxx\"], candidate.call([\"\
  xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\"))\n    assert_equal([\"\
  xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"], candidate.call([\"xxx\", \"asd\", \"aaaxxy\"\
  , \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\"))\n    assert_equal([\"grunt\", \"\
  prune\"], candidate.call([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
  ))\n  end\nend\n"
completions: ["  filtered = []\n  strings.each do |str|\n    if str.include? substring\n\
    \      filtered << str\n    end\n  end\n  filtered\nend", "  return strings.select\
    \ { |string| string.include?(substring) }\nend", "  strings.select { |s| s.include?(substring)\
    \ }\nend", "  strings.select { |str| str.include?(substring) }\nend\nfilter_by_substring\
    \ = RubyProc.new([:string, :string]) { |string, substring| filter_by_substring(string,\
    \ substring) }", "  return strings.select { |s| s.include? substring }\nend",
  "    strings.map! do |string|\n        if string.include? substring\n          \
    \  string\n        else\n            nil\n        end\n    end\n    strings\n\
    end", "    filtered_strings = strings.select do |string|\n        string =~ /#{substring}/\n\
    \    end\n    filtered_strings\nend\n</code>\nThe result is:\n<code>\n$ ruby filter_by_substring.rb\
    \ \n[\"abc\", \"bacd\", \"cde\", \"array\"]\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nThank you very much for your answer, but this would not satisfy the requirement\
    \ that substring must be at the start or end of the string. ", "  strings.select\
    \ { |str| str.include?(substring) }\nend", "  strings.select { |s| s.include?(substring)\
    \ }\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis is much more concise and readable\
    \ than my answer. +1\n<|/ c |>\n<| c |>\nI think I like it more, as it is using\
    \ Ruby's native `select`, which makes use of short-circuit evaluation.\n<|/ c\
    \ |>\n<| c |>\nI like it. Ruby's native `select` makes use of short-circuit evaluation\
    \ (which I don't think is necessary here) whereas my answer doesn't use it. I\
    \ would have to run a test to see which is more performant. But the downside of\
    \ short-circuit is that the result is an array, so it isn't very useful if you\
    \ need the original array intact.\n<|/ c |>\n<| a tags=ruby dscore=1 |>\nHere\
    \ is a simple solution: \n<code>", "  strings.select! do |string|\n    !string.nil?\
    \ && string.index(substring)\n  end\nend", "    strings.select do |string| string.include?(substring)\
    \ end\nend", "  strings.grep(%r{^#{Regexp.quote(substring)}}).map(&:to_s)\nend\n\
    </code>\nThe above code is using the same regex as your filter_by_substring function,\
    \ which I recommend using if you don't want to refactor your code to use something\
    \ different from grep.\nThe above code doesn't modify the original array, but\
    \ returns the filtered array.\n<|/ a |>\n<| a dscore=0 |>\nIf anyone is interested\
    \ I found a nice way to solve this problem without creating a new method or rewriting\
    \ everything. I just had to use inject\n<code>\narray.inject({}) do |memo, string|\n\
    \  memo[string] ||= []\n  memo[string] << string\n  memo\nend\n</code>\n<|/ a\
    \ tags=arrays,ruby,hashmap |>\n<| c |>\nThis won't work if you have duplicate\
    \ values in the array. You have to add `memo[string] ||= []` before `memo[string]\
    \ << string`.\n<|/ c |>\n<| c |>\nAlso, `inject` will add empty arrays to the\
    \ array if it doesn't find a value for the given string.\n<|/ c |>\n<| c |>\n\
    I think `memo[string] ||= []` before `memo[string] << string` solves it.\n<|/\
    \ c |>\n<| c |>\nYou are right! I'll fix it\n<|/ c |>\n<| c |>\nI think `memo[string]\
    \ ||= []` is unnecessary because `memo[string] ||= []` returns `memo[string]`\
    \ if `memo[string]` isn't set.\n<|/ c |>\n<| a tags=arrays,ruby,hashmap |>\nYou\
    \ could also use the group_by method (which returns a Hash). It groups the values\
    \ by key (which we pass as the first parameter) and returns that group (which\
    \ we pass as the second parameter). This way we can easily get all the values\
    \ for a given key (a key's value) using values method.\nIn case you want to get\
    \ all the values of a given key (a key's value) regardless of other keys having\
    \ that key value, you can use\n<code>\nvalues = array.group_by{|e| e}.values.flatten.uniq\n\
    </code>\n<|/ a dscore=0 |>\n<| a |>\nIf your array is sorted, you can use inject.\n\
    <code>\narr = ['abc', 'abc', 'abc', 'abc', 'bacd', 'bacd', 'bacd', 'array', 'array',\
    \ 'array']\narr.inject({}) do |memo, str|\n  memo[str] = str\n  memo\nend\n</code>\n\
    <|/ a dscore", "  results = []\n  strings.each do |string|\n    if string.include?(substring)\n\
    \      results << string\n    end\n  end\n  return results\nend", "  strings.select\
    \ { |str| str.include?(substring) }\nend", "  return strings[strings.index(*substring)]\n\
    end", "  strings.select do |string|\n    string =~ /#{substring}/\n  end\nend",
  "  return strings.select { |string| string.include?(substring) }\nend", "  strings.select\
    \ do |string|\n    string.include?(substring)\n  end\nend", "  strings.select\
    \ { |string| string.include? substring }\nend", "  strings.select do |string|\n\
    \    string =~ /#{substring}/\n  end\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1\
    \ |>\nI came up with the following solution, using only Ruby. It uses a recursive\
    \ method and a regex:\n<code>", "  return strings.select do |string|\n    string\
    \ =~ /#{substring}/\n  end\nend", "  strings.select do |string|\n    string.include?(substring)\n\
    \  end\nend", "  strings.select{ |str| str.include?(substring) }\nend", "    strings.collect{|x|\
    \ x.include?(substring) ? x : nil}\nend", "  return [] if strings.empty? || substring\
    \ == '*' else strings.select do |string|\n    string.include?(substring)\n  end\n\
    end\n</code>\n<|/ a tags=string,ruby |>\n<| a tags=string,ruby |>\nMy solution\
    \ would be to use regular expressions:\n<code>", "  strings.select { |string|\n\
    \    string.index(substring) != -1\n  }\nend", "  strings.select { |string|\n\
    \    string.include?(substring)\n  }\nend", "  result = Array.new(strings.length,\
    \ 0)\n  strings.each { |string| result.push(string) if string.index(substring)\
    \ != -1 }\n  result\nend", "    strings.grep(/^#{substring}/i)\nend\nalias_method\
    \ :filter_without_substring, :filter_by_substring", "    strings.select{|s| s.include?(substring)}\n\
    end", "\tstrings.reject do |string|\n\t\tstring.include?(substring)\n\tend\nend",
  "  strings.select { |s| s.include?(substring) }\nend\n</code>\n<|/ a tags=ruby-on-rails,ruby\
    \ dscore=3 |>\n<| a |>\nThe code as originally posted is very similar to the following\
    \ in the Rails console:\n<code>\nirb(main):001:0> array = [\"abc\", \"bacd\",\
    \ \"cde\", \"array\"]\n=> [\"abc\", \"bacd\", \"cde\", \"array\"]\nirb(main):002:0>\
    \ array.grep(/a/)\n=> [\"abc\", \"bacd\", \"array\"]\n</code>\nThat said, I find\
    \ it much more readable to use the select method instead of the grep method:\n\
    <code>\nirb(main):010:0> array = [\"abc\", \"bacd\", \"cde\", \"array\"]\n=> [\"\
    abc\", \"bacd\", \"cde\", \"array\"]\nirb(main):011:0> array.select { |s| s.include?('a')\
    \ }\n=> [\"abc\", \"bacd\", \"array\"]\n</code>\n<|/ a dscore=3 tags=ruby-on-rails,ruby\
    \ |>\n<| c |>\nThis is by far the best answer. Using `select` is exactly what\
    \ it was meant for.\n<|/ c |>\n<| a dscore=2 tags=ruby-on-rails,ruby |>\nI thought\
    \ it would be easiest to write a simple method that just returns all the elements\
    \ that have a given value:\n<code>", "  substring_matcher_without_slashes = Regexp.new(\"\
    ^\" + Regexp.quote(substring) + \"$\")\n  matching_strings = strings.select {\
    \ |string| substring_matcher_without_slashes.match(string) }\n  matching_strings\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThank you so much for taking the time to write\
    \ this up; I appreciate it.  I will give this a try, and I hope it will work.\
    \  ", "  strings.select { |s| s.include?(substring) }\nend", "  strings.select\
    \ {|s| s.include?(substring)}\nend", "  strings.select {|string| string =~ /#{substring}/i}\n\
    end\n</code>\nI thought about a regex but this one is really fast.  Note that\
    \ it does match empty strings and strings with non-ascii characters (like \u011B\
    \u0161\u010D\u0159\u017E\xFD\xE1\xED\xE9\xFA\xFA\u010F\u0148).\n<|/ a |>\n<| c\
    \ |>\nI made a benchmark using Benchmark Ruby gem (http://ruby-doc.org/stdlib-1.9.3/libdoc/benchmark/rdoc/Benchmark.html)\
    \ and this version was twice faster (from about 4 seconds to about 6 seconds).\
    \ Thanks!\n<|/ c |>\n<| c |>\nWow, that's a great improvement!  Thank you.  I\
    \ updated the answer accordingly.  By the way, if you don't mind, I added the\
    \ regex version too.  Hopefully you'll find it useful to you and others.\n<|/\
    \ c |>\n<| a |>\nYou can use a regular expression:\n<code>", "  strings.select\
    \ do |s|\n    s.include?(substring)\n  end\nend", "  return strings.select { |s|\
    \ s.include? substring }\nend", "  strings.select do |string|\n    substring.include?(string)\n\
    \  end\nend\n</code>\nAs a side-note, you can also use a regex in Ruby:\n<code>\n\
    strings =\n  [\n    \"abc\",\n    \"bacd\",\n    \"cde\",\n    \"array\"\n  ]",
  "  strings.select do |string|\n    string.include? substring\n  end\nend", "  return\
    \ strings.select do |str|\n    str.include?(substring)\n  end\nend", "  strings.select\
    \ do |string|\n    string.include?(substring)\n  end\nend", "  strings.collect\
    \ { |string| string.include?(substring) }\nend", "  strings.select { |string|\
    \ string =~ Regexp.new(substring) }\nend", "  strings.each do |string|\n    return\
    \ string if string.index(substring)\n  end\n  strings\nend", "  strings.select\
    \ {|s| s.include?(substring) }\nend", "  strings.collect { |string| string.include?(substring)\
    \ ? string : nil }\nend", "  strings.each do |string|\n    if string.include?(substring)\n\
    \      yield string\n    end\n  end\nend", "  strings.select { |string| string.include?(substring)\
    \ }\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| a |>\nIf you're looking\
    \ for a one liner you can use Array#find and Array#include?:\n<code>\n>> arr =\
    \ [\"abc\", \"bacd\", \"cde\", \"array\"]\n>> arr.find { |s| s.include?(\"a\"\
    ) }", "    strings.select do |string|\n        string =~ /^#{substring}$/\n  \
    \  end\nend", "  strings.select { |string| string.index(substring) != nil } #\
    \ remove nil elements (indices of substrings which don't exist in strings)\nend",
  "  strings.select do |string|\n    string =~ /#{substring}/i\n  end\nend", "  return\
    \ strings.select { |x| x =~ /^#{substring}/ }\nend", "  strings.select do |string|\n\
    \    string.downcase == substring\n  end\nend", "  strings.each do |string|\n\
    \    string.index(substring) ? strings << string : nil\n  end\n  strings\nend",
  "  strings.select{|x| x =~ substring }\nend", "  strings.grep(/^#{substring}/).map(&:chomp)\n\
    end", "  strings = strings.map do |string|\n    string.sub(substring, \"\")\n\
    \  end\n  strings\nend", "  strings.grep(/^#{substring}/i)\nend", "  return strings.select\
    \ { |str| str.include?(substring) }\nend", "  strings.select { |string|\n    string.include?(substring)\n\
    \  }\nend", "  result = strings.dup\n  string_index = 0\n  strings_length = strings.length",
  "  strings.select{|str| str.include?(substring) }\nend", "\tstrings.select{ |e|\
    \ e.include?(substring) }\nend", "  strings.reject! { |string| string[string.index(substring)]\
    \ == substring }\n  strings\nend", "  strings.reject do |string|\n    string.index(substring)\
    \ == nil\n  end\nend", "  new_strings = []\n  new_strings.concat strings.reject\
    \ do |string|\n    substring =~ string\n  end\n  new_strings\nend", "  strings.select{\
    \ |string| string.include?(substring) }\nend", "  result = \"\"\n  strings.each\
    \ do |string|\n    if string.include? substring\n      result << string\n    end\n\
    \  end\n  result\nend\n</code>\n<|/ a dscore=1 tags=filtering,ruby,arrays |>\n\
    <| c |>\n\"a\".include? \"a\" => true, so \"a\".include? \"b\" => true, so \"\
    a\".include? \"c\" => true, so \"a\".include? \"d\" => true, so \"a\".include?\
    \ \"e\" => true, so \"a\".include? \"z\" => false, so \"a\".include? \"bcd\" =>\
    \ true, so \"a\".include? \"cde\" => true, so \"a\".include? \"array\" => false,\
    \ so \"a\".include? \"bcd\".include? \"ba\" => false, so \"a\".include? \"cde\"\
    .include? \"ba\" => false, so \"a\".include? \"array\".include? \"ab\" => false,\
    \ so \"a\".include? \"bcd\".include? \"ca\" => false, so \"a\".include? \"cde\"\
    .include? \"ca\" => false, so \"a\".include? \"array\".include? \"ac\" => false,\
    \ so \"a\".include? \"bcd\".include? \"ca\" => false, so \"a\".include? \"cde\"\
    .include? \"ca\" => false, so \"a\".include? \"array\".include? \"ad\" => false,\
    \ so \"a\".include? \"bcd\".include? \"ca\" => false, so \"a\".include? \"cde\"\
    .include? \"ca\" => false, so \"a\".include? \"array\".include? \"ae\" => false,\
    \ so \"a\".include? \"bcd\".include? \"ca\" => false, so \"a\".include? \"cde\"\
    .include? \"ca\" => false, so \"a\".include? \"array\".include? \"af\" => false,\
    \ so \"a\".include? \"bcd\".include? \"ca\" => false, so \"a\".include? \"cde\"\
    .include? \"ca\" => false, so \"a\".include? \"array\".include? \"ag\" => false,\
    \ so \"a\".include? \"bcd\".include? \"ca\" => false, so \"a\".include? \"cde\"\
    .include? \"ca\" => false, so \"a\".include? \"array\".include? \"ah\" => false,\
    \ so \"a\".include? \"bcd\".include? \"ca\" => false, so \"a\".include? \"cde\"\
    .include? \"ca\" => false, so \"a\".include? \"array\".include? \"ai\" => false,\
    \ so \"a\".include? \"bcd\".include? \"ca\" => false, so ", "  return strings.select\
    \ { |s| s.include?(substring) }\nend", "  strings.select { |str| str.include?(substring)\
    \ }\nend", "  strings.select do |string|\n    string.include?(substring)\n  end\n\
    end", "  strings.select{|s| s =~ /^#{substring}/i}.map {|s| s}\nend", "  strings.select\
    \ { |string| string.include?(substring) }\nend", "  return strings.select do |string|\n\
    \    string.index(substring) != nil\n  end\nend", "  filtered_strings = []\n \
    \ strings.each do |string|\n    if string.include?(substring)\n      filtered_strings\
    \ << string\n    end\n  end\n  filtered_strings\nend", "  filtered = []\n  strings.each\
    \ do |str|\n    if str.include?(substring)\n      filtered << str\n    end\n \
    \ end\n  filtered\nend", "  strings.grep(Regexp.new(Regexp.escape(substring) +\
    \ \"$\"))\nend\n</code>\n<|/ a tags=ruby-on-rails,ruby |>\n<| c |>\nGood answer,\
    \ but the function itself should be `def filter_by_substring(strings, substring)`\n\
    <|/ c |>\n<| a |>\nThe other answers here don't quite answer the question: how\
    \ to get all the strings that match a pattern without needing to build an entire\
    \ regex or use grep\n<code>", "  strings.select { |string| string.include?(substring)\
    \ }\nend", "  strings.select { |string| string.include?(substring) }\nend", " \
    \ strings.select { |string| string.include?(substring) }\nend", "    strings.collect\
    \ { |str| str.index(substring) ? str : nil }.compact\nend", "  return strings.grep(/^#{substring}$/)\n\
    end", "  strings.select { |string| string.include?(substring) }\nend", "  strings.select\
    \ { |string| string.include?(substring) }\nend", "  filtered_strings = []\n  strings.each\
    \ do |string|\n    next if string == substring\n    filtered_strings << string\n\
    \  end\n  filtered_strings\nend", "  filtered_strings = []\n  strings.each do\
    \ |string|\n    if string.include?(substring)\n      filtered_strings << string\n\
    \    end\n  end\n  filtered_strings\nend", "  filtered_strings = []\n  strings.each\
    \ do |string|\n    if string.include?(substring)\n      filtered_strings << string\n\
    \    end\n  end\n  filtered_strings\nend", "  strings.grep(/^#{substring}$/)\n\
    end", "  strings.select do |string|\n    string.include?(substring)\n  end\nend",
  "  strings.select { |s| s.include?(substring) }\nend\n</code>\n<|/ a dscore=5 |>\n\
    <| c |>\nI came here looking for a way to remove a prefix from the middle of the\
    \ string. Here's my solution for that case: `strings.map{|s| s.sub(/^prefix/,'')}`\n\
    <|/ c |>\n<| c |>\nGood answer. I would change `include?` to `include?(substring)`\
    \ in `filter_by_substring`.\n<|/ c |>\n<| a tags=ruby,string,filter |>\nFor anyone\
    \ using Rails, you can easily create a filter like this:\n<code>", "    strings.select\
    \ do |string|\n      string.include?(substring)\n    end\nend", "  strings.select{|string|\
    \ string.include? substring }\nend", "  strings.grep(/#{substring}/)\nend", " \
    \ strings.select { |s| s.include? substring }\nend", "  strings.select do |string|\n\
    \    string.include?(substring)\n  end\nend", "  strings = strings.collect { |str|\
    \ str.include?(substring) ? str : nil }\n  strings = strings.compact\n  strings\n\
    end", "  strings.select do |string|\n    string.index(substring)\n  end\nend",
  "  strings.select{|x| x.include?(substring) }\nend", "  strings.each do |s|\n  \
    \  s.include?(substring) ? strings.pop : strings\n  end\n  strings\nend\n</code>\n\
    <|/ a tags=string,arrays,ruby,loops |>\n<| a dscore=1 |>\n<code>\nrequire 'benchmark'",
  "  result = Array.new\n  strings.each do |string|\n    if string.include?(substring)\n\
    \      result << string\n    end\n  end\n  result\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThanks Josh, your answer gave me some good ideas and I got the\
    \ code working. I edited my post to show what I did.\n<|/ c |>\n<| a dscore=0\
    \ |>\nHere is a general approach using only methods from the String class.\n<code>",
  "  strings.select do |string|\n    string.include?(substring)\n  end\nend", "  strings.select{\
    \ |string| string.include?(substring) }\nend", "  return strings.select do |string|\n\
    \    string.index(substring)\n  end\nend", "  strings[0, strings.size-1].each\
    \ do |string|\n    next if string.index?(substring)\n    strings << string\n \
    \ end\n  strings\nend", "  return strings.select { |str| str.include?(substring)\
    \ }\nend", "  strings.grep(%r{#{Regexp.escape(substring)}}).map(&:to_s)\nend",
  "  strings.map! do |string|\n    if string.include?(substring)\n      string\n \
    \   else\n      nil\n    end\n  end\nend", "  strings.select do |s|\n    s =~\
    \ Regexp.escape(substring)\n  end\nend", "    strings.select{|s| s.include?(substring)\
    \ }\nend\n</code>\nTo get a list of those that do not include the substring, just\
    \ drop the select method. This returns an Enumerator object which you can convert\
    \ to an array with to_a.\n<code>", "  strings.select{ |s| s.include?(substring)\
    \ }\nend", "  strings.select do |string|\n    string.include?(substring)\n  end\n\
    end", "  strings.select do |string|\n    string.include?(substring)\n  end\nend",
  "  strings = strings.reject do |str|\n    str.include?(substring)\n  end\n  strings\n\
    end", "  strings.select do |element|\n    element.include?(substring)\n  end\n\
    end", "  strings.select do |string|\n    string.include?(substring)\n  end\nend\n\
    </code>\n<|/ a tags=arrays,ruby,string |>\n<| c |>\nI'm sorry that I did not see\
    \ your answer before. This one seems cleaner\n<|/ c |>\n<| a tags=arrays,ruby,string\
    \ |>\nI think that the easiest way is to convert both string to Arrays and then\
    \ use Array#include? :\n<code>", "  strings.select do |string|\n    string.index(substring)\
    \ != nil\n  end\nend", "\tstrings.select do |str|\n\t\tstr.include?(substring)\n\
    \tend\nend", "  strings.reject!{|string| !string.include?(substring) }\n  strings\n\
    end", "  strings.select { |str| str.include?(substring) }\nend", "  strings.select\
    \ { |s| s.include?(substring) }\nend", "  strings.select {|string| string.index(substring)\
    \ != -1}\nend", "  strings = strings.grep(/^#{substring}/).map(&:to_s)\n  strings.length\
    \ == 0 ? (nil) : strings\nend", "  strings.select do |string|\n    string.index(substring)\
    \ != nil\n  end\nend", "  strings.select do |string|\n    string.include?(substring)\n\
    \  end\nend", "    strings.select { |s| s.include? substring }\nend", "  strings.grep(/^.*#{substring}.*$/)\n\
    end", "  strings.select { |string| string.index(substring) != -1 }\nend", "  strings.select\
    \ do |string|\n    string =~ /#{substring}/\n  end\nend", "  strings.select{|str|\
    \ str.include?(substring)}\nend", "  strings.reject! { |s| not s.include?(substring)\
    \ }\n  strings\nend", "\tstrings.select { |x| x =~ /^.*#{substring}.*/ }\nend",
  "    strings.select do |string|\n        string =~ /#{substring}/ ? true : false\n\
    \    end\nend", "  return strings.select { |str| str.include?(substring) }\nend",
  "  strings.collect!{ |s| s.gsub(substring, \"\") }\n  strings\nend", "  strings.grep(%r{^#{Regexp.escape(substring)}}).map(&:to_s)\n\
    end", "  strings.select { |string| string.include?(substring) }\nend", "  strings.select\
    \ do |string|\n    string.downcase.include?(substring)\n  end\nend", "    strings.select\
    \ { |string| string.include?(substring) }\nend", "  strings.select { |string|\
    \ string.index(substring) }\nend", "  strings.select{ |str| str.include?(substring)\
    \ }\nend", "  strings.select { |s| s.include?(substring) }\nend", "    strings.select\
    \ { |string| string =~ /^#{substring}/i }\nend\n</cell>\n<text>\nNow that we have\
    \ implemented a filter function we can use it to filter our original array for\
    \ all the ones that contains \"a\" in them:", "  strings.select { |str| str.include?(substring)\
    \ }\nend", "  return strings.select{|s| s.include?(substring) }\nend", "  strings.select\
    \ { |string| string.include?(substring) }\nend", "  strings = Array.new(strings.size)\
    \ { |i| strings[i] }\n  strings.grep(/^#{substring}$/)\nend\n</code>\nThe last\
    \ method is the one you might need to implement if you want a more powerful filter\
    \ that can match anywhere in the string rather than just at the beginning.  You\
    \ can see this example at the bottom of this post.\n<|/ a |>\n<| a tags=ruby,ruby-on-rails,activerecord,ruby-on-rails-3\
    \ |>\nAnother way:\n<code>", "  strings.select do |s|\n    include? substring,\
    \ s\n  end\nend", "\tstrings.select { |s| s.include?(substring) }\nend", "  strings.select\
    \ do |string|\n    string.include?(substring)\n  end\nend", "  return strings.select\
    \ do |string|\n    string.include?(substring)\n  end\nend", "  strings.select\
    \ do |string|\n    string =~ Regexp.new(substring, Regexp::IGNORECASE)\n  end\n\
    end", "  return strings.select { |s| s =~ substring }\nend", "  strings = strings.select\
    \ { |x| x.include?(substring) }\n  strings\nend", "  strings.select do |str|\n\
    \    str.include?(substring)\n  end\nend", "  strings.select { |string| string.include?(substring)\
    \ }\nend", "  strings.grep(/^#{substring}$/)\nend", "  strings.collect { |str|\
    \ str.include?(substring) ? str : nil }\nend", "  strings.select{|s| s.include?(substring)}\n\
    end", "  strings = strings.map { |s| s.gsub!(substring, \"\") }\n  strings\nend",
  "  strings.select{|s| s.include? substring}\nend", "\tstrings.map do |string|\n\t\
    \tif string.include?(substring)\n\t\t\tstring\n\t\tend\n\tend.compact\nend", " \
    \ strings.grep(/^#{substring}/)\nend", "  return strings.select { |x| x.include?(substring)\
    \ }\nend", "  strings.select {|string| string.include?(substring) }\nend", " \
    \ strings.select { |string| string.include?(substring) }\nend", "  strings.select{|s|\
    \ s.include?(substring) }\nend", "    strings.select { |s| s.include?(substring)\
    \ }\nend", "  strings.grep(/^.*#{substring}.*$/)\nend", "  strings.select { |string|\
    \ string.include? substring }\nend", "  strings.select{|s| s.include?(substring)}\n\
    end", "  strings.grep(/^#{substring}$/)\nend", "  strings.select { |string| string.include?(substring)\
    \ }\nend", "  strings.select{ |string| string.include?(substring) }\nend", " \
    \ strings.each do |str|\n    if str.include? substring\n      yield str\n    end\n\
    \  end\nend\n  ", "  strings.select { |string| string.include?(substring) }\n\
    end", "  return strings.select {|s| s =~ /^#{substring}/}\nend", "    \n    if\
    \ strings.nil? or substring == nil\n        return strings\n    end\n    \n  \
    \  if substring == \"*\"\n        return strings\n    end\n    \n    strings.select\
    \ {|str| str.include?(substring)}\nend", "  strings.select { |s| s =~ /^#{substring}/\
    \ }\nend", "  return strings.select { |string| string.include?(substring) }\n\
    end", "  strings.grep(/^#{substring}/)\nend", "  strings.grep(/^#{substring}/)\n\
    end", "  strings.select{ |string| string.include? substring }\nend", "  strings.select{|string|\
    \ string.include?(substring)}.to_a\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    thanks for your answer. I think I was confused about what method and argument\
    \ to use.\n<|/ c |>\n<| c |>\nI added an explanation of what is actually happening\
    \ in the methods I described. If you are new to Ruby, I would strongly recommend\
    \ checking out the [Ruby Documentation](http://ruby-doc.org/) where you can find\
    \ the various methods and arguments used.\n<|/ c |>\n<| c |>\nYes, I realize Ruby\
    \ is extremely powerful, and I really appreciate the pointer to documentation.\
    \ I will do that. The main reason I did not want to use the Ruby documentation\
    \ is because I'm working on a ruby homework assignment and I wanted to write a\
    \ simple method that would do the trick for me. I do have a basic understanding\
    \ of the select/reject methods though.\n<|/ c |>\n<| c |>\nAlso, I was confused\
    \ by what was actually happening in the method. I think I got it now. I guess\
    \ \"select\" basically takes the string in question and returns a new array with\
    \ the ones that match the given criteria. For example, \"abc\".include?(\"a\"\
    ) would return true. So the line \"strings.select{|string| string.include?(substring)}.to_a\"\
    \ is simply saying, \"Select each string in strings and return a new array only\
    \ containing the ones that match the given criteria\".\n<|/ c |>\n<| c |>\nThat's\
    \ right, and as you said, that line does that. The reason I used the method I\
    \ described is because that method returns the same data structure as your `filter_by_substring`\
    \ method, i.e. a new array, not a hash, and that is more idiomatic Ruby than using\
    \ an each-loop to create another array. However, if you were to use a loop, `map`,\
    \ or `select`, or any other method, then yes you would have to create an array\
    \ from it, as you say.\n<|/ c |>\n<| a |>\nThe other answers are quite helpful,\
    \ and I learned some new Ruby syntax, so thank you for your input.\nI wanted to\
    \ share the method I created based on the Ruby documentation you provided and,\
    \ since I needed to be able to call it from my main program file, I wanted to\
    \ include the method's definition in my main program file. I did this by adding\
    \ the following to the top of my main program file (I'm working in Rubymine):\n\
    <code>\ninclude MyFilter\n</code>\nAnd then creating the method in the file I\
    \ created:\n<code>", "  strings.select { |string| string.include?(substring) }\n\
    end", "  strings.select do |s|\n    s.include?(substring)\n  end\nend", "  strings.select\
    \ { |str| str.index(substring) != -1 }\nend", "  strings.select { |string| string.include?(substring)\
    \ }\nend", "  return strings.collect { |s| s.include?(substring) ? s : nil } unless\
    \ substring.empty?\n  strings\nend", "  strings.select { |str| str.include?(substring)\
    \ }\nend", "  strings.each do |str|\n    next if str =~ /\\A#{Regexp.escape(substring)}\\\
    z/\n    next if str.blank?\n    yield str\n  end\nend", "  strings.select do |string|\n\
    \    string.include? substring\n  end\nend", "\tret = Array.new\n\t\n\tstrings.each\
    \ do |s|\n\t\tif s.include?(substring)\n\t\t\tret << s\n\t\tend\n\tend\n\t\n\t\
    return ret\nend", "  return strings.select { |s| s.include? substring }\nend",
  "  strings.select do |string|\n    string.index(substring) == 0\n  end\nend", " \
    \ strings.select{ |s| s.include?(substring) }\nend", "  strings.select do |string|\n\
    \    string.index(substring) != nil\n  end\nend", "  strings.select { |string|\
    \ string.include?(substring) }\nend", "  return strings.select do |string|\n \
    \   string.include?(substring)\n  end\nend", "  strings.select { |string| string.index(substring)\
    \ == 0 }\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
