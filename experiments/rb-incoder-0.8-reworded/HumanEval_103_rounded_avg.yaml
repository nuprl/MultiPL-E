name: HumanEval_103_rounded_avg
language: rb
prompt: "# You are given two positive integers n and m, and your task is to compute\
  \ the\n# average of the integers from n through m (including n and m). \n# Round\
  \ the answer to the nearest integer and convert that to binary.\n# If n is greater\
  \ than m, return -1.\n# Example:\n# >>> rounded_avg.call(1, 5)\n# \"0b11\"\n# >>>\
  \ rounded_avg.call(7, 5)\n# -1\n# >>> rounded_avg.call(10, 20)\n# \"0b1111\"\n#\
  \ >>> rounded_avg.call(20, 33)\n# \"0b11010\"\ndef rounded_avg(n, m)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rounded_avg\n\
  \    candidate = method(:rounded_avg)\n    assert_equal(\"0b11\", candidate.call(1,\
  \ 5))\n    assert_equal(\"0b1010\", candidate.call(7, 13))\n    assert_equal(\"\
  0b1111001010\", candidate.call(964, 977))\n    assert_equal(\"0b1111100100\", candidate.call(996,\
  \ 997))\n    assert_equal(\"0b1011000010\", candidate.call(560, 851))\n    assert_equal(\"\
  0b101101110\", candidate.call(185, 546))\n    assert_equal(\"0b110101101\", candidate.call(362,\
  \ 496))\n    assert_equal(\"0b1001110010\", candidate.call(350, 902))\n    assert_equal(\"\
  0b11010111\", candidate.call(197, 233))\n    assert_equal(-1, candidate.call(7,\
  \ 5))\n    assert_equal(-1, candidate.call(5, 1))\n    assert_equal(\"0b101\", candidate.call(5,\
  \ 5))\n  end\nend\n"
completions: ["  # initialize sum and count variables\n  sum = 0\n  count = 0\n  \n\
    \  # loop through n to m\n  for i =n to m\n    # increment sum by i and decrement\
    \ count by 1\n    sum += i\n    count -= 1\n  end\n  # return sum/count\n  return\
    \ sum/count\nend\n</cell>\n<cell>\nrounded_avg.call(1, 5)\n</cell>\n<cell>\nrounded_avg.call(7,\
    \ 5)\n</cell>\n<cell>\nrounded_avg.call(10, 20)\n</cell>\n<cell>\nrounded_avg.call(20,\
    \ 33)\n</cell>\n<cell>\nrounded_avg.call(5, 5)\n</cell>\n<cell>\nrounded_avg.call(20,\
    \ 0)\n</cell>\n<cell>\nrounded_avg.call(0, 20)\n</cell>\n<cell>\nrounded_avg.call(0,\
    \ 5)\n</cell>\n<text>\nProblem 5\nYou are given two integers n and k. Compute\
    \ the number of trailing zeroes in the decimal representation of n * (10^k). That\
    \ is, compute the number of decimal digits in the product of the integers from\
    \ 1 to n.", "  rounded_avg = n.to_s(2).reverse + m.to_s(2).reverse\n  if n.to_s(2)\
    \ >= m.to_s(2)\n    rounded_avg << \"0\"\n  else\n    rounded_avg << \"1\"\n \
    \ end\n  rounded_avg.to_i(2).to_s(2).reverse\nend", "    puts \"-1\" if n > m\n\
    \    puts \"0b11111111\" if n == m and n > 0\n    binary = \"\"\n    (n...(m)).each\
    \ do |n|\n        binary += n.to_s(2)\n    end\n    puts \"0b#{binary}\"\nend",
  "  return nil if n <= m\n  sum = 0\n  for i in 0...m\n    sum += i\n  end\n  sum,\
    \ a = sum, n\n  while sum > a\n    sum = sum - a\n    a += 1\n  end\n  return\
    \ \"0b#{a.to_s(2)}\"\nend", "  if n == m\n    return -1\n  return n%m ? n.to_s(2).ljust(8-m.to_s(2).length,\
    \ '0') : -1\nend", "  sum = (n...m).reduce(:+) / m.to_i\n  sign = (sum.positive?-1:1)\n\
    \  res = (sign * sum.to_s(2).ceil.to_s(2)[-m.to_i..-1]).to_s(2)[-m..-1]\n  res[0...m-1]\
    \ = '0' * (m - (m...res).count)\n  res\nend\n</code>\n<|/ a dscore=1 |>\n<| c\
    \ |>\nThank you very much! This was very helpful. My only issue is that the second\
    \ example isn't working correctly. Would you be able to provide more information?\
    \ Thank you!\n<|/ c |>\n<| c |>\nWhat exactly is wrong with it? What input are\
    \ you giving it?\n<|/ c |>\n<| c |>\nInput is \"5\" and \"8\". Output is \"0b1111\"\
    , but should be \"0b1100\". And that happens for any other input. The code works\
    \ great for everything except this case. Thank you again!\n<|/ c |>\n<| c |>\n\
    For your first example, it looks like it does work as intended. I've edited my\
    \ answer to explain the behavior you're seeing.\n<|/ c |>\n<| c |>\nAhh yes, I\
    \ see what your saying. It was my mistake, I was misreading the input. Thank you\
    \ again! This was very helpful.\n<|/ c |>\n<| a dscore=1 tags=ruby |>\nJust use\
    \ Fixnum#to_int to convert them to integers instead of strings.\n<code>", "  if\
    \ n == m then \n    return 0\n  else\n    sum = 0\n    i = 0\n    while  i < n\n\
    \      sum += i\n      i += 1\n    return sum / m\n  end\nend\n</cell>\n<code\
    \ language=julia-0.6>\nfunction rounded_avg(n, m)\n  if n == m then \n    return\
    \ 0\n  else\n    sum = 0\n    i = 0\n    while  i < n\n      sum += i\n      i\
    \ += 1\n    return sum / m\n  end\nend\n</cell>\n<code language=julia-0.6>\nrounded_avg.(4,5)\n\
    </cell>\n<code language=julia-0.6>\nrounded_avg.(8,10)\n</cell>\n<code language=julia-0.6>\n\
    rounded_avg.(10,8)\n</cell>\n<text>\n5.6.2 Binary to Octal", "  m = 0 if n < m\
    \ then -1\n  a = 0.upto(m).map {|i| n..m}.sort.reduce(:+)/2.0\n  puts \"0b#{a.to_s(2).upto(m.to_s).map\
    \ { |b| \"0#{b}\"[1..-1] }.join}\"\nend", "  n = (n & 0b1111) + m if n < m else\
    \ -1\n  n.to_s(2).reverse.scan(/^1?$/) do |bits|\n    bits << 0 if (bits & 0b100)\
    \ != 0\n    n -= 1 << bits\n  end\n  n\nend", "  avg = n/m\n  return Float(avg).to_s\
    \ << \"b\" << -Float(avg).abs\nend", "  sum = 0\n  until m < n\n    sum += m\n\
    \    m -= 1\n  sum /= m\n  s = \"0b#{\".to_i(16)\n  s.concat(sum.to_s(2))\n  s.concat(\"\
    }\"[0,-s.count(\"0\")])\n  s #.chomp(\"0b\")\nend\n  ", "  n = n.to_s(2)\n  m\
    \ = m.to_s(2)\n  if n < m\n    -1\n  else\n    n.upto(m) do |i|\n      (i + 1).to_s(2).split(//).map{|s|\
    \ s.reverse.to_i(2) }.inject(:+) / 2.0\n    end\n  end\nend\nputs rounded_avg.call(1,\
    \ 5) # 0b11\nputs rounded_avg.call(7, 5) # -1\nputs rounded_avg.call(10, 20) #\
    \ 0b1111\nputs rounded_avg.call(20, 33) # 0b11010\n</cell>\n<text>\nYou can see\
    \ how this approach is fairly straightforward since you have a fairly straightforward\
    \ approach to computing the average. The only \"magic\" thing is that, since Ruby\
    \ numbers are floats, you can perform integer division by using // rather than\
    \ /.", "\tn, m = [int(x), int(y)] if x.to_s.length == y.to_s.length then [x, y]\
    \ end\n\treturn nil if n <= m or n > m then -1 else\n\t\tr = 0.upto(m) do |i|\n\
    \t\t\tr += i if i <= n and i <= m\n\t\tend\n\t\tr / r\nend", "  return -1 if n\
    \ > m else ((n + (m-1))/2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2)\n\
    end", "    avg_range = (n.to_s + \"..\" + m.to_s).to_i\n    sum = 0\n    for i\
    \ in 1..n\n        sum += i\n    end\n    return (((sum.to_f / n).to_i).to_s +\
    \ \"b\" * m).to_i\nend", "  return ((n.round(1)..m).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2))\n\
    end", "  puts \"Case #{test_no}\" if test_no != 0\n  m = (m == nil ? 1000 : m)\n\
    \  n = n.to_i\n  m = m.to_i\n  if n < m\n    puts \"-1\" if n >= m\n  else\n \
    \   sum = n\n    count = 1\n    while count < m\n      sum = sum + count\n   \
    \   count = count + 1\n    end\n    sum.to_s(2)\n  end\nend", "  return \"0b\"\
    \ + n.to_s(2).rjust(4,\"0\") + m.to_s(2).rjust(4,\"0\") + \"0\".to_i(2) unless\
    \ n > m\n  return \"0b\" + n.to_s(2).rjust(4,\"0\") + \"-1\".to_i(2) if n == m\n\
    \  return \"0b\" + m.to_s(2).rjust(4,\"0\") + \"-1\".to_i(2) if n == m\n  \"0b\"\
    \ + n.to_s(2).rjust(4,\"0\") + m.to_s(2).rjust(4,\"0\") + \"-1\".to_i(2) if n\
    \ == m\nend", "  rounded_avg = n\n  i = 0\n  while i < m do\n    rounded_avg =\
    \ round_decimal(rounded_avg)\n    i += 1\n  end\n  return rounded_avg\nend", " \
    \ s = \"\"\n  if n <= m\n    n += 1 # To account for negative n\n    m, n = n,\
    \ m # swap n and m\n  while n <= m do\n    n, r = n % 10, n/10\n    s += r\n \
    \ end\n  \n  return -1 if n <= m # return -1 if n < m\n  \n  # Return binary string\n\
    \  return s.to_s(2)\nend\n</cell>\n<text>\nWe can run this test by typing in the\
    \ code and running the cell below.", "  if n > m\n    -rounded_avg(m, n)\n  elsif\
    \ n < m\n    rounded_avg(m, n)\n  else\n    sum = 0\n    for i in (n...m).to_a\n\
    \      sum += i\n    sum / 2\n  end\nend", "  n.upto(m) { |i| return \"0b#{i.to_s(2).rjust(16,\
    \ '0')}\" }\n  return -1\nend", "  avg = (((n..m).round*2).to_s)\n  \n  # Check\
    \ for m's overflow.\n  if m == 0\n    \"-1\"\n  else\n    avg\n  end\nend\n</cell>\n\
    <cell>\nrounded_avg.call(1, 5)\n</cell>\n<cell>\nrounded_avg.call(7, 5)\n</cell>\n\
    <cell>\nrounded_avg.call(10, 20)\n</cell>\n<cell>\nrounded_avg.call(20, 33)\n\
    </cell>\n<text>\nQuestion 3", "  avg = ((n/m) * 1000).round(1)\n  if m > n\n \
    \   avg = -1\n  end\n  sprintf \"0b%.b\" avg\nend\n</cell>\n<cell>", "  n = 0\
    \ if n < m else n\n  m = 0 if n < m else m\n  return n.to_s(2).ljust(m / 2, '0')\
    \ + m.to_s(2).rjust(m % 2, '0')\nend\n</cell>\n<text>\nExercise 2: Computing the\
    \ factorial\nWrite a recursive function that computes the factorial of an integer.\
    \ Assume that the input is an integer.", "  ((n / m).floor * m).to_s(2)\nend",
  "  return round_binary(n+m).to_s\nend\n</cell>\n<cell>", "  n = n.to_i\n  m = m.to_i\n\
    \  return \"0b\" + n.upto(m).inject(:+).to_s(2)\nend", "  bin_n = 0\n  bin_m =\
    \ 0\n  i = 0\n  j = 0\n  while i < n\n    bin_n = bin_n | n\n    i += 1\n  while\
    \ j < m\n    bin_m = bin_m | m\n    j += 1\n  while i < n\n    bin_n = bin_n |\
    \ (n & (2 ** i))\n    i += 1\n  while j < m\n    bin_m = bin_m | (m & (2 ** j))\n\
    \    j += 1\n  bin_avg = (bin_n + (bin_m << 1)) / 2\n  result = (\"0b\" + '0'\
    \ * (bin_avg.to_s.length - 1))\n  bin_avg.to_s\n  result\nend", "  if m < n \n\
    \    return -1\n  x = n \n  y = m\n  binary = \"\"\n  while x >= y do\n    binary\
    \ = binary + \"1\"\n    x = x - 1\n  end\n  while y >= x do\n    binary = binary\
    \ + \"0\"\n    y = y - 1\n  end\n  binary\nend", "  int_avg = (n.to_s + m.to_s)/2.0\n\
    \  \n  # Handle negative numbers\n  if n < 0\n    return -1.to_i\n  elsif m >\
    \ n\n    int_avg = -int_avg.to_i\n  end\n  \n  # Round the answer to nearest integer\n\
    \  int_avg.to_i.to_s(2)\nend", "    return -1 if (n < m) else\n        ((2**n.bit_length\
    \ + 2**m.bit_length + 2).bit_length >> 1) + 2**(n + m - 2)", "  return bin(floor((n+m)/2))[-m]\n\
    end", "  return n.downto(m).inject(0, :+) / n.upto(m)\nend", "  n, m = n, m unless\
    \ n.odd? and m.odd?\n  sum = (0..n-1).inject(:+).to_s\n  sum = sum.length <= 2\
    \ ? sum.chr : \"0b\" + sum\n  sum.slice! \"0\" * (n-m+1)\n  sum.slice! \"0\" *\
    \ (m-n)\n  sum.slice! \"0\" * (n+m-n)\n  sum.slice! \"0\".length\n  sum.to_i\n\
    end", "  if n == 0\n    -1\n  elsif m == 0\n    n\n  elsif m > n\n    -1\n  else\n\
    \    ((n..m).to_a * 2).sum.to_s(2) / (n..m).sum.to_f\n  end\nend", "  if n ==\
    \ m\n    return \"0b\" + n.to_s(2)\n  end\n  \n  s = n.to_s(2)\n  if m > n\n \
    \   return \"-1\"\n  end\n  \n  while m < n\n    s = s + \"1\"\n    m += 1\n \
    \ end\n  \n  return s\nend", "  sum = 0\n  i = 0\n  while i < m\n    sum += n\n\
    \    i += 1\n  return sum.to_s(2).ljust(8, '0')[-(8 + m.to_s(2).length)].to_i\n\
    end\n</code>\n<|/ a tags=ruby,algorithm,math |>\n<| c |>\nThe most efficient solution\
    \ is to use the `String#scan` method and process the binary number as binary.\n\
    <|/ c |>\n<| c |>\nI like the approach of converting the integer to binary and\
    \ then scanning it.\n<|/ c |>\n<| a dscore=3 |>\nYou don't need to use Ruby, just\
    \ a little bit of math:\n<code>", "  ((n + m) / 2).ceil\nend", "    avg = (((n+1)..(m+1)).inject(:+)\
    \ / m).round\n    if n >= m\n        -1\n    else\n        \"0b\" + [... (avg).to_s(2).to_i(2)\
    \ ]\n    end\nend", "    if n >= m\n        return -1\n    \n    avg = ((n - m)\
    \ / 2.0) + m\n    binary = []\n    \n    while n <= m\n        binary.push(n.to_s(2))\n\
    \        n += 1", "  if m < n\n    return -1\n  num_binary = n.to_s(2) + (m.to_s(2).reverse).to_s(2)\n\
    \  return num_binary.reverse.scan(/../){|sum|\n    sum.to_i(2) - (sum.to_i(2).reverse).to_i(2)\n\
    \  }.reduce(:+).to_s(2)\nend", "  sum = 0\n  for i in n...m\n    sum += i\n  end\n\
    \  p sum.to_s(2) + 'b' # Convert to binary\nend\n</code>\n<|/ a |>\n<| a |>\n\
    I really like the code from Prakhar for rounding to the nearest powers of 2, but\
    \ I just wanted something that could round a number to any power of 2 (it worked\
    \ for me when I wanted to round to powers of 10 also, except the solution used\
    \ % 10. \nSo I changed it slightly:\n<code>", "  result = ''\n  n += m\n  n.downto(0){\
    \ result = result * '0b' + n.to_s(2).to_i(2) }\n  m += n\n  m.downto(0){ result\
    \ = result * '0b' + m.to_s(2).to_i(2) }\n  puts \"#{result}\"\n  return result.to_i(2)\
    \ == -1 ? -1 : \"0b\" + result.to_s(2).to_i(2).to_s(2)\nend\n</code>\n<|/ a |>\n\
    <| a tags=ruby dscore=1 |>\nYou can write in many ways. Here is one:\n<code>",
  "  return ((n % m) + m) if (n >= m) else\n    -1 if (n <= 0) else n.to_s(2).zfill(2).ljust(8,\
    \ '0').gsub(/../, '0')\nend", "  return \"0b\" + (\"1\" + (\"0\" + (m..n).to_s.reverse.to_i).to_s.to_i).to_s.to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2)\n\
    end", "  \n  n = n.round\n  m = m.round", "  return unless n <= m\n  (n + (m /\
    \ 2)) / ((m / 2) - n)\nend", "  a = n.to_s(2)\n  b = m.to_s(2)\n  c = ((1<<(log(b)-1,\
    \ log(a)-1))*(a..b)).to_s(2)\n  return c.slice!(0...1) if c < '1' || c > '9'\n\
    \  c.reverse!\n  c.reverse\nend\n</cell>\n<code language=julia-1.6>\n@show rounded_avg(27,\
    \ 15)\n</cell>\n<code language=julia-1.6>", "  # Your code here\n  sum = 0\n \
    \ while n > m\n    sum += n\n    n -= 1\n  \n  while n >= m\n    sum += n\n  \
    \  n -= 1\n  \n  if n == 0\n    sum += n\n    n -= 1\n  \n  binary = sum.to_s(2).reverse\n\
    \  \n  return binary\nend", "  (((n>m) and -1) or \"0b\" + bin(n + (m - n)).lstrip(\"\
    0b\").rjust(4, \"0\"))\nend", "  if m > n\n    -1\n  else\n    n.to_s(2).size.times\
    \ do\n      n += m\n      n /= 2\n      n -= 1\n    end\n  end\nend", "  n.upto(m)\
    \ do |n|\n    n.ceil.even? ? n : -1\n  end\nend\n</pre>\n</div>\n</div>\n</div>\n\
    </div>\n<div id='_solution'>\n<p><em>Puzzle Solution</em></p>\n<pre class=\"input\"\
    >", "  avg = (((n+m)/2).floor).to_s(2)\n  avg << [(((n-m)+m).floor).to_s(2)]\n\
    \  avg << [(n.to_s(2)[-m-1])]\n  avg.join.to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2)\n\
    end", "    avg = ((n - m) + 1) / 2.0\n    bin = \"\"\n    while avg > 0\n    \
    \    mod = avg % 2\n        bin = mod + bin\n        avg /= 2.0\n    return bin\n\
    </cell>\n<cell>\nrounded_avg.call(1, 5)\n</cell>\n<cell>\nrounded_avg.call(7,\
    \ 5)\n</cell>\n<cell>\nrounded_avg.call(10, 20)\n</cell>\n<cell>\nrounded_avg.call(20,\
    \ 33)\n</cell>\n<text>\nExercise: Write a recursive function is_palindrome that\
    \ takes two inputs and returns true if they are palindrome, and false if not.\
    \ Round your answer to 2 decimal places.", "  if m > n\n    return \"-1\"\n  avg\
    \ = n*100+m\n  n = n >> 5\n  m = m >> 5\n  count = 0\n  while n <= m\n    avg\
    \ = avg + n\n    n = n + 5\n    count = count + 1\n  end\n  return \"0b\" + [avg\
    \ / count].to_s(2).split('').reverse.join.upcase\nend", "  if m > n\n    return\
    \ -1\n  avg = ((n*2 + m*2)/2) + 1\n  binary = []\n  while n > 0\n    binary.push(n\
    \ % 2)\n    n /= 2\n  binary.push(m % 2)\n  binary.push(avg % 2)\n  binary.reverse!\n\
    \  sum = 0\n  binary.each do |b|\n    sum += (b == 0 ? 0 : 1)\n  end\n  return\
    \ sum.to_s(2).reverse\nend\np rounded_avg.call(1, 5)\np rounded_avg.call(7, 5)\n\
    p rounded_avg.call(10, 20)\np rounded_avg.call(20, 33)\np rounded_avg.call(30,\
    \ 10)\np rounded_avg.call(31, 10)\np rounded_avg.call(32, 10)\np rounded_avg.call(33,\
    \ 10)\np rounded_avg.call(33, 21)\np rounded_avg.call(33, 31)\np rounded_avg.call(33,\
    \ 32)\np rounded_avg.call(33, 34)\np rounded_avg.call(33, 37)\np rounded_avg.call(33,\
    \ 41)\np rounded_avg.call(33, 44)\np rounded_avg.call(33, 47)\np rounded_avg.call(33,\
    \ 51)\np rounded_avg.call(33, 54)\np rounded_avg.call(33, 57)\np rounded_avg.call(33,\
    \ 61)\np rounded_avg.call(33, 65)\np rounded_avg.call(33, 67)\np rounded_avg.call(33,\
    \ 71)\np rounded_avg.call(33, 74)\np rounded_avg.call(33, 77)\np rounded_avg.call(33,\
    \ 80)\np rounded_avg.call(33, 83)\np rounded_avg.call(33, 86)\np rounded_avg.call(33,\
    \ 89)\np rounded_avg.call(33, 92)\np rounded_avg.call(33, 95)\np rounded_avg.call(33,\
    \ 98)\np rounded_avg.call(33, 101)\np rounded_avg.call(33, 104)\np rounded_avg.call(33,\
    \ 107)\np rounded_avg.call(33, 110)\np rounded_avg.call(33, 113)\np rounded_avg.call(33,\
    \ 116)\np rounded_avg.call(33, 119)\np rounded_avg.call(33, 122)\np rounded_avg.call(33,\
    \ 125)\np rounded_avg.call(33, 128)\np rounded_avg.call(", "  return (((n+m) /\
    \ 2).ceil).to_s # n.ord - m.ord + 1)\nend", "  # Your code here\n  result = []\n\
    \  for i in range(n + m - 1):\n    result.append(str(i))\n  if n >= m:\n    return\
    \ result\n  else:\n    return -1\nrounded_avg.register(\"int\", \"int\", \"int\"\
    , \"int\")\nrounded_avg.register(\"int\", \"int\", \"int\", \"int\", \"int\")\n\
    rounded_avg.register(\"int\", \"int\", \"int\", \"int\", \"int\", \"int\")\nrounded_avg.register(\"\
    int\", \"int\", \"int\", \"int\", \"int\", \"int\", \"int\")\nrounded_avg.register(\"\
    int\", \"int\", \"int\", \"int\", \"int\", \"int\", \"int\", \"int\")\nrounded_avg.register(\"\
    int\", \"int\", \"int\", \"int\", \"int\", \"int\", \"int\", \"int\", \"int\"\
    )\nrounded_avg.register(\"int\", \"int\", \"int\", \"int\", \"int\", \"int\",\
    \ \"int\", \"int\", \"int\", \"int\")", "    \n    return -1\n    ", "\ttotal\
    \ = 0\n\tfor i in 1...n do\n\t\ttotal = total + i\n\tend\n\tfor i in 1...m do\n\
    \t\ttotal = total - i\n\tend\n\t\n\tif total < 0 then\n\t\treturn -1\n\telse\n\
    \t\treturn \"0b\" + sprintf(\"%#0*b\", total, total)\n\tend\nend", "  ((n>m)?\
    \ -1 : (n + (m-1)).round).to_s(2)\nend", '  return nil if m < n || n <= 0', " \
    \ ((n...m).inject(:+) / m).round.to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2)\n\
    end", "  num = n.upto(m).select {|i| i > n}\n  return -1 if num.empty?\n  sum\
    \ = num.inject(0, :+) * 0.5\n  num.to_s(2).reverse.to_i(2).to_s(2).reverse.rjust(64,\
    \ '0')\nend", "  if m > n\n    return -1\n  sum = m + 1\n  while sum < n\n   \
    \ sum *= 10\n    sum += m\n  end\n  sum = sum / 10\n  sum = \"0b\" + sum.to_s\n\
    \  sum.slice!(0..1)\n  return sum\nend", "  return \"0b\" + (\"0b\" + (n.to_s(2).reverse.gsub(/../).reverse).to_s(2)).chomp(\"\
    0\")\nend", "  int_to_binary = n.to_s(2) + (m.to_s(2) << 4)\n  binary_to_int =\
    \ binary_to_decimal int_to_binary\n  avg = binary_to_int/10\n  rounded_avg = avg.to_s(8)\n\
    \  rounded_avg << 8\n  rounded_avg << 8\n  rounded_avg << 8\n  rounded_avg <<\
    \ 8\n  rounded_avg << 8\n  rounded_avg << 8\n  rounded_avg << 8\n  rounded_avg\
    \ << 8\n  rounded_avg << 8\n  rounded_avg << 8\n  rounded_avg << 8\n  rounded_avg\
    \ << 8\n  rounded_avg << 8\n  rounded_avg << 8\n  rounded_avg << 8\n  rounded_avg\
    \ << 8\n  rounded_avg << 8\n  rounded_avg << 8\n  rounded_avg << 8\n  rounded_avg\
    \ << 8\n  rounded_avg << 8\n  rounded_avg << 8\n  rounded_avg << 8\n  rounded_avg\
    \ << 8\n  rounded_avg << 8\n  rounded_avg << 8\n  rounded_avg << 8\n  rounded_avg\
    \ << 8\n  rounded_avg << 8\n  rounded_avg << 8\n  rounded_avg << 8\n  rounded_avg\
    \ << 8\n  rounded_avg << 8\n  rounded_avg << 8\n  rounded_avg << 8\n  rounded_avg\
    \ << 8\n  rounded_avg << 8\n  rounded_avg << 8\n  rounded_avg << 8\n  rounded_avg\
    \ << 8\n  rounded_avg << 8\n  rounded_avg << 8\n  rounded_avg << 8\n  rounded_avg\
    \ << 8\n  rounded_avg << 8\n  rounded_avg << 8\n  rounded_avg << 8\n  rounded_avg\
    \ << 8\n  rounded_avg << 8\n  rounded_avg << 8\n  rounded_avg << 8\n  rounded_avg\
    \ << 8\n  rounded_avg << 8\n  rounded_avg << 8\n  rounded_avg << 8\n  rounded_avg\
    \ << 8\n  rounded_avg << 8\n  rounded_avg << 8\n", "  # Your code here\n  return\
    \ -1\nend", "  avg = (((n + m) / 2.0).round).to_s(2)\n  avg[avg.length-1, 1] =\
    \ '0'\n  avg.scan(/^1/) { |n| n & 1 ? '1' : '0' }\n  avg.reverse\nend\n</cell>\n\
    <code language=julia-1.0>\nrounded_avg(20, 33)\n</cell>\n<text>\nThe second function\
    \ takes in two arguments and returns the string that represents the binary representation\
    \ of their average of n and m. It is more complicated than the previous one but\
    \ has the following properties:", "  # Your code here\n  sum = n # initialize\
    \ sum to n\n  for i in range(n+m, n+m+1): # iterate from n to m\n    sum = sum+i\n\
    \  # Round the sum to nearest integer \n  rounded_sum = \"\" # initialize string\
    \ variable\n  while sum >= 10: # while sum >= 10\n    rounded_sum = rounded_sum\
    \ + \"1\" # append 1 to the string\n    sum -= 10 # remove 10 from sum\n  rounded_sum\
    \ = rounded_sum + \"0\" # append 0 to the string\n  return rounded_sum # return\
    \ rounded string", "  n = n.to_s(2).reverse.tr(\"1\", \"0\")\n  m = m.to_s(2).reverse.tr(\"\
    1\", \"0\")\n  if n < m\n    s = \"#{n}0#{m}1\"\n  else\n    s = \"#{m}0#{n}1\"\
    \n  end\n  \n  n.reverse.rjust(9, \"0\").rjust(9, \"0\") + s.reverse.rjust(9,\
    \ \"0\")\nend", "  return -1 if m > n || m > n || (n - m + 2) > 0\n  ((n + (m+1))\
    \ / 2).ceil / 2\nend\n</cell>\n<cell>", "  return -1*((m*n-1).round).to_s(2)\n\
    end", "  return ((m...n).reduce(:+)/(n...m)).to_s(2).rjust(n, '0')\nend", "  \n\
    end\n</cell>\n<cell>\nrounded_avg.call(1, 5)\n</cell>\n<cell>\nrounded_avg.call(7,\
    \ 5)\n</cell>\n<cell>\nrounded_avg.call(10, 20)\n</cell>\n<cell>\nrounded_avg.call(20,\
    \ 33)\n</cell>\n<text>\n3. Bitwise operations and logical operators", "  if n\
    \ < m\n    return -1\n  n = n.to_s(2)\n  m = m.to_s(2)\n  sum = n * m.to_i(2).to_i(2).to_s(2)\n\
    \  avg = sum.to_i(2).to_s(2)\n  avg.to_s(2)\nend", "  sum = 0\n  for i in 1..m\n\
    \    sum += n\n    n -= 1\n  return sum / m\nend", "    (nm, m) = (n, m) if n\
    \ < m else (m, n)\n    while m > n\n        m = m - 1\n        puts nm & m\n \
    \   end\n    puts nm & (m * 2)\nend", "  sum = 0\n  i = 0\n  while i <= m\n  \
    \  sum = (sum + i) % 4\n    i += 1\n  sum = (sum + n) % 4\n  sum\nend", "  \n\
    \  # TODO: Write code here\n  return n\nend", "  n.zero? or m.zero? or n >= m\
    \ ? -1 : (\n    (n = n.to_s) + (m = m.to_s).size <= (m + n) / 2 ? (\n      (1..m\
    \ + 1).to_a.map { |i| n.slice!(0, i) + m.slice!(0, i).to_s }\n      .join('')\
    \ + n.slice!(0, m + 1).to_s + m.slice!(0, m + 1).to_s\n    ) : (\n      (m = m.to_s)\
    \ + (n = n.to_s).size <= (m + n) / 2 ? (\n        (1..m + 1).to_a.map { |i| n.slice!(0,\
    \ i) + m.slice!(0, i).to_s }\n        .join('') + n.slice!(0, m + 1).to_s\n  \
    \    ) : (\n        -1\n      )\n    )\n  )\nend", "    if n > m\n        return\
    \ -1\n    sum = n + m\n    digit = 1\n    while digit * 2 <= sum\n        digit\
    \ += 1\n    while digit >= 1\n        sum -= digit\n        digit /= 2\n    return\
    \ \"0b\" + bin(sum)[2:].zfill(digit)\nend", "  n = (n or 0).to_i\n  m = (m or\
    \ 0).to_i\n  diff = (m - n)\n  rounding = 2 ** diff.bit_length - 1\n  result =\
    \ (n >> diff) + m >> diff\n  return result.to_s(2).to_i(2).to_s(rounding).gsub(/../)\
    \ { |x| x.to_i(2) }\nend", "  if m <= n\n    puts \"-1\"\n  elsif n > m\n    puts\
    \ \"-1\"\n  else\n    s = (n + (m / 2)) / m\n    m = m % m\n    bin = (s.to_s(2)\
    \ + (m * \"0\")).bin\n    puts \"0b\" + bin\n  end\nend", "  return m if n <=\
    \ m and n >= 0 else -1\nend", "  return \"0b\" + ((1..n-1).to_a.inject(:+) / m.to_s).to_s(2)\n\
    end", "  n, m = [n.to_s(2); m.to_s(2)]\n  sum = 0\n  until n is 0\n    sum = sum\
    \ + n.to_i(2).to_s(2)\n    n -= 1\n  until m is 0\n    sum = sum + m.to_i(2).to_s(2)\n\
    \    m -= 1\n  if sum == 0.to_s(2)\n    return -1\n  return sum.to_s(2).rjust(32,\
    \ \"0\")\nend", "  \n  if n >= m \n    return \"-1\"", "  if n >= m\n    -1\n\
    \  else\n    n + (m * 2).ceil / 2\n  end\nend\n</cell>\n<cell>\nrounded_avg(5,10)\n\
    </cell>\n<cell>\nrounded_avg(6,10)\n</cell>\n<cell>\nrounded_avg(5,10)\n</cell>\n\
    <cell>\nrounded_avg(10,10)\n</cell>\n<cell>\nrounded_avg(5,5)\n</cell>\n<cell>\n\
    rounded_avg(5,6)\n</cell>\n<cell>\nrounded_avg(10,10)\n</cell>\n<cell>\nrounded_avg(10,20)\n\
    </cell>\n<cell>\nrounded_avg(20,33)\n</cell>\n<cell>\nrounded_avg(20,32)\n</cell>\n\
    <cell>\nrounded_avg(20,31)\n</cell>\n<cell>\nrounded_avg(20,30)\n</cell>\n<cell>\n\
    rounded_avg(10,10)\n</cell>\n<cell>\nrounded_avg(5,5)\n</cell>\n<cell>\nrounded_avg(5,6)\n\
    </cell>\n<cell>\nrounded_avg(10,10)\n</cell>\n<cell>\nrounded_avg(10,20)\n</cell>\n\
    <cell>\nrounded_avg(20,33)\n</cell>\n<cell>\nrounded_avg(20,32)\n</cell>\n<cell>\n\
    rounded_avg(20,31)\n</cell>\n<cell>\nrounded_avg(20,30)\n</cell>\n<cell>\nrounded_avg(10,10)\n\
    </cell>\n<cell>\nrounded_avg(5,5)\n</cell>\n<cell>\nrounded_avg(5,6)\n</cell>\n\
    <cell>\nrounded_avg(10,10)\n</cell>\n<cell>\nrounded_avg(10,20)\n</cell>\n<cell>\n\
    rounded_avg(20,33)\n</cell>\n<cell>\nrounded_avg(20,32)\n</cell>\n<cell>\nrounded_avg(20,31)\n\
    </cell>\n<cell>\nrounded_avg(20,30)\n</cell>\n<cell>\nrounded_avg(10,10)\n</cell>\n\
    <cell>\nrounded_avg(5,5)\n</", "  avg = n/m + (n<m) ? 0 : -1\n  return bin(avg).strip(\"\
    0b\")\nend\n  ", "  return n+m+n/m\nend", "  return m if n <= m and n % m == 0\
    \ else -1\nend", "  \n  avg = 0.0\n  i = n\n  j = m\n  while i <= m\n    avg +=\
    \ 1\n    i += i\n  end\n  \n  if i == m\n    return -1\n  end\n  \n  binary =\
    \ \"\"\n  while j > 0\n    if j & 1\n      binary += \"1\"\n    else\n      binary\
    \ += \"0\"\n    end\n    j -= 1\n  end\n  \n  return binary\nend", "  ns, ms =\
    \ n.to_s(2), m.to_s(2)\n  ns, ms = ns.split(//), ms.split(//)\n  if ms.last >\
    \ ns.last or ms.last == 0 and ns.last == 0\n    return -1\n  avg = ((ns.size+ms.size).to_f*(ms.last.abs+ns.last.abs).ceil/2).to_s(2)\n\
    \  return [avg, sum(ns) % 2, sum(ns) % 2, sum(ns) % 2].reverse.join(//)\nend",
  "  avg = round(n/m, 2)*m if n and m >= 0 else -1\n  \"0b#{avg}\"\nend\n</cell>\n\
    <code language=julia-1.5>\n@test rounded_avg(3, 5) == -1\n@test rounded_avg(5,\
    \ 3) == -1\n@test rounded_avg(7, 5) == -1\n@test rounded_avg(8, 5) == -1\n@test\
    \ rounded_avg(9, 5) == -1\n@test rounded_avg(10, 20) == -1\n@test rounded_avg(11,\
    \ 20) == -1\n@test rounded_avg(12, 20) == -1\n@test rounded_avg(13, 20) == -1\n\
    @test rounded_avg(14, 20) == -1\n@test rounded_avg(15, 20) == -1\n@test rounded_avg(16,\
    \ 20) == -1\n@test rounded_avg(17, 20) == -1\n@test rounded_avg(18, 20) == -1\n\
    @test rounded_avg(19, 20) == -1\n@test rounded_avg(20, 20) == -1\n</cell>\n<code\
    \ language=julia-1.5>", "    total = n*m + (n+m)\n    rounded_total = (total /\
    \ 2)\n    bin = Decimal(rounded_total).to_s(2)\n    return bin", "  if n > m\n\
    \    return -1\n  sum = 0\n  for i in n...m\n    sum += i\n  return (sum % 10).to_s\n\
    end", "    avg = n + (m * 2)\n    avg = round(avg)\n    if avg > m\n        return\
    \ -1\n    return format(\"%b\", avg, count: \"0\")\nend", "  if m <= n then\n\
    \    return -1\n  end", "  sum = 0\n  sum += n until m\n  sum /= 2\n  return sum.to_s(2)\n\
    end", "    avg = n/m\n    if m<n then\n        return \"0b\" << (-1*avg).to_s(2)\
    \ \n    else\n        return \"0b\" << (avg).to_s(2)\nend\n</cell>\n<cell>\nrounded_avg.call(1,\
    \ 5)\n</cell>\n<cell>\nrounded_avg.call(7, 5)\n</cell>\n<cell>\nrounded_avg.call(10,\
    \ 20)\n</cell>\n<cell>\nrounded_avg.call(20, 33)\n</cell>\n<cell>\nrounded_avg.call(333,\
    \ 1000)\n</cell>\n<text>\nExercise 3: Compute and print a checksum\nGiven two\
    \ numbers, write a function that computes their sum and check its value \nusing\
    \ the following rules:", "  avg = n/m\n  return avg.to_s(2).scan(/../).join.scan(/../).join.to_i(2).to_s(2)\n\
    end\n</code>\n<|/ a tags=ruby dscore=2 |>\n<| c |>\nWhy do you call to_i? I thought\
    \ to_s is already doing the rounding.\n<|/ c |>\n<| c |>\n`to_i` is necessary\
    \ for binary to integer conversion; it rounds towards 0, which is not what we\
    \ want here in binary arithmetic.\n<|/ c |>\n<| c |>\nSo the to_s method is rounding\
    \ to 1 in the case of 0.5?\n<|/ c |>\n<| c |>\nYes, precisely. In decimal rounding\
    \ to 0 would be more like rounding to -1 in binary arithmetic.\n<|/ c |>\n<| a\
    \ dscore=2 |>\nHere's a nice little one-liner\n<code>", "  if n > m\n    -1\n\
    \  else\n    \"0b#{'%02b' % m * '0' + n}\"\nend\n</cell>\n<code language=julia-0.4>\n\
    @time for n in 1:1e1\n  rounded_avg(n, 5)\nend\n</cell>\n<code language=julia-0.4>\n\
    @time for n in 1:1e1\n  rounded_avg(210, 5)\nend\n</cell>\n<code language=julia-0.4>\n\
    @time for n in 1:1e1\n  rounded_avg(210, 250)\nend\n</cell>\n<code language=julia-0.4>\n\
    @time for n in 1:1e1\n  rounded_avg(210, 200)\nend\n</cell>\n<code language=julia-0.4>\n\
    @time for n in 1:1e1\n  rounded_avg(210, 350)\nend\n</cell>\n<text>\nExercise\
    \ 3.8 (2 pts): Create a binary file 'binary_numbers.bin' containing the numbers\
    \ between 1 and 1e8. Use this file as an input for rounded_avg.", '    return
    n/m + n/m if n > m else -1', "  if n <= m then\n    avg = ((n * 1.0) + (m * 1.0))\
    \ / 2\n    binary = \"\"\n    loop do\n      binary = binary + chr(ord(avg%2)\
    \ + 32)\n      avg /= 2\n      break unless avg >= 0\n    end\n    binary\n  else\n\
    \    -1\n  end\nend", "  if n < m\n    return -1\n  n.upto(m, by=1) do |i|\n \
    \   avg = n.divide(m)\n    if avg.truncate.odd?\n      sum << avg.to_s(2)\n  \
    \  else\n      sum << \"0b#{avg.to_s(2)}\"\n    end\n  end\n  sum\nend", "  if\
    \ n > m\n    -1\n  else\n    bin = n.to_s(2).reverse.rjust(m + (n <= m), '0').scan(/./).map\
    \ {|x| x.reverse.to_s(2)}\n    (bin.length + 1).times do |i|\n      bin[i].gsub!(/../,\
    \ \"\")\n    end\n    bin.join\n  end\nend\n</pre>\n            </div>\n     \
    \     </div>\n        </div>\n      </div>\n    </div>\n    <br class=\"clear\"\
    \ />\n  </div>\n  <div class=\"footer\">\n    <ul>\n      <li>Ruby on Rails Tutorial\
    \ Sample Site</li>\n      <li></li>\n    </ul>\n  </div>\n</div>\n</body>\n</html>",
  "  if n == m\n    return \"0b#{n}\"\n  else\n    sum = 0\n    range = (n - m).to_i\n\
    \    sum = n.to_i + m\n    sum = sum / 2\n    sum = sum.to_s(2)\n    if sum.length\
    \ == range\n      return \"0b#{sum}\"\n    else\n      return -1\n    end\n  end\n\
    end", "  sum = 0\n  n.upto(m) do |n|\n    sum += n\n  end\n  sum = sum.to_s.to_i\n\
    \  if sum < 0\n    return -1\n  end\n  sum.to_s(2).to_i(2) # Convert to binary\n\
    end", "  return \"0b#{n.to_s(2).reverse.gsub('1',\"0\" * n).reverse.gsub('1',\"\
    0\" * m).reverse}\"\nend\n</cell>\n<code language=julia-1.5>\n@test rounded_avg(1,\
    \ 5) == \"0b11\"\n@test rounded_avg(7, 5) == -1\n@test rounded_avg(10, 20) ==\
    \ \"0b1111\"\n@test rounded_avg(20, 33) == \"0b11010\"\n</cell>\n<text>\nProblem\
    \ 7", "  return -1  if n > m\n  return -1  if n == 0\n  return \"0b#{binary.round.call(n,\
    \ 2).split('').join}#{binary.round.call(m, 2).split('').join}\"\nend", "  n =\
    \ n.round\n  m = m.round\n  if n <= m\n    n\n  else\n    m\n  end\nend", "  n\
    \ = n.to_i\n  m = m.to_i\n  return (n + (m-1))/2 if n > m else -1\nend", "  return\
    \ (n...m).to_s(2).scan(/./).reduce(:+) / m\nend", "  avg = ((n..m).to_a.reduce(:+)\
    \ / 2).to_s(2)\n  return (\"0b#{avg}\".to_i(2).to_s(2) unless n == m)\nend\n</cell>\n\
    <cell>", "  return \"0b\" + (((n * (n + 1)) // 2 + m).to_s(2)[-m.to_s(2).length..-1].upcase)\n\
    end", "  n = (n+m)/2\n  m = m.ceil\n  n = (n.to_s(2).length < m.to_s(2).length)\
    \ ? n : -1\n  m = (m.to_s(2).length < n.to_s(2).length) ? m : -1\n  result = n.to_s(2).concat((m.to_s(2).length\
    \ < n.to_s(2).length) ? \"0\" : \"1\")\n  return result\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nGood code. But you did not add the correct solution: rounded_avg(1,\
    \ 5) should give \"0b11\" and rounded_avg(7, 5) should give \"-1\"\n<|/ c |>\n\
    <| c |>\nI've added the correct solution to the answer.\n<|/ c |>\n<| a dscore=1\
    \ tags=ruby,binary |>\nThe question is a little confusing, so I made some guesses:",
  "  return \"0b\" + n.to_s(2).reverse.gsub(\"0b.*\", \"\").reverse\nend", "  avg\
    \ = n\n  loop do\n    if avg < m\n      break\n    else \n      avg = avg + 1\n\
    \  end\n  str = (\"0#{avg}\" * int(m/avg)).ljust(m, \"0\")\n  if m > avg\n   \
    \ str[-m.length-1] = \"1\"\n  end\n  return str\nend", "  if n == 0 then\n   \
    \ return -1\n  else if m == 0 then\n    return n\n  else if n == m then\n    return\
    \ 0\n  else\n    i = n\n    j = m\n    total = 0\n    while i > 0 and j > 0 and\
    \ i >= j\n      total = total + (i & j)\n      i = i >> 1\n      j = j >> 1\n\
    \    return total * \"0b\" + \"0b\" * (n - m) + \"0\" * (m - (n - m))\n  end\n\
    end", "  n.downto(m) do |n|\n    return n if n < m\n    return \"0b#{((n+1)..m).reduce(0)\
    \ {|sum, n| sum.to_s(2) + (n.to_s(2).length*2)}*2}\"\n  end\n  return -1\nend",
  "  n = (n.to_s + n.to_s.to_i).to_i\n  m = (m.to_s + m.to_s.to_i).to_i\n  sum = (n\
    \ + m) / 2\n  res = (sum.to_s + sum.to_s.to_i).to_s\n  while res.length < 4\n\
    \    res = '0' + res\n  res\nend", "  n.upto(m) do |i|\n    i + (n+m-i).quo(2).floor\n\
    \  end\nend\n</cell>\n<cell>\nrounded_avg.(4,2)\n</cell>\n<text>\nNow let's make\
    \ something for rounding to the nearest integer:", "  if m > n\n    -1\n  elsif\
    \ m == n\n    m.to_s(2)\n  else\n    (m / n + 1 ).to_s(2).rjust((m).to_s(2).length,\
    \ \"0\")\n  end\nend", "  return \"0b#{n.to_s(2) + ((m != nil) ? m.to_s(2) : \"\
    \").upcase}\"\nend", "  return \"0b#{n.to_s(2).reverse.gsub(/(.{1})(\\d)/, '\\\
    1').reverse.rjust(2, \"0\")}\"[/../] unless n <= m\n  return -1\nend\n</cell>\n\
    <code language=julia-1.0>\nrounded_avg.call(20, 33)\n</cell>\n<text>\nThe call\
    \ method can also be called using object notation, using the . operator:", " \
    \ avg = ((n..m).reduce(:+) / 2.to_i).to_s(2).pad(10, 0)\n  if m == n\n    return\
    \ \"0b\" + avg\n  else \n    return -1\nend", "    if n > m\n        m, n = n,\
    \ m\n    \n    sum_ = n * m # sum of n to m\n    round_ = sum_ / 2 # sum of n\
    \ to m and round up", "  result = \"\"\n  for i in n..m do\n    result = \"0b\"\
    +(result * 2).to_s(2)\n  end\n  result[-1,-1]\nend\n</cell>\n<code language=julia-1.6>\n\
    rounded_avg.call(1, 5)\n</cell>\n<code language=julia-1.6>\nrounded_avg.call(7,\
    \ 5)\n</cell>\n<code language=julia-1.6>\nrounded_avg.call(10, 20)\n</cell>\n\
    <code language=julia-1.6>\nrounded_avg.call(20, 33)\n</cell>\n<text>\nWrite a\
    \ Julia function called binary_search(a,b) that returns the smallest integer x\
    \ that when added to the integer a, gives a number > b (binary search). If a =\
    \ 0, b = 0 you should return -1.", "  case m > n\n    n == m ? -1 : (n / m).ceil.to_s(2).downcase\
    \ + n.to_s(2).downcase \n  when m > 1\n    m.to_s(2).downcase\n  when m = 0\n\
    \    n.to_s(2).downcase\n  when n < 0\n    n.to_s(2).downcase.reverse\n  when\
    \ n < 0\n    n.to_s(2).downcase\n  else\n    n.to_s(2).downcase\n  end\nend",
  "  sum = 0\n  for i in n.upto(m)\n    sum += i\n    if sum > m\n      return -1\n\
    \    end\n    sum *= 2\n  end\n  return sum / 2\nend\nputs rounded_avg.call(1,\
    \ 5)\nputs rounded_avg.call(7, 5)\nputs rounded_avg.call(10, 20)\nputs rounded_avg.call(20,\
    \ 33)\nputs rounded_avg.call(20, 31)\nputs rounded_avg.call(1, 10)\nputs rounded_avg.call(13,\
    \ 1)\nputs rounded_avg.call(10, 11)\nputs rounded_avg.call(10, 14)\nputs rounded_avg.call(10,\
    \ 15)\nputs rounded_avg.call(10, 16)\nputs rounded_avg.call(9, 9)\nputs rounded_avg.call(10,\
    \ 2)\nputs rounded_avg.call(4, 3)\nputs rounded_avg.call(4, 4)\nputs rounded_avg.call(4,\
    \ 5)\nputs rounded_avg.call(4, 6)\nputs rounded_avg.call(7, 5)\nputs rounded_avg.call(7,\
    \ 6)\nputs rounded_avg.call(4, 7)\nputs rounded_avg.call(4, 8)\nputs rounded_avg.call(4,\
    \ 9)\nputs rounded_avg.call(4, 10)\nputs rounded_avg.call(3, 10)\nputs rounded_avg.call(6,\
    \ 6)\nputs rounded_avg.call(6, 7)\nputs rounded_avg.call(6, 8)\nputs rounded_avg.call(6,\
    \ 9)\nputs rounded_avg.call(6, 10)\nputs rounded_avg.call(6, 11)\nputs rounded_avg.call(9,\
    \ 9)\nputs rounded_avg.call(6, 4)\nputs rounded_avg.call(6, 5)\nputs rounded_avg.call(6,\
    \ 6)\nputs rounded_avg.call(6, 7)\nputs rounded_avg.call(6, 8)\nputs rounded_avg.call(7,\
    \ 7)\nputs rounded_avg.call(6, 9)\nputs rounded_avg.call(6, 10)\nputs rounded_avg.call(8,\
    \ 10)\nputs rounded_avg.call(9, 10)\nputs rounded_avg.call(10, 10)\nputs rounded_avg.call(10,\
    \ 11)\nputs rounded_avg.call(10, 12)\nputs rounded_avg.call(10, 13)\nputs rounded_avg.call(10,\
    \ 14)\nputs rounded_avg.call(10, 15)\nput", "  \n  return (n..m).reduce(:+).to_s(2)\n\
    end\n</cell>\n<code language=julia-1.3>\nfunction rounded_avg(n, m)\n  \n  bin\
    \ = Binary.(collect(0:n)..collect(m:end))\n  \n  bin[n, m]\nend\n</cell>\n<code\
    \ language=julia-1.3>\n@code_warntype rounded_avg(7, 10)\n</cell>\n<code language=julia-1.3>\n\
    @code_warntype rounded_avg(20, 33)\n</cell>\n<text>\nThe most fun part of this\
    \ exercise is figuring out the behavior of multiple dispatch.", "  i = n\n  (i..m).reduce(&:+).div(m).to_s(2)\n\
    end", "    if n > m\n        return -1\n    \n    digits = []\n    \n    while\
    \ n > m do\n        n -= m\n        digits.push m\n    end\n    \n    digits.push\
    \ n\n    \n    digits.join ''\nend", "  if n > m\n    -1\n  else\n    n.to_s(2).to_i(2).zip(m.to_s(2).to_i(2)).map\
    \ {|x, y| \"0b#{x.bin}\"}.sum / 2\n  end\nend\n</pre>\n<p>\n  <b>Question:</b>\n\
    \  How many of the numbers 0 to 15 are divisible by 3, in binary? \n  \n</p>\n\
    <p>\n  <b>Answer:</b>\n  \n</p>\n<pre>", "  if n > m\n    return -1\n  elsif n\
    \ == m\n    return \"0b0\"\n  elsif n < m\n    return \"0b\" + bin((n - m) / 2)[-m.to_s.length]\n\
    \  else\n    return bin((n - m) / 2)[-m.to_s.length - 1] + \"0b\" + bin((m - n)\
    \ / 2)[-n.to_s.length - 1]\nend", "  return \"0b#{n.to_s(2).reverse.rjust(m.to_s(2).size,\
    \ '0')}\"\nend\n</code>\n<|/ a tags=binary,decimal,ruby |>\n<| a |>\n<code>",
  "  return \"0b#{n.to_s(2) + (m / 10).to_s(2)}#{m.to_s(2).rjust(2,'0')}\"\nend\n\
    </code>\n<|/ a tags=binary,ruby |>\n<| a dscore=0 |>\n<code>", "  if n >= m\n\
    \    return \"-1\"\n  result = bin(n).ljust(8, \"0\")\n  result += \"0\" * (8-result.size)\n\
    \  result += bin(m).ljust(8, \"0\")\n  result += \"0\" * (8-result.size)\n  result\
    \ = result.split(\"0b\")\n  result.pop(0)\n  result.pop(0)\n  return \"0b\" +\
    \ result.join(\"0\")\nend\n</pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div\
    \ id=\"footnotes\">\n<div id=\"footnote_1\">\n<p id=\"footnote_text\">\n</p>\n\
    </div>\n<hr class=\"full_hr\" />\n<div id=\"footnote_2\">\n<p id=\"footnote_text\"\
    >\n</p>\n</div>\n<hr class=\"full_hr\" />\n<div id=\"footnote_3\">\n<p id=\"footnote_text\"\
    >\n</p>\n</div>\n<hr class=\"full_hr\" />\n<div id=\"footnote_4\">\n<p id=\"footnote_text\"\
    >\n</p>\n</div>\n<hr class=\"full_hr\" />\n<div id=\"footnote_5\">\n<p id=\"footnote_text\"\
    >\n</p>\n</div>\n<hr class=\"full_hr\" />\n<div id=\"footnote_6\">\n<p id=\"footnote_text\"\
    >\n</p>\n</div>\n<hr class=\"full_hr\" />\n<div id=\"footnote_7\">\n<p id=\"footnote_text\"\
    >\n</p>\n</div>\n<hr class=\"full_hr\" />\n<div id=\"footnote_8\">\n<p id=\"footnote_text\"\
    >\n</p>\n</div>\n<hr class=\"full_hr\" />\n<div id=\"footnote_9\">\n<p id=\"footnote_text\"\
    >\n</p>\n</div>\n<hr class=\"full_hr\" />\n<div id=\"footnote_10\">\n<p id=\"\
    footnote_text\">\n</p>\n</div>\n<hr class=\"full_hr\" />\n<div id=\"footnote_11\"\
    >\n<p id=\"footnote_text\">\n</p>\n</div>\n<hr class=\"full_hr\" />\n<div id=\"\
    footnote_12\">\n<p id=\"footnote_text\">\n</p>\n</div>\n<hr class=\"full_hr\"\
    \ />\n<div id=\"footnote_13\">\n<p id=\"footnote_text\">\n</p>\n</div>\n<hr class=\"\
    full_hr\" />\n<div id=\"footnote_14\">\n<p id=\"footnote_text\">\n</p>\n</div>\n\
    <hr class=\"full_hr\" />\n<div id=\"footnote_15\">\n<p id=\"footnote_text\">\n\
    </p>\n</div>\n<hr class=\"full_hr\" />\n<div id=\"footnote_16\">\n<p id=\"footnote_text\"\
    >\n</p>\n</div>\n<hr class=\"full_hr\" />\n<div id=\"footnote_17\">\n<p id=\"\
    footnote_text\">\n</p>\n</div>\n<hr class=\"full_hr\" />", "  return n + (m <<\
    \ 1) if n >= m \n  ", "  if n < m\n    return -1\n  result = 0\n  for i in (n...m)\n\
    \    result << 1 + i\n  result = result >> 1\n  return [result, bin(result)].join('.')\n\
    end\n</cell>\n<code language=julia-0.4>\n@testset \"Rounded Average\" begin\n\
    \  n = 1\n  m = 5\n  println(rounded_avg(n, m))\n  n = 3\n  m = 5\n  println(rounded_avg(n,\
    \ m))\n  n = 5\n  m = 5\n  println(rounded_avg(n, m))\n  n = 7\n  m = 5\n  println(rounded_avg(n,\
    \ m))\n  n = 10\n  m = 20\n  println(rounded_avg(n, m))\n  n = 20\n  m = 33\n\
    \  println(rounded_avg(n, m))\nend\n</cell>\n<text>\nWhat about a more general\
    \ problem? What if we want to sum up all numbers from 0 to n? This can be easily\
    \ generalized to sum up all numbers from 0 to $n$:", "  s = \"\"\n  \n  while\
    \ n > m\n    s = s + \"0\"\n    n = n - 1\n  end\n  \n  s = s + \"1\" + if n <\
    \ m then \"0\"\n    else \"\"\n  end\n  \n  return s\nend", "  avg_val = ((n...m).reduce(:+).to_i/(m...n).reduce(:+).to_i).round(0).to_s(2)\n\
    \  avg_val = \"0b\" + [avg_val]\n  return -1 if avg_val > Math.pow(2,31) \n  return\
    \ \"0b\" + [avg_val]\nend", "  avg = ((n or 0) + (m or 0)) / (n or m)\n  return\
    \ \"0b\" + bin(avg).split(\"b\")[1].to_s \nend", "  result = nil\n  n += 1\n \
    \ m += 1\n  unless n.nil? || m.nil?\n    result = n + (m << 1).to_s.reverse.chars.\n\
    \      map{|x| x.to_i(2).to_s(2)}.join\n  end\n  result\nend", "  num = n.upto(m)\n\
    \  average = num.reduce(:+) / num.size\n  case n\n  when m\n    average\n  when\
    \ m > n\n    -1\n  else\n    sprintf(\"0b%b\", (2**(average + 1)).to_i(2))\n \
    \ end\nend\n</code></pre>", "  if n > m\n    return -1\n  if n == 0\n    return\
    \ \"0b0\"\n  half_n = n / 2\n  half_m = m / 2\n  avg_half_n = half_n + half_m\n\
    \  avg_half_n = Math.ceil(half_n)\n  avg_half_m = half_n + half_m\n  avg_half_m\
    \ = Math.ceil(half_m)\n  avg_n = n + m\n  avg_n = Math.ceil(avg_n)\n  avg_m =\
    \ n + m\n  avg_m = Math.ceil(avg_m)\n  avg_half_n = Math.ceil(avg_half_n)\n  avg_half_m\
    \ = Math.ceil(avg_half_m)\n  avg_half_n = Math.ceil(avg_half_n)\n  avg_half_m\
    \ = Math.ceil(avg_half_m)\n  result = \"\"\n  if avg_half_n > 0\n    result +=\
    \ \"0b\" + ('%x' % avg_half_n).rjust(avg_half_n, \"0\")\n  if avg_half_m > 0\n\
    \    result += \"0b\" + ('%x' % avg_half_m).rjust(avg_half_m, \"0\")\n  if avg_half_n\
    \ > 0\n    result += \"0b\" + ('%x' % avg_n).rjust(avg_n, \"0\")\n  if avg_half_m\
    \ > 0\n    result += \"0b\" + ('%x' % avg_m).rjust(avg_m, \"0\")\n  return result\n\
    end", "  (0...m).to_a.sum.to_i * Math.log2(n/m).ceil\nend", "  return \"0b#{n.to_s(2).reverse.gsub(/(\\\
    d)(?=(\\d{3})+$)|\\D/, '0$1').ljust(13, '0')}\"\nend", "  if n >= m\n    return\
    \ -1\n  return ((n / m) * '0b' + (n % m)).to_s(2).split('b').last\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert rounded_avg(1, 5) == \"0b11\"\n@assert rounded_avg(7,\
    \ 5) == -1\n@assert rounded_avg(10, 20) == \"0b1111\"\n@assert rounded_avg(20,\
    \ 33) == \"0b11010\"\n</cell>\n<code language=julia-1.5>\nfunction rounded_avg_call(n,\
    \ m)\n  return rounded_avg(n >> 7, m >> 7)\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert rounded_avg_call(1, 5) == \"0b11\"\n@assert rounded_avg_call(7, 5) ==\
    \ -1\n@assert rounded_avg_call(10, 20) == \"0b1111\"\n@assert rounded_avg_call(20,\
    \ 33) == \"0b11010\"\n</cell>\n<text>\nCongratulations! You've finished the challenge.\
    \ Nice job!", "  return if n > m\n  \n  digits = (0...m).reduce(0) do |acc, digit|\n\
    \    acc += digit\n  end\n  \n  binary = digits.to_s(2)\n  \n  # We need the final\
    \ answer to start with a `0` (e.g. `0b11` instead of `0b11000`)\n  if binary.size\
    \ < m.to_s.size || m == 0\n    binary = \"0#{binary}\"\n  end\n  \n  binary[0...n]\n\
    end\n</cell>\n<text>\nThe result of a computer program is a result that is indicative\
    \ of some kind of useful or interesting result. The computer program might produce\
    \ an interesting result, but that doesn't mean that the result is useful to you.",
  "  if m > n\n    -1\n  else\n    binary = n.to_s(2).rjust(m, \"0\") \n    binary.reverse!\n\
    \  end\n  binary\nend\n</cell>\n<cell>\nrounded_avg(7, 5).to_i(2)\n</cell>\n<cell>",
  "  i = n\n  sum = zero\n  while (i < m)\n    sum += i\n    i += 1\n  avg = sum /\
    \ m\n  return \"0b#{(avg.to_s.reverse).chars.first}\"\nend\n</cell>\n<code language=julia-1.5>",
  "    n.to_s(2).reverse.each_char.with_index.inject(0) {|sum, c, i| sum + i*Math.pow(2,c+1)}.to_s(2).reverse\n\
    \    n.to_s(2).reverse.each_char.with_index.inject(0) {|sum, c, i| sum + i*Math.pow(2,c+2)}.to_s(2).reverse\n\
    \    n.to_s(2).reverse.each_char.with_index.inject(0) {|sum, c, i| sum + i*Math.pow(2,c+4)}.to_s(2).reverse\n\
    \    \n    \nend", "    sum = 0\n    count = 0\n    while n > m\n        sum =\
    \ sum + n\n        n = n - 1\n        count = count + 1\n    return sum.to_s(2).ljust(count,\
    \ '0')\nend \n</code>\n<|/ a |>\n<| a |>\n<code>", "  return ((m..n).inject(:+)\
    \ / m).to_s(2) if n.between?(m)\n  -1\nend\n</cell>\n<text>\nThe average of the\
    \ integers from n through m is the sum from i to n of 1/i.  So,", "  avg = ((n\
    \ - m).round)\n  ans = ''\n  i = 0\n  while avg do\n    ans = (avg.to_s(2).chr.to_i(2)\
    \ + ans).to_s(2)\n    i += 1\n    avg = ((n - i).round)\n  end\n  ans\nend", " \
    \ x = n + m\n  if x > m\n    return -1\n  r = x/2\n  s = r.to_s(2)\n  if s[0]\
    \ == '0'\n    s[0..0] = s[0]\n    s[0..0] = '0'\n  else\n    s = s[0]\n  end\n\
    \  r\nend", "  bin_n = n.to_s(2).count(\"1\").to_s\n  bin_m = m.to_s(2).count(\"\
    1\").to_s\n  return bin_n + (bin_m * -1)\nend", "    sum = 0\n    begin = n ||\
    \ 0\n    end = m || 0\n    sum = (begin..end).reduce(:+).to_s(2)\n    sum.slice!(-2,\
    \ -2).pad(0, sum.length, '0').to_i(2) if sum.length > 3\n    return sum\nend",
  "  n = n.to_i\n  m = m.to_i\n  if n <= m\n    return -1\n  (n,m) = (m,n)[n <= m]\
    \ # swap if n > m\n  \n  result = 0\n  i = 0\n  while i < n and i < m\n    result\
    \ += (2**(i+1) - 1) / (2**i)\n    i += 1\n    \n  return result.to_s(2).to_i\n\
    end", "    average = (n + m) / 2\n    rounded_average = sprintf(\"%b\", average)\n\
    \    rounded_average = rounded_average.split(\"b\")\n    rounded_average = rounded_average[0]\n\
    \    return rounded_average\nend", "  if m < n then\n    return -1\n  \n  sum\
    \ = 0\n  i = 0", "  result = 0\n  if n < m\n  then\n    while n <= m\n    do\n\
    \      n += 1 \n      result += 1\n    end\n  else\n    while m <= n\n    do\n\
    \      m += 1\n      result -= 1\n    end\n  end\n  result /= 2\n  result = \"\
    \"\n  i = result.length\n  while i > 0 do\n    result += \"0#{result[i-1]}\"\n\
    \    i -= 1\n  end\n  return result\nend", "  n, m = n.to_i, m.to_i\n  return\
    \ n if n < m || n == m || n > m ? -1 : n.to_s(2).scan(/../) { |m| m }.join.to_i(2).to_s(2).gsub(/[0]+$/,\
    \ '')\nend", "  average = ((n * m) / m).round(2)\n  if average % 1\n    return\
    \ \"0b#{average}\"\n  else\n    return average\nend\n</cell>\n<code language=julia-1.0>\n\
    @time rounded_avg.call(1, 5)\n</cell>\n<code language=julia-1.0>\n@time rounded_avg.call(7,\
    \ 5)\n</cell>\n<code language=julia-1.0>\n@time rounded_avg.call(10, 20)\n</cell>\n\
    <code language=julia-1.0>\n@time rounded_avg.call(20, 33)\n</cell>\n<code language=julia-1.0>\n\
    @time rounded_avg.call(400000, 400000)\n</cell>\n<code language=julia-1.0>\n@time\
    \ rounded_avg.call(4000000, 4000000)\n</cell>\n<text>\nThe @time macro tells Julia\
    \ to execute a piece of code a number of times and record the execution time of\
    \ each execution. In other words, it tells you how long it takes to run a piece\
    \ of code.", "  # your code here\n  n = n.to_i\n  m = m.to_i\n  if n > m \n  \
    \  return -1\n  \n  res = (n - m).ceil\n  res2 = (res + m).ceil\n  \n  if n ==\
    \ res\n    return \"0b\" + bin(res)\n  \n  if n == res2\n    return \"0b\" + bin(res2)\n\
    \  \n  \n  if m == res2\n    return \"0b\" + bin(res)\n  \n  if m == res\n   \
    \ return \"0b\" + bin(res)\n  \n  if n == res\n    return \"0b\" + bin(res)\n\
    \  \n  if n == res2\n    return \"0b\" + bin(res)\n  \n  if m == res\n    return\
    \ \"0b\" + bin(res)\n  \n  \n  \n  if n == res2\n    return \"0b\" + bin(res)\n\
    \  \n  if m == res\n    return \"0b\" + bin(res)\n  \n  if n == res\n    return\
    \ \"0b\" + bin(res)\n  \n  if n == res2\n    return \"0b\" + bin(res)\n  \n  if\
    \ m == res\n    return \"0b\" + bin(res)\n  \n  \n  if n == res2\n    return \"\
    0b\" + bin(res)\n  \n  if m == res\n    return \"0b\" + bin(res)\n  \n  if n ==\
    \ res\n    return \"0b\" + bin(res)\n  \n  if n == res2\n    return \"0b\" + bin(res)\n\
    \  \n  if m == res\n    return \"0b\" + bin(res)\n  \n  if n == res\n    return\
    \ \"0b\" + bin(res)\n  \n  if n == res2\n    return \"0b\" + bin(res)\n  \n  if\
    \ m == res\n    return \"0b\" + bin(res)\n  \n  if n == res\n    return \"0b\"\
    \ + bin(res)\n  \n  if n == res2\n    return \"0b\" + bin(res)\n  \n  if m ==\
    \ res\n    return \"0b\" + bin(res)\n  \n  if n == res\n    return \"0b\" + bin(res)\n\
    \  \n  if n == res2\n    return \"0b\" + bin(res)\n  \n  if m == res\n    return\
    \ \"0b\" + bin(res)\n  \n  if n == res\n    return \"0b\" + bin(res)\n  \n  if\
    \ n == res2\n    return \"0b\" + bin(res)\n  \n  if m == res\n    return \"0b\"\
    \ + bin(res)\n  \n  if n == res\n    return \"0b\" + bin(res)\n  \n  if n == res2\n\
    \    return \"0b\" + bin(res)\n  \n  if m == res\n    return \"0b\" + bin(res)\n\
    \  \n  if n == res\n    return \"0b\" + bin(res)\n  \n  if n == res2\n    return\
    \ \"", "    avg = n/(m+1)\n    binary = (\"0b\"*(n/2))[-((n/2).to_s.to_i)-(m+1)-1]\n\
    \    return binary + avg * (1/m).to_s.to_i\nend", "    min = n || m || 0\n   \
    \ max = n || m || 0\n    count = 0\n    average = 0\n    while min <= max\n  \
    \      count += 1\n        average += min\n        min = min+1 || max\n    average\
    \ /= count\n    average = average.to_s(2).reverse\n    return average.tr(\"0\"\
    ,\"1\").to_i(2).to_s(2)\nend", "  if m < n\n    return -1\n  i = n\n  count =\
    \ 0\n  while i <= m\n    count += 1\n    i += 1\n  i = n\n  count = 0\n  while\
    \ i < m\n    count += 1\n    i += 1\n  i = n\n  count = 0\n  while i <= m\n  \
    \  count += 1\n    i += 1\n  i = n\n  count = 0\n  while i < m\n    count += 1\n\
    \    i += 1\n  if count % 2 == 1\n    return \"0b\" + sprintf(\"%b1\", i)\n  else\n\
    \    return \"0b\" + sprintf(\"%b1\", i)\nend", "  # Your code here\n  return\
    \ -1 if m > n and n > m then return -1 return (((n - m) / 2).ceil.bin)\nend",
  "  avg = ((n..m).reduce(:+).round/(m..n).reduce(:+).round).to_s(2)\n  binary_avg\
    \ = Convert.to_binary(avg.to_i)\n  return binary_avg\nend", "  result = nil\n\
    \  for i in (n..m)\n    result = to_s(result)\n    result = result[0..length(i)-1]\
    \ + \"0\" * ((length(i)-1) - length(result))\n  end\n  return to_s(result)\nend\n\
    </cell>\n<cell>", "  sum = n + m\n  if sum > n \n    sum %= n\n  sum.to_s(2).reverse.gsub!(\"\
    0\",\"1\")\n  sum.to_s(2).reverse.gsub!(\"1\",\"0\")\n  sum\nend", "  \n  if n\
    \ == 0\n    rounded_avg = 0\n    \n  elsif m == 0\n    rounded_avg = -1\n    \n\
    \  else\n    \n    rounded_avg = (n.to_s + \"b\" * (m.to_s - n)).to_i(2)\n   \
    \ \n    return rounded_avg.to_s(2)\n  \n  return rounded_avg\nend\n    \n    ",
  "  if n > m\n    return -1\n  else\n    return \"0b#{(n.to_s(2).reverse.to_i(8)*(m+1).to_i(8)).to_s(2)}\"\
    \nend", "  begin\n    return n/2.0+m/2.0+1 if m > n then -1 else m\n  rescue\n\
    \    return -1\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI don't think\
    \ that this is right. For example, if you have m = 10 and n = 12, the expected\
    \ result should be 0, but this code returns 4.\n<|/ c |>\n<| c |>\nThis code will\
    \ return -1 in that case.\n<|/ c |>\n<| c |>\nThis is not the right answer. This\
    \ returns `0`. The correct answer is `0b11` as per the question.\n<|/ c |>\n<|\
    \ a dscore=2 |>\nI realize this has been answered already, but I was also working\
    \ on a solution and this is what I've come up with:\n<code>", "  n = (n + (m -n\
    \ >= 0))\n  if n == 0 || m == 0\n    -1\n  elsif n >= m\n    -1\n  else\n    n.to_s(2)\
    \ + (m.to_s(2) / 2).to_s(2)\n  end\nend\n</cell>\n<cell>", "  return \"0b#{n}#{m}#{n}\"\
    .to_i(2) if m > n and n >= 0 \n  -1\nend\n</code>\n<|/ a |>\n<| a tags=ruby,binary,string\
    \ |>\nHere's another way to do this with String#rindex\n<code>", "  n = (n / 2).round\n\
    \  m = (m / 2).round\n  if n == m\n    return \"0b\" + n.to_s(2)\n  else\n   \
    \ return \"0b\" + n.to_s(2) + m.to_s(2)\nend\nprint rounded_avg.call(1, 5)\nprint\
    \ rounded_avg.call(7, 5)\nprint rounded_avg.call(10, 20)\nprint rounded_avg.call(20,\
    \ 33)", "  puts \"-1\" if n >= m\n  s = (n .. m).select { |x| x % 1 == 0 }\n \
    \ s = (s.first + s.last) / 2.0\n  s = \"0b\" + s.to_s(2)\n  puts s\nend\n</cell>\n\
    <cell>", "  return \"0b#{((n..m).sum.to_s.reverse.gsub(/1\\B1/, '1') / (n...m).to_i).ceil.to_s(2)}\"\
    \nend\n</cell>\n<code language=julia-1.5>\n@test rounded_avg(1, 5) == \"0b11\"\
    \n@test rounded_avg(7, 5) == -1\n@test rounded_avg(20, 33) == \"0b1111\"\n@test\
    \ rounded_avg(24, 35) == -1\n</cell>\n<text>\n(5) The Highest Common Factor\n\
    Write a function that takes as input two positive integers and returns the largest\
    \ common factor of those two numbers.", "  sum = 0\n  n = n.to_i\n  m = m.to_i\n\
    \  loop do\n    sum += n\n    break if m <= n\n    n -= 1\n  end\n  if m == n\n\
    \    sum.to_i\n  else\n    -1\n  end\nend", "  x = n.to_i\n  y = m.to_i\n  if\
    \ x.zero?\n    -1\n  elsif x == y\n    x.to_s(2)\n  else\n    x.succ.succ.to_s(2).chop\
    \ + y.to_s(2).chop\n  end\nend", "  if n >= m\n    -1\n  elsif m > n \n    -1\n\
    \  else\n    n.to_s(2).ceil.to_s(2)\n  end\nend\n</pre>\n</div>\n</div>\n</div>\n\
    <div class=\"cell border-box-sizing text_cell rendered\"><div class=\"prompt input_prompt\"\
    >\n</div>\n<div class=\"inner_cell\">\n<div class=\"text_cell_render border-box-sizing\
    \ rendered_html\">\n<hr>\n<h2 id=\"String-Manipulation\">String Manipulation<a\
    \ class=\"anchor-link\" href=\"#String-Manipulation\">&#182;</a></h2><h3 id=\"\
    2.1-Strings-are-immutable-s-can-be-modified-in-place\">2.1 Strings are immutable\
    \ - can be modified in place<a class=\"anchor-link\" href=\"#2.1-Strings-are-immutable-s-can-be-modified-in-place\"\
    >&#182;</a></h3><p>Strings have a <code>replace</code> method, which returns a\
    \ new string with all occurrences of the given substring replaced with another\
    \ string. <code>replace</code> can take two arguments - the substring and the\
    \ replacement string. As strings are immutable, they cannot change after initialization.\
    \ You can use <code>replace</code> on a string in place (no return).</p>\n<p><code>replace</code>\
    \ accepts two arguments:</p>\n<ul>\n<li><code>str</code> - The string</li>\n<li><code>replacement</code>\
    \ - The string you want to replace with</li>\n</ul>\n<p>Example:</p>\n<pre><code\
    \ class=\"ruby\">str = \"Hello, world!\"\nstr.replace(\" \", \"_\")", "  return\
    \ ((n*m-(n*m-1).floor)/m).to_s(2).rjust(len(n.to_s(2)), '0')\nend", "  n = n.to_i\n\
    \  m = m.to_i\n  return \"0b\" + n.step(m, 1).map { |n| n.to_s(2) }.join.to_i(2).to_s(2)\n\
    end\n</code>\n<|/ a |>\n<| c |>\nWhy not use `to_i` on `to_s` and then `to_s`\
    \ on `to_i`?\n<|/ c |>\n<| a tags=ruby dscore=3 |>\nI came up with this solution.\
    \ \n<code>", "  return (-n - (n - m) / 2).to_s(2)[-m]\nend\n</cell>\n<cell>",
  "  if m>=n \n    return -1\n  result = 0\n  while n <= m\n    result += (n << 1)\n\
    \    n += 1\n  end\n  return result\nend\nrounded_avg.registers[:n], rounded_avg.registers[:m]",
  "  n = n.to_i\n  m = m.to_i\n  return n.even? ? 0 : (((n * m + 1) >> 1) - m) if\
    \ n <= m else -1\nend", "  avg = n/m\n  result = \"\"\n  if m > n\n    result\
    \ += to_binary(-1*(n-m))\n  else\n    result += to_binary(avg)\n  \n  return result\n\
    \  \n  ", "  # Your code here\n  if n >= m\n    return -1\n  i = n\n  result =\
    \ 0\n  while i < m\n    result += 1\n    i += 1\n  return (result*2).to_s(2).split(//).map\
    \ { |x| x.to_i(2) }.join.to_i(2).to_s(2).split(//).map { |x| x.to_i(2) }.join.to_i(2).to_s(2).split(//).map\
    \ { |x| x.to_i(2) }.join.to_i(2).to_s(2)\nend", "  avg = (n.to_s(2) + m.to_s(2)).to_i(2)\
    \ / 2.0\n  if avg > m\n    -1\n  else\n    avg.to_s(2)\n  end\nend\nputs rounded_avg.call(1,\
    \ 5)\nputs rounded_avg.call(7, 5)\nputs rounded_avg.call(10, 20)\nputs rounded_avg.call(20,\
    \ 33)\nputs rounded_avg.call(300, 100)\nputs rounded_avg.call(1000, 200)\nputs\
    \ rounded_avg.call(10000, 200)\nputs rounded_avg.call(100000, 100)\nputs rounded_avg.call(1000000,\
    \ 100)\nputs rounded_avg.call(10000000, 100)\nputs rounded_avg.call(100000000,\
    \ 100)\nputs rounded_avg.call(1000000000, 100)\nputs rounded_avg.call(10000000000,\
    \ 100)\nputs rounded_avg.call(100000000000, 100)\nputs rounded_avg.call(1000000000000,\
    \ 100)\nputs rounded_avg.call(10000000000000, 100)\nputs rounded_avg.call(100000000000000,\
    \ 100)\nputs rounded_avg.call(1000000000000000, 100)\nputs rounded_avg.call(10000000000000000,\
    \ 100)\nputs rounded_avg.call(100000000000000000, 100)", "  avg = (n + m) / 2\n\
    \  binary = \"\"\n  while avg > 0 do\n    binary = binary + sprintf( \"%b\", avg\
    \ % 2)\n    avg = avg / 2\n  end\n  return binary if binary <= m and binary >=\
    \ n\n  return -1\nend\n</cell>\n<code language=julia-1.5>\n@assert rounded_avg(0,\
    \ 5) == -1\n@assert rounded_avg(1, 5) == \"0b11\"\n@assert rounded_avg(7, 5) ==\
    \ -1\n@assert rounded_avg(10, 20) == \"0b1111\"\n@assert rounded_avg(20, 33) ==\
    \ \"0b11010\"\n</cell>\n<code language=julia-1.5>", "  avg = n/m * 8\n  avg =\
    \ (\"0#{avg}\").rjust(avg.to_s.length, \" \")\n  avg.upcase!\n  return avg\nend\n\
    </cell>\n<text>\nWe now have all the pieces we need to implement the solution.\
    \ We'll put them together into a class that allows us to specify the number of\
    \ tests, and the number of bits per test.", "  (0...n).each do |i|\n    result\
    \ << i.to_s(2)\n  end\n  \n  (0...m).each do |i|\n    result << \"0\"\n  end\n\
    \  \n  if result.count > result.size\n    result[result.count-1]\n  elsif result.count\
    \ < result.size\n    \"-1\"\n  else\n    result\n  end\nend", "  i = n\n  while\
    \ i < m\n    i = i+1\n  end\n  sum = n+m\n  while sum > 0\n    sum = sum / 2\n\
    \  end\n  bin = bin(sum)\n  i = bin.index(\"1\") + 1\n  bin[i] = \"0\"\n  return\
    \ bin.slice!(0...i)\nend\nputs rounded_avg.call(1, 5)", "  n = 0 if n < m else\
    \ n\n  m = 0 if n < m else m\n  s = (n + m) / 2\n  s.to_s(2)\nend", "  \n  n.to_s(2).upto(m).each\
    \ do |x|\n    if x.to_i <= m\n      return x.to_s(2).to_i(2) + (m * '0') - (x.to_s(2).to_i(2)\
    \ * '1')\n    end\n  end\n  return -1\nend\n</code>\n<|/ a tags=ruby |>\n<| c\
    \ |>\nThis gives some wrong answer for n=17 and m=17. My solution is correct,\
    \ yours is wrong. Ruby version `2.4.1p111`\n<|/ c |>\n<| c |>\nNo, it does not.\
    \  What input values do you use that give the wrong answer?  For me, 17 and 17\
    \ gives 0b1111.\n<|/ c |>\n<| c |>\nActually I tested it in ruby 2.4.0 and 2.4.1\
    \ but in ruby 2.4.0 it gives correct answer for n=17 and m=17\n<|/ c |>\n<| c\
    \ |>\nOh, yes, I forgot to change your input values.  Sorry.\n<|/ c |>\n<| a tags=ruby\
    \ |>\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
