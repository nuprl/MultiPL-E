name: HumanEval_90_next_smallest
language: rb
prompt: "# You are given an array of integers.\n# Write a function next_smallest()\
  \ that returns the 2nd smallest element of the array.\n# Return nil if there is\
  \ no such element.\n# >>> next_smallest.call([1, 2, 3, 4, 5])\n# 2\n# >>> next_smallest.call([5,\
  \ 1, 4, 3, 2])\n# 2\n# >>> next_smallest.call([])\n# nil\n# >>> next_smallest.call([1,\
  \ 1])\n# nil\ndef next_smallest(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_next_smallest\n\
  \    candidate = method(:next_smallest)\n    assert_equal(2, candidate.call([1,\
  \ 2, 3, 4, 5]))\n    assert_equal(2, candidate.call([5, 1, 4, 3, 2]))\n    assert_equal(nil,\
  \ candidate.call([]))\n    assert_equal(nil, candidate.call([1, 1]))\n    assert_equal(1,\
  \ candidate.call([1, 1, 1, 1, 0]))\n    assert_equal(nil, candidate.call([1, 1]))\n\
  \    assert_equal(-35, candidate.call([-35, 34, 12, -45]))\n  end\nend\n"
completions: ["  return nil if lst.empty?\n  elsif lst.size > 2\n    idx = lst.index\
    \ { |x| x < lst.min }\n    idx == 0 ? nil : lst.at(idx + 1)\n  else\n    idx =\
    \ lst.index { |x| x == lst.min }\n    lst.at(idx)\n  end\nend\n</code>\n<|/ a\
    \ tags=ruby,sorting,arrays |>\n<| c |>\n+1 for the `Enumerable#min` solution.\
    \ Unfortunately it fails to produce the correct result if the smallest element\
    \ occurs more than twice, e.g. `[4,4,4,4,4].min` gives `4`, whereas it should\
    \ produce `nil`.\n<|/ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>\n[4,3,2,1].min",
  '  return nil if lst.empty?', "  case lst\n  when nil\n    nil\n  when Integer\n\
    \    if lst.length <= 1\n      nil\n    else\n      lst.min + 1\n    end\n  else\n\
    \    lst.each_with_index.inject(nil) do |smallest, (i, j)|\n      next smallest\
    \ unless i.nil?\n      smallest = j\n      smallest\n    end\n  end\nend", " \
    \ \n  return nil if (lst.length == 0)\n  \n  if lst.include?(lst[0].min)\n   \
    \ smallest = lst[0].min\n  elsif lst.include?(lst[0].max)\n    smallest = lst[0].max\n\
    \  else\n    smallest = nil\n  end\n  \n  smallest_index = lst.index(smallest)\n\
    \  \n  if smallest_index > 0\n    if lst[smallest_index-1].min\n      smallest\
    \ = lst[smallest_index-1].min\n    else\n      smallest = nil\n    end\n  end\n\
    \  \n  return smallest\nend\n        </pre>\n      </dd>\n      </dl>\n      \n\
    \      <dl>\n        <dt>Ruby</dt>\n        <dd>\n          <pre>", "  return\
    \ nil unless lst\n  \n  lst.min_by do |x| \n    break x if x > lst[1]\n    break\
    \ if x > lst[1..-1].min_by do |x| \n      break x if x == lst[1]\n      break\
    \ nil if x == lst[1..-1].min_by do |x| \n        break x if x == lst[1]\n    \
    \    break nil if x == lst[1..-1].min_by do |x| \n          break x if x == lst[1]\n\
    \          break nil\n        end\n      end\n    end\n  end\nend", "  return\
    \ nil unless lst\n  min, max = lst.minmax_by(&:first)\n  max.nil? ? nil : max.second\n\
    end", "  return nil if lst.nil?\n  first_elt = lst.shift\n  first_elt.nil? ? nil\
    \ : first_elt\nend\n</cell>\n<cell>", "  lst.sort.last\nend\n</code>\n<|/ a tags=arrays,ruby\
    \ |>\n<| a dscore=0 |>\n<code>", "  smallest_idx = nil\n  smallest_value = nil\n\
    \  \n  lst.each_with_index do |e, i|\n    if e < smallest_value or (smallest_value.nil?\
    \ and e < smallest_idx)\n      smallest_value = e\n      smallest_idx = i\n  \
    \  end\n  end\n  return smallest_value unless smallest_value.nil?\n  return nil\n\
    end", "  return nil if lst.nil?\n  lst.include?(lst[0]) ? lst.shift : nil\nend",
  '    return nil if lst.length <= 1', '  lst.sort!', "  lst.each do |e|\n    break\
    \ if e > lst.min # if we found a new min we break from the loop\n    return e\
    \ # return it (so it will not be returned below)\n  end\nend", "    smallest,\
    \ largest = lst[0], lst[0]\n    lst.each do |x|\n        if x < smallest\n   \
    \         smallest = x\n        end\n        if x > largest\n            largest\
    \ = x\n        end\n    end\n    next((smallest.nil? || smallest.to_f < largest.to_f)\
    \ ? nil : smallest)\nend", "  if lst.size > 0\n    arr = Array.new(lst.size)\n\
    \    lst.each_with_index { |item, i| arr[i] = item }\n    arr.sort.each_with_index\
    \ { |item, i| return i if item == arr[i+1] }\n  else\n    nil\n  end\nend", " \
    \ return lst.sort.last if lst.size > 0 && lst.size < 10000\nend", "  lst = lst\
    \ or []\n  if lst.size == 0\n    nil\n  else\n    smallest = lst.min\n    index\
    \ = lst.index(smallest)\n    next if index < lst.size - 2\n    smallest\n  end\n\
    end", "  return nil if lst.empty?\n  result = nil\n  lst.each do |x|\n    next\
    \ if result == nil\n    break unless result.compare_to(x) <=> 0\n    result =\
    \ x\n  end\n  result\nend\n</code></pre>", "  return nil if lst.length == 0\n\
    \  min = lst[0]\n  lst[0] = nil\n  lst.each do |e|\n    if e < min\n      min\
    \ = e\n    end\n  end\n  min\nend", "  lst.sort!\n  lst.size == 1 ? nil : lst[1]\n\
    end", "  lst.find do |x|\n    x < lst.min\n  end\nend", "  if lst.size > 0\n \
    \   idx = 1\n    smallest = lst[idx]\n    while idx < lst.size\n      el = lst[idx]\n\
    \      if el > smallest\n        smallest = el\n      else\n        idx += 1\n\
    \      end\n    end\n    return smallest\n  end\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| a |>\n<code>", "  smallest = nil\n  lst.each { |i| smallest = i if i\
    \ < smallest }\n  smallest\nend", "  lst.sort.each_with_index do |x, i|\n    return\
    \ nil unless i == lst.size-1 || x <= lst[i+1]\n    return x if x <= lst[i+1]\n\
    \  end\nend", "  return nil unless lst\n  lst.each_with_index do |value, index|\n\
    \    return nil unless index < lst.length - 1\n    return value if (value < lst[index\
    \ + 1])\n  end\nend", "  smallest_index = lst.find_index { |x| x < lst.min_by(&:to_i)\
    \ }\n  lst.min_by(&:to_i)[smallest_index == lst.length - 1 ? 0 : 1]\nend", " \
    \ lst.size >= 2 ? (lst[1] <= lst[0]) ? next_smallest(lst[1..-1]) : nil : nil\n\
    end\n</cell>\n<cell>", "  lst = lst || []\n  lst.shift\n  lst.shift while lst.size\
    \ > 1 \n  return nil if lst.size == 0\n  lst.shift\nend", "  smallest_value =\
    \ nil\n  smallest_index = nil\n  \n  lst.each_with_index do |elem, i|\n    if\
    \ elem.is_a?(Fixnum)\n      # Set min value\n      smallest_value = elem if elem.is_a?(Fixnum)\n\
    \      smallest_index = i\n    elsif elem.is_a?(Array)\n      # Recursive call\n\
    \      elem.each do |e|\n        if e.is_a?(Fixnum)\n          smallest_value\
    \ = e if e.is_a?(Fixnum)\n          smallest_index = i\n        end\n      end\n\
    \    end\n  end\n  \n  if smallest_value.is_a?(Fixnum)\n    smallest_value\n \
    \ elsif smallest_value.is_a?(Array)\n    smallest_value[smallest_index]\n  else\n\
    \    nil\n  end\nend\n</cell>\n<text>\nNow we will implement a function that gets\
    \ the n largest elements from the given array. We will also implement a recursive\
    \ solution.", "  return nil if lst.empty?\n  smallest = lst.first\n  smallest_index\
    \ = lst.index(smallest)\n  smallest_index += 1\n  \n  if smallest_index >= lst.size\n\
    \    smallest_index = 0\n  end\n  \n  return lst.nth(smallest_index)\nend", " \
    \ smallest = nil\n  smallest = lst.min\n  lst.delete_at(lst.index(smallest))\n\
    \  smallest\nend", "  lst.sort.reverse.find { |x| x < lst[1] }\nend", "  return\
    \ nil if lst.length == 0\n  idx = 1\n  while idx < lst.length\n    v = lst[idx]\n\
    \    idx += 1\n    if v <= lst[idx-1]\n      return v\n    end\n  end\n  nil\n\
    end", "  return nil unless lst\n  return nil unless lst.size > 1\n  lst.sort!\n\
    \  lst[1].nil? ? nil : lst[1]\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThat\
    \ makes sense but it doesn't work, i get an error \"undefined method `+' for nil:NilClass\"\
    \n<|/ c |>\n<| c |>\nI fixed it! Thanks so much for the help :)\n<|/ c |>\n<|\
    \ c |>\nSorry about that. I'm glad this worked out. :-)\n<|/ c |>\n<| a dscore=2\
    \ tags=ruby |>\nA more functional approach would be to use a hash to store the\
    \ min values and the corresponding index for the hash entries:\n<code>", "  smallest\
    \ = nil\n  smallest_index = nil", "  smallest = lst[0]\n  smallest_index = nil\n\
    \  lst.each { |num| return num if num > smallest }\n  lst.each { |num| return\
    \ num if num > smallest and num != smallest }\n  nil\nend", "  lst.sort!\n  lst.shift\
    \ if lst.size < 2\n  lst.first\nend", "  first = (lst.first || lst.first)\n  second\
    \ = (lst.second || lst.second)\n  \n  (first <=> second) if first && second\n\
    end\n</cell>\n<text>\nnext_smallest([1, 2, 3, 4, 5]) should return 2, because\
    \ 2 < 1.", "  lst.find { |el| el < lst.min }\nend", "  smallest = nil\n  smallest_index\
    \ =  nil\n  lst.each_with_index do |val, idx|\n    if val < smallest\n      smallest\
    \ = val\n      smallest_index = idx\n    end\n  end\n  if smallest_index\n   \
    \ lst[smallest_index + 1]\n  else\n    nil\n  end\nend", "  lst = lst.sort.take(2)\n\
    \  lst.length > 0 ? lst[1] : nil\nend\n</code>\n<|/ a |>\n<| c |>\nThis is what\
    \ I was looking for and it worked great.\n<|/ c |>\n<| a tags=ruby dscore=3 |>\n\
    <code>", "  i = 0\n  while i < lst.size do\n    i += 1\n    if i < (lst.size)\n\
    \      lst[i] < lst[i + 1] ?\n        lst[i + 1] : nil\n    else\n      nil\n\
    \    end\n  end\nend", "  lst.find {|e| e < lst.min}\nend", "  # write your code\
    \ here\n  smallest = lst[0]\n  smallest2 = lst[1]\n  if smallest2 < smallest\n\
    \    smallest = lst[1]\n  end\n  return smallest\nend", "  return nil if lst.length\
    \ == 0\n  \n  i = lst.length - 1\n  j = lst.length - 1\n  while i >= 0 and lst[i]\
    \ < lst[j]\n    i -= 1\n  end\n  \n  while j < lst.length and lst[j] < lst[i]\n\
    \    j -= 1\n  end\n  \n  return lst[i] if i >= 0 and j >= 0\n  return nil\nend",
  "  lst.nil? or lst.size == 1 or lst.first > lst.second\nend", "  lst.sort\n  next_smallest\
    \ = lst[1]\n  lst.clear\n  lst[1]\n  nil\nend", "    smallest = lst[0]\n    second_smallest\
    \ = nil\n    smallest_idx = 1\n    \n    # Find smallest element and index\n \
    \   until smallest_idx < lst.size\n        if smallest[0] < lst[smallest_idx]\n\
    \            smallest = lst[smallest_idx]\n            second_smallest = smallest\n\
    \        end\n        smallest_idx += 1\n    end\n    \n    return second_smallest\n\
    end", "  smallest_index, smallest_value = smallest.index(lst[0]), lst[0]\n  if\
    \ smallest_index != nil and smallest_value < lst[smallest_index+1]\n    smallest_index,\
    \ smallest_value = smallest_index+1, lst[smallest_index+1]\n  end\n  return smallest_value\n\
    end", "  lst.sort.last(2)[1]\nend\n</cell>\n<text>\n\u23CE Returning a tuple from\
    \ methods\nWe've seen how methods work in Ruby. Methods are just like any other\
    \ method, and can be called on any object. However, a method can return multiple\
    \ values (or an Array, or a Hash, or a Range, etc.), and this can be exploited\
    \ when chaining methods calls, for instance if one method returns a tuple:", " \
    \ lst.sort!\n  lst = lst.first(2)\n  \n  lst.nil? ? nil : lst[1]\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| a dscore=1 |>\nRuby's standard library has a method that\
    \ returns an array with the two smallest values, and another that returns the\
    \ second smallest value. You could use those to get two values at a time and compare\
    \ them to the original, if you really wanted:\n<code>", "  lst.min\nend", "  return\
    \ nil unless lst.length>0\n  smallest_value = lst[0]\n  smallest_index = 0\n \
    \ \n  lst.each_with_index do |value, index|\n    return nil unless value<smallest_value\n\
    \    smallest_value = value if value<smallest_value\n    smallest_index = index\n\
    \  end\n  \n  lst[smallest_index]\nend", "  if lst.empty?\n    nil\n  else\n \
    \   lst.sort\n    lst.pop\n  end\nend", "  raise ArgumentError if lst.length <\
    \ 2\n  first_el = lst[0]\n  second_el = lst[1]\n  second_el = nil if second_el\
    \ < first_el\n  second_el\nend", "  return nil if lst.nil?\n  if lst.size > 1\n\
    \    arr = []\n    arr.push(lst.min)\n    arr.push(lst.max)\n    arr.push(lst.max)\n\
    \    arr.sort!\n    arr.shift if arr.last == lst.min\n    return arr.last\n  end\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| a dscore=2 |>\nHere's another possibility\n\
    <code>\na = [5,2,1,3,4]\na.find { |x| (a.count { |y| x < y }) == 1 }", "  lst.shift\n\
    \  lst.shift\n  lst.shift if lst.size < 2\nend", "  return nil unless lst\n  lst.sort!\
    \ # sort before comparing element\n  return nil unless lst.first\n  elsif lst.first\
    \ == lst.last\n    lst.pop\n  else\n    lst.shift\n  end\nend", "  lst.sort!\n\
    \  lst.first == lst.last ? nil : lst.first\nend", "  lst.sort.last || nil\nend",
  "  lst.sort.find { |x| x < lst[lst.index(x)] } ? nil : lst[lst.index + 1]\nend",
  "  lst.index(lst.min) + 1 if lst && lst.size > 0 && lst.count > 1\nend", "  smallest\
    \ = nil\n  lst.each do |i|\n    if smallest.nil?\n      smallest = i\n    elsif\
    \ i < smallest\n      smallest = i\n    end\n  end\n  return smallest\nend", " \
    \ return lst.min() if (lst.size == 1) || lst.min().nil? # don't call a method\
    \ on a nil object\n  lst.min() if (lst.size >= 2)\nend", "  lst.sort!\n  if lst.length\
    \ < 2\n    nil\n  else\n    first = lst[1]\n    lst[1] = nil\n    next\n  end\n\
    end", "  return nil unless lst.is_a?(Array) && lst.size > 0\n  smallest = lst[0]\n\
    \  lst[1] = nil\n  lst.delete_at(0)\n  lst.sort_by! { |item| item.abs }\n  lst.last.nil?\
    \ ? nil : lst.last\nend", "    return nil if lst.nil?\n    smallest = lst[0]\n\
    \    second_smallest = lst[1]\n    (lst.size > 2) and lst.slice(1, 2).each {|e|\
    \ smallest = e if e.lt smallest}\n    second_smallest == smallest ? nil : second_smallest\n\
    end\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nThis solution has a problem\
    \ when input array has only one element. `next_smallest.call([1,1])` returns nil\
    \ and it should be 1.\n<|/ c |>\n<| c |>\n: You are right. I thought that this\
    \ was a special case and did not include it in the answer, but you are right.\
    \ I'll edit the answer when I get back to my computer.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\n<code>", "  return nil unless lst.length\n  lst.sort!.first(1)[0]\nend",
  "  # Your code here\n  lst.each { |a| \n    if a > lst[0] \n      lst[1] = a\n \
    \     break\n    end \n  }\n  lst.shift if lst[1]\n  lst[1]\nend", "  lst.min_by(&:to_i).to_i\n\
    end", "  lst.delete_if { |v| v.nil? }\n  returning(lst.sort { |a, b| a.to_i <\
    \ b.to_i })[2] if lst.length != 0\n  nil\nend", "  if lst.length == 0\n    next\n\
    \  end\n  smallest = lst[0]\n  i = lst.index{|x| x <=> smallest}\n  lst.delete_at(i)\n\
    \  smallest\nend\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| c |>\nThanks for your\
    \ help and time. Still not getting it to work. Not sure if I'm doing something\
    \ wrong.\n<|/ c |>\n<| c |>\nAh, I see what you mean. The problem is that the\
    \ problem is that your function needs to return an `Integer` instead of `nil`.\
    \ So you'll need to do something like `lst.delete_at(i).min` or something. The\
    \ problem with that is that `min` doesn't actually change any values in the array.\
    \ You'll need to replace `lst.delete_at(i)` with `lst.delete_at(i).min`\n<|/ c\
    \ |>\n<| c |>\nThanks a lot for the help. That did it.\n<|/ c |>\n<| c |>\nThe\
    \ downside of this solution is that it will not work if the minimum element is\
    \ the first element in the array. It will also return nil if the array is empty.\n\
    <|/ c |>\n<| c |>\nCorrect. I was just fixing that. `nil` isn't an Integer, so\
    \ I made it return nil.\n<|/ c |>\n<| a dscore=1 tags=ruby |>\nThis is how I would\
    \ solve this problem:\n<code>", "  # Solution:\n  if lst.empty?\n    nil\n  else\n\
    \    lst.min_by(&:itself).next\n  end\nend", "  return nil if lst.length == 0\
    \ || lst.first == lst.last\n  lst.first.to_i < lst.last.to_i ? lst.shift(1) :\
    \ lst[1]\nend", "  size = lst.size\n  return nil if size <= 0\n  smallest = lst[0]\n\
    \  smallest_index = nil\n  lst.each_with_index do |value, index|\n    if value\
    \ < smallest\n      smallest = value\n      smallest_index = index\n    end\n\
    \  end\n  lst.delete_at(smallest_index)\n  smallest\nend\n</pre>", "  lst.min\
    \ # Return the 1st minimum\nend\n</cell>\n<code language=other-env>", "  if lst.empty?\n\
    \    nil\n  else\n    smallest = lst.min\n    lst.delete smallest\n    next_smallest(lst)\n\
    \  end\nend", "  sorted = lst.sort.reverse\n  smallest = sorted.first\n  smallest.nil?\
    \ ? nil : sorted.next\nend", "  lst.each do |el|\n    unless el == el[0]\n   \
    \   return el\n    end\n  end\n  nil\nend", "    smallest = lst[0]\n    secondSmallest\
    \ = nil\n    smallerCount = 1\n    largerCount = 1\n    secondSmallerCount = 1\n\
    \    smallestCount = 0\n    \n    smallestCount.times do\n        smallestCount\
    \ += smallest\n        secondSmallerCount += secondSmallest\n        if smallestCount\
    \ > secondSmallerCount\n            secondSmallest = smallest\n        end\n \
    \       if secondSmallest == nil && smallestCount > 0\n            smallest =\
    \ lst[smallestCount]\n            smallestCount = 1\n            secondSmallest\
    \ = nil\n        end\n        if secondSmallest == nil && smallestCount < lst.length\n\
    \            secondSmallest = lst[smallestCount]\n            smallestCount =\
    \ lst.length - 1\n            smallest = nil\n        end\n        if smallestCount\
    \ != 1\n            smallest = lst[smallestCount]\n            smallestCount =\
    \ 1\n            secondSmallest = nil\n        end\n    end\n    \n    smallestCount\n\
    end", "  raise 'no such element' if lst.empty?\n  lst.sort.reverse.first || nil\n\
    end", "  lst.sort.last || nil\nend", '  return nil unless lst', "  return nil\
    \ if lst.empty?\n  a_idx = lst.index { |x| x < lst[0] }\n  return nil if a_idx\
    \ == -1\n  lst.slice(a_idx+1)\nend", "  lst.min\nend", "  i = 0\n  loop do\n \
    \   return nil if i >= lst.length\n    i +=1\n    return lst[i+1] if lst[i] <\
    \ lst[i+1]\n  end\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI don't think that\
    \ \"smallest\" is the correct term here. \"Smallest\" doesn't necessarily mean\
    \ the smallest value, it may mean the smallest item according to some sorting\
    \ criteria.\n<|/ c |>\n<| c |>\nThis answer is wrong, since it returns the minimum\
    \ not the 2nd smallest. See's answer below for the correct implementation\n<|/\
    \ c |>\n<| c |>\nThanks for pointing that out. I've fixed the answer.\n<|/ c |>\n\
    <| c |>\n`return nil if i == lst.length` should probably be `return nil if i >=\
    \ lst.length`, otherwise you'll get an index out of bounds exception\n<|/ c |>\n\
    <| c |>\nAlso, why `i + 1` instead of `i+1` in the comparison?\n<|/ c |>\n<| a\
    \ tags=ruby,arrays dscore=3 |>\nIf you need to handle nil values as well, use:\n\
    <code>", "  return nil if lst.empty?\n  smallest = lst[0]\n  second_smallest =\
    \ smallest\n  \n  lst.delete_at(0) \n  lst.delete_at(0)\n  lst.delete_at(0)\n\
    \  lst.delete_at(0)\n  lst.delete_at(0)\n  lst.delete_at(0)\n  lst.delete_at(0)\n\
    \  lst.delete_at(0)\n  lst.delete_at(0)\n  lst.delete_at(0)\n  lst.delete_at(0)\n\
    \  lst.delete_at(0)\n  lst.delete_at(0)\n  lst.delete_at(0)\n  lst.delete_at(0)\n\
    \  lst.delete_at(0)\n  lst.delete_at(0)\n  lst.delete_at(0)\n  lst.delete_at(0)\n\
    \  lst.delete_at(0)\n  lst.delete_at(0)\n  lst.delete_at(0)\n  lst.delete_at(0)\n\
    \  lst.delete_at(0)\n  lst.delete_at(0)\n  lst.delete_at(0)\n  lst.delete_at(0)\n\
    \  lst.delete_at(0)\n  lst.delete_at(0)\n  lst.delete_at(0)\n  lst.delete_at(0)\n\
    \  lst.delete_at(0)\n  lst.delete_at(0)\n  lst.delete_at(0)\n  lst.delete_at(0)\n\
    \  lst.delete_at(0)\n  lst.delete_at(0)\n  lst.delete_at(0)\n  lst.delete_at(0)\n\
    \  lst.delete_at(0)\n  lst.delete_at(0)\n  lst.delete_at(0)\n  lst.delete_at(0)\n\
    \  lst.delete_at(0)\n  lst.delete_at(0)\n  lst.delete_at(0)\n  lst.delete_at(0)\n\
    \  lst.delete_at(0)\n  lst.delete_at(0)\n  lst.delete_at(0)\n  lst.delete_at(0)\n\
    \  lst.delete_at(0)\n  lst.delete_at(0)\n  lst.delete_at(0)\n  lst.delete_at(0)\n\
    \  lst.delete_at(0)\n  lst.delete_at(0)\n  lst.delete_at(0)\n  lst.delete_at(0)\n\
    \  lst.delete_at(0)\n  lst.delete_at(0)\n  lst.delete_at(0)\n  lst.delete_at(0)\n\
    \  lst.delete_at(0)\n  lst.delete_at(0)\n  lst.delete_at(0)\n  lst.delete_at(0)\n\
    \  lst.delete_at(0)\n  lst.delete_at(0)\n  lst.delete_at(0)", "  if lst.empty?\n\
    \    false\n  else\n    sorted = lst.sort\n    sorted.index(1)\n  end\nend", " \
    \ lst.sort!\n  \n  index = (lst.count - 1).succ\n  \n  if index == 0 \n    nil\n\
    \  else\n    lst[index]\n  end\nend", "  return lst.sort {|a, b| a <=> b }.first\
    \ if lst.length == 1\n  \n  # Using an index array and popping each element out\
    \ until we find the 2nd smallest\n  idx = [lst.index(a) - 1 for a in lst.sort\
    \ {|a, b| a <=> b }].min\n  \n  lst[idx]\nend\n</cell>\n<code language=julia-1.0>\n\
    function next_smallest(lst)\n  return lst.sort {|a, b| a <=> b }.first if lst.length\
    \ == 1\n  \n  # Using an index array and popping each element out until we find\
    \ the 2nd smallest\n  idx = [lst.index(a) - 1 for a in lst.sort {|a, b| a <=>\
    \ b }].min\n  \n  lst[idx]\nend\n</cell>\n<code language=julia-1.0>\nnext_smallest([1,\
    \ 2, 3, 4, 5])\n</cell>\n<code language=julia-1.0>\nnext_smallest([5, 1, 4, 3,\
    \ 2])\n</cell>\n<code language=julia-1.0>\nnext_smallest([])\n</cell>\n<code language=julia-1.0>\n\
    next_smallest([1, 1])\n</cell>\n<code language=julia-1.0>\n[next_smallest([1,\
    \ 2, 3, 4, 5]), next_smallest([5, 1, 4, 3, 2]), next_smallest([]), next_smallest([1,\
    \ 1])]\n</cell>\n<code language=julia-1.0>\nfunction next_smallest(lst)\n  return\
    \ lst.sort {|a, b| a <=> b }.first if lst.length == 1\n  \n  # Using an index\
    \ array and popping each element out until we find the 2nd smallest\n  idx = [lst.index(a)\
    \ - 1 for a in lst.sort {|a, b| a <=> b }].min\n  \n  lst[idx]\nend\n</cell>\n\
    <code language=julia-1.0>\n[next_smallest([1, 2, 3, 4, 5]), next_smallest([5,\
    \ 1, 4, 3, 2]), next_smallest([]), next_smallest([1, 1])]\n</cell>\n<code language=julia-1.0>",
  "    smallest, index =\n    if index == 0 then\n        smallest, index = nil, 0\n\
    \    else\n        smallest, index = lst[index - 1], index - 1\n    end", "  lst.sort!\n\
    \  if lst.size < 2\n    nil\n  else\n    lst[1]\n  end\nend", "  lst = lst.sort\n\
    \  lst.shift if lst.length <= 1\n  lst[0]\nend", "  return nil if lst.empty?\n\
    \  lst.sort.each_with_index do |value, i|\n    next unless value <= lst[i + 1]\n\
    \    lst[i] = nil\n    break\n  end\n  lst.pop if lst.empty?\nend", "  return\
    \ nil unless lst\n  smallest_index = 0\n  smallest = nil\n  index_of_smallest\
    \ = nil\n  index_of_smallest_index = 0\n  lst.each do |i|\n    if i == smallest\n\
    \      index_of_smallest = i\n      index_of_smallest_index = smallest_index\n\
    \    elsif i < smallest\n      smallest_index = smallest_index + 1\n      smallest\
    \ = i\n    end\n  end\n  return nil unless index_of_smallest_index\n  lst[index_of_smallest_index]\n\
    end", "  lst.sort.last\nend", "    return nil unless lst\n    \n    i = lst.size",
  "  return lst.include?(lst.first) ? lst.first : nil unless lst.empty?\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| a |>\n<code>\narray.min\n</code>\nis the most straightforward\
    \ way. \nHowever, if you have another requirement you just want to know the 2nd\
    \ smallest element, then sort the array (which is O(nlogn)) and return the second\
    \ element.\n<|/ a dscore=3 tags=ruby |>\n<| a tags=ruby |>\n<code>\narray.min_by(2)\n\
    </code>\nThis will return the 2nd smallest element of the array\n<|/ a dscore=3\
    \ |>\n<| a dscore=2 tags=ruby |>\n<code>\na = [10, 15, 17, 3, 8, 9]\na.select\
    \ {|i| a.count(i) > 1}.max\n</code>\n<|/ a |>\n<| a dscore=2 |>\nI thought this\
    \ was the only solution that worked for me. I needed to return the 2nd smallest\
    \ item from an array of objects in Ruby. I wanted a solution without sorting (although\
    \ I did test it and it was faster, but still).\n<code>", "  lst.sort\n  lst.each_with_index\
    \ do |value, i|\n    return value if i == 0 || value < lst[i - 1]\n  end\n  nil\n\
    end\n</cell>\n<code language=ruby-3>", "    return nil if lst.length <= 0\n  \
    \  \n    first = lst[0]\n    \n    next = (first + 1).succ\n    \n    lst[0] =\
    \ next\n    \n    next.succ\n    \n    next unless lst.include?(next)\n    \n\
    \    next\nend", "  smallest = nil\n  array.each_with_index { |e, i| next if i\
    \ < lst.size && !smallest  || smallest && e.to_i <=> smallest.to_i } || smallest\n\
    end", "  case lst\n  when nil\n    nil\n  else\n    arr.index(lst.min) + 2\n \
    \ end\nend\n</cell>\n<cell>", "    return nil if lst.length < 2\n    lst.min ==\
    \ lst[1]\nend", "  lst.sort.each_with_index do |val, i|\n    break if i == 0\n\
    \    break if val == lst[i-1]\n  end\n  lst.sort.last\nend\n</code>\n<|/ a tags=ruby\
    \ dscore=0 |>\n<| a |>\n<code>", "    smallest = lst.min\n    index = lst.index(smallest)\n\
    \    return index if index < lst.size\n    return nil\nend", "  return nil unless\
    \ lst\n  lst.each_with_index.reduce({}) do |result, pair|\n    (result[pair[0]]\
    \ = pair[1]) unless result[pair[0]].nil?\n    result\n  end.fetch(lst[0], nil)\n\
    end", "  if lst.size == 0\n    nil\n  else\n    lst[1]\n  end\nend", "  # Solution\n\
    \  lst.delete_at(0)\n  if lst.size == 0\n    return nil\n  else\n    lst.min\n\
    \  end\nend", "  lst.sort.reverse!\n  lst.min\nend\n</code>\n<|/ a dscore=4 |>\n\
    <| c |>\nThis is a great solution, but I feel compelled to point out that `lst.min`\
    \ requires Ruby 1.9, which many people may or may not have available right now.\n\
    <|/ c |>\n<| c |>\nThis fails for an empty array.  `arr = [1, 2, 3, 4]` returns\
    \ `nil` and not `4`.\n<|/ c |>\n<| a |>\n<code>", "  if lst.empty? or lst.size\
    \ == 0\n    nil\n  else\n    lst[0]\n  end\nend", "  return lst.find {|el| el\
    \ < lst.min && el != lst.min }\nend", "  smallest = nil\n  smallest = lst[0]\n\
    \  lst.each { |i| smallest = i if i < smallest }\n  smallest\nend", "  lst.sort!\n\
    \  lst.size == 0 ? nil : lst[1]\nend\n</code>\n<|/ a dscore=2 tags=ruby,ruby-on-rails,arrays\
    \ |>\n<| c |>\nJust a heads up: in Ruby 1.9, there are faster ways to do this\
    \ (for Ruby 1.9, you could use `Array#min_by`)\n<|/ c |>\n<| c |>\nYes. But that\
    \ would require Ruby 1.9. I am looking for an answer that would work in older\
    \ versions.\n<|/ c |>\n<| c |>\nThis algorithm is wrong. Try it with [1,2,3,4]\
    \ and [1,2,3]. Also, in ruby 1.9 you can write it as `lst.min_by(2)`\n<|/ c |>\n\
    <| c |>\nThat's a great point! I'll fix it.\n<|/ c |>\n<| c |>\nIn case you missed\
    \ my comment, `min_by` doesn't sort in-place. Try it: `a = [1,2,3]; a += a; p\
    \ a` outputs `[1,2,3,1,2,3,1,2,3]`.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,arrays\
    \ |>\n<code>", "  return nil if lst.empty?\n  lst.min do |x|\n    if x == lst.min\n\
    \      lst.min\n    else\n      next\n    end\n  end\nend", "  smallest = nil\n\
    \  for i in 0..lst.size - 1\n    return smallest.nil? ? i : smallest = lst[i]\n\
    \  end\nend", "  lst.sort!\n  return lst[1] if lst.length == 2\n  lst.shift\n\
    \  next_smallest(lst)\nend", "  lst.length == 1 ? nil : lst[1]\nend", "  smallest\
    \ = nil\n  smallest_index = nil\n  index = 0\n  \n  while index < lst.size\n \
    \   current = lst[index]\n    next =\n    if current < smallest\n      smallest\
    \ = current\n      smallest_index = index\n    end\n    index += 1\n  end\n  \n\
    \  if smallest_index\n    lst[smallest_index]\n  else\n    nil\n  end\nend", " \
    \ smallest = nil\n  smallest2 = nil\n  \n  \n  if lst.size <= 0\n    return nil\n\
    \  elsif lst.size <= 1\n    smallest = lst[0]\n    smallest2 = smallest\n  else\n\
    \    smallest2 = lst[0]\n    \n    \n    for i in lst.each_index\n      if smallest2\
    \ < lst[i]\n        smallest2 = lst[i]\n        smallest = lst[i]\n      end\n\
    \    end\n  end\n  smallest\nend\n  ", "  lst.shift if lst.size <= 1\n  lst.last.nil?\
    \ ? nil : lst.last\nend", "  return nil if lst.empty?\n  smallest, index =  lst.min_by(&:abs).last,\
    \ 1\n  while index < lst.size && smallest.abs < lst[index].abs\n    smallest,\
    \ index = lst[index], index + 1\n  end\n  return smallest\nend", "  if lst.nil?\n\
    \    nil\n  else\n    lst.first\n    loop do\n      smallest = lst.shift\n   \
    \   if smallest.nil?\n        return nil\n      end\n      if smallest < lst.first\n\
    \        lst.push(smallest)\n      else\n        return smallest\n      end\n\
    \    end\n  end\nend", "  smallest = lst[0]\n  smallest.succ\nend", '  return
    nil unless lst.length == 1', "    return lst.sort.take(2).first if lst.length\
    \ <= 2\n    arr1 = lst.sort.reverse\n    arr2 = arr1.take(2).reverse\n    if arr1.length\
    \ < arr2.length\n        return next_smallest(arr1)\n    else\n        return\
    \ arr2.first\n    end\nend\n</cell>\n<code language=julia-1.5>\nnext_smallest([2,\
    \ 1])\n</cell>\n<text>\nGreat! Now, our function next_smallest is complete. But\
    \ we can do better. Since we are going through all the elements, our function\
    \ will take a very long time to run.", "  return nil if lst.length < 2\n  a =\
    \ lst[1..-1]\n  a.each_with_index do |e, i|\n    return nil if e<a[1]\n    return\
    \ i if e<a[1]\n    return i if e<a[i-1]\n  end\nend", "  first = 1\n  last = lst.length\
    \ - 1\n  while first <= last\n    mid = (first + last) / 2\n    if lst.include?(mid)\n\
    \      last = mid\n    else\n      first = mid\n    end\n  end\n  lst[first]\n\
    end", "  return lst.sort.last(2).first if lst.length == 2\n  lst.sort.first\n\
    end", "  \n  lst.pop if lst.empty?\n  \n  lst.sort.drop(1).first\nend", "  return\
    \ nil if lst.length == 0\n  return lst[1] if lst.min < lst[1]\n  return nil\n\
    end", "  return lst.min_by(&:itself)\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\n\
    This is a really useful answer - although it might benefit from a bit more detail.\
    \ Like how does `it` work? How does `&:it` work? How can you do `min_by(&:itself)`\
    \ instead of `min_by(&:to_i)` so that you can get the index instead of the value?\n\
    <|/ c |>\n<| c |>\nIt might be worth mentioning that `min_by` was introduced in\
    \ Ruby v2.3.0.\n<|/ c |>\n<| c |>\nThe documentation explains it here: http://www.ruby-doc.org/core-2.3.1/Enumerable.html#method-i-min_by\n\
    <|/ c |>\n<| c |>\nYou can find some examples here: https://stackoverflow.com/questions/8261396/how-to-get-index-of-minimum-value-in-array\n\
    <|/ c |>\n<| c |>\nYep. My bad. I just went with the original post that used `to_i`,\
    \ then commented that it wouldn't work. Oh well. :)\n<|/ c |>\n<| a dscore=4 tags=ruby\
    \ |>\nHere is how you can do it in one line:\n<code>\n[1,2,3].max_by {|x| x}\n\
    </code>\nThe block passed as the argument to max_by returns the object you pass\
    \ to it (in this case the object) and it compares it to all other objects in an\
    \ array.\n<|/ a |>\n<| c |>\nThis is very inefficient. A very slow one for big\
    \ arrays.\n<|/ c |>\n<| c |>\nThat's why I love Ruby's `max_by` :)\n<|/ c |>\n\
    <| c |>\nIt's not so much that the implementation is inefficient as it is that\
    \ it performs an O(n) operation every time you call `max_by`, regardless of whether\
    \ you actually need to get the highest value.\n<|/ c |>\n<| c |>\nThis is not\
    \ O(n) as you might have thought when coming from a language that does optimize\
    \ for you. Remember that the array is iterated through once to determine the highest\
    \ value, and then once again to find the second highest and so on. O(n) is only\
    \ when you are performing operations on every object in the array.\n<|/ c |>\n\
    <| a dscore=3 tags=ruby |>\nHere's how I would do it:\n<code>", "  arr.sort.reverse.find\
    \ do |e|\n    e < arr.min\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n\
    You don't need `.sort.reverse` - just `.min`\n<|/ c |>\n<| c |>\n: That is true,\
    \ thanks. I was not aware of this method. Added it to the answer.\n<|/ c |>\n\
    <| c |>\nThis has two bugs. First, the `min` method will return the minimum value,\
    \ not the minimum index. Second, the block will return `nil` if there are no elements,\
    \ not the minimum value.\n<|/ c |>\n<| c |>\n: Actually, I tested it and it does\
    \ return `nil` if the array is empty. I will add this to the answer. Thanks for\
    \ the feedback.\n<|/ c |>\n<| c |>\nYeah, I see that now. I'm wondering how `min`\
    \ works internally - I haven't been able to figure it out (I only know that `min`\
    \ isn't a method on Enumerable). My guess is that it scans the entire array and\
    \ returns the minimum element at the end, but I wouldn't know what else to do\n\
    <|/ c |>\n<| a |>\nYou can use the Enumerable library to solve this. Here is a\
    \ simple example to illustrate how you might do this:\n<code>", "  smallest =\
    \ lst[0]\n  index = 1\n  while index < (lst.size - 1)\n    if smallest < lst[index\
    \ + 1]\n      smallest = lst[index + 1]\n    end\n    index += 1\n  end\n  if\
    \ lst.size == 1\n    nil\n  else\n    smallest\n  end\nend", "  return nil unless\
    \ lst\n  min_element = lst.min\n  index = lst.index(min_element)\n  return nil\
    \ if index == 0\n  lst[index + 1]\nend", "  smallest = nil\n  smallest = nil if\
    \ lst.empty?\n  lst.each_with_index do |value, index|\n    if smallest == nil\
    \ || value < smallest\n      smallest = value\n    end\n  end\n  smallest\nend",
  "  lst.sort.reverse.find { |el| el < lst.last }.to_i\nend\n</code>\n<|/ a tags=ruby\
    \ dscore=1 |>\n<| a dscore=1 tags=ruby |>\nThis is really easy with Array#index,\
    \ but that won't work if your array is not sorted.\n<code>\na = [5,2,4,6,3]\n\
    a.index{|x| x < a.last }\n=> 2 # note it returns nil if it finds nothing, not\
    \ a number\n</code>\nYou want this:\n<code>\na = [5,2,4,6,3]\na.sort.index{|x|\
    \ x < a.last }\n=> 2\n</code>\n<|/ a |>\n<| c |>\nYour solution works for array\
    \ without repetition. For example `a = [5,2,4,6,3]`\n<|/ c |>\n<| a |>\nYou can\
    \ use Ruby's Enumerable#min_by to find the minimum value in a sequence:\n<code>",
  "    lst = lst.sort.reverse\n    i = 0\n    while i < lst.length && lst[i] < lst[i+1]\n\
    \        i += 1\n    end\n    return lst[i]\nend", "  return nil if lst.empty?\n\
    \  a, b = lst[0], lst[0]\n  lst.delete(first)\n  lst.insert(first, b)\n  return\
    \ a if first < b\n  return b if first > b\n  return nil\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,arrays,ruby-on-rails-3\
    \ |>\n<| a |>\n<code>", "  return nil if lst.empty?\n  smallest = lst.min\n  \n\
    \  lst.each do |num|\n    return num if num > smallest\n  end\n  \n  return nil\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a |>\nThe below code is for getting next smallest\
    \ value in array in ruby \n<code>", "  return nil if lst.length <= 0\n  x = lst[0]\n\
    \  y = lst[1]\n  return x if y < x\n  lst[0] = y\nend", "  sorted_arr = lst.sort\n\
    \  return sorted_arr.first if sorted_arr.count > 1\n  return nil\nend", "  smallest_element,\
    \ index = nil, nil\n  lst.each_with_index do |item, i|\n    if smallest_element.nil?\
    \ || smallest_element > item\n      smallest_element, index = item, i\n    end\n\
    \  end\n  smallest_element\nend", "  smallest = nil\n  smallest = lst[0]", " \
    \ lst.each_with_index.\n    with_index { |(x, i), _| i > 0 &&\n              \
    \     (i < lst.size - 1) && (lst[i + 1] < x) }.\n    last.\n    first\nend", " \
    \ loop do\n    smallest = nil\n    smallest = lst.min\n    break if smallest.nil?\n\
    \    lst.delete_at(lst.index(smallest))\n  end\n  smallest\nend", "  smallest_idx\
    \ = 0\n  smallest_val = lst[0]\n  smallest_val_idx = smallest_val\n  lst.each_index\
    \ do |i|\n    if smallest_val < lst[i] then\n      smallest_val = lst[i]\n   \
    \   smallest_idx = i\n    end\n  end\n  return smallest_val\nend", "  arr = lst.sort\n\
    \  \n  arr.first\n  if arr.first == arr.last\n    nil\n  else\n    arr.second\n\
    \  end\nend", "  lst.sort.each_with_index do |e, i|\n    return e if i == 0\n\
    \    return e if e < lst[i-1]\n  end\n  return nil\nend", "  smallest = nil\n\
    \  smallest_index = nil\n  lst.each do |number|\n    if smallest.nil? or smallest.last\
    \ < number\n      smallest_index += 1\n      smallest = number\n    end\n  end\n\
    \  return smallest\nend\n</code>\n<|/ a tags=ruby,arrays,sorting,algorithm,ruby-on-rails\
    \ dscore=0 |>\n<| c |>\nYou do not need `smallest_index += 1`, this line does\
    \ nothing.\n<|/ c |>\n<| c |>\nOh ok. Thanks for the heads up!\n<|/ c |>\n<| a\
    \ tags=ruby,arrays,sorting,algorithm,ruby-on-rails |>\nO(nlogn)\n<code>", "  return\
    \ nil if lst.nil?\n  \n  first = lst.first\n  return nil if first > first.next\n\
    \  \n  lst.shift until lst.empty? || lst.first.next > first \n  \n  return first\n\
    end", "  lst.shift if lst.size > 0\n  return nil unless lst.length\n  lst.shift\n\
    end", "  # your code goes here\n  return nil if lst.empty?\n  smallest = lst.min\n\
    \  second = lst.find {|x| x < smallest }\n  second if second\nend\n</code>\n<|/\
    \ a dscore=0 |>\n<| c |>\nPlease don't use backticks for inline code, use 4 spaces\
    \ instead\n<|/ c |>\n<| a |>\nI wrote this Ruby code to find the minimum value\
    \ in an array with two conditions:", "  lst = lst.sort\n  return(lst[1..-1].min)\n\
    end", "  return nil if (lst.nil?)\n  result = lst.shift\n  result.nil? ? next_smallest(lst)\
    \ : result\nend\n</code>\n<|/ a tags=arrays,ruby,ruby-on-rails,algorithm |>\n\
    <| a dscore=1 tags=arrays,ruby,ruby-on-rails,algorithm |>\n<code>", "  lst.sort.first\n\
    end", "  lst.min == lst.max ? nil : lst.max\nend", "  return nil unless lst.size\
    \ == 1\n  smallest = lst[0]\n  second = nil\n  lst.each_with_index do |n, i|\n\
    \    return second if n == smallest\n    second = smallest\n    smallest = n\n\
    \  end\nend", "  return nil if lst.nil?\n  lst.sort { |x, y| y <=> x }[2]\nend",
  "  return nil if lst.size == 0\n  smallest = lst[0]\n  lst[0] = nil\n  lst[1] =\
    \ nil\n  lst.each_with_index { |e, i|\n    next unless e > smallest\n    smallest\
    \ = e\n    lst[i] = nil\n  }\n  smallest\nend", "  return lst.first if lst.size\
    \ >= 2\n  return nil if lst.size == 0\n  a = lst.first\n  lst.delete(a)\n  lst.shift\n\
    \  a\nend", "  smallest_val = lst.min\n  smallest_idx = lst.index(smallest_val)\n\
    \  next_val = lst[smallest_idx+1]\n  return next_val if next_val\n  return nil\n\
    end", "    arr.each { |x| arr.delete(x) }\n    arr.delete_if { |x| x < arr.first\
    \ }\n    arr.first\nend", "  arr.sort!\n  if arr.empty?\n    nil\n  else\n   \
    \ arr.shift\n    arr.shift\n  end\nend", "    sorted_arr = lst.sort\n    sorted_arr.first\n\
    end", "  lst.sort_by!(&:to_i).shift\nend", "  smallest = nil\n  smallest_idx =\
    \  0\n  lst.reverse_each do |e|\n    if smallest_idx > 0\n      smallest_idx -=\
    \ 1\n      return e if e < lst[smallest_idx]\n    end\n    smallest = e\n    smallest_idx\
    \ = lst.index(e)\n  end\n  return smallest\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nPlease explain your answer. How is this better than OP's original method?\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>", "  lst[0] < lst[1] and lst[0] < lst[2] and\
    \ lst[0] < lst[3] and lst[0] < lst[4] and lst[0] < lst[5] and lst[0] < lst[6]\
    \ and lst[0] < lst[7] and lst[0] < lst[8] and lst[0] < lst[9] and lst[0] < lst[10]\
    \ and lst[0] < lst[11] and lst[0] < lst[12] and lst[0] < lst[13] and lst[0] <\
    \ lst[14] and lst[0] < lst[15] and lst[0] < lst[16] and lst[0] < lst[17] and lst[0]\
    \ < lst[18] and lst[0] < lst[19] and lst[0] < lst[20] and lst[0] < lst[21] and\
    \ lst[0] < lst[22] and lst[0] < lst[23] and lst[0] < lst[24] and lst[0] < lst[25]\
    \ and lst[0] < lst[26] and lst[0] < lst[27] and lst[0] < lst[28] and lst[0] <\
    \ lst[29] and lst[0] < lst[30] and lst[0] < lst[31] and lst[0] < lst[32] and lst[0]\
    \ < lst[33] and lst[0] < lst[34] and lst[0] < lst[35] and lst[0] < lst[36] and\
    \ lst[0] < lst[37] and lst[0] < lst[38] and lst[0] < lst[39] and lst[0] < lst[40]\
    \ and lst[0] < lst[41] and lst[0] < lst[42]\nend", "  return nil if lst.empty?\n\
    \  lst[0] <= lst[1] ? lst[0] : next_smallest(lst.drop(1).take(2))\nend", "  return\
    \ nil if lst.length == 0 || !lst.empty?\n  return nil if lst.length == 1", " \
    \ smallest = lst.sort\n  smallest.first\nend\n</code>\n<|/ a dscore=2 tags=sorting,ruby\
    \ |>\n<| c |>\nSorting is O(n log n), but this isn't the right way to do it. \
    \ You need to find the largest element in the array first, then use binary search\
    \ to find the second smallest.\n<|/ c |>\n<| c |>\nI think you misunderstood me.\
    \ As far as I understand it, he is looking for an algorithm that returns the 2nd\
    \ smallest element of an array, not necessarily a sorted array, and I believe\
    \ the algorithm above does exactly that. Unless I misunderstood his question :)\n\
    <|/ c |>\n<| c |>\nI assumed a sorted array was sufficient to satisfy the requirements.\
    \  Binary search is not necessary when the first element is a candidate for the\
    \ minimum.\n<|/ c |>\n<| a tags=sorting,ruby |>\nA variation on Tim's answer that\
    \ might be faster (less comparisons):\n<code>", "  if lst.length < 2\n    nil\n\
    \  else\n    lst.sort!\n    lst[1] = nil\n    return lst[1]\n  end\nend", "  lst.each\
    \ do |i|\n    break if i > lst[-1]\n  end\n  lst[-1]\nend", "  lst.sort.reverse_each.pop.first\
    \ if lst\nend", "  return nil if (lst.empty?)\n  a = lst[0]\n  b = lst[1]\n  if\
    \ a < b\n    b\n  else\n    a\n  end\nend", "  return nil if lst.empty?\n  min\
    \ = lst.min\n  next_min = nil\n  lst.each_with_index do |el, i|\n    return nil\
    \ if el == min\n    next_min = el if el < min\n    min = el\n  end\n  next_min\n\
    end", "  lst.sort!\n  \n  index = 1\n  \n  while index < lst.size\n    return\
    \ nil if lst[index] > lst[index + 1]\n    \n    index += 1\n  end\n  \n  nil\n\
    end", "  if lst.length == 0 or lst.size == 1\n    nil\n  else\n    lst.sort\n\
    \    smallest = lst[1]\n    lst.remove(smallest)\n    smallest\n  end\nend", " \
    \ lst.each_with_index do |e, i|\n    return nil if i == 0\n    return e if e <\
    \ lst[i]\n  end\n  nil\nend\n</cell>\n<cell>", "  l = lst.sort\n  n = l[1..-2]\n\
    \  return n[0] if n.size && n[0] && l[1] < n[0] end\nend", "  lst.empty? ? nil\
    \ : lst.shift\nend", "  lst.sort\n  lst.shift if lst.size == 1\n  lst.shift\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThis is extremely inefficient as `sort` will\
    \ create a whole new array and copy all the elements.\n<|/ c |>\n<| c |>\nYes,\
    \ I thought about using `shift`, but then I realised that OP wanted the second\
    \ smallest number. `shift` moves the element, and doesn't really matter if it's\
    \ in the first or last position. And I haven't been working on Ruby for a while\
    \ - I realised `sort` will create an unnecessary array (and copied all the elements)\
    \ in the first place.\n<|/ c |>\n<| a |>\nYou could sort the array using sort_by.\
    \ Then take the first two elements of the sorted array. \n<code>\nmy_array = [10,\
    \ 1, 3, 4, 5]", "  lst.sort\n  puts lst.index(1)\nend", "  lst.each {|i| return\
    \ i unless i.nil? }\n  nil\nend", "  lst.sort_by!(&:first).first(2)\nend\n</cell>\n\
    <code language=julia-0.4>\nfunction next_smallest(lst)\n    smallest = lst.first\n\
    \    \n    for num in lst.second\n        if num < smallest\n            smallest\
    \ = num\n        end\n    end\n    \n    smallest\nend\n</cell>\n<code language=julia-0.4>\n\
    [next_smallest(lst) for lst in lst_array]\n</cell>\n<text>\n3. Sort an array in\
    \ place\n3.1 Ruby way\nRuby arrays are mutable, meaning that if you change their\
    \ elements, you are actually changing the data they contain.", "  lst.sort.last\n\
    end", "  sorted_lst = lst.sort\n  return sorted_lst.shift if sorted_lst.length\
    \ > 0\n  nil\nend\n</cell>\n<code language=julia-1.0>\n@test next_smallest([5,\
    \ 1, 4, 3, 2]) == 2 \n</cell>\n<text>\n4. Minimum Element in a Stream", "  lst.shift\
    \ while lst.first && lst.last.first < lst.first.value\n  lst.last.last if lst.size\
    \ >= 2\nend\n</code>\nA couple things I wanted to point out are that you should\
    \ not use an enumerator to go through the list as this could cause the list to\
    \ be modified during the loop. This makes it a little trickier to keep track of\
    \ the index.\nAnother thing I want to point out is that you should not use a while\
    \ loop for this problem as this can cause the problem to run forever in some cases.\
    \ If you do use a while loop then make sure that your return statement is outside\
    \ of the loop otherwise it will always return nil.\n<|/ a dscore=2 tags=ruby |>\n\
    <| c |>\nI didn't know about `first` and `last`.  That's awesome!\n<|/ c |>\n\
    <| a |>\n<code>", "  if lst.size < 2\n    return nil\n  else\n    smallest = lst[0]\n\
    \    second_smallest = lst[1]", "  lst.each_with_index do |el, i|\n    if i ==\
    \ 0\n      el\n    else\n      if el < lst[i - 1]\n        el\n      else\n  \
    \      lst[i]\n      end\n    end\n  end\nend", "  return lst.first([1..-1].min)\
    \ if lst.length != 0\nend", "    smallest = lst[1]\n    i = 0\n    if lst.count\
    \ > 2\n        while i < lst.count\n            if lst[i] == smallest\n      \
    \          return smallest\n            end\n            i += 1\n        end\n\
    \    else\n        return nil\n    end\nend", "  lst.reverse.find { |x| x < lst.first\
    \ }\nend", "  if lst.size < 2\n    lst\n  else\n    lst.sort[1]\n  end\nend",
  "  lst.sort.reverse.first\nend", "  if lst.nil?\n    nil\n  else\n    lst.sort!\n\
    \    lst.shift if lst.size < 2\n  end\nend\n</code>\nIn case you wonder, Ruby\
    \ doesn't have nil type, so nil.size will raise an error. The above code returns\
    \ nil if there is no such element.\n<|/ a dscore=2 |>\n<| c |>\nThe above code\
    \ is to find the 2nd smallest element in an array. I think you need to sort it\
    \ in descending order first. Also I think you need to return nil if there is no\
    \ such element.\n<|/ c |>\n<| c |>\n, you're absolutely right. I edited my answer\
    \ to reflect all your comments.\n<|/ c |>\n<| a tags=ruby dscore=1 |>\nUse Ruby's\
    \ built-in enumerators:\n<code>", "  lst.sort { |a,b| a <=> b }\n  lst[1]\nend",
  "  # Your code here.\n  return nil\nend", "  return lst.min_by(2) { |x| x } if lst.length\
    \ != 0\n  nil\nend", "  return nil if lst.length <= 1\n  smallest = lst[0]\n \
    \ smallest = 1\n  i = 2\n  while i < lst.length\n    if smallest > lst[i]\n  \
    \    smallest = lst[i]\n    end\n    i += 1\n  end\n  smallest\nend", "  lst.each\
    \ { |x| break if x < x }\n  lst.shift\nend\n</code>\n<|/ a tags=ruby |>\n<| c\
    \ |>\nI love the use of `break`.\n<|/ c |>\n<| c |>\nYou could have used `x.succ`,\
    \ which is more readable and possibly more efficient, but `break` is more expressive\
    \ and probably faster.\n<|/ c |>\n<| c |>\nThanks, I just updated the answer to\
    \ reflect that. Also, thanks for mentioning `succ`; I didn't know that one.\n\
    <|/ c |>\n<| a tags=ruby dscore=3 |>\nYou could also use a comparison operator\
    \ for sort:\n<code>\narray.sort{ |a, b| a <=> b }[1]\n</code>\n<|/ a |>\n<| c\
    \ |>\nI love this one.  Especially as it keeps all the code within the block where\
    \ it belongs.\n<|/ c |>\n<| a tags=ruby dscore=3 |>\nRuby's sort method has an\
    \ optional argument to allow you to specify the number of elements to compare.\
    \ Here's how you can sort a list without using extra methods:\n<code>\nnumbers\
    \ = [7, 2, 5, 3, 7, 9, 3, 9, 5, 9, 2]"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
