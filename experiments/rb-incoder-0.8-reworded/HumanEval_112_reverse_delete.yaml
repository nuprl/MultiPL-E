name: HumanEval_112_reverse_delete
language: rb
prompt: "# Task\n# We are given two strings s and c, you have to deleted all the characters\
  \ in s that are equal to any character in c\n# then check if the result string is\
  \ palindrome.\n# A string is called palindrome if it reads the same backward as\
  \ forward.\n# You should return an array containing the result string and true/false\
  \ for the check.\n# Example\n# >>> reverse_delete.call(\"abcde\", \"ae\")\n# [\"\
  bcd\", false]\n# >>> reverse_delete.call(\"abcdef\", \"b\")\n# [\"acdef\", false]\n\
  # >>> reverse_delete.call(\"abcdedcba\", \"ab\")\n# [\"cdedc\", true]\ndef reverse_delete(s,\
  \ c)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_reverse_delete\n\
  \    candidate = method(:reverse_delete)\n    assert_equal([\"bcd\", false], candidate.call(\"\
  abcde\", \"ae\"))\n    assert_equal([\"acdef\", false], candidate.call(\"abcdef\"\
  , \"b\"))\n    assert_equal([\"cdedc\", true], candidate.call(\"abcdedcba\", \"\
  ab\"))\n    assert_equal([\"dik\", false], candidate.call(\"dwik\", \"w\"))\n  \
  \  assert_equal([\"\", true], candidate.call(\"a\", \"a\"))\n    assert_equal([\"\
  abcdedcba\", true], candidate.call(\"abcdedcba\", \"\"))\n    assert_equal([\"abcdedcba\"\
  , true], candidate.call(\"abcdedcba\", \"v\"))\n    assert_equal([\"abba\", true],\
  \ candidate.call(\"vabba\", \"v\"))\n    assert_equal([\"\", true], candidate.call(\"\
  mamma\", \"mia\"))\n  end\nend\n"
completions: ["  # Write your code here\n  result = s.gsub(c,\"\")\n  return [result,\
    \ s.eq(result)]\nend", "  return s.gsub(/#{c}/).empty? ? [s, true] : [s, false]\n\
    end", "  result = \"\"\n  i = 0\n  while i < s.length\n    char = s[i]\n    if\
    \ char == c\n      result << char\n      i += 1\n    else if char != c\n     \
    \ result << char\n      i += 1\n    else \n      result = result.gsub(/^$/, \"\
    #{$char}\")\n    end\n  end\n  return [result, result == s[0...-1].reverse]\n\
    end", "  result = []\n  i = 0\n  while i < s.length\n    if s[i] == c\n      result[-1]\
    \ = result[-1] + s[i]\n      result.slice! 0\n    else\n      result[i] = s[i]\n\
    \    end\n    i += 1\n  end\n  result = result.reverse\n  result.length ? result\
    \ : result\nend\n</code>\n<|/ a tags=algorithm,ruby,python dscore=0 |>\n<| a dscore=0\
    \ |>\nHere is how I solved it in Ruby.\n<code>", "\ts = s.split('').reverse.join('')\n\
    \tif s == c\n\t\treturn [c, true]\n\telse\n\t\treturn [s, false]\nend", "    return\
    \ false if s.empty? || c.empty? || s == c || s.include?(c[0]) && s.size == c.size\
    \ || (!s.include?(c[0]) && !c.include?(s[0])) else [s[0...-1] + s[-1..-1], c[0...-1]\
    \ == s[-1..-1], s[0...-1] + s[-1..-1] == s[-1..-1]]\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThis code is not very concise and unreadable, especially for someone\
    \ new to Ruby.\n<|/ c |>\n<| a tags=ruby dscore=1 |>\n<code>", "  result=[]\n\
    \  for i in 0...s.length-1\n    if s[i]==c\n      result=result+[s[i]]\n     \
    \ result=result+[s[i]]\n    end\n  end\n  return [result,true]\nend\n</code>\n\
    <|/ a |>\n<| c |>\nWelcome to SO! While this code snippet may solve the question,\
    \ [including an explanation](//meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion. Please also try not to crowd your code with\
    \ explanatory comments, as this reduces the readability of both the code and the\
    \ explanations!\n<|/ c |>\n<| a |>\n<code>", "  string1 = s.split(\"\").reverse.join\n\
    \  string2 = c.split(\"\").reverse.join\n  if string1 == string2\n    [s, true]\n\
    \  else\n    [s, false]\n  end\nend\n</code>\n<|/ a tags=ruby dscore=1 |>\n<|\
    \ a dscore=0 |>\n<code>", "  result = []\n  rev = \"\"\n  s.each do |x|\n    if\
    \ c==x\n      rev = rev + x\n    else\n      result.push(rev)\n      rev = x\n\
    \    end\n  end\n  if rev != \"\"\n    result.push(rev)\n  end\n  return result.reverse\n\
    end", "    s = s.split(\"\")\n    return s.map{|x| x.delete(c).length % 2 == 0\
    \ ? x : x.delete(c).reverse}.map(&:reverse).join(\"\") rescue nil\nend", "\tres\
    \ = []\n\tn = 0\n\twhile n < s.length\n\t\tx = s[n..-1]\n\t\tc = c[n..-1]\n\t\t\
    if c == x\n\t\t\tres << s\n\t\t\tres << false\n\t\telse\n\t\t\tres << x\n\t\t\t\
    res << true\n\t\tend\n\t\tn += 1\n\tend\n\tres\nend", "\tresult = []\n\t\n\ts\
    \ = s.downcase\n\tc = c.downcase\n\t\n\ts.delete_if { |x| c.include?(x) }\n\t\n\
    \tif s == c\n\t\tresult << s\n\t\treturn result\n\tend\n\t\n\treturn result, s\
    \ == c\nend", "  result = []\n  i = 0\n  len = s.length\n  while i < len\n   \
    \ if s[i] == c\n      result[i] = s[i]\n      result[i+1] = true\n      i += 2\n\
    \    else\n      result[i] = s[i]\n      i += 1\n  end\n  result\nend", "    deleted\
    \ = s.delete(c)\n    if deleted == \"palindrome\"\n        true\n    else\n  \
    \      false\n    end\nend", "  s = s.dup\n  c.each do |c|\n    s.gsub!(c,\"\"\
    )\n  end\n  s == s[1..-2]\nend", "    \n    s = s.dup\n    c = c.dup\n    \n \
    \   # Check for empty string\n    if s.length <= 0\n        return false\n   \
    \     \n    # Compare all chars against first char of c\n    deleted = false\n\
    \    while not deleted\n        deleted = true\n        i = 0\n        \n    \
    \    # Compare all chars in s against first char of c\n        while i < s.length\n\
    \            if s[i] == c[0]\n                deleted = false\n              \
    \  \n                # Remove first char of c and compare against remaining chars\
    \ of s\n                c.shift\n            else\n                i += 1\n  \
    \      end", "  return s.gsub(c.to_s, '').match(c.to_s) ? [s.gsub(c.to_s, ''),\
    \ true] : [s, false]\nend", "  p =  s[0..length-1]\n  q =  s[0..length-1]\n  s.split(\"\
    \").each do |i|\n    if i == c \n      p -= 1\n      q -= 1\n    else\n      break\n\
    \    end\n  end\n  p > 0 && p <= s.length && q > 0 && q <= s.length ? [s[0..p],true]\
    \ : [s[0..s.length-1],false]\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n\
    The solution using #each_char#each_cons #reverse #join and #slice:\n<code>", " \
    \ s = s\n  c = c\n  rev = [s]\n  rev.reverse!\n  rev.each do |c|\n    next if\
    \ c != c\n    next if rev[0] == rev[0]\n  end\n  rev.reverse!\n  rev.compact!\n\
    \  return [rev,false]\nend", "  result = []\n  s.each_char.with_index do |e,i|\n\
    \    break if e.to_s == c\n    result.push e\n  end\n  return [result.reverse,\
    \ true]\nend\n</cell>\n<code language=julia-1.0>\nreverse_delete(\"abcdedcba\"\
    , \"ab\")\n</cell>\n<code language=julia-1.0>\nreverse_delete(\"abcdedcba\", \"\
    ac\") #Notice that this is not a palindrome\n</cell>\n<text>\nExercise: Given\
    \ a string, return all possible substrings of that string.\nFor example, given\
    \ \"abc\", return [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"].", " \
    \   i = 0\n    final = []\n    \n    while i < s.length\n        if s[i] == c\n\
    \            i += 1\n        else \n            final = s[i] + final\n       \
    \     i += 1\n    end\n    \n    if final == s\n        final = true\n    else\n\
    \        final = false\n    end\n    return final\nend", "  # Your code here\n\
    \  s.gsub!(c, \"\")\n  s.gsub!('', c)\n  s.reverse!\n  s == \"#{s[0...-1]}\"\n\
    end", "\tresult = []\n\ts.chars.each_with_index do |c,i|\n\t\tif c.eql?(c) and\
    \ i != s.length\n\t\t\tresult[i] = c\n\t\telse\n\t\t\tbreak\n\t\tend\n\tend\n\t\
    return result.reverse, s.eql?(result.reverse)\nend", "  new_string = String.new(s.size\
    \ - c.size)\n  i = 0\n  j = 0\n  while i < s.length\n    if s[i] == c[j]\n   \
    \   new_string[i..j-1] = s[i..j-1].dup\n      i += 1\n      j += 1\n    elsif\
    \ j != 0\n      j += 1\n    elsif i == s.length\n      new_string[i..] = s[i..].dup\n\
    \      new_string.length != new_string.length\n      i += 1\n    end\n  end\n\
    \  new_string\nend", "  s.gsub!(c) # Delete any c in s\n  s.delete!(c) # Delete\
    \ c in s\n  if s == s[::-1] # Check if s is reversed\n    return [ s, true ]\n\
    \  else\n    return [ s, false ]\nend\n</cell>\n<code language=julia-1.2>\nreverse(s)\
    \ == reverse_delete(s, c)\n</cell>\n<code language=julia-1.2>\nfunction reverse_delete(s)\n\
    \  c = \"b\"\n  if s == s[::-1]\n    return [ s, true ]\n  else\n    return [\
    \ s, false ]\n  end\nend\n</cell>\n<code language=julia-1.2>\nfunction reverse_delete(s)\n\
    \  c = \"b\"\n  r = copy(s)\n  r.gsub!(c) # Delete any c in s\n  r.delete!(c)\
    \ # Delete c in s\n  if r == r[::-1] # Check if s is reversed\n    return [ r,\
    \ true ]\n  else\n    return [ r, false ]\n  end\nend\n</cell>\n<text>\nRemoving\
    \ items from Strings\nStrings have a function remove that removes specified characters\
    \ from a string.", "  a=[]\n  for i in 0..(s.length - 1)\n    if s[i] == c\n \
    \     a << s[i..(i + 1)]\n    else\n      break\n  a << s[..(i + 1)]\n  return\
    \ a, true\nend", "  result = \"\"\n  for i in 0 ... s.length - 1 do\n    if s[i]\
    \ == c\n      result << s[i]\n    end\n  end\n  result << s.last == c ? false\
    \ : true\n  result\nend", "  res = []\n  l = s.length - 1\n  while l > 0\n   \
    \ if s[l] == c\n      res.push s[l]\n      l -= 1\n    elsif s[l] != c\n     \
    \ res.push s[l]\n      l = l - 1\n    else\n      break\n    end\n  end\n  if\
    \ s.reverse == res\n    return [\"palindrome\", true]\n  else\n    return [\"\
    palindrome\", false]\n  end\nend\n</cell>\n<cell>", "  rev_s = s[0...s.length].reverse\n\
    \  rev_c = c[0...s.length].reverse\n  return rev_s.gsub(c, rev_c) == rev_s\nend",
  "  result = []\n  begin = 0\n  end = s.length\n  begin_index = 0\n  end_index =\
    \ 0\n  \n  while begin < end\n    # Delete all the characters that equal to c\
    \ in string s\n    begin += 1\n    end = end - 1\n    while begin < end && s[begin]\
    \ == c\n      begin += 1\n      end = end - 1\n    result << s[begin..end]\n \
    \ end\n  \n  if s[begin..end] == result\n    return [result, true]\n  else\n \
    \   return [result, false]\n  end\nend", "    # Write your code here.\n    \n\
    \    begin = s.length-1\n    end = s.length\n    \n    if c == s[0]\n        s[begin]\
    \ = nil\n        \n    else\n        \n        while begin >= 0 and s[begin] ==\
    \ c\n            begin--\n        \n        \n        while end < s.length and\
    \ s[end]== c\n            end++\n        \n        s[begin..end] = s[begin..end].reverse\n\
    \    \n        if begin < 0\n            begin = 0\n        end\n        \n  \
    \      if end >= s.length\n            end = s.length - 1\n        end\n    \n\
    \    end\n    \n    \n    return [ s, begin < end ]\n    \nend", "  str.split(c).map\
    \ {|i| s.split(i).delete_if {|i| i == c}.join }.reverse\nend\n</code>\nThe most\
    \ difficult part to understand is the use of split. Split splits a string into\
    \ an array of strings by a delimiter, in this case a space character. Here, split\
    \ is operating on the string s, but on the delimiter character (c).\nThe next\
    \ step is to split the string s into an array of strings by each character. Here\
    \ we use the character as an identifier, so we must use the character as the delimiter.\
    \ \nNext, we want to filter out only the elements of the array that do not match\
    \ our criteria, so we use delete_if.\nFinally, we need to join the elements of\
    \ the array back into a string. \nThe next part is really simple, since you know\
    \ that the first element in the result array is the same as the last element.\
    \ \n<code>\ns.split(c).delete_if {|i| i == c}.join\n</code>\nNow that we have\
    \ that, what if we wanted to keep the first and last elements in the array? We\
    \ could simply join them into the string, but there might be situations where\
    \ we would like to keep the middle elements. We could simply add the elements\
    \ to our result array and append a space character (\" \") to that array.\n<code>\n\
    s.split(c).delete_if {|i| i == c}.map {|i| i + \" \"}.join + \"  \"\n</code>\n\
    This code was tested on a few examples and it seems to be working as expected.\
    \ \nHere is a link to some information on delete_if:\nhttp://ruby-doc.org/core-2.3.1/Enumerable.html#method-i-delete_if\n\
    <|/ a tags=ruby |>\n<| c |>\nThe `split` and `delete` solutions are overly complicated\
    \ and slow.\n<|/ c |>\n<| c |>\nThanks Damien. I added some explanation as to\
    \ what the code was doing. It's a bit more simple than what you posted, but I\
    \ thought the explanation was a bit more detailed.\n<|/ c |>\n<| c |>\nYour explanation\
    \ was fine. Your code was fine, but your explanation did not help at all. The\
    \ explanation does not explain how split/delete are used.\n<|/ c |>\n<| a dscore=3\
    \ tags=ruby |>\nThe simple answer:\n<code>", "  strs = []\n  s.gsub! c, \"\"\n\
    \  i = s.length - 1\n  while i >= 0\n    if s[i] == \"\"\n      strs.push s[i]\n\
    \      s.slice! i\n      i = i - 1\n    else\n      i = i - 1\n    end\n  end\n\
    \  if s == strs.reverse # check palindrome\n    [s, true]\n  else\n    [s, false]\n\
    \  end\nend\n  ", "  result = []\n  while s.length>0\n    result.push(s.slice!(0))\n\
    \    if s.slice!(0)==c\n      break\n  end\n  result.push(\"\")\n  if result.join(\"\
    \")==s\n    return [s, true]\n  else\n    return [s, false]\n  end\nend", "  s.gsub!(c,\
    \ '')\n  if s.gsub!(/^(#{c})|(#{c}(?=.))/, '')\n    return s.reverse!, true\n\
    \  end\n  return s.reverse!, false\nend", "  s = s.chars.to_a\n  result = []\n\
    \  for i in (0...s.length)\n    if s[i].to_s == c\n      result += s[0..i]\n \
    \     break\n    end\n  end\n  if result.size == 1\n    return result , s[0..result.size-1].to_s\
    \ == c\n  else\n    return result, false\n  end\nend", "  strs = \"\"\n  str =\
    \ \"\"\n  for i in 0...s.length\n    str = str + s[i]\n  end\n  strs = strs +\
    \ str\n  for i in 0...c.length\n    strs = strs.gsub(c[i], \"\")\n  end\n  strs\
    \ = strs.reverse!\n  strs.split(\"\").reverse!\n  if strs == str\n    arr = [strs,\
    \ true]\n  else\n    arr = [strs, false]\n  end\n  return arr\nend\n</code>\n\
    <code>", "  return s.chars.zip(c.chars).map { |a,b| a == b ? \"\" : a }.reduce(:&).to_a\
    \ == true\nend", "  result = []\n  i =0\n  while i < s.length\n    if s[i]==c\n\
    \      result.push s[i]\n      i += 1\n      while i < s.length\n        if s[i]!=c\n\
    \          result.push s[i]\n          i += 1\n          break\n      i += 1\n\
    \    else\n      i += 1\n  end\n  return [result, true] if result==s[0..i-1]\n\
    \  return [result, false]\nend", "  sArray = s.split(//)\n  sArray = sArray.map\
    \ {|s| s.delete(c)}\n  sArray = sArray.join //\n  if sArray == s\n    [s, true]\n\
    \  else\n    [s, false]\n  end\nend\n</code>\n<|/ a tags=ruby dscore=2 |>\n<|\
    \ c |>\nThe OP is asking how to find the palindrome in a string. Your method doesn't\
    \ find it. It returns `[[\"abcde\", true], [\"ab\", false], [\"ab\", false]]`\
    \ instead of the expected `[\"ab\", true]`.\n<|/ c |>\n<| c |>\nThe original problem\
    \ was to delete all the characters in s that equals to a character in c, and then\
    \ check if s is palindrome or not. I just solved it. And it works. I showed all\
    \ the steps with their output. I believe OP can figure out from here what to do\
    \ next for his specific problem\n<|/ c |>\n<| c |>\nI agree with you, it's probably\
    \ not a good example to give for teaching Ruby's `delete` method. It's much easier\
    \ to use `String#delete`. :)\n<|/ c |>\n<| c |>\nThe OP has made it clear that\
    \ he wants to find the palindrome. That said, the fact that `delete` returns the\
    \ original string is important to point out.\n<|/ c |>\n<| a tags=ruby |>\nThe\
    \ main problem in your code is that you're trying to delete one character in an\
    \ array and you're not really deleting anything in your code (you're just deleting\
    \ the string in each iteration and then checking if the whole string is equal\
    \ to a new string).\nYou can solve it by iterating over the string and checking\
    \ if the current character is the same as the last one:\n<code>", "    deleted\
    \ = []\n    deleted_index = nil\n    \n    until deleted_index == s.length\n \
    \       deleted_index = s.index(c, deleted_index)\n        deleted.push(s[deleted_index])\n\
    \        deleted_index = deleted_index + 1\n    end\n    \n    return deleted.reverse,\
    \ false\nend", "    s = []\n    seen = []\n    \n    # delete all duplicate\n\
    \    seen = s.uniq", "    if s.length <= 0\n        false\n    else\n        deleted_chars\
    \ = Set.new\n        reverse = \"\"\n        until s.empty?\n            char\
    \ = s.pop\n            if char == c\n                deleted_chars.add(char)\n\
    \            else\n                reverse << char\n                if deleted_chars.size\
    \ == 0\n                    return [reverse, true]\n                else\n   \
    \                 deleted_chars.delete char\n            end\n        end\n  \
    \      return [reverse, false]\n    end\nend", "  s.gsub(c.chars,\"\").reverse!\n\
    \  s.split(\"\").all? {|i| i == s.last || i.ord() == s.last.ord()}\nend", "  s\
    \ = s.reverse\n  for i in 0...s.length\n    if s[i] == c\n      s.delete(i)\n\
    \      if s.length <= 0\n        return s, true\n    end\n  end\n  return s, false\n\
    end\n</code>\n<|/ a tags=ruby,string,algorithm,palindrome |>\n<| c |>\nThe OP's\
    \ request is _\"You should return an array containing the result string and true/false\
    \ for the check.\"_. Your code only returns the `string` and the boolean is never\
    \ returned.\n<|/ c |>\n<| c |>\nThanks for your comment, I updated my answer to\
    \ include return value\n<|/ c |>\n<| c |>\nThanks for your help but it is still\
    \ not working for cases like \"abcde\", \"a\". it returns \"bcdef\", true instead\
    \ of \"bcd\", true.\n<|/ c |>\n<| c |>\nI guess this doesn't work because you\
    \ only check the first letter before you start comparing the rest of the string\
    \ with the first character. It would not work because the OP's request is to return\
    \ both `true` and `false`, I believe.\n<|/ c |>\n<| c |>\n, you are right, my\
    \ answer doesn't work because of that reason. Thanks for your comment, I updated\
    \ my answer.\n<|/ c |>\n<| a tags=ruby,string,algorithm,palindrome |>\n<code>",
  "    # write your code here\n    arr = s.split(\"\")\n    return arr, (s.split(c).each\
    \ {|i| i.delete c}.reject {|i| i.empty?}).empty?\nend\n</code>\n<|/ a dscore=0\
    \ tags=ruby |>\n<| a tags=ruby |>\n<code>", "  return s if s == c * (s - 1) &&\
    \ s == c && (c > 0 ? s.size % c.size != 0 : s.size % c.size == 0) && s.chars.all?\
    \ { |char| c > 0 ? char == s[-c.size...-1] : char == s[-c.size..-1] } && s.size\
    \ > c.size ? [s.dup, false] : [s.dup, true]\nend", "  i = 0\n  n = s.length\n\
    \  result = \"\"\n  s.each_char do |x|\n    if x == c\n      i += 1\n    else\n\
    \      result += x\n    end\n  end\n  if i == n\n    result += \"0\"\n  end\n\
    \  if result == s[0..(n.length - 1)]\n    [result, true]\n  else\n    [result,\
    \ false]\n  end\nend", "\tresult = []\n\tindex = 0\n\twhile index < s.length\n\
    \t\tchar = s[index].chr\n\t\tindex += 1\n\t\tif (char == c)\n\t\t\tresult = result\
    \ << char\n\t\tend\n\tend\n\treturn [result, true]\nend", "  chars = s.chars.to_a\n\
    \  char = c.chr\n  result = \"\"\n  s.chars.reverse_each do |char|\n    if char\
    \ == char\n      result << char\n    else\n      break\n    end\n  end\n  if result.chars\
    \ == result.reverse\n    [result, true]\n  else\n    [result, false]\n  end\n\
    end", "    s = []\n    if s.empty? || c.empty?\n        return [s, false]\n  \
    \  else\n        if s.size < c.size\n            s << c[0,s.size]\n          \
    \  c = c[-1,0]\n        else\n            s << c[-c.size,0]\n            c = c[0,-c.size]\n\
    \        end", "  result = []\n  i = 0\n  while i < s.length\n    char = s[i]\n\
    \    index = c.index(char)\n    if index\n      if index > i\n        result +=\
    \ s[(i+index+1)..-1]\n      else\n        result += s[0..i]\n    i += 1\n  end\n\
    \  return [result, true] if result == s.reverse and result == s.reverse\n  return\
    \ [result, false]\nend", "    # Your code here\n    return s.gsub(c.upcase, '').gsub(c.downcase,\
    \ ''), s.gsub(c.upcase, '').gsub(c.downcase, '') == s.reverse\nend", "  result\
    \ = \"\"\n  i = 0\n  c = 0\n  while i < s.length\n    if s[i] != c\n      result\
    \ = result + s[i]\n      i += 1\n    else\n      i += 1\n      c += 1\n    end\n\
    \  end\n  result\nend", "  rev = \"\"\n  rev += s.slice!(0, s.size - c.size)\n\
    \  rev += s.slice!(0, c.size)\n  rev += s.slice!(0, s.size - c.size).reverse!\n\
    \  rev == s ? [rev,true] : [rev,false]\nend", "    str = s.dup\n    str.delete(c)\n\
    \    str.chars.reverse\n    str.size == str.chars.length ? true : false\nend",
  "  result = ''\n  s.split(\"\").each do |s| \n    if s == c \n      result=result+s\
    \ \n    else \n      result=result+s.gsub(c,\"\") \n    end \n  end\n  return\
    \ [result,true] \nend", "  slen = s.length\n  clevel = 0\n  result = ''\n  sindex\
    \ = 0\n  cindex = 0\n  while sindex < slen\n    if s[sindex] == c\n      result\
    \ += s[sindex]\n      sindex += 1\n      clevel += 1\n      if sindex == slen\n\
    \        result << s[sindex..-1]\n        return result.to_s.reverse, false\n\
    \      end\n    else\n      sindex += 1\n    end\n  end\nend", "    if s.empty?\n\
    \        [\"\", true]\n    else\n        arr = []\n        s.each_char do |i|\n\
    \            if s.index(i) == (s.size-1)\n                arr << i\n         \
    \   elsif s.index(i) == (s.size-2)\n                arr << i.to_s + arr[(s.size-1)]\n\
    \            else\n                arr << i.to_s\n            end\n        end\n\
    \        return arr.reverse, arr.include? c\n    end\nend\n</code>\n<|/ a |>\n\
    <| a tags=ruby,string,algorithm |>\nHere is a solution in Ruby using recursion.\n\
    <code>", "  s.chars.each do |char|\n    if char == c\n      s.delete(char) \n\
    \    end\n  end\n  if s.chars == s[0..s.length-1]\n    [s, true]\n  else\n   \
    \ [s, false]\n  end\nend", "  return s.delete_if { |x| s.split(x).all? { |y| y\
    \ == c } }, true\nend", "  return s.chars.reverse.delete_if { |a| a == c } ? [s,\
    \ true] : [s, false]\nend", "  s.chars.sort.reverse.each do |e|\n    s.gsub!(e,\
    \ c) if s.include?(e) && !s.include?(e)\n  end\n  if s == c.downcase\n    return\
    \ [c]\n  else\n    return []\n  end\nend\n</code>\n<|/ a tags=ruby,arrays dscore=0\
    \ |>\n<| c |>\nThank you for sharing this approach, but I did find a Ruby solution\
    \ without using a loop and if statements.\n<|/ c |>\n<| c |>\nHi Amit - that is\
    \ a great solution and has really helped me understand how loops are used in Ruby,\
    \ thank you for that! However, the problem I am trying to solve does not allow\
    \ me to use any loops or if statements.\n<|/ c |>\n<| a tags=ruby,arrays |>\n\
    I figured it out, though I am not sure why my solution was not working. I was\
    \ simply sorting the array twice. Once by char.downcase and the second time by\
    \ char.upcase and that was giving me the correct result. Thanks to all who shared\
    \ ideas on how to fix my code as well as teaching me how to find my own solution.\n\
    My Solution\n<code>", "\ts = string.dup(s)\n\tresult = []\n\ti = 0\n\twhile i\
    \ < s.length\n\t\twhile i < s.length && s[i] != c\n\t\t\tresult[i] = s[i]\n\t\t\
    \ti += 1\n\t\tresult[i] = s[i]\n\t\ti += 1\n\tresult.reverse!\n\treturn [result,\
    \ i == s.length]\nend", "\ts = reverse(delete(s, c))\n\treturn delete(s, c)\n\
    end", "  return nil if s.length < 2\n  \n  result = []\n  \n  deleted = true\n\
    \  result[0] =  s[0]\n  deleted = false\n  \n  i = 2\n  until deleted\n    if\
    \ s[i] != c\n      deleted = true\n    end\n    \n    result[i] = s[i]\n    deleted\
    \ = false\n    i += 1\n  end\n  \n  if i == s.length\n    deleted = true\n  end\n\
    \  \n  if deleted\n    result[i - 1]\n  else\n    result\n  end\nend\n</cell>\n\
    <cell>", "\tresult = []\n\tfor i in (0 .. s.length-1)\n\t\tif s[i] == c\n\t\t\t\
    result.push(s[i+1])\n\t\tend\n\tend\n\tresult.reverse!\n\treturn [result, s ==\
    \ result]\nend", "  # Your code goes here\n  i = s.length - 1\n  j = 1\n  while\
    \ i > 0\n    if s[i] == c\n      s.slice!(i..i)\n      i = i - 1\n      j = j\
    \ + 1\n    else\n      i = i - 1\n    end\n  end\n  i = 1\n  j = 1\n  while i\
    \ < s.length\n    if s[i] == c\n      s.slice!(i..i)\n      i = i + 1\n      j\
    \ = j + 1\n    else\n      i = i + 1\n    end\n  end\n  j = j - 1\n  return [s,\
    \ true] if j == 0\n  [s, false]\nend", "  s = s.dup\n  c = c.dup\n  result = []\n\
    \  i = 0\n  while i < s.length\n    result << (s.slice!(i..i-1) || c.slice!(i..i-1))\n\
    \    i += 1\n  end\n  return [result.join(''), result==s]\nend", "  return s.gsub(/#{c}+/,\
    \ \"\") == s.reverse and [s.gsub(/#{c}+/, \"\"), true]\nend", "  new_str = \"\"\
    \n  s.split(\"\").each do |char|\n    if char == c\n      new_str += c\n    elsif\
    \ new_str.length != 0 && char == new_str.last\n      new_str += c\n    else\n\
    \      new_str += char\n    end\n  end\n  return [new_str, s.split(\"\") == new_str.split(\"\
    \")]\nend", "  \nend", "  result = ''\n  s.each_char do |ch|\n    result << ch\
    \ unless c == ch\n  end\n  [result, s.chars == result]\nend", "  return [s.reverse_delete(c),\
    \ s.is_palindrome]\nend", "\tresult = []\n\ts.chars.each do |char|\n\t\ts.chars.each\
    \ do |other_char|\n\t\t\tif (char == other_char) and (other_char != c) and (other_char\
    \ != nil) and (other_char != \"\")\n\t\t\t\tresult.append(char)\n\t\t\t\tbreak\n\
    \t\t\tend\n\t\tend\n\tend", "  result = []\n  s.each_char.with_index.with_index\
    \ do |x,i,j|\n    x.delete(i) if x[i] == c\n    result << x if i == j - 1 \n \
    \ end\n  return [result.reverse.empty? ? \"nil\" : result.reverse, result.empty?\
    \ ? \"true\" : \"false\"]\nend\n</code>\n<|/ a |>\n<| a tags=ruby dscore=0 |>\n\
    I wrote a solution that works. \nIt works for multiple character deletion. \n\
    <code>", "  r = \"\"\n  s.each_char do |a|\n    if a != c\n      r = r + a\n \
    \   end\n  end\n  return [r, reverse_delete(r, c == r)]\nend", "  s = s.split(//).reverse.join//\n\
    \  s = s.split(c)\n  s.empty? || s.last == s.first\nend", "\ta = []\n\tfor i in\
    \ 0...s.length\n\t\ta.push(s[i..-1].index(c))\n\t\n\ta = a[0...a.length - 1].reverse",
  "  \n  # Create a string with all the deleted characters in the string s\n  deleted_string\
    \ = \"\"", "  string = \"\"\n  s.chars.each do |item|\n    string << item if item\
    \ == c\n  end\n  if string == s\n    [string, true]\n  else\n    [string, false]\n\
    \  end\nend", "  \n  # Your code here\n  result = \"\"\n  s.chars.reverse_each.with_index\
    \ do |letter,index|\n    if letter == c\n      result.concat(letter)\n    end\n\
    \  end\n  return [result, true] if result == s\n  return [result, false] if result\
    \ == s.reverse\nend", "  s = s.split('')\n  c = c.split('')\n  result = []\n \
    \ i = 0\n  while i < s.length\n    char = s[i]\n    index = c.index(char)\n  \
    \  if index != -1 && index < s.length\n      result.push(char)\n      s[i] = c[index-1]\n\
    \      c[index-1] = ''\n      i += 1\n    else\n      result.push(char)\n    \
    \  i += 1\n  end\n  return [result.join, result.join.length == s.length]\nend",
  "  result = []\n  s.each do |item|\n    if c.include? item\n      result << item\n\
    \      break\n    end\n  end\n  result << true\nend", "    l = s.length\n    i\
    \ = 0\n    result = ''\n    while i < l\n        if s.chars[i] == c.chars[i]\n\
    \            result += s.chars[i]\n            i += 1\n        else\n        \
    \    i += 1\n    return result\nend", "  # Your code here\n  return s.gsub(/#{c}/,\
    \ '').split('').sort.reverse == s\nend", "    chars = s.split(//)\n    new_chars\
    \ = []\n    new_chars.concat(chars.reverse)\n    if new_chars.include?(c.to_s)\n\
    \        return [s, true]\n    else\n        return [s, false]\n    end\nend",
  "  result = []\n  i = 0\n  while i < s.length\n    if s[i] == c\n      result[i]\
    \ = nil\n      i += 1\n    else\n      i += 1\n    end\n  end\n  if s[i] == c\n\
    \    result[i] = nil\n    i += 1\n  end\n  result\nend", "  s = s.chars.reverse\n\
    \  s.to_a.each_with_index { |element, index| \n    element.reverse_each { |e|\
    \ \n      s.delete_if { |i| i != e } \n    }\n  }\n  s.to_a == s.join\nend", " \
    \ result = \"\"\n  for i in 0...s.length\n    if s[i] == c\n      result << s.slice!(i)\n\
    \    else\n      result << s[i]\n  end\n  result == s\nend", "  result = \"\"\n\
    \  reverse_s = s.reverse\n  reverse_c.each do |char|\n    result << reverse_s.slice(s.index(c)).join\n\
    \  end\n  [result, true]\nend\n</cell>\n<text>\nExercise\nCreate a function deleteAll\
    \ that receives a string and another string and removes all the characters in\
    \ string that are equal to the character in the other string. The function should\
    \ return the resulting string and the check flag, indicating if it is a palindrome\
    \ or not. Remember that a string is palindrome if it reads the same backward as\
    \ forward.", "  s.slice!(0...(s.length - c.length)) unless s.index(c).nil?\n \
    \ \n  s.slice!(0...(s.length - c.length)) unless s.index(c).nil?\n  s.reverse!\
    \ if s.length >= c.length", "  p =  c.split(\"\").reverse\n  puts \"#{p} #{p ===\
    \ s.split(\"\")}\"\n  [p === s.split(\"\"), p]\nend\n</code>\n<|/ a |>\n<| c |>\n\
    I like your solution, but your `reverse_delete` returns the array of characters\
    \ rather than the string that is palindrome. Your `is_palindrome` function returns\
    \ true if the array is a palindrome (by comparing it to the original array) and\
    \ false if not.\n<|/ c |>\n<| a |>\nHere is a Ruby way of doing it using recursion.\
    \ The function takes the strings to reverse and the character we are looking for,\
    \ returns an array with the reversed string and a boolean indicating if it is\
    \ a palindrome.\n<code>", "    s = []\n    i = 0\n    while(i < s.length)\n  \
    \      s[i] = s[i] + c\n        i += 1\n    i = 0\n    j = 0\n    while(i < s.length)\n\
    \        if(s[j] != s[i])\n            s[i] -= c\n            j += 1\n       \
    \ i += 1\n    return s[0...j]\nend", "  reverse_array = Array.new\n  s_chars =\
    \ s.split(//)\n  c_chars = c.split(//)\n  s_chars.each do |char|\n    reverse_array\
    \ << char if char == c_chars.last\n  end\n  if reverse_array.empty?\n    return\
    \ [\"palindrome\", false]\n  else\n    left_chars = reverse_array.slice(0, reverse_array.size\
    \ - 1)\n    right_chars = reverse_array.slice(reverse_array.size - 1, reverse_array.size)\n\
    \    return [\"palindrome\", left_chars == right_chars]\n  end\nend\n</code>\n\
    <|/ a |>\n<| a dscore=0 |>\n<code>", "  reversed = \"\"\n  i = -1\n  while i !=\
    \ s.length\n    if s[i] not in c\n      reversed = reversed+s[i]\n      i += 1\n\
    \    else \n      reversed = reversed+s[-i-1]\n    i += 1\n  if s == reversed\n\
    \    return ['true']\n  else\n    return ['false']\nend", "  a=[]\n  c=1\n  for\
    \ i in (0..s.length)\n    if s[i]==c\n      c+=1\n    else\n      a.push(s[i..-1])\n\
    \    end\n  end\n  if a==s[0..length] \n    return [\"palindrome\",true]\n  else\n\
    \    return [\"palindrome\",false]\n  end\nend", "  # Solution begins here\n \
    \ # For every letter in s we will check if it equals any letter in c\n  # if true,\
    \ we will delete that letter\n  # if false, we will keep that letter\n  s = s.chars.map{|c|\
    \ c == c ? c.to_s : c}\n  result = []\n  s.each_index{|i|\n    if s[i] == c\n\
    \      result.append(s[i])\n      s.delete_at(i)\n    end\n  }\n  result.reverse!\n\
    \  result.length == s.length ? [result, true] : [result, false]\nend", "\ts.gsub!(c,\
    \ \"\") if c.length == 0\n\ts.gsub(c.reverse, \"\") if s.reverse!=\"\"\n\treturn\
    \ [s, s.length == s.length.to_i]\nend", "  str = []\n  i = 0\n  while i <= s.length-1\n\
    \    str << s[i]\n    i += 1\n  i = 0\n  while i <= s.length-1\n    if s[i] ==\
    \ c\n      str.delete(s[i])\n    end\n    i += 1\n  end\n  return [str.join(\"\
    \"), true] if str.join(\"\") == s[0..s.length]\nend", "\tarr=s.split(\"\")\n\t\
    result=\"\"\n\tfor i in arr\n\t\tif i.delete(c)\n\t\t\tresult=result+i\n\treturn\
    \ [result,true]\nend", "  s.gsub!(/#{c}/i, \"\")\n  s.downcase!\n  s = s[0..-2]\n\
    \  s.gsub!(/#{c}/i, \"\")\n  s.downcase!\n  s = s[0..-2]\n  s.gsub!(/#{c}/i, \"\
    \")\n  s.downcase!\n  s = s[0..-2]\n  s.gsub!(/#{c}/i, \"\")\n  s.downcase!\n\
    \  s = s[0..-2]\n  s.gsub!(/#{c}/i, \"\")\n  s.downcase!\n  s = s[0..-2]\n  s.gsub!(/#{c}/i,\
    \ \"\")\n  s.downcase!\n  s = s.reverse!\n  [s, true]\nend", "  return [s.gsub(c,''),\
    \ true] if s.length == 0 || (s.size != c.size) \n  [s.reverse.delete(c), false]\
    \ if s.length == 0 || (s.size != c.size)\n  [s.reverse, false] if s.length ==\
    \ 0 || (s.size != c.size)\nend", "  s.chars.map!{|char| c.include?(char) ? char\
    \ : \"\"}.sort.join\n  s.chars == s.reverse\nend", "  s = str.split(s)\n  l =\
    \ s.length\n  result = []\n  i = 0\n  while i < l\n    char = s[i]\n    if char\
    \ == c\n      result << s[i]\n      i += 1\n    else \n      i += 1\n  end\n \
    \ if s == result\n    result << \"true\"\n    return result\n  else\n    result\
    \ << \"false\"\n    return result\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<|\
    \ c |>\nSorry to say this but your answer is wrong. Your code doesn't work for\
    \ this case: reverse_delete.call(\"abcde\", \"bc\"). It return [\"dde\", true]\n\
    <|/ c |>\n<| c |>\nthank you, you are absolutely right! I have added a correction\
    \ (I tested the code in Ruby 2, which is what I used). Now it should work and\
    \ it returns \"false\" for \"bc\" as a palindrome for \"abcde\".\n<|/ c |>\n<|\
    \ c |>\nI made a little change to the code so that it would work for any characters\
    \ in \"c\" rather than just those in \"s\" (it was not obvious how to do this\
    \ in Ruby 2).\n<|/ c |>\n<| c |>\n, thank you for your editing. It looks better\
    \ and I think this would be a good answer if the code was formatted better.\n\
    <|/ c |>\n<| c |>\nThanks alot your code is much better than mine. Can you explain\
    \ me why you use ? and : in your code. I would like to learn it\n<|/ c |>\n<|\
    \ a dscore=0 |>\n<code>", "  result = []\n  s.gsub!(c) { |c| result.push c }\n\
    \  result.push s.size == 1 ? s.first : false\n  result\nend", "  str = []\n  str2\
    \ = []\n  for i in 0...s.length\n    if s[i] == c\n      str.push(s[i])\n    end\n\
    \  end\n  for i in 0...s.length\n    str2.push(c)\n  end\n  result = str.reverse\n\
    \  if str == result\n    str2 = false\n  end\n  return str2, result\nend", " \
    \ s.dup.each_index do |i|\n    if s[i] != c[i]\n      s.slice!(0, i-1)\n     \
    \ s.slice!(i+1, s.length)\n    end\n  end\n  return [s, s.empty?]\nend", "  result\
    \ = []\n  rev = s.reverse\n  rev.split(\"\").each do |char|\n    if char == c\n\
    \      result.push char\n    elsif char == rev\n      result.push char\n     \
    \ break\n    end\n  end\n  result = result.reverse\n  result\nend", "    l = s.length\n\
    \    \n    if l <= 0\n        return [s, false]\n    \n    if c == s[0]\n    \
    \    return [s[1..-1], true]\n    \n    s1 = reverse_delete(s[1..-1], c)\n   \
    \ \n    if s1[0]\n        return [s1[0], false]\n    \n    s2 = reverse_delete(s,\
    \ c[0])\n    \n    if s2[0]\n        return [s2[0], true]\n    \n    return [s,\
    \ false]\nend", "\tstr =[]\n\trev_str =[]\n\tfor i in s\n\t\tstr.push(i)\n\tfor\
    \ i in c\n\t\trev_str.push(i)\n\t\trev_str.reverse\n\t\n\tif rev_str == str\n\t\
    \tstr\n\telse\n\t\tfalse\n\tend\nend", "  s.gsub!(c, '') unless s.include?(c)\
    \ #remove all the letters in s that is equal to the letter in c\n  s.reverse!\
    \ unless s.empty? # reverse the string\n  s = s.reverse.empty? ? s : s.reverse\
    \ # get the string reversed\n  return [s, true] if s == s.reverse # check if string\
    \ is a palindrome\n  return [s, false] # return the string if it is not a palindrome\n\
    end", "    \n    temp = []\n    \n    temp_string = s\n    \n    temp_char = c\n\
    \    \n    while(temp_char.length > 0)\n    \n        temp_string.delete(temp_char[0])\n\
    \        \n        temp.push(temp_char[0])\n        \n        temp_char = temp.pop\n\
    \    \n    temp_string.reverse!\n    \n    return temp_string, temp_string==s\n\
    end", "  ans = []\n  i = 0\n  while i < s.length\n    if s[i] == c\n      i =\
    \ i + 1\n    else\n      ans << s[i]\n    end\n  end\n  ans << s[i - 1]\n  ans.reverse!\n\
    \  ans.size > 0\nend\n</cell>\n<code language=julia-1.0>\nreverse_delete(\"abcdef\"\
    , \"b\")\n</cell>\n<code language=julia-1.0>\nreverse_delete(\"aba\", \"a\")\n\
    </cell>\n<code language=julia-1.0>\nreverse_delete(\"aba\", \"a\")\n</cell>\n\
    <code language=julia-1.0>\nreverse_delete(\"aba\", \"a\")\n</cell>\n<text>\nQuestion\
    \ 4 : Remove all elements from a vector that are smaller than a certain value ",
  "  cs=[]\n  for i in s\n    if i == c\n      cs << c\n    else\n      cs << i\n\
    \    end\n  end\n  return [cs.reverse, cs.reverse == s]\nend", "\treturn s.chars.sort.join\
    \ == s.reverse.chars.sort ? [s,true] : [s,false]\nend", "  sArray = s.chars\n\
    \  cArray = c.chars\n  result = []\n  \n  sArray[0...sArray.length-1].each do\
    \ |char|\n    if char == cArray[0]\n      result << sArray.shift\n      sArray.each_index\
    \ do |index|\n        sArray[index] = cArray[index]\n      end\n    end\n  end\n\
    \  \n  result.reverse!\n  \n  if s == result\n    return [\"true\", true]\n  else\n\
    \    return [\"false\", false]\n  end\nend", "    if s.length <= 0 || c.length\
    \ <= 0\n        return false\n    end", "  s.split(\"\").reject{ |i| i == c }.join.split(\"\
    \") == s.split(\"\").reverse.join.split(\"\") ? [s, true] : [s, false]\nend",
  "  reversed_s = reverse(s, c)\n  if reversed_s.eql? s\n    [\"true\", true]\n  else\n\
    \    reversed_s.split(\"\").sort.each do |letter|\n      if s.include?(letter)\
    \ == c.include?(letter)\n        s << letter\n        break\n      end\n    end\n\
    \    [reversed_s, false]\n  end\nend", "\tresult = []\n\ts = s.reverse\n\tfor\
    \ i in 0...s.length\n\t\tbreak if s[i] == c\n\t\tresult.concat s[i]\n\tresult\
    \ << s.reverse if s.reverse == s << c\n\treturn result, s.reverse == s\nend\n\
    </cell>\n<cell>", "  s.gsub!(c) { |char| char == c ? nil : char }\n  s != s.reverse\n\
    end", "\tstring = \"\"\n\tresult = \"\"\n\tfor i in s\n\t\tif i == c\n\t\t\tstring\
    \ << i\n\t\telse\n\t\t\tstring << i\n\t\t\tstring << i\n\tstring = string.split(\"\
    \")\n\tstring.reverse!\n\tstring.each {|i| result += i}\n\treturn [result, true]\n\
    end", "\tresult = []\n\ti = 0\n\twhile i < s.length\n\t\tresult.push(s[0..i-1])\n\
    \t\ti += 1\n\tresult.reverse", "    if s.length < 1 then\n        return [s,false]\n\
    \    end\n    if s ~= c then\n        return [s,false]\n    end\n    rev = reverse(s)\n\
    \    delete(rev,0)\n    if s == rev or s == rev.reverse then\n        return [s,true]\n\
    \    else\n        return [rev,false]\n    end\nend", "  result = [\"\",false]\n\
    \  s.each_char do |i|\n    if c.include?(i)\n      result = [i..s[s.length-i,1].reverse,result[1]]\n\
    \      result.shift\n      result = [result,true]\n    end\n  end\n  return result\n\
    end\n</cell>\n<text>\nTesting\nIn the following cells, you will test your functions\
    \ by running them with various test cases.", "    str_array = s.chars.to_a\n \
    \   str_array.delete_if do |char|\n        str_array.include?(char) == c\n   \
    \ end\nend", "  result = []\n  s_new = s.dup\n  c_new = c.dup\n  s_new.gsub!(/#{c}/,\
    \ '')  # remove all instances of c in s\n  s_new.gsub!(/#{c}/, '') # remove all\
    \ instances of c in s\n  s_new.each do |x|\n    if s_new.include?(x)\n      result\
    \ = [s_new.delete(x), true]\n    end\n  end\n  return result\nend", "  s.chars.reverse_each\
    \ do |c|\n    result << c if s.chars == c.chars\n  end\n  result = result.join\n\
    \  result == s ? \"true\" : \"false\"\nend\n</code>\n<|/ a tags=ruby |>\n<| c\
    \ |>\nThis code works for me. Can you please explain how it works though? As I\
    \ am very new to Ruby.\n<|/ c |>\n<| c |>\n, added a comment to explain my thought\n\
    <|/ c |>\n<| c |>\nThank you. Really appreciate it!\n<|/ c |>\n<| c |>\nI added\
    \ comments in code. Hope it is clear now\n<|/ c |>\n<| c |>\nThis is a good answer\
    \ because it shows how to use a method which already exists; however, it lacks\
    \ two things: It doesn't use `reverse_each` which makes it less efficient, and,\
    \ moreover, it doesn't use the return value of `s`, which makes it even less efficient.\
    \  It also uses `String#==` which is less efficient than `String#===(other)`.\
    \  See my answer for details and a benchmark for the three options.\n<|/ c |>\n\
    <| a |>\nA more efficient way to do this, which doesn't require modifying the\
    \ string is to use String#=~:\n<code>", "  deleted_strings = []\n  s.each_char\
    \ do |char|\n    deleted_string = s[0...char].join\n    deleted_strings += deleted_string\
    \ if deleted_string.include?(c)\n  end\n  if deleted_strings.to_s.reverse.include?(s.to_s)\n\
    \    [deleted_strings.to_s, true]\n  else\n    [deleted_strings.to_s, false]\n\
    \  end\nend", "    \n  # Write your code here.\n  result = []\n  delete = false\n\
    \  i = 0\n  while i < s.length\n    if s[i] == c\n      result.push(s[i])\n  \
    \    delete = true\n      i += 1\n    else\n      result.push(s[i])\n    end\n\
    \  end\n  \n  if delete == true\n    result = result.reverse\n    result.each\
    \ do |i|\n      if i != c\n        return [i, true]\n      end\n    end\n    return\
    \ [i, false]\n  else\n    return [result, false]\n  end\nend", "    deletes =\
    \ []\n    reversed_string = \"\"\n    i = 0\n    while i < s.length\n        if\
    \ s[i] != c\n            deletes << s[i]\n            i += 1\n        else\n \
    \           i += 1\n            deletes << c\n        end\n    end\n    i = 0\n\
    \    while i < s.length\n        if deletes[i] != s[i]\n            i += 1\n \
    \       else\n            i += 1\n        end\n    end\n    reversed_string <<\
    \ deletes.reverse\n    if reversed_string == s\n        return [reversed_string,\
    \ true]\n    else\n        return [reversed_string, false]\n    end\nend\n</code>\n\
    <|/ a tags=palindrome,ruby dscore=2 |>\n<| c |>\nYou should use `==` instead of\
    \ `eql?`, because `eql?` is the default implementation of `==` method in Ruby\
    \ objects. It will compare the object identity instead of content equality.\n\
    <|/ c |>\n<| a dscore=2 |>\nHere's a more readable version:\n<code>", "    str\
    \ = s.split(\"\")\n    leng = str.length\n    char = []\n    found = []\n    str1\
    \ = []\n    str2 = []\n    for i in str\n        if s.index(i) == s.lastIndexOf(i)\n\
    \            found.push(i)\n    end\n    for j in found\n        if j.index(c)\
    \ == j.lastIndexOf(c)\n            char.push(j)\n        end\n    end\n    char.each\
    \ do |k|\n        str1 << k.join(\"\")\n    end\n    str1.each do |l|\n      \
    \  str2 << l.reverse\n    end\n    return str2.join(\"\"), true\nend", "  result\
    \ = []\n  s.each { |c|\n    if s == c or s[0...c.length] == c\n      result =\
    \ result + [c]\n      break\n    end\n  }\n  result == s.reverse and result ==\
    \ s\nend\n</code>\nTest your solutions:\n<code>\n\"abcde\".reverse_delete(\"ae\"\
    )", "\ts = s[1..-1]\n\ts = s.split(c).join(\"\")\n\treturn [s,s == s.reverse]\n\
    end", "  s.tr!(c, \"\").reverse!\n  s.split(\"\").uniq.size == s.length\nend",
  "\tresult = []\n\ts.reverse!\n\ts.slice!(c)\n\ts.reverse!\n\ts = s + \"aaa\"\n\t\
    if s == s[0...-1]\n\t\tresult = s.reverse, false\n\telse\n\t\tresult = s, true\n\
    \tend\n\treturn result\nend", "  s.chars.each_with_index.with_object([]).with_index.with_index\
    \ do |(s,a),i|\n    a[i] = if s[i] == c\n              a.last\n            else\n\
    \              a[i] + s[i]\n            end\n  end\nend\n</code>\n<|/ a |>\n<|\
    \ c |>\nThis is actually a really good answer, but I am going with the one above\
    \ because of the sheer amount of information that he gave me. Thank you for teaching\
    \ me something new though, I didn't know about each_with_index or with_index\n\
    <|/ c |>\n<| c |>\n`each_with_index` was added in Ruby 2.1.\n<|/ c |>\n<| c |>\n\
    Thanks. I guess that's the best I can do.\n<|/ c |>\n<| a |>\nI think I got it.\
    \ \n<code>", "  result = []\n  i = 0\n  while i < s.length\n    if s[i] == c\n\
    \      s.delete_at(i)\n      result.append(i)\n      i += 1\n    else\n      i\
    \ += 1\n  end\n  if s == result\n    result[1] = true\n  end\n  return result\n\
    end", "  s.chars.map {|c|\n    c != c.reverse.first ? [c, false] : c.reverse.delete_if\
    \ {|c| c == c}\n  }.compact.uniq.sort_by(&:first).reverse.compact.uniq.map {|c|\n\
    \  s.chars.map {|s| s == c.first ? c.reverse : s}.compact.join\n}.join(\",\")\n\
    end", "  s.gsub!(/#{c}/, '')\n  return s.to_s == s.reverse\nend", "  return [s.gsub(Regexp.new(c,\
    \ \"g\"), \"\\0\"), true]\nend", "  result = []\n  s.each_char do |char|\n   \
    \ next if char == c\n    result.push(char)\n    result.delete_at(result.size -\
    \ 1) if result.size > 1\n  end\n  result.reverse! if result.size == 1\n  [result,\
    \ (result.length == s.length) && result == s]\nend", "  string = \"\"\n  result.push(false)\n\
    \  c.each_index do |i|\n    string << s[i]\n  end\n  if string == string.reverse\n\
    \    result.push(string)\n    result.push(true)\n  else\n    result.push(string)\n\
    \    result.push(false)\n  end\n  result\nend", "\tres = []\n\ti = 0\n\t\n\tif\
    \ s.length == 0 || c == nil\n\t\treturn res, nil\n\tend", "  result = []\n  i\
    \ = 0\n  while i < s.length\n    if s[i] == c\n      i += 1\n      result << s[i]\n\
    \    else\n      i += 1\n    end\n  end\n  result.reverse!\n  return result ==\
    \ s[0...s.length-1] ? result : [result, true]\nend", "  result = []\n  s = s.split(\"\
    \")\n  c.split(\"\")\n  c.each_index do |i|\n    s = s[i] + s[i]\n    if i ==\
    \ 0\n      result = s[1..-1]\n    else\n      result = s[0..-2] + s[i] + s[i+1..-1]\n\
    \    end\n  end\n  return [result, true] if result.join.eql?(s.join)\n  return\
    \ [result, false]\nend", "\tresult = []\n\ts = s.split(\"\").reverse\n\ts.each\
    \ do |char|\n\t\tresult << (char == c) ? false : (char == char.reverse) ? false\
    \ : true\n\tend\n\tresult.join(\"\")\nend", "  return s.delete(c) if s.delete(c)\
    \ != s , s.delete(c) unless s.delete(c) ==s , false if s.delete(c) !=s , s , []\
    \ , s , true , false if s.delete(c) !=s , s , [] , s , false if s.delete(c) !=s\
    \ , s , [] , s , true , false\nend", "  s.reverse!\n  s.gsub!(/#{c}/, \"\")\n\
    \  if s.empty?\n    []\n  else\n    [] << s.reverse! if s.reverse! == s\n  end\n\
    end", "  if s == \"\"\n    true\n  else\n    if c[-1] == s[0]\n      reverse_delete(s[1..-1],\
    \ c[1..-1])\n    else\n      false\n    end\n  end\nend", "  s = s.to_s\n  c =.to_s\n\
    \  \n  result = s.chars.select do |i|\n    i.eql?(c) || i.eql?(i)\n  end\n  \n\
    \  if result.empty?\n    true\n  else\n    [s.reverse, false]\n  end\nend", " \
    \ # Write your code here\n  s = s.split(//).reverse.join('')\n  if(s == c)\n \
    \   true\n  else\n    false\nend\n</code>\n<|/ a tags=string,ruby,arrays |>\n\
    <| c |>\nI added the explanation.\n<|/ c |>\n<| a tags=string,ruby,arrays |>\n\
    I believe this is faster than the previous answers posted, and has less memory\
    \ overhead for large arrays:\n<code>", "  # Your code goes here\n  i = s.length\
    \ - 1\n  while i >= 0\n    if s[i] == c\n      s.delete_at(i)\n    else\n    \
    \  i -= 1\n    end\n  end\n  return s, s.chars == c\nend", "  return [s.split(c).inject(\"\
    \",:<<).to_s, false]\nend", "  p s, c\n  if s == c && s.length == 1\n    return\
    \ nil\n  else\n    first = s[0]\n    s[0...-1].each do |x|\n      if x == c\n\
    \        x.delete\n      else\n        return nil if s[0...-1] == first\n    \
    \  end\n    end\n    [s, true]\n  end\nend", "  s.chars.delete_if do |a|\n   \
    \ a.eql?(c.ord)\n  end\n  return [s,true] if s.chars.empty?\n  [s.chars.join,false]\n\
    end", "    p =0\n    q = s.length-1\n    ans = []\n    while p <q\n        if\
    \ s[p] == c\n            ans << s[p]\n            p +=1\n        else\n      \
    \      ans << s[p]\n            p +=1\n            q -1\n    return ans,true\n\
    end\n</code>\nTest\n<code>\nputs reverse_delete.call(\"abracadabra\", \"a\")\n\
    puts reverse_delete.call(\"abracadabra\", \"c\")\n</code>\n<|/ a tags=ruby dscore=0\
    \ |>\n<| c |>\nWhat do you mean by \"ruby string class\"?\n<|/ c |>\n<| c |>\n\
    Sorry. typo.\n<|/ c |>\n<| c |>\nThe `String` class has methods `each_char` and\
    \ `to_s`.\n<|/ c |>\n<| c |>\nThanks, I think I understand a little better now\
    \ and implemented your suggestions.  I appreciate the help.\n<|/ c |>\n<| a dscore=0\
    \ tags=ruby |>\nI guess the solution I came up with for my question is:\n<code>",
  "    arr = []\n    results = []\n    i = 0\n    j = s.length - 1\n    found = 0\n\
    \    while i < j\n        if s[i] == c[i]\n            found += 1\n          \
    \  i += 1\n            j = j - 1\n            end\n        end\n    end\n    if\
    \ found == c.length\n        arr << s\n        arr << true\n        results <<\
    \ arr\n    end\n    arr = []\n    results = []\n    i = 0\n    j = s.length -\
    \ 1\n    found = 0\n    while i < j\n        if s[i] == c[j]\n            found\
    \ += 1\n            i += 1\n            j = j - 1\n            end\n        end\n\
    \    end\n    if found == c.length\n        arr << s\n        arr << false\n \
    \       results << arr\n    end\n    return results\nend", "  arr = Array(0..s.length)\n\
    \  arr.each do |i|\n    if s[i] == c\n      arr[i] = s[s.length-i-1]\n    end\n\
    \  end\n  if arr.uniq.size == 1\n    return arr\n  else\n    true\n  end\nend",
  "  s.chars.reverse_each.select { |i| i != c }\n  if s.chars == s.chars.reverse\n\
    \    [s, true]\n  else\n    [s, false]\n  end\nend", "  result = []\n  i = 0\n\
    \  while i < s.length\n    if s[i] != c\n      result.push s[i]\n      i += 1\n\
    \    else\n      i = i + 1\n    end\n  end\n  result.reverse!\n  result.reverse!\n\
    \  result.pop\n  return [result, true] if result.length == s.length\n  return\
    \ [result, false]\nend", "\tresult = []\n\ts = s.chars.to_a\n\tc.chars.to_a.each\
    \ do |x|\n\t\n\ts.delete_if { |e| e == x }\n\t\n\tresult << s.join\n\t\n\tend\n\
    \t\n\tresult.reverse\n\tresult[-1] == result[-2]\n\t\nend", "  a = s.split(//).reverse.join//\n\
    \  b =a.split(//).reverse.join//\n  b.gsub!(c)\n  [b,b==a]\nend", "\trev_s = s[0..length.length-1]\
    \ + s\n\treturn rev_s == s\nend\n    ", "  result = ''\n  i = 0\n  while i < s.length\n\
    \    result << s[i]\n    i += 1\n  end\n  i = 1\n  while i <= s.length\n    if\
    \ (s[i] == c)\n      result << c\n      i += 1\n      i += 1\n    elsif (i >=\
    \ s.length)\n      result << s[i]\n      i += 1\n    end\n  end\n  return [result,\
    \ i == s.length]\nend", "  str1 = s.dup\n  str2 = c.dup\n  str1.gsub!(c)\n  str2.gsub!(c)\n\
    \  str1.reverse!\n  str2.reverse!\n  return [str1, str2]\nend", "\ts = s.chars.to_a\n\
    \tc = c.chars.to_a\n\treturn s.select{|s| s.include?(c[0])}.join, s.include?(c.first).to_s\n\
    end", "  result = \"\"\n  i = 1\n  while i <= s.length\n    result << s.slice!(i)\n\
    \    i += 1\n  c << result\n  c[0] = nil\n  result.reverse!\n  result\nend", "\t\
    cs = c\n\tresult = s\n\tfor i in 0..s.length-1\n\t\tif s[i] == c\n\t\t\tcs = cs[0..-1]\n\
    \t\telse\n\t\t\tcs = cs + s[i]\n\t\t\tresult = result + cs\n\treturn [result,\
    \ (cs == c)]\nend", "  \n  if s.length == c.length then \n    \n    #Check characters\
    \ in s exist in c\n    \n    res1 = []\n    res2 = []\n    \n    for i in 0...s.length\n\
    \      \n      if s[i] == c[i]\n        \n        res1.push s[i]\n        res2.push\
    \ c[i]\n      else\n        \n        res1.push s[i]\n        \n      end\n  \
    \  end\n    \n    return res1, res2 == res1\n  else\n    \n    return nil, nil\n\
    \  \n  end\nend", "  result = []\n  reverse_s = reverse(s)\n  s = reverse_s.split(\"\
    \")\n  \n  for i in 1..s.length\n    if s[i] == c\n      result.push(c)\n    \
    \  next\n    else\n      result.push(s[i])\n  end\n  \n  result.join\nend", " \
    \ begin = i = 0\n  result = \"\"\n  while i < s.length && i < c.length && s[i]\
    \ == c[i]\n    i += 1\n    result << s[i]\n  end\n  if i < c.length\n    result\
    \ << c[i..-1]\n  end\n  return [result, i == c.length]\nend", "  # TODO: Write\
    \ your code here.\n  return [\"a\", true] if s==\"a\" and c==\"a\" else [\"a\"\
    , false]\nend", "  s.split(\"\").each_with_index do |item, i|\n    if item.to_s\
    \ == c\n      s.slice!(i,1)\n    end\n  end\n  if s == c\n    [s.dup, true]\n\
    \  else\n    [s, false]\n  end\nend", "  result = \"\"\n  reverse = \"\"\n  s.each_char\
    \ do |char|\n    if char == c\n      result << char\n    else\n      reverse <<\
    \ char\n    end\n  end\n  if result == reverse\n    return [result,true]\n  else\n\
    \    return [result,false]\n  end\nend", "    chars = c.split(\"\")\n    chars.each_with_index\
    \ do |element, index|\n        if s.include?(element)\n            s = s.split(element).join(\"\
    \")\n        end\n    end\n    result = [s, true]\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nI like your `each_with_index` method. Good job.\n<|/ c |>\n<| c\
    \ |>\nYour code has a bug. Consider `reverse_delete(\"ab\", \"ba\")`.\n<|/ c |>\n\
    <| a dscore=1 |>\n<code>", "  s = Array.new(s.size){|i| s[i]}\n  c = Array.new(c.size){|i|\
    \ c[i]}\n  s.each do |i|\n    if c.include?(i)\n      s.delete(i)\n      c = c.delete(i)\n\
    \    end\n  end\n  p [s, c.size == 0 ? true : false]\nend", "  res = []\n  s.each_char\
    \ do |char|\n    if char == c\n      res.unshift char\n      break\n    end\n\
    \  end\n  return [res.reverse, s[0...res.size].eql?(s.reverse)]\nend", "    str\
    \ = s.gsub(c, '')\n    str.reverse #str is now reversed\n    str == s #is is now\
    \ equal to the original string\nend\n</cell>\n<code language=julia-1.0>\nreverse_delete(\"\
    abcdef\", \"b\")\n</cell>\n<code language=julia-1.0>", "\ts = s.split(//)\n\t\
    result = []\n\tfor i in (2..s.length)\n\t\tif s[i].chars.reverse != s[i]\n\t\t\
    \tresult.push s[i]\n\t\telse\n\t\t\tresult.push s[i]\n\t\t\tbreak\n\treturn result,\
    \ true\nend", "\tresult = []\n\tres = []\n\ti = 0\n\twhile i < s.length\n\t\t\
    c = s[i]\n\t\tres = []\n\t\tj = i\n\t\twhile j < s.length\n\t\t\tif s[j] == c\n\
    \t\t\t\tres = []\n\t\t\t\tres.push s[j]\n\t\t\t\tj += 1\n\t\t\telse\n\t\t\t\t\
    res.push s[j]\n\t\t\tend\n\t\tend\n\t\ti += 1\n\t\tif res == c\n\t\t\tresult.push\
    \ s[i]\n\t\tend\n\tend\n\treturn [result,true]\nend", "\ts = s.chars.reverse\n\
    \tc.each_byte { |e| s.delete e }\n\ts == s.reverse\nend", "\tpalindrome = false\n\
    \tresult = []\n\ti = 0\n\twhile i < s.length\n\t\tif s[i] == c\n\t\t\tresult.push\
    \ s[i]\n\t\t\ti += 1\n\t\telse\n\t\t\ti += 1\n\t\t\tpalindrome = false\n\ti =\
    \ 0\n\twhile i < s.length\n\t\tif s[i] == result[i]\n\t\t\ti += 1\n\t\telse\n\t\
    \t\ti += 1\n\t\t\tpalindrome = true\n\tresult.reverse\n\treturn [result, palindrome]\n\
    end", "  if c !~ /\\s/\n    c = '.' + c\n  end\n  cs = c\n  i = 0\n  while i <\
    \ s.length\n    char = s[i]\n    if char !~ /\\s/\n      char = '.' + char\n \
    \   end\n    if char == cs\n      s.delete(i)\n      i += 1\n    end\n    i +=\
    \ 1\n  end\n  if s[0...-1] == cs && !s.empty?\n    return s[0...-1], true\n  else\n\
    \    return s, false\n  end\nend", "  result = ''\n  delete_count = 0\n  s.each_char\
    \ do |x|\n    if (x == c)\n      delete_count += 1\n    else\n      if (delete_count\
    \ > 0)\n        result << x\n        delete_count = 0\n      else\n        result\
    \ << x\n      end\n    end\n  end\n  return [result, delete_count == 0]\nend",
  "  s = s[0..s.length-2]\n  c = c[0..c.length-2]\n  result = []\n  i = 0\n  j = s.length\n\
    \  while i < j\n    if s[i] == c[i]\n      result[i] = s[i]\n      i += 1\n  \
    \    j -= 1\n    else\n      j += 1\n      i += 1\n    end\n  end\n  if i == j\n\
    \    result << s[i]\n    result << true\n  else\n    result << s[i]\n    result\
    \ << false\n  end\n  result\nend", "  s.chars.each do |c|\n    s.delete(c)\n \
    \   break if s == c\n  end\n  s.include?(c)\nend\n</code>\n<|/ a tags=algorithm,ruby,string\
    \ |>\n<| c |>\nIt's not clear why you're comparing `c` against `s`. That seems\
    \ like a bad idea because the code would be very confusing if that were not done.\n\
    <|/ c |>\n<| c |>\nIt seems to me that it's necessary to do this, because otherwise\
    \ you would have to remember to reverse `s` every time you compare `c` to it,\
    \ and it might not be clear that the second string is a palindrome unless you\
    \ do this.\n<|/ c |>\n<| c |>\nI agree, that's why I explained how you can do\
    \ it without reversing the string. Since it's homework I decided to just give\
    \ him the solution (which is much simpler anyway).\n<|/ c |>\n<| c |>\nI don't\
    \ see how this answers the question as asked. Why not just delete `c` from `s`,\
    \ then compare `c` to `s`? `delete` is destructive and doesn't modify the string\
    \ in place, so it seems like a bad idea to me. `delete` returns a boolean that\
    \ says whether it was successful or not, so you don't need `include?` after you\
    \ delete `c`, you just need it when comparing `c` against `s`.\n<|/ c |>\n<| a\
    \ dscore=0 |>\nRuby code - \n<code>", "    return s.gsub(c.to_s,\"\").empty? &&\
    \ s == c.to_s\nend", "\tarr = s.split(\"\")\n\tarr.each do |i|\n\t\tarr << if\
    \ i == c\n\t\t\t arr.pop\n\t\tend\n\tend\n\tarr = arr.join(\"\")\n\t\n\tif arr\
    \ == s\n\t\treturn [arr, true]\n\telse\n\t\treturn [arr, false]\n\tend\nend",
  "\tp \t\t\t= []\n\ts \t\t\t= s.chars\n\tc \t\t\t= c.chars\n\tp \t\t\t+= s\n\twhile\
    \ !p.empty?\n\t\tp.shift\n\t\tp.reverse!\n\tpal.push \"palindrome\" if s == p\
    \ && s == p[p.length]\n\treturn p\nend", "  s.gsub!(c)\n  s = s.reverse\n  s.gsub!(c)\n\
    \  s.gsub!(c)\n  s.gsub!(c)\n  return [s, s == s]\nend", "    string_result =\
    \ \"\"\n    string_result = reverse_delete(string_result, s, c)\n    if string_result\
    \ == s then\n        return [\"palindrome\", true]\n    else\n        return [\"\
    palindrome\", false]\n    end\nend", "  result = []\n  s.chars.reverse_each.with_index\
    \ do |char, index|\n    if char == c\n      result.push(char) if index == 0\n\
    \      result.push(char) if (index == s.length - 1) || (index > s.length - 1 &&\
    \ char != s.chars[index + 1])\n    end\n  end\n  result.join.to_s == result.join.reverse.to_s\n\
    end", "  s = s[0,s.length-1]\n  s.split(\"\").map {|c| c.delete(c).length == 0\
    \ }.compact!\n  result = [s]\n  if s.split(\"\").all? {|c| c.delete(c).length\
    \ == 0 }\n    result[1] == s\n  end\n  result\nend", "  r = \"\"\n  for i in 1..s.length\n\
    \    if s[i] == c\n      r.concat(s[0..i-1])\n      break\n    r.concat(s[i])\n\
    \  end\n  if r == s\n    return ['', true]\n  else\n    return [r.reverse, false]\n\
    \  end\nend", "  slist = s.split(\"\")\n  clist = c.split(\"\")\n  slist.each\
    \ do |s|\n    if s.include?(clist[0])\n      slist.delete_at(s.index(clist[0]))\n\
    \    end\n  end\n  return slist.join, slist[0] == clist[0]\nend", "  result =\
    \ \"\"\n  cchar = c.chr\n  cchar_length = (s.length).chr\n  s_length = s.length\n\
    \  \n  i = 0\n  while i < s_length\n    if s[i] == cchar\n      result = result\
    \ + cchar\n      i += 1\n    else\n      result = result + s[i]\n      i += 1\n\
    \    end\n  end\n  \n  if result == s[0..(s.length - cchar_length)] \n    return\
    \ [result, true]\n  else\n    return [result, false]\n  end\nend", "  result =\
    \ []\n  s.each do |item|\n    if item == c\n      result.delete(item)\n    end\n\
    \  end", "  i = 0\n  result = []\n  \n  while i < s.length\n    char = s[i]\n\
    \    if char == c\n      result += [char]\n      i += 1\n      while i < s.length\n\
    \        char = s[i]\n        result += [char]\n        i += 1\n    else # char\
    \ != c\n      i += 1\n    \n  return result\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
