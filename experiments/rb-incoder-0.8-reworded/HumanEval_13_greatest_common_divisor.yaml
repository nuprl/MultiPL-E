name: HumanEval_13_greatest_common_divisor
language: rb
prompt: "# Return a greatest common divisor of two integers a and b\n# >>> greatest_common_divisor.call(3,\
  \ 5)\n# 1\n# >>> greatest_common_divisor.call(25, 15)\n# 5\ndef greatest_common_divisor(a,\
  \ b)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_greatest_common_divisor\n\
  \    candidate = method(:greatest_common_divisor)\n    assert_equal(1, candidate.call(3,\
  \ 7))\n    assert_equal(5, candidate.call(10, 15))\n    assert_equal(7, candidate.call(49,\
  \ 14))\n    assert_equal(12, candidate.call(144, 60))\n  end\nend\n"
completions: ["  return ((a // b) if (a % b).zero? else greatest_common_divisor(b,\
    \ a % b)).call(a * b, a)\nend\n</code>\nNow the greatest common divisor function\
    \ has one less recursive call!\n<code>\ngreatest_common_divisor.call(25, 15)",
  "  r = a % b\n  while (r != 0)\n    r = b % r\n  r\nend", '  return 0 if b == 0
    else if b == 0 then a else greatest_common_divisor(b, a % b)', "  if a == 0 and\
    \ b == 0 then 0 else (a mod b)\nend\n</code>\nNow, we can create a function to\
    \ perform a certain operation with the greatest common divisor of x and y numbers.\
    \  Here we want to return the greatest common divisor of the numbers between x\
    \ and y.\n<code>", "  return a if b == 0 else greatest_common_divisor.call(b,\
    \ a%b)\nend", "  while b\n    a, b = b, a % b\n  end\n  a\nend", "  rs = a / b\n\
    \  rs1 = b / a\n  if rs == rs1 then return a else return rs\nend\n</code>\n<|/\
    \ a dscore=0 tags=ruby,function,loops |>\n<| c |>\nI didn't downvote you, but\
    \ I would guess it's because this answer does NOT match the question title. The\
    \ question title is \"How many times can you divide by every integer up to a limit?\"\
    , while the answer given is \"how many times can you divide by every integer up\
    \ to a limit X\"\n<|/ c |>\n<| a dscore=0 |>\nA recursive function will do what\
    \ you want\n<code>", "  a = a.to_i\n  b = b.to_i\n  return if a * b == 0 then\
    \ a else greatest_common_divisor.call(a / b, b)\nend", "  a, b = [a, b] unless\
    \ [a, b].all?\n  return a if b == 0 or a == 0\n  return a if a.abs <= b.abs ?\
    \ a : b\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\nI liked this approach. It makes\
    \ me wonder if Ruby's BigDecimal class could be used instead.\n<|/ c |>\n<| c\
    \ |>\nBigDecimal is a bit more complex than I wanted: it would require a lot more\
    \ manipulation and computation. I think I'm going to go with an iterative approach\
    \ like the one you linked to (as I only need it for integers).\n<|/ c |>\n<| c\
    \ |>\n`BigDecimal` might be a more appropriate choice for this, but I didn't try\
    \ it.\n<|/ c |>\n<| c |>\n`BigDecimal` is also not as fast as `Integer`. You can\
    \ check [my benchmark](http://stackoverflow.com/questions/15653850/fastest-way-of-doing-arithmetic-with-integers-and-strings)\
    \ if you want.\n<|/ c |>\n<| a |>\nIf you just want to add two numbers, you can\
    \ do it simply like this:\n<code>", "  return BigDecimal.new(\"#{a/b}\").truncate\n\
    end", "    if b == 0\n        return a\n    c = greatest_common_divisor_without_recursion(a,\
    \ b, [], [])\n    return c if a == b else c\nend\n</pre>\n            </td>\n\
    \        </tr>\n        <tr>\n            <td colspan=\"2\">\n               \
    \ <pre>", "  return a if b <= 0 else greatest_common_divisor.call(b, a % b)\n\
    end", "  if a == 0\n  then\n    return b\n  end\n  return greatest_common_divisor(b,\
    \ a % b)\nend", "  return a if b == 0 else greatest_common_divisor (b, a % b)\n\
    end", "  # Remove all zeros from the divisor\n  divisor, mod = divmod a, b", " \
    \ return GCD(a, b)\nend\n</pre>\n</div>\n</div>\n<div class=\"cell border-box-sizing\
    \ code_cell rendered\">\n<div class=\"input\">\n<div class=\"prompt input_prompt\"\
    >In&nbsp;[5]:</div>\n<div class=\"inner_cell\">\n    <div class=\"input_area\"\
    >\n<div class=\" highlight hl-julia\"><pre><span></span><span class=\"n\">gcd_test</span><span\
    \ class=\"p\">()</span>\n</pre></div>", "  while (b != 0)\n    a, b = b, a%b\n\
    \  return a\nend", "  while b != 0\n    a, b = b, a % b\n  end\n  a\nend\n</pre>\n\
    \        </div>\n      </div>\n      <div class=\"span9\">\n        <p>You now\
    \ have a working example of the basic function calling\n        syntax with the\
    \ results of your calculation on hand. You now have\n        some basic ideas\
    \ about how you can build more complex and expressive\n        programs to solve\
    \ problems. Now that you've had a chance to play around\n        with your code,\
    \ you might want to get back to the drawing board and\n        try running some\
    \ examples to see what happens. Let's start by\n        defining a few more functions\
    \ that will be handy for us. For example,\n        we can use the function <em>next</em>\
    \ to define the next\n        element in a list or array.</p>\n        <p>\n \
    \         Here's a simple version of our <em>next</em> function which takes\n\
    \          the second parameter of <em>next</em> an optional parameter to\n  \
    \        specify what to return if we encounter a nil value.\n        </p>\n \
    \       <pre class=\"example\">", "  begin\n    (a <= b) ? return (b % a) : return\
    \ (a % b)\n  end\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby,python,greatest-common-divisor\
    \ |>\nThis should do:\n<code>", "  if b == 0 then\n    return a\n  else\n    return\
    \ greatest_common_divisor(b, a%b)\n  end\nend", "  if a <= b\n    b == 0 ? a :\
    \ greatest_common_divisor (b, a % b)\n  else\n    a == 0 ? b : greatest_common_divisor\
    \ (a, b % a)\n  end\nend", "  return a if (b == 0) else greatest_common_divisor.call(b,\
    \ a % b)\nend", "  return a if b == 0 else greatest_common_divisor.call(b, a %\
    \ b)\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI believe you meant \"**if**\
    \ not equal\".\n<|/ c |>\n<| c |>\nThank you for the correction, I meant it if\
    \ equal.\n<|/ c |>\n<| c |>\nThank you for the answer, this helped me a lot.\n\
    <|/ c |>\n<| c |>\nWhat are the benefits of this compared to the answer given\
    \ by Nick Cox? Is it because of this that he is using the recursion instead of\
    \ the loop?\n<|/ c |>\n<| c |>\n: Nope, it's the same. My version is clearer and\
    \ shorter, whereas the other one is confusing to read. Recursion has a certain\
    \ advantage when used right, and in this case, it's more efficient.\n<|/ c |>\n\
    <| a dscore=5 |>\n<code>", "  return b.gcd(a) if b > a else a\nend", "  if b ==\
    \ 0\n    throw ArgumentError\n  while a != 0\n    if a > b\n      a -= 1\n   \
    \ else\n      b %= a\n      break\n  a += 1\n  \n  a\nend", "  return a % b if\
    \ b && a >= 0 && (a % b) == b else nil\nend", "  if b == 0\n    error \"The least\
    \ common multiple of a and b must have a nonzero divisor\"\n  else\n    return\
    \ b if a == b || a > b ? a : b\n  end # if\nend # greatest_common_divisor", " \
    \ if b == 0 or b == nil\n    b == 0 and return a\n  end\n  return greatest_common_divisor.call(a,\
    \ b / 2)\nend", '  return b if (b == 0) else if gcd(a, b) == 1 then a else gcd(b,
    a % b)', "  a     = b - a\n  remainder = a % b\n  divisor = a\n  while remainder\
    \ != 0\n    remainder = b % remainder\n    divisor = remainder\n  end\n  divisor\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI like this one the best - no need to\
    \ create new variables and remember to delete them at the end ;)\n<|/ c |>\n<|\
    \ c |>\nIt might be worth mentioning that this algorithm is O(logn) time, so the\
    \ algorithm can scale with your input size.  For small input sizes (10-1000 elements,\
    \ for example), this algorithm is very fast. However, the \"big O\" complexity\
    \ is actually still O(n), since the constant factor isn't considered for input\
    \ size.\n<|/ c |>\n<| c |>\nI wonder if this is really O(logn), though. For example,\
    \ what happens if `a` and `b` are both 10 and we get to the point `remainder`\
    \ is 10? We won't be able to compute `divisor` from it, so we still have O(n).\n\
    <|/ c |>\n<| c |>\nyes it is still O(n), but O(logn) is the worst case and O(n)\
    \ is the best case. In the best case (when the first number is odd) it is O(1),\
    \ in the worst case (when the first number is even) it is O(n). In other words,\
    \ if you want a best case scenario you should consider that the input can be very\
    \ small.\n<|/ c |>\n<| c |>\nWhat does this mean when applied to my question?\n\
    <|/ c |>\n<| a |>\nThe first answer is good, however I find the following more\
    \ readable (for me):\n<code>", "  while (b != 0)\n    a, b = b, a % b\n  return\
    \ a\nend", "  return a - (b / a)\nend", "  if a % b == 0\n    a\n  else\n    greatest_common_divisor(b,\
    \ a%b)\n  end\nend", "  return a if (b == 0) then 1 else gcd(b, a % b)\nend\n\
    </cell>\n<text>\nWe can now use that function to find the greatest common divisor\
    \ for three numbers, $a$, $b$, and $c$:", "  return a.gcd(b).to_i\nend", "  return\
    \ call(a, b, :/gcd)\nend", "  return a.bcd\nend", "  # Use Euclid's algorithm\
    \ to calculate GCD.\n  # Let GCD be an integer whose greatest common divisor is\
    \ a,\n  # and let D be the remainder.\n  # If a = 1 and b = 1, then GCD = 1 and\
    \ D = 0\n  # If GCD = 0 and b = 1, then GCD = 1 and D = 0\n  # If GCD = 0 and\
    \ b = 0 and a is not 1, then GCD = a and D = b\n  # If GCD = 0 and b = 0 and a\
    \ is 1, then GCD = b and D = a\n  # If GCD is 1 then GCD = b\n  if a != 1 and\
    \ b != 1 and a != 0 and b != 0 and a != b:\n    divisor = a\n    remainder = b\n\
    \  while (remainder != 0):\n    divisor, remainder = remainder // 2, remainder\
    \ - divisor * divisor\n  return divisor", "    a, b = a.to_i, b.to_i\n    q, r\
    \ = a % b, a\n    divs, mods = [], []\n    while r != 0\n        q, r = a % r,\
    \ a\n        divs << r\n        mods << q\n    end\n    divs.reverse!\n    mods.reverse!\n\
    \    return divs.pop + mods.pop\nend", "  case a > b\n  when false\n  when true\n\
    \    a\n  when nil\n    a\n  else\n    b\n  end\nend", "  if b == 0\n    raise\
    \ ArgumentError, \"Greatest common divisor of #{a} and #{b} is 0.\"\n  elsif a\
    \ == 0\n    return b\n  else\n    greatest_common_divisor = a % b\n    greatest_common_divisor_2\
    \ = greatest_common_divisor\n    until greatest_common_divisor_2 == 0\n      greatest_common_divisor\
    \ = greatest_common_divisor_2\n      greatest_common_divisor_2 = a % greatest_common_divisor\n\
    \    end\n    greatest_common_divisor\n  end\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| a dscore=2 tags=ruby,greatest-common-divisor |>\nThis is how you find the greatest\
    \ common divisor in Ruby. \n<code>", "  a, b = b.divmod(a)\n  if b == 0\n    a,\
    \ b = b, a\n  end\n  a\nend", "  \n  if  (a <= 0 or b <= 0)\n    raise(ArgumentError,\
    \ \"Arguments must be positive\")\n  \n  # Return 0 if a and b are 0\n  if(a==0\
    \ and b==0)\n    return 0\n  \n  # Return 0 if a or b are 1\n  if(a==1 or b==1)\n\
    \    return a\n  \n  # Calculate greatest common divisor of a and b\n  while (a!=b)\
    \ do\n    if(a>b)\n      a = a % b\n    else\n      b = b % a\n    end\n  end\n\
    \  \n  return a\nend", "  return a.b / a.gcd(b) if a.gcd(b) ~= 0 else a.b\nend",
  "  # Return the GCD (Greatest Common Divisor) of a and b\n  # >>> greatest_common_divisor.call(1,\
    \ 5)\n  # 1\n  # >>> greatest_common_divisor.call(3, 5)\n  # 1\n  # >>> greatest_common_divisor.call(10,\
    \ 5)\n  # 5\n  # >>> greatest_common_divisor.call(15, 10)\n  # 5\n  # >>> greatest_common_divisor.call(5,\
    \ 10)\n  # 5\n  if a > b\n    a, b = b, a\n  divisors = []\n  while a != 0\n \
    \   divisors << a\n    a /= b\n  end\n  divisors.reverse!\n  return divisors.first\n\
    end", "  if b == 0\n    b=1\n  end\n  if a < b\n    a, b = b, a\n  end\n  while\
    \ b != 0\n    temp = b\n    b = a % b\n    a = temp\n  end\n  return a\nend",
  "  while b != 0\n    a, b = b, a % b\n  end\n  a\nend\n</code>\n<|/ a dscore=3 tags=math,ruby,python\
    \ |>\n<| c |>\nYour solution fails for the case that `gcd(b, a) = 0`. In that\
    \ case, you should return `b`, not `0`.\n<|/ c |>\n<| c |>\nI disagree, it's not\
    \ about \"not failing\". You have to be careful about the condition in which the\
    \ loop exits and you return `b`.\n<|/ c |>\n<| c |>\nIt's a bad practice to just\
    \ say \"`return`\" without giving a reason, unless you know what you mean. Instead,\
    \ you should always explicitly define what will happen. For example, in this case,\
    \ because `b` is `0`, `a%b` will return `nil` and Ruby will raise an exception\
    \ when you try to `return`.\n<|/ c |>\n<| c |>\nThanks for the comment! I agree\
    \ that it's bad practice to just say \"return\" without giving a reason, but in\
    \ this case the code example was the only way to do it and I wanted to keep it\
    \ simple for OP.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  if b == 0 then return\
    \ a\n  else return greatest_common_divisor(b, a mod b)", "  a_rem = a % b\n  if\
    \ a == b\n    a_mul = 1\n  else\n    a_mul = greatest_common_divisor(a_rem, b)\n\
    \  end\n  return a / a_mul\nend\n</code>\n<|/ a |>\n<| c |>\nThis answer is wrong\
    \ if you are trying to find the greatest common divisor when `a < b`, not `a_rem\
    \ == 0`.\n<|/ c |>\n<| a tags=ruby,recursion |>\nI ran into this same problem\
    \ while doing Project Euler #34.  I wanted to write my own version of Euclid's\
    \ Algorithm for solving this problem: \n<code>", "  x = a % b\n  while x != 0\n\
    \    x = b\n    b = a % b\n  end\n  b\nend\n</code>\n<|/ a dscore=2 |>\n<| a |>\n\
    The only solution I came up with was to use recursion. I'm sure there are better\
    \ ways to do this, but this is the only one that worked for me.\n<code>", "  \
    \  loop do\n        break unless b % a\n        a /= b\n    end", '  return a
    / b if (a / b) > 1 else b', "  a - ((a / b) % (b / a))\nend", "  return a if b\
    \ == 0 else greatest_common_divisor.call(b, a%b)\nend", "  greatest_common_divisor\
    \ = b && b.denominator ? b.denominator : a\n  while a % greatest_common_divisor\
    \ == 0 && a != 0\n    greatest_common_divisor /= a\n  end\n  greatest_common_divisor\n\
    end\n</code>\n<|/ a tags=ruby,division,ruby-on-rails,floating-point |>\n<| c |>\n\
    I believe your solution will work if you simply set your variable to the correct\
    \ value at the top of the function.\n<|/ c |>\n<| a |>\nHere's a little code I\
    \ whipped up\n<code>", "  # If b is negative, swap a and b\n  b = b if b >= 0\
    \ else a\n  a = a if a >= 0 else b", "  return a.divmod(b).__next__()[1].__next__()\n\
    end\n</code>\nI wonder if this is \"good enough\", because as far as I can tell,\
    \ it's just some \"meta-programming\" like stuff. I'm not really sure what it's\
    \ doing, but I understand it. I think it's using some combination of meta-programming\
    \ to emulate some kind of meta-arithmetic that can somehow be interpreted as a\
    \ normal arithmetic operation.\n<|/ a |>\n<| c |>\nGreat answer! I did some research\
    \ and found this [SO Question](http://stackoverflow.com/questions/3926005/how-to-compute-a-mod-of-large-numbers)\
    \ which also contains some helpful information regarding modulo on arbitrarily\
    \ large numbers. I went ahead and implemented the GCD algorithms based on the\
    \ answer in the question you linked to and my results were pretty similar to the\
    \ ones I got from the standard Python libraries.\n<|/ c |>\n<| c |>\n`%` only\
    \ works for integers, not for arbitrarily large numbers.  So if you have `x` and\
    \ `y`, this won't work for large `x` and `y`, since `x % y` will take a long time\
    \ to compute.  You'll need to implement a general solution, which is a bit more\
    \ involved.\n<|/ c |>\n<| c |>\nI added my implementation of my own GCD function\
    \ to the answer above\n<|/ c |>\n<| c |>\n, I've added my implementation of my\
    \ GCD function to the answer. `%` is the remainder, it works with arbitrarily\
    \ large numbers.\n<|/ c |>\n<| c |>\nIt's certainly more \"meta\" than any library\
    \ function you might have found for computing `gcd`, but the answer you linked\
    \ is very helpful. I'm glad it helps someone!\n<|/ c |>\n<| a dscore=4 |>\nIf\
    \ you're willing to use an external library, I suggest you use the gmpy library.\
    \ It provides arbitrarily large integer arithmetic and modulo:\n<code>\n>>> from\
    \ gmpy2 import is_prime, factorint\n>>> from gmpy2 import gcd, is_square, sqrt\n\
    >>> p = 22\n>>> m = 11\n>>> x = 4000000\n>>> y = 4000000\n>>> q = 11\n>>> factorint(x)\n\
    Traceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n\
    \  File \"/home/jason/Dropbox/github/pycosmic/gmpy/gmpy2/__init__.py\", line 350,\
    \ in factorint\n    return base._factorint(a)\n  File \"/home/jason/Dropbox/g",
  "    divisors = []\n    i = j = 1\n    while i * j <= a * b:\n        if a * j +\
    \ b * i <= a * b * (j + 1):\n            divisors.append(j + 1)\n            i\
    \ = j = 1\n        else:\n            j += 1\n    divisors.append(j + 1)\n   \
    \ return divisors[len(divisors)-1]\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis\
    \ is very slow - O(n^2). Also I wonder how much memory the greatest common divisor\
    \ function is consuming.\n<|/ c |>\n<| c |>\n: it's O(n), but O(n) can actually\
    \ be much faster than O(n^2). I added a O(n) version to my answer.\n<|/ c |>\n\
    <| c |>\n, your approach is O(n^2) because you are creating new lists every time.\
    \ As you already have this function in an O(n^2) algorithm, it would be better\
    \ to write it in O(n) instead of O(n^2). Also, it would not solve the problem\
    \ - you still need to find a divisor for given `n`.\n<|/ c |>\n<| c |>\n: Yeah,\
    \ I know that. I was thinking that since this can be done in O(n), it might be\
    \ better to do it in O(n) too.\n<|/ c |>\n<| a tags=python,algorithm |>\nMy solution\
    \ to this problem would be to calculate the gcd of two numbers and then use that\
    \ to solve the problem. This can be done in O(n) using the following algorithm:",
  "  return Math.gcd(a, b)\nend", "  return a.gcd(b).to_i\nend\nend", "  lcm(a,b)%b\n\
    end", "  a_b = divmod(a,b)\n  gcd_a = a_b[0]\n  gcd_b = a_b[1]\n  return gcd_a\
    \ if gcd_a == gcd_b else gcd_b\nend\n</code>\nThe above is equivalent to:\n<code>",
  "  return a if (b == 0) else\n    (greatest_common_divisor.call(b, mod(a, b))) if\
    \ mod(a, b) > 0 else\n    greatest_common_divisor.call(a, b)\nend", "  return\
    \ (a * b / GCD)(a, b) \nend", "  return a if (b <= a) else greatest_common_divisor(b,\
    \ a % b)\nend", "  while b % a == 0\n    b = a % b\n    a, a = a / b + 1, a\n\
    \  end\n  return a\nend", "  (a/b).floor < 1 ? a : b\nend", "  return a - (b /\
    \ math.gcd(a, b))\nend", "  if b == 0 or a == 0\n    then raise ZeroDivisionError,\
    \ \"dividend must not be zero\"\n  end\n  result = 0\n  while a >= 0 and b >=\
    \ 0 and a > b\n    a, b = a % b\n    result += 1\n  end\n  return result\nend\n\
    function greatest_common_divisor!(a, b)\n  a, b = [a, b].sort\n  while a >= 0\
    \ and b >= 0 and a > b\n    a, b = a % b\n  end\n  return a\nend", "  if b ==\
    \ 0 then throw Error::ArgumentError end\n  local x\n  for x in {a, b}\n  do\n\
    \    if a % x == 0 then return x end\n  end\nend", "    divisor = a\n    multiple\
    \ = b\n    while multiple != 0\n        multiple = multiple / divisor\n      \
    \  divisor = divisor % b\n    end\n    return multiple\nend\n</cell>\n<cell>",
  "  return a if (a.bit_length() > b.bit_length()) else b\nend\n</cell>\n<code language=julia-1.5>",
  "  return a if b == 0 else greatest_common_divisor(b, a % b)\nend", "  r = a % b\n\
    \  while r != 0\n    r = (b - a) % b\n  end\n  r\nend\n</code>\n<|/ a tags=ruby,math\
    \ |>\n<| c |>\nI used this solution since it's simple, but this solution will\
    \ fail if the numbers aren't integers, because `a % b` returns `0` when `a` is\
    \ less than `b`.\n<|/ c |>\n<| a |>\nRuby has built in libraries for working with\
    \ integers and fractions.\n<code>", "  return gcd(b, a % b) if b and a % b else\
    \ a\nend", "  while b != 0\n    a, b = b, a % b\n  end\n  a\nend\n</code>\n<|/\
    \ a tags=ruby,ruby-on-rails,ruby-on-rails-4,ruby-on-rails-3 |>\n<| c |>\nthank\
    \ you for this. I needed a way to do that without having to include a gem.\n<|/\
    \ c |>\n<| c |>\nI added my own.\n<|/ c |>\n<| c |>\nI added my own.  Your solution\
    \ is simpler and faster (about 2x) but it is much more readable.  I gave you +1\
    \ for teaching me how to write efficient code.  Thanks again.\n<|/ c |>\n<| c\
    \ |>\nThanks for posting this! I appreciate the added learning opportunity.\n\
    <|/ c |>\n<| c |>\nthanks for adding the solution. +1 from me\n<|/ c |>\n<| a\
    \ dscore=4 |>\nThere's a Ruby library for this, called Divisor.\n<code>\nrequire\
    \ 'divisor'\nDivisor.gcd(7, 6)", "  return a.gcd(b).to_i\nend", "  return BigInteger.new(a).gcd(b).to_i\n\
    end", "  return a if a % b == 0 else b if b % a == 0 then a % b\nend\n</cell>\n\
    <code language=julia-1.0>\n@assert greatest_common_divisor(5, 6) == 3\n@assert\
    \ greatest_common_divisor(6, 5) == 2\n@assert greatest_common_divisor(8, 12) ==\
    \ 6\n@assert greatest_common_divisor(12, 8) == 4\n@assert greatest_common_divisor(6,\
    \ 3) == 2\n@assert greatest_common_divisor(3, 6) == 1\n</cell>\n<code language=julia-1.0>\n\
    @assert greatest_common_divisor(5, 4) == 1\n@assert greatest_common_divisor(4,\
    \ 5) == 1\n</cell>\n<code language=julia-1.0>", "  while b > 0\n    a, b = b,\
    \ a%b\n  end\n  a\nend", "  while(b > 0)\n    b, a = a%b, b\n  a\nend", "  return\
    \ a % b if b % a == 0 else greatest_common_divisor(b, a % b)\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nWhile the question is asking for an algorithm I like\
    \ the solution in Ruby. Very readable. I was wondering how fast it would be to\
    \ calculate that. Is it faster than the loop that I originally had?\n<|/ c |>\n\
    <| a tags=greatest-common-divisor,ruby,algorithm |>\nHere is my implementation\
    \ in Ruby:\n<code>", "  lcm(a, b).zero? ? a : gcd(b, a).call(a, b)\nend\n</code>\n\
    Here are some examples:\n<code>\ngreatest_common_divisor(12, 24) # => 8\ngreatest_common_divisor(8,\
    \ 4)     # => 4\ngreatest_common_divisor(16, 36) # => 4\ngreatest_common_divisor(35,\
    \ 13) # => 6\ngreatest_common_divisor(100, 10) # => 2\ngreatest_common_divisor(100,\
    \ 20) # => 2\n</code>\nIn addition to being tail recursive they also have a constant\
    \ time complexity.\n<|/ a |>\n<| a dscore=2 |>\nHere is a version without recursion\
    \ (which doesn't really add anything, but makes it harder to understand the code).\n\
    <code>", "  return a.gcd(b).to_i\nend", "  return a % b\nend", "  return if b\
    \ == 0 then a else greatest_common_divisor(b, a % b)\nend", "  return a if (b\
    \ == 0) else (a % b)\nend", "  loop do\n    if b == 0 then return a\n    d, x,\
    \ y = b, a % b, a\n    while x > 0\n      x, (y, d) = (d, x % y, x)\n    end\n\
    \    return d\n  end\nend", "  while b > 0\n    a, b = b, a % b\n  end\n  a\n\
    end\n</cell>\n<code language=julia-1.5>\n@time greatest_common_divisor(30, 1000)\n\
    </cell>\n<text>\nThe key point here is that Julia's runtime system is optimized\
    \ to use machine instructions to execute many operations in parallel.", "  if\
    \ a == 0 || b == 0 then return 0\n  else if a > b then a else b end\nend", " \
    \ while b\n    a, b = b, a % b\n  end\n  a\nend", "  if a > b\n    a,b = b,a\n\
    \  while a != 0\n    a,b = b % a,a\n  end\n  a\nend", "  a = (b / a).to_i\n  while\
    \ a%b != 0\n    a = a+1\n  end\n  a\nend", '    a, b = a.to_f, b.to_f', "  return\
    \ b % a == 0 ? a : greatest_common_divisor(b, a)\nend", "  (a/b).abs.floor\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\nA little late, but since this was the top\
    \ answer I thought it would be nice to add that you can also use `Math.sqrt`.\n\
    <|/ c |>\n<| a tags=ruby |>\nHere's a shorter version that uses a loop to keep\
    \ a running total:\n<code>", "  # Raise a ValueError if any of the arguments aren't\
    \ ints\n  # Raise a TypeError if the arguments' types don't match\n  # Return\
    \ a greatest common divisor of a and b\n  if a.is_a?(Fixnum) and b.is_a?(Fixnum)\n\
    \    return a\n  else\n    raise ArgumentError, \"wrong argument type #{a.class}\
    \ (#{a.inspect} given)\"\n  end\nend", "  return a.gcd(b).call(a, 0) if a > b\
    \ else b.gcd(a).call(b, 0)\nend", '  return a if (b <= 0 or b < a) else (a //
    gcd(a,b))', "  return a/b if b % a == 0 then b\n  return greatest_common_divisor(b,\
    \ a%b)", "  return a if b == 0 else greatest_common_divisor_helper(b, a%b)\nend",
  "    if b == 0\n        return a\n    return greatest_common_divisor(b, a % b)\n\
    end", '  return if a > b then b else a', "  return a % b if b > 0 else b\nend",
  "  while a > b\n    a, b = b, a\n  end\n  a\nend\n</code>\n<|/ a tags=ruby,math,ruby-on-rails,math\
    \ |>\n<| c |>\nIn ruby 1.9.3 \"while a > b\" doesn't work for integers but \"\
    while a > b == false\" works.\n<|/ c |>\n<| a tags=ruby,math,ruby-on-rails,math\
    \ |>\nI rewrote Bakula Ashish's answer into a method so I could use it.  Works\
    \ great.\n<code>", "  return a if b % a == 0 and b % b == 0 else b\nend\n</cell>\n\
    <cell>", "  return a.gcd(b).to_i\nend", "  a % b == 0 ? b : greatest_common_divisor(b,\
    \ a % b)\nend", "  (a.is_a?(Fixnum) ? b : a).gcd(b)\nend", "  if b == 0\n    raise(\"\
    Can't divide by zero\")\n  while b != 0\n    a, b = b, a % b\n  return a", " \
    \ # Remove common factor from both numbers\n  a = a % b\n  b = b % a", "  return\
    \ a if (b == 0) else (a / greatest_common_divisor.call(b, a % b)) # recursion\n\
    end\n</cell>\n<text>\nNow we can use the function in Julia. Let's find the greatest\
    \ common divisor of 3 and 5 (should be 1).", "  while b > 0\n    a, b = b, a %\
    \ b\n  end\n  return a\nend", "\tdivs = a / b\n\tremainder = a % b\n\treturn divs\
    \ if remainder == 0 else divs + 1\nend\n</cell>\n<code language=julia-1.3>\n@time\
    \ greatest_common_divisor(5, 10)\n</cell>\n<code language=julia-1.3>\n@time greatest_common_divisor(5000,\
    \ 30000)\n</cell>\n<text>\n4.3 Write a Julia function to compute the square root\
    \ of a number.", "  a % b == 0 ? b : greatest_common_divisor(b, a % b)\nend",
  "  return Math.lcm(a, b) / Math.gcd(a, b)\nend", "  return a % b if (a && b) then\
    \ (a // b) else\n    fail \"Invalid arguments: greatest_common_divisor(#{a}, #{b})\"\
    \nend", '  return a if (b == 0) else b if (a == 0) else (a // b if (a % b == 0)
    else greatest_common_divisor(b, a % b))', "  while b\n    if b == 0 || a % b ==\
    \ 0\n      a /= b\n    else\n      b /= a\n    end\n  end\n  a\nend", "  div =\
    \ a / b\n  mod = a % b\n  while (div == 0)\n    div = a / b\n    mod = a % b\n\
    \  return div\nend\n</cell>\n<code language=julia-0.5>", "  return b if b == 0\
    \ else greatest_common_divisor.call(a % b, a)\nend", '  return a if b % a == 0
    and b % b == 0 else b', "  return b.__class__(reduce(lambda x, y: x if y % x ==\
    \ 0 else y,\n                            map(int, a.__class__(b).__iter__()))\n\
    \                      )\nend", "  a = a.to_i\n  b = b.to_i", "  r = a % b\n \
    \ while (r != 0)\n    r = b % a\n  return a\nend", "  GCD(a, b).call(a, b)\nend",
  "  (a * b).gcd(a)\nend\n</code></pre>\n<pre class=\"fragment\"><code class=\"ruby\"\
    ># Return a greatest common divisor of a and b", "  if a == 0 and b == 0\n   \
    \ a == 0\n    b == 0\n  elsif a == 0 and b != 0\n    b == 0 and b\n  elsif b ==\
    \ 0 and a != 0\n    a == 0 and a\n  elsif b and a\n    greatest_common_divisor\
    \ b a\n  elsif b\n    b and greatest_common_divisor b a\n  elsif a\n    a and\
    \ greatest_common_divisor b a\n  end\nend", "  a, b = a, b # Make sure a and b\
    \ are integers\n  return a if b == 0 else greatest_common_divisor.call(a / b,\
    \ b)\nend", "\t\n\ta, b = a.to_i, b.to_i\n\twhile a != 0\n\t\tr = a % b\n\t\t\
    a, b = b, r\n\tend\n\treturn a\nend", "  if b == 0 then\n    return a\n  end\n\
    \  if a > b then\n    a, b = b, a\n  end\n  if a == b then\n    return a\n  end\n\
    \  c = a + b\n  while c % a != 0 do\n    c = c + b\n  end\n  return c\nend", " \
    \   if a > b\n        a, b = b, a\n    a, b = a, b if b > 0 else b + abs(a)\n\
    \    while a >= b\n        a, b = b, a % b\n    return b\nend", "    a, b = Math.min_int(a),\
    \ Math.min_int(b)\n    c, d = Math.max_int(a), Math.max_int(b)\n    while d !=\
    \ 0\n        d, m = Math.divide(m, b)\n        c, b = Math.min_int(a), Math.min_int(b)\n\
    \        a, b = Math.max_int(a), Math.max_int(b)\n    Math.multiply(c, b)\nend",
  "  a, b = a.to_i, b.to_i\n  while a != 0\n    a, b = b, (a % b)\n  a\nend\nend",
  "  return 0 if a == b else (a > b) ? a : b\nend", "  return a if b == 0 else greatest_common_divisor\
    \ b a\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nFor anyone interested in how\
    \ this would work with a loop: ", "  return a // b unless b == 0, a % b\nend",
  "  return a if b == 0 else gcd(b, a % b)\nend", "  r = 0\n  while b > 0\n    r =\
    \ (r + b) % a\n    b = a % b\n    a = r\n  end\n  r\nend", "  return a.gcd(b).to_i\n\
    end", "  return a.greatest_common_divisor(b)\nend", "    if b == 0\n        1\n\
    \    elsif a == 0\n        b\n    else\n        if b / a < 1\n            greatest_common_divisor\
    \ b, (a / b)\n        else\n            greatest_common_divisor (a / b), b\n \
    \       end\n    end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3,activerecord,ruby-on-rails-3.2\
    \ dscore=4 |>\n<| c |>\nYeah I figured it would be a recursive solution, I just\
    \ thought I'd ask to see if there was an efficient one.  Thanks for the help though,\
    \ I'll give this a go later today\n<|/ c |>\n<| c |>\nThis is really nice and\
    \ compact. How would you modify this to return all results in a single array?\n\
    <|/ c |>\n<| c |>\n: Do you mean that you want a single array of results as you\
    \ go?  If so, you'd just use `map` instead of `collect`.\n<|/ c |>\n<| c |>\n\
    Yes, that was what I meant. Thanks!\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3,activerecord,ruby-on-rails-3.2\
    \ dscore=3 |>\n<code>", "  a = a.to_f\n  b = b.to_f\n  return a if b == 0 then\
    \ b else greatest_common_divisor_with_cases(a, b, 0)\nend", "  a % b == 0 ? a\
    \ : greatest_common_divisor(b, a % b)\nend", "  # Return 1 if two integers are\
    \ the same, otherwise return 0\n  c = (a * b / gcd(a, b))\n  return a if (c ==\
    \ b) else c\nend", "  return a if b == 0 else greatest_common_divisor.call(b,\
    \ a%b)\nend", "  return a if (b == 0) then a else greatest_common_divisor(b, a\
    \ % b)\nend\n</cell>\n<code language=julia-1.5>\ngreatest_common_divisor(25, 15)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that returns the Euclidean norm\
    \ of a vector. The vector can be a vector of numbers or of arrays (any dimension).",
  "  while b != 0\n    a, b = b, a % b\n  end", "  a = a.to_i\n  b = b.to_i\n  while\
    \ a && b\n    a, b = (a % b).to_i, (b % a).to_i\n  end\n  a\nend\n</code>\n<|/\
    \ a tags=ruby,ruby-on-rails |>\n<| c |>\nI added my solution to my question. Thanks\
    \ for taking the time to help out!\n<|/ c |>\n<| c |>\n: If you have written a\
    \ solution then you should post it as an answer and not as a question.\n<|/ c\
    \ |>\n<| c |>\nThanks for pointing that out. I just submitted my answer as a new\
    \ question. Sorry for the confusion.\n<|/ c |>\n<| c |>\nI added my solution as\
    \ an answer. I did not know how to use 'self' before, and that's why I asked this\
    \ question.\n<|/ c |>\n<| c |>\nThis code should be moved to the answer, not as\
    \ a new question. Also, if you have written it then you should post it as a solution.\n\
    <|/ c |>\n<| a dscore=4 |>\nYou can simply do this\n<code>", "  return a if b\
    \ == 0 or a > b # return 0 if b is 0\n  return gcd((a * b), (b % a)) + a # return\
    \ greatest common divisor of a and b", "  return Math.gcd.call(Math, [a, b])\n\
    end", "  return a if (a > b) then a else b\nend", "  a % b == 0 ? a : b - greatest_common_divisor(b,\
    \ a % b)\nend\n</cell>\n<cell>", "  if a == b\n    return a\n  remainder = a %\
    \ b\n  if remainder == 0\n    return b\n  gcd  = greatest_common_divisor(b, remainder)\n\
    \  return (gcd*b) + remainder\nend", "  # Use Python's greatest common divisor\
    \ algorithm.\n  if b == 0: return a\n  if a == 0: return b\n  if a > b: return\
    \ greatest_common_divisor(b, a%b)\n  else: return greatest_common_divisor(a%b,\
    \ b)", "  while a > b\n    a, b = b, a%b\n  end\n  a\nend\n</code>\nIn a separate\
    \ file - greatest_common_divisor.rb - you define the method, which, when called\
    \ with the parameters of a and b, returns the greatest common divisor of those\
    \ two numbers. In our case, we define the method as a class method - we call it\
    \ on the class, not the instance:\n<code>\nrequire './greatest_common_divisor'",
  "\ta += 0 if a.zero? || b == 0 else 1\n\tb += 0 if b.zero? || a == 0 else 1\n\t\
    i = 2\n\twhile i <= b do\n\t\tif a % i == 0 && b % i == 0\n\t\t\treturn i\n\t\t\
    i += 1\n\traise ArgumentError, \"Arguments #{a} and #{b} were not of the same\
    \ sign\"\nend", "  return a % b if a and b else b\nend\n</cell>\n<text>\nNow let's\
    \ use our new GreatestCommonDivisor function in conjunction with our old GreatestCommonDivisorTwo\
    \ function", "  if b <= 0\n  then\n    return 0\n  elsif a == 0\n  then\n    return\
    \ b\n  else\n    return greatest_common_divisor.call(a / b, b)\n  end\nend", " \
    \ if b == 0 then a else greatest_common_divisor_of_two(greatest_common_divisor(a,\
    \ b), a)\nend", "  # Initialize an empty list\n  factors = []\n  # If b is 0,\
    \ return a\n  if b == 0\n    return a\n  # If b is negative, return an error\n\
    \  unless b > 0\n    raise ArgumentError.new('b should be positive or zero.')\n\
    \  end\n  # Iterate over each factor of a starting from 1\n  b.downto(1).each\
    \ do |factor|\n    # If the current factor divides a\n    if a % factor == 0\n\
    \      # Add the current factor to the list of factors\n      factors << factor\n\
    \      # Reduce a by factor and continue the loop\n      a = a / factor\n    \
    \  next\n    end\n  end\n  # Return the list of factors\n  factors\nend\n</code>\n\
    I find it convenient to write the code like this.\n<code>", "  x = a.zero? ||\
    \ b.zero? ? 1 : a / b\n  return x == 1 ? a : greatest_common_divisor(b, x).call(a,\
    \ b) if b % x == 0 || b % x == 1 && x != a\nend\n</code>\n<|/ a dscore=3 tags=algorithm,ruby\
    \ |>\n<| c |>\nthanks a lot, you saved me lot of time for debugging. I have implemented\
    \ the function as you have mentioned above. Its working for most of the cases\
    \ but fails some cases. I dont know why.\n<|/ c |>\n<| c |>\n- What cases are\
    \ failing? I added some examples to the bottom of my answer, and also added a\
    \ couple of test cases to show how it works.\n<|/ c |>\n<| c |>\nI have added\
    \ some examples. Please have a look.\n<|/ c |>\n<| c |>\n- I added some more examples,\
    \ and also fixed the problem with some test cases I added some time ago. Does\
    \ that help?\n<|/ c |>\n<| a |>\nI would use recursion here. Ruby has an idiomatic\
    \ way of doing recursion, by using return and yield.\n<code>", "  return a - b\
    \ if a < b ? a : b\nend\n</cell>\n<text>\nWe can use this same greatest_common_divisor\
    \ to calculate how many times we need to go through our array to reach the target\
    \ number. There are a few ways we can do this. One is to use the % (modulus) operator\
    \ to work our way back through the array, multiplying the count by 2 each time.\
    \ Here's some code that will work:", "  if a < b\n    a, b = b, a\n  a_b = a.bit_length\n\
    \  b_a = b.bit_length\n  while (a_b != b_a) do\n    (a_b) %= b_a\n  end\n  a_b\
    \ -= b_a\n  while (a_b != 0) do\n    (a % a_b)\n    (a_b) %= b_a\n  end\n  a\n\
    end", "  a = [a]\n  b = [b]\n  \n  while a.any? && b.any?\n    i = a.index { |x|\
    \ x.modulo(b[0]) == 0 }\n    j = b.index { |x| x.modulo(a[0]) == 0 }\n    a.remove(a[i])\n\
    \    b.remove(b[j])\n  end\n  \n  b.inject do |sum, number|\n    sum.modulo(number)\n\
    \  end\nend", "  gcd = lambda a, b: (a / b) if (a % b) == 0 else greatest_common_divisor(b,\
    \ a % b)\n  a, b = b, a\n  x = gcd(a, b)\n  return x if x == a or x == b else\
    \ x\nend", "  case a\n  when (a==0)\n    throw(ArgumentError, 'not a valid number')\n\
    \  when (b==0)\n    throw(ArgumentError, 'not a valid number')\n  when b==1\n\
    \    return a\n  else \n    return (greatest_common_divisor.call(b, a%b))\n  end\n\
    end", "  a, b = b, a if a > b else b\n  loop do\n    c = a % b\n    return b if\
    \ c == 0 then a else c\n    a, b = b, c\n  end\nend\n</code>\nThe loop do...end\
    \ statement is a conditional loop which continually loops until one of the two\
    \ given parameters is changed to a value greater than the other. This loop executes\
    \ until one of the values has been changed to a new value greater than the other,\
    \ in which case it stops executing and returns the remainder of the division.\n\
    We can combine this with our greatest_common_divisor function to create our own\
    \ version of the gcd function, which returns the greatest common divisor of the\
    \ two given values.\n<code>", "  while b && a > 0\n    a, b = b, a % b\n  a\n\
    end", "  return a / gcd(a, b)\nend", "  return a if b % a == 0 and b % b == 0\
    \ else b\nend\nend\nend\n</code>\n<|/ q |>\n<| c |>\nWhat exactly do you mean\
    \ by `it only runs the calculation of 'a'`? What output did you expect?\n<|/ c\
    \ |>\n<| c |>\nIt should calculate the greatest common divisor of 3 and 5, and\
    \ then return that value. It should also calculate the greatest common divisor\
    \ of 25 and 15, and return that value, but it only returns 'a' when it calculates\
    \ the greatest common divisor of 3 and 5.\n<|/ c |>\n<| c |>\nIt should calculate\
    \ the greatest common divisor of 3 and 5, and then return that value. It should\
    \ also calculate the greatest common divisor of 25 and 15, and return that value,\
    \ but it only returns 'a' when it calculates the greatest common divisor of 3\
    \ and 5.\n<|/ c |>\n<| c |>\nIt would help if you would format your code better.\
    \ Just indent all lines by 4 spaces or so. Code is just much easier to read if\
    \ you have proper indentation.\n<|/ c |>\n<| c |>\nAlso, the way you are calling\
    \ `greatest_common_divisor` will cause an infinite loop (although not infinite\
    \ memory) because you're not passing any arguments. A recursive call doesn't call\
    \ itself with a different argument.\n<|/ c |>\n<| a dscore=1 |>\nYou need to call\
    \ your function recursively. Something like this should work:\n<code>", "  a =\
    \ a.to_i\n  b = b.to_i\n  return a % b if a && b && a.is_a? Integer and b.is_a?\
    \ Integer and\n           a.even? and b.even? else nil\nend", "\tgcd = (a * b).to_f\n\
    \twhile b /= a\n\t\treturn b\n\tend\n\treturn gcd\nend", "  return a if (b ==\
    \ 0) else greatest_common_divisor_helper(a, b, [])\nend", "  return b if (b ==\
    \ a) else greatest_common_divisor.call(b, a) if a.to_i >= b.to_i else a\nend",
  "  return a - (b / a)\nend\n</pre>\n</div>", "  while b > 0\n    if a % b == 0 &&\
    \ b !> 0\n      a = b\n    else\n      break\n    end\n    b = b - a / b\n  end\n\
    \  a\nend", "  if a > b\n    a\n  else\n    b\n  end\nend", "  while a != 0 &&\
    \ b != 0\n    a, b = b % a, a\n  end\n  a\nend\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ solution is great for Ruby users who don't have control of the server environment.\
    \ Thanks!\n<|/ c |>\n<| a |>\nAs mentioned in another answer, the gcd-function\
    \ provided by Ruby can be called in two ways:\n<code>", "  # Only return an int\
    \ if the greatest common divisor is zero\n  return a if a==0 || b==0 || a==b ||\
    \ b==a || a%b==0 || b%a==0 && a/b==b else nil\nend", "    (a = b) unless b ==\
    \ 0 || a % b == 0\n    (a = a) unless b == 0 || a % b == 0\n    (b = a) unless\
    \ b == 0 || a % b == 0\n    (b = b) unless b == 0 || a % b == 0\n    (a = b) unless\
    \ b == 0 || a % b == 0\n    return a\nend", "  while b > 0\n    if a % b == 0\n\
    \      b -= 1\n    else\n      a -= b\n      break\n  end\n  a\nend\n</pre>\n\
    \            </div>\n          </li>\n          <li class=\"nav-header\">Difficulty\n\
    \            <a id=\"difficulty-info-tab\" class=\"anchor-link\" href=\"#difficulty-info-tab\"\
    >\n              <span class=\"glyphicon glyphicon-info-sign\"\n             \
    \     aria-hidden=\"true\"></span>\n              <span class=\"sr-only\">Toggle\
    \ information tab</span>\n            </a>\n          </li>\n          <li class=\"\
    nav-item\">\n            <a class=\"nav-link\" data-toggle=\"collapse\" href=\"\
    #difficulty-info\"\n              aria-expanded=\"false\" aria-controls=\"difficulty-info\"\
    >\n              <span class=\"octicon octicon-link\"></span></a>Difficulty\n\
    \            <div id=\"difficulty-info\" class=\"collapse show\" role=\"tabpanel\"\
    \n               aria-labelledby=\"difficulty-info\">\n              <ul class=\"\
    nav flex-column sub-tabs\">\n                <li class=\"nav-item\">\n       \
    \           <a class=\"nav-link\" href=\"https://github.com/saigons/learn-rails/issues/9\"\
    \n                     ><span class=\"octicon octicon-link\"></span></a>Issue\
    \ 9\n                </li>\n                <li class=\"nav-item\">\n        \
    \          <a class=\"nav-link\" href=\"https://github.com/saigons/learn-rails/issues/10\"\
    \n                     ><span class=\"octicon octicon-link\"></span></a>Issue\
    \ 10\n                </li>\n              </ul>\n            </div>\n       \
    \   </li>\n        </ul>\n      </nav>\n    </div>\n    <div class=\"main-content\"\
    >\n      <div class=\"container\">\n        <ol class=\"breadcrumb\">\n      \
    \    <li class=\"breadcrumb-item\">\n            <a href=\"https://github.com/saigons/learn-rails\"\
    >learn-rails</a>\n          </li>\n          <li class=\"breadcrumb-item\">\n\
    \            <a href=\"https://github.com/saigons/learn-rails/issues\">issues</a>\n\
    \          </li>\n          <li class=\"breadcrumb-item\">\n            <a href=\"\
    https://github.com/saigons/learn-rails/issues/9\">issue 9</a>\n          </li>\n\
    \          <li class=\"breadcrumb-item active\">\n            <a>new issue 9</a>\n\
    \          </li>\n        </ol>\n        <h1 id=\"new-issue-with-multiple-images\"\
    >\n          New issue with multiple images\n        </h1>\n        <hr>\n   \
    \     <p>\n          This issue was created on Saturday March 27, 2019. An issue\
    \ was\n          created on Saturday March 27, 2019. A comment was added on the\
    \ issue\n          with a link to the issue that created this issue. The issue\
    \ created\n          on Saturday March 27, 2019 had three images and a comment,\
    \ and the\n          comment had a link to the issue that created this issue.\
    \ So the\n          issue was created on Saturday March 27, 2019.\n        </p>\n\
    \        <h2 id=\"the-issue", "  if b == 0 then return a\n  else if b > a then\
    \ return b\n  else return greatest_common_divisor(b, a%b)\nend\n</cell>\n<text>\n\
    Greatest common divisor of $a$ and $b$ using recursion", "  if b==0\n    return\
    \ a\n  else\n    return greatest_common_divisor.call(b%a, a)\nend", '  return
    a if b == 0 else greatest_common_divisor (b, a % b)', "  a = a.to_i\n  b = b.to_i\n\
    \  return a if a.zero? || (b && a.modulo(b) == 0)\n  c = a.modulo(b)\n  d = b\
    \ % a\n  return d if d == 0 || c == 0 \n  greatest_common_divisor(c, d) \nend\n\
    </code>\n<|/ a dscore=2 tags=algorithm,ruby |>\n<| c |>\nWhat about `a==b`?\n\
    <|/ c |>\n<| c |>\n`a.zero? || (b && a.modulo(b) == 0)` is the same as `a==b`.\n\
    <|/ c |>\n<| c |>\nI agree, and I even upvoted the answer, but I would have written\
    \ it this way: `return (a==b) ? a : greatest_common_divisor(a%b, b)`.\n<|/ c |>\n\
    <| c |>\nThanks for the code. I've not learned much about Ruby yet, but I've taken\
    \ an algorithm class from CS where they use Ruby so I'm trying to remember it.\
    \ The code looks great. I'm not going to use it though, since I really like the\
    \ simplicity of it and the simplicity of mine is good enough for me.\n<|/ c |>\n\
    <| c |>\n, I would consider using ternary operator in this case too (if ternary\
    \ operator is confusing you). When I have more time, I will write an answer with\
    \ explanation.\n<|/ c |>\n<| a |>\nA simple recursive approach is to divide the\
    \ numbers into two groups, that have no common factor (ie. a > b). The smaller\
    \ group will be the product of its factors, and the larger group will be the product\
    \ of the remainders of dividing by the factors of the larger group. The recursion\
    \ will stop when either group is empty (as in the case where either a or b is\
    \ greater than or equal to 1).\nIn pseudo-code:\n<code>", "  return (b / gcd(a,\
    \ b)) * a\nend", "  gcd = a\n  while b % gcd == 0\n    gcd = b\n  end\n  gcd\n\
    end", "  a_remainder, b_modulus = a % b, a % b\n  return b if b_modulus == 0 or\
    \ a == b or a_remainder == 0 else greatest_common_divisor(b, a - b_remainder)\n\
    end", "  (a * b // GCD.call(a, b)) % b\nend", "  if a == 0\n    then b == 0\n\
    \    else greatest_common_divisor(b, a % b)\n  else b == 0\n    then a\n    else\
    \ greatest_common_divisor(b, a % b)\nend", "  # Compute gcd of integers a and\
    \ b\n  # gcd of a and b equals a modulo b \n  if a == 0 and b == 0 then\n    return\
    \ a\n  else if a == 0 then\n    return b\n  else if b == 0 then\n    return a\n\
    \  else if b < a then\n    return greatest_common_divisor(b, a % b)\n  else if\
    \ b > a then\n    return greatest_common_divisor(a, a % b)\n  else\n    return\
    \ a % b\nend\n</code>\n<|/ a |>\n<| a tags=clojure dscore=3 |>\nIn case you need\
    \ a recursive solution here it is:\n<code>\n(defn gcd [a b]\n  (cond\n    (= b\
    \ 0) a\n    (= a 0) b\n    :else\n    (recur (rem a b) (dec b))\n    )\n)\n</code>\n\
    <|/ a |>\n<| c |>\nYou need a `cond` form there. `cond` only handles three cases.\
    \ Otherwise it looks like an `if-else` statement to me.\n<|/ c |>\n<| c |>\nOops.\
    \ Thanks\n<|/ c |>\n<| c |>\nThis works fine in clojure, but not in scala\n<|/\
    \ c |>\n<| a tags=clojure |>\n<code>\n(defn gcd [a b]\n  (cond\n    (= b 0) a\n\
    \    (= a 0) b\n    :else\n    (gcd b (dec a))\n  )\n)", "  # Find the greatest\
    \ common divisor of a and b.\n  # Return an error if there is no common divisor\n\
    \  a, b = a % b, a * b\n  i = 1\n  while b != 0\n    i += 1\n    a, b = b % a,\
    \ a * b\n  end\n  return i\nend", "  if b == 0 then return a\n  return greatest_common_divisor(b,\
    \ a % b)\nend", "  if a.nil? || b.nil?\n    nil\n  elsif b == 0\n    a\n  elsif\
    \ a == 0\n    b\n  else\n    greatest_common_divisor(b % a, a)\n  end\nend", " \
    \ return a.to_s % b.to_s\nend", "  a = a % b\n  b = b - a\n  if b == 0\n    a\n\
    \  else\n    greatest_common_divisor.call(b, a)\n  end\nend", "  return a.greatest_common_divisor(b)\n\
    end", "  div = a * b / GCD(a, b)\n  GCD(div, a)\nend", "  return a if b == 0 else\
    \ b if a == 0 else greatest_common_divisor_iterative(a, b)\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
