name: HumanEval_43_pairs_sum_to_zero
language: rb
prompt: "# pairs_sum_to_zero takes an array of integers as an input.\n# it returns\
  \ true if there are two distinct elements in the array that\n# sum to zero, and\
  \ false otherwise.\n# >>> pairs_sum_to_zero.call([1, 3, 5, 0])\n# false\n# >>> pairs_sum_to_zero.call([1,\
  \ 3, -2, 1])\n# false\n# >>> pairs_sum_to_zero.call([1, 2, 3, 7])\n# false\n# >>>\
  \ pairs_sum_to_zero.call([2, 4, -5, 3, 5, 7])\n# true\n# >>> pairs_sum_to_zero.call([1])\n\
  # false\ndef pairs_sum_to_zero(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pairs_sum_to_zero\n\
  \    candidate = method(:pairs_sum_to_zero)\n    assert_equal(false, candidate.call([1,\
  \ 3, 5, 0]))\n    assert_equal(false, candidate.call([1, 3, -2, 1]))\n    assert_equal(false,\
  \ candidate.call([1, 2, 3, 7]))\n    assert_equal(true, candidate.call([2, 4, -5,\
  \ 3, 5, 7]))\n    assert_equal(false, candidate.call([1]))\n    assert_equal(true,\
  \ candidate.call([-3, 9, -1, 3, 2, 30]))\n    assert_equal(true, candidate.call([-3,\
  \ 9, -1, 3, 2, 31]))\n    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 30]))\n\
  \    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 31]))\n  end\nend\n"
completions: ["  return l.each_cons(2).none? { |a, b| (a + b) < 0 }\nend", "  sum\
    \ = 0\n  l.each_index do |i|\n    sum += l[i]\n    if sum == 0\n      return true\n\
    \    else \n      return false\n    end\n  end\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| a |>\nHere's a way that doesn't require the use of a function.\n<code>\n\
    require \"set\"", "  l.each_with_index do |n, i|\n    next if n == 0\n    l.each\
    \ {|n| return true if n == i}\n  end\n  false\nend\n</cell>\n<cell>", "    return\
    \ pairs?(l.inject(0) {|sum,e| sum + e if sum + e > 0}.nil?)\nend\n</code>\n<|/\
    \ a |>\n<| a dscore=0 tags=ruby,ruby-on-rails,algorithm |>\n<code>\n  def find_pair(arr)\n\
    \    return nil if arr.empty?\n    arr.each_with_index do |e,i|\n      next if\
    \ i > arr.length-1\n      i2 = i+1\n      i3 = i+2\n      while i2 < arr.length-1\
    \ && arr[i3] < arr[i2]\n        i3 += 1\n      end\n      if i2 == arr.length-1\n\
    \        arr[i], arr[i3] = arr[i3], arr[i]\n      end\n      next if i3 > arr.length-1\n\
    \      while arr[i] < arr[i2] && arr[i] < arr[i3]\n        arr[i], arr[i2] = arr[i2],\
    \ arr[i]\n        i2 += 1\n      end\n      arr[i], arr[i2] = arr[i2], arr[i]\n\
    \    end\n  end", "    l.each do |x|\n        l.each do |y|\n            return\
    \ true if x + y == 0\n        end\n    end\n    return false\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nThat is way too complicated for a simple task.\n<|/\
    \ c |>\n<| a |>\n<code>", "  return l.uniq.select {|x| l.all? {|y| y.to_s == x.to_s\
    \ && y.to_i == x.to_i}}.empty?\nend", "  l.sort!\n  result = []\n  sum = 0\n \
    \ for i in 0...l.length\n    sum += l[i]\n    result << [sum]\n  end\n  l.length.times\
    \ do |i|\n    next if i == 0\n    j = i - 1\n    break if l[j] == 0\n    break\
    \ unless l[j] > 0 and l[j] < l[i]\n    sum += l[j]\n  end\n  result.pop\nend",
  "    l.all? { |n| n == 0 || n != n + (l.uniq.length % 2 == 0)}\nend\n</code>\n<|/\
    \ a tags=arrays,ruby |>\n<| a |>\nMy method uses two passes, first to count the\
    \ elements and second to test each pair to see if they are distinct and sum to\
    \ zero in both directions.\n<code>", "  l.sort.each do |i|\n    j = i + 1\n  \
    \  while j < l.length && l[j] == 0\n      j += 1\n    end\n    return false if\
    \ j - i > 1\n  end\n  true\nend\n</code>\nThe ruby code I came up with for this\
    \ exercise can be seen at https://gist.github.com/bmoerker/f1904a258998cc096ae8\n\
    The function pairs_sum_to_zero takes any number of integer arguments and returns\
    \ true only if there are two distinct elements in the array that sum to zero,\
    \ and false otherwise.\nThe code is in Ruby, but it should be fairly easy to translate\
    \ it to any other language.\n<|/ a tags=ruby,arrays |>\n<| a dscore=3 |>\nThis\
    \ is a little bit faster than the ruby one, and is about as concise as you can\
    \ make it.\n<code>", "  l.inject(true) do |result,item|\n    result &&= pair_to_zero.call(item)\n\
    \  end\nend\nputs(\"ok, passed all tests.\")\n</cell>\n<text>\nExercise 2: Use\
    \ inject to compute the number of pairs in the list whose sum is to $0$.", " \
    \ l.uniq!\n  l.sort!\n  pairs = 0\n  l.each_index { |i| pairs += 1 if l[i] + l[i\
    \ + 1] == 0 }\n  pairs == 2\nend", "  return l.inject(true) do |acc, el|\n   \
    \ return acc if el < 0 || !(el > 0 && el < acc.last)\n    acc + (el == 0 || acc.last)\n\
    \  end\nend", "    l.sort!\n    even = 1\n    odd  = 0\n    return even+1 == odd\
    \ if l.size > 1 \n    pair = 0\n    l.each do |i|\n      pair += i if pair !=\
    \ 0 && pair != i\n      if pair == 0\n        even = 1\n      else\n        odd\
    \ = 1\n      end\n    end\n    even+1 == odd\n  end\nend", "  return l.inject(true,\
    \ :&) do |result, (el, i)|\n    result && el == l.delete_at(i)\n  end\nend\n</pre>",
  "  l.group_by { |i| -i }.all? { |k, v| v != 0 }\nend", "  l.each_with_index do |n,\
    \ i|\n    l.size - l.index { |x| n == x }.nil? && return false\n  end\n  true\n\
    end", "  pairs.all? {|x,y| x + y == 0}\nend\n</code>\n<|/ a dscore=3 |>\n<| a\
    \ tags=ruby dscore=2 |>\n<code>\na = [1,2,3,4,5]", "  l.each { |x| return false\
    \ if l.count(x) < 2 }\n  l.uniq.size == l.size\nend", "  l.sort.with_index{|x,i|\
    \ (i+1)*(x-(l[i])).abs < 0} != nil\nend", "  return l.each_cons(2) do |x, y|\n\
    \    y == 0\n  end.any?\nend", "  l.each_cons(2) do |a,b|\n    break if a.nil?\
    \ || b.nil? || a + b == 0\n  end\n  l.each_cons(2) do |a,b|\n    break if a.nil?\
    \ || b.nil? || a + b == 0\n  end\n  l.each_cons(2) do |a,b|\n    break if a.nil?\
    \ || b.nil? || a + b == 0\n  end\n  l.each_cons(2) do |a,b|\n    break if a.nil?\
    \ || b.nil? || a + b == 0\n  end\n  l.each_cons(2) do |a,b|\n    break if a.nil?\
    \ || b.nil? || a + b == 0\n  end\n  l.each_cons(2) do |a,b|\n    break if a.nil?\
    \ || b.nil? || a + b == 0\n  end\n  l.each_cons(2) do |a,b|\n    break if a.nil?\
    \ || b.nil? || a + b == 0\n  end\n  l.each_cons(2) do |a,b|\n    break if a.nil?\
    \ || b.nil? || a + b == 0\n  end\n  l.each_cons(2) do |a,b|\n    break if a.nil?\
    \ || b.nil? || a + b == 0\n  end\n  l.each_cons(2) do |a,b|\n    break if a.nil?\
    \ || b.nil? || a + b == 0\n  end\n  l.each_cons(2) do |a,b|\n    break if a.nil?\
    \ || b.nil? || a + b == 0\n  end\n  l.each_cons(2) do |a,b|\n    break if a.nil?\
    \ || b.nil? || a + b == 0\n  end\n  l.each_cons(2) do |a,b|\n    break if a.nil?\
    \ || b.nil? || a + b == 0\n  end\n  l.each_cons(2) do |a,b|\n    break if a.nil?\
    \ || b.nil? || a + b == 0\n  end\n  l.each_cons(2) do |a,b|\n    break if a.nil?\
    \ || b.nil? || a + b == 0\n  end\n  l.each_cons(2) do |a,b|\n    break if a.nil?\
    \ || b.nil? || a + b == 0\n  end\n  l.each_cons(2) do |a,b|\n    break if a.nil?\
    \ || b.nil? || a + b == 0\n  end\n  l.each_cons(2) do |a,b|\n    break if a.nil?\
    \ || b.nil? || a + b == 0\n  end\n  l.each_cons(2) do |a,", "  l.sort.each do\
    \ |item|\n    (item + 1)*(item + 2) == 0 ||\n    (false)\n  end\nend", "  return\
    \ l.length == 2 and l[0] == l[1] and l[0] > 0\nend", "  l.sort.each do |i|\n \
    \   l.each do |j|\n      next if (j > i)\n      break if j == i - 1\n      break\
    \ if j < i\n    end\n    return false if (i-1) > i\n  end\n  return true\nend",
  "    l.each do |i|\n      l.each do |j|\n        next if i == j\n        return\
    \ false if i + j == 0\n      end\n    end\n    true\n  end\nend", "  l.each do\
    \ |i|\n    l.each do |j|\n      next if j >= i\n      break if j - i == 0\n  \
    \    return false if j - i == 0\n    end\n    return false unless i\n  end\n \
    \ return true\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nNice, but how would\
    \ you improve efficiency for large lists?\n<|/ c |>\n<| c |>\n`[[1], [2], [3]].sort.group_by(&:first).values.all?{\
    \ |v| v.all? { |x| x.last == 0 } }` will give `True` for the example from the\
    \ OP, although it seems to me to be a rather roundabout way of doing it.\n<|/\
    \ c |>\n<| a dscore=1 |>\nAnother way to approach this problem is by breaking\
    \ down the problem into smaller steps.\nThis approach is more efficient for very\
    \ large arrays.\n<code>", "    return l.inject(true, :two?).any? && l.inject(true,\
    \ :one?).any?\nend", "  l.sort!\n  l.reduce!{|x, y| (x + y) * (y + 2) < 0 ? false\
    \ : true}\nend", "  l.inject(true) do |memo, pair|\n    (memo.call (memo.call\
    \ (memo.call pair) pair) pair) || memo\n  end\nend\n</cell>\n<code language=julia-1.0>",
  "  l.each_with_index do |x,i|\n    if i+1 < l.length && l[i] + l[i+1] == 0 then\
    \ return false end\n  end\n  true\nend", "  return l.count(nil) > 1 && l.count(nil).even?\
    \ && l.uniq.count(0) == l.size\nend", "  return l.sort.inject(true, :<<) do |memo,\
    \ pair|\n    memo = memo && pair[-1] == 0\n  end\nend", "  l.each_cons(2).any?\
    \ do |x,y|\n    x + y == 0\n  end\nend", "    l.uniq.each_cons(2) do |v|\n   \
    \   return true if v.sum == 0\n    end\n    false\nend", "  l.uniq!\n  l.sort!\n\
    \  l.inject(true) do |sum_to_zero, e|\n    if sum_to_zero and e.zero?\n      sum_to_zero\
    \ = false\n    elsif sum_to_zero and e != 0\n      sum_to_zero = false\n    end\n\
    \    sum_to_zero\n  end\n  l.uniq!\n  l.empty?\nend", "    l.each_cons(2).all?\
    \ {|a, b| a + b == 0} \nend\n</cell>\n<cell>\npairs_sum_to_zero.call([1, 1, 1])\n\
    </cell>\n<cell>\npairs_sum_to_zero.call([1, -2, 1])\n</cell>\n<cell>\npairs_sum_to_zero.call([1,\
    \ 3, -2, 1])\n</cell>\n<cell>\npairs_sum_to_zero.call([1, 2, 3, 7])\n</cell>\n\
    <cell>\npairs_sum_to_zero.call([2, 4, -5, 3, 5, 7])\n</cell>\n<cell>\npairs_sum_to_zero.call([1])\n\
    </cell>\n<cell>\npairs_sum_to_zero.call([-1, -2, -3, -1, -7, 5, 8, -5, -7, 1])\n\
    </cell>\n<cell>", "  return l.uniq.all? { |n| (0..l.size).none? { |i| (l[i] +\
    \ l[i+1]).zero? } }\nend", "  return l.uniq.reduce(:+) == 0 && l.uniq.size ==\
    \ l.size\nend", "  l.sort!\n  l.uniq!\n  l.length.times{ |i| l.shift}\n  l.inject(true){|a,\
    \ b| a && b.zero? }\nend", "  l.each_cons(2) do |a,b|\n    return true if a -\
    \ b == 0\n    return false\n  end\n  return false\nend", "  # TODO: See if you\
    \ can do it in O(n log n) time and use bucket sort\n  l.each do |l|\n    l.each\
    \ do |r|\n      l.each do |c|\n        if c == r + l\n          return false\n\
    \        end\n      end\n    end\n  end\n  return true\nend\n</cell>\n<cell>",
  "  l.uniq!\n  l.compact.uniq!\n  l.map { |a| a.sum -=0 }\n  l.empty? && return false\n\
    \  l.empty? && return true\n  l.all? { |a| a.sum >= 0 }\nend", "  return l.inject(:+)\
    \ == 0 && l.uniq.size == l.size\nend", "  l.sort!\n  return l[0]==l[-1] && pairs_sum_to_zero.call(l[0..-2])\n\
    end", "  l.each_cons(2) do |a|\n    l.each_index do |i|\n      next if i == 0\n\
    \      break if a[i + 1] + a[i] != 0\n    end\n    return false if a[0] && a[0]\
    \ == a[-1]\n  end\n  true\nend\n  ", "  return true if l.each_cons(2).all? { |x,\
    \ y| x == 0 && y != 0 }\n  false\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>",
  "  l.each_cons(2) do |a, b|\n    next if (b - a)\n    puts \"#{a} #{b}\"\n    true\n\
    \  end\nend\nprint pairs_sum_to_zero([1, 2, 3, -5, 7]), \"\\n\"\nprint pairs_sum_to_zero([1,\
    \ 3, -2, 1]), \"\\n\"\nprint pairs_sum_to_zero([2, 4, -5, 3, 5, 7]), \" \\n\"\n\
    print pairs_sum_to_zero([1]), \" \\n\"\nprint pairs_sum_to_zero([3, 1, 2, 5, 6]),\
    \ \" \\n\"\nprint pairs_sum_to_zero([1, 4, 9, 10, 5, 7, 4, 10, 2, 5, 5]), \" \\\
    n\"\nprint pairs_sum_to_zero([3, -1, 2, -5, -8, 4, 5, -5, 8, -7, -9, -9]), \"\
    \ \\n\"\nprint pairs_sum_to_zero([3, -10, 2, -5, -8, 4, 5, -5, 8, -7, -9, -9]),\
    \ \" \\n\"", "\tl.each do |i|\n\t\tl.each do |j|\n\t\t\tif (i + j != 0)\n\t\t\t\
    \treturn false\n\t\t\tend\n\t\tend\n\tend\n\treturn true\nend", "  l.group_by\
    \ { |i| i }.map { |k, v| [k, v.size > 1 ? v.all? { |i| i == 0 } : false] }.all?\
    \ { |k, has_zero| has_zero }\nend", "  l.each_cons(2) do |a, b|\n    next false\
    \ if (b + a + 1).zero?\n    next false if (a - b + 1).zero?\n    break\n  end\n\
    \  true\nend\n</cell>\n<text>\nThe function pairs_sum_to_zero above accepts arrays\
    \ of integers as an input and returns a boolean indicating whether there are two\
    \ distinct integers in the array that sum to zero.\nNow let's define a function\
    \ sum_of_two_numbers, which takes a single integer as an input and returns two\
    \ numbers. First, it adds one to the integer and returns the new integer, and\
    \ second, it adds one to the output and returns the new integer.\nThe function\
    \ should return a pair consisting of the sum of the two integers, and should return\
    \ nil if there is no such pair.\nIf the sum of the two integers is positive, then\
    \ it should return [a, b], where:", "  return !l.to_a.group_by { |i| l.sum - i\
    \ }.empty?\nend", "  l.each do |n|\n    l.each do |m|\n      if n == m and n !=\
    \ 0\n        return false\n      end\n    end\n  end\n  true\nend\n</code>\n<|/\
    \ a dscore=2 tags=ruby |>\n<| a tags=ruby |>\nThis is probably the simplest solution\
    \ in Ruby. It's probably not the most efficient for very large arrays, but it\
    \ should do the trick.\n<code>", "  return l.count(l[0]) == l.count(l[0] + l[1])\
    \ and l.count(l[0] + l[1]) == 0\nend", "  return l.uniq.map { |x| x.sum == 0 }.all?\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nHere is another way using Ruby's\
    \ Enumerable#partition\n<code>\n(1..100).partition {|i| i.even? }.reduce(:+)\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\nI like this one because it is concise. I\
    \ wonder why they don't include a partition_by. I'm assuming it's not a common\
    \ use case.\n<|/ c |>\n<| a dscore=1 |>\nJust to throw in another way:\n<code>",
  "  l.each do |i|\n    j = l.index(i)\n    return true if i.abs - l[j].abs == 0\n\
    \  end\n  return false\nend", "    l.each_cons(2) do |a,b|\n      return false\
    \ if a.zero? || b.zero?\n    end\n    return true\nend", "  l.sort\n  l.reduce!\
    \ {|x, y| x + y if x != y } == 0\nend", "  l.map { |e| [e, l.count(e)] }.uniq.all?\
    \ do |a, b|\n    a == b && a.all? { |e| e == 0 }\n  end\nend\n</code>\n<|/ a tags=ruby\
    \ dscore=1 |>\n<| a dscore=0 tags=ruby |>\nAs I suggested in my comment, here\
    \ is some code to find pairs of elements in the array that sum to zero.\nCode\n\
    <code>", "  l.sort!\n  \n  pair = nil\n  \n  until pair.nil? do\n    if pair[0]\
    \ != pair[1]\n      return false\n    end\n    \n    pair = pair[2]\n  end\n \
    \ \n  return true\nend", "    l = l.sort\n    l.each_index do |i|\n        l2\
    \ = l[(i+1):]\n        l2.each_index do |j|\n            if l2[j] == l[i]\n  \
    \              return false\n            end\n        end\n    end\n    true\n\
    end", "  l.sort\n  sum = 0\n  l.each_cons(2) do |a, b|\n    sum -= a\n    return\
    \ true if sum == 0\n  end\n  false\nend\n</code>\n<|/ a |>\n<| c |>\nThis does\
    \ not produce the desired results for `[3, 2, -5]`, which is true according to\
    \ the OP's specification.\n<|/ c |>\n<| c |>\nYou are right. I was too quick.\
    \ Edited the answer. I misunderstood the OP's question. Thanks :)\n<|/ c |>\n\
    <| c |>\nIt works now, but it's so complicated. Why would you choose this over\
    \ `pairs.all? { |a,b| a == b }`? It's also not as fast as `pairs_sum_to_zero`.\n\
    <|/ c |>\n<| c |>\nI think this answer is actually the most efficient solution.\
    \ Why do you think that it's not? I ran this on my machine (a Macbook Pro) and\
    \ got `pairs_sum_to_zero 0.08322200257955696` and `pairs.all? { |a,b| a == b }`\
    \ returning `true` in 0.001065 seconds. I'm interested in how you came up with\
    \ this solution. I'd love to learn from it.\n<|/ c |>\n<| c |>\nThe reason this\
    \ one is not the most efficient is the extra work the sort does and O(n) vs O(n\
    \ log n) complexity.\n<|/ c |>\n<| a |>\nThis solution uses the builtin enumerable\
    \ pairs method and is quite fast too:\n<code>\n(1..100_000).to_enum.with_object([])\
    \ { |i, ary| ary << [i, i] }\n                   .select { |x, y| y == 0 }\n \
    \                  .all?(&:first)\n</code>\nEDIT:\nI thought I should add some\
    \ benchmarks comparing the 3 answers I posted.\n<code>", "\tl.inject([[], []])\
    \ do |pairs, sum|\n\t\tpairs.map do |a, b|\n\t\t\tif sum > 0 && a+b == sum\n\t\
    \t\t\tpairs.push([a, b])\n\t\t\tend\n\t\tend\n\tend\n\tl.size > 1\nend\nputs pairs_sum_to_zero.call([2,\
    \ 7, 1, 4])", "  l.each_cons(2) do |a,b|\n    return false if a.nil? or b.nil?\n\
    \    return false if a.zero? and b.zero?\n    return false if a.zero? != b.zero?\n\
    \    return false if a.sum != b.sum\n    return false if a.sum < 0\n    return\
    \ true\n  end\nend", "  return l.inject(true) do |memo, el|\n    memo && memo.last\
    \ || memo || false\n  end\nend", "  return l.count(l.inject(:+)) < 2\nend", " \
    \ l.sort!\n  (n - l).zero? or l[0]+l[-1] == 0\nend", "  return true if l.uniq.count\
    \ > 1\n  pairs.each do |i|\n    pairs.each do |j|\n      return true if i[1] +\
    \ j[1] > 0\n    end\n  end\n  false\nend", "  return l.count > 0 and l.reduce(:+)\
    \ == 0\nend", "  sum = 0\n  l.each_with_index do |elem, i|\n    sum += elem\n\
    \    break if sum == 0\n  end\n  l.each_with_index do |elem, i|\n    break if\
    \ sum != elem\n    sum -= elem\n  end\n  sum == 0\nend", "  l.each_index do |i|\n\
    \    i = l.index_at(i)\n    return false if i >= 0 and i < l.length-1\n    j =\
    \ i+1\n    l.each_index do |j2|\n      j = j+1 if (j2 != i and l[j2].zero?)\n\
    \    end\n    return false if (j-i+1) <= 1\n  end\n  true\nend", "    l.sort!\n\
    \    return false if l.inject(:+) != 0 && l.inject(:+) == 0 end\nend", "  pairs\
    \ = l.chunk(2).map(&:sort)\n  pairs.inject { |sums, pair| sums[0] += pair[0] &&\
    \ sums[1] += pair[1] ? pair[0] + pair[1] : 0 }\n  sums.zero?\nend", "  return\
    \ l.group_by { |i| i }.all? { |k,v| v.all? { |i| i <=> 0 } } ? true : false\n\
    end", "  l.to_set.size == l.to_set.size && l.to_set.sort.all? { |x| x < 0 }\n\
    end", "  return false if l.count < 2\n  first_sum = 0\n  second_sum = 0\n  l.each\
    \ do |x|\n    first_sum += x\n    second_sum += -x\n    return false if first_sum\
    \ == second_sum\n  end\n  true\nend", "  l.group_by {|l| l}.all? {|l,a| a.inject(0)\
    \ {|s, i| s += i } } && l.all? {|l,i| l.sum == i }\nend", "    l.sort.each_index\
    \ do |i|\n        sum = 0\n        l.each_index do |j|\n            sum += l[j]\n\
    \            next if sum > 0\n            sum = 0\n        end\n        return\
    \ false if sum == 0\n    end\n    return true\nend", "  return l.uniq.sort.each_cons(2).inject(true)\
    \ do |m, (c1, c2)|\n    m = (c1 + c2).zero? and m\n    m and m == false\n  end\n\
    end\n</code>\n<|/ a tags=arrays,ruby,sorting,algorithm |>\n<| a dscore=3 |>\n\
    Here's my take:\n<code>", "  l.each_cons(2) do |a,b|\n    return false if a-b\
    \ == 0\n  end\n  true\nend\n</code>\nAnd another way is to use uniq to remove\
    \ the negative numbers from the array:\n<code>", "  return l.inject(true) { |s,i|\
    \ (s & !l[i+1]) }\nend\n</cell>\n<text>\nThe function should return true if the\
    \ array contains two distinct elements that sum to zero.  Otherwise it should\
    \ return false.", "  l.each do |e|\n    l.uniq!\n    l.uniq!\n    return true\
    \ if l.include?(e)\n  end\n  return false\nend", "  l.each do |a|\n    a.each\
    \ do |b|\n      next if b == 0 || a != b\n      b.times { p \"#{$a} + #{$b} =\
    \ 0\" if $a + $b == 0 }\n      puts \"\" if a != 0\n    end\n  end\nend", "  \
    \  l.each_index do |i|\n        if l[i].zero? && l[i+1].zero?\n            return\
    \ true\n        end\n    end\n    false\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nThanks, this is very clever, but I think you need to add something\
    \ to avoid an infinite loop.\n<|/ c |>\n<| c |>\nYou're right, but since we're\
    \ looking for pairs, I think this would be safe enough.\n<|/ c |>\n<| c |>\nI\
    \ don't think it's safe enough.  `nil` is equal to `nil` in Ruby, so the method\
    \ will always return false for an empty array.  You would need some way to handle\
    \ that case in the method itself, without adding another method or changing the\
    \ behavior of the method itself.\n<|/ c |>\n<| c |>\nThanks, I modified it.\n\
    <|/ c |>\n<| a dscore=2 tags=ruby,arrays |>\n<code>", "  l.each_with_index do\
    \ |e, i|\n    break if i > 0 && e - l[i - 1] == 0 || e == 0\n    l.delete_at(i)\
    \ if e == 0\n  end\n  l.size != l.uniq.size\nend", "  pairs.reduce(:&).all? {|a,\
    \ b| b.zero? && a == b}\nend", "    l.each_with_index { |e, i|\n      l.delete_at(i)\n\
    \      if sum.call(e) == 0 && !l.empty?\n        return true\n      end\n    }\n\
    \    return false\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nA small problem with\
    \ your implementation (assuming you meant pair-sum-to-0) is that it is not transitive.\
    \ Consider `[1,1,1]` => `[1,1,2]` => `[1,2,3]`, now `[1,2,3]` is not a pair, but\
    \ `[1,2,4]` is. A simple fix would be to add a third condition: `return true if\
    \ l.empty? || pairs.call(l.last) == l[0..-2]`.\n<|/ c |>\n<| c |>\n-kohler: Yes,\
    \ you're absolutely right. I did not pay attention to the requirements more closely\
    \ when I wrote my solution. Thank you for the correction.\n<|/ c |>\n<| c |>\n\
    : I just realized that my solution only works for positive integers. Sorry.\n\
    <|/ c |>\n<| c |>\n-kohler: No worries, I think your solution is much more elegant,\
    \ but in some ways less efficient.\n<|/ c |>\n<| a dscore=3 |>\nHere is an implementation\
    \ using memoization:\n<code>", "  l.sort!\n  l.uniq!\n  l[0] == 0 && return true\n\
    \  l[-1] == 0 && return false\n  l.size - 2 > l[0..-2].inject { |s,e| s + e }\
    \ &&\n    return false\n  true\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\nA perfect\
    \ solution when trying to find all possible pairs in an array with a length greater\
    \ than 2.\n<|/ c |>\n<| c |>\nI love this answer because it's short and easy.\
    \ I just wanted to point out that as long as `l` is a Ruby Array and doesn't include\
    \ a `sort!`, this answer will find pairs whose sum is zero.\n<|/ c |>\n<| c |>\n\
    Great solution.  Elegant and concise.  I went with the `inject(:+) == 0.0` solution\
    \ in the end.\n<|/ c |>\n<| c |>\nThis solution is perfect for my situation. I\
    \ am a ruby beginner but this solution helped me a lot. Thanks!\n<|/ c |>\n<|\
    \ a |>\nThis problem is called partition problem.\nYou can find good algorithm\
    \ here: https://en.wikipedia.org/wiki/Partition_problem\nIf you don't want to\
    \ use pseudocode, here is the solution in python:\n<code>", "  l.each_cons(2)\
    \ do |x, y|\n    return false if x.nil? || y.nil?\n    return false if x <=> y\
    \ == 0\n  end\n  true\nend\nend", "  l.group_by { |e| (l.count(e) > 1).count {\
    \ |e| (l.count(e) == 1) } }\nend", "  l.each do |i|\n    l.each do |j|\n     \
    \ return false if i + j != 0\n    end\n  end\n  true\nend\n</code>\n<|/ a |>\n\
    <| a |>\n<code>", "    l.sort! # makes the code more efficient\n    return l[1]\
    \ < 0 and l[0] < l[2]\nend", "  l.sort!\n  pairs = []\n  l.each do |i|\n    pairs\
    \ << [i, l[i..-1].sum]\n  end\n  pairs.sort! { |a, b| b[1] <=> a[1] }\n  pairs.first\
    \ == [pairs.last, 0].max\nend\n</code>\n<|/ a tags=algorithm,ruby,arrays |>\n\
    <| c |>\nAwesome. Thanks! I did some reading and it seems that using sort is more\
    \ expensive than using hash tables. I guess my initial thought was that sorting\
    \ and searching would take longer than searching a hash table with O(1) lookups,\
    \ since that's how the hash table works. But now that I think about it, I wonder\
    \ if a hash table has that much of a lookup? Can you give a specific example of\
    \ a hash table lookup?\n<|/ c |>\n<| c |>\nA hash table lookup is basically a\
    \ key-value pair. For example, you have `{'a'=>1, 'b'=>2, 'c'=>3}` and you do\
    \ `Hash['b', 'a']`. When you do `Hash['b', 1]`, it returns a `Fixnum`, not a `String`.\
    \ In a hash table, you can do `Hash['b', 1]` once and get the value of `1` instead\
    \ of doing it each time you want to look up a value. You could also store an `Array`\
    \ of all the values and lookup the array each time.\n<|/ c |>\n<| c |>\n: It's\
    \ more expensive in terms of memory. Sorting is `O(N*logN)`, while building a\
    \ hash table with `N` keys and `N` values in a `Hash` class is `O(N)`. It's `O(N*logN)`\
    \ because you do `N` passes over the array, then `N` passes over the sorted array.\n\
    <|/ c |>\n<| a dscore=2 |>\nHere is a possible implementation of a pure Ruby solution,\
    \ using two helper methods:\n<code>\nrequire 'benchmark'\nrequire 'set'", "\t\
    l.sort!\n\tsum = 0\n\tfor i in l\n\t\tsum += i\n\tl.length.times do |i|\n\t\t\
    return false if sum != 0\n\t\tsum += l[i+1]\n\tend\n\treturn true\nend", "  l.each_index\
    \ do |i|\n    j = i + 1\n    until j == l.size\n      if l[i] + l[j] == 0\n  \
    \      true\n      else\n        false\n      end\n      j = j + 1\n    end\n\
    \  end\nend\n</code>\n<|/ a |>\n<| c |>\nI used `each_cons` instead of `each_index`\
    \ so that the block is only called once.\n<|/ c |>\n<| a dscore=3 tags=ruby |>\n\
    I find the following solution to be simpler and more efficient:\n<code>", "  return\
    \ l.count{|x| l.count(x) % 2 != 0}\nend", "    l.sort!\n    return l.first(l.count)\
    \ == l.last(l.count) && l.uniq.size == 1\nend", "  l.each_cons(2) do |v|\n   \
    \ if v.inject(0) {|n,x| n + x} != 0\n      return true\n    end\n  end\n  return\
    \ false\nend", "  return l.inject(true) do |sum,e|\n    sum = sum and e==0\n \
    \   sum && sum\n  end\nend", "  pairs = l.group_by{|x| x}\n  pairs.each{|x| x[1].each{|y|\
    \ return false if y.to_i == x[0].to_i }}\n  true\nend", "  return l.inject(true,\
    \ :+) && l.uniq.length == 1 && l.uniq.all? { |i| i.zero? }\nend\n</code>\n<|/\
    \ a tags=ruby,loops |>\n<| a dscore=2 |>\nYet another way of doing it, but only\
    \ using a single loop:\n<code>", "    l.length.times { |i| return false if l[i]+l[i-1]\
    \ != 0 }\n    true\nend", "  l.each_with_index do |elem, index|\n    pair = l.slice(index\
    \ + 1, l.size)\n    pair.each { |i| return false if elem == i }\n  end\n  true\n\
    end", "  l.sort!\n  return l.reduce(0) {|acc, x| acc + x != 0 ? false : true}\n\
    end", "  return l.uniq.length == l.uniq.reduce(&:+) && l.uniq.all? do |i| l.index(i).zero?\
    \ end\nend\n  ", "    l.each do |x|\n      l.each do |y|\n\treturn false unless\
    \ x+y == 0\n      end\n    end\n    true\nend", "  l.each do |i|\n    l.each do\
    \ |j|\n      if i > j\n        break if i - j == 0\n      elsif i == j\n     \
    \   break if i - j == 0\n      end\n    end\n  end\n  l.uniq.size == l.size\n\
    end", "  l.length.times do |i|\n    j = i + 1 unless l.length < j\n    break if\
    \ l[i] + l[j] == 0\n  end\n  i != j\nend", "  l.sort.each do |i|\n    l.each do\
    \ |j|\n      break false if i + j < 0\n    end\n  end\n  true\nend", "  if l.count\
    \ > 1\n    l.sort\n    return true\n  l.each_index do |i|\n    return true if\
    \ l[i] == 0 &&\n      l[(i+1)..-1].all? do |j|\n      j == 0\n    end\n  end\n\
    \  return false\nend", "  l.sort!\n  i = 0\n  j = i + 1\n  while j < l.length\n\
    \    k = j + 1\n    while k < l.length and l[i] + l[j] == l[k]\n      k += 1\n\
    \    end\n    return k - j == 0 if k < j\n    j += 1\n  end\n  return false\n\
    end", "  sum = 0\n  l.each do |x|\n    sum += x\n  end\n  sum == 0\nend\nend\n\
    </code>\n<|/ a tags=arrays,ruby,combinations,permutation,ruby-1.9.3 |>\n<| c |>\n\
    +1 for the `uniq` suggestion. I should have thought of that - but this is exactly\
    \ what I would have done in the first place.\n<|/ c |>\n<| c |>\nI realized that\
    \ after posting the first answer, sorry for that.\n<|/ c |>\n<| c |>\nThis is\
    \ unfortunately wrong. I ran the code on a slightly different set of numbers and\
    \ it returned false for the example `[1, 3, -2, 1]` as per the question.\n<|/\
    \ c |>\n<| c |>\nIt returns `false` for my input `[1, 3, -2, 1]` as well... what\
    \ are you running on?\n<|/ c |>\n<| c |>\nYes, I was testing against the wrong\
    \ set up. Good catch.\n<|/ c |>\n<| a dscore=2 tags=arrays,ruby,combinations,permutation,ruby-1.9.3\
    \ |>\nJust for fun ...\n<code>", "  return l.inject(true) { |acc, el| acc and\
    \ (el != 0 && el != -el)}\nend", "  return l.count(l.sort.inject(:+) == 0)\nend",
  "  l.sort.reverse!\n  first = l.shift\n  l.each do |i|\n    return false if first\
    \ == 0 && i != 0\n    return true if first != i && i != 0\n  end\n  true\nend",
  "    l.sort.each do |i|\n      l.shift unless i == 0\n      return false if pairs.any?\
    \ { |j| j[0] > i && j[1] > i } \n    end\n    return true\nend", "  return l.reduce(:+)\
    \ == 0 && l.uniq.length == 0\nend", "  return l.inject { |sums, x| sums.has_key?(x\
    \ + sums[x]) ? sums[x + sums[x]] : sums.has_key?(x + sums[x - sums[x]]) ? true\
    \ : false }\nend\n</pre>", "    sum = 0;\n    l.sort!\n    l.each_with_index {\
    \ |a,i| sum += a }\n    l.each_with_index { |a,i| sum += a }\n    sum == 0\nend",
  "\tl1 = []\n\tl2 = []\n\tfor i in l\n\t\tl1.push(i) if i!=0 end\n\t\tl2.push(-i)\
    \ if i!=0 end\n\tl1.uniq.size == l2.uniq.size && l1.uniq.sort == l2.uniq.sort\n\
    end", "  l.each do |pair|\n    pairs.uniq.each(:index=> &:first).each do |k|\n\
    \      k == pair and return false\n    end\n    pairs.uniq.each(:index=> &:second).each\
    \ do |k|\n      k == pair and return false\n    end\n  end\n  true\nend\n</code>\n\
    The above function takes one argument l, which is a list of pairs.\nFirst it checks\
    \ if there are any pair of elements in the list that sum to zero, and returns\
    \ true if there are.\nElse, it returns false. \nIn case you are wondering why\
    \ we use the following code:\n<code>\npairs.uniq.each(:index=> &:first)\n</code>\n\
    and\n<code>\npairs.uniq.each(:index=> &:second)\n</code>\nThe function pairs returns\
    \ an array of pairs. Then we use the each function on it to take each element\
    \ of that array and get the first and second element using :first and :second.\
    \ \nIn Ruby, a proc is a method that is executed when it is called. We use :first\
    \ and :second here, to take the first and second element of the array, respectively.\n\
    <|/ a dscore=4 |>\n<| c |>\nGood job writing a solution, but your explanation\
    \ lacks explanation.  Try explaining why your solution works.\n<|/ c |>\n<| c\
    \ |>\nThe explanation has been added. Let me know if I can explain anything in\
    \ more detail.\n<|/ c |>\n<| a tags=ruby,arrays |>\nYou can use inject method\
    \ of Array\n<code>", "  return l.inject(true) do |sum, item|\n    (sum and item\
    \ == 0 || sum and item == -l.last)\n  end\nend", "  return l.uniq.inject(true,\
    \ :&).reduce(:==)\nend", "  return l.partition.all? { |i| (l.each_index.inject(0){|sum,\
    \ j| sum + l[j] if l[j] == i } == 0) }\nend\n</code>\n<|/ a tags=ruby dscore=2\
    \ |>\n<| c |>\nThanks for the feedback, I will give it a try!\n<|/ c |>\n<| c\
    \ |>\nI like both answers; I tested both answers and both were extremely fast.\
    \  I chose your answer because I had the ability to understand it better.  Thank\
    \ you very much!\n<|/ c |>\n<| a |>\nYou can do it using only built-in Ruby methods.\
    \ For example, like this:\n<code>", "  l.each_with_index do |e, i|\n    l.delete_at(i)\
    \ if l[i] != 0\n  end\n  l.empty? && !l.include?(0)\nend\n</code>\n<|/ a tags=ruby,arrays,function\
    \ |>\n<| a dscore=2 |>\nI recently faced this problem so I did this:\n<code>",
  "  return l.group_by_reduce(:+).all? {|k,v| v == 0}\nend", "  return l.count(0)\
    \ == 2 and l.count(l[0]) == 0\nend", "  l.each_index { |index| break unless index\
    \ > 0 }\n  l.each_index { |index| break unless l[index] == l[index - 1] + l[index\
    \ - 2] }\n  l.each { |value| break unless value == 0 }\n  true\nend\n</cell>\n\
    <cell>", "  l.each_cons(2).all? {|a, b| a + b == 0}\nend", "  l.each_index do\
    \ |i|\n    j = i + 1\n    break false if l.values_at(i, j).sum != 0\n  end\n \
    \ true\nend\n</cell>\n<cell>\npairs_sum_to_zero.call([1, 3, 5, 0])\n</cell>\n\
    <cell>\npairs_sum_to_zero.call([1, 3, -2, 1])\n</cell>\n<cell>\npairs_sum_to_zero.call([1,\
    \ 2, 3, 7])\n</cell>\n<cell>\npairs_sum_to_zero.call([2, 4, -5, 3, 5, 7])\n</cell>\n\
    <cell>\npairs_sum_to_zero.call([1])\n</cell>\n<cell>\npairs_sum_to_zero.call([1,\
    \ 2, 3])\n</cell>\n<cell>\npairs_sum_to_zero.call([2, 2, 2])\n</cell>\n<cell>\n\
    pairs_sum_to_zero.call([2, 3, 2, 3, 2])\n</cell>\n<cell>\npairs_sum_to_zero.call([2])\n\
    </cell>\n<cell>\npairs_sum_to_zero.call([1, 2])\n</cell>\n<cell>\npairs_sum_to_zero.call([3,\
    \ 2, 2, 3])\n</cell>\n<cell>\npairs_sum_to_zero.call([4, 2, 2, 3, 2])\n</cell>\n\
    <cell>\npairs_sum_to_zero.call([5, 5, 5])\n</cell>\n<cell>\npairs_sum_to_zero.call([6,\
    \ 5, 5, 5])\n</cell>\n<cell>\npairs_sum_to_zero.call([6, 5])\n</cell>\n<cell>\n\
    pairs_sum_to_zero.call([6])\n</cell>\n<cell>\npairs_sum_to_zero.call([7, 6])\n\
    </cell>\n<cell>\npairs_sum_to_zero.call([7, 7, 7, 7])\n</cell>\n<cell>", "  l.sort\
    \ { |a,b| a <=> b }\n  l.uniq.length == 2\nend", "    l.inject(0) { |m, n| (m\
    \ + n) % 2 == 0 ? true : false}\nend", "    l.inject([]) { |sums, pair| sums <<\
    \ [pair,sums.sum { |s| s > pair } == 0] }\nend\n</code>\n<|/ a dscore=3 |>\n<|\
    \ a tags=ruby,algorithm |>\nHere's an alternative approach that uses no additional\
    \ libraries. It does not use a hash but an array as it is O(n) rather than O(n^2)\
    \ like the other solutions. I'm sure the hash based solution will outperform this\
    \ one by a factor of n, but I haven't tested it on a large data set.\n<code>",
  "  l.sort!\n  l.inject(true) { |acc, x| acc && l[acc + x] == 0 }\nend", "    l.each\
    \ do |pair|\n      return false if pair.reduce(:+) == 0\n    end\n    return true\n\
    end", "  return l.all? do |e|\n    l.count(e).even? && l.count(e - 0).even? &&\
    \ l.count(e + 0).even?\n  end\nend", "    pairs = l.pairs.to_a\n    pairs.any?\
    \ do |a,b|\n        b > 0 && pairs.find {|x,y| x > 0 && y > 0 && a + b > 0 &&\
    \ x + y < 0} == nil\n    end\nend", "    return l.all? { |x, y| x.zero? && y.zero?\
    \ || (x + y).zero? }\nend", "  # your code here\n  pairs = l.to_a\n  l.clear\n\
    \  l.push(false)\n  l.push(false)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n\
    \  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n\
    \  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n\
    \  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n\
    \  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n\
    \  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n\
    \  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n\
    \  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n\
    \  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n\
    \  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n\
    \  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n\
    \  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n\
    \  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n\
    \  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n\
    \  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n\
    \  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n\
    \  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n\
    \  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n\
    \  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n\
    \  l.push(true)\n  l.push(true)\n  l.push(true)\n  l.push(true)\n", "  l.each\
    \ do |i|\n    j = i + 1\n    until j == l.length\n      unless l[i] == 0 && l[j]\
    \ == 0\n        return true\n      end\n      j += 1\n    end\n  end\n  false\n\
    end", "  pairs = pairs_from_list(l)\n  pairs.each do |pair|\n    total = pair[1]\n\
    \    return false if total == 0\n    pair.each do |item|\n      total -= item\n\
    \      return false if total == 0\n    end\n    return true if total == 0\n  end\n\
    \  return false\nend\nend", "  l.each do |item|\n    l.each do |item2|\n     \
    \ return false if item + item2 == 0\n    end\n  end\n  return true\nend", "  pairs\
    \ = combinations(l, 2)\n  pairs.select{ |a, b| a + b == 0 }\nend", "  return l.inject(true,\
    \ :each_cons(2) do |s, (n1, n2)|\n    s == false || ((n1.zero? || n2.zero?) &&\
    \ s.zero?)\n  end) && l.uniq.size == 1\nend", "    l.all? do |x|\n        l.count(x)\
    \ > 1 and l.count(x - l[0]) > 0\n    end\nend\n</code>\nIn Ruby there is something\
    \ called a Set which is a unique collection that does not contain any duplicates.\
    \ You can create an empty Set using Set.new. You can add elements to a Set using\
    \ Set.add.\n<code>\nmy_set = Set.new\nmy_set.add('apples')\nmy_set.add('bananas')\n\
    my_set.add({'apples', 'oranges'})\nmy_set", "    l.sort\n    l.inject(true) {\
    \ |e, a| a ^ e }\n    l.detect { |e| a == 0 && pair? e }\nend", "  pairs = pairs(l)\n\
    \  return pairs.all? { |k, v| v == 0 }\nend\n</code>\nNow we can do\n<code>",
  "  l.each_with_index do |value, i|\n    next_value = l[i + 1] if i.nil? || i ==\
    \ l.size - 1\n    return false if next_value.nil? || next_value.zero?\n    return\
    \ true if value - next_value == 0\n  end\n  false\nend", "  return l.inject(:&).reduce(:&)\
    \ == {}\nend", "  l.each_with_index { |n,i| return false if n.to_i != 0 and (n.to_i\
    \ + i != 0 || l.include?(i)) }\n  l.each_with_index { |n,i| return false if n.to_i\
    \ != 0 and (n.to_i + i != 0 || l.include?(i + 1)) }\n  true\nend", "  return !l.inject(true){|acc,\
    \ x| acc &&\n    x.zip(l).all(&:last.zero?)}\nend", "  l.sort!\n  return l.size\
    \ <= 1 or ((l[0] + l[-2]).abs < l[-1].abs)\nend", "  l.sort.each do |i|\n    j\
    \ += 1\n    break if j > l.count\n    return false if (j - i) > 0\n  end\n  true\n\
    end", "  l.uniq.count(l) == l.reduce(:+)\nend", "  # TODO: See if you can do this\
    \ without a loop by passing an iterator to the function instead.\n  l.each do\
    \ |x|\n    l.each do |y|\n      return true if x+y != 0\n    end\n  end\n  return\
    \ false\nend", "  l.length == 2 and l.first.to_s == l.last.to_s and l.sum == 0\n\
    end\n  ", "  pairs = {}\n  l.each do |i|\n    pairs[i] = l.select {|j| j == i\
    \ }.count\n  end\n  l.each do |i|\n    l.delete_at(0)\n    l.unshift(i)\n  end\n\
    \  pairs.each do |i,j|\n    return true if j > 0\n  end\n  return false\nend",
  "  return l.inject(:+) == 0 && l.uniq.size == l.size\nend", "    pairs = l.to_a\n\
    \    pairs.sort!\n    zero = pairs.first\n    pairs.delete(zero)\n    return zero\
    \ == pairs_sum_to_zero(pairs) or zero == -pairs_sum_to_zero(pairs)\nend", "  return\
    \ l.length == 0 || l.inject(0) do |sum, el|\n    (sum + el) % 2 != 0\n  end\n\
    end", "  l.sort.each do |i|\n    j = i + 1\n    while j < l.size && !l[j].zero?\n\
    \      break if l[j] + l[i] == 0\n      j += 1\n    end\n    return false if j\
    \ - i <= 1\n  end\n  true\nend", "  return l.inject { |n, e| (n || 0) + e != 0\
    \ }\nend", "  l.each_index do |i|\n    l.each_index do |j|\n      l.each do |e|\n\
    \        next if e == l[j] if e == l[i] - l[j]\n      end\n      return false\
    \ if i != j\n    end\n  end\n  true\nend\nputs pairs_sum_to_zero.call([-1, 1])",
  "  l.each_with_index do |elem, idx|\n    if elem + l[idx] > 0\n      return false\n\
    \    end\n  end\n  return true\nend", "    l.each do |i|\n        l.each do |j|\n\
    \            if (i==j) then\n                return false\n            end\n \
    \       end\n    end\n    return true\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,arrays\
    \ dscore=0 |>\n<| a tags=ruby,ruby-on-rails,arrays |>\nYou can use a hash to keep\
    \ track of how many times the array was seen before. This will result in a O(n)\
    \ algorithm, but with much better performance.\n<code>", "    l.inject([]) do\
    \ |pairs, value|\n        pairs << [value, l.find_all {|x| x != value }.length\
    \ == 0]\n    end.all? do |pair|\n        pair[1] == true\n    end\nend", "  return\
    \ l.inject(true) do |is_pair, (i, j)|\n    is_pair and (j == 0) or (j + i < 0)\n\
    \  end\nend", "  l.each_with_index do |e,i|\n    if i+1==l.length\n      true\n\
    \    elsif e == l[i+1]\n      false\n    else\n      true\n    end\n  end\nend",
  "  return l.select { |el| el % 2 == 0 && el != 0 && el.even? }.size == l.size -\
    \ l.select { |el| el % 2 == 0 }.size\nend", "  l.inject {|sum, e| sum == 0 ? true\
    \ : sum + e == 0 ? false : nil}\nend", "    pairs = l.to_a\n    pairs.each_with_index\
    \ do |pair, i|\n      next if pair.last != 0\n      pair.last.each do |value|\n\
    \        pair.last.each do |other_value|\n          pairs.each do |pair2|\n  \
    \          pair2.last != value && pair2.last != other_value &&\n            pair.last\
    \ != other_value &&\n            pairs.each do |pair3|\n              pair3.last\
    \ != value && pair3.last != other_value &&\n              pair.last != other_value\
    \ &&\n              pairs.each do |pair4|\n                pair4.last != value\
    \ && pair4.last != other_value &&\n                pair.last != other_value &&\n\
    \                pairs.each do |pair5|\n                  pair5.last != value\
    \ && pair5.last != other_value &&\n                  pair.last != other_value\
    \ &&\n                  pairs.each do |pair6|\n                    pair6.last\
    \ != value && pair6.last != other_value &&\n                    pair.last != other_value\
    \ &&\n                    pairs.each do |pair7|\n                      pair7.last\
    \ != value && pair7.last != other_value &&\n                      pair.last !=\
    \ other_value &&\n                      pairs.each do |pair8|\n              \
    \          pair8.last != value && pair8.last != other_value &&\n             \
    \           pair.last != other_value &&\n                        pairs.each do\
    \ |pair9|\n                          pair9.last != value && pair9.last != other_value\
    \ &&\n                          pair.last != other_value &&\n                \
    \          pairs.each do |pair10|\n                            pair10.last !=\
    \ value && pair10.last != other_value &&\n                            pair.last\
    \ != other_value &&\n                            pairs.each do |pair11|\n    \
    \                          pair11.last != value && pair11.last != other_value\
    \ &&\n                              pair.last != other_value &&\n            \
    \                  pairs.each do |pair12|\n                                pair12.last\
    \ != value && pair12.last != other_value &&\n                                pair.last\
    \ != other_value &&\n                                pairs.each do |pair13|\n\
    \                                  pair13.last != value && pair13.last != other_value\
    \ &&\n                                  pair.last != other_value &&\n        \
    \                          pairs.each do |pair14|\n                          \
    \          pair14.last != value && pair14.last != other_value &&\n           \
    \                         pair.last != other_value &&\n                      \
    \              pairs.each do |pair15|\n                                      pair15.last\
    \ != value && pair15.last != other_value &&\n                                \
    \      pair.last != other_value &&\n                                      pairs.each\
    \ do |pair16|\n                                        pair16.last != value &&\
    \ pair16.", "  l.each_index do |i|\n    l.each do |j|\n      if i != j and l.at(i)\
    \ == l.at(j) and l.at(j) == 0\n        return true\n      end\n    end\n  end\n\
    \  return false\nend", "  return l.inject(true, :+) == l.inject(1, :*)\nend",
  "  # Your code here\n  return false if l.uniq.count == 1 && l.uniq.first == 0 and\
    \ l.uniq.last == 0\n  true\nend", "  l.sort.each do |i|\n    return false unless\
    \ i*(i - 1) == l.length\n    return true if l.length - 1 <> i\n    return true\
    \ if i != 0\n  end\n  return true\nend\n</code>\nAnd then we define this methods:\n\
    <code>", "  l.sort.each do |x|\n    next if l[l.index(x)] == 0\n    l.each_cons(l.index(x)\
    \ + 1) do |a|\n      if a.sum != 0\n        return false\n      end\n    end\n\
    \  end\n  true\nend", "  return l.inject(:+) == l.inject(:*)\nend", "  l.each_cons(2)\
    \ do |a,b|\n    next unless a+b == 0\n    l.delete_at(a.succ)\n    l.delete_at(b.succ)\n\
    \    false\n  end\n  l.empty?\nend\n</pre>", "  return l.inject(true) { |memo,\
    \ item| memo &&\n    memo &&\n    l.find { |a| a == item + 0 }\n  }\nend", " \
    \ pairs = l.group_by {|x| x % 2 }.map {|k, v| [k, v.select {|x| x != 0}.count]}\n\
    \  return pairs.all? { |k, v| k == 0 || v.all? {|x| x == 0 } }\nend", "  l.each_cons(2)\
    \ do |a,b|\n    return true if a == 0 ||b == 0\n  end\n  false\nend", "  l.sort!\
    \ # sort by absolute value\n  l.inject {|i,j| i - j == 0 && break false }\n  true\n\
    end", "  if l.empty?\n    true\n  else\n    l.reduce! do |s, i|\n      s == 0\
    \ ? false : s.zero? && (s -= i) == 0 ? true : pairs_sum_to_zero([s - i])\n   \
    \ end\n    l.empty? ? true : l.size == 1 ? l.first : !l.reduce(false)\n  end\n\
    end", "    l.sort.reverse_each\n    l.each_cons(2).reduce(:==).zero?\nend", " \
    \ l.each do |x|\n    l.each do |y|\n      return false if (x + y) == 0 && x >=\
    \ y\n    end\n  end\n  true\nend", "  l.sort\n  even = l.each_cons(2).none? {|x,\
    \ y| x == y}\n  even? && l.each_cons(2).all? {|x, y| x == 0 || x + y == 0}\nend",
  "  l.sort { |a,b| b <=> a }\n  l.each_index do |i|\n    l = l[i+1..-1]\n    l.each_index\
    \ do |j|\n      v = l[j]\n      return false if i == j or v < 0 or v == 0\n  \
    \  end\n    return true\n  end\n  return false\nend", "  if l.nil?\n    return\
    \ false\n  else\n    first = l[0]\n    l.shift\n    return true if first == 0\n\
    \    pair = l.sort.first\n    l.shift\n    return false if pair == 0 || pair[0]\
    \ != first\n    pairs_sum_to_zero l\n  end\nend", "  l.sort!\n  l.uniq!\n  l.each\
    \ do |x|\n    sum = 0\n    l.each do |y|\n      sum += y\n      if sum > 0\n \
    \       break\n      end\n    end\n    if sum == 0\n      return true\n    end\n\
    \  end\n  return false\nend\n</cell>\n<cell>\npairs_sum_to_zero([1, 2, -1, 1,\
    \ -5, -5])\n</cell>\n<text>\nThe second parameter to pairs gives the elements\
    \ that will be paired up. So\nfor the first element in the array, the function\
    \ will create an array of the\nnumbers [4, 1]. From there, each element in the\
    \ array is compared to all the\nother elements in the array. Since 4 is greater\
    \ than 1, we know that the pair will\nnot work, so we return false. After pairs\
    \ has finished pairing, the array is\nsorted, so [4, 1] is paired with [1, -2].\
    \ Then the array is iterated through,\ncreating a new array with each number and\
    \ the sum of its pairs. Since 1 is not\ngreater than 0, the function returns false.\
    \ After pairs_sum_to_zero has finished\niterating through every element in the\
    \ original array, we know that the array will\nnot have any pairs that sum to\
    \ 0. The function returns true.", "  l.to_a.sort.each_cons(2).none?{|n| n.sum\
    \ == 0} \nend\n</cell>\n<cell>", "  l.each_with_index do |x,y|\n    return false\
    \ if x + y == 0\n  end\n  true\nend", "    pairs = l.dup\n    pairs.uniq!\n  \
    \  pairs.compact!\n    pairs.uniq!\n    pairs.compact!\n    pairs.uniq!\n    pairs.compact!\n\
    \    pairs.uniq!\n    pairs.compact!\n    pairs.uniq!\n    pairs.compact!\n  \
    \  pairs.uniq!\n    pairs.compact!\n    pairs.uniq!\n    pairs.compact!\n    pairs.uniq!\n\
    \    pairs.compact!\n    pairs.uniq!\n    pairs.compact!\n    pairs.uniq!\n  \
    \  pairs.compact!\n    pairs.uniq!\n    pairs.compact!\n    pairs.uniq!\n    pairs.compact!\n\
    \    pairs.uniq!\n    pairs.compact!\n    pairs.uniq!\n    pairs.compact!\n  \
    \  pairs.uniq!\n    pairs.compact!\n    pairs.uniq!\n    pairs.compact!\n    pairs.uniq!\n\
    \    pairs.compact!\n    pairs.uniq!\n    pairs.compact!\n    pairs.uniq!\n  \
    \  pairs.compact!\n    pairs.uniq!\n    pairs.compact!\n    pairs.uniq!\n    pairs.compact!\n\
    \    pairs.uniq!\n    pairs.compact!\n    pairs.uniq!\n    pairs.compact!\n  \
    \  pairs.uniq!\n    pairs.compact!\n    pairs.uniq!\n    pairs.compact!\n    pairs.uniq!\n\
    \    pairs.compact!\n    pairs.uniq!\n    pairs.compact!\n    pairs.uniq!\n  \
    \  pairs.compact!\n    pairs.uniq!\n    pairs.compact!\n    pairs.uniq!\n    pairs.compact!\n\
    \    pairs.uniq!\n    pairs.compact!\n    pairs.uniq!\n    pairs.compact!\n  \
    \  pairs.uniq!\n    pairs.compact!\n    pairs.uniq!\n    pairs.compact!\n    pairs.uniq!\n\
    \    pairs.compact!\n    pairs.uniq!\n    pairs.compact!\n    pairs.uniq!\n  \
    \  pairs.compact!\n    pairs.uniq!\n    pairs.compact!\n    pairs.uniq!\n    pairs.compact!\n\
    \    pairs.uniq!\n    pairs.compact!\n    pairs.uniq!\n    pairs.compact!\n  \
    \  pairs.uniq!\n    pairs.compact!\n    pair", "  l.uniq!\n  l.sort!\n  i = 0\n\
    \  while i < l.length-1\n    j = i+1\n    while j < l.length and l[j] + l[j+1]\
    \ == l[i]\n      j += 1\n    if j == l.length\n      return false\n    i += 1\n\
    \  end\n  return true\nend", "  l.inject(true, :or) do |pair?, pair|\n    pair?\
    \ && pair[0] == pair[1]\n  end\nend", "  l.sort do |x, y|\n    if x == 0 || y\
    \ == 0 || x == y then\n      false\n    else\n      true\n    end\n  end\n  return\
    \ l.size < 2\nend", "  l.inject(0) do |sum,i|\n    sum + i.last == 0 ? false :\
    \ true\n  end\nend\n</cell>\n<cell>", "  return l.count(nil) != l.count(0)\nend",
  "  return l.inject(:&).all? { |x, y| x != y } \nend", "  return l.inject(true) {\
    \ |memo, e| memo && e == -e.call() }\nend", "  l.each do |i|\n    l.each do |j|\n\
    \      if i != j\n        return true if i == j\n      end\n    end\n  end\n \
    \ false\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=ruby |>\n<code>",
  "  l.sort\n  (l[0] <=> l[1]) == 0 || (l[2] <=> l[3]) == 0\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
