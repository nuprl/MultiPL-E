name: HumanEval_86_anti_shuffle
language: rb
prompt: "# Write a function that takes a string and returns an ordered version of\
  \ it.\n# Ordered version of string, is a string where all words (separated by space)\n\
  # are replaced by a new word where all the characters arranged in\n# ascending order\
  \ based on ascii value.\n# Note: You should keep the order of words and blank spaces\
  \ in the sentence.\n# For example:\n# >>> anti_shuffle.call(\"Hi\")\n# \"Hi\"\n\
  # >>> anti_shuffle.call(\"hello\")\n# \"ehllo\"\n# >>> anti_shuffle.call(\"Hello\
  \ World!!!\")\n# \"Hello !!!Wdlor\"\ndef anti_shuffle(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_anti_shuffle\n\
  \    candidate = method(:anti_shuffle)\n    assert_equal(\"Hi\", candidate.call(\"\
  Hi\"))\n    assert_equal(\"ehllo\", candidate.call(\"hello\"))\n    assert_equal(\"\
  bemnru\", candidate.call(\"number\"))\n    assert_equal(\"abcd\", candidate.call(\"\
  abcd\"))\n    assert_equal(\"Hello !!!Wdlor\", candidate.call(\"Hello World!!!\"\
  ))\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\".Hi My aemn\
  \ is Meirst .Rboot How aer ?ouy\", candidate.call(\"Hi. My name is Mister Robot.\
  \ How are you?\"))\n  end\nend\n"
completions: ["  s.split(\" \").sort.join\nend", " \n    s.chars.each_with_index do\
    \ |ch, i|\n        if i > 0 and s[i] <= s[i-1]\n            s[i-1], s[i] = s[i],\
    \ s[i-1]\n        end\n    end\n \n    return s.reverse\nend\n \n ", "    return\
    \ s.tr(\"a-z A-Z 0-9 !\".to_i, '!'.to_i).downcase\nend", "  s = s.gsub(/\\s+/,\
    \ ' ')\n  s = s.gsub(/[\\.!?]([a-z])/, '\\1\\1')\n  s = s.gsub(/([a-z])([\\.!?])/,\
    \ '\\1\\2')\n  s = s.gsub(/([a-z])([\\.!?])/, '\\1\\2')\n  s = s.gsub(/([a-z])([\\\
    .!?])/, '\\1\\2')\n  s = s.gsub(/([a-z])([\\.!?])/, '\\1\\2')\n  s = s.gsub(/([a-z])([\\\
    .!?])/, '\\1\\2')\n  s = s.gsub(/([a-z])([\\.!?])/, '\\1\\2')\n  s = s.gsub(/([a-z])([\\\
    .!?])/, '\\1\\2')\n  s = s.gsub(/([a-z])([\\.!?])/, '\\1\\2')\n  s = s.gsub(/([a-z])([\\\
    .!?])/, '\\1\\2')\n  s = s.gsub(/([a-z])([\\.!?])/, '\\1\\2')\n  s = s.gsub(/([a-z])([\\\
    .!?])/, '\\1\\2')\n  s = s.gsub(/([a-z])([\\.!?])/, '\\1\\2')\n  s = s.gsub(/([a-z])([\\\
    .!?])/, '\\1\\2')\n  s = s.gsub(/([a-z])([\\.!?])/, '\\1\\2')\n  s = s.gsub(/([a-z])([\\\
    .!?])/, '\\1\\2')\n  s = s.gsub(/([a-z])([\\.!?])/, '\\1\\2')\n  s = s.gsub(/([a-z])([\\\
    .!?])/, '\\1\\2')\n  s = s.gsub(/([a-z])([\\.!?])/, '\\1\\2')\n  s = s.gsub(/([a-z])([\\\
    .!?])/, '\\1\\2')\n  s = s.gsub(/([a-z])([\\.!?])/, '\\1\\2')\n  s = s.gsub(/([a-z])([\\\
    .!?])/, '\\1\\2')\n  s = s.gsub(/([a-z])([\\.!?])/, '\\1\\2')\n  s = s.gsub(/([a-z])([\\\
    .!?])/, '\\1\\2')\n  s = s.gsub(/([a-z])([\\.!?])/, '\\1\\2')\n  s = s.", "  result\
    \ = \"\"\n  word = s.split(\" \")\n  word = word.sort\n  word.each do |letter|\n\
    \    result << \"#{letter}\"\n  end\n  result\nend", "    s.downcase!\n    words\
    \ = s.split\n    words.sort!\n    words.join\nend", "  new_word = \"\"\n  letters\
    \ = \"\"\n  for i in range(0,s.length,2)\n    letters << s[i+1]\n  end\n  s.scan(/\\\
    w/){|w| new_word << w.swapcase}\n  new_word << letters.downcase\n  return new_word.join(\"\
    \ \")\nend", "    s = s.downcase\n    s = s.gsub(/[\\W]+/, \" \")\n    s = s.gsub(/([a-z])/,\
    \ '\\1 ')\n    s = s.gsub(/(\\s)/, ' ')\n    s = s.strip\n    return s\nend",
  "  new_str = \"\"\n  words_list = s.split(\" \") \n  words_list.each do |word|\n\
    \    char_list = word.chars.to_a\n    char_list.sort_by{|x| x.ord}\n    new_str\
    \ << char_list.join \" \"\n  end\n  new_str\nend", "  s.split.each do |word|\n\
    \    word.split.sort.each do |char|\n      s[char.chr] = word[char.chr]\n    end\n\
    \  end\n  s\nend", "    s = s.split(\" \").map{|w| w.tr(\"a-zA-Z0-9 \", \"\")}\n\
    \    s = s.flatten\n    s.sort.map{|w| w.tr(\" \", \"_\")}.join(\" \")\nend",
  "    return s.gsub(/(.)\\s(?=\\S)|(\\s)(?=\\S)|(\\s)(?=\\W)/, \"\\1\\3\\4\")\nend\n\
    </code>\nThe solution below uses recursion and an explicit stack data structure\
    \ (as opposed to using .split method on the string). Both solutions take the same\
    \ amount of time to execute.\n<code>", "  s.gsub!(/\\w+/) { $0.split('').sort.join.to_s\
    \ }\n  s\nend", "  words = s.split(\" \")\n  words.sort_by!{|w| w.each_char.sort_by!{|c|\
    \ c.ord - 'a'.ord}}\n  words.join(\" \")\nend", "  s.gsub!(/\\s+/, \" \")\n  s.gsub(/(.+)/){|x|\
    \ x.gsub(/\\s+/, \" \")}\n  s.gsub(/(\\w)(\\w)(\\w)\\2\\1\\3/){|x| x.gsub(/\\\
    s+/, \" \")}\n  s.gsub(/(\\w)(\\w)\\2\\1\\3/){|x| x.gsub(/\\s+/, \" \")}\n  s.gsub(/(\\\
    w)(\\w)(\\w)\\2\\1\\3/){|x| x.gsub(/\\s+/, \" \")}\n  s.gsub(/(\\w)(\\w)\\2\\\
    1\\3/){|x| x.gsub(/\\s+/, \" \")}\n  s.gsub(/(\\w)(\\w)\\2\\1\\3/){|x| x.gsub(/\\\
    s+/, \" \")}\n  s.gsub(/(\\w)(\\w)\\2\\1\\3/){|x| x.gsub(/\\s+/, \" \")}\n  s.gsub(/(\\\
    w)(\\w)\\2\\1\\3/){|x| x.gsub(/\\s+/, \" \")}\n  s.gsub(/(\\w)(\\w)\\2\\1\\3/){|x|\
    \ x.gsub(/\\s+/, \" \")}\n  s.gsub(/(\\w)(\\w)\\2\\1\\3/){|x| x.gsub(/\\s+/, \"\
    \ \")}\n  s.gsub(/(\\w)(\\w)\\2\\1\\3/){|x| x.gsub(/\\s+/, \" \")}\n  s.gsub(/(\\\
    w)(\\w)\\2\\1\\3/){|x| x.gsub(/\\s+/, \" \")}\n  s.gsub(/(\\w)(\\w)\\2\\1\\3/){|x|\
    \ x.gsub(/\\s+/, \" \")}\n  s.gsub(/(\\w)(\\w)\\2\\1\\3/){|x| x.gsub(/\\s+/, \"\
    \ \")}\n  s.gsub(/(\\w)(\\w)\\2\\1\\3/){|x| x.gsub(/\\s+/, \" \")}\n  s.gsub(/(\\\
    w)(\\w)\\2\\1\\3/){|x| x.gsub(/\\s+/, \" \")}\n  s.gsub(/(\\w)(\\w)\\2\\1\\3/){|x|\
    \ x.gsub(/\\s+/, \" \")}\n  s.gsub(/(\\w)(\\w)\\2\\1\\3/){|x| x.gsub(/\\s+/, \"\
    \ \")}\n", "  # TODO: Write your solution\n  return s\n</cell>\n<cell>", "  return\
    \ s.gsub(/(\\w+\\s+)+\\w+/) { |m| m.split(' ').sort_by(&:ord).join }\nend\n</code>\n\
    <|/ a |>\n<| a |>\nI thought about using sort with a lambda, but I noticed a drawback\
    \ in my case that lambda is called multiple times.\nThis problem was solved using\
    \ inject instead:\n<code>", "  word = s.split(\" \").sort\n  result = \"\"\n \
    \ for x in word\n    result = result + x.to_s\n  result\nend", "  s = s.split\n\
    \  s.sort do |x,y|\n    p x = x.ord and y = y.ord\n    if x > y\n      1\n   \
    \ elsif x< y\n      -1\n    elsif x == y\n      0\n    else\n      -1\n    end\n\
    \  end\n  s.join(\" \")\nend", "  s.split.sort!.join \" \"\nend\n</cell>\n<cell>",
  "  s = s.split\n  s.sort.reverse!\n  s.join\n  s.join!\nend\n</cell>\n<cell>", " \
    \ letters = s.split(' ').map{|l| l.downcase}\n  letters.sort!\n  letters.join\n\
    end", " str.split(\" \").map{ |x| x.chars.sort.join }.join\nend", "  s.split(\"\
    \ \").sort.join(\" \")\nend", "  return s.split(\" \").sort_by {|w| w.gsub(/[a-z]/i)\
    \ { |m| m.ord } }.join(\" \")\nend", "  shuffled_sentence = []\n  s.gsub!(\" \"\
    ,\"\")\n  s.split(\"  \").each do |word|\n    word = word.downcase\n    word.gsub!(\"\
    a\",\"e\")\n    word.gsub!(\"b\",\"c\")\n    word.gsub!(\"c\",\"b\")\n    word.gsub!(\"\
    d\",\"f\")\n    word.gsub!(\"e\",\"a\")\n    word.gsub!(\"f\",\"d\")\n    word.gsub!(\"\
    g\",\"h\")\n    word.gsub!(\"h\",\"g\")\n    word.gsub!(\"i\",\"j\")\n    word.gsub!(\"\
    j\",\"i\")\n    word.gsub!(\"k\",\"l\")\n    word.gsub!(\"l\",\"k\")\n    word.gsub!(\"\
    m\",\"n\")\n    word.gsub!(\"n\",\"m\")\n    word.gsub!(\"o\",\"p\")\n    word.gsub!(\"\
    p\",\"o\")\n    word.gsub!(\"q\",\"r\")\n    word.gsub!(\"r\",\"q\")\n    word.gsub!(\"\
    s\",\"t\")\n    word.gsub!(\"t\",\"s\")\n    word.gsub!(\"u\",\"v\")\n    word.gsub!(\"\
    v\",\"u\")\n    word.gsub!(\"w\",\"x\")\n    word.gsub!(\"x\",\"w\")\n    word.gsub!(\"\
    y\",\"z\")\n    word.gsub!(\"z\",\"y\")\n    word.gsub!(\"A\",\"E\")\n    word.gsub!(\"\
    B\",\"C\")\n    word.gsub!(\"C\",\"B\")\n    word.gsub!(\"D\",\"F\")\n    word.gsub!(\"\
    E\",\"A\")\n    word.gsub!(\"F\",\"D\")\n    word.gsub!(\"G\",\"H\")\n    word.gsub!(\"\
    H\",\"G\")\n    word.gsub!(\"I\",\"J\")\n    word.gsub!(\"J\",\"I\")\n    word.gsub!(\"\
    K\",\"L\")\n    word.gsub!(\"L\",\"K\")\n    word.gsub!(\"M\",\"N\")\n    word.gsub!(\"\
    N\",\"M\")\n    word.gsub!(\"O\",\"P\")\n    word.gsub!(\"P\",\"O\")\n    word.gsub!(\"\
    Q\",\"R\")\n    word.gsub!(\"R\",\"Q\")\n    word.g", "  s = \"\"\n  s = s.split(\"\
    \ \").sort\n  s.each {|x| s = x + \" \" + s}\n  s\nend", "  s.split(' ').sort.join('\
    \ ')\nend\n</cell>\n<cell>", "  words = s.split\n  new_words = []\n  words.each\
    \ do |w|\n    new_w =\"\"\n    w.chars.each do |c|\n      if c.upcase > c\n  \
    \      new_w << c\n      else\n        new_w << c.upcase\n      end\n    end\n\
    \    new_words << new_w\n  end\n  new_words.join\nend\n</code>\n<|/ a |>\n<| c\
    \ |>\nThis does not satisfy the requirements for \"a function\".  \"Function\"\
    \ implies a functional approach to solving the problem, not a procedural approach.\n\
    <|/ c |>\n<| c |>\nYou might want to mention that the solution by is more idiomatic\
    \ Ruby.\n<|/ c |>\n<| c |>\nYes, I did. It was a fun exercise!\n<|/ c |>\n<| c\
    \ |>\nWhat is the purpose of the line `new_words.map { |s| s.map { |c| c.upcase\
    \ } }` ?\n<|/ c |>\n<| c |>\nYou might want to try your solution on this string:\
    \ `'Hello     World!'`\n<|/ c |>\n<| a tags=ruby,string dscore=2 |>\n<code>",
  "  result = \"\"\n  words = s.split\n  word_index = 0\n  word_list = []\n  while\
    \ word_index < words.length\n    word = words[word_index]\n    word_list << word\n\
    \    word_index += 1\n  end", "  s = s.split(\" \").sort.join(\" \")\n  s = s.replace(\"\
    \ \", \"\")\n  return s\nend", "  return s.split(\" \").map {|word| word.chars.sort_by\
    \ {|c| c.ascii}.join}.join\nend\n</cell>\n<text>\nThe anti_shuffle method takes\
    \ in a string and returns a new string where all the characters are arranged in\
    \ ascending order based on ascii value.", "  words = s.split(\" \").sort\n  words\
    \ = words.map {|w| w.gsub(/[a-z]/, '\\201')}.join(\" \")\n  words.downcase\nend",
  "  s.split(' ').sort!\n  s.gsub!(/[!-~]+/, ' ')\n  s.gsub!('  ', ' ').gsub!(' ',\
    \ ' ').downcase\n  s\nend\n    ", "  s.gsub!(\" \", \"\") # remove all spaces\
    \ from the string\n  s = s.split(\" \") # separate words from the blank space\n\
    \  s.sort! # sort the words in ascending order\n  return s.join(\" \")\nend",
  "  s.split(\" \").sort.join(\" \")\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI\
    \ ran your code. It gives the following error:  `RuntimeError: wrong number of\
    \ arguments (given 0, expected 1)`\n<|/ c |>\n<| c |>\nThe code given is written\
    \ in Ruby, hence the syntax differences. Try running the code given.\n<|/ c |>\n\
    <| c |>\nI ran your code and it gives this error: `RuntimeError: wrong number\
    \ of arguments (given 0, expected 1)`\n<|/ c |>\n<| c |>\n: Which version of Ruby\
    \ are you using?\n<|/ c |>\n<| c |>\n, I'm using ruby 2.0. But I'm on a mac.\n\
    <|/ c |>\n<| a |>\nIf you don't need to worry about case then this would work:\n\
    <code>", "  s.downcase!\n  s.gsub!(/\\s+/, \" \")\n  letters = Array.new\n  s.split.each\
    \ do |word|\n    letters << word[0]\n  end\n  letters.sort.each do |letter|\n\
    \    s.gsub!(letter, letter.ord.to_s)\n  end\n  s.downcase!\nend", "  s.downcase!\n\
    \  s.gsub!(/[^A-Za-z0-9 ]+/, \" \")\n  s.gsub!(/ /, \"!\")\n  s.gsub!(/!\\Z/,\
    \ \"\")\n  s.downcase!\n  s.gsub!(/[^A-Za-z0-9 ]+/, \" \")\n  s.gsub!(/ /, \"\
    !\")\n  s.gsub!(/!\\Z/, \"\")\n  s.downcase!\n  s.gsub!(/[^A-Za-z0-9 ]+/, \" \"\
    )\n  s.gsub!(/ /, \"!\")\n  s.gsub!(/!\\Z/, \"\")\n  s.downcase!\n  s.gsub!(/[^A-Za-z0-9\
    \ ]+/, \" \")\n  s.gsub!(/ /, \"!\")\n  s.gsub!(/!\\Z/, \"\")\n  s.downcase!\n\
    \  s.gsub!(/[^A-Za-z0-9 ]+/, \" \")\n  s.gsub!(/ /, \"!\")\n  s.gsub!(/!\\Z/,\
    \ \"\")\n  s.downcase!\n  s.gsub!(/[^A-Za-z0-9 ]+/, \" \")\n  s.gsub!(/ /, \"\
    !\")\n  s.gsub!(/!\\Z/, \"\")\n  s.downcase!\n  s.gsub!(/[^A-Za-z0-9 ]+/, \" \"\
    )\n  s.gsub!(/ /, \"!\")\n  s.gsub!(/!\\Z/, \"\")\n  s.downcase!\n  s.gsub!(/[^A-Za-z0-9\
    \ ]+/, \" \")\n  s.gsub!(/ /, \"!\")\n  s.gsub!(/!\\Z/, \"\")\n  s.downcase!\n\
    \  s.gsub!(/[^A-Za-z0-9 ]+/, \" \")\n  s.gsub!(/ /, \"!\")\n  s.gsub!(/!\\Z/,\
    \ \"\")\n  s.downcase!\n  s.gsub!(/[^A-Za-z0-9 ]+/, \" \")\n  s.gsub!(/ /, \"\
    !\")\n  s.gsub!(/!\\Z/, \"\")\n  s.downcase!\n  s.gsub!(/[^A-Za-z0-9 ]+/, \" \"\
    )\n  s.gsub!(/ /, \"!\")\n  s.gsub!(/!\\Z/, \"\")\n  s.downcase!\n  s.gsub!(/[^A-Za-z0-9\
    \ ]+/, \" \")\n  s.gsub!(/ /", "  s.tr!('abcdefghijklmnopqrstuvwxyz', ' zyxwvutsrqponmlkjihgfedcba')\n\
    end\n</pre>", "  s = s.split(\". \")\n  words = s.reverse.split(\", \").reverse\n\
    \  return words.join \" \"\nend", "    words = s.split(' ')\n    words.sort_by\
    \ {|w| w.ord }\n    words.join(' ')\nend\n</cell>\n<text>\n5.3 Reverse a String",
  "    split_s = s.split\n    new_s=\"\"\n    word_list = split_s(\" \")\n    word_list.each{|w|\n\
    \        new_s+=(w.gsub(/./){|c| c.upcase }.downcase)\n    }\n    new_s\nend",
  "  new_s = \"\"\n  s.split(\" \").each do |word|\n    word = word.chars.sort_by\
    \ { |c| c.ord }.join\n    new_s << word << \" \"\n  end\n  new_s[0...-1]\nend\n\
    print anti_shuffle(\"Hi\")", "  l = s.split(' ')\n  s.gsub!(/\\s+/, '').gsub(/\\\
    w+/) do |w|\n    j = l.index{|w| w.downcase > w.downcase}.first\n    i = j + 1\
    \ if j && j < l.length\n    j = 0 if i && j < l.length\n    j = l.length unless\
    \ j\n    i || l.insert(j, w)\n  end\n  s\nend", "    words = s.split(\" \") #\
    \ Split string by space\n    new_words = [] # Create new empty list\n    word\
    \ = \"\" # Create empty string\n    for w in words # Loop through each word in\
    \ words\n        if w.length > 0 # If word is not blank\n            char = w[0]\
    \  # Pick first character in the word\n            word += char  # Append to string\n\
    \            for c in w[1:] # Loop through each character in the word\n      \
    \          if ord(c) < ord(char) + 65 # If ascii value of the char is less than\
    \ ascii value of the first char\n                    char = chr(ord(char) + 1)\
    \ # Decrement ascii value of the first char\n                word += char # Append\
    \ the char onto the word\n            new_words.append(word) # Add to the new_words\
    \ list\n            word = char\n        else:\n            word += w\n      \
    \      new_words.append(word)\n    return \" \".join(new_words) # Join the new_words\
    \ by space", "  new_str = ''\n  s.split(\" \").each do |word|\n    new_str +=\
    \ word[0].upcase + word[1..-1] + \" \"\n  end\n  new_str\nend", "    alphabet\
    \ = string.ascii_lowercase\n    l = len(alphabet)\n    lst = []\n    \n    for\
    \ i in s:\n        \n        if i.isalpha():\n        \n            if i == \"\
    \ \":\n                lst.append(i)\n            else:\n            \n      \
    \          lst.append(alphabet[(alphabet.index(i) + l)%l])\n        else:\n  \
    \          lst.append(i)\n    \n    return \"\".join(lst)", "  s.split(//).sort.join\
    \ //\nend", "    words = s.split(' ')\n    words_sorted = []\n    \n    for word\
    \ in words\n      word_chars = word.chars\n      word_sorted = []\n      \n  \
    \    for char in word_chars\n        char_ord = char.ord\n        \n        if\
    \ char_ord > 97\n          new_char = 'a'\n        else\n          new_char =\
    \ 'z'\n        \n        word_sorted.concat(new_char)\n      \n      words_sorted.concat(word_sorted.join(''))\n\
    \    \n    sentence = words_sorted.join(' ')\n    \n    return sentence\n    ",
  "  s = s.split(\"\\n\")\n  s.map!{|x| x.scan(/\\w+/).map{|w| w.chars.sort_by{|c|\
    \ c.ord}.to_s }.join}\n  return s.join(\"\\n\")\nend", "  s.downcase!\n  s = s.scan(/\\\
    w+/)\n  s.sort!\n  s.join('')\nend\n</code>\nIt also uses a method called downcase\
    \ to lowercase everything in the string\nand scans the string using regex to find\
    \ all the words in the string and then sorts them and joins them back using spaces.\n\
    For Example: Hello World!!! becomes ehllo !!!Wdlor\n<|/ a |>\n<| a tags=ruby,arrays,sorting\
    \ dscore=0 |>\nI believe the following code will do the trick. \n<code>", "  result\
    \ = ''\n  s.split(\" \").each do |word|\n    result << word.chars.sort.join\n\
    \  end\n  result\nend", "    word_list = s.split(\" \")\n    new_word_list = ['']*len(word_list)\n\
    \    char_list = list(s.lower())\n    \n    for i in range(len(word_list)):\n\
    \        char_list.sort()\n        char_list.sort(key=lambda x: ord(x))\n    \
    \    new_word_list[i] = ''.join(char_list)", "  s = ''\n  s.split(//).each do\
    \ |char|\n    char.upcase > char.downcase ? char.downcase : char.upcase\n    char\n\
    \  end\nend", "  return s.gsub(/(\\w)(\\w+)/, '\\\\2\\\\1')\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    words = s.split(' ')\n    characters = string.ascii_lowercase\
    \ + string.ascii_uppercase\n    word_list = [\"\"]\n    for word in words: \n\
    \        word_list.append(word.lower())\n    ordered_list = ''\n    for word in\
    \ word_list: \n        ordered_list += word + ''.join([characters[i] for i in\
    \ [ord(c) for c in word]])\n    return ordered_list", "  s = s.split(' ') \n \
    \ s.each do |i| \n    i.downcase \n    i.gsub! /[^a-zA-Z]/,''\n    i.split('').sort.join('')\n\
    \  end.join(' ')\nend", "    word = s.split(\" \")\n    word_copy = word[:]\n\
    \    word_copy.sort()\n    word_copy.reverse()\n    s = \" \".join(word_copy)\n\
    \    return s", "  s.split(' ').sort.join(' ')\nend\n</cell>\n<code language=julia-1.6>",
  "  # TODO: Write your solution here\nend\n</cell>\n<cell>", "  s.split(\" \").sort.join\n\
    end", "    words = []\n    i = 0\n    while i < len(s)\n        word = s[i]\n\
    \        i += 1\n        words.append(word)\n    while i < len(s)\n        word\
    \ = s[i]\n        i += 1\n        j = words.index(word) + 1 \n        words[j]\
    \ = word\n    return ''.join(words)", "  s = s.gsub(/ /,\"#\")\n  s = s.split(\"\
    \ \").collect do |w|\n    w.gsub(/[a-zA-Z]/,''.chr).join\n  end.join\n  s.gsub!(/#{s[0]}/,s[0].upcase)\n\
    \  return s\nend\n</cell>\n<cell>", "  # write your code here\n  s = s.split('\
    \ ')\n  sorted_words = []\n  sorted_word_count = 0\n  sorted_word_index = 0\n\
    \  i = 0\n  while i < len(s):\n    if s[i].isalpha():\n      sorted_words.append(s[i])\n\
    \      sorted_word_count += 1\n      i += 1\n    else:\n      break\n  while sorted_word_count\
    \ > 0:\n    sorted_words[sorted_word_index] = s[sorted_word_index].upper()\n \
    \   sorted_word_index += 1\n    sorted_word_count -= 1\n  return ' '.join(sorted_words)",
  "  # TODO: Write your implementation here.\n  return s\n</cell>\n<cell>", "    split_s\
    \ = word_split(s)\n    ordered = \"\"\n    for word in split_s:\n        ordered\
    \ += word\n        ordered += \" \"\n    ordered = ordered[:-1]\n    return ordered\n\
    \    ", "  s = str.split(s)\n  res = []\n  for i in 0..(s.length - 1)\n    s =\
    \ s[0..(s.length - 1)].sort.reverse\n    if s[i] == \" \".chr\n      s[i] = \"\
    \"\n    else\n      s[i + 1] = s[i + 1] + s[i].chr\n    res.join(\" \")\n  end\n\
    \  return s\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nThis is not correct.\
    \ Try it, and you'll see that \"hello world\" becomes \"o llo oll\". It would\
    \ be nice to see a version that keeps the original spacing of the words. That\
    \ can be done by modifying the regex in the `split` call slightly: `.split(/\\\
    s+/).sort { |a,b| a.size<=>b.size }.join`\n<|/ c |>\n<| c |>\nAgreed. Edited to\
    \ include `sort` and `reverse` calls.\n<|/ c |>\n<| c |>\nAh, yes, that makes\
    \ more sense now.\n<|/ c |>\n<| c |>\nYou don't need `sort` at all. `sort` sorts\
    \ in-place, so the returned array is sorted in-place.\n<|/ c |>\n<| c |>\n, that's\
    \ what I meant when I wrote \"not correct yet\". I've tried to fix it, but I may\
    \ have missed a corner case. I'll probably have to check this again before I post\
    \ it.\n<|/ c |>\n<| a |>\n<code>", "  new_word = \"\"\n  s = new_word + s.to_s.split(\"\
    \ \").sort.join(' ') + new_word\n  return s\nend", "  # TODO: Write your code\
    \ here.\nend", "    s = s.split(\" \") if s.kind_of? String else s\n    p =  s.map\
    \ {|x| x.ord.to_s}.uniq.sort \n    p << \"\" if p.size != s.size\n    s = p.join(\"\
    \ \")\nend", "  s.split(' ').sort_by {|s| s.bytesize}.join(' ')\nend", "  result\
    \ = \"\"\n  words = s.split(\" \").sort\n  result = words.join\n  result = result.gsub(\"\
    \ \", \"\").gsub(\" \", \"\")\n  return result\nend", "  words = s.split(' ')\
    \ # split words in a sentence\n  words_sorted = words.sort.join # sort the words\
    \ based on ascii value\n  result = words.join(' ') # join all the words in the\
    \ sentence with spaces\n  result << words_sorted # join the sorted words with\
    \ spaces and return\nend\n</code>\n<|/ a |>\n<| c |>\nThis is much better than\
    \ the one I posted. I also like that it sorts the words based on the ascii value.\n\
    <|/ c |>\n<| a tags=ruby |>\nHere is my take on this:\n<code>", "  res = []\n\
    \  s.split.each { |item|\n    item.split.each { |letter|\n      res += [letter]\n\
    \    }\n    res += [\" \"]\n  }\n  res.join.strip\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,string,arrays\
    \ dscore=0 |>\n<| c |>\nThis is awesome!  I do get an error when I try to run\
    \ it.  For anti_shuffle.call(\"Hi\") I get \"undefined method `split' for nil:NilClass\"\
    .  I understand that split doesn't exist, but I'm not sure why.  Does that make\
    \ sense?\n<|/ c |>\n<| c |>\nSorry my bad, forgot that. Please check it again.\
    \ Sorry for not pointing it out.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,string,arrays\
    \ |>\n<code>", "  s = s.split(\" \").collect do |s| s.ord; end\n  s.max\nend",
  "  s.split.sort.join\nend", "  s.downcase!\n  s.split(' ').sort do |a, b|\n    a.split('').map{|i|\
    \ i.upcase }.join.to_i <=> b.split('').map{|i| i.upcase }.join.to_i\n  end.join\
    \ \" \"\nend\n</code>\n<|/ a tags=ruby,string,algorithm |>\n<| a |>\nYou could\
    \ do the following:", "  s = s.split(' ')\n  s.sort!\n  s.reverse!\n  s.join('\
    \ ')\nend", "  s = s.replace(\" \", \"\")\n  s.split(\" \").sort!.map do |s|\n\
    \    s.upcase\n  end.join(\" \")\nend\n</code>\n<|/ a tags=ruby,string,arrays,shuffle\
    \ dscore=3 |>\n<| a tags=ruby,string,arrays,shuffle dscore=3 |>\nA simple and\
    \ efficient solution would be to first sort the string and then pick random chars\
    \ one by one in alphabetical order. \n<code>", "  # Split string into array.\n\
    \  arr = s.split(\" \")\n  # Return array with new words.\n  return arr.collect\
    \ do |word|\n    # Find index of word based on ascii value.\n    index = word.index(word,\
    \ 0) + 1\n    # Return string without word and add ascii value.\n    \"#{word.slice(0,index)}#{word.slice(index)}\"\
    \n  end.join(' ')\nend", "  words = s.split # split the sentence into words\n\
    \  words.sort! # sort them in ascending order\n  s = words.join # join them with\
    \ spaces again\n  s.delete! # remove duplicate space characters\nend", "    return\
    \ s.split(' ').sort().join(' ')\nend\n</cell>\n<code language=julia-1.6>\nanti_shuffle.(\"\
    Hi\")\n</cell>\n<text>\n5.1 Challenge: Write a function that takes a string and\
    \ returns the number of words in the string.", "  s = s.split(\" \").sort.join\n\
    end", "  # Your code here\n  result = []\n  s = s.replace(\" \", \"\")\n  words\
    \ = s.split()\n  words.sort(key=lambda x: ord(x[0]))\n  for i in words:\n    if\
    \ i not in result:\n      result.append(i)\n  return \" \".join(result)", "  \
    \  words = s.split(\" \") # split the string into words separated by space\n \
    \   ordered_words = words.sort_by { |word| word.ord }\n    ordered_words.join(\"\
    \ \")\nend", "    # Replace all the spaces with another character.\n    s_ = s.gsub(\"\
    \ \", \"z\")\n    s_ = s_.gsub(\" \", \"a\")\n    s_ = s_.gsub(\" \", \"b\")\n\
    \    s_ = s_.gsub(\" \", \"c\")\n    s_ = s_.gsub(\" \", \"d\")\n    s_ = s_.gsub(\"\
    \ \", \"e\")\n    s_ = s_.gsub(\" \", \"f\")\n    s_ = s_.gsub(\" \", \"g\")\n\
    \    s_ = s_.gsub(\" \", \"h\")\n    s_ = s_.gsub(\" \", \"i\")\n    s_ = s_.gsub(\"\
    \ \", \"j\")\n    s_ = s_.gsub(\" \", \"k\")\n    s_ = s_.gsub(\" \", \"l\")\n\
    \    s_ = s_.gsub(\" \", \"m\")\n    s_ = s_.gsub(\" \", \"n\")\n    s_ = s_.gsub(\"\
    \ \", \"o\")\n    s_ = s_.gsub(\" \", \"p\")\n    s_ = s_.gsub(\" \", \"q\")\n\
    \    s_ = s_.gsub(\" \", \"r\")\n    s_ = s_.gsub(\" \", \"s\")\n    s_ = s_.gsub(\"\
    \ \", \"t\")\n    s_ = s_.gsub(\" \", \"u\")\n    s_ = s_.gsub(\" \", \"v\")\n\
    \    s_ = s_.gsub(\" \", \"w\")\n    s_ = s_.gsub(\" \", \"x\")\n    s_ = s_.gsub(\"\
    \ \", \"y\")\n    s_ = s_.gsub(\" \", \"z\")\n    s_ = s_.gsub(\"z\", \"a\")\n\
    \    s_ = s_.gsub(\"a\", \"b\")\n    s_ = s_.gsub(\"b\", \"c\")\n    s_ = s_.gsub(\"\
    c\", \"d\")\n    s_ = s_.gsub(\"d\", \"e\")\n    s_ = s_.gsub(\"e\", \"f\")\n\
    \    s_ = s_.gsub(\"f\", \"g\")\n    s_ = s_.gsub(\"g\", \"h\")\n    s_ = s_.gsub(\"\
    h\", \"i\")\n    s_ = s_.gsub(\"i\", \"j\")\n    s_ = s_.gsub(\"j\", \"k\")\n\
    \    s_ = s_.gsub(\"k\", \"l\")\n    s_ = s_.gsub(\"l\", \"m\")\n    s_ = s_.gsub(\"\
    m\", \"n\")\n    s_ = s_.gsub(\"n\", \"o\")\n    s_ = s_.gsub(\"o\", \"p\")\n\
    \    s_ = s_.gsub(\"p\", \"q\")\n    s_ = s_.gsub(\"q\", \"r\")\n    s_ = s_.gsub(\"\
    r\", \"", "    ans = \"\"\n    words = s.split(\" \")\n    words.sort()\n    words.reverse()\n\
    \    for word in words:\n        ans += word\n        ans += \" \"\n    return\
    \ ans\n</cell>\n<cell>", "    s.gsub!(/\\s+/, \"_\")\n    s.split(\" \").sort\n\
    \  end\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nWhy was this downvoted? It is\
    \ the correct answer, though it is an incredibly inefficient solution for very\
    \ large inputs. The accepted answer uses a more efficient solution.\n<|/ c |>\n\
    <| a tags=string,ruby |>\nA solution using String#tr:\n<code>", "  new_string\
    \ = []\n  new_word = \"\"\n  s.split(\" \").each do |word|\n    letter = word[0]\n\
    \    new_word += letter\n    new_word += letter\n    new_word += letter\n    new_word\
    \ += letter\n    new_word += letter\n    new_word += letter\n    new_word += letter\n\
    \    new_word += letter\n    new_word += letter\n    new_word += letter\n    new_word\
    \ += letter\n    new_word += letter\n    new_word += letter\n    new_word += letter\n\
    \    new_word += letter\n    new_word += letter\n    new_word += letter\n    new_word\
    \ += letter\n    new_word += letter\n    new_word += letter\n    new_word += letter\n\
    \    new_word += letter\n    new_word += letter\n    new_word += letter\n    new_word\
    \ += letter\n    new_word += letter\n    new_word += letter\n    new_word += letter\n\
    \    new_word += letter\n    new_word += letter\n    new_word += letter\n    new_word\
    \ += letter\n    new_word += letter\n    new_word += letter\n    new_word += letter\n\
    \    new_word += letter\n    new_word += letter\n    new_word += letter\n    new_word\
    \ += letter\n    new_word += letter\n    new_word += letter\n    new_word += letter\n\
    \    new_word += letter\n    new_word += letter\n    new_word += letter\n    new_word\
    \ += letter\n    new_word += letter\n    new_word += letter\n    new_word += letter\n\
    \    new_word += letter\n    new_word += letter\n    new_word += letter\n    new_word\
    \ += letter\n    new_word += letter\n    new_word += letter\n    new_word += letter\n\
    \    new_word += letter\n    new_word += letter\n    new_word += letter\n    new_word\
    \ += letter\n    new_word += letter\n    new_word += letter\n    new_word += letter\n\
    \    new_word += letter\n    new_word += letter\n    new_word += letter\n    new_word\
    \ += letter\n    new_word += letter\n    new_word += letter\n    new_word += letter\n\
    \    new_word += letter\n    new_word += letter\n    new_word += letter\n    new_word\
    \ += letter\n    new_word += letter\n    new_word += letter\n    new_word += letter\n\
    \    new_word += letter\n    new_word += letter\n    new_word += letter\n    new_word\
    \ += letter\n    new_word += letter\n    new_word += letter\n    new_word += letter\n\
    \    new_word += letter\n    new_word += letter\n    new_word += letter\n    new_word\
    \ += letter\n    new_word += letter\n    new_word += letter\n    new_word += letter\n\
    \    new_word += letter\n    new_word += letter\n    new_word += letter\n    new_word\
    \ += letter\n    new_word += letter\n    new_word += letter\n    new_", "  return\
    \ s.split(' ').sort().join(' ')\n</code>\nThe test case\n<code>", "  words = s.split('\
    \ ')\n  words.sort!\n  words.join(' ')\nend\n</cell>\n<text>\nQ4: Write a function\
    \ that takes a string and a dictionary, and returns an ordered version of string.\n\
    The dictionary is a hash of words that are already in the string. The function\
    \ will return the ordered version of the string.\nNote: You should keep the order\
    \ of words and blank spaces in the sentence.\nFor example:\n>>> anti_shuffle.call(\"\
    Hello World!!!\", {:\"!!!\", :\"World\", :!:\"Hello World\"})\n\"Hello World\"\
    \n>>> anti_shuffle.call(\"Hello World!!!\",{:\"!!!\", :\"World\", :!:\"Hello World\"\
    })\n\"Hello World!!!\"\n>>> anti_shuffle.call(\"Hello World!!!\",{:\"!!!\", :\"\
    World\", :!:\"Hello World\", :\"!!\"::\"World\", :!!!:\"Hello\", :!!!\"World\"\
    , :!!!\"Hello\", :!!!\"World\", :!!!\"Hello\", :\"World\", :\"Hello\", !\"World\"\
    , !\"Hello\", !\"World\", !\"Hello\", !\"World\", !\"Hello\", !\"World\", !\"\
    Hello\", :\"Hello\", !\", !\"World\", !\", !\", !\", !\", !\"World\", !\", !\"\
    Hello\", !\", !\"World\", !\", !\"Hello\", !\", !\"World\", !\", !\"Hello\", !\"\
    , !\"World\", !\", !\"Hello\", !\", !\"World\", !\", !\"Hello\", !\", !\"World\"\
    , !\", !\"Hello\", !\", !\"World\", !\", !\"Hello\", !\", !\"World\", !\", !\"\
    Hello\", !\", !\"World\", !\", !\"Hello\", !\", !\"World\", !\", !\"Hello\", !\"\
    , !\"World\", !\", !\"Hello\", !\", !\"World\", !\", !\"Hello\", !\", !\"World\"\
    , !\", !\"Hello\", !\", !\"World\", !\", !\"Hello\", !\", !\"World\", !\", !\"\
    Hello\", !\", !\"World\", !\", !\"Hello\", !\", !\"World\", !\", !\"Hello\", !\"\
    , !\"World\", !\", !\"Hello\", !\", !\"World\", !\", !\"Hello\", !\", !\"World\"\
    , !\", !\"Hello\", !\", !\"World\", !\", !\"Hello\", !\", !\"World\", !\", !\"\
    Hello\", !\", !\"World\", !\", !\"Hello\", !\", !\"World\", !\", !\"Hello\", !\"\
    , !\"World\", !\", !\"Hello\", !\", !\"World\", !\", !\"Hello\", !\", !\"World\"\
    , !\", !\"Hello\", !\", !\"World\", !\", !\"Hello\", !\", !\"", "  result = \"\
    \"\n  words = s.split(\" \")\n  words.sort(&:downcase)\n  words.each do |word|\n\
    \    if word.empty?\n      result << word\n      next\n    end\n    result <<\
    \ word.gsub(/[ -]/, \"\").reverse.insert(word.length, \"z\").insert(1, word.first).insert(-1,\
    \ word.last)\n  end\n  result\nend", "    words = s.split(\" \")\n    new_words\
    \ = []\n    \n    for word in words\n        new_word = word\n        \n     \
    \   for i in \"abcdefghijklmnopqrstuvwxyz\"\n            if  word[i] < new_word[i]\
    \ \n                new_word = new_word[i..j]\n            end\n        new_words\
    \ << new_word\n    end\n    \n    words = new_words * \" \"\n    \n    return\
    \ words\nend", "    s = s.split(\"\")\n    s.reverse!\n    s = s.join\n    s.split(\"\
    \ \").join\n    s = \"#{'\" + s + \"'}\"\n    s = s.split(s)\n    s = s.join(\"\
    _\")\n    return s\nend", "    letters = s.split(//).sort\n    letters.join\n\
    end", "  s.downcase!\n  s.gsub(\" \", \"_\")\n  s.gsub!(/[^a-z]+/i, \"_\")\n \
    \ s.gsub!(/[A-Z]+/i, \"_\")\n  s.split(\" \").sort!\n  s.join(\" \")\nend", " \
    \   # Replace all spaces with an underscore\n    s = s.gsub(' ', \"_\")", "  s\
    \ = s.split(' ') \n  s.each{ |word| word.upcase }\n  s.each{ |word| word.downcase\
    \ }\n  s.each{ |word| word.chars.sort_by{ |x| x.ord }.join(\"\") }\n  s.join('\
    \ ')\nend", "  s.gsub(/\\w+/) {|word| word.gsub(/./) {|letter|\n    letter.upcase}}\n\
    end", "  s.downcase!\n  s.gsub!(/\\s+/, \" \")\n  s.split(' ').sort.join ' '\n\
    end\n</cell>\n<cell>", "  words = s.split \" \"\n  words.sort!\n  words.join \"\
    \ \"\nend", "    ans = \"\"\n    words = s.split(\" \") # Split sentence on spaces\n\
    \    words.sort!\n    words = words.join # Convert to string (join using space\
    \ )\n    words = words.split(\"\") # Split string in characters, split again on\
    \ \"\"\n    words.sort!\n    words.join!\n    words.each { |char| ans += char\
    \ }\n    ans # Return results\nend\n</code>\n<|/ a |>\n<| c |>\nYou might want\
    \ to use a [block lambda](http://stackoverflow.com/questions/4394398/ruby-block-equivalent-for-loops-i-e-block-yield)\n\
    <|/ c |>\n<| c |>\nI haven't tested the above code, but it looks right to me.\
    \ What are you referring to by \"block\"?\n<|/ c |>\n<| c |>\nI meant the `{ |char|\
    \ ans += char }` part. I'm not that familiar with Ruby's syntax so I don't know\
    \ how I would have done that in Ruby, but it's definitely a possibility.\n<|/\
    \ c |>\n<| c |>\nThanks for your answer! I understand now that I have to use `each`\
    \ to iterate over each character of `ans`, however, I'm not understanding how\
    \ to sort alphabetically and keep the spaces? Also, is there a way to not have\
    \ to split the characters in the string?\n<|/ c |>\n<| c |>\nI added a method\
    \ in the answer to do that for you. `words.join` will concatenate them all together\
    \ into a string.\n<|/ c |>\n<| a dscore=3 |>\nSince Ruby 1.8.7, you can also use\
    \ the Enumerable#chunk method.\n<code>\ns.chars.chunk(&:itself).map(&:join).join\n\
    </code>\n<|/ a tags=ruby,string |>\n<| c |>\nThe method `chunk` is actually available\
    \ since 1.8.7. I've updated my answer to reflect that. Thanks!\n<|/ c |>\n<| a\
    \ dscore=3 |>\nA more efficient solution would be the following, using the same\
    \ concept as Eliot's answer:\n<code>\n\"abc\".each_char.each_cons(2).map { |c,p|\
    \ c..p }\n=> [\"ab\", \"ac\", \"ba\", \"bc\", \"ca\", \"cb\", \"cc\"]\n</code>\n\
    <|/ a tags=ruby,string |>\n<| a dscore=2 tags=ruby,string |>\nHere is my solution:\n\
    <code>", "    words = s.split(\" \")\n    words_sorted = []\n    words_sorted\
    \ = sorted(words)\n    s = \"-\".join([word for word in words_sorted])\n    return\
    \ s", "    \n    words = s.split(\" \")\n    \n    new_words = []\n    \n    for\
    \ word in words:\n        \n        new_word = word.strip()\n        \n      \
    \  if len(new_word) > 0:\n            \n            new_words.append(new_word)\n\
    \            \n    \n    return \" \".join(new_words)", "  new_string = \"\"\n\
    \  word = \"\"\n  i = 0\n  while i < s.length\n    char = s[i]\n    j = i + 1\n\
    \    while j < s.length\n      if s[i] == s[j]\n        word = word + char\n \
    \       j++\n      else\n        word = word + char\n        j++\n      end\n\
    \    end\n    new_string = new_string + word\n    word = word\n    i += 1\n  end\n\
    \  return new_string\nend", "    s = s.downcase\n    w = s.split(\" \")\n    w.sort!\n\
    \    w = w.join(\" \")\n    w.gsub!(/[^a-zA-Z ]+/) { |x| x.gsub(/([a-z])/, '\\\
    1')}\n    w.gsub!(/ +/, \"_\")\n    w.gsub!(/[^A-Za-z0-9]+/) { |x| x.downcase}\n\
    \    w.gsub!(/[^a-z]/) { |x| x.downcase}\n    w.gsub!(/[_]/, \"-\") \n    w.gsub!(/_+/,\
    \ \"-\")\n    w.gsub!(/-/, \"_\")\n    w.gsub!(/-/, \"_\")\n    w.gsub!(/-/, \"\
    -\")\n    w.gsub!(/[^a-z0-9-]/, \"-\")\n    w.gsub!(/[^a-zA-Z-]/, \"\")\n    w.gsub!(/[^a-zA-Z]/,\
    \ \"\")\n    w.gsub!(/[^a-zA-Z]/, \"\")\n    w.gsub!(/[^a-zA-Z]/, \"\")\n    w.gsub!(/[^a-zA-Z]/,\
    \ \"\")\n    w.gsub!(/[^a-zA-Z]/, \"\")\n    w.gsub!(/[^a-zA-Z]/, \"\")\n    w.gsub!(/[^a-zA-Z]/,\
    \ \"\")\n    w.gsub!(/[^a-zA-Z]/, \"\")\n    w.gsub!(/[^a-zA-Z]/, \"\")\n    w.gsub!(/[^a-zA-Z]/,\
    \ \"\")\n    w.gsub!(/[^a-zA-Z]/, \"\")\n    w.gsub!(/[^a-zA-Z]/, \"\")\n    w.gsub!(/[^a-zA-Z]/,\
    \ \"\")\n    w.gsub!(/[^a-zA-Z]/, \"\")\n    w.gsub!(/[^a-zA-Z]/, \"\")\n    w.gsub!(/[^a-zA-Z]/,\
    \ \"\")\n    w.gsub!(/[^a-zA-Z]/, \"\")\n    w.gsub!(/[^a-zA-Z]/, \"\")\n    w.gsub!(/[^a-zA-Z]/,\
    \ \"\")\n    w.gsub!(/[^a-zA-Z]/, \"\")\n    w.gsub!(/[^a-zA-Z]/, \"\")\n    w.gsub!(/[^a-zA-Z]/,\
    \ \"\")\n    w.gsub!(/[^a-zA-Z]/, \"\")\n    w.gsub!(/[^a-zA-Z]/, \"\")\n    w.gsub!(/[^a-zA-Z]/,\
    \ \"\")\n    w.gsub!(/[^a-zA-Z]/, \"\")\n    w.gsub!(/[^a-zA-Z]/, \"\")\n    w.gsub!(/[^a-zA-Z]/, ",
  "  s.split\n  sorted_array = s.split\n  sorted_array.sort!\n  sorted_array.join(\"\
    \ \")\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for your answer but the\
    \ problem with that method it only works with alphabetical words i.e \"hi\" becomes\
    \ \"ih\". Can you also provide another way to do this if I want to apply it to\
    \ any word. i.e. \"I love programming\" becomes \"Lv prgrmnts\"\n<|/ c |>\n<|\
    \ c |>\nI have updated the code above. Hope it helps\n<|/ c |>\n<| a |>\n<code>",
  "  # split words by spaces and return an array\n  return s.split.sort\nend", " \
    \   words = s.split(\" \").sort\n    words.reverse!\n    words.join\nend", " \
    \   words = s.split(\" \")\n    words2 = []\n    for word in words\n        chars\
    \ = [ord(char) for char in word]\n        order = chars.sort\n        words2.append(word[:i]\
    \ + word[i:j] + word[j+1:] + order[j:] + order[:j] + order[j:] + order[:j])\n\
    \    return \" \".join(words2)\n</cell>\n<cell>", "  s = s.split(' ').map do |x|\n\
    \    x.chars.sort_by(&:ord).join\n  end.join(' ')\n  return(s)\nend", "  return\
    \ s.to_s.split(\" \").sort.join(' ')\nend", "    # Write your code here\n    array\
    \ = s.split\n    new_array = []\n    blank_space = \" \"\n    sorted_characters\
    \ = {}\n    for i in array:\n        sorted_characters[i] = sorted_characters.get(i,\
    \ 0) +1\n    for i in sorted_characters:\n        if sorted_characters[i] <= 2:\n\
    \            new_array.append(i)\n    for i in new_array:\n        if i == blank_space:\n\
    \            new_array.remove(i)\n    new_string = blank_space.join(new_array)\n\
    \    return new_string\n</code>\n<|/ a dscore=0 |>\n<| c |>\n`anti_shuffle` won't\
    \ work with the input `\"Hi hello\"` because the spaces are in different orders.\n\
    <|/ c |>\n<| c |>\nThis is why I made it more complicated and added the space\
    \ in between the words by converting them into their ascii values\n<|/ c |>\n\
    <| a tags=python,string dscore=0 |>\nI think this is what you want, it's kind\
    \ of complicated but works just fine:\n<code>", "  word_list = s.split\n  new_list\
    \ = []\n  for i in 0..word_list.size-1\n    new_list.push( word_list[i].downcase.to_i\
    \ )\n  end\n  new_list.reduce( (a, b) -> (a<b?b:a) )\nend\n</code>\n<|/ a |>\n\
    <| a |>\nMy first idea was to create a hash with the characters of the word as\
    \ keys and the count as the value which would map the chars to the count, for\
    \ instance:\n<code>\n h=Hash.new(0)\n \"abcde\".split(//).each do |c|\n   h[c]\
    \ += 1\n end\n</code>\nThat would be the easiest way without needing any helper\
    \ functions or regular expressions.\nNow you can sort the hash based on the count\
    \ and print the characters sorted by count (largest to smallest):\n<code>\nh.sort_by{|k,v|\
    \ -v}\n</code>\n<|/ a tags=ruby,shuffle,algorithm,ruby-on-rails dscore=1 |>\n\
    <| c |>\nThis seems pretty efficient.  What I'm struggling with now is finding\
    \ an efficient way to print the letters that get shuffled.  I'd like to do this\
    \ without having to store it in memory until it's shuffled.\n<|/ c |>\n<| c |>\n\
    I ended up doing something like this and storing it in memory, but I'd really\
    \ like to figure out a way to do it without storing it in memory.  I thought about\
    \ sorting alphabetically, but that would only work if all the letters were the\
    \ same length, which they aren't in my case.\n<|/ c |>\n<| c |>\nyou could store\
    \ `h.sort_by{|k,v| -v}` as `shuffled_letters = h.sort_by{|k,v| -v}`\n<|/ c |>\n\
    <| a dscore=1 |>\nI was able to do this:\n<code>", "    # write your code here\n\
    \    lst = []\n    for c in s:\n        if c.isupper():\n            lst.append(c)\n\
    \        elif c.islower():\n            lst.append(c.upper())\n        elif c.isspace():\n\
    \            lst.append(c.lower())\n    lst.reverse()\n    return ''.join(lst)",
  "    chars = s.split(//)\n    chars.sort do |a, b|\n        return a <=> b # return\
    \ if a == b\n    end\n    chars.join(\"\")\nend", "    s = s.strip.downcase\n\
    \    s = s.strip.gsub(/[\\s]+/, \" \").strip\n    letters = Array.new(s.length)\
    \ { |i| s[i..i+1] }.sort\n    s.gsub!(/\\s+/, \"\")\n    s.gsub!(letters.join,\
    \ letters[0...-1].join)\n    puts s\nend", "  s.gsub!(/(\\S+)( \\S+)?/){ |m| m.reverse!;\
    \ m[1] }\n  s.gsub!(/(\\S+)(\\s+)(\\S+)?/){ |m| m[1].reverse!; m[2] }\n  s\nend",
  "  s.split(\" \").sort!.shuffle.join\nend", "  # Return the string with words sorted\
    \ in alphabetic order.\n  # Note: You don't have to return the original string.\n\
    \  # You need to create a new string.\n  new_s = \"\"\n  # Create a blank array.\n\
    \  a = Array.new()\n  s.split(\" \").each do |word|\n    # Get the ascii value\
    \ of each character\n    character = word.ord\n    # Add the character to a sorted\
    \ array.\n    a.push(character)\n  end\n  # Sort the array in ascending order.\n\
    \  a.sort!\n  # Iterate through the sorted array and for each element get an index.\n\
    \  # For each element insert a character at the specified index.\n  # Example:\
    \ arr[i] = \"a\"\n  a.each_with_index do |item, i|\n    new_s << a[i]\n    new_s\
    \ << \" \"\n  end\n  # Return the string.\n  return new_s\nend", "  new_s = s.dup.tr(\"\
    \ \\n\", \"!\").tr(\"!\", \" \").tr(\"!!\", \"!\")\n  new_s.sub!(/./, lambda do\
    \ |ch|\n    ch.upcase\n  end).scan(/./).sort_by(&:ord).join\nend", "  # Write\
    \ your code here.\n  s.gsub(/\\w+/){|s| s.split('').sort_by{|x| x.ord - 'a'}}.join('\
    \ ')\nend", "  \n  s = s.split() \n  s.each_index do |i| \n    if s[i] == \" \"\
    \n      s[i] = \"\"\n    end\n  end\n  \n  s.each_index do |i| \n    if s[i] !=\
    \ \"\"\n      s[i].downcase!\n    end\n  end\n  \n  return s.join(\" \")\nend",
  "  result = s.split(\" \").sort{|a,b| a.chars.sort_by {|e| e.to_i}.first<=>b.chars.sort_by\
    \ {|e| e.to_i}.first}\n  result = result.join(\" \")\n  result.blank! if result[-1]\
    \ == \" \"\n  result\nend", "  s = s.split() # Split a string into an array of\
    \ words.\n  s.sort! # Sort the array of words in ascending order.\n  s.join('')\
    \ # Join the array of words with space.\nend", "  words = s.split(' ').sort.reverse\n\
    \  s.gsub(/\\w+/, words.join)\nend", "    answer = \"\"\n    words = s.split('\
    \ ')\n    words_sorted = []\n    \n    for word in words:\n        words_sorted.append(word.lower())\n\
    \    \n    for i in range(len(words_sorted)):\n        for k in range(len(words_sorted)):\n\
    \            if i < k:\n                if words_sorted[i] > words_sorted[k]:\n\
    \                    words_sorted[i], words_sorted[k] = words_sorted[k], words_sorted[i]\n\
    \                    \n    words = ' '.join(words_sorted).split()\n    \n    for\
    \ word in words:\n        answer += word\n    \n    return answer", "  s.downcase!\n\
    \  s.gsub!(/\\s+/, \" \")\n  s.gsub!(/([^ ])([A-Z])/, '\\1 \\2')\n  s.gsub!(/([A-Z])([^\
    \ ])/, '\\1 \\2')\n  s.gsub!(/([^ ])([^A-Z])([A-Z])/, '\\1 \\2 \\3')\n  s.gsub!(/([A-Z])([A-Z])([^\
    \ ])/, '\\1 \\2\\3')\n  s.gsub!(/([A-Z])([^A-Z])([^ ])/, '\\1 \\3\\2')\n  s.downcase!\n\
    \  s\nend", "  return s.split(' ').collect{|word| word.chars.sort.join}.join('\
    \ ')\nend", "  # Split string into an array of words, then sort alphabetically.\n\
    \  words = s.split \" \"\n  words.sort\n  # Return an array of words where each\
    \ word is replaced by an\n  # ordered version where all characters are in ascending\
    \ order.\n  new_words = []\n  s.split.each do |word|\n    new_word = word\n  \
    \  word.split(\"\").each do |char|\n      if char.ord.to_i < char.ord.to_i\n \
    \       new_word += \"a\"\n      else\n        new_word += \"b\"\n      end\n\
    \    end\n    new_words << new_word\n  end\n  return new_words.join(\" \")\nend\n\
    </code>\n<|/ a |>\n<| c |>\nThanks for this, I did learn a lot about Ruby from\
    \ it!\n<|/ c |>\n<| a dscore=3 tags=arrays,string,ruby,function |>\nHere is a\
    \ simple solution that uses the Ruby sort function along with an array of ASCII\
    \ values to sort the string: \n<code>", "  s = s.split(' ').sort\n  s.join\nend\n\
    </cell>\n<code language=julia-0.6>\nusing Plots\n</cell>\n<code language=julia-0.6>\n\
    x = collect(0:9)\ny = sin.(x)\nplot(x, y);\n</cell>\n<code language=julia-0.6>",
  "  s.split(' ').map{|w| w.chars.map{|c| c.upcase }}.join(' ').gsub(/\\w+/){|s| s.split('').sort}.chomp\n\
    end", "    letters = s.split(//)\n    letters.sort!\n    letters.join//\nend",
  "  new_string = \"\"\n  new_list = s.split(\" \").sort\n  new_list.each do |character|\n\
    \    new_string << character\n  end\n  new_string\nend", "  s = s.split(\" \"\
    ).sort.join \" \"\n  s = s.gsub(\" \", \"\")\n  s = s.split(\"\")\n  s.reverse!\n\
    \  s.join!\n  s\nend", "  s.gsub!(/\\s+/, \" \")\n  s.split(\" \").sort.join\n\
    end", "  res = []\n  i = 0\n  while i < s.size\n    word = s[i]\n    chars = word.split('\
    \ ')\n    chars.sort() \n    word = chars[0]\n    res << word\n    i += 1\n  end\n\
    \  return res.join(' ')\nend", "  new_sentence = ''\n  count = 0\n  sentence =\
    \ s.split(//).map(&:strip).reject{|x| x.empty?}\n  sentence.each do |x|\n    if\
    \ x.start_with?(' ') && count > 0\n      new_sentence += ' '\n      count += 1\n\
    \    end\n    new_sentence += x.upcase\n  end\n  return new_sentence\nend", " \
    \   words = s.split(\" \")\n    words_shuffled = \"\"\n    sorted_words = []",
  "  # Your code here\n  result = ''\n  words = s.split\n  words.each do |x|\n   \
    \ if x.size == 0 then next\n    elsif x.include?(\" \") then x = x.gsub(\" \"\
    , \"_\")\n    elsif x.include?(\"_\") then x = x.gsub(\"_\", \" \")\n    end\n\
    \    result << x <<\" \"\n  end\n  return result\nend", "  s = words_to_ascii(s)\n\
    \  words = s.split(\" \")\n  word_sorted = words.sort\n  \n  new_s = \"\"\n  \n\
    \  for word in word_sorted\n    if word != \"\"\n      new_s += word + \" \"\n\
    \  \n  new_s.strip!\n  new_s\nend", "    s=s.split\n    s2 = []\n    s2.insert(0,s[0])\n\
    \    for i,c in enumerate(s[1:]):\n        if ord(c)>ord(s[0]):\n            tmp\
    \ = s2[0]\n            s2[0] = c\n            s2[i+1] = tmp\n        else:\n \
    \           s2[i+1] = c\n    return ' '.join(s2)", "    # Your code here\nend\n\
    </cell>\n<text>\nProblem 2\nWrite a function that takes a string and returns an\
    \ ordered version of it. Ordered version of string, is a string where all words\
    \ (separated by space) are replaced by a new word where all the characters arranged\
    \ in descending order based on ascii value.", "  return s.gsub(/\\w+/){|x| x.chars.sort_by{|c|\
    \ c.to_i}.join}\nend\n</cell>\n<text>\nChallenge Problem\nWrite a function that\
    \ takes a string and returns the string with the words reversed.\nFor example:\n\
    >>> reverse_words.call(\"hello world\")\n\"world hello\"", "  s.downcase!\n  s.gsub!(/\\\
    s+/, \" \")\n  s.gsub!(/[^a-z0-9 ]/, \"_\")\n  s.split.each do |word|\n    word.gsub!(/[^a-z\
    \ ]/, \"_\")\n  end\n  s\nend", "    return s.split(\" \").map(&:chars).map(&:sort).join\n\
    end", "  result = \"\"\n  s.split(\" \").each do |word|\n    char_list = word.split('')\n\
    \    char_list.sort_by(&:ord)\n    char_list << \"\"\n    result = result + char_list.map(&:chr).join('')\n\
    \    result = result + \" \" + word + \" \"\n  end\n  result.chomp\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\nI made an example using recursion and yield\
    \ to get the next word in the list without sorting the list first. This is probably\
    \ a little more efficient than sorting the entire array each time you get a word.\n\
    <code>", "  s = s.split(\" \")\n  s.each_index do |i|\n    s[i][0] = s[i].delete(i).downcase\n\
    \  end\n  s.join(\" \")\nend", "  str.split(s).sort_by{ |str| str.each_char.sort_by{\
    \ |char| char.ord - 64}.join }.join\nend", "  s.gsub!(' ','').gsub!('!','') #\
    \ remove blank and exclamation mark\n  s = s.gsub(/[a-zA-Z]+/) {|c| c.downcase\
    \ } # lower case letter\n  s = s.gsub(/[^a-zA-Z]+/) {|c| c.upcase } # upper case\
    \ letter\n  s = s.gsub(/\\s+/, '-') # replace multiple spaces with one\n  s =\
    \ s.gsub(/--/, '-') # replace two dashes with one\n  s = s.gsub(/-$/, '') # remove\
    \ trailing dashes\n  s.downcase!\n  s\nend", "  s.split(\" \").map! do |word|\n\
    \    word.split(\"\").sort_by do |c|\n      c.to_i.abs\n    end.join(\"\")\n \
    \ end.join(\" \")\nend", "\ts = s.split(\"  \")\n\ts.sort!\n\ts.join!\n\ts.join(\"\
    \  \")\nend", "  shuffled = s.dup\n  shuffled.gsub!(/\\w+/){|s| s.to_s[0...1].upcase\
    \ + s.to_s[2...3].downcase }\n  shuffled\nend", "  new_s = \"\"\n  s.split(\"\
    \ \").sort.each { |word| new_s += word }\n  new_s\nend", "    words = s.split(\"\
    \ \").sort\n    s = words.join(\" \")\nend\n</cell>\n<code language=julia-1.6>\n\
    anti_shuffle.(\"Hi\")\n</cell>\n<code language=julia-1.6>\nanti_shuffle.(\"hello\"\
    )\n</cell>\n<code language=julia-1.6>\nanti_shuffle.(\"Hello World!!!\")\n</cell>\n\
    <code language=julia-1.6>", "  words = s.split(\" \")\n  sorted_words = []\n \
    \ sorted_chars = []\n  for i in words\n    if words.index(words[i]) != words.index(words[i])\
    \ - 1 then\n      words[i] = words[words.index(words[i]) - 1]\n      words[words.index(words[i])\
    \ - 1] = \"\"\n    end\n  end\n  for i in words\n    sorted_chars = sorted_chars\
    \ + i.split(\"\")\n    sorted_chars = sorted_chars.sort\n  end\n  return words.join(\"\
    \ \")\nend\nprint(anti_shuffle.call(\"Hi\"))\nprint(anti_shuffle.call(\"hello\"\
    ))\nprint(anti_shuffle.call(\"Hello World!!!\")) \n</cell>\n<cell>", "  s.split(\"\
    \ \").each do |word|\n    word.chars.sort_by{|c| c.ord - \"A\".ord}.join\n  end\n\
    end", "  s.gsub(/\\s+/, '').scan(/(\\p{Word})/).each_with_object({}) { |(word,\
    \ hash)| hash[word] = word.chars.sort_by(&:itself).join }\nend", "  s = s.gsub(\"\
    \ \", \"_\")\n  s = s.downcase\n  arr = s.split\n  arr.sort!\n  s = arr.join\n\
    \  s\nend\n  ", "    w = \"\"\n    l = s.split(\" \")\n    for i in l:\n     \
    \   for j in i:\n            if ord(char) >= ord(\"a\"):\n                if ord(char)\
    \ < ord(\"z\"):\n                    w = w + char.lower()\n                else:\n\
    \                    w = w + char.upper()\n            elif ord(char) >= ord(\"\
    A\"):\n                if ord(char) < ord(\"Z\"):\n                    w = w +\
    \ char.upper()\n                else:\n                    w = w + char.lower()\n\
    \    return w\n</cell>\n<cell>\nanti_shuffle(\"hello world\")\n</cell>\n<cell>",
  " \n  return s\n \n \nanti_shuffle.defv = True\n ", "    words = s.split(' ')\n\
    \    sorted_words=[]\n    new_words=[]\n    for i in range(len(words)):\n    \
    \    sorted_words.append(words[i])\n    for i in range(len(sorted_words)):\n \
    \       sorted_words[i]=sorted_words[i].replace(\" \", \"\")\n        sorted_words[i]=sorted_words[i].lower()\n\
    \        if sorted_words[i].isalpha():\n            new_words.append(sorted_words[i])\n\
    \    for i in range(len(new_words)):\n        new_words[i]=new_words[i].ljust(3,\"\
    \ \")\n    new_string=''\n    for word in new_words:\n        new_string=new_string+word+'\
    \ '\n    new_string=new_string.replace('  ', ' ')\n    return new_string", " \
    \ s.downcase!\n  s.gsub!(\" \", \"_\")\n  s.gsub!(\"^_*\", \"\")\n  s.gsub!(\"\
    _*$\", \"\")\n  s.downcase!\n  s.gsub(/\\s+/, \" \")\nend", "    words = s.split\n\
    \    words.sort(key=sorter)\n    return \" \".join(words)", "    words = s.split(\"\
    \ \")\n    words_ordered = words.sort\n    s_ordered = words_ordered.join \" \"\
    \nend", "  s.split(' ').sort.join(' ')\nend\n</code>\n<|/ a tags=string,ruby,algorithm\
    \ |>\n<| c |>\n`split` and `join` are extremely efficient in Ruby, so using `gsub`\
    \ is unnecessary and unreadable.  Also, your example would also produce `Hello!!!`\
    \ instead of `Hello !!!Wdlor`.\n<|/ c |>\n<| c |>\nThanks for your comment. Your\
    \ are right about using gsub. But I wanted to keep the code as clean as possible.\
    \ I didn't want to confuse OP's code with the actual code.\n<|/ c |>\n<| c |>\n\
    Thank you for your comment and editing. I've added the explanation why gsub is\
    \ unnecessary. Could you please take a look again and advise me on how to improve\
    \ this answer?\n<|/ c |>\n<| c |>\n`gsub` is not unnecessary, it's just unreadable.\
    \ `gsub('Hello World!!!', 'Hello!!!Wdlor')` works just fine.\n<|/ c |>\n<| c |>\n\
    I agree that it's unnecessary, but it's also unreadable, and it's even less efficient\
    \ than `gsub`.  I would expect that someone reading this code would have to think\
    \ in order to understand what you're doing, which would take longer than just\
    \ looking up the methods you used.\n<|/ c |>\n<| a tags=string,ruby,algorithm\
    \ |>\nHere is a solution using String#split/Array#sort and String#join:\n<code>",
  "  arr = s.split(' ')\n  arr.map! do |x|\n    x.tr!('a-z', 'z-a')\n    x.tr!('A-Z',\
    \ 'Z-A')\n    x\n  end\n  arr.join(' ')\nend", "  s = s.downcase\n  words=s.split(/\
    \ +/)\n  words=words.sort_by { |word| word.size}.inject([]) do |result,word|\n\
    \    chars=word.split(//)\n    chars=chars.sort_by { |c| c.upcase }.inject([])\
    \ do |result,c|\n      result << c\n    end\n    result << word\n    result <<\
    \ chars\n  end\n  words.join(\" \")\nend\n</cell>\n<cell>", "    sentence = s\n\
    \    sentence.split(' ').sort!.reverse!.join(' ')\nend", "    s = s.split(//)\n\
    \    chars.sort!\n    chars = chars.join\n    s.join!\n    s.join(chars)\nend",
  "  words = s.split \" \"\n  words.each_with_index do |word, index|\n    if index\
    \ > 0 and words[index-1] == word\n      words[index] = words[words.length-1]\n\
    \      words.delete_at(-1)\n    end\n  end\n  words.join(' ')\nend\n</code>\n\
    <|/ a tags=ruby dscore=1 |>\n<| a tags=ruby dscore=1 |>\nFor a solution without\
    \ gems, try this:\n<code>", "  a = s.split(\" \").map(&:downcase).map(&:chars).flatten\n\
    \  a.sort!\n  a.join(\" \")\nend", "  # Solution code here.\n  return s\n</cell>\n\
    <cell>", "    chars = ''\n    words = s.split(\" \")\n    sorted_words = s.split(\"\
    \ \")\n    word_list = []\n    word_list = []\n    word_list = []\n    word_list\
    \ = []\n    chars = ' '\n    chars = ' '\n    chars = ' '\n    chars = ' '\n \
    \   chars = ' '\n    chars = ' '\n    chars = ' '\n    chars = ' '\n    chars\
    \ = ' '\n    chars = ' '\n    chars = ' '\n    chars = ' '\n    chars = ' '\n\
    \    chars = ' '\n    chars = ' '\n    chars = ' '\n    chars = ' '\n    chars\
    \ = ' '\n    chars = ' '\n    chars = ' '\n    chars = ' '\n    chars = ' '\n\
    \    chars = ' '\n    chars = ' '\n    chars = ' '\n    chars = ' '\n    chars\
    \ = ' '\n    chars = ' '\n    chars = ' '\n    chars = ' '\n    chars = ' '\n\
    \    chars = ' '\n    chars = ' '\n    chars = ' '\n    chars = ' '\n    chars\
    \ = ' '\n    chars = ' '\n    chars = ' '\n    chars = ' '\n    chars = ' '\n\
    \    chars = ' '\n    chars = ' '\n    chars = ' '\n    chars = ' '\n    chars\
    \ = ' '\n    chars = ' '\n    chars = ' '\n    chars = ' '\n    chars = ' '\n\
    \    chars = ' '\n    chars = ' '\n    chars = ' '\n    chars = ' '\n    chars\
    \ = ' '\n    chars = ' '\n    chars = ' '\n    chars = ' '\n    chars = ' '\n\
    \    chars = ' '\n    chars = ' '\n    chars = ' '\n    chars = ' '\n    chars\
    \ = ' '\n    chars = ' '\n    chars = ' '\n    chars = ' '\n    chars = ' '\n\
    \    chars = ' '\n    chars = ' '\n    chars = ' '\n    chars = ' '\n    chars\
    \ = ' '\n    chars = ' '\n    chars = ' '\n    chars = ' '\n    chars = ' '\n\
    \    chars = ' '\n    chars = ' '\n    chars = ' '\n    chars = ' '\n    chars\
    \ = ' '\n    chars = ' '\n    chars = ' '\n    chars = ' '\n    chars = ' '\n\
    \    chars = ' '\n    chars = ' '\n    chars = ' '\n    chars = ' '\n    chars\
    \ = ' '\n    chars = ' '\n    chars = ' '\n    chars = ' '\n    chars = ' '\n\
    \    chars = ' '\n    chars = ' '\n", "  \n    words = s.split\n  \n    i = 0\n\
    \    l = -1\n    \n    l = words.size\n  \n    while(i<l)\n      i += 1\n    \
    \  word = words[i]\n      word = word.strip\n      \n      j = i\n      k = l\n\
    \      \n      while(k<l)\n        k = k + 1\n        \n        new_word = word[k]\n\
    \        j = k\n        \n        if(word[j] == ' ')\n          word[j] = new_word\n\
    \        end\n      end\n    end\n    \n    return words.join(\" \")\nend\n</cell>\n\
    <cell>", "  return s.gsub(/(([a-z])\\2)/i) { |s| $1.upcase + $2.downcase }\nend",
  "    arr = []\n    s.split(\" \").each do |word|\n        arr.push(word.chars.sort.join)\n\
    \    end\n    arr.join(\" \")\nend\nprint anti_shuffle(\"Hi\")", "  result = ''\n\
    \  s.split(' ').each do |word|\n    result << word.gsub(/[!.,?;:]/) {|c| c.ord\
    \ + c.ord % 26 }\n  end\n  result\nend", "  l = s.length\n  \n  s.gsub!(/[[:upper:]]/){\
    \ |match| match.downcase }\n  s.gsub!(/[[:lower:]]/){ |match| match.downcase }\n\
    \  s.gsub!(/[[:space:]]/, '')\n  s.gsub!(/\\s+/, ' ')\n  s.downcase!\n  \n  s\
    \ = s[0..(l-1)].split(\" \").sort_by{|s| s.size.to_i}.reverse.join\n  \n  return\
    \ s\nend", "    words = s.split(\" \")\n    words.delete_if{|w| w.length == 0\
    \ }\n    words.sort!{|a,b| a.chars.to_a.sort_by{|c| c.chr}.join}\n    words.join!\"\
    \ \"\nend", "  s = s.gsub(\" \", \"\").gsub(\" \", \"_\")\n  s = s.upcase\n  s\
    \ = s.gsub(\"_\", \" \")\n  s = s.downcase\n  s.gsub!(\"_\", \" \")\n  s.gsub!(\"\
    !\", \" \")\n  s.gsub!(\"?\", \" \")\n  s.gsub!(\",\", \" \")\n  s.gsub!(\".\"\
    , \" \")\n  s.gsub!(\" \", \"_\")\n  s.gsub!(\" \", \"_\")\n  s.gsub!(\" \", \"\
    _\")\n  s.gsub!(\" \", \"_\")\n  s.gsub!(\" \", \"_\")\n  s.gsub!(\" \", \"_\"\
    )\n  s.gsub!(\" \", \"_\")\n  s.gsub!(\" \", \"_\")\n  s.gsub!(\" \", \"_\")\n\
    \  s.gsub!(\" \", \"_\")\n  s.gsub!(\" \", \"_\")\n  s.gsub!(\" \", \"_\")\n \
    \ s.gsub!(\" \", \"_\")\n  s.gsub!(\" \", \"_\")\n  s.gsub!(\" \", \"_\")\n  s.gsub!(\"\
    \ \", \"_\")\n  s.gsub!(\" \", \"_\")\n  s.gsub!(\" \", \"_\")\n  s.gsub!(\" \"\
    , \"_\")\n  s.gsub!(\" \", \"_\")\n  s.gsub!(\" \", \"_\")\n  s.gsub!(\" \", \"\
    _\")\n  s.gsub!(\" \", \"_\")\n  s.gsub!(\" \", \"_\")\n  s.gsub!(\" \", \"_\"\
    )\n  s.gsub!(\" \", \"_\")\n  s.gsub!(\" \", \"_\")\n  s.gsub!(\" \", \"_\")\n\
    \  s.gsub!(\" \", \"_\")\n  s.gsub!(\" \", \"_\")\n  s.gsub!(\" \", \"_\")\n \
    \ s.gsub!(\" \", \"_\")\n  s.gsub!(\" \", \"_\")\n  s.gsub!(\" \", \"_\")\n  s.gsub!(\"\
    \ \", \"_\")\n  s.gsub!(\" \", \"_\")\n  s.gsub!(\" \", \"_\")\n  s.gsub!(\" \"\
    , \"_\")\n  s.gsub!(\" \", \"_\")\n  s.gsub!(\" \", \"_\")\n  s.gsub!(\" \", \"\
    _\")\n  s.gsub!(\" \", \"_\")\n  s.gsub!(\" \", \"_\")\n  s.gsub!(\" \", \"_\"\
    )\n  s.gsub!(\" \", \"_\")\n  s.gsub!(\" \", \"_\")\n  s.gsub!(\" \", \"_\")\n\
    \  s.gsub!(\" \", \"_\")", "  s = s.split(\" \") #split the string into words\n\
    \  s.sort!\n  s.map!{|i| i.downcase} #sort the individual letters of the words\n\
    \  s.join!\" \" #join the words into a string and return\nend\n</code>\n<|/ a\
    \ tags=ruby dscore=1 |>\n<| a dscore=0 |>\nHere is another way of doing it.\n\
    <code>", "  s.split!\n  s.each do |e|\n    s[0...e.length].sort_by!{|x|x.to_i}.join(\"\
    \")\n  end\n  return s\nend", "  # Split string into array of words\n  words =\
    \ s.split(\" \").sort\n  # Return string with words in correct order\n  words.reverse.join\
    \ \" \"\nend\n</code>\n<|/ a |>\n<| c |>\nThanks for the answer! It helped me\
    \ a lot.\n<|/ c |>\n<| a tags=ruby,string |>\nIf you don't care about performance,\
    \ here's an easy to understand solution. \n<code>", "    \n    sorted_s = s.split\n\
    \    \n    sorted_s.reverse!\n    \n    i = 0\n    \n    temp = ''\n    \n   \
    \ sorted_s.each do |word|\n        \n        temp_arr = []\n        \n       \
    \ temp += word\n        \n        temp_arr << (word.count(' ')) ? word.split(\"\
    \ \").sort!.join(' ') : word\n        \n        sorted_s[i] = temp_arr.join(\"\
    \ \")\n        \n        i += 1\n        \n    end\n    \n    return temp\nend",
  "  s.split.map!{ |e| e.split(\" \") }.sort_by! { |e| e.map { |e| e.ord } }.flatten!\n\
    end", "    ans = \"\"\n    s.split(\" \").sort.each do |word|\n        word.split(\"\
    \").sort.each do |letter|\n            ans << letter\n        end\n        ans\
    \ << \" \" if ans.size > 0\n    end\n    return ans\nend", "  s.split(\" \").sort!.each_char.uniq.join\
    \ \" \"\nend", "  s = s.split\n  s.sort_by {|x| x.downcase } \n  s.join\nend",
  "  s.tr!.sort\nend\n</cell>\n<text>\n4.3 Exercise\nWrite a function that takes a\
    \ string as input and returns the same string with characters in reverse order.\n\
    Make sure you preserve the original string in the same variable after modifying\
    \ it in the function.", "  s.split.sort_by { |word| word.chars.sort_by(&:chr).join.to_i\
    \ }.join\nend", "  s.split.sort_by { |a| a.ord }.join\nend", "  s.split(\" \"\
    ).collect { |w| w.gsub(/[a-zA-Z]/) {|x| x.ord }.to_s }.join\nend", "  # split\
    \ string by space\n  word_list = s.split()\n  # create new string\n  new_s = \"\
    \"\n  # traverse word list\n  for word in word_list\n    # split current word\
    \ into characters\n    cur_word_chars = word.split(\" \")\n    # traverse characters\n\
    \    for ch in cur_word_chars\n      # convert ascii value of char to integer\
    \ value\n      ord_ch = ord(ch.encode())\n      # find max ascii value of characters\n\
    \      max_ord = ord_ch + 32\n      # find index of max ascii value\n      max_ord_index\
    \ = cur_word_chars.index(chr(max_ord))\n      # replace current character with\
    \ max ascii value\n      cur_word_chars[max_ord_index] = chr(max_ord)\n    # convert\
    \ cur_word_chars to string\n    cur_word_chars_string = \" \".join(cur_word_chars)\n\
    \    # append current string with converted string\n    new_s += cur_word_chars_string\n\
    \  # return new string\n  return new_s", "  letters = s.split(\" \").map{|w| w.downcase}\n\
    \  letters.sort!\n  letters.join(\" \")\nend", "  return s.downcase.split(' ').sort.join('\
    \ ')\nend\n</cell>\n<cell>", '  puts(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(',
  "\twords = s.split\n\tsorted = words.sort\n\tnew_words = []\n\ti = 0\n\twhile (i\
    \ < words.length)\n\t\tif (words[i] != \"\" || words[i] != \" \")\n\t\t\tnew_words.push(words[i].downcase)\n\
    \t\ti += 1\n\treturn new_words.join(\" \")\nend", "  s.split(//).sort_by{ |e|\
    \ e.ord }.join('')\nend", " \n    # Write your code here\n    \n    word_list=[]\n\
    \    \n    for i in s.split(\" \")\n        word_list.insert(i,\"_\")\n      \
    \  \n    words=\"\"\n    \n    for i in word_list\n        words=words+i\n   \
    \     \n    words=words.lower()\n    \n    new_word_list=list()\n    \n    for\
    \ i in range(len(words)-1,-1,-1)\n        new_word_list.insert(i,words[i])\n \
    \   \n    new_word=\"\"\n    \n    for i in new_word_list\n        new_word=new_word+i\n\
    \    \n    new_word=new_word.lower()\n    \n    return new_word\n        "]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
