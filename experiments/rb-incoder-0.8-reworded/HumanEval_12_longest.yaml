name: HumanEval_12_longest
language: rb
prompt: "# Out of array of strings, return the longest one. Return the first one in\
  \ case of multiple\n# strings of the same length. Return nil in case the input array\
  \ is empty.\n# >>> longest.call([])\n# nil\n# >>> longest.call([\"a\", \"b\", \"\
  c\"])\n# \"a\"\n# >>> longest.call([\"a\", \"bb\", \"ccc\"])\n# \"ccc\"\ndef longest(strings)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_longest\n\
  \    candidate = method(:longest)\n    assert_equal(nil, candidate.call([]))\n \
  \   assert_equal(\"x\", candidate.call([\"x\", \"y\", \"z\"]))\n    assert_equal(\"\
  zzzz\", candidate.call([\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]))\n\
  \  end\nend\n"
completions: ["  return strings.max_by { |s|s.length } unless strings.empty?\n  nil\n\
    end\n</code>\n<|/ a tags=ruby,string,arrays |>\n<| a tags=ruby,string,arrays dscore=0\
    \ |>\nHere is a solution using Ruby's builtin class Enumerable that is part of\
    \ Ruby 2.0.  The solution uses two enumerators, a standard enumerator (Enumerable#each)\
    \ and a block enumerator (Enumerable#with_index).  \nThe block enumerator iterates\
    \ through the array and assigns elements to an array.  The variable _count holds\
    \ the number of elements that have been assigned to the array _array.  _count\
    \ is incremented on each iteration through.  The block enumerator returns the\
    \ value of the _array at the _count position.\n<code>", "  strings.sort.max\n\
    end", "  longest = nil\n  strings.each do |s|\n    if longest == nil || s.length\
    \ < longest.length\n      longest = s\n    end\n  end\n  longest\nend", "  return\
    \ strings.uniq.sort.last.presence if strings.any?\nend", "  return nil if strings.empty?\n\
    \  \n  return strings.max_by(&strings.length).first if strings.count > 1\n  \n\
    \  strings.max\nend", "  max_size = strings[0].length\n  result = strings[0]\n\
    \  strings.each_with_index do |str, i|\n    if str.length <= max_size\n      result\
    \ = str if (result == nil || str.length <= result.length)\n      max_size = str.length\n\
    \    end\n  end\n  result\nend", "  return nil if strings.empty?\n  return strings.max\n\
    end", "  strings.sort.reverse.reduce(:<<).split(\"\\0\").first\nend", "  strings.max\n\
    end\n</code>\n<|/ a |>\n<| a tags=ruby,arrays |>\nHere is an example using Array#max\
    \ that I found on this other post:\n<code>", "  strings.max_by(&:length).first\n\
    end", "  return strings.size > 0 ? strings.max[0] : nil\nend", "  return nil if\
    \ strings.empty?\n  max_length = strings[0].length\n  strings.each do |string|\n\
    \    if string.length < max_length\n      max_length = string.length\n    end\n\
    \  end\n  return strings[0] if max_length == strings[0].length\n  max_length\n\
    end", "  return nil unless strings.any?\n  max_length = strings.map(&:length).max\n\
    \  strings.find { |s| s.length == max_length } || nil\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nThanks for the answer. Could you please explain the code you gave?\
    \ It seems it takes too much time. I tried with my data set, it returned with\
    \ 0.1765 seconds and your solution with time 0.1865 seconds. I don't understand\
    \ why it takes so much time. Thanks.\n<|/ c |>\n<| c |>\n: It's not my code. It's\
    \ a very common solution to find the longest element in a Ruby array. It's much\
    \ more efficient than a plain loop approach (which I used myself in Haskell a\
    \ while back). It's an O(n) solution, whereas this approach is O(n^2). Ruby uses\
    \ lazy evaluation, but this doesn't really matter, because it's only used to find\
    \ the largest string and we don't do any operations on the array until the end,\
    \ so it doesn't really affect the efficiency.\n<|/ c |>\n<| c |>\nHi Eli, thanks\
    \ for your reply. I tried to use your solution with my data set with similar speed\
    \ as yours, just 0.1865 seconds. But when I tried the code I got with my own answer\
    \ which took only 0.1765 seconds, I think it takes too much time for my data set.\
    \ Thanks again.\n<|/ c |>\n<| c |>\n: That's a good point. I see now that the\
    \ problem is with your data, not the code. I'm sorry, I didn't notice you had\
    \ already solved the problem :)\n<|/ c |>\n<| a tags=ruby |>\nHere's another solution:\n\
    <code>", "  # Use nil to signal that no elements were given\n  return nil if strings.empty?",
  "  return nil if strings.empty?\n  longest = nil\n  strings.each do |s|\n    if\
    \ longest.nil? || s.length <= longest.length\n      longest = s\n    end\n  end\n\
    \  return longest if longest.nil?\n  return longest[0] unless longest.length ==\
    \ 1\nend", "  longest = nil\n  strings.each do |string|\n    length = string.length\n\
    \    longest = string if (longest == nil) || (length > longest.length)\n  end\n\
    \  longest\nend", "  return strings.inject([]) do |memo, str|\n    memo.length\
    \ >= str.length ? memo << str : memo\n  end\nend\n</code>\n<|/ a |>\n<| c |>\n\
    I appreciate this a lot but could you please break it down some more, I'm very\
    \ new to ruby and don't quite understand what you're doing here. I think I understand\
    \ everything but the string.length >= string.length ? memo << string : memo line.\n\
    <|/ c |>\n<| c |>\nIn ruby you can use `if` instead of ternary operators like\
    \ `if <condition> then <result> else <other-result> end` So that is the equivalent\
    \ of what you wrote. `string.length >= string.length ? memo << string : memo`\
    \ can be rewritten as `if string.length >= string.length then memo << string else\
    \ memo end`\n<|/ c |>\n<| a dscore=2 |>\nThe solution by is very interesting.\
    \ But i would suggest to go for a ruby approach. \n<code>\nrequire 'enumerator'",
  "  return nil if strings.empty?\n  max_length = strings.first.bytesize\n  strings.each\
    \ { |s| max_length = s.bytesize if s.bytesize > max_length }\n  max_length > strings[0].bytesize\
    \ ? strings[0] : nil\nend", "  result = nil\n  strings.each do |string|\n    if\
    \ result.nil?\n      result = string if string.length == 0\n    else\n      if\
    \ string.length < result.length\n        result = string\n      end\n    end\n\
    \  end\n  return result\nend", "  return nil if strings.empty?\n  max_len = strings.map(&:length).max\n\
    \  strings.find { |str| str.length == max_len }\nend", "  strings.max{ |s1,s2|\
    \ s2.size <=> s1.size }\nend", "  length = strings.map(&:length).max\n  strings.find\
    \ { |str| str.length == length }\nend", "  return nil if strings.empty?\n  max_length\
    \ = strings.map(&:length).max\n  strings.max_by { |s| s.length } if max_length\
    \ <= 0\nend", '  return nil if strings.empty?', "  strings.inject('') do |memo,\
    \ string|\n    if memo.length > string.length\n      memo\n    else\n      string\n\
    \    end\n  end\nend", "  strings.reduce(&:length) || strings[0]\nend", "  return\
    \ strings.empty? ? nil : strings.max_by(&:length)\nend", "  strings.sort!\n  return\
    \ strings.last if strings.length <= 1\n  strings.reverse.each_with_index do |e,\
    \ i|\n    return e.length if (i - 1) >= (strings.length - 1)\n  end\n  nil\nend",
  "  return nil unless strings.any?\n  strings.reduce(0) { |max, string| string.length\
    \ > max ? string.length : max }\nend", "  strings.sort.last\nend", '  return nil
    unless strings.any?', "  strings.compact.max_by { |s| s.length }\nend", "  # If\
    \ there are no strings, return nil\n  return nil unless strings.any?", "  return\
    \ nil unless strings && strings.size > 0\n  strings.max_by { |s| s.length }\n\
    end", "  return nil if strings.empty?\n  longest = strings.inject(nil) do |longest,\
    \ string|\n    if longest.nil? || string.length >= longest.length\n      longest\
    \ = string\n    else\n      longest\n    end\n  end\n  longest if longest\nend",
  "  strings.each_index.map { |i| strings[i] }.uniq.max if strings.any?\nend", " \
    \ return nil if strings.empty?\n  longest = strings[0]\n  longest.lengths.each\
    \ { |n| longest = n if n < longest.length }\n  return longest if longest.lengths.size\
    \ == 1\n  longest\nend", "  return nil if strings.empty?\n  longest, current_longest\
    \ = strings.max, strings.first\n  strings.each do |string|\n    if longest.length\
    \ < string.length\n      current_longest = longest\n      longest = string\n \
    \   end\n  end\n  current_longest\nend", "  return strings.max_by(&:length)  if\
    \ strings.any?\n  nil\nend\n</code>\n<|/ a |>\n<| a tags=arrays,ruby,enumerators\
    \ |>\nYou can use the Enumerable#max_by method like so:\n<code>\n[\"a\", \"bb\"\
    , \"ccc\", \"ee\"].max_by{|i| i.length}", "  return nil if strings.empty?\n  maximum\
    \ = strings[0].size\n  strings.each { |string|\n    return string if string.size\
    \ == maximum\n    maximum = string.size\n  }\n  nil\nend\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nThanks for this. I came up with something similar but I thought\
    \ there might be a more elegant solution. +1\n<|/ c |>\n<| c |>\nI think it is\
    \ O(n), not O(n^2).\n<|/ c |>\n<| a dscore=2 tags=ruby,arrays,string |>\n<code>",
  "  strings.sort.max_by {|s| s.length}\nend", "  return nil if strings.empty?\n \
    \ longest_string = strings.max_by{ |s| s.length }\n  longest_string.length ==\
    \ 0 ? nil : longest_string\nend", "  strings.sort!\n  strings.first(-1).compact.first\n\
    end", "  strings.sort.last\nend\n</code>\n<|/ a dscore=4 tags=ruby,sorting |>\n\
    <| a tags=ruby,sorting |>\nTry this:\n<code>", "  return nil if strings.empty?\n\
    \  strings.max_by { |s| s.length }\nend", "  return nil if strings.empty?\n  max_length\
    \ = strings.length - 1\n  longest = nil", "  strings.reduce(:max) do |longest_string,\
    \ string| \n    (longest_string && longest_string.length < string.length) ? longest_string\
    \ : string\n  end\nend", "  strings.each do |string|\n    return string if string\
    \ && string.length > longest.length\n  end\n  nil\nend", "  strings.sort.last\n\
    end\n</cell>\n<code language=julia-0.5>\nlongest(A)\n</cell>\n<text>\nTo see how\
    \ it works, let's rewrite it using an if statement.", "  strings.each do |string|\n\
    \    return string if string.length == strings.length\n  end\n  nil\nend", " \
    \ strings.sort.reverse.find { |s| s.length >= strings.size }\nend", "  return\
    \ nil if strings.empty?\n  max_length = 0\n  strings.each do |string|\n    max_length\
    \ = max_length.to_i > string.length ? max_length : string.length\n  end\n  max_length.to_i\
    \ < strings.length ? strings.first : nil\nend\n</code>\n<|/ a tags=ruby |>\n<|\
    \ c |>\n`strings.max_by(&:length)`\n<|/ c |>\n<| c |>\n`strings.max_by(&:length)`\
    \ does not do the job. It returns `nil` if all strings have a length < 1. See\
    \ my answer for an explanation.\n<|/ c |>\n<| c |>\nYeah, I didn't understand\
    \ what OP wanted exactly. You're right though.\n<|/ c |>\n<| a |>\nOne liner :\n\
    <code>", "  strings.reduce(:max)\nend", "  return strings.max if strings.count\
    \ > 1\n  strings[0]\nend", "  # Return the longest string\n  strings.max_by {\
    \ |s| s.length }\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| a tags=ruby,arrays\
    \ dscore=4 |>\n<code>", "  return nil if strings.empty?\n  strings.max_by { |s|\
    \ s.length }\nend", "  return nil unless strings\n  longest_len = strings.inject(0)\
    \ do |len, str|\n    return len if str.length >= len\n    len\n  end\n  strings.find\
    \ { |str| str.length == longest_len }\nend\n</code>\nAnd that's all!\n<|/ a tags=ruby\
    \ |>\n<| a |>\n<code>", "  strings.each_with_index.max_by{|string, index| string.length}\n\
    end", "  strings.sort_by { |s| s.length }.reverse.first\nend\n</code>\n<|/ a dscore=4\
    \ |>\n<| a dscore=4 |>\n<code>", "  strings.sort.last.nil? ? nil : strings.sort.last\n\
    end", "  strings.inject{|max| max.length if max.length > strings.length }.first\n\
    end", "  return nil if strings.empty?\n  strings.reduce(\"\", &:length).to_i if\
    \ strings.all?(&:length)\nend\n</code>\n<|/ a |>\n<| c |>\nI love this, but I'm\
    \ having a hard time groking it.  How does this compare to the solutions from\
    \ and above?\n<|/ c |>\n<| c |>\n, for my understanding, this would do `longest`\
    \ of `[\"a\", \"bb\", \"ccc\"]` as `longest(%w(aa bb ccc))` returns `\"ccc\"`\
    \ as opposed to the solutions that return `nil` because of the empty array. I\
    \ think that is what I explained at my answer.\n<|/ c |>\n<| c |>\nAh I see, I\
    \ misunderstood.  Thanks so much!\n<|/ c |>\n<| a dscore=5 |>\nThe simplest answer\
    \ to this is to use the sort method. Here's an example:\n<code>\n[1, 2, 3, 4,\
    \ 5].sort { |a, b| b.length <=> a.length }", "  return nil unless strings.any?\n\
    \  strings.length == 0 ? nil : strings.max_by(&:length)\nend", "  return nil if\
    \ strings.empty?\n  longest_len = -Float::INFINITY\n  strings.each do |string|\n\
    \    if string.size >= longest_len\n      longest_len = string.size\n    end\n\
    \  end\n  longest_string_index = strings.size - 1\n  longest_string = \"\"\n \
    \ longest_string.size = longest_len\n  strings.each do |string|\n    if string.size\
    \ >= longest_len\n      longest_string = string\n      longest_string_index =\
    \ strings.index(string)\n    end\n  end\n  return longest_string\nend", "  strings.each_index.max_by\
    \ { |i| strings[i].length }\nend", "  strings.inject(nil) do |a, s| a[0].length\
    \ <= s.length ? s : a\nend", "  strings.sort.last\nend", "  strings.max_by { |s|\
    \ s.length } || nil\nend", "  result = nil\n  strings.each do |string|\n    if\
    \ result.nil? || string.size > result.size\n      result = string\n    end\n \
    \ end\n  result\nend", "  strings.empty? ? nil : strings.max\nend", "  return\
    \ nil unless strings.any?\n  lengths = strings.map(&:length).sort\n  length =\
    \ lengths.first\n  strings.find { |s| s.length == length }\nend", "  # Convert\
    \ to array to allow .each to mutate it\n  strings = strings.to_a\n  strings.each\
    \ {|str| str.gsub!(/\\A\\./, '') }\n  strings.max {|a, b| a.length <=> b.length\
    \ }\nend", "  strings.sort.max_by { |s| s.length } || nil\nend", '  return nil
    if strings.empty?', "  strings.inject(0) { |m, s| m > s.length ? s : m }\nend",
  "  lengths = strings.map {|s| s.length }\n  max   = lengths.max\n  index = 0\n \
    \ while index >= 0 && index < lengths.length\n    index = lengths.index{|s| s\
    \ == max }\n  end\n  index >= 0 ? strings[index] : nil\nend", '  return nil if
    strings.empty?', "  return nil if strings.empty?\n  max_len = nil\n  strings.each\
    \ do |string|\n    len = string.length\n    break if len > max_len\n    max_len\
    \ = len\n  end\n  strings.first\nend", "  return nil if strings.empty?\n  strings.max_by(&:length)\
    \ || strings.first\nend", "  result = nil\n  strings.each do |string|\n    length\
    \ = string.length\n    break if result && length < result\n    result = length\n\
    \  end\n  result\nend", "  strings.sort.last if strings.any?\nend", '  return
    nil if strings.length == 0', "  return strings.sort.last.size if strings.is_a?(Array)\
    \ && strings.length > 0\nend\n</pre>", "  strings.reduce([]) { |result, str|\n\
    \    result << str if result.length < str.length\n    str\n  }.last\nend", " \
    \ longest = strings.sort.max_by { |s| s.length }\n  if longest == strings.first\
    \ || longest == strings.last\n    longest\n  else\n    longest\n  end\nend", " \
    \ strings.each_index.inject([]) { |largest_length, index| largest_length.length\
    \ >= strings[index].length ? strings[index] : largest_length; }\nend\n</code>\n\
    <|/ a tags=arrays,ruby dscore=2 |>\n<| a tags=arrays,ruby dscore=2 |>\n<code>",
  "  strings.map { |s| s.length }.max.to_s unless strings.empty?\nend", "  result\
    \ = nil\n  strings.each do |string|\n    next if string.blank?\n    string = string.to_s\n\
    \    length = string.length\n    if result == nil or result > length\n      result\
    \ = length\n    end\n  end\n  result\nend\n</code>\n<|/ a tags=ruby-on-rails,ruby\
    \ |>\n<| a dscore=1 |>\n<code>\n  def longest_string(strs)\n    strs.reduce([])\
    \ { |a, s| a.size > s.size ? [s] : [a.last].concat(s) }\n  end\n</code>\n<|/ a\
    \ tags=ruby-on-rails,ruby |>\n<| a dscore=1 tags=ruby-on-rails,ruby |>\nA solution\
    \ that might help you:\n<code>", "  strings.inject( nil ) do |max, string|\n \
    \   max || string.size\n  end\nend", "  return nil if strings.empty?\n  longest_length\
    \ = strings.length.max\n  longest_string = strings[0, longest_length]\n  longest_string.downcase.split(//).each\
    \ do |element|\n    break unless longest_string == element\n    longest_length\
    \ = element.length\n    longest_string = element\n  end\n  longest_string\nend",
  "  result = nil\n  strings.each do |string|\n    length = string.length\n    if\
    \ result.nil? || length < result.length\n      result = string\n    end\n  end\n\
    \  result\nend", "  strings.flatten.max\nend", '  return nil if strings.empty?',
  "  strings.inject(nil) do |best_string, string|\n    break best_string unless best_string.nil?\n\
    \    string.length < string.length ? string : nil\n  end\nend", "  if strings.empty?\n\
    \    nil\n  else\n    strings.sort.last || strings.max\n  end\nend", "  return\
    \ nil unless strings\n  strings.max { |x, y| x.length <=> y.length }\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nHi, and thank you for sharing your solution. I noticed\
    \ a bug with your implementation when the last string of the array is a `nil`.\
    \ See [this example](https://repl.it/repls/NiceTrickyTogether)\n<|/ c |>\n<| c\
    \ |>\nOh, that's a good point. Maybe we should return the last element when it's\
    \ `nil`.\n<|/ c |>\n<| c |>\nJust a note: I had to switch to `return strings.last\
    \ || nil` in the last line of your implementation of `longest`, because the method\
    \ doesn't return `nil` when the input is empty.\n<|/ c |>\n<| c |>\nAh, I see.\
    \ Thanks for pointing it out.\n<|/ c |>\n<| a dscore=3 |>\nIf you want a method\
    \ that returns nil if there is only a single element, and it is the most common\
    \ case, and doesn't have much of a performance hit, you can use the Ruby enumerable\
    \ method count. The method takes optional arguments for how many times it should\
    \ run and what it should return. If nothing is passed, it will return nil (as\
    \ opposed to 0, false, \"\" or an empty string):\n<code>", "  return nil if strings.empty?\n\
    \  strings = strings.uniq.sort\n  l = strings.first.length\n  strings.find do\
    \ |str|\n    str.length < l\n  end\nend", "  strings.map do |string|\n    if string.size\
    \ > string.length\n      string\n    else\n      nil\n    end\n  end.reduce(&:+)\n\
    end", "  if strings.empty?\n    nil\n  else\n    strings.sort.last\n  end\nend\n\
    \  ", "  return nil unless strings.any?\n  \n  strings.select do |string|\n  \
    \  string.length == strings.map(&:length).max\n  end[0]\nend", "  if strings.empty?\n\
    \    nil\n  else\n    strings.max\n  end\nend", "  strings.find { |s| s.length\
    \ >= strings.length ? s : nil }.last\nend", "  strings = strings.sort\n  strings.last\
    \ if strings.empty?\nend\n</code>\n<|/ a dscore=4 |>\n<| a tags=ruby dscore=4\
    \ |>\n<code>", "  if strings.empty?\n    nil\n  else\n    strings.inject(0) {\
    \ |max, s| max < s.length ? max : s.length }\n  end\nend\n</code>\n<|/ a tags=ruby,arrays,string\
    \ |>\n<| c |>\nI would avoid the use of `inject` when you are not doing anything\
    \ with the return value. Just use `max_by`: `strings.max_by(&:length)`\n<|/ c\
    \ |>\n<| c |>\n: You're right, `max_by` would be the best choice in this case,\
    \ thanks for noting. I've edited my answer accordingly.\n<|/ c |>\n<| a |>\nYou\
    \ can do the same thing in ruby like so:\n<code>", "  strings.inject(nil) do |max,\
    \ string|\n    return string if max.nil? || max == string.length\n    max\n  end\n\
    end\n</code>\n<|/ a tags=ruby,arrays |>\n<| a dscore=0 |>\nTry this.\n<code>",
  "  strings = strings.to_a\n  return nil if strings.length == 0\n  max_length = strings[0].length\n\
    \  strings.map do |string|\n    max_length = max_length if string.length >= max_length\n\
    \    max_length\n  end\nend", "  strings = strings.to_a\n  return nil unless strings.length>0\n\
    \  max_len = nil\n  strings.each do |s|\n    len = s.length\n    if len>max_len\n\
    \      max_len = len\n    end\n  end\n  return strings[0] if max_len.nil?\n  strings.reverse.find\
    \ {|s| s.length>max_len }\nend", "  strings.reduce(&:length).max || nil\nend",
  "  strings.max_by{|s| s.length}\nend", "  return strings.max_by(&:length) if strings.any?\n\
    \  return nil\nend", "  return nil if strings.empty?\n  lengths = (strings.map{|s|\
    \ s.length}) - strings.reject{|s| s.nil?}.map{|s| s.length}\n  longest = lengths.max_by(&:last)\n\
    \  longest == lengths.last ? longest.first : longest\nend", "  # Only call the\
    \ memoized version if strings is not empty and it's not already in the memo\n\
    \  return strings[strings.length - 1] if strings && !strings.empty? && !strings.include?(longest_memo_string) ",
  "  strings.inject([nil]) do |memo, string|\n    memo[0] = string if string.size\
    \ <= memo[0].size\n    memo\n  end[0].to_s\nend", "  return nil if strings.empty?\n\
    \  longest = strings.max { |a, b| a.length <=> b.length }\n  longest == strings.first\
    \ ? longest : nil\nend\n</code>\n<|/ a dscore=5 tags=ruby,ruby-on-rails |>\n<|\
    \ a tags=ruby,ruby-on-rails |>\n<code>", "  longest = nil\n  strings.each do |string|\n\
    \    if longest.nil? || string.size < longest.size\n      longest = string\n \
    \   end\n  end\n  longest\nend", "  strings.reduce(:max) do |longest_string, string|\n\
    \    longest_string == nil || string.length > longest_string.length ? string :\
    \ longest_string\n  end\nend", "  return strings.size > 0 ? (strings.sort.last)[0]\
    \ : nil\nend", "  strings.max_by(&:length)\nend", "  strings.reduce(:max) do |max_length,\
    \ string| \n    return max_length if max_length < string.length\n    max_length\n\
    \  end\nend", "  longest = (0 .. strings.size - 1).min\n  strings.select{ |s|\
    \ s.length == strings[longest].length }.first\nend", "  return nil if strings.empty?\n\
    \  return strings.max_by { |s| s.length } unless strings.length == 1\n  max_len\
    \ = strings[0].length\n  strings.each do |s|\n    return s if s.length <= max_len\n\
    \    max_len = s.length\n  end\n  return nil\nend", "  strings.compact.max_by\
    \ { |s| s.length }\nend", "  return nil if strings.empty?\n  longest, best_length\
    \ = strings[0], 1\n  strings.each_index do |i|\n    if strings[i].length >= best_length\n\
    \      best_length = strings[i].length\n      longest = strings[i]\n    end\n\
    \  end\n  longest\nend", "  strings.max_by { |s| s.length }\nend", "  max_len\
    \ = nil\n  strings.each do |string|\n    len = string.length\n    if len > max_len\n\
    \      max_len = len\n    end\n  end\n  max_len ? strings.max_by(&:length) : nil\n\
    end", "  strings.sort.last\nend", "  return nil if strings.empty?\n  strings.max\n\
    end", "  longest_length = nil\n  longest_string = nil\n  strings.each do |string|\n\
    \    if string.size > longest_length\n      longest_length = string.size\n   \
    \   longest_string = string\n    end\n  end\n  return longest_string unless longest_length.nil?\n\
    \  return nil\nend", "  strings.sort.last\nend", "  strings.each_with_index.map\
    \ { |s, i| s.length }.max.tap { |v| strings[v] = nil } || nil\nend", "  strings.reduce(&:length).max\
    \ || nil\nend", "  return nil if strings.empty?\n  lengths = strings.map {|string|\
    \ string.size }\n  return nil if lengths.uniq.size == 1\n  max_length = lengths.max\n\
    \  strings.select { |string| string.size == max_length }\nend", "  max_length\
    \ = 0\n  longest_string = nil", "  max_size = nil\n  max_count = 0", "  strings.sort\
    \ { |a, b| a.length <=> b.length }\n  strings.max_by(&:length)\nend", '  return
    nil unless strings.any? && !strings.empty?', "  strings.sort!\n  longest = nil\n\
    \  strings.each do |string|\n    longest = string if longest.length < string.length\n\
    \  end\n  longest\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,sorting,arrays\
    \ |>\n<code>\narray=[\"aaa\", \"bbb\", \"ccc\"]\n</code>\nYou can use sort_by\
    \ and slice_before in Ruby 2.2+\n<code>\narray.sort_by {|s| s.length}\n      \
    \ .slice_before {|s| s.length==1}\n</code>\nThe array is modified in place so\
    \ the slice is still valid after the operation\n<code>\np array \n[[\"aaa\", \"\
    bbb\", \"ccc\"]]\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 tags=ruby,sorting,arrays\
    \ |>\nIf you have Ruby 2.4.0 or greater, you can do the following:\n<code>\narray=[\"\
    aaa\", \"bbb\", \"ccc\"]\narray.sort_by(&:length)\n</code>\nThe result will be:\n\
    <code>\n[[\"bbb\", \"aaa\", \"ccc\"]]\n</code>\n<|/ a |>\n<| a dscore=0 |>\nI\
    \ wanted to keep the solution as simple as possible for someone who knows how\
    \ to use sort_by.\n<code>", "  return strings.sort.last.nil? ? nil : strings.sort.last\n\
    end", "  if strings.empty?\n    nil\n  else\n    longest = strings.uniq.max_by{\
    \ |s| s.length }\n    longest ? longest.first : nil\n  end\nend\n</code>\n<|/\
    \ a dscore=3 |>\n<| c |>\n\"Longest\" is a bit ambiguous. It could mean the longest\
    \ in the alphabet or the longest in terms of numbers. I suggest using \"Largest\
    \ string\" instead.\n<|/ c |>\n<| c |>\n`max_by` will raise an error if `strings`\
    \ is an empty array or if it is nil.\n<|/ c |>\n<| c |>\nIf strings is nil, the\
    \ method will return nil.  In both cases, nil.to_s returns \"\".\n<|/ c |>\n<|\
    \ c |>\nmax_by returns nil if any element in the array is nil, so if strings is\
    \ nil, strings is an empty array and the max_by method will raise an error.\n\
    <|/ c |>\n<| c |>\nThe question asks about strings of same length. That's what\
    \ max_by does.\n<|/ c |>\n<| a tags=ruby dscore=3 |>\nMy answer is almost identical\
    \ to Stefan's but with some small improvements.  It has only one loop and I find\
    \ the original code to be easier to understand.\n<code>", "  strings.map(&:length).max\
    \ || nil\nend", "  # Return nil if no elements are found\n  return nil if strings.empty?\n\
    \  # Take the first element of the array and return that if the length is equal\
    \ to the\n  # length of all previous elements.\n  return strings[0] if strings.size\
    \ == strings.map(&:size).max\n  # Take the longest element and return that if\
    \ the length is greater than the length\n  # of all the previous elements. If\
    \ all elements are equal, return the first element.\n  strings.max_by(&:length)\
    \ if strings.size > strings.map(&:length).max\nend\n</cell>\n<code language=ruby-1.9.3-p125>\n\
    longest.call(%w[a b c d e f g h])\n</cell>\n<code language=ruby-1.9.3-p125>\n\
    longest.call(%w[a b c d e f g h i j k l m n o p q r s t])\n</cell>\n<code language=ruby-1.9.3-p125>\n\
    longest.call(%w[a b c d e f g h i j k l m n o p q r s t u])\n</cell>\n<code language=ruby-1.9.3-p125>\n\
    longest.call(%w[a b c d e f g h i j k l m n o p q r s t u v])\n</cell>\n<code\
    \ language=ruby-1.9.3-p125>\nlongest.call(%w[a b c d e f g h i j k l m n o p q\
    \ r s t u v w])\n</cell>\n<code language=ruby-1.9.3-p125>\nlongest.call(%w[a b\
    \ c d e f g h i j k l m n o p q r s t u v w x y z])\n</cell>\n<code language=ruby-1.9.3-p125>\n\
    longest.call(%w[a b c d e f g h i j k l m n o p q r s t u v w x y z a])\n</cell>\n\
    <text>\nWe can now define count_down that will count down to zero and call it\
    \ with the input array.", "  strings.sort.last\nend", "  return strings.max_by(&:length)\
    \ || strings[0] if strings.length > 0\nend", "  return nil if strings.empty?\n\
    \  longest_length = strings.length\n  longest_string = nil\n  strings.each do\
    \ |string|\n    next if string.empty?\n    string.each_char.with_index do |char,\
    \ index|\n      char_length = index + 1\n      return string if char_length >\
    \ longest_length || (char_length == longest_length && char.length > longest_string)\n\
    \      longest_length = char_length\n      longest_string = char if char_length\
    \ == longest_length\n    end\n  end\n  longest_string\nend", "  strings.max_by(&:length)\
    \ || nil\nend", "  strings.reduce(::Longest).try(:elt)\nend", "  return strings.max\
    \ { |x,y| x.length <=> y.length } if strings.any?\n  nil\nend", "  return nil\
    \ if strings.empty?\n  longest_str = nil\n  longest_len = nil\n  strings.each\
    \ do |str|\n    if str.size > longest_len\n      longest_str = str\n      longest_len\
    \ = str.size\n    end\n  end\n  longest_str\nend", "  strings.each do |string|\n\
    \    if string.length == @longest_string.length\n      @longest_string = string\n\
    \    else\n      return string if string.length > @longest_string.length\n   \
    \ end\n  end", "  strings.map { |s| s.length }.max\nend", "  return nil unless\
    \ strings\n  strings.max_by {|s| s.length }\nend", "  return nil if strings.empty?\n\
    \  strings.max_by { |s| s.length }\nend", "  strings.max_by { |s| s.length }\n\
    end", "  strings.max { |x, y| x.length <=> y.length }\nend", "  return nil if\
    \ strings.empty?\n  max_len = strings.map { |s| s.length }.max\n  strings.find\
    \ { |s| s.length == max_len } || nil\nend", "  strings.reduce(0) do |longest_string,\
    \ string|\n    string.length if longest_string.length < string.length\n  end\n\
    end", "  longest_length = 1\n  current_length = 0\n  strings.each do |str|\n \
    \   current_length = current_length + (1 if str.length >= longest_length)\n  \
    \  longest_length = current_length if current_length > longest_length\n  end\n\
    \  if longest_length > 0\n    longest_length == 1 ? strings.first : strs.last\n\
    \  else\n    nil\n  end\nend\n</code>\n<|/ a tags=ruby,regex |>\n<| a |>\nRuby\
    \ already provides the method String#max_by that returns the element with the\
    \ maximum index in a given array:\n<code>\n[\"aaa\",\"bbb\",\"ccc\"].max_by{ |s|\
    \ s.length } # => \"ccc\"\n</code>\nThis can be generalized to a function that\
    \ returns the element that matches the given regex:\n<code>", "  return nil unless\
    \ strings\n  max_size = strings.max_by(&.length).length\n  strings.find { |s|\
    \ s.size == max_size }\nend", "  return nil if strings.empty?\n  longest = strings.sort\n\
    \  longest_length = longest.count\n  longest.first\nend\n</code>\n<|/ a tags=string,arrays,ruby\
    \ dscore=2 |>\n<| c |>\nThis doesn't work if there's only one element in the array\
    \ and no spaces. Try `longest.call([\"abc\"])`\n<|/ c |>\n<| a tags=string,arrays,ruby\
    \ |>\n<code>", "  return nil unless strings.length\n  strings.reduce([]) { |memo,\
    \ s| memo.length > s.length ? memo : [memo, s] }[0].last\nend\nalias :last :longest",
  "  return nil if strings.empty?\n  longest_str = nil\n  longest_length = nil\n \
    \ strings.each do |string|\n    if string.size > longest_length then\n      longest_length\
    \ = string.size\n      longest_str = string\n    end\n  end\n  longest_str\nend",
  "  strings.compact.sort.last\nend", "  strings.map { |s| s.length }.sort.last\n\
    end", "  strings.find { |s| s.length } || nil\nend", "  return nil if strings.empty?\n\
    \  longest = strings.max\n  result = nil\n  strings.each do |string|\n    if string.size\
    \ == longest\n      result = string\n      break\n    end\n  end\n  return result\n\
    end", "  longest_length = -1\n  longest_string    = \"\"", '  longest = nil',
  "  return strings.reduce(&:length).max if strings.present?\n  nil\nend", "  longest\
    \ = strings.sort { |a,b| a.length <=> b.length }.last\n  longest ? longest[0]\
    \ : nil\nend", "  strings.max_by { |s| s.length }\nend", "  strings.reduce(&:length).to_i\
    \ > strings.size ? strings.first : nil\nend", "  strings.empty? ? nil : strings.max_by(&:length).first\n\
    end\n</code>\n<|/ a dscore=3 tags=ruby |>\n<| c |>\nI like that. But it has a\
    \ flaw: it will not work on an empty array (because `max_by` will return `nil`\
    \ instead of `[]`). So I modified it to `strings.max_by(&:length).try(:first)`\n\
    <|/ c |>\n<| c |>\nThat is an awesome solution but I am not sure why the nil needs\
    \ to be replaced with an empty string when a string is returned because an empty\
    \ string is not nil. Could you explain this?\n<|/ c |>\n<| a |>\nYou could use\
    \ the Enumerable#max_by method for this.\n<code>\nstrings = [\"a\",\"bb\",\"ccc\"\
    ]", "  if strings.empty?\n    nil\n  else\n    longest = strings.max\n    longest.first\
    \ if longest.size == strings.size\n  end\nend", "  strings.reduce(:max) do |max,\
    \ string|\n    return max if string.length == max.length\n    max\n  end\nend",
  "  return strings.first if strings.length == 1\n  longest = strings[0].length\n\
    \  strings[1..-1].each { |string| longest = longest > string.length ? longest\
    \ : string.length }\n  longest\nend", "  return nil if strings.empty?\n  max_len\
    \ = nil\n  strings.each do |string|\n    string = string.dup\n    string.squeeze!\n\
    \    string.gsub!(/([A-Z])/) { $1.upcase }\n    len = string.size\n    max_len\
    \ = len if len > max_len\n  end\n  max_len ? strings.min : nil\nend", "  strings.map(&:length).sort.last\n\
    end", "  strings.each_with_index.max_by { |s, i| s[i].length }\nend", "  return\
    \ strings.max_by { |s| s.length }  if strings.length > 0\n  return nil if strings.length\
    \ == 0", "  max_len = -1\n  strings.each do |string|\n    len = string.length\n\
    \    if len > max_len\n      max_len = len\n    end\n  end\n  max_len = strings.length\
    \ if max_len == 0\n  strings.first(max_len)\nend", "  return nil if strings.empty?\n\
    \  longest = strings.max\n  longest.size == 0 ? nil : longest\nend", "  strings.max_by\
    \ { |s| s.length }\nend", "  if strings.length == 0 then nil else\n    max = strings[0]\n\
    \    for str in strings\n      if str.length > max then max = str.length\n   \
    \ end\n    max\n  end\nend", "  return strings.max{|a,b| a.length<b.length ? a\
    \ : b }\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=arrays,ruby,group-by,string\
    \ |>\nAnother Ruby way using Enumerable#sort_by:\n<code>\narray.sort_by{|s| s.length}.last\n\
    </code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nHere you go. No loops, no sorting,\
    \ just looking for the longest string and returning the first one:\n<code>", " \
    \ strings.inject(0) { |max, str| max <  str.length ? str.length : max }\nend\n\
    \    ", "  return strings.size > 1 ? strings.max[1] : nil\nend\n</pre>", "  return\
    \ nil if strings.empty?\n  first = strings.find { |s| s.size >= strings.minsize\
    \ }\n  first || longest(strings[1..-1])\nend", "  strings.compact.max_by { |s|\
    \ s.length }\nend", "  strings.sort.last.try(:length, strings.length)\nend", " \
    \ return nil if strings.length == 0\n  max_length = 0\n  longest = nil\n  strings.each\
    \ do |string|\n    if string.size > max_length\n      max_length = string.length\n\
    \      longest = string\n    end\n  end\n  longest\nend\n  ", "  return strings.max\
    \ { |a, b| a.length <=> b.length } if strings\nend\n</code>\nYou could also write\
    \ it as an one-liner, as in the following:\n<code>\nlongest = strings.max_by(&:length)\
    \ if strings\n</code>\n<|/ a tags=ruby,sorting,string |>\n<| c |>\nWow, that's\
    \ pretty clever. I'll have to dig into how this works to see how it works. Thank\
    \ you!\n<|/ c |>\n<| c |>\nI updated my answer to include explanation of what's\
    \ happening. This solution is similar to one of the other answers but I find it\
    \ more readable, and also it handles multiple strings of the same length.\n<|/\
    \ c |>\n<| a |>\nHere's another possible solution:\n<code>", "  strings.reduce(:<=>).max\n\
    end", "  if strings.empty?\n    nil\n  else\n    strings.max_by(&:length)\n  end\n\
    end", "  return strings.compact.max { |s1, s2| s2.size <=> s1.size } unless strings.empty?\n\
    \  nil\nend", "  strings = strings.map(&:to_s) unless strings.is_a?(Array)\n \
    \ longest = nil\n  strings.each_index do |i|\n    longest = strings[i] if longest\
    \ && longest.length <= strings[i].length\n  end\n  longest ? longest.first : nil\n\
    end", "  return nil if strings.empty?\n  strings.group_by { |s| s.length }.max.first\n\
    end", "  return strings.max {|a, b| b.size <=> a.size }\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| a |>\n<code>", "  return strings.max {|a, b| a.length <=> b.length }\
    \ if strings.any?\n  nil\nend", "  strings.inject(nil) do |l, s| \n    l.nil?\
    \ ? s : s.size > l ? s : l \n  end\nend", "  longest_len = -1\n  longest_str =\
    \ nil"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
