name: HumanEval_36_fizz_buzz
language: rb
prompt: "# Return the number of times the digit 7 appears in integers less than n\
  \ which are divisible by 11 or 13.\n# >>> fizz_buzz.call(50)\n# 0\n# >>> fizz_buzz.call(78)\n\
  # 2\n# >>> fizz_buzz.call(79)\n# 3\ndef fizz_buzz(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fizz_buzz\n\
  \    candidate = method(:fizz_buzz)\n    assert_equal(0, candidate.call(50))\n \
  \   assert_equal(2, candidate.call(78))\n    assert_equal(3, candidate.call(79))\n\
  \    assert_equal(3, candidate.call(100))\n    assert_equal(6, candidate.call(200))\n\
  \    assert_equal(192, candidate.call(4000))\n    assert_equal(639, candidate.call(10000))\n\
  \    assert_equal(8026, candidate.call(100000))\n  end\nend\n"
completions: ["  return unless n.is_a?(Fixnum)\n  case n.modulo(11)\n  when 7\n  \
    \  yield \"Fizz\"\n  when 11\n    yield \"Buzz\"\n  else\n    yield n.to_s\n \
    \ end\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nNice solution (but I don't like\
    \ that it requires passing in a `block`), but could you please explain why `yield\
    \ n` instead of `yield n.to_s`?\n<|/ c |>\n<| c |>\n: That's a very good question.\
    \ It's not immediately obvious that `yield.to_s` works, but `yield n` returns\
    \ `n` (the return value of the block) and `yield n.to_s` returns `n.to_s` (the\
    \ return value of the `to_s` method). So `yield n` works, but not `yield n.to_s`.\n\
    <|/ c |>\n<| c |>\nThanks for explaining. :)\n<|/ c |>\n<| a dscore=1 |>\n<code>",
  "    divisible_by_11 = n % 11 == 0\n    divisible_by_13 = n % 13 == 0\n    count\
    \ = 0", "  return (n%11==0) || (n%13==0)? 0 : n\nend", "  count=0\n  (1...n).each\
    \ do |i|\n    if i%11==0 || i%13==0\n      count+=1\n    end\n  end\n  count\n\
    end", "  while n > 0 do\n    case n % 11 when 0 then return 0\n              \
    \   when 1 then return 1\n                 when 2 then return 2\n            \
    \     when 3 then return 3\n                 when 4 then return 4\n          \
    \       when 5 then return 5\n                 when 6 then return 6\n        \
    \         when 7 then return 7\n                 when 8 then return 8\n      \
    \           when 9 then return 9\n                 else return n\n    end\n  \
    \  n = n / 11\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nThanks, I am still new\
    \ to Ruby. Would you mind elaborating a bit? It seems that there is an infinite\
    \ loop in this code.\n<|/ c |>\n<| c |>\nYes, there is a problem with the code\
    \ as you pointed out, and it is an infinite loop. The solution below uses `while`\
    \ instead of `until`.\n<|/ c |>\n<| a |>\nI solved this problem with recursion:\n\
    <code>", "  result = 1\n  if n % 11 == 0\n    result = result + 1\n  if n % 13\
    \ == 0\n    result = result + 1\n  return result\nend", "  n <= 0 ? 0 : n % 11\
    \ == 0 ? n / 11 : n % 13 == 0 ? n / 13 : 0\nend\n</pre>", "  return n.times.reduce(0){|memo,\
    \ i| memo + 1 if ((i / 11).zero?) && ((i / 13).zero?) }\nend", "  if n <= 0\n\
    \    p 1\n  else\n    p 0\n  end", "  return n.zero? ? 0 : n & 1 == 0 ? 0 : n\
    \ & 2 == 0 ? 1 : n & 4 ? 2 : n & 8 ? 3 : n & 16 ? 4 : n & 32 ? 5 : n & 64 ? 6\
    \ : n & 128 ? 7 : n & 256 ? 8 : n & 512 ? 9 : 10\nend", "  divisors = 0..11 |\
    \ 13\n  puts \"0\"\n  divisors.each { |i|\n    if (i % 11 == 0) && !(i % 13 ==\
    \ 0)\n      puts i\n    elsif (i % 13 == 0)\n      puts \"#{n}#{i}\"\n    end\n\
    \  }\n  puts \"#{n}#{n}\"\nend", "  (if (= (rem n 3) 0)\n    (if (= (rem n 7)\
    \ 0)\n      (if (= (rem n 11) 0)\n        (if (= (rem n 13) 0)\n          0\n\
    \          (+ 1 (fizz_buzz (rem n 11)))\n        )\n        (+ 1 (fizz_buzz (rem\
    \ n 13)))\n      )\n      (+ 1 (fizz_buzz (rem n 7)))\n    )\n    (+ 1 (fizz_buzz\
    \ (rem n 3)))\n  )\nend\n</code>\n<|/ a tags=fizzbuzz,fizzler,erlang,recursion,tail-recursion\
    \ |>\n<| c |>\nThis is more a comment than an answer so I cannot really see why\
    \ it's being voted down\n<|/ c |>\n<| c |>\nIt's not exactly a comment, this is\
    \ an answer so I can see why you downvoted it.\n<|/ c |>\n<| c |>\nIt's a comment\
    \ because it does not answer the original question, which is why it's not an answer.\n\
    <|/ c |>\n<| c |>\nI guess my point is that an answer could be: \"this answer\
    \ is correct, the original question was wrong\" and the answer would be \"yes,\
    \ it's a correct answer, the original question was wrong\", which clearly wouldn't\
    \ be an answer.\n<|/ c |>\n<| a dscore=1 |>\nThe first example of your code is\
    \ the simplest example of tail-recursion. Consider the following loop:\n<code>\n\
    Fizz_Buzz(0) ->\n  io:format(\"Fizz_Buzz: ~p~n\",[]),\n  ok;\nFizz_Buzz(N) ->\n\
    \  case N of\n    0 ->\n      io:format(\"Fizz_Buzz: ~p~n\",[]),\n      ok;\n\
    \    1 ->\n      io:format(\"Fizz_Buzz: ~p~n\",[]),\n      ok;\n    _ ->\n   \
    \   Fizz_Buzz(N-1),\n      io:format(\"Fizz_Buzz: ~p~n\",[N]),\n      ok\n  end.\n\
    </code>\nThe function Fizz_Buzz/1 does not call itself anywhere within the loop.\
    \ Its definition does not call itself, and it certainly does not call any other\
    \ functions. All it does is define an operation. It does not call anything else.\
    \ \nThe looping happens inside the function that calls the Fizz_Buzz/1 function.\
    \ The function Fizz_Buzz/1 itself is tail-recursive. ", "  (n / 11.0).ceil.should\
    \ == 0\n  (n / 13.0).ceil.should == 0\n  (n % 11.0).should == 0\n  (n % 13.0).should\
    \ == 0\n  (n.to_s.match(/7\\z/)).should == nil\nend\n</code>\n<|/ a tags=ruby,regex\
    \ |>\n<| c |>\n\"a number is divisible by 11 or 13\" - what about `42` which is\
    \ not divisible by either `11` or `13`?\n<|/ c |>\n<| c |>\nIt's true, but I thought\
    \ that only numbers divisible by 11 or 13 would be FizzBuzz. :)\n<|/ c |>\n<|\
    \ c |>\nSorry, I misread your answer (it would be more correct to say \"...which\
    \ are divisible by 11 **or** 13\") before I read your answer. :)\n<|/ c |>\n<|\
    \ c |>\nThe `/.../` regexp has one group and one group is `7`. So, `/7/` should\
    \ be written as `/7\\z/`. Not sure if this is what OP intended.\n<|/ c |>\n<|\
    \ c |>\nI thought that would work too, but I found that if I use either `/7/`\
    \ or `/7\\z/` I lose the last digit of the string for some reason. If I do `/7\\\
    z/` I get the last digit, but `/7/` does not.\n<|/ c |>\n<| a dscore=0 |>\n<code>",
  "  n % 11 == 0 && n % 13 == 0 ? 0 : 1\nend\n</code>\nYou can now use your new function\
    \ like this\n<code>\nfizz_buzz.call(50)\n</code>\n<|/ a |>\n<| a dscore=0 tags=ruby\
    \ |>\nYou can define it like this\n<code>", "  ((n // 11) * 11) + ((n // 13) *\
    \ 13)\nend", "  if n <= 11\n    return 0\n  if n <= 13\n    return 1\n  if n %\
    \ 11 == 0\n    return fizz_buzz(n / 11) + 2\n  if n % 13 == 0\n    return fizz_buzz(n\
    \ / 13) + 3\nend", "  n = n.to_i\n  (n == 7).times {|i| (i % 11 == 0) ? (i % 13\
    \ == 0 ? \"B\" : \"F\") : \"\" }\nend\n</code>\n<|/ a tags=ruby,string |>\n<|\
    \ c |>\nNice! Just a small suggestion: `n % 11 == 0 ? (n % 13 == 0 ? \"B\" : \"\
    F\") : \"\"` can be written `n % 11 == 0 ? n % 13 == 0 ? \"B\" : \"F\" : \"\"\
    `\n<|/ c |>\n<| c |>\nThanks everyone. I've been learning a lot about Ruby and\
    \ this was a great exercise.\n<|/ c |>\n<| a tags=ruby,string dscore=0 |>\nHere's\
    \ a fun way to do it.\n<code>", "  (0..(n-1)).find { |i| (i % 11) == 0 || i /\
    \ 13 == i / 11 } + 0\nend", "  i = 0\n  while i < n\n    j = i\n    while j >\
    \ 0\n      if j % 11 == 0 or j % 13 == 0\n        j /= 11\n        i += 1\n  \
    \    else\n        j /= 13\n        i += 1\n      end\n    end\n    if i % 11\
    \ == 0 or i % 13 == 0\n      i += 11\n    end\n  end\n  i\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nI like your answer. It's a good solution that also solves the other\
    \ issue I had with the fizzbuzz problem.\n<|/ c |>\n<| c |>\nI haven't been able\
    \ to get the second example to work but the first one works great and is very\
    \ clean.\n<|/ c |>\n<| c |>\n`return i` should be `i += 1` in the fizz buzz function.\n\
    <|/ c |>\n<| c |>\nI got it working. I'm going to edit your answer to show it.\n\
    <|/ c |>\n<| c |>\nI have no idea why `return i` would be a problem. It returns\
    \ the number of integers in `i` that are divisible by 11 or 13.\n<|/ c |>\n<|\
    \ a tags=ruby |>\n<code>", "  return n if n.modulo(11).zero? or n.modulo(13).zero?\
    \ else fizz_buzz(n.divide(11).add(13))\nend", "  return n if n % 11 == 0 or n\
    \ % 13 == 0 else fizz_buzz(n / 11) + fizz_buzz(n / 13)\nend", "  count = 0\n \
    \ if n <= 0\n    count = 0\n  elsif n % 11 == 0\n    count += 1\n    elsif n %\
    \ 13 == 0\n      count += 1\n    end\n    count\n  else\n    count\n  end\nend\n\
    </code>\n<|/ a dscore=2 tags=ruby,fizzbuzz |>\n<| a dscore=1 |>\nI wanted to see\
    \ what other folks said, so I threw together a little test app to see how they\
    \ compared.  I came up with some pretty obvious wins over the 'brute force' approach.\n\
    <code>", "  return if n % 11 == 0 or n % 13 == 0\n  i = (n%11 + n%13 + 7) % 19\n\
    \  while i\n    i % 11 == 0 and i % 13 == 0\n    i = ((i % 11 + 7) % 19 + i) %\
    \ 19\n  return i\nend\nputs fizz_buzz(50)\nputs fizz_buzz(78)\nputs fizz_buzz(79)\n\
    puts fizz_buzz(121)\nputs fizz_buzz(123)\nputs fizz_buzz(125)\n</code>\n<|/ a\
    \ dscore=3 |>\n<| c |>\nWhile this link may answer the question, it is better\
    \ to include the essential parts of the answer here and provide the link for reference.\
    \  Link-only answers can become invalid if the linked page changes. - [From Review](/review/low-quality-posts/12476632)\n\
    <|/ c |>\n<| c |>\nThanks for the suggestion. I've included a code snippet\n<|/\
    \ c |>\n<| c |>\nThe question is not about a coding problem but about the algorithmic\
    \ problem. The algorithm in the question has been proven by the author and his\
    \ fellow students. It is as close to an exhaustive search as possible and thus\
    \ is a valid answer. Having said that, it's great to see that the author is aware\
    \ of such a search and provides the right answer.\n<|/ c |>\n<| c |>\nThanks for\
    \ your great effort for this problem, it would be nice to see some explanations\
    \ as well. :)\n<|/ c |>\n<| a |>\nThe solution by is great, but has a minor bug\
    \ that causes it to print wrong answer if the number is 0.\n<code>", "  # Return\
    \ the number of times the digit 7 appears in integers less than n which are divisible\
    \ by 11 or 13.\n  if n<=10 then\n    return 0\n  elsif n<=100 then\n    return\
    \ 1 if n % 11 == 0\n  else\n    return 1 if n % 13 == 0\n  end\nend", "  if n\
    \ % 11 == 0 ||  n % 13 == 0\n    return \"#{n}\".scan(/7/).length\n  end\nend",
  "  return ((n - ((n / 10) % 11)) / 11).to_i\nend", "  n = n.to_i\n  count = 0\n\
    \  n.times do |x|\n    if x % 11 == 0 || x % 13 == 0\n      count += 1\n    end\n\
    \  end\n  count\nend", "  n%11==0 ? puts \"#{n} is a multiple of 11\" : n%13==0\
    \ ? puts \"#{n} is a multiple of 13\" : puts n\nend\nfizz_buzz.call(50)\nfizz_buzz.call(78)\n\
    fizz_buzz.call(79)", "  return 0 if n == 0 else 1 if n % 11 == 0 and n % 13 ==\
    \ 0 else 2\nend", "  if n<10 or n%11==0 or n%13==0:\n    return n\n  i=n.to_i\n\
    \  return i%7==0 and i%11==0 or i%13==0 and i%11==0", "  return number_digits_less_than(n,\
    \ 11, 13).count(7)\nend", "    if n < 11 or n > 67\n        return n\n    count\
    \ = 0\n    while n > 0\n        if n % 11 == 0\n            count += 1\n     \
    \       if n % 13 == 0\n                count += 1\n        n /= 10\n    return\
    \ count\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis is what I was looking for\
    \ but did not know how to use the code block.  Thanks!\n<|/ c |>\n<| a dscore=0\
    \ tags=ruby |>\nIt may be worth mentioning that Ruby has several built-in functions\
    \ for this purpose which are far more efficient than any of your solutions:",
  "  return 0 if n < 0 else (n % 11 == 0 and n % 13 == 0) ? 0 : fizz_buzz.call(n-1).call(n\
    \ / 11).call(n / 13).call(0)\nend", "  count = 0\n  x = n\n  while x > 1\n   \
    \ if x % 11 == 0\n      count += 1\n    x /= 11\n    if x % 13 == 0\n      count\
    \ += 1\n    x /= 13\n  end\n  count\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby\
    \ |>\n<code>", "  return n.zero? ? 0 : 1+ (n%11==0||n%13==0 ? 0 : fizz_buzz(n/10)*fizz_buzz(n/10))\
    \ \nend", "  return n.times.map {\n    0 => 0,\n    1 => 1,\n    2 => 2,\n   \
    \ 3 => 3,\n    4 => 4,\n    5 => 5,\n    6 => 6,\n    7 => 7,\n    8 => 8,\n \
    \   9 => 9,\n    10 => 10,\n    11 => 11,\n    12 => 12,\n    13 => 13,\n    14\
    \ => 14,\n    15 => 15,\n    16 => 16,\n    17 => 17,\n    18 => 18,\n    19 =>\
    \ 19,\n    20 => 20,\n    21 => 21,\n    22 => 22,\n    23 => 23,\n    24 => 24,\n\
    \    25 => 25,\n    26 => 26,\n    27 => 27,\n    28 => 28,\n    29 => 29,\n \
    \   30 => 30,\n    31 => 31,\n    32 => 32,\n    33 => 33,\n    34 => 34,\n  \
    \  35 => 35,\n    36 => 36,\n    37 => 37,\n    38 => 38,\n    39 => 39,\n   \
    \ 40 => 40,\n    41 => 41,\n    42 => 42,\n    43 => 43,\n    44 => 44,\n    45\
    \ => 45,\n    46 => 46,\n    47 => 47,\n    48 => 48,\n    49 => 49,\n    50 =>\
    \ 50,\n    51 => 51,\n    52 => 52,\n    53 => 53,\n    54 => 54,\n    55 => 55,\n\
    \    56 => 56,\n    57 => 57,\n    58 => 58,\n    59 => 59,\n    60 => 60,\n \
    \   61 => 61,\n    62 => 62,\n    63 => 63,\n    64 => 64,\n    65 => 65,\n  \
    \  66 => 66,\n    67 => 67,\n    68 => 68,\n    69 => 69,\n    70 => 70,\n   \
    \ 71 => 71,\n    72 => 72,\n    73 => 73,\n    74 => 74,\n    75 => 75,\n    76\
    \ => 76,\n    77 => 77,\n    78 => 78,\n    79 => 79,\n    80 => 80,\n    81 =>\
    \ 81,\n    82 => 82,\n    83 => 83,\n    84 => 84,\n    85 => 85,", "  n = n.to_i\n\
    \  return n % 11 == 0 or n % 13 == 0 ? (n % 15 == 0 and (n % 17 == 0 or n % 19\
    \ == 0) ? 1 : 0) : n % 11 == 0 ? (n % 17 == 0 and (n % 19 == 0 or n % 22 == 0)\
    \ ? 1 : 0) : 0\nend", "  while n > 0 && n <= 1000\n    if n % 11 == 0 || n % 13\
    \ == 0\n      puts n\n    end\n    n /= 10\n  end\nend", "  counter = 0\n  i =\
    \ n\n  while i > 0 do\n    if i % 11 == 0 or i % 13 == 0 then\n      counter +=\
    \ 1\n    end\n    i /= 10\n  end\n  return counter\nend", "  ((n % 11) == 0) ||\
    \ ((n % 13) == 0) ? 0 : 1\nend", "  x = n.to_s.reverse.gsub(/(.)(\\d)/, '\\1\\\
    2').reverse\n  x.scan(/11/){ |s| return s.to_i if s.to_i % 11 == 0 }\n  x.scan(/13/){\
    \ |s| return s.to_i if s.to_i % 13 == 0 }\n  x.to_i\nend", "  while n < 0 do\n\
    \    n += 100\n  end\n  n.zero? and raise ArgumentError, \"number must be positive\"\
    \n  n.div(11).zero? and raise ArgumentError, \"number must be divisible by 11\"\
    \n  n.div(13).zero? and raise ArgumentError, \"number must be divisible by 13\"\
    \n  n.div(11).zero? and raise ArgumentError, \"number must be divisible by 11\"\
    \n  return 0 if n.div(11).zero?\n  return 2 if n.div(13).zero?\n  return 3\nend",
  "  n.times.find {|i| i.modulo(11).zero? || i.modulo(13).zero?} || 0\nend", "  ((n\
    \ % 11) == 0) || ((n % 13) == 0) ? 0 : fizz_buzz(n - 1)\nend", "  i = 1\n  while\
    \ i <= n\n    if i % 11 == 0 && i % 13 == 0\n      return 0\n    i += 1\n  end\n\
    \  return 1\nend\n</cell>\n<cell>", "  return 0 if n < 100 else (n % 11 == 0 and\
    \ n % 13 == 0 or n % 11 == 0 and n % 13 == 0 or n % 11 == 0 and n % 13 == 0)\n\
    end", "  \n  # If the number is less than 11, return n\n  return n < 11 ? n :\
    \ \n  \n  # If number is divisible by 11, return it\n  return n % 11 == 0 ? n\
    \ : \n  \n  # If number is divisible by 13, return it\n  return n % 13 == 0 ?\
    \ n : \n  \n  # Otherwise, return the number divided by 11 and divide by 13 until\
    \ it is less than 11\n  (n % 11) / 13\nend\n</cell>\n<code language=julia-1.3>",
  "  return number_to_words(n, 11) + number_to_words(n, 13).count('7')\nend", "  \n\
    \  # Add your code below this line\n  if n % 11 == 0 or n % 13 == 0\n    return\
    \ \"FizzBuzz\"\n  else\n    return \"Fizz\" if n % 3 == 0 else \"Buzz\" if n %\
    \ 5 == 0 else \"FizzBuzz\" if n % 7 == 0\n  end\nend\n</cell>\n<text>\nExploring\
    \ Ruby\nRuby is an object-oriented programming language with strict rules. Though\
    \ Ruby is an extremely powerful language in many ways, we won't be using it in\
    \ this course. Instead, we'll be using Python and Ruby's syntax and semantics\
    \ to guide you through the process. We'll be using Jupyter Notebooks and a great\
    \ Python library called NumPy.", "  return 0 if n < 10 || n % 11 == 0 || n % 13\
    \ == 0 else 1 + fizz_buzz(n - 10)\nend", "  ((n / 11) % 13 == 0) || ((n / 13)\
    \ % 11 == 0)\nend", "  puts \"#{n}\" if n.even?\n  puts \"#{n}\" if n % 11 ==\
    \ 0\n  puts \"#{n}\" if n % 13 == 0\n  puts \"#{n}\" if n.even?\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>", "  # Add your code here\n  if(n\
    \ % 11 == 0 or n % 13 == 0)\n  puts n\n  else\n    puts \"Not A Fizz Buzz\"\n\
    \  end\nend", "  # The number n is divisible by 11 if and only if n = 11 * i\n\
    \  n.divmod(11).inject(0) do |m, i|\n    # i is divisible by 13 if and only if\
    \ n = 13 * i\n    if i % 13 == 0 then\n      m + 1\n    else m\n    end\n  end\n\
    end\n</code>\n<|/ a |>\n<| a tags=ruby,algorithm,math |>\nThis solution works\
    \ for all positive integers:\n<code>", "  n.times.each_with_index do |i, idx|\n\
    \    if i.to_s.include?(\"7\")\n      puts \"#{idx+1}\"\n    end\n  end\n  puts\
    \ \"#{n.to_s.count('7')}\"\nend", "  if n % 11 == 0 or n % 13 == 0\n    return\
    \ n\n  else\n    return fizz_buzz(n - 1) + fizz_buzz(n - 3)\n  end\nend\n</code>\n\
    And it works in Ruby 1.9.3!\n<|/ a dscore=1 |>\n<| c |>\n`fizz_buzz(100)` returns\
    \ `100` which is not the solution.\n<|/ c |>\n<| c |>\nThis works but I don't\
    \ think it is a good solution. `fizz_buzz(50)` returns `50`, but the `if n % 11\
    \ == 0 or n % 13 == 0` evaluates to true so it doesn't continue on to `fizz_buzz(50\
    \ - 1)`.\n<|/ c |>\n<| a tags=algorithm,ruby |>\n<code>", "  number_modulo = [11,\
    \ 13].include?(n % 11)\n  return number_modulo ? n : nil\nend", "  n = n.to_s\n\
    \  result = 0", "  return if n < 1 || n % 11 == 0\n  return if n % 13 == 0\n \
    \ n = n.to_i\n  return if n < 0\n  return if n < 10\n  return if n % 7 == 0\n\
    \  n = \"FizzBuzz\" if n < 20 ? \"Fizz\" : \"Buzz\"\n  return n.length + n.upcase\
    \ + n.pluralize(n % 10)\nend", "  i = 0\n  while (i < n) and (n % 11 == 0 or n\
    \ % 13 == 0)\n    i += 1\n  i\nend", "  n = n.to_i\n  return 0 if n <= 0 or n\
    \ % 11 == 0 or n % 13 == 0 else 1\nend", "  n % 11 == 0 || n % 13 == 0\nend",
  "  ((n / 11) % 13 + 1 if (n / 11) < 13)\nend", "  if n < 0\n    n = 0\n  elsif n\
    \ >= 100\n    n = n - 100\n  elsif n < 10\n    n = '0' + n\n  end", "  fizzbuzz(n\
    \ % 11 ? 0 : 1, n % 13 ? 0 : 1, n)\nend", "  return 0 if (n < 13) \n  \n  digits\
    \ = (n % 11).to_s + \" \" + (n % 13).to_s\n  \n  return digits[0..1].count(\"\
    7\") if (digits[0..1].count(\"7\") == 0)\n  \n  fizz_buzz.call(n - 13)\nend\n\
    </code>\n<|/ a |>\n<| c |>\nThis doesn't work in Ruby 2.2.\n<|/ c |>\n<| a dscore=1\
    \ tags=ruby,fizzbuzz |>\n<code>", "  if n < 15\n    n == n % 11 + 11\n  else\n\
    \    n == n % 13 + 13\nend", "  return 0 if n <= 0 end\n  if n <= 21 then return\
    \ 1 end\n  if n % 11 == 0 or n % 13 == 0 then return 2 end\n  fizz_buzz(n % 10\
    \ + 1)\nend\n    ", "  for i in 0..n\n    dig = (i % 11 == 0 || i % 13 == 0) ?\
    \ i : nil\n    if dig == 7\n      n\n    elsif dig == nil\n      0\n    end\n\
    \  end\nend\n</code>\n<|/ a |>\n<| c |>\nThis works, but the question asks for\
    \ the fizz_buzz method. `fizz_buzz.call(50)` returns 0, not 50.\n<|/ c |>\n<|\
    \ c |>\nThe OP wanted to find the number of times the digit 7 appears in integers\
    \ less than n which are divisible by 11 or 13. I was giving them a way to easily\
    \ achieve this.\n<|/ c |>\n<| c |>\nSorry I misread the question. Thought you\
    \ were looking for something that produces the number of times 7 appears in any\
    \ number below n divisible by 11 or 13 (i.e. `fizz_buzz(50) == 12`).\n<|/ c |>\n\
    <| c |>\nHonestly, this doesn't look like it solves the problem at all. I was\
    \ actually looking for some way to create a fizz buzz method that I could run\
    \ through a range of numbers (i.e. `fizz_buzz(50)` would return 12). But it's\
    \ definitely helpful for people to see a way to do this that I can easily implement\
    \ myself, so thanks!\n<|/ c |>\n<| c |>\nI suppose the key part is getting the\
    \ last number from the iterator returned. Otherwise the OP may think that calling\
    \ `fizz_buzz` will return an iterator and count the number of times 7 appears\
    \ in that iterator.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  div = n/11 + (n\
    \ <> 11 and n/13)\n  puts \"#{div} #{'FizzBuzz' if div == 0 else 'Fizz' if div\
    \ == 1 else 'Buzz'}\"\nend", "  n.to_i.times do |i|\n    if i % 11 == 0 || i %\
    \ 13 == 0\n      puts \"#{n} fizzbuzz\"\n    else\n      puts i\n    end\n  end\n\
    end", "  while n < 100\n    n += n % 11 or n % 13\n  end\n  return n\nend\n</code>\n\
    <|/ a tags=ruby,loops |>\n<| c |>\nThe `or` operator is redundant here since neither\
    \ `n % 11` nor `n % 13` is zero, so `n % 11 or n % 13` evaluates to `n % 13`.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "  if n == 0 then return nil\n  if n % 11\
    \ == 0 or n % 13 == 0 then return n\n  else return fizz_buzz(n - 1) end\nend\n\
    </code>\n<|/ a tags=fizzbuzz,ruby,recursion |>\n<| a tags=fizzbuzz,ruby,recursion\
    \ dscore=3 |>\n<code>", "  return 0 if n<=1 else\n  1 if n<=3 then\n    n if n%11==0\
    \ then 0 else \n    n if n%13==0 then 1 else 2 end\n  else \n    n if n%3==0 then\
    \ 1 else n if n%5==0 then 2 else n end\nend", "  return n if n <= 9 && n % 11\
    \ == 0 || n <= 13 && n % 13 == 0 ? 'fizzbuzz' : n % 10 == 0 ? n : nil\nend", " \
    \ return n if n =~ /^(11|13)$/ ? 0 : 1 +\n    ((n =~ /^(11|13)$/) ? fizz_buzz(n\
    \ =~ /^(11|13)$/ ? n*11 : n*13) : 0)\nend", "  count = 0\n  if n.to_s.div(11).zero?\
    \ && n.to_s.div(13).zero?\n    count += n.to_s.rindex(7)\n  elsif n.to_s.div(11).zero?\n\
    \    count += n.to_s.rindex(7)\n  elsif n.to_s.div(13).zero?\n    count += n.to_s.rindex(7)\n\
    \  else\n    count = 0\n  end\n  count\nend", "  return 0 if n < 10 && n % 11\
    \ == 0 or n < 13 && n % 13 == 0 else 1 if n < 10 && n % 11 != 0 else 2 if n <\
    \ 13 && n % 13 != 0 then 0 else 3\nend\n</cell>\n<cell>\nfizz_buzz(78)\n</cell>\n\
    <text>\nThe fizz buzz problem\nThe fizz buzz problem is a puzzle where you try\
    \ to find the number that makes the sum of all the numbers from 1 to n divisible\
    \ by 3 or 5. The idea is to use loops and control flow, and you might come up\
    \ with a better solution to the problem that doesn't involve a big array of numbers.\
    \ But in any case, you might still come up with a solution that uses a lot of\
    \ numbers. Let's see how we might solve it by looking at the problem in some different\
    \ ways. We'll use a method call \"call\" which we haven't seen before, and we'll\
    \ see how it works in several different places. Let's start with the \"call\"\
    \ method.", "  count = 0\n  while n > 0 and n % 11 == 0 or n % 13 == 0\n    count\
    \ += 1\n    n /= 11\n  while n > 0 and n % 10 == 0\n    count += 1\n    n /= 10\n\
    \  while n > 0 and n % 7 == 0\n    count += 1\n    n /= 7\n  count\nend", "  n\
    \ = n.to_i\n  if n % 11 == 0 or n % 13 == 0\n    return 0\n  else\n    return\
    \ 1\n  end\nend", "  divisor = case n % 10 of \n                7 => 0; \n   \
    \             11 => 1; \n                13 => 2;\n                default\n \
    \               0\n  \n  case n / divisor % 10 of\n    0 => 0 \n    1 => 0\n \
    \   2 => 1\n    3 => 1\n    4 => 2\n    5 => 2\n    6 => 3\n    7 => 3\n    8\
    \ => 4\n    9 => 4\n  else\n    n / divisor\n  end\nend", "  number_is_divisble_by_11\
    \ = (n % 11 == 0)\n  number_is_divisble_by_13 = (n % 13 == 0)\n  if number_is_divisble_by_11\
    \ && number_is_divisble_by_13\n    return 0\n  number_is_divisble_by_11 = number_is_divisble_by_13\n\
    \  \n  number_is_divisble_by_13 = (n % 13 == 0)\n  number_is_divisble_by_11 =\
    \ (n % 11 == 0)\n  if number_is_divisble_by_11 && number_is_divisble_by_13\n \
    \   return 0\n  \n  number_is_divisble_by_11 = number_is_divisble_by_13\n  number_is_divisble_by_13\
    \ = (n % 13 == 0)\n  if number_is_divisble_by_11 && number_is_divisble_by_13\n\
    \    return 0\n  \n  number_is_divisble_by_11 = number_is_divisble_by_13\n  number_is_divisble_by_13\
    \ = (n % 13 == 0)\n  if number_is_divisble_by_11 && number_is_divisble_by_13\n\
    \    return 0\n  \n  number_is_divisble_by_11 = number_is_divisble_by_13\n  number_is_divisble_by_13\
    \ = (n % 13 == 0)\n  if number_is_divisble_by_11 && number_is_divisble_by_13\n\
    \    return 0\n  \n  number_is_divisble_by_11 = number_is_divisble_by_13\n  number_is_divisble_by_13\
    \ = (n % 13 == 0)\n  if number_is_divisble_by_11 && number_is_divisble_by_13\n\
    \    return 0\n  \n  number_is_divisble_by_11 = number_is_divisble_by_13\n  number_is_divisble_by_13\
    \ = (n % 13 == 0)\n  if number_is_divisble_by_11 && number_is_divisble_by_13\n\
    \    return 0\n  \n  number_is_divisble_by_11 = number_is_divisble_by_13\n  number_is_divisble_by_13\
    \ = (n % 13 == 0)\n  if number_is_divisble_by_11 && number_is_divisble_by_13\n\
    \    return 0\n  \n  number_is_divisble_by_11 = number_is_divisble_by_13\n  number_is_divisble_by_13\
    \ = (n % 13 == 0)\n  if number_is_divisble_by_11 && number_is_divisble_by_13\n\
    \    return 0\n  \n  number_is_divisble_by_11 = number_is_divisble_by_13\n  number_is_divisble_by_13\
    \ = (n % 13 == 0)\n  if number_is_divisble_by_11 && number_is_divisble_by_13\n\
    \    return 0\n  \n  number_is_divisble_by_11 = number_is_divisble_by_13\n  number_is_divisble_by_13\
    \ = (n % 13 == 0)\n  if number_is_", "  return n % 11 == 0 and n % 13 == 0 ? 0\
    \ : n =~ /[13579]/ ? 3 : 0\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\n\
    The `=~` operator is new for me so I didn't know it existed until your answer.\
    \ Thanks!\n<|/ c |>\n<| a dscore=1 |>\nThe other answers are all good, but I wanted\
    \ to share this one:\n<code>", "  return n if n <= 9 else {\n    n / 11 | 13:\
    \ 0,\n    n / 13 | 11: 0,\n    n / 14 | 15: 0,\n    n / 15 | 14: 0,\n    n: 0}[n\
    \ % 11]\nend", "  n.to_s.split('').each do |c|\n    if c == '7'\n      return\
    \ n.to_s.split('').count { |c| c == '7' }\n    elsif c == '11'\n      return n.to_s.split('').count\
    \ { |c| c == '11' }\n    elsif c == '13'\n      return n.to_s.split('').count\
    \ { |c| c == '13' }\n    end\n  end\n  0\nend", '  return n if n % 11 == 0 or
    n % 13 == 0 else fizz_buzz(n / 11) + fizz_buzz(n / 13)', "  count = 0\n  until\
    \ n != 0\n    if n % 11 == 0\n      count += 1\n    elsif n % 13 == 0\n      count\
    \ += 1\n    end\n    n /= 10\n  end\n  return count\nend", "  if n >= 100\n  \
    \  if n % 11 == 0\n      print n\n    else\n      print n, \"FizzBuzz\"\n  elsif\
    \ n >= 90\n    if n % 13 == 0\n      print n\n    else\n      print n, \"Fizz\"\
    \n  elsif n >= 80\n    if n % 11 == 0\n      print n\n    else\n      print n,\
    \ \"Buzz\"\n  else\n    print n\nend\n</code>\n<|/ a |>\n<| c |>\nI thought `case`\
    \ statements were only supposed to be used for integer comparisons ?  If so, why\
    \ does `case 123 ...` work?  If not, why doesn't `case 123 ...` work?\n<|/ c |>\n\
    <| c |>\nA case statement is an expression, not a statement, that's why it doesn't\
    \ need an `end` keyword. The return value of the case expression is what is returned\
    \ to the caller.\n<|/ c |>\n<| c |>\nThank you for that clarification.  I see\
    \ now that case statements were specifically intended for integer comparisons,\
    \ and I misunderstood what they were doing (I thought they were just for returning\
    \ a value).\n<|/ c |>\n<| c |>\nAlso thank you for the additional comments about\
    \ the case keyword.  I am now more familiar with the keyword than I did before.\n\
    <|/ c |>\n<| c |>\nJust to clarify, the case expressions are only evaluated for\
    \ boolean expressions such as `if n >= 100`, `if n % 11 == 0`, etc. I find that\
    \ to be a little confusing, so I tend to avoid using them in cases where the expression\
    \ is more complex than a simple comparison or equality test.\n<|/ c |>\n<| a tags=ruby,syntax\
    \ |>\nApart from using case statements, one other option would be to return an\
    \ array from your function and simply use the splat operator to pass an array\
    \ of arguments into your print method. \n<code>", "  ((n % 13) == 0) ? ((n % 11)\
    \ == 0) ? (n == 0 ? 0 : 1) : (n % 11) : ((n % 13) == 0) ? n : 0\nend", "  n, i\
    \ = n, 0\n  while i <= n do\n    if (i % 11 == 0 and i % 13 != 0) or (i % 11 !=\
    \ 0 and i % 13 == 0)\n      fizz_buzz.call(i, n)\n    end\n    i += 1\n  end\n\
    end\nfizz_buzz.call(100)\n</code>\n<|/ a tags=ruby |>\n<| c |>\n+1 for the code.\
    \ I wouldn't have done this without it. But I'm glad you did this in Ruby.\n<|/\
    \ c |>\n<| a |>\n<code>", "  result = 0\n  n.times do |i|\n    result += (i %\
    \ 11 == 0)\n    result += (i % 13 == 0)\n  end\n  return result\nend", '  return
    1 if n % 11 == 0 or n % 13 == 0 else 0', "  return 0 if (n % 11 == 0 and n % 13\
    \ == 0)\n  n = (n % 11 + 11) % 13 + 13\n  return 3 if (n % 7 == 0)\n  return 2\
    \ if (n % 5 == 0)\n  return 1 if (n % 3 == 0)\nend", "  return n.times.map do\
    \ |i|\n    i = i.reverse\n    i = i.each_cons(2).find { |a| a[0] == 7 and a[1].to_s.include?\
    \ \"11\" }\n    i[1].to_s.include? \"13\" ? \"#{i[0]+1}\" : \"#{i[0]+1}\"\n  end.length\n\
    end", "  return if n <= 0 then 0 else if n % 11 == 0 or n % 13 == 0 then fizz_buzz(n\
    \ / 10 + 1) else fizz_buzz(n / 10 + 1)\nend", "  return n.times.reduce(0) {|t,\
    \ i| t + ((i%3==0&&i%5==0)||(i%7==0&&i%11==0))}\nend\n</code>\n<|/ a tags=ruby,algorithm,ruby-on-rails\
    \ |>\n<| a |>\nI think this is what you are looking for ...\n<code>", "  if n<0\n\
    \    return \"Error: n must be non-negative\"\n  elsif n==0\n    return \"0\"\n\
    \  elsif n<13\n    return \"\"\n  elsif n%11==0\n    return \"11\"\n  elsif n%13==0\n\
    \    return \"13\"\n  else\n    return n.to_s.scan(/./).map{|x|x+\"7\"}.reject(&:blank?).join\n\
    \  end\nend", "    count = 0\n    if n >= 0 and n <= 100 then\n        if n %\
    \ 11 == 0 then\n            count = count + 1\n        end\n        if n % 13\
    \ == 0 then\n            count = count + 1\n        end\n    end\n    return count\n\
    end", "  if n % 11 == 0 \n    n /= 11\n    puts n\n  elsif n % 13 == 0\n    n\
    \ /= 13\n    puts n\n  else\n    puts n\n  end\nend", "  n.divmod(11).zero? ||\
    \ n.divmod(13).zero? ? n : 0\nend", "  return ((n % 11) == 0) || ((n % 13) ==\
    \ 0)\nend\n</cell>\n<text>\nA quick note on performance: you can use this method\
    \ without specifying an argument by passing a value of nil into the call() method,\
    \ like so:", "  n = n.to_i\n  (n.even? and n.odd? and (n mod 11 == 0 or n mod\
    \ 13 == 0)) or (n.odd? and (n mod 11 != 0 or n mod 13 == 0))\nend", "\tn.downto(1)\
    \ do |x|\n\t\tif x % 11 == 0 || x % 13 == 0\n\t\t\tputs x\n\t\tend\n\tend\nend",
  "  num = 0\n  while n >= 10\n    if n % 11 == 0\n      num += 1\n      n /= 11\n\
    \    elsif n % 13 == 0\n      num += 1\n      n /= 13\n    else\n      n -= 1\n\
    \    end\n  end\n  num\nend\n</code>\n<|/ a dscore=4 |>\n<| a |>\nI wrote a ruby\
    \ script that implements a pure ruby solution (without recursion), using only\
    \ modulus and comparison:\n<code>", "  if n%11==0 or n%13==0\n    0\n  else\n\
    \    n%11\n  end\nend", "  n = (n % 11 + n % 13 + 1)\n  if n <= 11\n    puts \"\
    #{n}\"\n  elsif n <= 13\n    puts \"#{n}\"\n  else\n    puts \"#{n}\"\n  end\n\
    end\n</code>\n<|/ a tags=ruby,fizzbuzz |>\n<| c |>\nWhy not `puts \"#{n}\"`? And\
    \ why are you using `eval`?\n<|/ c |>\n<| c |>\nI added those suggestions. Thank\
    \ you for the comment. I used `eval` because I saw someone using it in a similar\
    \ situation. Is there a better way?\n<|/ c |>\n<| a dscore=4 |>\nThis one should\
    \ work pretty fine:\n<code>", "  while n > 9\n    if n % 11 == 0\n      puts \"\
    #{n} is divisible by 11\"\n      n /= 11\n    elsif n % 13 == 0\n      puts \"\
    #{n} is divisible by 13\"\n      n /= 13\n    else\n      puts n\n      n /= 11\n\
    \      n /= 13\n    end\n  end\nend", "  return ((n % 11 == 0) || (n % 13 == 0))\
    \ ? ((n < 100) ? 0 : ((n < 1000)) ? 1 : 2)\nend", "  i = 1\n  while i <= n\n \
    \   if n%11 == 0 and n%13 == 0\n      puts i\n      puts \"\\n\"\n    end\n  \
    \  i += 1\n  end\nend", "  return n.to_s.chars.map do |digit|\n    digit.to_i\
    \ >= 9 && digit.to_i <  10 ? 'FizzBuzz' : digit.to_i\n  end.inject('') do |result,\
    \ (digit, index)|\n    result + (index == 0 ? '' : digit)\n  end\nend", "  return\
    \ 0 if n < 10 then 1 elif n % 13 == 0 then 2 else fizz_buzz(n/10)\nend\n</cell>\n\
    <cell>", "  count = 0\n  \n  while n > 0\n    count = count + (n % 11 == 0 ? 0\
    \ : 1) + (n % 13 == 0 ? 0 : 1)\n    n /= 10\n  end\n  \n  count\nend", "  if n==0\
    \ then return 0\n  if n%11==0 or n%13==0 then return 1\n  fizz_buzz(n-1)\nend",
  "  if n < 11 or n % 11 == 0 and n % 13 == 0 \n    then 0\n  else\n    n / 11 + (n\
    \ % 11 == 0 and n % 13 == 0)\n  end\nend", "  n = (n / 10).to_i\n  if n % 11 ==\
    \ 0 or n % 13 == 0\n    return n / 11\n  else\n    return n / 13\n  end\nend",
  "  n.zero? && return n\n  n.modulo(11) == 0 || n.modulo(13) == 0\n    ? n.to_s.split('').map(&:succ).reduce(:+).zero?\
    \ ? n : 0\n    : 0\nend", "  return n.times.{ |i| i%11 == 0 or i%13 == 0 ? i :\
    \ 0 }.compact.length\nend", "  # Write your code here.\n  return n%11==0 and n%13==0",
  "    count = 0\n    i = 0\n    while i < n\n        i += 1\n        if i % 11 ==\
    \ 0 or i % 13 == 0 then # if both divisible by 11 or 13\n            count +=\
    \ 1\n    end\n    return count\nend", "    number_to_fizz = n.floor\n    (1..n).each\
    \ do |i|\n        number_to_fizz.next == 7 || number_to_fizz.next == 11 ? puts\
    \ \"#{number_to_fizz}\" : number_to_fizz\n    end\nend\nfizz_buzz.call(91)", " \
    \ return n.modulo(11).zero? ? 0 : (n.modulo(13).zero? ? 2 : fizz_buzz(n.divide(13)))\n\
    end\n</code>\n<|/ a dscore=4 tags=ruby,loops,fizzbuzz |>\n<| a |>\nHow about this?\n\
    <code>", "  i = 0\n  while i < n\n    if n % 11 == 0\n      printf \"Fizz\"\n\
    \    elsif n % 13 == 0\n      printf \"Buzz\"\n    else \n      printf \"%d\"\
    \ n\n    i += 1\n  end\nend", "  count = 0\n  while n > 1\n    if n % 11 == 0\n\
    \      count += 1\n    n /= 11\n    if n % 13 == 0\n      count += 1\n    n /=\
    \ 13\n  end\n  count\nend\n</cell>\n<cell>", "  ( n  %11 == 0 and n %13 == 0 and\
    \ n %21 == 0 and n %15 == 0 and n %3 == 1 ) ? ( n & 7 == 0 and ( n & 1 == 0 or\
    \ n & 5 == 0 ) and ( n & 9 == 0 ) and ( n & 3 == 0 ) or 0 ) : 0\nend", "  n =\
    \ 0 if n < 0 else n\n  n = 0 if n < 0 else n\n  n = 0 if n < 0 else n\n  n = 0\
    \ if n < 0 else n\n  n = 0 if n < 0 else n\n  n = 0 if n < 0 else n\n  n = 0 if\
    \ n < 0 else n\n  n = 0 if n < 0 else n\n  n = 0 if n < 0 else n\n  n = 0 if n\
    \ < 0 else n\n  n = 0 if n < 0 else n\n  n = 0 if n < 0 else n\n  n = 0 if n <\
    \ 0 else n\n  n = 0 if n < 0 else n\n  n = 0 if n < 0 else n\n  n = 0 if n < 0\
    \ else n\n  n = 0 if n < 0 else n\n  n = 0 if n < 0 else n\n  n = 0 if n < 0 else\
    \ n\n  n = 0 if n < 0 else n\n  n = 0 if n < 0 else n\n  n = 0 if n < 0 else n\n\
    \  n = 0 if n < 0 else n\n  n = 0 if n < 0 else n\n  n = 0 if n < 0 else n\n \
    \ n = 0 if n < 0 else n\n  n = 0 if n < 0 else n\n  n = 0 if n < 0 else n\n  n\
    \ = 0 if n < 0 else n\n  n = 0 if n < 0 else n\n  n = 0 if n < 0 else n\n  n =\
    \ 0 if n < 0 else n\n  n = 0 if n < 0 else n\n  n = 0 if n < 0 else n\n  n = 0\
    \ if n < 0 else n\n  n = 0 if n < 0 else n\n  n = 0 if n < 0 else n\n  n = 0 if\
    \ n < 0 else n\n  n = 0 if n < 0 else n\n  n = 0 if n < 0 else n\n  n = 0 if n\
    \ < 0 else n\n  n = 0 if n < 0 else n\n  n = 0 if n < 0 else n\n  n = 0 if n <\
    \ 0 else n\n  n = 0 if n < 0 else n\n  n = 0 if n < 0 else n\n  n = 0 if n < 0\
    \ else n\n  n = 0 if n < 0 else n\n  n = 0 if n < 0 else n\n  n = 0 if n < 0 else\
    \ n\n  n = 0 if n < 0 else n\n  n = 0 if n < 0 else n\n  n = 0 if n < 0 else n\n\
    \  n = 0 if n < 0 else n\n  n = 0 if n < 0 else n\n  n = 0 if n < 0 else n\n \
    \ n = 0 if n < 0 else n\n  n = 0 if n < 0 else n\n  n = 0 if n < 0 else n\n  n\
    \ = 0 if n < 0 else n\n  n = 0 if n < 0 else n\n  n = 0 if n < 0 else n\n  n =\
    \ 0 if n < 0 else n\n  n = 0 if n < 0 else n\n", "  if n < 21\n    return 0 if\
    \ n % 11 == 0 or n % 13 == 0 else 1\n  else \n    return 0 if n % 13 == 0 else\
    \ fizz_buzz(n / 13)\nend", "  case n % 11 or n % 13\n    when 0\n      0\n   \
    \ when 1\n      1\n    when 2\n      \"2\"\n    when 3\n      \"3\"\n    when\
    \ 4\n      \"4\"\n    when 5\n      \"5\"\n    when 6\n      \"6\"\n    when 7\n\
    \      \"7\"\n    when 8\n      \"8\"\n    when 9\n      \"9\"\n    when 10\n\
    \      \"10\"\n    when 11\n      \"11\"\n    when 12\n      \"12\"\n    when\
    \ 13\n      \"13\"\n    when 14\n      \"14\"\n    when 15\n      \"15\"\n   \
    \ when 16\n      \"16\"\n    when 17\n      \"17\"\n    when 18\n      \"18\"\n\
    \    when 19\n      \"19\"\n    when 20\n      \"20\"\n    when 21\n      \"21\"\
    \n    when 22\n      \"22\"\n    when 23\n      \"23\"\n    when 24\n      \"\
    24\"\n    when 25\n      \"25\"\n    when 26\n      \"26\"\n    when 27\n    \
    \  \"27\"\n    when 28\n      \"28\"\n    when 29\n      \"29\"\n    when 30\n\
    \      \"30\"\n    when 31\n      \"31\"\n    when 32\n      \"32\"\n    when\
    \ 33\n      \"33\"\n    when 34\n      \"34\"\n    when 35\n      \"35\"\n   \
    \ when 36\n      \"36\"\n    when 37\n      \"37\"\n    when 38\n      \"38\"\n\
    \    when 39\n      \"39\"\n    when 40\n      \"40\"\n    when 41\n      \"41\"\
    \n    when 42\n      \"42\"\n    when 43\n      \"43\"\n    when 44\n      \"\
    44\"\n    when 45\n      \"45\"\n    when 46\n      \"46\"\n    when 47\n    \
    \  \"47\"\n    when 48\n      \"48\"\n    when 49\n      \"49\"\n    when 50\n\
    \      \"50\"\n    when 51\n      \"51\"\n    when 52\n      \"52\"\n    when\
    \ 53\n      \"53\"\n    when 54\n      \"54\"\n    when 55\n      \"55\"\n   \
    \ when 56\n      \"56\"\n    when 57\n      \"57\"\n    when 58\n      \"58\"\n\
    \    when 59\n      \"59\"\n    when 60\n      \"60\"\n    when 61\n      \"61\"\
    \n    when 62\n      \"62\"\n    when 63\n      \"63\"\n    ", "  nums = n.to_s.split(//)\n\
    \  nums.select{|i| i % 11 == 0 || i % 13 == 0 }.count('7')\nend", "  count = 0\n\
    \  while n > 0 && n < 100\n    if n % 11 == 0 && n % 13 == 0\n      count += 1\n\
    \    n /= 11\n    n /= 13\n  end\n  return count\nend", "  if n < 11 then return\
    \ n\n  elsif n < 13 then return (n-1) % 11\n  else return nil\nend", "  n = n.to_i\n\
    \  return 0 if (0 == n%11 || 0 == n%13) # if n is divisible by 11 or 13, return\
    \ 0\n  return 2 if (0 == n%11 && 0 == n%13) # if n is divisible by 11, return\
    \ 2\n  return 3 if (0 == n%13) # if n is divisible by 13, return 3\n  return 5\
    \ if (2 == n%11 && 0 == n%13) # if n is divisible by 11, return 5\n  return 6\
    \ if (0 == n%11 && 2 == n%13) # if n is divisible by 11, return 6\n  return 7\
    \ if (3 == n%13) # if n is divisible by 13, return 7\n  return 10 if (0 == n%11\
    \ && 2 == n%13 && 0 == n%13) # if n is divisible by 11, return 10\n  return 11\
    \ if (5 == n%13) # if n is divisible by 13, return 11\n  return 13 if (0 == n%11\
    \ && 5 == n%13) # if n is divisible by 11, return 13\nend\n</code>\n<|/ a tags=fizzbuzz,ruby,algorithm\
    \ |>\n<| c |>\nThis doesn't work for negative numbers. You need to check `if n\
    \ == 0 || n == 1` before you start computing the conditions.\n<|/ c |>\n<| c |>\n\
    `def fizz_buzz(n); n = n.to_i; return 0 if (n == 0 || n == 1); return 2 if (n\
    \ == 0 && (n == 1 || n == 3)); return 3 if (n == 1 && (n == 0 || n == 3)); return\
    \ 5 if (n == 2 && (n == 0 || n == 1 || n == 3)); return 6 if (n == 0 && (n ==\
    \ 1 || n == 3) && (n == 0 || n == 3)); return 7 if (n == 3 && (n == 0 || n ==\
    \ 1 || n == 3) && (n == 0 || n == 3)); return 10 if (n == 0 && (n == 1 || n ==\
    \ 3) && (n == 0 || n == 3) && (n == 0 || n == 3)); return 11 if (5 == n); return\
    \ 13 if (n == 0 && (n == 1 || n == 3) && (n == 0 || n == 3) && (n == 0 || n ==\
    \ 3) && (n == 0 || n == 3)); end` works for negative numbers and non-zero numbers.\n\
    <|/ c |>\n<| a |>\nIn Ruby, one can use the following code:\n<code>\n(1..100).to_a.select\
    \ { |n| n % 3 == 0 || n % 5 == 0 }.count\n</code>\nWhere the range is from 1 to\
    \ 100.\n<|/ a tags=fizzbuzz,ruby,algorithm dscore=4 |>\n<| c |>\n`(1..100).to_a.select\
    \ { |n| n % 3 == 0 || n % 5 == 0 }.count", "    count = 0\n    while n > 0\n \
    \       if n % 11 == 0\n            count += 1\n        n /= 11\n        if n\
    \ % 13 == 0\n            count += 1\n        n /= 13\n    end\n    count\nend",
  "  n, remainder = (n % 11), (n / 11)\n  if remainder == 0 or remainder == 1 or remainder\
    \ == 2 or remainder == 3\n    return 0 if remainder == 0 else 1\n  elsif remainder\
    \ == 4 or remainder == 5 or remainder == 6 or remainder == 7\n    return 2\n \
    \ elsif remainder == 8 or remainder == 9 or remainder == 10 or remainder == 11\n\
    \    return 3\n  else\n    return 0\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    Your solution would be good for this example, but how do I implement this into\
    \ a larger code? I am not sure how to return \"n\" in the function and have it\
    \ print out in the console when the function is called.\n<|/ c |>\n<| c |>\nThe\
    \ function can be easily modified to return `n`, just add `return n` at the end\
    \ of the function.  You call the function with `fizz_buzz.call(42)` and it will\
    \ return `42` in the variable `n`.\n<|/ c |>\n<| a |>\nFor fizzbuzz:\n<code>",
  "  (n.modulo 11 == 0) ? (n.modulo 13 == 0) ? n : (n.modulo 13 ? n + 13 : n + 11)\
    \ : fizz_buzz.call(m)\nend", "  return 0 if (n <= 0) || n % 11 == 0 || n % 13\
    \ == 0\n  return 2 if (n % 11 == 0) && n % 13 == 0\n  return 3 if (n % 11 == 0)\
    \ && n % 13 != 0\n  return 1 if (n % 11 != 0) && n % 13 == 0\n  return 2 if (n\
    \ % 11 != 0) && n % 13 != 0\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n+1 from\
    \ me for being thorough, though I'm not a big fan of using an `end` keyword on\
    \ line endings like that. Ruby has a lot of nice ways of making the code easier\
    \ to read and maintain.\n<|/ c |>\n<| c |>\nThanks for pointing that out. I always\
    \ use an explicit `end` when writing Ruby, even for single lines. I find it's\
    \ much clearer to me which end goes with what condition.\n<|/ c |>\n<| c |>\n\
    One minor improvement would be to use a ternary operator: `return 2 if n % 11\
    \ == 0 && n % 13 == 0`\n<|/ c |>\n<| c |>\nI see, thank you. I'll keep that in\
    \ mind. I usually just use an `if/else` because I like to keep my code as concise\
    \ as possible.\n<|/ c |>\n<| a dscore=2 |>\nHere's my take on it. This is only\
    \ ruby 1.9.\n<code>", "  return n.digits.inject(0) { |sum, digit| \n    sum +\
    \ digits[digit.to_i]\n  }\nend", "  count = 0\n  return (0..(n-1).to_a).each_with_object(count)\
    \ { |i, count| count += 1 if n % 11 == i || n % 13 == i }\nend", "  count=0\n\
    \  remainder=n%11\n  if remainder == 7 && n<13\n    count+=1\n  end\n  remainder=n%13\n\
    \  if remainder == 7 && n<13\n    count+=1\n  end\n  remainder=n%11\n  if remainder\
    \ == 7 && n<13\n    count+=1\n  end\n  return count\nend", "  # Only for n < 100,\
    \ since we only need the first three digits for our testing\n  return 0 if n <\
    \ 100 else n % 11 == 0 and n % 13 == 0 or (n - n % 11) % 13 == 0\nend", "  return\
    \ 0 if n <= 0 # Make sure n is positive\n  return 1 if n % 11 == 0 or n % 13 ==\
    \ 0 # Make sure n is divisible by 11 or 13\n  ", "  return fizz_buzz_inner(n,\
    \ 1)\nend", "  return 0 if n.modulo 11 ==0 || n.modulo 13 ==0 then 0 else 1 +\
    \ fizz_buzz(n.modulo 11)\nend\nfizz_buzz = memoize(fizz_buzz)", "  return n <=\
    \ 0 ? 0 : n % 13 == 0 ? n : n % 11 == 0 ? fizz_buzz(n / 11) + 1 : (fizz_buzz(n\
    \ / 13) + 1)\nend\n    ", '  return 0 if n <= 0 else 1 if n <= 11 else 2 if n
    <= 13 else 3', "  # Return an integer from 1 up to the value passed in which is\
    \ divisible by 11 or 13 but not both.\n  # >>> fizz_buzz.call(50)\n  # 1\n  #\
    \ >>> fizz_buzz.call(78)\n  # 2\n  # >>> fizz_buzz.call(79)\n  # 3\n  m = n %\
    \ 11\n  n = n / 11\n  \n  if m == 0 and n == 13\n    return 3\n  end\n  \n  if\
    \ m == 0 or n == 13\n    return 1\n  end\n  \n  if m == 0 or n == 11\n    return\
    \ 0\n  end\n  \n  if m == 0 and n == 0\n    return 1\n  end\n  \n  if m == 1 and\
    \ n == 0\n    return 1\n  end\n  \n  if m == 1 or n == 0\n    return 0\n  end\n\
    \  \n  i = 2\n  \n  while i <= n\n    if m % i == 0 and n % i == 0\n      return\
    \ 0\n    end\n    i += 1\n  end\n  \n  if m == 1 and n == 0\n    return 1\n  end\n\
    \  \n  if m == 1 and n == 11\n    return 2\n  end\n  \n  if m == 1 and n == 13\n\
    \    return 3\n  end\nend", "  if n % 11 == 0 or n % 13 == 0\n    puts \"#{n}\
    \ is a multiple of 11 or 13\"\n  else\n    if n % 7 == 0\n      puts \"#{n} is\
    \ a multiple of 7\"\n    else\n      puts \"#{n} is a multiple of 11 or 13\"\n\
    \    end\n  end\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThanks for the solution!\
    \ It helped me to improve my code.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails |>\n\
    This code will help you understand why your code isn't working.\n<code>", "  if\
    \ n < 13\n  then return 0\n  elsif n % 11 == 0\n  then return 1\n  elsif n % 13\
    \ == 0\n  then return 2\n  else\n    puts \"error\"\n  end\nend", "  if n%11==0\
    \ then\n    return 0\n  end\n  if n%13==0 then\n    return 1\n  end\n  return\
    \ 2\nend", "  return n if n % 11 == 0 or n % 13 == 0 else fizz_buzz(n/11) + fizz_buzz(n/13)\n\
    end", "  ( n <= 13 and n % 11 == 0 or n % 13 == 0 ) ? 0 : fizz_buzz(n / 10) +\
    \ fizz_buzz(n % 10)\nend", "  return n.divmod(11).zero? ? 2 : n.divmod(13).zero?\
    \ ? 3 : 0\nend", "  number_to_return = 0\n  while n != 0\n    if n % 13 == 0\n\
    \      number_to_return += 3\n    elsif n % 11 == 0\n      number_to_return +=\
    \ 1\n    elsif n % 7 == 0\n      number_to_return += 0\n    end\n    n /= 10\n\
    \  end\n  return number_to_return\nend\n</code>\nI hope this helps you understand\
    \ a bit better!\n<|/ a dscore=2 |>\n<| c |>\nWhile this might be a valuable hint\
    \ to solve the problem, a good answer also demonstrates the solution.  Please\
    \ [edit] to provide example code to show what you mean. Alternatively, consider\
    \ writing this as a comment instead.\n<|/ c |>\n<| c |>\nSure, will do! This was\
    \ the first real explanation I got from the question itself, I didn't realize\
    \ the question was specific to `fizzbuzz` algorithm. I'll do that in a bit.\n\
    <|/ c |>\n<| a tags=algorithm,ruby |>\nIn Ruby, use Enumerable#find:\n<code>",
  "    if n % 11 == 0 or n % 13 == 0\n        0\n    else\n        1\n    end\nend\n\
    </code>\n<|/ a tags=fizzbuzz,ruby |>\n<| a dscore=0 |>\n<code>\nrequire 'fizzbuzz'",
  "  numbers = n.to_s.split(\"\")\n  numbers.each do |num|\n    if num == \"7\" or\
    \ num == \"8\" or num == \"9\" then\n      number = numbers[0]\n      numbers.shift\n\
    \      number << \"FizzBuzz\" if number % 11 == 0\n      number << \"Fizz\" if\
    \ number % 13 == 0\n      number << \"Buzz\" if number % 3 == 0\n      puts number\n\
    \    end\n  end\nend\n</cell>\n<cell>", "  if n <= 9\n    puts n\n  elsif n ==\
    \ 9\n    puts n + 'Fizz'\n  elsif n%11 == 0\n    puts n + 'FizzBuzz'\n  else\n\
    \    puts n + 'Buzz'\n  end\nend\n</cell>\n<cell>\nfizz_buzz.call(99)\n</cell>\n\
    <cell>\nfizz_buzz.call(100)\n</cell>\n<cell>\nfizz_buzz.call(123)\n</cell>\n<cell>\n\
    fizz_buzz.call(125)\n</cell>\n<cell>\nfizz_buzz.call(157)\n</cell>\n<text>\nFor\
    \ loops and control flow\nLoops\nFor loops iterate through a set of instructions\
    \ until a particular condition is met. There are three ways you can do this.",
  "  div = 0\n  div = n / 11.0\n  div0 = n % 11\n  if div0 == 0\n    puts \"0\"\n\
    \  elsif div == 0\n    puts n\n  else\n    puts div0\n  end\nend", "  return n\
    \ if n % 11 == 0 or n % 13 == 0 else fizz_buzz(n / 11) + fizz_buzz(n / 13)\nend",
  "  return n % 11 == 0 and n % 13 == 0 ? n : nil\nend", "  if n % 11 == 0\n    return\
    \ 0\n  elsif n % 13 == 0\n    return 2\n  else \n    return 1\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThe code you provided is what I tried initially but this didn't\
    \ seem to work in Ruby. I also found this gem that I think would allow me to do\
    \ it without resorting to recursion: http://www.rubydoc.info/gems/fizzbuzz/0.0.1/FizzBuzz\n\
    <|/ c |>\n<| c |>\nOk, so I just checked that gem and it works like a charm. I\
    \ think I misunderstood how it worked when I first looked at it but now I know\
    \ it works thanks to you. Thanks very much.\n<|/ c |>\n<| a |>\nThis works in\
    \ Ruby 2.2.0p0:\n<code>", "  fizzbuzz_counter = n.to_s.chars.each_with_index.select\
    \ do |n, i|\n    i % 11 == 0 && n % 13 == 0\n  end\n  return fizzbuzz_counter.size\
    \ if fizzbuzz_counter.size > 0\n  return n\nend\n</code>\n<|/ a tags=ruby,fizzbuzz,fizzbuzz-puzzle,algorithm\
    \ |>\n<| c |>\nI don't think this does what the OP is looking for. OP wants the\
    \ number to be divisible by 11 **or** 13, not by both.\n<|/ c |>\n<| c |>\nHis\
    \ question is \"...which is divisible by 11 or 13...\" which means he wants 11\
    \ to be divisible by 11 and 13 to be divisible by 13.\n<|/ c |>\n<| c |>\nRight,\
    \ sorry. Just trying to be helpful and correct, haha.\n<|/ c |>\n<| a |>\nHere's\
    \ a solution in Ruby.\n<code>", "  return n.times.collect { |i| (i / 11) == 0\
    \ ? 0 : (i / 13) == 0 ? 1 : 2 }.count\nend\n</code>\n<|/ a |>\n<| c |>\nAhh this\
    \ is a nice solution. Much appreciated for the insight\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ |>\nAs I pointed out in the comment and in the other answer, the most efficient\
    \ way to do this would be to use regular expressions. Regular expressions can\
    \ be used to match things like \"number followed by number followed by number\"\
    , which is not the case here. Also, you will have to deal with situations where\
    \ the number is not divisible by 11 or 13 since this would cause the regex to\
    \ fail.\nThe pattern that I would use would be /((\\d{2})?(\\d{2})?(\\d{2})?)/\
    \ which matches either one of the three types of expressions: two numbers followed\
    \ by optional middle part, or three numbers followed by optional middle part.\
    \ The middle part can be optional because the middle part could be a whole number\
    \ or not.\nThen, you can use the method match? and pass the regular expression\
    \ created above to it to see if the string matches.\n<code>", "  i = n\n  fbuzz\
    \ = 0\n  while i <= n\n    i = i / 11\n    if i % 11 == 0 \n      fbuzz = fbuzz\
    \ + 0\n    elsif i % 13 == 0\n      fbuzz = fbuzz + 1\n    else\n      fbuzz =\
    \ fbuzz + 0\n    end\n  end\n  return fbuzz\nend", "  while n > 0\n    if n %\
    \ 11 == 0 || n % 13 == 0\n      return n\n    n /= 10\n  end\n  return n\nend",
  "  s = n.to_s\n  s = s[0...-1]\n  return s.split('').select{ |s| s.include?('7')\
    \ && !s.include?('9') && !s.include?('13') }.count\nend", "  num_times = 0\n \
    \ i = n\n  while i <= n\n    if i % 11 == 0\n      num_times += 3\n    elsif i\
    \ % 13 == 0\n      num_times += 1\n    end\n    i += 1\n  end\n  num_times + num_times\n\
    end", "  ( n % 11 == 0 ) && return \"FizzBuzz\"\n  ( n % 13 == 0 ) && return \"\
    Fizz\"\n  ( n % 15 == 0 ) && return \"Buzz\"\n  return\nend", "  i = 2\n  while\
    \ i <= n and n % i != 0\n    i += 1\n  i % 11 == 0 and i % 13 == 0 and return\
    \ i\nend\n</cell>\n<code language=julia-0.5>", "  return 0 unless ((n/11).modulo(11).zero?\
    \ || (n/13).modulo(13).zero?)\n  n = n.to_i\n  a = n % 11\n  b = n % 13\n  c =\
    \ n/11\n  d = n/13\n  if a != 0 && a.to_s == 1\n    return 0\n  end\n  if b !=\
    \ 0 && b.to_s == 1\n    return 0\n  end\n  if c != 0 && (c.to_s == 1 || c.to_s\
    \ == 11)\n    return 0\n  end\n  if d != 0 && (d.to_s == 1 || d.to_s == 13)\n\
    \    return 0\n  end\n  if a == 0 && b == 0 && c == 0 && d == 0\n    if n != 0\n\
    \      return 1\n    end\n    return 0\n  end\n  if a == 0 && b == 0 && c == 0\
    \ && d != 0\n    if n != 0\n      return 2\n    end\n    return 0\n  end\n  if\
    \ a == 0 && b == 0 && c != 0 && d == 0\n    if n != 0\n      return 3\n    end\n\
    \    return 0\n  end\n  if a == 0 && b == 0 && c != 0 && d != 0\n    if n != 0\n\
    \      return 4\n    end\n    return 0\n  end\n  if a == 0 && b != 0 && c == 0\
    \ && d == 0\n    if n != 0\n      return 5\n    end\n    return 0\n  end\n  if\
    \ a == 0 && b != 0 && c == 0 && d != 0\n    if n != 0\n      return 6\n    end\n\
    \    return 0\n  end\n  if a == 0 && b != 0 && c != 0 && d == 0\n    if n != 0\n\
    \      return 7\n    end\n    return 0\n  end\n  if a == 0 && b != 0 && c != 0\
    \ && d != 0\n    if n != 0\n      return 8\n    end\n    return 0\n  end\n  if\
    \ a == 0 && b != 0 && c != 0 && d == 0\n    if n != 0\n      return 9\n    end\n\
    \    return 0\n  end\n  if a == 0 && b != 0 && c == 0 && d != 0\n    if n != 0\n\
    \      return 10\n    end\n    return 0\n  end\n  if a == 0 && b != 0 && c ==\
    \ 0 && d == 0\n    if n != 0\n      return 11\n    end\n    return 0\n  end\n\
    \  if a == 0 && b == 0 && c == 0 && d == 0\n    if n != 0\n      return 12\n \
    \   end\n    return 0\n  end\n  if a == 0 && b == 0 && c == 0 && d != 0\n    if\
    \ n != 0\n      return 13\n    end\n    return 0\n  end\n  if a == 0 && b == 0\
    \ && c != 0 && d == 0\n    if n != 0\n      return 14\n    end\n    return 0\n\
    \  end\n  if a == 0 && b == 0 && c != 0 && d != 0\n    if n != 0\n", "  # Write\
    \ your code here.\n  if n % 11 == 0 or n % 13 == 0:\n    return 0\n  elif n %\
    \ 11 != 0 and n % 13 != 0:\n    return 1\n  elif n % 11 == 0 and n % 13 != 0:\n\
    \    return 2\n  elif n % 11 != 0 and n % 13 == 0:\n    return 3\n  else:\n  \
    \  return 4\nfizz_buzz.def('call')\n</cell>\n<cell>\nfizz_buzz.def('fizzbuzz')\n\
    </cell>\n<cell>\nfizz_buzz.call(78)\n</cell>\n<cell>\nfizz_buzz.fizzbuzz(78)\n\
    </cell>\n<text>\nEx 15", "  if n < 13\n    return n if n % 11 == 0 or n % 13 ==\
    \ 0 else \"FizzBuzz\"\n  else\n    return fizz_buzz(n / 11) if n % 11 == 0 else\
    \ fizz_buzz(n / 13) if n % 13 == 0 else fizz_buzz(n / 17) if n % 17 == 0 else\
    \ fizz_buzz(n / 19) if n % 19 == 0 else fizz_buzz(n / 29) if n % 29 == 0 else\
    \ fizz_buzz(n / 31) if n % 31 == 0 else fizz_buzz(n / 37) if n % 37 == 0 else\
    \ fizz_buzz(n / 41) if n % 41 == 0 else fizz_buzz(n / 43) if n % 43 == 0 else\
    \ fizz_buzz(n / 47) if n % 47 == 0 else fizz_buzz(n / 53) if n % 53 == 0 else\
    \ fizz_buzz(n / 59) if n % 59 == 0 else fizz_buzz(n / 61) if n % 61 == 0 else\
    \ fizz_buzz(n / 67) if n % 67 == 0 else fizz_buzz(n / 71) if n % 71 == 0 else\
    \ fizz_buzz(n / 73) if n % 73 == 0 else fizz_buzz(n / 79) if n % 79 == 0 else\
    \ fizz_buzz(n / 83) if n % 83 == 0 else fizz_buzz(n / 89) if n % 89 == 0 else\
    \ fizz_buzz(n / 97) if n % 97 == 0 else \"FizzBuzz\"\nend", "  if n % 11 == 0\n\
    \  then\n    puts n\n  end\n  if n % 13 == 0\n  then\n    puts n\n  end\nend",
  "  count=0\n  while n != 0\n    count += n % 7 == 0\n    n /= 7\n  end\n  return\
    \ count\nend", "  (0..100).select { |i| i % 11 == 0 || i % 13 == 0 }.map { |i|\
    \ if i % 11 == 0 && i % 13 == 0\n    i % 11\n  else\n    if i % 11 == 0\n    \
    \  i\n    else if i % 13 == 0\n      i + 11\n    else\n      i + 13\n    end\n\
    \  end.count(n)\nend", "  n, i = n.divmod(11)\n  n, j = n.divmod(13)\n  return\
    \ 0 if i or j else 2 if i or j else 3\nend\n</cell>\n<cell>\n@test", "  num_digits(n).times\
    \ do |i|\n    return 0 if (n % 11 == 0 or n % 13 == 0)\n  end", "    a, b = n,\
    \ n\n    while a % 11 == 0 or a % 13 == 0\n        a, b = b, a % b\n    puts b\n\
    end", "  return ((n != 0 and (n % 11 == 0 or n % 13 == 0)) ?\n          ((n %\
    \ 7 == 0) ?\n           (((n - 1) % 7 == 0) ? 0 : ((n - 1) % 7 == 1) ? 1 : ((n\
    \ - 1) % 7 == 2) ? 2 : ((n - 1) % 7 == 3) ? 3 : 4)\n         : 0);\nend\n</cell>\n\
    <cell>", "  return (n == 0) ? '0' : (n % 11 == 0) ? '1' : '2' : (n % 13 == 0)\
    \ ? '3' : '4'\nend", "  n <= 100 ? fizz_buzz_count(n) : n % 11 == 0 ? fizz_buzz_count(n)\
    \ : n % 13 == 0 ? fizz_buzz_count(n) : 0\nend", "  result = n.to_s.count(\"7\"\
    )\n  result += (n % 11 == 0) ? 1 : 0\n  result += (n % 13 == 0) ? 1 : 0\n  result\n\
    end", "  (0...n).count { |i| i % 11 == 0 && i % 13 == 0 }\nend", "  if n==0 or\
    \ n==10 then return \"FizzBuzz\"\n  if n==3 then return \"Fizz\"\n  if n==5 then\
    \ return \"Buzz\"\n  if n%11==0 or n%13==0 then return \"#{n}\"\n  fizz_buzz(n/11)\
    \ || fizz_buzz(n/13)\nend\n</cell>\n<cell>\n%%ruby -r ./fizz_buzz.rb 45\n45\n\
    </cell>\n<text>\nThe Ruby community has embraced a lot of these ideas as Ruby\
    \ methods. This is one of the best reasons to use a Ruby language as your primary\
    \ language. You'll get used to this and more by enjoying it so you can become\
    \ a better developer!", "  return n / 11 if n % 11 == 0 else n / 13 if n % 13\
    \ == 0 else 0\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nA function named `fizz_buzz`\
    \ could be confusing, I would name it `fizzBuzz`\n<|/ c |>\n<| c |>\nI think this\
    \ is more Rubyish than the other solutions.\n<|/ c |>\n<| c |>\nI think this is\
    \ the best answer. Plus 1 for the refactoring suggestions.\n<|/ c |>\n<| c |>\n\
    Thanks for the tip about fizz_buzz. I'm new to Ruby, so I didn't know what to\
    \ name it.\n<|/ c |>\n<| c |>\nI love this solution since it uses Ruby's \"lazy\
    \ evaluation\". The way the function works it only evaluates the remainder after\
    \ you call it for the first time, which means that the remainder gets calculated\
    \ only when you try to read it.\n<|/ c |>\n<| a dscore=5 tags=ruby |>\n<code>",
  "  if n <= 0 \n    then return nil \n  else \n    if n % 11 == 0\n    then return\
    \ 1\n    else if n % 13 == 0\n    then return 3\n    else return 0 \n  end\nend",
  "  if n % 11 == 0 and n % 13 == 0 then return 0 else return n\nend", "  fizz_count\
    \ = n.to_s.split(//).map { |n| n % 11 == 0 || n % 13 == 0 ? n : 0 }.count\n  buzz_count\
    \ = n.to_s.split(//).map { |n| n % 3 == 0 || n % 5 == 0 ? n : 0 }.count\n  fizz_count\
    \ + buzz_count\nend", "  if n < 21\n    if n % 11 == 0\n      0\n    elsif n %\
    \ 13 == 0\n      1\n    elsif n % 17 == 0\n      2\n    elsif n % 19 == 0\n  \
    \    3\n    else\n      4\n  end\nend", "  if n<0\n    return 0\n  elsif n==0\n\
    \    return 1\n  elsif n==1\n    return 0\n  elsif n==2\n    return 0\n  elsif\
    \ n%3 == 0\n    return 1\n  elsif n%5 == 0\n    return 2\n  elsif n%7 == 0\n \
    \   return 3\n  else\n    return fizz_buzz(n/3)+1", "  if n % 11 == 0\n    puts\
    \ \"#{n} is a multiple of 11\"\n  elsif n % 13 == 0\n    puts \"#{n} is a multiple\
    \ of 13\"\n  else\n    puts \"#{n} is a multiple of 11 or 13\"\n  end\nend", " \
    \ return n if n.to_i.modulo(11).zero? or n.to_i.modulo(13).zero? else fizz_buzz.call(n/10)\
    \ + fizz_buzz.call(n%10)\nend", "  count = 0\n  (n.modulo 11).zero? && (count\
    \ += 1) if n.modulo 11\n  (n.modulo 13).zero? && (count += 1) if n.modulo 13\n\
    \  count\nend", "  count = (n/11).floor * 2 if (n%11==0 or n%13==0) else (n/13).floor\
    \ * 2\n  count\nend", "  return 0 if n <= 10 || n > 100 || n % 11 == 0 || n %\
    \ 13 == 0 else fizz_buzz(n - 1)\nend", "  if n.modulo(11).zero?\n    n.modulo(13).zero?\
    \ ? 0 : 1\n  else\n    n.modulo(11).zero? ? 2 : 3\n  end\nend", "  return n /\
    \ 11 if n % 11 == 0\n  n / 13 if n % 13 == 0\n  0\nend", "  return n.times.select\
    \ { |n| n.modulo(11).zero? && n.modulo(13).zero? && n == 7}.count\nend", "  if\
    \ n > 100\n    return n\n  else\n    return 0 if n % 11 == 0 or n % 13 == 0 else\
    \ fizz_buzz(n - 1) + (n % 11) + fizz_buzz(n / 13)\n  end\nend", "  if n<=3 then\n\
    \    return n\n  elsif n%11=0 or n%13=0 then\n    return 1\n  else\n    return\
    \ fizz_buzz(n//11) + 1\n  end\nend", "  (0..(n % 11)).each do |i|\n    return\
    \ 0 if i % 11 == 0 && i % 13 == 0\n  end\n  return 2\nend", "  return ((n % 11)\
    \ == 0) || ((n % 13) == 0) ? 0 : fizz_buzz(n - 1)\nend\nputs fizz_buzz.call(50)\n\
    puts fizz_buzz.call(78)\nputs fizz_buzz.call(79)"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
