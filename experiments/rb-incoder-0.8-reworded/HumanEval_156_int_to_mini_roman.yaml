name: HumanEval_156_int_to_mini_roman
language: rb
prompt: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
  # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n#\
  \ >>> int_to_mini_roman.call(19)\n# \"xix\"\n# >>> int_to_mini_roman.call(152)\n\
  # \"clii\"\n# >>> int_to_mini_roman.call(426)\n# \"cdxxvi\"\ndef int_to_mini_roman(number)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
  \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
  \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
  \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
  \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
  \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
  \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
  \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
  \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
completions: ["  if number.is_a?(Integer)\n    result = \"\"\n    i = 2\n    while\
    \ number >= i\n      result << \"x\" * i\n      number -= i\n      i += 1\n  \
    \  result\n  else\n    puts \"#{number} is not a number\"\n  end\nend", "  roman\
    \ = \"X\"\n  digits = \"\"\n  while number > 0\n    if number >= 1000 then\n \
    \     digits += \"M\"\n      number -= 1000\n    elsif number >= 500 then\n  \
    \    digits += \"CM\"\n      number -= 500\n    elsif number >= 100 then\n   \
    \   digits += \"D\"\n      number -= 100\n    elsif number >= 50 then\n      digits\
    \ += \"CD\"\n      number -= 50\n    elsif number >= 10 then\n      digits +=\
    \ \"C\"\n      number -= 10\n    elsif number >= 5 then\n      digits += \"XC\"\
    \n      number -= 5\n    elsif number >= 1 then\n      digits += \"L\"\n     \
    \ number -= 1\n    elsif number >= 0.25 then\n      digits += \"X\"\n      number\
    \ -= 0.25\n    else\n      raise ArgumentError, \"Invalid input: #{number}\"\n\
    \    end\n  end\n  \n  # reverse the digits to get our roman\n  roman = roman.reverse\n\
    \  \n  # return roman in lowercase\n  roman.downcase!\n  return roman\nend", " \
    \ if number == 0\n    roman = \"0\"\n  elsif number == 1\n    roman = \"i\"\n\
    \  elsif number == 3\n    roman = \"ii\"\n  elsif number == 5\n    roman = \"\
    iii\"\n  elsif number == 7\n    roman = \"iv\"\n  elsif number == 10\n    roman\
    \ = \"v\"\n  elsif number == 12\n    roman = \"vi\"\n  elsif number == 15\n  \
    \  roman = \"vii\"\n  elsif number == 20\n    roman = \"viii\"\n  elsif number\
    \ == 25\n    roman = \"ix\"\n  elsif number == 30\n    roman = \"x\"\n  elsif\
    \ number == 40\n    roman = \"xi\"\n  elsif number == 50\n    roman = \"xii\"\n\
    \  elsif number == 60\n    roman = \"xiii\"\n  elsif number == 70\n    roman =\
    \ \"xiv\"\n  elsif number == 80\n    roman = \"xvi\"\n  elsif number == 90\n \
    \   roman = \"xvii\"\n  elsif number == 100\n    roman = \"xviii\"\n  else\n \
    \   roman = \"\"\n  end\n  return roman\nend", "  romnum = \"i\"\n  rom_count\
    \ = 1\n  while number >= 1000\n    romnum = \"c\" + romnum\n    rom_count += 1\n\
    \    number -= 1000\n  while rom_count > 0\n    romnum = rom_to_roman.call(romnum)\
    \ + rom_to_roman.call(number)\n    number -= rom_to_roman.call(number)\n    rom_count\
    \ -= 1\n  romnum.downcase!\nend", "  roman_numerals = \n  \n  # Find length of\
    \ array.\n  length_of_roman_numerals = roman_numerals.length\n  \n  # Create the\
    \ result string with one space between each letter.\n  mini_roman = \"\"\n  \n\
    \  # Loop through the length of the array.\n  1.upto(length_of_roman_numerals\
    \ - 1) do |index|\n    # Assign the roman numerals at each index to the corresponding\
    \ index.\n    roman_numeral = roman_numerals[index]\n    \n    # Convert the integer\
    \ into an array and convert each digit to a string and \n    # concatenate each\
    \ string to the final string.\n    mini_roman += roman_numeral.to_s.split(\"\"\
    ).map { |digit| digit.to_s.upcase }.join\n  end\n  \n  # Return result string.\n\
    \  mini_roman\nend", "  if number < 1 || number > 1000\n    raise ArgumentError\n\
    \  roman = \"\"\n  num_place = 1\n  while number > 1\n    if number % 10 == 1\n\
    \      roman += \"x\"\n      number /= 10\n    else \n      roman += num_to_roman[number\
    \ % 10]\n      number /= 10\n    \n    num_place += 1\n  end\n  \n  return roman\n\
    end", "  roman = \"\"\n  i = number.to_i\n  while i > 1\n    roman, i = roman.succ,\
    \ i - 1\n  end\n  roman, i = roman.succ, number - 1\n  while i >= 1\n    roman,\
    \ i = roman.succ, i - 1\n  end\n  roman.to_s\nend", "    roman = \"\"\n    roman_numeral_array\
    \ = [1, 2, 5, 10, 40, 100, 400, 1000]\n    i = 0\n    while number > 0 and i <\
    \ len(roman_numeral_array)\n        roman = roman + (roman_numeral_array[i] *\
    \ number)\n        number -= roman_numeral_array[i]\n        i += 1\n    if number\
    \ == 0\n        roman = roman + \"l\"\n    end\n    roman = roman.downcase\n \
    \   return roman\nend\n</code>\n<|/ a dscore=1 tags=ruby,ruby-on-rails |>\n<|\
    \ a tags=ruby,ruby-on-rails |>\n<code>", "  if number < 1000\n    int_to_roman(number)\n\
    \  else\n    int_to_mini_roman(number / 10) + '.' + int_to_mini_roman(number %\
    \ 10)\n  end\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis solution also works\
    \ for negative numbers as well.\n<|/ c |>\n<| a tags=ruby dscore=3 |>\nI have\
    \ tried to solve the problem in the following way:\n<code>", "  result = []\n\
    \  roman_numbers = %w[i v x c l m s d]\n  roman_numbers.each do |roman_number|\n\
    \    result.unshift(roman_number) if number >= roman_number\n    number -= roman_number\n\
    \  end\n  result << number if number >= 0\n  result.join('')\nend", "  return\
    \ int_to_roman(number).downcase\nend", "  ones = \"\"\n  tens = \"\"\n  hundreds\
    \ = \"\"\n  if number < 1000000\n    ones = (number/1000000).to_s.reverse + \"\
    m\"\n    number = (number/1000).to_s.reverse + \"k\"\n  elsif number < 1000000000\n\
    \    ones = (number/1000000000).to_s.reverse + \"m\"\n    number = (number/10000000).to_s.reverse\
    \ + \"k\"\n  elsif number < 1000000000000\n    ones = (number/1000000000000).to_s.reverse\
    \ + \"m\"\n    number = (number/1000000000000000).to_s.reverse + \"k\"\n  end\n\
    \  while number > 1000000000000000\n    ones = (number/1000000000000000).to_s.reverse\
    \ + \"m\"\n    number = (number/10000000000000000).to_s.reverse + \"k\"\n  end\n\
    \  while number > 10000000000000000\n    hundreds = (number/10000000000000000).to_s.reverse\
    \ + \"m\"\n    number = (number/100000000000000000).to_s.reverse + \"k\"\n  end\n\
    \  while number > 100000000000000000\n    hundreds = (number/100000000000000000).to_s.reverse\
    \ + \"m\"\n    tens = (number/100000000000000000).to_s.reverse + \"k\"\n  end\n\
    \  if hundreds.empty? && tens.empty? && ones.empty?\n    number\n  else\n    mini_roman\
    \ = (hundreds + tens + ones).strip\n    mini_roman.strip!\n    mini_roman.downcase!\n\
    \    mini_roman\n  end\nend", "  roman = Array.new\n  roman.push ('M')\n  roman.push\
    \ ('C')\n  roman.push ('D')\n  roman.push ('L')\n  roman.push ('X')\n  roman.push\
    \ ('V')\n  roman.push ('I')\n  if number == 0\n    roman\n  elsif number == 1\n\
    \    roman\n  elsif number == 2\n    roman\n  elsif number == 3\n    roman\n \
    \ elsif number == 4\n    roman\n  elsif number == 5\n    roman\n  elsif number\
    \ == 6\n    roman\n  elsif number == 7\n    roman\n  elsif number == 8\n    roman\n\
    \  elsif number == 9\n    roman\n  elsif number < 0\n    return nil\n  else\n\
    \    (1..number).each do |i|\n      roman.push roman[-1] + i.to_s.reverse\n  \
    \  end\n    roman\n  end\nend", "  return \"#{ number < 0 ? -number : number }\"\
    \nend", "  result = ''\n  while number > 0\n    result = mini_roman_numerals[number\
    \ % 1000].upcase + result\n    number /= 1000\n  end\n  return result\nend", " \
    \ roman = \"\"\n  i=1\n  while i <= number\n    roman = roman + (number%10)+\"\
    -\"+roman #roman += \"-\" + (number%10)+\"-\"\n    number /= 10\n    i += 1\n\
    \    \n  roman = roman.strip(\"-\").strip(\"i\")\n  roman = roman.lstrip(\"m\"\
    ).lstrip(\"M\").strip(\"x\").strip(\"X\").strip(\"d\")\n  return roman\nend\n\
    </code>\n<|/ a dscore=4 |>\n<| c |>\n+1 for actually doing some work instead of\
    \ just sharing a link.\n<|/ c |>\n<| a tags=ruby,algorithm,string,roman |>\nHere's\
    \ an approach:\n<code>", "    romans = [ \"M\", \"CM\", \"D\", \"CD\", \"C\",\
    \ \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" ]\n    roman = ''\n\
    \    roman_number = 0\n    roman_counter = 0\n    \n    while number > 0:\n  \
    \      roman_counter = roman_counter + 1\n        number = number / 10\n    \n\
    \    while roman_counter > 0:\n        if roman_counter % 2 == 0:\n          \
    \  roman_number = roman_number + romans.index(roman)\n            roman = roman.upcase\n\
    \        roman_counter = roman_counter -1\n        roman_number = roman_number\
    \ + romans.index(roman)\n        roman = roman.upcase\n    return roman_number.to_s.downcase\n\
    end", "  if number < 1\n    raise ArgumentError, \"The argument should be a positive\
    \ number\"\n  elsif number == 1\n    return \"x\"\n  elsif number == 2\n    return\
    \ \"ii\"\n  elsif number > 9\n    roman_numeral = MiniRoman.int_to_roman(number)\n\
    \    if roman_numeral.size < \"II\".size\n      return roman_numeral\n    else\n\
    \      return roman_numeral[0..-2].upcase + roman_numeral[-2..-1]\n    end\n \
    \ else\n    roman_numeral = MiniRoman.int_to_roman(number)\n    if roman_numeral.size\
    \ < \"IV\".size\n      return roman_numeral\n    else\n      return roman_numeral[0..-2].upcase\
    \ + roman_numeral[-2..-1]\n    end\n  end\nend", "  return number_to_mini_roman(number,\
    \ true)\nend", "  # Split number into hundreds, thousands, unit, and unit.\n \
    \ unit  = number.to_s.split('')\n  hundreds = number.to_s.slice!(0,2)\n  thousands\
    \ = number.to_s.slice!(0,1)\n  # Calculate numeral equivalent and add unit.\n\
    \  numeral = unit.map { |s| ROMAN_ALPHABET[s] }\n  if hundreds.present?\n    numeral\
    \ = ['thousand'] + numeral.map { |s| ROMAN_ALPHABET[s] }\n  end\n  numeral.join('')\
    \ + hundreds + thousands\nend", "    roman_numbers = Array.new\n    (1..1000).each\
    \ do |x|\n        roman_numbers << MiniRoman.to_s(x)\n    end\n    roman_numbers.select\
    \ {|x| x =~ /^#{number.to_s.split(\"\").join}/ }.join\nend", '  rom = []', " \
    \ # Write your code here.\n  roman = \"\"\n  while number >= 1000\n    roman +=\
    \ \"M\"\n    number -= 1000\n  end\n  while number >= 900\n    roman += \"CM\"\
    \n    number -= 900\n  end\n  while number >= 500\n    roman += \"D\"\n    number\
    \ -= 500\n  end\n  while number >= 400\n    roman += \"CD\"\n    number -= 400\n\
    \  end\n  while number >= 100\n    roman += \"C\"\n    number -= 100\n  end\n\
    \  while number >= 90\n    roman += \"XC\"\n    number -= 90\n  end\n  while number\
    \ >= 50\n    roman += \"L\"\n    number -= 50\n  end\n  while number >= 40\n \
    \   roman += \"XL\"\n    number -= 40\n  end\n  while number >= 10\n    roman\
    \ += \"X\"\n    number -= 10\n  end\n  while number >= 9\n    roman += \"IX\"\n\
    \    number -= 9\n  end\n  while number >= 5\n    roman += \"V\"\n    number -=\
    \ 5\n  end\n  while number >= 4\n    roman += \"IV\"\n    number -= 4\n  end\n\
    \  while number >= 1\n    roman += \"I\"\n    number -= 1\n  end\n  roman = roman.ljust(3,\
    \ \"I\")\n  roman = roman.ljust(6, \"V\")\n  roman = roman.ljust(9, \"X\")\n \
    \ roman = roman.ljust(12, \"L\")\n  roman = roman.ljust(15, \"C\")\n  roman =\
    \ roman.ljust(17, \"D\")\n  roman = roman.ljust(20, \"M\")\n  return roman\nend",
  '  return roman unless number.is_a?(Fixnum)', "  roman = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  roman = roman[1..-1] + (\"M\" * number)\n  roman = roman[1..-1] + (\"CM\"\
    \ * number)\n  roman = roman[1..-1] + (\"D\" * number)\n  roman = roman[1..-1]\
    \ + (\"CD\" * number)\n  roman = roman[1..-1] + (\"C\" * number)\n  roman = roman[1..-1]\
    \ + (\"XC\" * number)\n  roman = roman[1..-1] + (\"L\" * number)\n  roman = roman[1..-1]\
    \ + (\"XL\" * number)\n  roman = roman[1..-1] + (\"X\" * number)\n  roman = roman[1..-1]\
    \ + (\"IX\" * number)\n  roman = roman[1..-1] + (\"V\" * number)\n  roman = roman[1..-1]\
    \ + (\"IV\" * number)\n  roman = roman[1..-1] + (\"I\" * number)\n  return roman\n\
    end", "  roman = []\n  roman.push(\"i\")\n  roman.push(\"ii\")\n  roman.push(\"\
    iii\")\n  roman.push(\"iv\")\n  roman.push(\"v\")\n  roman.push(\"vi\")\n  roman.push(\"\
    vii\")\n  roman.push(\"viii\")\n  roman.push(\"ix\")\n  roman.push(\"x\")\n  roman.push(\"\
    xii\")\n  roman.push(\"xiii\")\n  roman.push(\"xiv\")\n  roman.push(\"xvi\")\n\
    \  roman.push(\"xvii\")\n  roman.push(\"xviii\")\n  roman.push(\"xix\")\n  roman.push(\"\
    xx\")\n  roman.push(\"xxx\")\n  roman.push(\"xxxx\")\n  roman.push(\"xxxxi\")\n\
    \  roman.push(\"xxxxii\")\n  roman.push(\"xxxxiii\")\n  roman.push(\"xxxxiv\"\
    )\n  roman.push(\"xxxxv\")\n  roman.push(\"xxxxvi\")\n  roman.push(\"xxxxvii\"\
    )\n  roman.push(\"xxxxviii\")\n  roman.push(\"xxxxix\")\n  roman.push(\"xxx\"\
    )\n  roman.push(\"xxxi\")\n  roman.push(\"xxxii\")\n  roman.push(\"xxxiv\")\n\
    \  roman.push(\"xxxiv\")\n  roman.push(\"xxxiv\")\n  roman.push(\"xxxv\")\n  roman.push(\"\
    xxxvi\")\n  roman.push(\"xxxvii\")\n  roman.push(\"xxxviii\")\n  roman.push(\"\
    xxxix\")\n  roman.push(\"x\")\n  roman.push(\"xi\")\n  roman.push(\"xii\")\n \
    \ roman.push(\"xiv\")\n  roman.push(\"xvi\")\n  roman.push(\"xvii\")\n  roman.push(\"\
    xviii\")\n  roman.push(\"xix\")\n  roman.push(\"xx\")\n  roman.push(\"xxx\")\n\
    \  roman.push(\"xxxx\")\n  roman.", "  number = number.to_i\n  roman = Array.new\n\
    \  roman.push(\"x\")\n  roman.push(\"ii\")\n  roman.push(\"iii\")\n  roman.push(\"\
    iv\")\n  roman.push(\"v\")\n  roman.push(\"vi\")\n  roman.push(\"vii\")\n  roman.push(\"\
    ix\")\n  roman.push(\"x\")\n  roman.push(\"x\")\n  roman.push(\"x\")\n  roman.push(\"\
    x\")\n  roman.push(\"x\")\n  roman.push(\"x\")\n  roman.push(\"x\")\n  roman.push(\"\
    x\")\n  roman.push(\"x\")\n  roman.push(\"x\")\n  roman.push(\"x\")\n  roman.push(\"\
    x\")\n  roman.push(\"x\")\n  roman.push(\"x\")\n  roman.push(\"x\")\n  roman.push(\"\
    x\")\n  roman.push(\"x\")\n  roman.push(\"x\")\n  roman.push(\"x\")\n  roman.push(\"\
    x\")\n  roman.push(\"x\")\n  roman.push(\"x\")\n  roman.push(\"x\")\n  roman.push(\"\
    x\")\n  roman.push(\"x\")\n  roman.push(\"x\")\n  roman.push(\"x\")\n  roman.push(\"\
    x\")\n  roman.push(\"x\")\n  roman.push(\"x\")\n  roman.push(\"x\")\n  roman.push(\"\
    x\")\n  roman.push(\"x\")\n  roman.push(\"x\")\n  roman.push(\"x\")\n  roman.push(\"\
    x\")\n  roman.push(\"x\")\n  roman.push(\"x\")\n  roman.push(\"x\")\n  roman.push(\"\
    x\")\n  roman.push(\"x\")\n  roman.push(\"x\")\n  roman.push(\"x\")\n  roman.push(\"\
    x\")\n  roman.push(\"x\")\n  roman.push(\"x\")\n  roman.push(\"x\")\n  ro", " \
    \ return unless number.is_a?(Integer) && number > 0 && number <= 1000\n  romans\
    \ = []\n  while number\n    romans.unshift(number % 100)\n    number -= 100\n\
    \  end\n  romans.reverse\n  romans.unshift(0)\n  romans.map { |i| roman_roman_table[i][0]\
    \ }.join(\"\")\nend\n</code>\n<|/ a dscore=3 tags=mini-language,ruby |>\n<| c\
    \ |>\nThis doesn't answer the question. The asker wants to know if there is a\
    \ way to get the roman numerals by looking them up in a hash. The answer was to\
    \ build a hash that does that.\n<|/ c |>\n<| c |>\nThis answer is wrong. The OP\
    \ wants to do what my answer does, but without the hash lookup.\n<|/ c |>\n<|\
    \ c |>\n, you're right. Now it does.\n<|/ c |>\n<| a dscore=3 tags=mini-language,ruby\
    \ |>\nA small variant on Alex's answer.\n<code>", "  # Handle special cases\n\
    \  if number <= 1\n    \"x\"\n  elsif number <= 3999\n    mini_roman = \"x\"\n\
    \  elsif number <= 5000\n    mini_roman = \"c\" + roman_numeral_to_mini_roman(number\
    \ / 100) + \"x\"\n  elsif number <= 26000\n    mini_roman = roman_numeral_to_mini_roman(number\
    \ / 10) + \"c\" + roman_numeral_to_mini_roman(number % 10)\n  else\n    # Romans\
    \ up to and including 27999 can be written using at most 3 mini-romans.\n    roman_numbers\
    \ = []\n    roman_numbers.push(roman_numeral_to_mini_roman(number / 100));\n \
    \   roman_numbers.push(roman_numeral_to_mini_roman(number / 10));\n    roman_numbers.push(roman_numeral_to_mini_roman(number\
    \ % 10));\n    roman_numbers.reverse;\n    roman_numbers.each do |numeral|\n \
    \     if number <= 3999\n        mini_roman = \"c\" + numeral + \"x\"\n      elsif\
    \ number <= 5000\n        mini_roman = \"c\" + numeral + \"x\"\n      elsif number\
    \ <= 26000\n        mini_roman = \"c\" + numeral + \"x\"\n      else\n       \
    \ # Romans up to and including 27999 can be written using at most 3 mini-romans.\n\
    \        mini_roman = \"x\" + numeral\n      end\n      if mini_roman != roman_numeral_to_mini_roman(number\
    \ % 10)\n        break\n      end\n    end\n  end\n  # Lowercase and return\n\
    \  mini_roman.downcase\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI wrote a Python\
    \ program to test this, which I found was slightly faster than the Ruby implementation.\
    \ But I don't like how I used `puts` so I changed it. I used `puts` here to show\
    \ the results of multiple runs of the code. Using `puts` would be slower without\
    \ it.\n<|/ c |>\n<| c |>\nNice. Thank you, I will have to try this out tomorrow.\
    \ I think I'll get my work done today.\n<|/ c |>\n<| c |>\nThis looks very good!\
    \ I might need some time to digest the logic, but I'll be back in a few days with\
    \ the results.\n<|/ c |>\n<| c |>\n", '  roman = Array.new', "  return mini_roman(number)\n\
    end", "  roman = \"\"\n  for i in (100..99)\n    roman = roman + i.to_s.rjust(1,\
    \ \"_\").gsub(/_(.)$/, '\\1')\n  end\n  roman = roman + \"i\" * (100 - number)\n\
    \  return roman\nend", "  roman = \"MCMXC\"\n  roman = roman.chars.to_a\n  roman.map!\
    \ { |c| c.to_s.upcase }", "  return roman_to_int(number_to_roman(number))\nend",
  "  roman = \"\"\n  if number == 0 || number == 1 || number == 2 || number == 3 ||\
    \ number == 4 || number == 5 || number == 6\n    roman = \"mfm\"\n  elsif number\
    \ == 7\n    roman = \"md\"\n  elsif number == 8\n    roman = \"dx\"\n  elsif number\
    \ == 9\n    roman = \"cm\"\n  elsif number == 10\n    roman = \"x\"\n  elsif number\
    \ == 11\n    roman = \"b\"\n  elsif number == 12\n    roman = \"v\"\n  elsif number\
    \ == 13\n    roman = \"n\"\n  elsif number == 14\n    roman = \"m\"\n  elsif number\
    \ == 15\n    roman = \"l\"\n  elsif number == 16\n    roman = \"s\"\n  elsif number\
    \ == 17\n    roman = \"d\"\n  elsif number == 18\n    roman = \"r\"\n  elsif number\
    \ == 19\n    roman = \"f\"\n  elsif number == 20\n    roman = \"vd\"\n  elsif\
    \ number == 30\n    roman = \"xc\"\n  elsif number == 40\n    roman = \"cc\"\n\
    \  elsif number == 50\n    roman = \"m\"\n  elsif number == 60\n    roman = \"\
    lc\"\n  elsif number == 70\n    roman = \"xl\"\n  elsif number == 80\n    roman\
    \ = \"xb\"\n  elsif number == 90\n    roman = \"xr\"\n  elsif number == 100\n\
    \    roman = \"xb\"\n  else\n    roman = \"xb\"\n  end\n  roman = roman.upcase\n\
    \  roman\nend", "  roman_number = Array.new\n  number.times do |i|\n    roman_number[i]\
    \ = [1000, 'M', 'MM', 'MMM'][(i * 10) % 10]\n  end\n  roman_number.join.gsub!(/1$/,\
    \ '')\n  roman_number.join\nend\n</code>\nThis solution is not the most elegant,\
    \ but it does work for the tests. Feel free to suggest improvements.\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-4,rubygems,ruby-on-rails-3\
    \ |>\n<| a dscore=2 tags=ruby,ruby-on-rails,ruby-on-rails-4,rubygems,ruby-on-rails-3\
    \ |>\nHere is my solution using Rails ActiveSupport::Concern:\n<code>\nmodule\
    \ IntToMiniRoman\n  extend ActiveSupport::Concern", "  number_roman = number_to_roman(number)\n\
    \  if number_roman == \"1000\"\n    \"x\"\n  else\n    roman_numeral = roman_to_number(number_roman)\n\
    \    roman_numeral.upcase!\n    roman_numeral.gsub(/[\\s-]+/, \"\")\n  end\nend",
  "  if number == 0\n    \"0\"\n  else\n    roman = []\n    roman = roman.concat(convert_int_to_roman(number)).join(\"\
    \")\n    return roman\nend", "  roman_numerals = Array.new(10)\n  roman_numerals\
    \ << \"\"\n  roman_numerals << \"c\"\n  roman_numerals << \"l\"\n  roman_numerals\
    \ << \"x\"\n  roman_numerals << \"d\"\n  roman_numerals << \"m\"\n  roman_numerals\
    \ << \"n\"\n  roman_numerals << \"k\"\n  roman_numerals << \"h\" \n  roman_numerals\
    \ << \"v\" \n  roman_numerals << \"i\"\n  roman_numerals << \"x\"\n  roman_numerals\
    \ << \"l\"\n  roman_numerals << \"c\"\n  roman_numerals << \"d\"\n  roman_numerals\
    \ << \"m\"\n  roman_numerals << \"n\"\n  roman_numerals << \"k\"\n  roman_numerals\
    \ << \"h\"\n  roman_numerals << \"v\"\n  roman_numerals << \"i\"\n  roman_numerals\
    \ << \"x\"\n  roman_numerals << \"l\"\n  roman_numerals << \"c\"\n  roman_numerals\
    \ << \"d\"\n  roman_numerals << \"m\"\n  roman_numerals << \"n\"\n  roman_numerals\
    \ << \"k\"\n  roman_numerals << \"h\"\n  roman_numerals << \"v\"\n  roman_numerals\
    \ << \"i\"\n  roman_numerals << \"x\"\n  roman_numerals << \"l\"\n  roman_numerals\
    \ << \"c\"\n  roman_numerals << \"d\"\n  roman_numerals << \"m\"\n  roman_numerals\
    \ << \"n\"\n  roman_numerals << \"k\"\n  roman_numerals << \"h\"\n  roman_numerals\
    \ << \"v\"\n  roman_numerals << \"i\"\n  roman_numerals << \"x\"\n  roman_numerals\
    \ << \"l\"\n  roman_numerals << \"c\"\n  roman_numerals << \"d\"\n  roman_numerals\
    \ << \"m\"\n  roman_numerals << \"n\"\n  roman_numerals << \"k\"\n  roman_numerals\
    \ << \"h\"\n  roman_numerals << \"v\"\n  roman_numerals << \"i\"\n  roman_numerals\
    \ << \"", "  if number < 1 or number > 1000\n    raise ArgumentError, \"Integer\
    \ must be between 1 and 1000\"\n  roman_numeral = ''\n  digits = number.to_s.split(//).map{\
    \ |i| i.to_i }\n  digits.each do |digit|\n    roman_numeral += (10**(digit-1)*digit)\n\
    \  end\n  return roman_numeral.downcase\nend", '  roman = Array.new', "  roman\
    \ = \"\"\n  while number > 0\n    if number % 100 == 0\n      roman += \"M\"\n\
    \      number /= 100\n    elsif number % 10 == 0\n      roman += \"CM\"\n    \
    \  number /= 10\n    else\n      roman += \"D\"\n      number /= 10\n    end\n\
    \    \n    roman += \"C\"\n    number /= 10\n  end\n  \n  if number > 0\n    if\
    \ number % 10 == 0\n      roman += \"XC\"\n      number /= 10\n    else\n    \
    \  roman += \"L\"\n      number /= 10\n    end\n    \n    roman += \"X\"\n   \
    \ number /= 10\n  end\n  \n  if number > 0\n    if number % 10 == 0\n      roman\
    \ += \"IX\"\n      number /= 10\n    else\n      roman += \"V\"\n      number\
    \ /= 10\n    end\n    \n    roman += \"IV\"\n    number /= 10\n  end\n  \n  \n\
    \  return roman\nend", "  roman = \"\"\n  roman_digit = 0\n  while number > 0\n\
    \    if number % 1000 == 0\n      roman_digit = roman_digit + 1\n      roman =\
    \ roman + \"M\" * roman_digit\n      roman_digit = 0\n    end\n    number = number\
    \ % 1000\n    roman_digit = roman_digit + 1\n    roman = roman + \"C\" * roman_digit\
    \ + roman.slice(roman.size - roman_digit)\n  end\n  return roman.upcase\nend",
  "  # Find out what number modulo 100 it is to determine how many times\n  # to iterate\
    \ through and apply the mapping function\n  mapping = {0 => \"M\", 1 => \"CM\"\
    , 2 => \"D\", 3 => \"CD\",\n             4 => \"C\", 5 => \"XC\", 6 => \"L\",\
    \ 7 => \"XL\",\n             8 => \"X\", 9 => \"IX\", 10 => \"V\", 11 => \"IV\"\
    ,\n             12 => \"I\"}\n  roman = \"M\"\n  num_mod = number%100\n  num_mod\
    \ = num_mod if num_mod < 20 else 99\n  num_mod = num_mod if num_mod < 10 else\
    \ 999", "  roman = \"C\"\n  rest = number\n  while rest > 0 do\n    roman, last\
    \ = romans[roman], roman\n    number, rest = rest, number - last\n  end\n  return\
    \ romans[roman]\nend", "  # Convert to roman numerals.\n  roman =\n    (\n   \
    \   # The first 12 romans are uncommon, so omit them.\n      (\n        [\"M\"\
    ,  \"MM\", \"MMM\",  \"MMMM\",  \"MMMMM\", \"MMMMMM\", \"MMMMMMM\",  \"MMMMMMMM\"\
    ,  \"MMMMMMMMM\", \"MMMMMMMMMM\", \"MMMMMMMMMMM\"],\n        [\"MMM\", \"MMMM\"\
    , \"MMMMM\"]\n      )[number % 100]\n      # All other roman numerals are just\
    \ roman numerals times 10.\n      + [\"M\",  \"MM\", \"MMM\",  \"MMMM\",  \"MMMMM\"\
    , \"MMMMMM\", \"MMMMMMM\",  \"MMMMMMMM\",  \"MMMMMMMMM\", \"MMMMMMMMMM\", \"MMMMMMMMMMM\"\
    ]\n      * (number / 100).to_i\n    ).tolower()\n  # If there are no common romans,\
    \ add an \"i\" to the end.\n  roman = [roman] unless roman.include?(\"i\")\n \
    \ # Add roman numerals to result.\n  result = roman.map { |r| r.to_s.ljust(2,\
    \ \"0\") }.join(\"\")\n  # Add \"i\".\n  result += \"i\"\n  # Return result.\n\
    \  result\nend", "  int_to_roman(number)\n  number.to_s.gsub!(/[0-9](?=\\d)/,\
    \ 'x')\nend", "  roman = Array.new\n  roman[0] = 'M'\n  roman[1] = 'CM'\n  roman[2]\
    \ = 'D'\n  roman[3] = 'CD'\n  roman[4] = 'C'\n  roman[5] = 'XC'\n  roman[6] =\
    \ 'L'\n  roman[7] = 'XL'\n  roman[8] = 'X'\n  roman[9] = 'IX'\n  roman[10] = 'V'\n\
    \  roman[11] = 'IV'\n  roman[12] = 'I'\n  roman[13] = 'III'\n  roman[14] = 'VI'\n\
    \  roman[15] = 'II'\n  roman[16] = 'IV'\n  roman[17] = 'V'\n  roman[18] = 'IV'\n\
    \  roman[19] = 'IX'\n  roman[20] = 'X'", "  return \"XXX\" + int_to_roman.call(number)\n\
    end", "  if number < 1 or number > 1000\n    puts <<-EOF\n    Error: Invalid number\
    \ given. Number should be between 1 and 1000\n    EOF\n    return nil\n  end\n\
    \  roman = Array.new\n  roman.push('m')\n  roman.push('c')\n  roman.push('d')\n\
    \  roman.push('l')\n  roman.push('xl')\n  roman.push('l')\n  roman.push('xcvi')\n\
    \  roman.push('v')\n  roman.push('vi')\n  roman.push('vi')\n  roman.push('viii')\n\
    \  roman.push('vii')\n  roman.push('vi')\n  roman.push('vi')\n  roman.push('vi')\n\
    \  roman.push('vi')\n  roman.push('vi')\n  roman.push('vi')\n  roman.push('vii')\n\
    \  roman.push('vii')\n  roman.push('vii')\n  roman.push('vii')\n  roman.push('vii')\n\
    \  roman.push('vi')\n  roman.push('vi')\n  roman.push('vi')\n  roman.push('vi')\n\
    \  roman.push('vi')\n  roman.push('vi')\n  roman.push('vi')\n  roman.push('vi')\n\
    \  roman.push('vi')\n  roman.push('vi')\n  roman.push('vi')\n  roman.push('vi')\n\
    \  roman.push('vi')\n  roman.push('vi')\n  roman.push('vi')\n  roman.push('vii')\n\
    \  roman.push('vi')\n  roman.push('vi')\n  roman.push('vi')\n  roman.push('vi')\n\
    \  roman.push('vi')\n  roman.push('vii')\n  roman.push('vii')\n  roman.push('vii')\n\
    \  roman.push('vii')\n  roman.push('vii')\n  roman.push('vii')\n  roman.push('vii')\n\
    \  roman.push('vii')\n  roman.push('vii')\n  roman.push('vii')\n  roman.push('vii')\n\
    \  roman.push('vii')\n  ro", "  return roman(number)\nend", "  return to_mini_roman(number)\n\
    end", "  roman = \"\"\n  roman = roman.to_s # this is necessary in Ruby 1.9, maybe\
    \ 1.8 doesn't require this.\n  roman = roman + roman.to_i.to_s.reverse # reverse\
    \ the integer into its Roman numeral\n  roman = roman + roman.to_s[-number.to_s.size..-1]\
    \ # reverse the last number in the Roman numeral\n  roman = roman + roman.to_i.to_s.reverse\
    \ # reverse the integer into its Roman numeral\n  roman = roman + roman.to_s[-number.to_s.size..-1]\
    \ # reverse the last number in the Roman numeral\n  roman = roman + roman.to_i.to_s.reverse\
    \ # reverse the integer into its Roman numeral\n  roman = roman + roman.to_s[-number.to_s.size..-1]\
    \ # reverse the last number in the Roman numeral\n  return roman\nend", "  number_str\
    \ = number.to_s\n  number_str.gsub!('I', 'x')\n  number_str.gsub!('V', 'c')\n\
    \  number_str.gsub!('L', 'l')\n  number_str.gsub!('X', 'x')\n  number_str.gsub!('C',\
    \ 'c')\n  number_str.gsub!('D', 'd')\n  number_str.gsub!('M', 'm')\n  number_str.gsub!('L',\
    \ 'l')\n  number_str.gsub!('X', 'x')\n  number_str.gsub!('C', 'c')\n  number_str.gsub!('M',\
    \ 'm')\n  number_str.gsub!('V', 'v')\n  number_str.gsub!('I', 'i')\n  number_str.gsub!('X',\
    \ 'x')\n  number_str.gsub!('C', 'c')\n  number_str.gsub!('M', 'm')\n  number_str.gsub!('V',\
    \ 'v')\n  number_str.gsub!('I', 'i')\n  number_str.gsub!('X', 'x')\n  number_str.gsub!('V',\
    \ 'v')\n  number_str.gsub!('I', 'i')\n  number_str.gsub!('I', 'i')\n  number_str.gsub!('I',\
    \ 'i')\n  number_str.gsub!('I', 'i')\n  number_str.gsub!('I', 'i')\n  number_str.gsub!('I',\
    \ 'i')\n  number_str.gsub!('I', 'i')\n  number_str.gsub!('I', 'i')\n  number_str.gsub!('I',\
    \ 'i')\n  number_str.gsub!('I', 'i')\n  number_str.gsub!('I', 'i')\n  number_str.gsub!('I',\
    \ 'i')\n  number_str.gsub!('I', 'i')\n  number_str.gsub!('I', 'i')\n  number_str.gsub!('I',\
    \ 'i')\n  number_str.gsub!('I', 'i')\n  number_str.gsub!('I', 'i')\n  number_str.gsub!('I',\
    \ 'i')\n  number_str.gsub!('I', 'i')\n  number_str.gsub!('I', 'i')\n  number_str.gsub!('I',\
    \ 'i')\n  number_str.gsub!('I', 'i')\n  number_str.gsub!('I', 'i')\n  number_str.gsub!('I',\
    \ 'i')\n  number_str.gsub!('I', 'i')\n  number_str.gsub!('I', '", "  if number.to_s.length\
    \ == 0 then\n    return\n  end\n  roman = \"\"\n  remainder = number\n  while\
    \ remainder > 0 do\n    roman = roman.concat(\"M\")\n    remainder = remainder\
    \ - 10\n  end\n  while number > 0 do\n    if number % 2 == 1 then\n      roman\
    \ = roman.concat(\"D\")\n    else\n      roman = roman.concat(\"C\")\n    end\n\
    \    number = number / 2\n  end\n  if roman.length < 3 then\n    roman = roman.concat(\"\
    M\")\n  end\n  if roman.length < 4 then\n    roman = roman.concat(\"CM\")\n  end\n\
    \  if roman.length < 5 then\n    roman = roman.concat(\"D\")\n  end\n  if roman.length\
    \ < 6 then\n    roman = roman.concat(\"CD\")\n  end\n  if roman.length < 7 then\n\
    \    roman = roman.concat(\"C\")\n  end\n  if roman.length < 8 then\n    roman\
    \ = roman.concat(\"XC\")\n  end\n  if roman.length < 9 then\n    roman = roman.concat(\"\
    L\")\n  end\n  if roman.length < 10 then\n    roman = roman.concat(\"XL\")\n \
    \ end\n  if roman.length < 11 then\n    roman = roman.concat(\"X\")\n  end\n \
    \ if roman.length < 12 then\n    roman = roman.concat(\"IX\")\n  end\n  if roman.length\
    \ < 13 then\n    roman = roman.concat(\"V\")\n  end\n  if roman.length < 14 then\n\
    \    roman = roman.concat(\"IV\")\n  end\n  if roman.length < 15 then\n    roman\
    \ = roman.concat(\"I\")\n  end\n  if roman.length < 16 then\n    roman = roman.concat(\"\
    II\")\n  end\n  if roman.length < 17 then\n    roman = roman.concat(\"III\")\n\
    \  end\n  if roman.length < 18 then\n    roman = roman.concat(\"IV\")\n  end\n\
    \  if roman.length < 19 then\n    roman = roman.concat(\"V\")\n  end\n  if roman.length\
    \ < 20 then\n    roman = roman.concat(\"I\")\n  end\n  if roman.length < 21 then\n\
    \    roman = ", "  return \"\" if (number < 1) || (number > 1000) else roman_numeral_translation[number]\n\
    end", "  roman = int_to_roman.call(number)\n  roman.downcase!\n  roman\nend",
  "  number = to_number(number)\n  return int_to_roman(number)\nend", "  roman = \"\
    -\"\n  i = number\n  while i >= 1000\n    i /= 1000\n    roman += \"M\"\n  end\n\
    \  while i >= 100\n    i /= 100\n    roman += \"CM\"\n  end\n  while i >= 10\n\
    \    i /= 10\n    roman += \"D\"\n  end\n  while i >= 1\n    i /= 1\n    roman\
    \ += \"CD\"\n  end\n  return roman.insert(0, \"0\") + to_roman_numeral(number)\n\
    end", "  numbers = [nil] * 10\n  roman_numerals = [nil] * 10\n  i = 10\n  while\
    \ number\n    numbers[i] = number%10\n    number = number / 10\n    i += 1\n \
    \ end\n  i = 9\n  while numbers\n    roman_numerals[10-numbers[i]] = roman_numerals[10-i]\
    \ = i+1\n    numbers[i] = nil\n    i += 1\n  end\n  return roman_numerals.map{|n|\
    \ n==nil ? \"\" : n.to_s}.join\nend", "  roman = \"IVXLCDM\"\n  i = number-1\n\
    \  ret = \"\"\n  while i > 0 do\n    ret << roman[i]\n    i -= 1\n  end\n  ret\n\
    end", "  number = number.to_i\n  return mini_roman[number] if number < mini_roman.size\
    \ && number > 0 &&\n  number < 1000 && number > -1000\nend", "  roman = Array.new(5,\
    \ \"i\")\n  roman[0..2].concat(Array.new(3 - (number % 3), \"x\"))\n  roman[3..-1].concat(Array.new(number\
    \ % 3, \"l\"))\n  roman.join(\"\").downcase!\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| a dscore=0 |>\n<code>", "  if number < 1 or number > 1000\n    raise ArgumentError\n\
    \  roman = Array.new\n  roman[0] = \"M\"\n  roman[1] = \"CM\"\n  roman[2] = \"\
    D\"\n  roman[3] = \"CD\"\n  roman[4] = \"C\"\n  roman[5] = \"XC\"\n  roman[6]\
    \ = \"L\"\n  roman[7] = \"XL\"\n  roman[8] = \"X\"\n  roman[9] = \"IX\"\n  roman[10]\
    \ = \"V\"\n  roman[11] = \"IV\"\n  roman[12] = \"I\"\n  roman[13] = \"IU\"\n \
    \ roman[14] = \"MU\"\n  roman[15] = \"MMM\"\n  roman[16] = \"MMMM\"\n  roman[17]\
    \ = \"MMMMM\"\n  roman[18] = \"MMMMMM\"\n  roman[19] = \"MMMMMMM\"\n  roman[20]\
    \ = \"MMMMMMMM\"\n  roman[21] = \"MMMMMMMMM\"\n  roman[22] = \"MMMMMMMMMM\"\n\
    \  roman[23] = \"MMMMMMMMMMM\"\n  roman[24] = \"MMMMMMMMMMMM\"\n  roman[25] =\
    \ \"MMMMMMMMMMMMM\"\n  roman[26] = \"MMMMMMMMMMMMMM\"\n  roman[27] = \"MMMMMMMMMMMMMMM\"\
    \n  roman[28] = \"MMMMMMMMMMMMMMMM\"\n  roman[29] = \"MMMMMMMMMMMMMMMMM\"\n  roman[30]\
    \ = \"MMMMMMMMMMMMMMMMMM\"\n  roman[31] = \"MMMMMMMMMMMMMMMMMMM\"\n  roman[32]\
    \ = \"XIV\"\n  roman[33] = \"XVI\"\n  roman[34] = \"XVII\"\n  roman[35] = \"XVIII\"\
    \n  roman[36] = \"XIX\"\n  roman[37] = \"XX\"\n  roman[38] = \"XXX\"\n  roman[39]\
    \ = \"XL\"\n  roman[40] = \"LXXX\"\n  roman[41] = \"LX\"\n  roman[42] = \"LXXXI\"\
    \n  roman[43] = \"LXXII\"\n  roman[44] = \"LXXIII\"\n  roman[45] = \"LXXIV\"\n\
    \  roman[46] = \"LXXV\"\n  roman[47] = \"LXXVI\"\n  roman[48] = \"LXXV", "  roman\
    \ = \"-\"\n  numeral = number.to_s\n  roman_numeral = Array(0..999).map do |n|\n\
    \    roman = roman.succ\n    numeral = numeral.split(\"\").map do |c|\n      RomanNumeralMap[c]\
    \ ? RomanNumeralMap[c].to_s : c\n    end.join(\"\")\n    roman.succ\n  end\n \
    \ mini_roman = roman_numeral.join(\"\")\n  mini_roman.downcase\nend\n</code>\n\
    <|/ a |>\n<| a dscore=0 |>\nThis is based on Jonas' answer, but fixes the problem\
    \ of not being able to input a decimal value and instead allows for a different\
    \ roman numeral system. \n<code>", "  return roman_to_int(to_mini_roman(number))\n\
    end", "  return \"XXXIV\"[number]\nend", "  mini_roman = \"\"\n  roman_numbers\
    \ = {\n    \"I\" : 1,\n    \"V\" : 5,\n    \"X\" : 10,\n    \"L\" : 50,\n    \"\
    C\" : 100,\n    \"D\" : 500,\n    \"M\" : 1000\n  }\n  \n  while number > 0\n\
    \    if number >= 100\n      number -= 100\n      mini_roman += \"C\"\n    else\n\
    \      number -= roman_numbers[@(number / 10) * 10]\n      mini_roman += \"M\"\
    \n    end\n  end", "  # Handle non-positive integers gracefully\n  if number.zero?\n\
    \    return ''\n  elsif number < 1\n    raise ArgumentError, \"argument must be\
    \ positive\"\n  end\n  roman = roman_numeral(number).downcase\n  res = []\n  roman.scan(/../)\
    \ do |x|\n    char, rest = x\n    char = char.upcase if char == \"M\"\n    res\
    \ << char\n    res << rest unless rest.empty?\n  end\n  res\nend", "  roman_numerals\
    \ = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\"\
    , \"V\", \"IV\", \"I\"]\n  roman_numeral_digits = [\"I\", \"II\", \"III\", \"\
    IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"XIII\"\
    , \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\"]\n  roman_numeral_digit_to_roman\
    \ = {\n    \"M\"=>1000,\n    \"CM\"=>900,\n    \"D\"=>500,\n    \"CD\"=>400,\n\
    \    \"C\"=>100,\n    \"XC\"=>90,\n    \"L\"=>50,\n    \"XL\"=>40,\n    \"X\"\
    =>10,\n    \"IX\"=>9,\n    \"V\"=>5,\n    \"IV\"=>4,\n    \"I\"=>1\n  }\n  roman_numeral_digit.reverse!\n\
    \  roman_numeral.reverse!\n  roman_numeral_digit.reverse!\n  if number == 0\n\
    \    \"0\"\n  else\n    roman_numerals.each do |roman_numeral|\n      while number\
    \ >= roman_numeral_digit_to_roman[roman_numeral]\n        number -= roman_numeral_digit_to_roman[roman_numeral]\n\
    \        roman_numeral += roman_numerals[roman_numerals.index{|r| r == roman_numeral}]\n\
    \      end\n      if roman_numeral.length == 0 #roman_numeral is empty\n     \
    \   break\n      end\n      roman_numeral_digit.reverse!\n      roman_numeral_digit.reverse!\n\
    \      roman_numeral_digit.reverse!\n      if roman_numeral == roman_numerals[roman_numerals.index{|r|\
    \ r == roman_numeral}]\n        roman_numeral_digit.reverse!\n      else\n   \
    \     roman_numeral_digit_to_roman[roman_numerals[roman_numerals.index{|r| r ==\
    \ roman_numeral}]] += roman_numeral_digit.index{|r| r == roman_numeral}\n    \
    \  end\n    end\n    roman_numerals.reverse!\n    roman_numeral.reverse!\n  end\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThank you for taking the time to write\
    \ such a detailed answer, but I'm afraid your code is still ", "  return number.to_s.chars.map\
    \ do |i|\n    case i\n    when 0..9\n      \"x\"\n    when 10..40\n      \"c\"\
    \n    when 41..59\n      \"l\"\n    when 60..79\n      \"xl\"\n    when 80..100\n\
    \      \"xc\"\n    else\n      i.to_s.chars.map { |j| j == \"0\" ? \"m\" : j }.join\n\
    \    end\n  end.join(\"\")\nend", "  roman = []\n  roman_vals = %w[m \"\"]\n \
    \ (1..1000).each do |i|\n    if number >= i then\n      digit = number - i\n \
    \     roman = roman_vals.map { |s| s << digit }.join(\"\").downcase\n      break\n\
    \    end\n  end\n  return roman\nend", "  roman = Array.new(number, 0).join\n\
    \  roman.split(//).each do |num|\n    digit = num.to_s.rjust(3, '0')\n    roman.index(digit)\
    \ ? (roman[roman.index(digit)] + num[roman.index(digit)]).rjust(4, '0') : roman[roman.index(digit)]\
    \ = num\n  end\n  roman.split(//).join\nend\n</code>\n<|/ a tags=minify,ruby dscore=0\
    \ |>\n<| c |>\nThis is a nice answer. Just wondering, what does the question mark\
    \ represent? `roman.index(digit) ?` What does it do?\n<|/ c |>\n<| c |>\nThis\
    \ is a conditional operator, similar to ternary operators in other languages.\
    \ http://en.wikipedia.org/wiki/Ternary_operation\n<|/ c |>\n<| a dscore=0 tags=minify,ruby\
    \ |>\n<code>", "  str_roman = roman_to_int(number)\n  return str_roman.downcase\n\
    end", "  int_to_roman(number, \"\")\nend", "  roman = Array.new\n  roman[0] =\
    \ '' # (empty string)\n  roman[1] = 'I' # (1)\n  roman[2] = 'II' # (2)\n  roman[3]\
    \ = 'III' # (3)\n  roman[4] = 'IV' # (4)\n  roman[5] = 'V' # (5)\n  roman[6] =\
    \ 'VI' # (6)\n  roman[7] = 'VII' # (7)\n  roman[8] = 'VIII' # (8)\n  roman[9]\
    \ = 'IX' # (9)\n  roman[10] = 'X' # (10)\n  roman[11] = 'XI' # (11)\n  roman[12]\
    \ = 'XII' # (12)\n  roman[13] = 'XIII' # (13)\n  roman[14] = 'XIV' # (14)\n  roman[15]\
    \ = 'XV' # (15)\n  roman[16] = 'XVI' # (16)\n  roman[17] = 'XVII' # (17)\n  roman[18]\
    \ = 'XVIII' # (18)\n  roman[19] = 'XIX' # (19)\n  roman[20] = 'XX' # (20)\n  roman[21]\
    \ = 'XXI' # (21)\n  roman[22] = 'XXII' # (22)\n  roman[23] = 'XXIII' # (23)\n\
    \  roman[24] = 'XXIV' # (24)\n  roman[25] = 'XXV' # (25)\n  roman[26] = 'XXVI'\
    \ # (26)\n  roman[27] = 'XXVII' # (27)\n  roman[28] = 'XXVIII' # (28)\n  roman[29]\
    \ = 'XXIX' # (29)\n  roman[30] = 'XXX' # (30)\n  roman[31] = 'XXXI' # (32)\n \
    \ roman[32] = 'XXXII' # (33)\n  roman[33] = 'XXXIII' # (34)\n  roman[34] = 'XXXIV'\
    \ # (35)\n  roman[35] = 'XXXV' # (36)\n  roman[36] = 'XXXVI' # (37)\n  roman[37]\
    \ = 'XXXVII' # (38)\n  roman[38] = 'XXXVIII' # (39)\n  roman[39] = 'XXIX' # (39)\n\
    \  roman[40] = 'XXX' # (40)\n  roman[41] = 'XXXI' # (44", "  roman = Array.new\n\
    \  number = number.to_i\n  roman = roman.push(\"x\" * number)\n  roman.push(\"\
    i\" * (number - 1))\n  roman.push(\"v\" * (number - 2))\n  roman.push(\"l\" *\
    \ (number - 3))\n  roman.push(\"c\" * (number - 4))\n  roman.push(\"d\" * (number\
    \ - 5))\n  roman.push(\"m\" * (number - 6))\n  roman.push(\"n\" * (number - 7))\n\
    \  roman.push(\"x\" * (number - 8))\n  roman.push(\"l\" * (number - 9))\n  roman.push(\"\
    c\" * (number - 10))\n  roman.push(\"m\" * (number - 11))\n  roman.push(\"n\"\
    \ * (number - 12))\n  roman.push(\"x\" * (number - 13))\n  roman.push(\"l\" *\
    \ (number - 14))\n  roman.push(\"c\" * (number - 15))\n  roman.push(\"m\" * (number\
    \ - 16))\n  roman.push(\"n\" * (number - 17))\n  roman.push(\"x\" * (number -\
    \ 18))\n  roman.push(\"l\" * (number - 19))\n  roman.push(\"c\" * (number - 20))\n\
    \  roman.push(\"m\" * (number - 21))\n  roman.push(\"n\" * (number - 22))\n  roman.push(\"\
    x\" * (number - 23))\n  roman.push(\"l\" * (number - 24))\n  roman.push(\"c\"\
    \ * (number - 25))\n  roman.push(\"m\" * (number - 26))\n  roman.push(\"n\" *\
    \ (number - 27))\n  roman.push(\"x\" * (number - 28))\n  roman.push(\"l\" * (number\
    \ - 29))\n  roman.push(\"c\" * (number - 30))\n  roman.push(\"m\" * (number -\
    \ 31))\n  roman.push(\"n\" * (number - 32))\n  roman.push(\"x\" * (number - 33))\n\
    \  roman.push(\"l\" * (number - 34))\n  roman.push(\"c\" * (number - 35))\n  roman.push(\"\
    m\" * (number - 36))\n", "  return to_mini_roman(number)\nend", "  mini_roman\
    \ = \"\"\n  while number > 0\n    mini_rand = number % 37 # Mini random from 0\
    \ to 36\n    number = number / 37 # Integer division\n    mini_roman += \"M\"\n\
    \    if mini_rand == 0\n      mini_roman += \"C\"\n      number = number / 10\n\
    \      mini_roman += \"L\"\n      number = number / 10\n      mini_roman += \"\
    X\"\n      number = number / 10\n      mini_roman += \"V\"\n    else\n      if\
    \ mini_rand < 9\n        mini_roman += \"I\"\n        number = number / 10\n \
    \     else\n        if mini_rand < 17\n          mini_roman += \"V\"\n       \
    \   number = number / 10\n        else\n          if mini_rand < 27\n        \
    \    mini_roman += \"X\"\n            number = number / 10\n          else\n \
    \           mini_roman += \"L\"\n            number = number / 10\n          end\n\
    \        end\n      end\n    end\n  end\n  mini_roman.downcase!\n  return mini_roman\n\
    end", "  roman = Array.new\n  roman.push(*[\" \"]*7)\n  roman.push(*[\"\",\"M\"\
    ,\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"\
    ])\n  roman.push(*[\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\"\
    ,\"IX\",\"X\",\"XX\"])\n  roman.push(*[\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\"\
    ,\"DC\",\"DCC\",\"DCCC\",\"CM\",\"M\",\"MM\",\"MMM\"])\n  roman.each do |num|\n\
    \    roman_index = 0\n    while number >= num\n      roman_index += 1\n      number\
    \ -= num\n    end\n    roman_index -= 3\n    roman[roman_index] += \"M\" if roman_index\
    \ > 0\n    roman[roman_index] += \"C\" if roman_index > 1\n    roman[roman_index]\
    \ += \"D\" if roman_index > 2\n    roman[roman_index] += \"L\" if roman_index\
    \ > 3\n    roman[roman_index] += \"X\" if roman_index > 4\n    roman[roman_index]\
    \ += \"V\" if roman_index > 5\n    roman[roman_index] += \"I\" if roman_index\
    \ > 6\n  end\n  roman.join\nend", '  return roman_to_mini_roman(to_roman(number))',
  "  roman = %w(m l c d x v)\n  roman.each do |rom|\n    number = number / rom.to_i\n\
    \    return roman if number == 0\n  end\nend", "  if number <= 0\n    puts \"\
    Invalid argument: #{number.inspect}\"\n  elsif number <= 100\n    mini_roman =\
    \ \"x\"\n  elsif number <= 500\n    mini_roman = \"C\"\n  elsif number <= 1000\n\
    \    mini_roman = \"D\"\n  else\n    mini_roman = \"M\"\n  end", "  roman_to_int\
    \ = { \"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\"\
    : 1000 }\n  numbers = (number * [roman_to_int]).floor\n  min_roman = numbers.to_s.roman\n\
    \  min_roman[0] = min_roman[0].upcase\n  min_roman\nend", "  number = number.to_i\n\
    \  romans = []\n  romans << [\"c\", \"c\", \"l\", \"l\", \"i\"]\n  romans << [\"\
    d\", \"d\", \"l\", \"l\", \"i\"]\n  romans << [\"c\", \"c\", \"l\", \"i\", \"\
    i\"]\n  romans << [\"c\", \"c\", \"l\", \"v\", \"i\"]\n  romans << [\"c\", \"\
    c\", \"l\", \"l\", \"x\"]\n  romans << [\"c\", \"c\", \"l\", \"d\", \"x\"]\n \
    \ romans << [\"c\", \"c\", \"l\", \"v\", \"x\"]\n  romans << [\"c\", \"c\", \"\
    l\", \"l\", \"c\"]\n  romans << [\"c\", \"c\", \"l\", \"d\", \"c\"]\n  romans\
    \ << [\"c\", \"c\", \"l\", \"v\", \"c\"]\n  romans << [\"c\", \"c\", \"l\", \"\
    l\", \"m\"]\n  romans << [\"c\", \"c\", \"l\", \"d\", \"m\"]\n  romans << [\"\
    c\", \"c\", \"l\", \"v\", \"m\"]\n  romans << [\"c\", \"c\", \"l\", \"l\", \"\
    i\"]\n  romans << [\"c\", \"c\", \"l\", \"d\", \"i\"]\n  romans << [\"c\", \"\
    c\", \"l\", \"v\", \"i\"]\n  romans << [\"c\", \"c\", \"l\", \"l\", \"ii\"]\n\
    \  romans << [\"c\", \"c\", \"l\", \"d\", \"ii\"]\n  romans << [\"c\", \"c\",\
    \ \"l\", \"v\", \"ii\"]\n  romans << [\"c\", \"c\", \"l\", \"l\", \"iii\"]\n \
    \ romans << [\"c\", \"c\", \"l\", \"d\", \"iii\"]\n  romans << [\"c\", \"c\",\
    \ \"l\", \"v\", \"iii\"]\n  romans << [\"c\", \"c\", \"l\", \"l\", \"iv\"]\n \
    \ romans << [\"c\", \"c\", \"l\", \"d\", \"iv\"]\n  romans << [\"c\", \"c\", \"\
    l\", \"v\", \"iv\"]\n  romans << [\"c\", \"c\", \"l\", \"l\", \"v\"]\n  romans\
    \ << [\"c\", \"c\", \"l\", \"d\", \"v\"]\n  romans << [\"c\", \"c\", \"l\", \"\
    v\", \"v\"]\n  romans << [\"c\", \"c\", \"l\", \"l\", \"x\"]\n  romans << [\"\
    c\", \"c\", \"l\", \"d\", \"x\"]\n  romans << [\"c\", \"c\", \"l\", \"v\", \"\
    x\"]\n  romans << [\"c\", \"c\", \"l\", \"l\", \"xx\"]\n  romans << [\"c\", \"\
    c\", \"l\", \"d\", \"xx\"]\n  romans << [\"c\", \"c\", \"l\", \"v\", \"xx", " \
    \ return int_to_roman.call(number)\nend", "  return number_to_mini_roman(number).upcase\n\
    end", "  romanized = \"\"\n  romanized = \"x\" until number == 0\n  romanized\
    \ = \"x\" until number < 1000\n  romanized = romanized.gsub(/1|5|6|7|8|9|10|11|12|13|14|15|16|17|18/)\
    \ { |i| i.to_s.upcase }\n  romanized = romanized.gsub(/0/, \"o\")\n  romanized\
    \ = romanized.gsub(/1/, \"i\")\n  romanized = romanized.gsub(/2/, \"ii\")\n  romanized\
    \ = romanized.gsub(/3/, \"iii\")\n  romanized = romanized.gsub(/4/, \"iv\")\n\
    \  romanized = romanized.gsub(/5/, \"v\")\n  romanized = romanized.gsub(/6/, \"\
    vi\")\n  romanized = romanized.gsub(/7/, \"vii\")\n  romanized = romanized.gsub(/8/,\
    \ \"viii\")\n  romanized = romanized.gsub(/9/, \"ix\")\n  romanized = romanized.gsub(/10/,\
    \ \"x\")\n  romanized = romanized.gsub(/11/, \"xi\")\n  romanized = romanized.gsub(/12/,\
    \ \"xii\")\n  romanized = romanized.gsub(/13/, \"xiii\")\n  romanized = romanized.gsub(/14/,\
    \ \"xiv\")\n  romanized = romanized.gsub(/15/, \"xv\")\n  romanized = romanized.gsub(/16/,\
    \ \"xvi\")\n  romanized = romanized.gsub(/17/, \"xvii\")\n  romanized = romanized.gsub(/18/,\
    \ \"xviii\")\n  romanized = romanized.gsub(/19/, \"xx\")\n  romanized = romanized.gsub(/20/,\
    \ \"xxx\")\n  romanized = romanized.gsub(/30/, \"xxxx\")\n  romanized = romanized.gsub(/40/,\
    \ \"xxxxx\")\n  romanized = romanized.gsub(/51/, \"xxxxxx\")\n  romanized = romanized.gsub(/52/,\
    \ \"xxxxxxx\")\n  romanized = romanized.", "  roman = \"\"\n  num_arr = number.to_s.split(\"\
    \").reverse.map(&:to_i)\n  if num_arr.count < 2 || num_arr.first > 1000\n    \"\
    Error\"\n  elsif num_arr.first < 9 || num_arr.first > 40\n    \"Error\"\n  else\n\
    \    roman = num_arr.map do |number|\n      roman = roman + roman_nums[number]\n\
    \    end\n    roman.reverse!\n    roman.prepend(roman.first)\n  end\n  roman\n\
    end", "  roman = \"\"\n  roman_to_integrate(number, roman)\n  roman.downcase!\n\
    \  return roman\nend", "  romans = [nil, [], [], [], []]\n  romans.each { |i|\
    \ romans[i] = i }\n  romans.concat(1000) # start with the number 1", "\troman\
    \ = \"\"\n\tremainder = number\n\twhile number > 0\n\t\tif remainder >= 1000\n\
    \t\t\troman << [remainder % 1000].chr\n\t\t\tremainder -= 1000\n\t\telse\n\t\t\
    \troman << remainder.chr\n\t\t\tremainder %= 100\n\t\tend\n\tend\n\treturn roman.downcase\n\
    end", "  return to_roman(number, :lower)\nend", "  if number > 1000 or number\
    \ < 1\n    return \"Invalid Input\"\n  string = \"\"\n  index = 0\n  while number\
    \ >= 1000\n    string.concat(get_mini_roman(number / 1000).to_s)\n    number =\
    \ number % 1000\n    index += 1\n  end\n  if number == 0\n    string.concat(get_mini_roman(number).to_s)\n\
    \  else\n    string.concat(get_mini_roman(number).to_s).concat(get_mini_roman(100\
    \ - number).to_s)\n  end\n  return string.to_s.downcase\nend", "  roman = []\n\
    \  roman.concat([''] * number)\n  roman.concat([''] * number / 10)\n  roman.concat(['']\
    \ * number % 10)\n  roman.push(number % 10)\n  roman.push('M')", "  roman_numerals\
    \ = \n    [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"\
    V\",\"IV\",\"I\"]\n  if number < 1\n    raise ArgumentError, \"Integer must be\
    \ positive: #{number}\"\n  elsif number < 1000\n    roman = roman_numerals[number-1]\n\
    \  else\n    left_roman, right_roman = \n      number.to_s.split('').map.with_index\
    \ do |char, index|\n        index % 2 == 0 ? char.to_s.reverse! : char\n     \
    \ end\n    roman = \n      left_roman.zip(right_roman).map { |char| roman_numerals.index(char.chars.first).to_s\
    \ }.join('')\n  end\n  roman.downcase!\n  roman\nend\n</code>\n<|/ a dscore=5\
    \ |>\n<| a dscore=4 |>\nI wrote this function some time ago and just use it like\
    \ this.\n<code>", "  roman = \"\"\n  index = 0\n  while number >= index\n    if\
    \ index == 0\n      if number == 1\n        roman = \"x\"\n      else\n      \
    \  roman = \"x\"\n    end\n    roman = roman.to_s + roman_table[number % 100]\n\
    \    number = number / 100\n    index += 1\n  end\n  return roman.downcase\nend",
  "  roman_number = 0\n  roman_number += ((number / 100) * 1000)\n  roman_number +=\
    \ number % 100\n  roman_number += ((number / 10) * 10)\n  roman_number += number\
    \ % 10\n  roman_number += ((number / 1) * 1)\n  roman_number += number % 1\n \
    \ roman_number = roman_number.to_i\n  if roman_number < 1000\n    mini_roman_num\
    \ = roman_number.to_s\n  elsif roman_number < 5000\n    mini_roman_num = \"v\"\
    \n  elsif roman_number < 10000\n    mini_roman_num = \"iv\"\n  elsif roman_number\
    \ < 50000\n    mini_roman_num = \"i\"\n  elsif roman_number < 100000\n    mini_roman_num\
    \ = \"vi\"\n  elsif roman_number < 500000\n    mini_roman_num = \"vii\"\n  elsif\
    \ roman_number < 1000000\n    mini_roman_num = \"ix\"\n  elsif roman_number <\
    \ 5000000\n    mini_roman_num = \"xii\"\n  elsif roman_number < 10000000\n   \
    \ mini_roman_num = \"xxii\"\n  elsif roman_number < 50000000\n    mini_roman_num\
    \ = \"x\"\n  elsif roman_number < 100000000\n    mini_roman_num = \"xx\"\n  elsif\
    \ roman_number < 500000000\n    mini_roman_num = \"l\"\n  elsif roman_number <\
    \ 1000000000\n    mini_roman_num = \"ll\"\n  elsif roman_number < 5000000000\n\
    \    mini_roman_num = \"l\"\n  elsif roman_number < 10000000000\n    mini_roman_num\
    \ = \"ll\"\n  elsif roman_number < 50000000000\n    mini_roman_num = \"l\"\n \
    \ elsif roman_number < 100000000000\n    mini_roman_num = \"ll\"\n  elsif roman_number\
    \ < 500000000000\n    mini_roman_num = \"l\"\n  elsif roman_number < 1000000000000\n\
    \    mini_roman_num = \"ll\"\n  elsif roman_number < 5000000000000\n    mini_roman_num\
    \ = \"l\"\n  elsif roman_number < 10000000000000", "  roman = Array.new(11) do\
    \ |i|\n    if number < 1000\n      roman[i] = \"M\" if number <= 5000\n      roman[i]\
    \ = \"CM\" if number <= 10000\n      roman[i] = \"D\" if number <= 20000\n   \
    \   roman[i] = \"CD\" if number <= 40000\n      roman[i] = \"C\" if number <=\
    \ 90000\n      roman[i] = \"XC\" if number <= 99000\n      roman[i] = \"L\" if\
    \ number <= 99999\n      roman[i] = \"XL\" if number <= 999999\n      roman[i]\
    \ = \"X\" if number <= 9999999\n      roman[i] = \"IX\" if number <= 999999999\n\
    \      roman[i] = \"V\" if number <= 9999999995\n      roman[i] = \"IV\" if number\
    \ <= 99999999999\n      roman[i] = \"I\" if number <= 999999999995\n    end\n\
    \  end\n  roman[number / 1000].upcase\nend", "  roman_nums = []\n  roman_num =\
    \ \"\"\n  index = 0\n  while index < number\n    if number % 1000 == 0\n     \
    \ roman_nums.concat roman_num\n      roman_num = \"\"\n    roman_num = roman_num\
    \ + get_roman_number_for_number(number)\n    number = number / 1000\n  end\n \
    \ roman_nums.concat roman_num\n  roman_nums.join \"\"\nend\n</code>\n<|/ a tags=ruby-on-rails-4,ruby-on-rails\
    \ |>\n<| a tags=ruby-on-rails-4,ruby-on-rails |>\nI have found a way to convert\
    \ the number as you ask. The only problem is it will return \"I\" instead of \"\
    i\" in the roman numeral. I don't think this is an issue though, as the letter\
    \ is usually used in place of the roman numeral.\n<code>", "  roman = []\n  i\
    \ = 1 # index\n  while (i < number)\n    case i % 100\n    when 1\n      roman\
    \ << i\n      roman.concat [[\"M\"], [\"C\"], [\"D\"], [\"M\"]]\n    when 2\n\
    \      roman << i / 100\n      roman.concat [[\"C\"], [\"X\"], [\"L\"], [\"C\"\
    ]]\n    when 3\n      roman << i / 100\n      roman.concat [[\"C\"], [\"X\"],\
    \ [\"L\"], [\"C\"], [\"V\"]]\n    when 4\n      roman << i / 100\n      roman.concat\
    \ [[\"C\"], [\"X\"], [\"L\"], [\"C\"], [\"V\"], [\"I\"]]\n    when 5\n      roman\
    \ << i / 100\n      roman.concat [[\"C\"], [\"X\"], [\"L\"], [\"C\"], [\"V\"],\
    \ [\"I\"], [\"X\"]]\n    when 6\n      roman << i / 100\n      roman.concat [[\"\
    C\"], [\"X\"], [\"L\"], [\"C\"], [\"V\"], [\"I\"], [\"X\"], [\"V\"]]\n    when\
    \ 7\n      roman << i / 100\n      roman.concat [[\"C\"], [\"X\"], [\"L\"], [\"\
    C\"], [\"V\"], [\"I\"], [\"X\"], [\"V\"], [\"I\"]]\n    when 8\n      roman <<\
    \ i / 100\n      roman.concat [[\"C\"], [\"X\"], [\"L\"], [\"C\"], [\"V\"], [\"\
    I\"], [\"X\"], [\"V\"], [\"I\"], [\"X\"]]\n    when 9\n      roman << i / 100\n\
    \      roman.concat [[\"C\"], [\"X\"], [\"L\"], [\"C\"], [\"V\"], [\"I\"], [\"\
    X\"], [\"V\"], [\"I\"], [\"X\"], [\"V\"]]\n    when 10\n      roman << i / 100\n\
    \      roman.concat [[\"C\"], [\"X\"], [\"L\"], [\"C\"], [\"V\"], [\"I\"], [\"\
    X\"], [\"V\"], [\"I\"], [\"X\"], [\"V\"], [\"I\"]]\n    when 11\n      roman <<\
    \ i / 100\n      roman.concat [[\"C\"], [\"X\"], [\"L\"], [\"C\"], [\"V\"], [\"\
    I\"], [\"X\"], [\"V\"], [\"I\"], [\"X\"], [\"V\"], [\"I\"], [\"X\"]]\n    when\
    \ 12\n      roman << i ", "  return \"\" if number < 1 or  number > 1000 else\n\
    \    (if number < 2 then \"x\"\n    else int_to_mini_roman(number - 1) + [number\
    \ - 2].map { |i| i ? \"i\" : \"i\" }.join)\nend\n</code>\n<|/ a tags=ruby,recursion\
    \ |>\n<| c |>\nIt's a great answer, but the OP asked for a solution where they\
    \ didn't have to convert the whole number. The problem with this is that when\
    \ your function is called with `9` as an argument, you're basically doing `int_to_mini_roman(9)`,\
    \ which calls `int_to_mini_roman(8)`, which calls `int_to_mini_roman(7)` and so\
    \ on...\n<|/ c |>\n<| c |>\nThank you, I was just trying to get some code to work\
    \ and then I saw this and was happy\n<|/ c |>\n<| a tags=ruby,recursion dscore=3\
    \ |>\nThe general idea is:", "  if number == 0 then\n    \"0\"\n  else\n    roman\
    \ = [\n      \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\"\
    , \"IX\", \"V\", \"IV\", \"I\"\n    ].map do |char|\n      case number\n     \
    \ when 1; char.upcase\n      when 2; char.upcase + char.downcase\n      when 3;\
    \ char.upcase + char.downcase + char.upcase\n      when 4; char.upcase + char.downcase\
    \ + char.upcase + char.downcase\n      when 5; char.upcase + char.downcase + char.upcase\
    \ + char.downcase + char.upcase\n      when 6; char.upcase + char.downcase + char.upcase\
    \ + char.downcase + char.upcase + char.downcase\n      when 7; char.upcase + char.downcase\
    \ + char.upcase + char.downcase + char.upcase + char.downcase + char.upcase\n\
    \      when 8; char.upcase + char.downcase + char.upcase + char.downcase + char.upcase\
    \ + char.downcase + char.upcase + char.downcase\n      when 9; char.upcase + char.downcase\
    \ + char.upcase + char.downcase + char.upcase + char.downcase + char.upcase +\
    \ char.downcase + char.upcase\n      when 10; char.upcase + char.downcase + char.upcase\
    \ + char.downcase + char.upcase + char.downcase + char.upcase + char.downcase\
    \ + char.upcase + char.downcase\n      when 11; char.upcase + char.downcase +\
    \ char.upcase + char.downcase + char.upcase + char.downcase + char.upcase + char.downcase\
    \ + char.upcase + char.downcase + char.upcase\n      when 12; char.upcase + char.downcase\
    \ + char.upcase + char.downcase + char.upcase + char.downcase + char.upcase +\
    \ char.downcase + char.upcase + char.downcase + char.upcase\n      when 13; char.upcase\
    \ + char.downcase + char.upcase + char.downcase + char.up", "  int_to_roman(number)\n\
    \  case number when < 1000 or > Number.MAX_VALUE then nil\n  end\nend", "  if\
    \ number < 1\n    raise(ArgumentError, \"expected a positive integer, got #{number}\"\
    )\n  elsif number == 1\n    return \"x\"\n  elsif number == 2\n    return \"c\"\
    \n  elsif number > 2 and number < 20\n    return \"v\"\n  elsif number > 20 and\
    \ number < 100\n    return \"l\"\n  elsif number >= 100\n    return \"d\"\n  end\n\
    \  roman_numerals = Hash.new(0)\n  current_roman_value = 1\n  roman_numerals[11]\
    \ = \"M\"\n  roman_numerals[5] = \"D\"\n  roman_numerals[10] = \"C\"\n  roman_numerals[9]\
    \ = \"L\"\n  roman_numerals[4] = \"X\"\n  roman_numerals[6] = \"V\"\n  roman_numerals[3]\
    \ = \"I\"", "  roman_array = Array.new(number, 0)\n  roman_array[1] = -1\n  roman_array[2]\
    \ = -1\n  roman_array[3] = -1\n  roman_array[4] = -1\n  roman_array[5] = -1\n\
    \  roman_array[6] = -1\n  roman_array[7] = -1\n  roman_array[8] = -1\n  roman_array[9]\
    \ = -1\n  roman_array[10] = -1\n  roman_array[11] = -1\n  roman_array[12] = -1\n\
    \  roman_array[13] = -1\n  roman_array[14] = -1\n  roman_array[15] = -1\n  roman_array[16]\
    \ = -1\n  roman_array[17] = -1\n  roman_array[18] = -1\n  roman_array[19] = -1\n\
    \  roman_array[20] = -1\n  roman_array[21] = -1\n  roman_array[22] = -1\n  roman_array[23]\
    \ = -1\n  roman_array[24] = -1\n  roman_array[25] = -1\n  roman_array[26] = -1\n\
    \  roman_array[27] = -1\n  roman_array[28] = -1\n  roman_array[29] = -1\n  roman_array[30]\
    \ = -1\n  roman_array[31] = -1\n  roman_array[32] = -1\n  roman_array[33] = -1\n\
    \  roman_array[34] = -1\n  roman_array[35] = -1\n  roman_array[36] = -1\n  roman_array[37]\
    \ = -1\n  roman_array[38] = -1\n  roman_array[39] = -1\n  roman_array[40] = -1\n\
    \  roman_array[41] = -1\n  roman_array[42] = -1\n  roman_array[43] = -1\n  roman_array[44]\
    \ = -1\n  roman_array[45] = -1\n  roman_array[46] = -1\n  roman_array[47] = -1\n\
    \  roman_array[48] = -1\n  roman_array[49] = -1\n  roman_array[50] = -1\n  roman_array[51]\
    \ = -1\n  roman_array[52] = -1\n  roman_array[53] = -1\n  roman_array[54] = -1\n\
    \  roman_array[55] = -1\n  roman_array[56] = -1\n  roman_array[57] = -1\n  roman_array[58]\
    \ = -1\n  roman_array[59] = -1\n  roman_array[60] = -1\n  roman_array[61] = -1\n\
    \  roman_array[62] = -1\n  roman_array[63] = -1\n  ro", "  roman = \"\"\n  number_to_roman_conversions\
    \ = Hash.new", "  roman = \"\"\n  roman_num = [nil, \"c\", \"d\", \"x\", \"l\"\
    , \"m\", \"n\", \"i\"]\n  i = 2\n  while i <= number\n    roman = roman + roman_num[(number\
    \ % i).floor]\n    number = number / i\n    i += 1\n  end\n  roman = roman + roman_num[number].upcase\n\
    \  return roman\nend\n</code>\n<|/ a dscore=0 tags=ruby |>\n<| c |>\nI like your\
    \ use of 'roman_num' which is an excellent way to do it.  I ended up using your\
    \ code, and modified it a bit.  Thank you for your help :)\n<|/ c |>\n<| a |>\n\
    I've written a little library that handles things like these for you. It's very\
    \ simple to use and it also supports arbitrary bases. The API looks something\
    \ like this.\n<code>\n> require 'romatize'\n> roman_numeral = RomanNumeral.new(:I,\
    \ 2)\n=> #<RomanNumeral:0x00007fc7a34b08f0=\"IX\",:base=2,:uppercase=false>\n\
    > roman_numeral.to_s\n=> \"III\"\n> roman_numeral.to_s(:upper)\n=> \"XI\"\n</code>\n\
    It's on Github: https://github.com/jayway/romatize\n<|/ a dscore=0 tags=ruby |>\n\
    <| a tags=ruby |>\nI would use the string module's each_char and iterate over\
    \ the characters in the string and keep a tally of which roman numerals start\
    \ with what character. Something like this:\n<code>", "  roman_number = \"\"\n\
    \  while number != 0\n    roman_number << (number%100).to_s + roman(number%100).to_s\n\
    \    number /= 100\n  end\n  roman_number.to_s.downcase\nend\n</code>\n<|/ a |>\n\
    <| a tags=algorithm,ruby,ruby-on-rails |>\nHere's a method that converts a number\
    \ to its string representation.\n<code>", "  result = ''\n  if number > 1000\n\
    \    puts \"The number has to be less than 1000\"\n  else\n    (number < 50) ?\
    \ \"M\" : ((number < 100) ? \"C\" : ((number < 500) ? \"D\" : ((number < 1000)\
    \ ? \"M\" : ((number < 5000) ? \"B\" : \"X\"))))\n  end\n  return result\nend",
  "  roman = Array.new\n  if number < 0 or number > 1000\n    raise ArgumentError\n\
    \  roman.push(\"nul\")\n  roman.push(\"dol\")\n  roman.push(\"lii\")\n  roman.push(\"\
    vii\")\n  roman.push(\"viii\")\n  roman.push(\"ix\")\n  roman.push(\"xii\")\n\
    \  roman.push(\"l\")\n  roman.push(\"c\")\n  roman.push(\"d\")\n  roman.push(\"\
    m\")\n  roman.push(\"m\")\n  roman.push(\"l\")\n  roman.push(\"xc\")\n  roman.push(\"\
    xc\")\n  roman.push(\"xc\")\n  roman.push(\"c\")\n  roman.push(\"m\")\n  roman.push(\"\
    m\")\n  roman.push(\"c\")\n  roman.push(\"l\")\n  roman.push(\"xc\")\n  roman.push(\"\
    c\")\n  roman.push(\"m\")\n  roman.push(\"m\")\n  roman.push(\"c\")\n  roman.push(\"\
    l\")\n  roman.push(\"xc\")\n  roman.push(\"xc\")\n  roman.push(\"xc\")\n  roman.push(\"\
    xc\")\n  roman.push(\"xc\")\n  roman.push(\"xc\")\n  roman.push(\"xc\")\n  roman.push(\"\
    xc\")\n  roman.push(\"xc\")\n  roman.push(\"xc\")\n  roman.push(\"xc\")\n  roman.push(\"\
    xc\")\n  roman.push(\"xc\")\n  roman.push(\"xc\")\n  roman.push(\"xc\")\n  roman.push(\"\
    xc\")\n  roman.push(\"xc\")\n  roman.push(\"xc\")\n  roman.push(\"xc\")\n  roman.push(\"\
    xc\")\n  roman.push(\"xc\")\n  roman.push(\"xc\")\n  roman.push(\"xc\")\n  roman.push(\"\
    xc\")\n  roman.push(\"xc\")\n  roman.push(\"xc\")\n  roman.push(\"xc\")\n  roman.push(\"\
    xc\")", "  roman = Array.new(ROMAN_NUMBERS.length, \"_\")\n  roman[ROMAN_NUMBERS.index(\"\
    I\")] = \"i\"\n  roman[ROMAN_NUMBERS.index(\"V\")] = \"v\"\n  roman[ROMAN_NUMBERS.index(\"\
    X\")] = \"x\"\n  roman[ROMAN_NUMBERS.index(\"L\")] = \"l\"\n  roman[ROMAN_NUMBERS.index(\"\
    C\")] = \"c\"\n  roman[ROMAN_NUMBERS.index(\"D\")] = \"d\"\n  roman[ROMAN_NUMBERS.index(\"\
    M\")] = \"m\"\n  roman[ROMAN_NUMBERS.index(\"_\")] = \"_\"\n  roman[ROMAN_NUMBERS.index(\"\
    M\")] = \"_\"\n  roman[ROMAN_NUMBERS.index(\"CM\")] = \"_\"\n  roman[ROMAN_NUMBERS.index(\"\
    D\")] = \"_\"\n  roman[ROMAN_NUMBERS.index(\"CD\")] = \"_\"\n  roman[ROMAN_NUMBERS.index(\"\
    C\")] = \"_\"\n  roman[ROMAN_NUMBERS.index(\"XC\")] = \"_\"\n  roman[ROMAN_NUMBERS.index(\"\
    L\")] = \"_\"\n  roman[ROMAN_NUMBERS.index(\"XL\")] = \"_\"\n  roman[ROMAN_NUMBERS.index(\"\
    XC\")] = \"_\"\n  roman[ROMAN_NUMBERS.index(\"IX\")] = \"_\"\n  roman[ROMAN_NUMBERS.index(\"\
    V\")] = \"_\"\n  roman[ROMAN_NUMBERS.index(\"IV\")] = \"_\"\n  roman[ROMAN_NUMBERS.index(\"\
    I\")] = \"_\"\n  roman[ROMAN_NUMBERS.index(\"N\")] = \"_\"\n  roman[ROMAN_NUMBERS.index(\"\
    N\")] = \"_\"\n  roman[ROMAN_NUMBERS.index(\"D\")] = \"_\"\n  roman[ROMAN_NUMBERS.index(\"\
    CD\")] = \"_\"\n  roman[ROMAN_NUMBERS.index(\"C\")] = \"_\"\n  roman[ROMAN_NUMBERS.index(\"\
    M\")] = \"_\"\n  roman[ROMAN_NUMBERS.index(\"MMM\")] = \"_\"\n  roman[ROMAN_NUMBERS.index(\"\
    MMM\")] = \"_\"\n  roman[RO", "  str_roman = \"\"\n  \n  while number > 0\n  \
    \  str_roman << (number%100).to_s + str_roman\n    number -= (number%100).to_i\n\
    \  end\n  \n  str_roman[0..(str_roman.length - 1)].downcase!\nend", "  result\
    \ = ''\n  roman_number = 1\n  while number > 0\n    roman_number += number % 10\n\
    \    number /= 10\n  end\n  roman_numbers.reverse_each do |number|\n    if roman_number\
    \ == number\n      result += roman_numbers.delete(number)\n    end\n  end\n  result\
    \ = result.to_s\n  if result.length == 1\n    result += 'i'\n  end\n  result =\
    \ result.upcase\n  if roman_number != 0\n    result += 'i' unless result.index?('i')\n\
    \  end\n  result\nend", "  roman = roman_numbers[number]\n  roman = roman.split(\"\
    \")\n  roman[0] = roman[0].upcase\n  roman = roman.join(\"\")\n  return roman\n\
    end", "  roman = 0\n  while number > 0\n    roman = roman + (number % 10)\n  \
    \  number = number / 10\n    roman = roman + (number % 10)\n    number = number\
    \ / 10\n    roman = roman + (number % 10)\n    number = number / 10\n  end\n \
    \ roman = roman.to_s.reverse\n  roman = roman.chars.to_a.reverse.join\n  return\
    \ roman\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThe only solution that works\
    \ for me in Ruby 2.1.5.\n<|/ c |>\n<| c |>\nWorks great, Thanks. One liner: `roman\
    \ = (1..1000).map { |n| n.to_s.reverse.chars.to_a.reverse.join.to_s }.join.to_s.reverse`\n\
    <|/ c |>\n<| c |>\nYeah. I'm just trying to make my answer more concise. I'm also\
    \ trying to be helpful as I go along.\n<|/ c |>\n<| c |>\nA solution that uses\
    \ recursion is superior to others. Thanks a lot.\n<|/ c |>\n<| c |>\nI wonder\
    \ if there's any way to make this faster? It runs pretty fast, but I'm wondering\
    \ if it could be written more elegantly. I'm thinking maybe a binary search, but\
    \ I can't think of how that would work.\n<|/ c |>\n<| a tags=ruby |>\nI used the\
    \ solution provided by but made it more concise.\n<code>", "  romans = {\n   \
    \ 1  => 'i',\n    2  => 'ii',\n    3  => 'iii',\n    4  => 'iv',\n    5  => 'v',\n\
    \    6  => 'vi',\n    7  => 'vii',\n    8  => 'viii',\n    9  => 'ix',\n    10\
    \ => 'x',\n    11 => 'xi',\n    12 => 'xii',\n    13 => 'xiii',\n    14 => 'xiv',\n\
    \    15 => 'xv',\n    16 => 'xv',\n    17 => 'xvi',\n    18 => 'xvii',\n    19\
    \ => 'xviii',\n    20 => 'xvx',\n    21 => 'xx',\n    22 => 'xxi',\n    23 =>\
    \ 'xxii',\n    24 => 'xxiii',\n    25 => 'xxiv',\n    26 => 'xxv',\n    27 =>\
    \ 'xxvi',\n    28 => 'xxvii',\n    29 => 'xxviii',\n    30 => 'xxix',\n    31\
    \ => 'xxx',\n    32 => 'xxxi',\n    33 => 'xxxii',\n    34 => 'xxxiii',\n    35\
    \ => 'xxxiv',\n    36 => 'xxxv',\n    37 => 'xxxvi',\n    38 => 'xxxvii',\n  \
    \  39 => 'xxxviii',\n    40 => 'xxxix',\n    41 => 'xxxy',\n    42 => 'xxxz',\n\
    \    43 => 'xxxy',\n    44 => 'xxxx',\n    45 => 'xxxz',\n    46 => 'xxz',\n \
    \   47 => 'xl',\n    48 => 'l',\n    49 => 'll',\n    50 => 'lll',\n    51 =>\
    \ 'llll',\n    52 => 'xc',\n    53 => 'c',\n    54 => 'cc',\n    55 => 'ccc',\n\
    \    56 => 'cccd',\n    57 => 'cccc',\n    58 => 'ccccd',\n    59 => 'csc',\n\
    \    60 => 'cs',\n    61 => 'csd',\n    62 => 'csdc',\n    63 => 'cscd',\n   \
    \ 64 => 'ccc',\n    65 => 'cccd',\n    66 => 'cccc',\n    67 => 'ccccd',\n   \
    \ 68 => 'csc',\n    69 => 'cs',\n    70 => 'csd',\n    71 => 'csdc',\n    72 =>\
    \ 'cscd',\n    73 => 'ccc',\n    74 => '", "  return nil if number.zero?\n  str\
    \ = ''\n  i = 2\n  while i < number\n    str += (i > 1 ? roman_to_int_roman[i-1]\
    \ : '') + roman_to_int_roman[i]\n    i += 1\n  end\n  str.downcase!\n  return\
    \ str\nend", "  roman_number = []\n  while number > 0\n    roman_number << roman_number_to_int[number\
    \ % 10]\n    number /= 10\n  end", "  return int_to_roman.call(number)\nend",
  "  roman = RomanNumeral.new\n  roman.initial_value = ROMAN_NUMERALS[number]\n  roman.to_s\n\
    \  roman.roman_numerals\n  roman.to_s\n  return roman.to_s.downcase\nend", " \
    \ num = str(number).split(//).map(&:to_i)\n  result = \"\"\n  roman_numeral =\
    \ Hash.new\n  \n  (0..(roman_numeral.size -1)).each do |i|\n    roman_numeral[i]\
    \ = roman_numeral[i].to_s + roman_numeral[i+1].to_s\n    \n    i += 1\n    if\
    \ roman_numeral[i] > roman_numeral[i+1]\n      roman_numeral[i] -= roman_numeral[i+1].to_s.length\n\
    \      roman_numeral[i+1] = \"\"\n    end\n  end\n  \n  (0..(roman_numeral.size\
    \ -1)).each do |i|\n    result << roman_numeral[i]\n  end\n  \n  result.to_s.downcase\n\
    end\n</code>\nThis method is quite a bit slower than the one-line version, but\
    \ at least it works :)\n<|/ a tags=string,ruby |>\n<| c |>\nYep, this is quite\
    \ a bit slower than the one line version. I benchmarked it and it took 0.2 sec\
    \ to convert an integer to a string. My method took 5 sec to convert, so it's\
    \ not just my code. I tested on numbers from 10 to about 1000 and the method was\
    \ the fastest. I think the fastest way is to use a string array and iterate through\
    \ each character, checking to see if the character is in the correct position,\
    \ and if not, adding it to the correct position in the array.\n<|/ c |>\n<| c\
    \ |>\nIt was definitely the other way around - the other was faster. Thanks :)\n\
    <|/ c |>\n<| c |>\nYour solution doesn't work for `12` -> `\"x\"`\n<|/ c |>\n\
    <| c |>\nYeah, I saw that when I looked closely at the code when I was testing\
    \ it after you posted it. I'm still not sure what the requirements are, but my\
    \ guess is that it's supposed to return `\"\"` if the input is invalid. `12` is\
    \ invalid because it's missing a character - but it's valid because it's a string\
    \ of length 2. If that's not right, then I guess it's up to OP to fix it.\n<|/\
    \ c |>\n<| a tags=string,ruby |>\nThe reason why your solution is slower is that\
    \ you're rebuilding the roman_numeral string in each iteration of the loop. This\
    \ is fine for small numbers, but for large numbers you should use a Hash and then\
    \ just keep adding characters rather than doing string concatenation. \nFor example,\
    \ here's how you can do this with your current solution:\n<code>", "  roman =\
    \ '' # start with an empty string\n  roman_roman = { 0 => '',\n    1 => 'i',\n\
    \    4 => 'IV',\n    5 => 'V',\n    9 => 'IX',\n    10 => 'X'\n  }\n  if number\
    \ < 0\n    raise ArgumentError, \"Invalid argument: #{number}\"\n  else\n    number.times\
    \ do |i|\n      roman, roman_roman[number-i] = roman_roman[number-i], roman\n\
    \    end\n  end\n  roman.downcase!\n  roman\nend", "  roman = nil\n  number =\
    \ number.to_i\n  roman = []\n  roman.push ('C')\n  roman.push ('D')\n  roman.push\
    \ ('L')\n  roman.push ('M')\n  roman.push ('V')\n  roman.push ('I')", "  romanized\
    \ = int_to_roman(number)\n  return romanized.gsub(/[0-9]*/, '').gsub(/[MCLXVI]/,\
    \ 'm')\nend", "  roman = Array.new\n  roman.push(\"m\")\n  roman.push(\"c\")\n\
    \  roman.push(\"d\")\n  roman.push(\"i\")\n  roman.push(\"l\")\n  roman.push(\"\
    x\")\n  roman.push(\"v\")\n  roman.push(\"l\")\n  roman.push(\"x\")\n  roman.push(\"\
    c\")\n  roman.push(\"m\")", "  # Check for invalid input.\n  unless number.is_a?(Integer)\
    \ && number >= 1 && number <= 1000\n    return \"?\"\n  end", "  # Write your\
    \ code here.\n  if number > 1000 then\n    return \"Only support integer numbers\
    \ less than 1000\"\n  end\n  roman = \"\"\n  \n  while number >= 1000 do\n   \
    \ roman << \"M\"\n    number -= 1000\n  end\n  \n  while number >= 400 do\n  \
    \  roman << \"D\"\n    number -= 400\n  end\n  \n  while number >= 100 do\n  \
    \  roman << \"C\"\n    number -= 100\n  end\n  \n  while number >= 50 do\n   \
    \ roman << \"L\"\n    number -= 50\n  end\n  \n  while number >= 10 do\n    roman\
    \ << \"X\"\n    number -= 10\n  end\n  \n  while number >= 5 do\n    roman <<\
    \ \"V\"\n    number -= 5\n  end\n  \n  while number >= 1 do\n    roman << \"I\"\
    \n    number -= 1\n  end\n  \n  roman = roman.downcase\n  \n  return roman\nend",
  "  numbers = numbers_to_roman(number)\n  return numbers.first.capitalize\nend",
  "  if number == 0\n    number\n  elsif number < 0\n    int_to_mini_roman(-number)\n\
    \  elsif number < 100\n    \"x\"\n  elsif number < 500\n    \"c\"\n  elsif number\
    \ < 1000\n    \"cm\"\n  elsif number < 5000\n    \"d\"\n  elsif number < 10000\n\
    \    \"cd\"\n  elsif number < 100000\n    \"dc\"\n  elsif number < 1000000\n \
    \   \"cm\"\n  elsif number < 500000\n    \"xc\"\n  elsif number < 1000000\n  \
    \  \"xc\"\n  elsif number < 5000000\n    \"l\"\n  elsif number < 10000000\n  \
    \  \"xl\"\n  elsif number < 50000000\n    \"xc\"\n  elsif number < 100000000\n\
    \    \"ix\"\n  elsif number < 500000000\n    \"v\"\n  elsif number < 1000000000\n\
    \    \"vi\"\n  elsif number < 5000000000\n    \"vi\"\n  elsif number < 10000000000\n\
    \    \"iv\"\n  elsif number < 50000000000\n    \"i\"\n  elsif number < 100000000000\n\
    \    \"i\"\n  elsif number < 500000000000\n    \"ii\"\n  elsif number < 1000000000000\n\
    \    \"ii\"\n  elsif number < 5000000000000\n    \"ii\"\n  elsif number < 10000000000000\n\
    \    \"ii\"\n  elsif number < 50000000000000\n    \"iix\"\n  elsif number < 100000000000000\n\
    \    \"xix\"\n  elsif number < 500000000000000\n    \"lxx\"\n  elsif number <\
    \ 1000000000000000\n    \"lxx\"\n  elsif number < 5000000000000000\n    \"xix\"\
    \n  elsif number < 10000000000000000\n    \"xix\"\n  elsif number < 5000000000000000\n\
    \    \"xix\"\n  else\n    int_to_mini_roman(number / 100000)\n    int_to_mini_roman(number\
    \ % 100000)\n  end\nend", "  return number.to_s.roman(number)\nend", "  roman_numbers\
    \ = Array.new\n  while number >= 1000\n    roman_numbers << number_to_roman(number)\n\
    \    number -= 1000\n  roman_numbers << number_to_roman(number)\n  return roman_numbers.join('')\n\
    end\n</code>\n<|/ a dscore=3 |>\n<| a |>\n<code>", "  roman = \"\"\n  while number\
    \ > 0\n    roman, number = roman * 2 + [number % 100] + \\\n      [number % 10,\
    \ number % 100].map { |x| x.to_s.upcase }.reverse, number / 10\n  end\n  roman.sub!(/[0-9]$/,\
    \ \"\")\n  roman.upcase!\n  return roman\nend", "  if number.to_s == \"1\"\n \
    \   \"x\"\n  else\n    roman_numerals = Array.new\n    int_to_roman_numerals.call(number,\
    \ roman_numerals)\n    roman_numerals.join\n  end\nend", "  roman = Array.new\n\
    \  roman[0] = \"\"\n  roman[1] = \"I\"\n  roman[2] = \"II\"\n  roman[3] = \"III\"\
    \n  roman[4] = \"IV\"\n  roman[5] = \"V\"\n  roman[6] = \"VI\"\n  roman[7] = \"\
    VII\"\n  roman[8] = \"VIII\"\n  roman[9] = \"IX\"\n  roman[10] = \"X\"\n  roman[11]\
    \ = \"XI\"\n  roman[12] = \"XII\"\n  roman[13] = \"XIII\"\n  roman[14] = \"XIV\"\
    \n  roman[15] = \"XV\"\n  roman[16] = \"XVI\"\n  roman[17] = \"XVII\"\n  roman[18]\
    \ = \"XVIII\"\n  roman[19] = \"XIX\"\n  roman[20] = \"XX\"\n  roman[21] = \"XXI\"\
    \n  roman[22] = \"XXII\"\n  roman[23] = \"XXIII\"\n  roman[24] = \"XXIV\"\n  roman[25]\
    \ = \"XXV\"\n  roman[26] = \"XXVI\"\n  roman[27] = \"XXVII\"\n  roman[28] = \"\
    XXVIII\"\n  roman[29] = \"XXIX\"\n  roman[30] = \"XXX\"\n  roman[31] = \"XXXI\"\
    \n  roman[32] = \"XXXII\"\n  roman[33] = \"XXXIII\"\n  roman[34] = \"XXXIV\"\n\
    \  roman[35] = \"XXXV\"\n  roman[36] = \"XXXVI\"\n  roman[37] = \"XXXVII\"\n \
    \ roman[38] = \"XXXVIII\"\n  roman[39] = \"XXIX\"\n  roman[40] = \"XEX\"\n  roman[41]\
    \ = \"EX\"\n  roman[42] = \"EXI\"\n  roman[43] = \"EXII\"\n  roman[44] = \"EXIII\"\
    \n  roman[45] = \"EXIV\"\n  roman[46] = \"EXV\"\n  roman[47] = \"EXVI\"\n  roman[48]\
    \ = \"EXVII\"\n  roman[49] = \"EXVIII\"\n  roman[50] = \"EXIX\"", "  if number.to_s.length\
    \ < 1\n    raise ArgumentError.new('The number cannot be less than 1')\n  else\
    \ if number.to_s.length == 1\n    return \"x\"\n  else\n    romans = [ 'M', 'D',\
    \ 'C', 'X', 'L', 'V', 'I' ]\n    roman = romans[0]\n    roman_len = romans.index(\"\
    I\")\n    numerals = []\n    while roman_len <= number.to_s.length\n      numerals.push(romans[roman_len])\n\
    \      roman_len += 1\n      roman = romans[roman_len]\n    numerals.push(number.to_s)\n\
    \    return numerals.join('')\n  end\nend", "\tresult = ''\n\troman_array = ['',\
    \ 'M', 'MM', 'MMM', 'MMMM', 'MMMMM', 'MMMMMM', 'MMMMMMM', 'MMMMMMMM', 'MMMMMMMMM',\
    \ 'MMMMMMMMMM', 'MMMMMMMMMMM', 'MMMMMMMMMMMM', 'MMMMMMMMMMMMM', 'MMMMMMMMMMMMMM',\
    \ 'MMMMMMMMMMMMMMM', 'MMMMMMMMMMMMMMMM', 'MMMMMMMMMMMMMMMMM', 'MMMMMMMMMMMMMMMMMM',\
    \ 'MMMMMMMMMMMMMMMMMMM', 'MMMMMMMMMMMMMMMMMMMM', 'MMMMMMMMMMMMMMMMMMMMM', 'MMMMMMMMMMMMMMMMMMMMMM',\
    \ 'MMMMMMMMMMMMMMMMMMMMMMM', 'MMMMMMMMMMMMMMMMMMMMMMMM', 'MMMMMMMMMMMMMMMMMMMMMMMMM',\
    \ 'MMMMMMMMMMMMMMMMMMMMMMMMMM', 'MMMMMMMMMMMMMMMMMMMMMMMMMMM', 'MMMMMMMMMMMMMMMMMMMMMMMMMMMM',\
    \ 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMM', 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM', 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\
    \ 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM', 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM', 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\
    \ 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM', 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\
    \ 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM', 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\
    \ 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM', 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\
    \ 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM', 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\
    \ 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM', 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\
    \ 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM', 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\
    \ 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM', 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\
    \ 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM', 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\
    \ 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM', 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\
    \ 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM', 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\
    \ 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM', 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\
    \ 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM', 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM",
  "  return int_to_roman.call(number)\nend\n</cell>\n<code language=julia-1.0>\n@assert\
    \ int_to_mini_roman.call(1) == \"\"\n@assert int_to_mini_roman.call(2) == \"II\"\
    \n@assert int_to_mini_roman.call(3) == \"III\"\n@assert int_to_mini_roman.call(4)\
    \ == \"IV\"\n@assert int_to_mini_roman.call(9) == \"IX\"\n@assert int_to_mini_roman.call(10)\
    \ == \"X\"\n@assert int_to_mini_roman.call(99) == \"XXX\"\n@assert int_to_mini_roman.call(1000)\
    \ == \"XL\"\n@assert int_to_mini_roman.call(999) == \"LXXXII\"\n@assert int_to_mini_roman.call(1000)\
    \ == \"LXXXIII\"\n@assert int_to_mini_roman.call(99999) == \"LXXXIV\"\n@assert\
    \ int_to_mini_roman.call(9) == \"IX\"\n@assert int_to_mini_roman.call(10) == \"\
    X\"\n@assert int_to_mini_roman.call(1000) == \"XL\"\n</cell>\n<code language=julia-1.0>",
  "  roman_num = \"\"\n  while number > 0\n    roman_num += roman_map[number % 100]\n\
    \    number /= 100\n  end\n  roman_num.upcase!\n  return roman_num\nend", "  roman_numeral\
    \ = ''\n  while number >= 1000\n    roman_numeral << number%1000\n    number /=\
    \ 1000\n  roman_numeral << number\n  roman_numeral.downcase!\n  roman_numeral\n\
    end\n</code>\n<|/ a |>\n<| c |>\nI'm sorry, but your solution does not produce\
    \ the correct result for the following examples:\n`def int_to_mini_roman(num)\
    \ roman_numeral = ''\n  while num >= 1000\n    roman_numeral << num%1000\n   \
    \ num /= 1000\n  roman_numeral << num\n  roman_numeral.downcase!\n  roman_numeral\n\
    end", "  if number == 0\n    roman_numeral = \"0\"\n  else\n    roman_numeral\
    \ = []\n    roman_numerals =  [1000]\n    roman_numeral << roman_numerals.first\n\
    \    (roman_numeral << 1).each_index { |i| roman_numerals << roman_numerals[i]\
    \ * i }\n    (roman_numeral << number).each_index { |i| roman_numerals << roman_numerals[i]\
    \ * (number - roman_numerals[i]) }\n    roman_numeral.join(\"\")\n  end\nend",
  "  roman = Array.new\n  i = 0\n  while i < number\n    roman[i] = String.new\n \
    \   # Get the next roman number\n    roman[i] << get_roman_numeral(i).downcase\n\
    \    # Set the digit for the next\n    roman[i] << get_digit(i, number)\n    i\
    \ += 1\n  end\n  return roman.join(\"\")\nend\n</code>\nThe get_roman_numeral\
    \ function returns the roman numeral for the number. It takes into account the\
    \ numbers up to 1000, so it should work for numbers up to 999.\nThe get_digit\
    \ function returns each digit of the number in a string.\nFinally, the int_to_mini_roman\
    \ function is called to convert a number into its roman numeral equivalent.\n\
    I tested it with the following numbers:", "  roman = \"\"\n  while number >= 1000\n\
    \    roman, number = (number / 1000, \"M\" * number).split(\"M\".to_sym)\n  end\n\
    \  roman, number = (number, \"CM\" * number).split(\"CM\".to_sym)\n  roman, number\
    \ = (number, \"D\" * number).split(\"D\".to_sym)\n  roman, number = (number, \"\
    CD\" * number).split(\"CD\".to_sym)\n  roman, number = (number, \"C\" * number).split(\"\
    C\".to_sym)\n  roman, number = (number, \"XC\" * number).split(\"XC\".to_sym)\n\
    \  roman, number = (number, \"L\" * number).split(\"L\".to_sym)\n  roman, number\
    \ = (number, \"XL\" * number).split(\"XL\".to_sym)\n  roman, number = (number,\
    \ \"X\" * number).split(\"X\".to_sym)\n  roman, number = (number, \"IX\" * number).split(\"\
    IX\".to_sym)\n  roman, number = (number, \"V\" * number).split(\"V\".to_sym)\n\
    \  roman, number = (number, \"IV\" * number).split(\"IV\".to_sym)\n  roman, number\
    \ = (number, \"I\" * number).split(\"I\".to_sym)\n  roman.upcase!\nend", "  mini_roman\
    \ = \"\"\n  roman_values = [1000,900,500,400,100,90,50,40,10,9,5,4,1]\n  roman_numerals\
    \ = [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"\
    IV\",\"I\"]\n  i = number - 1 # First element of array is num #1\n  while (i >=\
    \ 0)\n    mini_roman << roman_numerals[i]\n    i-= roman_values[i]\n  end\n  mini_roman\
    \ << roman_numerals[i]\n  mini_roman.downcase!\n  return mini_roman\nend", " \
    \ number = number.to_i\n  romanized = \"\"\n  while number != 0\n    romanized\
    \ = romanized + roman_numeral_roman[number].to_s\n    number /= 1000\n  end\n\
    \  romanized.downcase!\n  return romanized\nend", "  return \"I\" + roman_to_int(convert_roman(number))\n\
    end", "  return to_roman(number)\nend", "  if number == 0\n    \"M\"\n  elsif\
    \ number < 0 || number > 1000\n    raise ArgumentError.new(\"Illegal number\"\
    )\n  else\n    roman_numerals = \"M\" * number\n    return roman_numerals[0..(number/3)-1]\
    \ + roman_numerals[(number/3+1)..-1] + (number%3 == 0 and \"I\" or \"x\")\n  end\n\
    end", "  number = number.to_s\n  result = ''\n  while number > 1\n    digit =\
    \ number % 10\n    number = number / 10\n    result = digit + (result ? \"M\"\
    \ : \"\")\n  end\n  return result.to_s.upcase\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| a tags=ruby,ruby-on-rails |>\nThis may look like a bit of a cheat but it's\
    \ pretty efficient and quick:\n<code>", "  number = number.to_i\n  return int_to_mini_roman_helper(number).join(\"\
    \")\nend", "  roman_num_lookup = Hash.new(0)\n  roman_num_lookup[0] = \"\"\n \
    \ roman_num_lookup[1] = \"M\"\n  roman_num_lookup[2] = \"CM\"\n  roman_num_lookup[3]\
    \ = \"D\"\n  roman_num_lookup[4] = \"CD\"\n  roman_num_lookup[5] = \"C\"\n  roman_num_lookup[6]\
    \ = \"XC\"\n  roman_num_lookup[7] = \"L\"\n  roman_num_lookup[8] = \"XL\"\n  roman_num_lookup[9]\
    \ = \"X\"\n  roman_num_lookup[10] = \"IX\"\n  roman_num_lookup[11] = \"V\"\n \
    \ roman_num_lookup[12] = \"IV\"\n  roman_num_lookup[13] = \"I\"\n  roman_num_lookup[14]\
    \ = \"IU\"\n  roman_num_lookup[15] = \"M\"\n  roman_num_lookup[16] = \"MM\"\n\
    \  roman_num_lookup[17] = \"MMM\"\n  roman_num_lookup[18] = \"MMMM\"\n  roman_num_lookup[19]\
    \ = \"MMMMM\"\n  roman_num_lookup[20] = \"MMMMMM\"\n  roman_num_lookup[21] = \"\
    MMMMMMM\"\n  roman_num_lookup[22] = \"MMMMMMMM\"\n  roman_num_lookup[23] = \"\
    MMMMMMMMM\"\n  roman_num_lookup[24] = \"MMMMMMMMMM\"\n  roman_num_lookup[25] =\
    \ \"MMMMMMMMMMM\"\n  roman_num_lookup[26] = \"MMMMMMMMMMMM\"\n  roman_num_lookup[27]\
    \ = \"MMMMMMMMMMMMM\"\n  roman_num_lookup[28] = \"MMMMMMMMMMMMMM\"\n  roman_num_lookup[29]\
    \ = \"MMMMMMMMMMMMMMM\"\n  roman_num_lookup[30] = \"MMMMMMMMMMMMMMMM\"\n  roman_num_lookup[31]\
    \ = \"MMMMMMMMMMMMMMMMM\"\n  roman_num_lookup[32] = \"MMMMMMMMMMMMMMMMMM\"\n \
    \ roman_num_lookup[33] = \"MMMMMMMMMMMMMMMMMMM\"\n  roman_num_lookup[34] = \"\
    MMMMMMMMMMMMMMMMMMMM\"\n  roman_num_lookup[35] = \"MMMMMMMMMMMMMMMMMMMMM\"\n \
    \ roman_num_lookup[36] = \"MMMMMMMMMMMMMMMMMMMMMM\"\n  roman_num_lookup[37] =\
    \ \"MMMMMMMMMMMMMMMMMMMMMMM\"\n  roman_num_lookup[38] = \"MMMMMMMMMMMMMMMMMMMMMMMM\"\
    \n  roman_num_lookup[39] = \"MMMMMMMMMMMMMMMMMMMMMMMMM\"\n  roman_num_lookup[40]",
  "  roman = Array.new(number)\n  index = 0\n  roman[0] = Roman.to_i(roman[0], index)\n\
    \  roman[1] = Roman.to_i(roman[1], index)\n  roman[2] = Roman.to_i(roman[2], index)\n\
    \  roman[3] = Roman.to_i(roman[3], index)\n  roman[4] = Roman.to_i(roman[4], index)\n\
    \  roman[5] = Roman.to_i(roman[5], index)\n  roman[6] = Roman.to_i(roman[6], index)\n\
    \  roman[7] = Roman.to_i(roman[7], index)\n  roman[8] = Roman.to_i(roman[8], index)\n\
    \  roman[9] = Roman.to_i(roman[9], index)\n  roman[10] = Roman.to_i(roman[10],\
    \ index)\n  roman[11] = Roman.to_i(roman[11], index)\n  roman[12] = Roman.to_i(roman[12],\
    \ index)\n  roman[13] = Roman.to_i(roman[13], index)\n  roman[14] = Roman.to_i(roman[14],\
    \ index)\n  roman[15] = Roman.to_i(roman[15], index)\n  roman[16] = Roman.to_i(roman[16],\
    \ index)\n  roman[17] = Roman.to_i(roman[17], index)\n  roman[18] = Roman.to_i(roman[18],\
    \ index)\n  roman[19] = Roman.to_i(roman[19], index)\n  roman[20] = Roman.to_i(roman[20],\
    \ index)\n  roman[21] = Roman.to_i(roman[21], index)\n  roman[22] = Roman.to_i(roman[22],\
    \ index)\n  roman[23] = Roman.to_i(roman[23], index)\n  roman[24] = Roman.to_i(roman[24],\
    \ index)\n  roman[25] = Roman.to_i(roman[25], index)\n  roman[26] = Roman.to_i(roman[26],\
    \ index)\n  roman[27] = Roman.to_i(roman[27], index)\n  roman[28] = Roman.to_i(roman[28],\
    \ index)\n  roman[29] = Roman.to_i(roman[29], index)\n  roman[30] = Roman.to_i(roman[30],\
    \ index)\n  roman[31] = Roman.to_i(", "  if number.to_s.length == 1\n    mini_roman\
    \ = (('M', 'CM', 'D', 'CD', 'CM', 'C', 'XC', 'L', 'XC', 'X', 'IX', 'V', 'IV')[number\
    \ / 100])\n  else\n    mini_roman = (('M', 'CM', 'D', 'CD', 'CM', 'C', 'XC', 'L',\
    \ 'L', 'L', 'XC', 'X', 'IX', 'V', 'IV')[(number / 10) % 10])\n    mini_roman +=\
    \ ((number / 100) % 10)\n  end\n  if number > 100\n    mini_roman += ('C')\n \
    \ end\n  if number > 10\n    mini_roman += ('L')\n  end\n  if number > 1\n   \
    \ mini_roman += ('X')\n  end\n  if number == 1\n    mini_roman\n  else\n    mini_roman\
    \ + ('I')\n  end\nend", "  roman_number = ''", "  roman = Array.new\n  roman[0]\
    \ = \"i\"\n  roman[1] = \"ii\"\n  roman[2] = \"iii\"\n  roman[3] = \"iv\"\n  roman[4]\
    \ = \"v\"\n  roman[5] = \"vi\"\n  roman[6] = \"vii\"\n  roman[7] = \"viii\"\n\
    \  roman[8] = \"ix\"\n  roman[9] = \"x\"\n  roman[10] = \"xii\"\n  roman[11] =\
    \ \"xiii\"\n  roman[12] = \"xiv\"\n  roman[13] = \"xvi\"\n  roman[14] = \"xvii\"\
    \n  roman[15] = \"xviii\"\n  roman[16] = \"xix\"\n  roman[17] = \"xx\"\n  roman[18]\
    \ = \"xxi\"\n  roman[19] = \"xxii\"\n  roman[20] = \"xxiii\"\n  roman[21] = \"\
    xxiv\"\n  roman[22] = \"xxv\"\n  roman[23] = \"xxvi\"\n  roman[24] = \"xxvii\"\
    \n  roman[25] = \"xxviii\"\n  roman[26] = \"xxix\"\n  roman[27] = \"xxx\"\n  roman[28]\
    \ = \"xxxi\"\n  roman[29] = \"xxxii\"\n  roman[30] = \"xxxiv\"\n  roman[31] =\
    \ \"xxxv\"\n  roman[32] = \"xxxvi\"\n  roman[33] = \"xxxvii\"\n  roman[34] = \"\
    xxxviii\"\n  roman[35] = \"xxxiix\"\n  roman[36] = \"xxxii\"\n  roman[37] = \"\
    xxxiii\"\n  roman[38] = \"xxxiv\"\n  roman[39] = \"xxxv\"\n  roman[40] = \"xxxvi\"\
    \n  roman[41] = \"xxxvii\"\n  roman[42] = \"xxxviii\"\n  roman[43] = \"xxxix\"\
    \n  roman[44] = \"xxxiv\"\n  roman[45] = \"xxxv\"\n  roman[46] = \"xxxvi\"\n \
    \ roman[47] = \"xxxvii\"\n  roman[48] = \"xxxviii\"\n  roman[49] = \"xxxiix\"\n\
    \  roman[50]", "  return number_to_roman(number) if number < 1000 else '???'\n\
    end", "  roman = \"\"\n  roman_map = {0 => \"i\", 1 => \"ii\", 2 => \"iii\", 3\
    \ => \"iv\", 4 => \"v\", 5 => \"vi\", 6 => \"vii\", 7 => \"viii\",\n    8 => \"\
    ix\", 9 => \"x\"}\n  \n  while number != 0\n    roman_digit = number % 10\n  \
    \  roman_digit -= 1 if number < 1000 else 0\n    roman << roman_map[roman_digit]\n\
    \    number -= roman_digit\n  end\n  \n  roman.downcase!\n  \n  return roman\n\
    end\n</cell>\n<text>\nThe main program which performs the required tasks is now\
    \ much shorter and easier to understand.", "  if number < 0\n    puts \"Invalid\
    \ input: #{number} must be greater than 0\"\n    return\n  elsif number < 100\n\
    \    puts \"Invalid input: #{number} must be greater than 100\"\n    return\n\
    \  end\n  roman_values = (\n    \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"\
    L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"\n  )\n  return_string = \"Invalid\
    \ input: #{number} must be greater than 1000\"\n  if number > 100\n    return_string\
    \ += \" but is #{number}\"\n  end\n  return_string += \": \"\n  return_string.succ!\n\
    \  roman_numerals = roman_values.take_while do |value|\n    value < number\n \
    \ end\n  roman_numerals.reverse + roman_numerals.take_while do |value|\n    value\
    \ <= number\n  end\n  roman_numerals.reverse_each.each.with_index do |numeral,\
    \ i|\n    return_string += numeral.gsub(/./, \"\")\n    return_string += roman_values[i]\
    \ unless roman_numerals.empty? || i == roman_numerals.length - 1\n  end\n  puts\
    \ return_string\nend", "    roman = Array.new\n    roman.push(0)\n    roman.push(1)\n\
    \    roman.push(2)\n    roman.push(3)\n    roman.push(4)\n    roman.push(5)\n\
    \    roman.push(6)\n    roman.push(7)\n    roman.push(8)\n    roman.push(9)\n\
    \    roman.push(10)\n    roman.push(11)\n    roman.push(12)\n    roman.push(13)\n\
    \    roman.push(14)\n    roman.push(15)\n    roman.push(16)\n    roman.push(17)\n\
    \    roman.push(18)\n    roman.push(19)\n    roman.push(20)\n    roman.push(21)\n\
    \    roman.push(22)\n    roman.push(23)\n    roman.push(24)\n    roman.push(25)\n\
    \    roman.push(26)\n    roman.push(27)\n    roman.push(28)\n    roman.push(29)\n\
    \    roman.push(30)\n    roman.push(31)\n    roman.push(32)\n    roman.push(33)\n\
    \    roman.push(34)\n    roman.push(35)\n    roman.push(36)\n    roman.push(37)\n\
    \    roman.push(38)\n    roman.push(39)\n    roman.push(40)\n    roman.push(41)\n\
    \    roman.push(42)\n    roman.push(43)\n    roman.push(44)\n    roman.push(45)\n\
    \    roman.push(46)\n    roman.push(47)\n    roman.push(48)\n    roman.push(49)\n\
    \    roman.push(50)\n    roman.push(51)\n    roman.push(52)\n    roman.push(53)\n\
    \    roman.push(54)\n    roman.push(55)\n    roman.push(56)\n    roman.push(57)\n\
    \    roman.push(58)\n    roman.push(59)\n    roman.push(60)\n    roman.push(61)\n\
    \    roman.push(62)\n    roman.push(63)\n    roman.push(64)\n    roman.push(65)\n\
    \    roman.push(66)\n", "  roman_numeral = \"\"\n  \n  # Only accept valid integers\n\
    \  if number < 1 || number > 1000\n    error \"#{number} is not a valid integer.\"\
    \n  end\n  \n  \n  # If the integer is divisible by 1000, append \"vi\" to roman_numeral.\n\
    \  if number % 1000 == 0\n    roman_numeral << \"vi\"\n    \n  # If the integer\
    \ is divisible by 100, append \"ix\" to roman_numeral.\n  elsif number % 100 ==\
    \ 0\n    roman_numeral << \"ix\"\n    \n  # If the integer is divisible by 10,\
    \ append \"x\" to roman_numeral.\n  elsif number % 10 == 0\n    roman_numeral\
    \ << \"x\"\n    \n  # If the integer is divisible by 5, append \"l\" to roman_numeral.\n\
    \  elsif number % 5 == 0\n    roman_numeral << \"l\"\n    \n  # If the integer\
    \ is divisible by 4, append \"c\" to roman_numeral.\n  elsif number % 4 == 0\n\
    \    roman_numeral << \"c\"\n    \n  # If the integer is divisible by 3, append\
    \ \"m\" to roman_numeral.\n  elsif number % 3 == 0\n    roman_numeral << \"m\"\
    \n    \n  # If the integer is divisible by 2, append \"i\" to roman_numeral.\n\
    \  elsif number % 2 == 0\n    roman_numeral << \"i\"\n    \n  # Otherwise, append\
    \ \"n\" to roman_numeral.\n  else\n    roman_numeral << \"n\"\n  end\n  \n  #\
    \ Return the roman numeral string\n  roman_numeral.downcase!\nend", "  if number.zero?\n\
    \    '0'\n  elsif number.abs < 400\n    int_to_mini_roman(number.to_s) + 'i'\n\
    \  elsif number.abs < 500\n    int_to_mini_roman(number.to_s) + 'ii'\n  elsif\
    \ number.abs < 4000\n    int_to_mini_roman(number.to_s) + 'iii'\n  elsif number.abs\
    \ >= 4000\n    int_to_mini_roman(number.to_s) + 'v'\n  else\n    int_to_mini_roman(number.to_s)\
    \ + 'vi'\n  end\nend", "  roman = Array.new\n  roman = roman.push(\"I\")\n  roman\
    \ = roman.push(\"V\")\n  roman = roman.push(\"X\")\n  roman = roman.push(\"L\"\
    )\n  roman = roman.push(\"C\")\n  roman = roman.push(\"D\")\n  roman = roman.push(\"\
    M\")\n  roman = roman.push(\"C\")\n  roman = roman.push(\"M\")\n  roman = roman.push(\"\
    D\")\n  roman = roman.push(\"C\")\n  roman = roman.push(\"M\")\n  roman = roman.push(\"\
    C\")\n  roman = roman.push(\"D\")\n  roman = roman.push(\"C\")\n  roman = roman.push(\"\
    M\")\n  roman = roman.push(\"C\")\n  roman = roman.push(\"D\")\n  roman = roman.push(\"\
    C\")\n  roman = roman.push(\"M\")\n  roman = roman.push(\"C\")\n  roman = roman.push(\"\
    D\")\n  roman = roman.push(\"C\")\n  roman = roman.push(\"M\")\n  roman = roman.push(\"\
    C\")\n  roman = roman.push(\"D\")\n  roman = roman.push(\"C\")\n  roman = roman.push(\"\
    M\")\n  roman = roman.push(\"C\")\n  roman = roman.push(\"D\")\n  roman = roman.push(\"\
    C\")\n  roman = roman.push(\"M\")\n  roman = roman.push(\"C\")\n  roman = roman.push(\"\
    D\")\n  roman = roman.push(\"C\")\n  roman = roman.push(\"M\")\n  roman = roman.push(\"\
    C\")\n  roman = roman.push(\"D\")\n  roman = roman.push(\"C\")\n  roman = roman.push(\"\
    M\")\n  roman = roman.push(\"C\")\n  roman = roman.push(\"D\")\n  ", "  roman_values\
    \ = [1000,900,500,400,100,90,50,40,10,9,5,4,1]\n  roman_values.map { |x| \n  \
    \  (x * number).to_s.rjust(3,\"0\")\n  }.join\nend\n</code>\nThe code is based\
    \ on this post on rosetta code, which also contains Ruby code\n<|/ a tags=ruby,ruby-on-rails-3.2,ruby-on-rails\
    \ |>\n<| a |>\nI've written a library to handle this very problem. It has methods\
    \ for formatting a number to any length you like. You can see some examples in\
    \ the readme in the repo.\n<|/ a dscore=3 tags=ruby,ruby-on-rails-3.2,ruby-on-rails\
    \ |>\n<| a dscore=2 |>\nHere's an example of using RomanNumerals in Ruby.\n<code>\n\
    require \"roman\"\nRN = RomanNumerals::Roman #=> #<Roman numerals: 1000:1, 900:2,\
    \ 500:3, 400:4, 100:5, 90:6, 50:7, 40:8, 10:9, 9:10, 5:11, 4:12, 1:13>", "  if\
    \ number > 1000\n    puts \"Error, number must be less than 1000!\"\n    return\n\
    \  end\n  roman_number = nil\n  roman_number << \".\"\n  roman_number << roman_to_int(\"\
    M\" * number)\n  roman_number << \".\"\n  roman_number << roman_to_int(\"D\" *\
    \ number)\n  roman_number << \".\"\n  roman_number << roman_to_int(\"C\" * number)\n\
    \  roman_number << \".\"\n  roman_number << roman_to_int(\"L\" * number)\n  roman_number\
    \ << \".\"\n  roman_number << roman_to_int(\"X\" * number)\n  roman_number <<\
    \ \".\"\n  roman_number << roman_to_int(\"V\" * number)\n  roman_number << \"\
    .\"\n  roman_number << roman_to_int(\"I\" * number)\n  return roman_number.downcase\n\
    end\n</code>\n<|/ a |>\n<| c |>\n+1 This is great for small integers.  To make\
    \ it work well for larger integers, one can just divide the integer by `100` before\
    \ calling the `int_to_mini_roman` method.\n<|/ c |>\n<| c |>\nThis answer has\
    \ a mistake.  It misses the 'L' modifier.  It should be `roman_number << \".\"\
    ; roman_number << roman_to_int(\"L\" * number); roman_number << \".\"`\n<|/ c\
    \ |>\n<| c |>\nAh, the L for Lakh threw me off.  Thanks for catching that.  I've\
    \ fixed it now.\n<|/ c |>\n<| c |>\nThis won't work for anything over 999.\n<|/\
    \ c |>\n<| a tags=ruby,integer |>\n<code>", "  return number_to_roman(number).downcase\n\
    end", "  roman = \"\"\n  roman_lookup = { \"I\"  => 1,\n                   \"\
    V\"  => 5,\n                   \"X\"  => 10,\n                   \"L\"  => 50,\n\
    \                   \"C\"  => 100,\n                   \"D\"  => 500,\n      \
    \             \"M\"  => 1000 }\n  while number > 0\n    roman_number = roman_lookup[roman.chr(number.chr)]\n\
    \    roman << roman_number\n    number = number - roman_number\n  end\n  return\
    \ roman\nend", "  return \"#{roman_to_int(number)}\"\nend", "  if number < 1 ||\
    \ number > 1000\n    puts \"Invalid number #{number}\"\n    return nil\n  end\n\
    \  roman_numeral = \"\"\n  while number > 0\n    roman_numeral << roman_letters[number\
    \ % 10]\n    number /= 10\n  end\n  roman_numeral.downcase!\n  return roman_numeral\n\
    end", "  roman = \"\"\n  while number > 1000\n    roman, number = (number / 100).to_s\
    \ + roman, (number % 100).to_i\n  roman, number = (number / 100).to_s + roman,\
    \ (number % 100).to_s + roman.chars.reverse.join\n  roman, number = (number /\
    \ 100).to_s + roman, (number % 100).to_s + roman.chars.reverse.join\n  roman,\
    \ number = (number / 100).to_s + roman, (number % 100).to_s + roman.chars.reverse.join\n\
    \  roman, number = (number / 100).to_s + roman, (number % 100).to_s + roman.chars.reverse.join\n\
    \  roman, number = (number / 100).to_s + roman, (number % 100).to_s + roman.chars.reverse.join\n\
    \  roman, number = (number / 100).to_s + roman, (number % 100).to_s + roman.chars.reverse.join\n\
    \  roman, number = (number / 100).to_s + roman, (number % 100).to_s + roman.chars.reverse.join\n\
    \  roman, number = (number / 100).to_s + roman, (number % 100).to_s + roman.chars.reverse.join\n\
    \  roman, number = (number / 100).to_s + roman, (number % 100).to_s + roman.chars.reverse.join\n\
    \  roman, number = (number / 100).to_s + roman, (number % 100).to_s + roman.chars.reverse.join\n\
    \  roman, number = (number / 100).to_s + roman, (number % 100).to_s + roman.chars.reverse.join\n\
    \  roman, number = (number / 100).to_s + roman, (number % 100).to_s + roman.chars.reverse.join\n\
    \  roman, number = (number / 100).to_s + roman, (number % 100).to_s + roman.chars.reverse.join\n\
    \  roman, number = (number / 100).to_s + roman, (number % 100).to_s + roman.chars.reverse.join\n\
    \  roman, number = (number / 100).to_s + roman, (number % 100).to_s + roman.chars.reverse.join\n\
    \  roman, number = (number / 100).to_s + roman, (number % 100).to_s + roman.chars.reverse.join\n\
    \  roman, number = (number / 100).to_s + roman, (", "  return to_roman(number)\
    \ if number < 0 || number == 0 \n  if number >= 1000 && number < 1000000\n   \
    \ to_roman(number / 1000) + \" \" + (number_to_roman(number % 1000))\n  elsif\
    \ number >= 1000000 && number < 1000000000\n    to_roman(number / 1000000) + \"\
    \ \" + (number_to_roman(number % 1000000))\n  elsif number >= 1000000000\n   \
    \ to_roman(number / 1000000000) + \" \" + (number_to_roman(number % 1000000000))\n\
    \  end\nend", "  numeral = \"M\"\n  i = 0\n  while number >= (i * 100 + 1) do\n\
    \    numeral = numeral.chop.call(to_string(i / 100) + numeral.chop.call(to_string(i\
    \ % 100)))\n    i += 1\n  end\n  numeral.chop.call(to_string(i / 10)).upcase +\
    \ numeral.chop.call(to_string(i % 10)).downcase\nend", "  roman = String.new\n\
    \  number.times { roman.concat(mini_roman_to_int[number.to_s.slice!(0,1)]) }\n\
    \  roman.downcase\nend", "  return roman_to_int(int_to_roman(number))\nend", " \
    \ roman = Array.new(number)\n  roman.map!{ |index| index == 0? \"\": index.to_s.rjust(2,\
    \ '0') }\n  roman.map!{ |index| index.to_s.ljust(3, '0') }", "  return number.to_s.gsub(/^\\\
    d/,'').gsub(/\\d{3}$/,'').\n            chars.sort.map { |char| MiniRoman [char,\
    \ number] }.\n            join\nend", "  roman =\n    case number\n    when 0..199\n\
    \      'x'\n    when 200..399\n      'l'\n    when 400..499\n      'c'\n    when\
    \ 500..599\n      'd'\n    when 600..699\n      'm'\n    when 700..799\n     \
    \ 'c'\n    when 800..899\n      'l'\n    when 900..999\n      'x'\n    else\n\
    \      'v'\n    end\n  int_to_roman_without_vowel.call(number).downcase + roman\n\
    end", "  return roman_numeral(number)\nend", "  result = ''\n  ones = ['', 'I',\
    \ 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX']\n  tens = ['', 'X', 'XX',\
    \ 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC']\n  hundreds = ['', '', 'XC', 'XL',\
    \ 'X', 'X', 'XX', 'XXX', 'XL', 'L', 'LX']\n  thousands = ['', 'M', 'MM', 'MMM',\
    \ 'MMMM']\n  i = number\n  while i > 0\n    roman = ones[i / 100]\n    digit =\
    \ i % 100\n    if digit > 9\n      roman += tens[digit]\n    else\n      roman\
    \ += hundreds[digit]\n    i = i / 100\n    result += roman\n  return result\n\
    end", "  if number.is_a? Integer\n    roman_numeral = MiniRoman.new(number).to_s\n\
    \    roman_numeral.downcase!\n    return roman_numeral\n  else\n    return \"\
    Integer required\"\n  end\nend", "  miniroman = nil\n  roman_nums = Array.new(13)\
    \ { 0 }\n  roman_nums[0] = 900\n  roman_nums[1] = 500\n  roman_nums[2] = 400\n\
    \  roman_nums[3] = 100\n  roman_nums[4] = 50\n  roman_nums[5] = 10\n  roman_nums[6]\
    \ = 5\n  roman_nums[7] = 1\n  roman_nums[8] = 5\n  roman_nums[9] = 1\n  roman_nums[10]\
    \ = 5\n  roman_nums[11] = 4\n  roman_nums[12] = 3", "  roman_numeral_alphabet\
    \ = [\n    \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\",\
    \ \"IX\", \"V\", \"IV\",\n    \"I\"\n  ]\n  roman_numeral_alphabet.reverse\n \
    \ roman_decimal_digits = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n\
    \  roman_decimal_digits.reverse\n  roman_numeral_digits = roman_numeral_alphabet.dup.reverse",
  "  roman_numeral = ''\n  roman_numeral << \"\" if number < 1\n  roman_numeral <<\
    \ roman_number_to_string(number % 1000) if number > 1000\n  roman_numeral << roman_number_to_string(number\
    \ % 100) if number % 100 > 0\n  roman_numeral << roman_number_to_string(number\
    \ % 10) if number % 10 > 0\n  roman_numeral.downcase!\n  return roman_numeral\n\
    end", "  roman_values = [ \"M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\" ] #\
    \ Initialize with allowed values\n  roman_values.each do |r|\n    roman = number.to_s.split(r).join(r)\n\
    \    return roman if roman <= \"1000\"\n  end\nend", "    roman = \"\"\n    number_to_roman\
    \ = lambda n: \"M\" * n + \"CM\"[n//4] \\\n        + \"D\"[n%4] + \\\n       \
    \ \"CD\"[n//4//3] \\\n        + \"C\"[n%4//3//2] \\\n        + \"XC\"[n//4//3//2]\n\
    \    if number < 0 or number > 1000: return roman\n    for i in range(0, number):\n\
    \        roman += number_to_roman(i)\n    return roman.lower()", "  romans = [\
    \ \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"\
    V\", \"IV\", \"I\" ]\n  roman = romans[number]\n  roman = roman.gsub(/([m]e)$/,\
    \ '\\1')\n  roman = roman.gsub(/([c]m)$/, '\\1')\n  roman = roman.gsub(/([d]e)$/,\
    \ '\\1')\n  roman = roman.gsub(/([x]c)$/, '\\1')\n  roman = roman.gsub(/([l]d)$/,\
    \ '\\1')\n  roman = roman.gsub(/([x]l)$/, '\\1')\n  roman = roman.gsub(/(x[iv])$/,\
    \ '\\1')\n  roman = roman.gsub(/(i[x])$/, '\\1')\n  roman = roman.gsub(/(vi)$/,\
    \ '\\1')\n  roman = roman.gsub(/(vi[iv])$/, '\\1')\n  roman = roman.gsub(/([i][x])$/,\
    \ '\\1')\n  roman = roman.gsub(/([x][v])$/, '\\1')\n  roman = roman.gsub(/([v][i])$/,\
    \ '\\1')\n  roman = roman.gsub(/(i[x][x])$/, '\\1')\n  roman = roman.gsub(/([x])$/,\
    \ '\\1')\n  roman = roman.gsub(/(x[v])$/, '\\1')\n  roman = roman.gsub(/([v])$/,\
    \ '\\1')\n  roman = roman.gsub(/([m][c])$/, '\\1')\n  roman = roman.gsub(/([c][d])$/,\
    \ '\\1')\n  roman = roman.gsub(/([d][c])$/, '\\1')\n  roman = roman.gsub(/([c][x])$/,\
    \ '\\1')\n  roman = roman.gsub(/([x][m])$/, '\\1')\n  roman = roman.gsub(/([m][d])$/,\
    \ '\\1')\n  roman = roman.gsub(/([d][x])$/, '\\1')\n  roman = roman.gsub(/([x][c])$/,\
    \ '\\1')\n  roman = roman.gsub(/([c][v])$/, '\\", "  roman = Array.new(number)\
    \ { |i| Roman.to_ordinal(i) }\n  roman << \" \"\n  roman << roman.delete(\"\"\
    )\n  roman.map! {|i| i.to_s.capitalize }\n  roman.join! \"-\"\n  roman.map! {|i|\
    \ i.upcase }\n  roman.join! \"M\"\n  roman.delete_at(-1)\n  roman.join! \"CM\"\
    \n  roman.delete_at(-1)\n  roman.join! \"D\"\n  roman.delete_at(-1)\n  roman.join!\
    \ \"CD\"\n  roman.delete_at(-1)\n  roman.join! \"C\"\n  roman.delete_at(-1)\n\
    \  roman.join! \"XC\"\n  roman.delete_at(-1)\n  roman.join! \"L\"\n  roman.delete_at(-1)\n\
    \  roman.join! \"XL\"\n  roman.delete_at(-1)\n  roman.join! \"X\"\n  roman.delete_at(-1)\n\
    \  roman.join! \"IX\"\n  roman.delete_at(-1)\n  roman.join! \"V\"\n  roman.delete_at(-1)\n\
    \  roman.join! \"IV\"\n  roman.delete_at(-1)\n  roman.join! \"I\"\n  roman.delete_at(-1)\n\
    \  roman.join! \"I\"\n  roman.delete_at(-1)\n  roman.join! \"VI\"\n  roman.delete_at(-1)\n\
    \  roman.join! \"V\"\n  roman.delete_at(-1)\n  roman.join! \"IX\"\n  roman.delete_at(-1)\n\
    \  roman.join! \"X\"\n  roman.delete_at(-1)\n  roman.join! \"XX\"\n  roman.delete_at(-1)\n\
    \  roman.join! \"XX\"\n  roman.delete_at(-1)\n  roman.join! \"XXX\"\n  roman.delete_at(-1)\n\
    \  roman.join! \"III\"\n  roman.delete_at(-1)\n  roman.join! \"II\"\n  roman.delete_at(-1)\n\
    \  roman.join! \"I\"\n  roman.delete_at(-1)\n  roman.join! \"I\"\n  roman.delete_at(-1)\n\
    \  roman.join! \"II\"\n", "  return number.to_s.reverse.gsub(/.../, '').gsub(/.../,\
    \ '').gsub(/[x-z]/, '').to_s.reverse.gsub(/[a-z]/, '').to_s.reverse.gsub(/[0-9]/,\
    \ '').to_s.reverse\nend", "  if number < 1\n    raise ArgumentError, \"Invalid\
    \ number, expected positive integer\"\n  else\n    return roman_numerals(number,\
    \ :downcase, :alpha).join\n  end\nend", "  return to_roman_str(number).downcase.gsub(/(\\\
    d)(?=(\\d))/, \"\\\\1\");\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI agree with\
    \ you but your regex does not cover the case where num is less than 10. For example,\
    \ int_to_mini_roman.call(1) returns \"i\" and not \"i\"\n<|/ c |>\n<| a |>\nI've\
    \ extended Jonathan Eliya's answer to work with negative numbers as well as zero.\
    \ I've also added a method for converting a number to a string and an inverse\
    \ for converting to an int and back.\n<code>", "  roman = \"\"\n  i = 0\n  while\
    \ (number >= 100)\n    roman = (roman << 1) | i\n    number -= 100\n    i += 1\n\
    \  roman = (roman << 1) | i\n  while number >= 10\n    roman << 1\n    number\
    \ -= 10\n  roman = (roman << 1) | i\n  while number >= 1\n    roman << 1\n   \
    \ number -= 1\n  roman = roman.to_s.upcase\n  return roman\nend", "  return number\
    \ == 0 ? \"\" : int_to_mini_roman.call(\"I\", number)\nend", "  num = number.to_s\n\
    \  roman_nums = []\n  roman_nums += \"MCMXLIV\"\n  roman_nums += \"MDCLXVI\"\n\
    \  roman_nums += \"MG\"\n  roman_nums += \"MM\"\n  roman_nums += \"III\"\n  roman_nums\
    \ += \"IV\"\n  roman_nums += \"V\"\n  roman_nums += \"I\"\n  roman_nums.each do\
    \ |num|\n    temp_roman_num = \"\"\n    roman_nums.each do |num|\n      temp_roman_num\
    \ += num\n      roman_nums.delete(num)\n    end\n    temp_roman_num.upcase!\n\
    \    roman_nums += temp_roman_num\n  end\n  roman_nums.delete('M')\n  roman_nums.delete('D')\n\
    \  roman_nums.delete('C')\n  roman_nums.delete('L')\n  roman_nums.delete('X')\n\
    \  roman_nums.delete('V')\n  roman_nums.delete('I')\n  roman_nums.delete('M')\n\
    \  roman_nums.delete('G')\n  roman_nums.delete('E')\n  roman_nums.delete('Y')\n\
    \  roman_nums.each do |num|\n    if num.length > 3\n      temp_roman_num = \"\"\
    \n      roman_nums.each do |num|\n        temp_roman_num += num\n        roman_nums.delete(num)\n\
    \      end\n      temp_roman_num.upcase!\n      roman_nums += temp_roman_num\n\
    \    end\n  end\n  roman_nums.each do |num|\n    roman_nums.delete(num)\n  end\n\
    \  roman_nums.each do |num|\n    roman_nums.delete(num)\n  end\n  roman_nums.each\
    \ do |num|\n    roman_nums.delete(num)\n  end\n  roman_nums.each do |num|\n  \
    \  roman_nums.delete(num)\n  end\n  roman_nums.each do |num|\n    roman_nums.delete(num)\n\
    \  end\n  roman_nums.each do |num|\n    roman_nums.delete(num)\n  end\n  roman_nums.each\
    \ do |num|\n    roman_nums.delete(num)\n  end\n  roman_nums.each do |num|\n  \
    \  roman_nums.delete(num)\n  end\n  roman_nums.each ", "  roman = String.new\n\
    \  roman = roman.succ! ('M') if number < 1000\n  roman = roman.succ! ('CM') if\
    \ number < 900\n  roman = roman.succ! ('D') if number < 500\n  roman = roman.succ!\
    \ ('CD') if number < 400\n  roman = roman.succ! ('C') if number < 300\n  roman\
    \ = roman.succ! ('XC') if number < 200\n  roman = roman.succ! ('L') if number\
    \ < 100\n  roman = roman.succ! ('XL') if number < 90\n  roman = roman.succ! ('X')\
    \ if number < 50\n  roman = roman.succ! ('IX') if number < 40\n  roman = roman.succ!\
    \ ('V') if number < 20\n  roman = roman.succ! ('IV') if number < 10\n  roman =\
    \ roman.succ! ('I') if number < 1\n  roman\nend", "  if number < 1 || number >\
    \ 1000\n    raise ArgumentError.new(\"The argument must be a positive integer\
    \ <= 1000\")\n  roman = Array.new(number)\n  for i in (0..number - 1)\n    roman[i]\
    \ = mini_roman_map.call(i)\n  end\n  roman.join\nend", "  # Handle edge case\n\
    \  if number <= 0\n    return \"0\"\n  if number <= 9\n    return string.downcase(number.to_s)\n\
    \  roman = Array.new\n  roman.push(\"M\")\n  roman.push(\"C\")\n  roman.push(\"\
    D\")\n  roman.push(\"CD\")\n  roman.push(\"C\")\n  roman.push(\"XC\")\n  roman.push(\"\
    L\")\n  roman.push(\"XL\")\n  roman.push(\"X\")\n  roman.push(\"IX\")\n  roman.push(\"\
    V\")\n  roman.push(\"IV\")\n  roman.push(\"I\")\n  roman.push(\"M\")\n  roman.push(\"\
    CM\")\n  roman.push(\"D\")\n  roman.push(\"CD\")\n  roman.push(\"C\")\n  roman.push(\"\
    XC\")\n  roman.push(\"L\")\n  roman.push(\"XL\")\n  roman.push(\"X\")\n  roman.push(\"\
    IX\")\n  roman.push(\"V\")\n  roman.push(\"IV\")\n  roman.push(\"I\")\n  roman.push(\"\
    V\")\n  roman.push(\"IX\")\n  roman.push(\"I\")\n  roman.push(\"V\")\n  roman.push(\"\
    V\")\n  roman.push(\"I\")\n  roman.push(\"I\")\n  roman.push(\"I\")\n  roman.push(\"\
    I\")\n  roman.push(\"I\")\n  roman.push(\"M\")\n  roman.push(\"CM\")\n  roman.push(\"\
    CM\")\n  roman.push(\"M\")\n  roman.push(\"D\")\n  roman.push(\"CD\")\n  roman.push(\"\
    CD\")\n  roman.push(\"D\")\n  roman.push(\"C\")\n  roman.push(\"C\")\n  roman.push(\"\
    XC\")\n  roman.push(\"C\")\n  roman.push(\"C\")\n  roman.push(\"XC\")\n  roman.push(\"\
    L\")\n  roman.push(\"L\")\n  roman.push(\"", "  roms = Array.new\n  (number %\
    \ 1000).to_i.times do |i|\n    roms << [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"\
    XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"].sample << \" \"\n  end\n\
    \  roms << [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\"\
    , \"IX\", \"V\", \"IV\", \"I\"].sample << \" \"\n  roms << [\"M\", \"CM\", \"\
    D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"\
    ].sample << \" \"\n  roms << [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"\
    L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"].sample << \" \"\n  roms << [\"\
    M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\"\
    , \"IV\", \"I\"].sample << \" \"\n  roms << [\"M\", \"CM\", \"D\", \"CD\", \"\
    C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"].sample << \"\
    \ \"\n  roms << [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"\
    X\", \"IX\", \"V\", \"IV\", \"I\"].sample << \" \"\n  roms << [\"M\", \"CM\",\
    \ \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"\
    I\"].sample << \" \"\n  roms << [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\",\
    \ \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"].sample << \" \"\n  roms\
    \ << [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\"\
    , \"V\", \"IV\", \"I\"].sample << \" \"\n  roms << [\"M\", \"CM\", \"D\", \"CD\"\
    , \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"].sample <<\
    \ \" \"\n  roms << [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\"\
    , \"X\", \"IX\", \"V\", \"IV\", \"I\"].sample << \" \"\n  roms << [\"M\", \"CM\"\
    , \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"\
    I\"].sample << \" \"\n  roms << [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\",\
    \ \"L\", \"XL\", \"X\", \"", "  result = ''\n  roman = Roman.new\n  roman.to_roman(number)\n\
    \  number -= roman.value\n  roman.to_mini(number)\n  number -= roman.value\n \
    \ roman.to_roman(number)\n  number -= roman.value\n  roman.to_mini(number)\n \
    \ number -= roman.value\n  roman.to_roman(number)\n  number -= roman.value\n \
    \ roman.to_mini(number)\n  number -= roman.value\n  roman.to_roman(number)\n \
    \ number -= roman.value\n  roman.to_mini(number)\n  number -= roman.value\n  roman.to_roman(number)\n\
    \  number -= roman.value\n  roman.to_mini(number)\n  number -= roman.value\n \
    \ roman.to_roman(number)\n  number -= roman.value\n  roman.to_mini(number)\n \
    \ number -= roman.value\n  roman.to_roman(number)\n  number -= roman.value\n \
    \ roman.to_mini(number)\n  number -= roman.value\n  roman.to_roman(number)\n \
    \ number -= roman.value\n  roman.to_mini(number)\n  number -= roman.value\n  roman.to_roman(number)\n\
    \  number -= roman.value\n  roman.to_mini(number)\n  number -= roman.value\n \
    \ roman.to_roman(number)\n  number -= roman.value\n  roman.to_mini(number)\n \
    \ number -= roman.value\n  roman.to_roman(number)\n  number -= roman.value\n \
    \ roman.to_mini(number)\n  number -= roman.value\n  roman.to_roman(number)\n \
    \ number -= roman.value\n  roman.to_mini(number)\n  number -= roman.value\n  roman.to_roman(number)\n\
    \  number -= roman.value\n  roman.to_mini(number)\n  number -= roman.value\n \
    \ roman.to_roman(number)\n  number -= roman.value\n  roman.to_mini(number)\n \
    \ number -= roman.value\n  roman.to_roman(number)\n  number -= roman.value\n \
    \ roman.to_mini(number)\n  number -= roman.value\n  roman.to_roman(number)\n \
    \ number -= roman.value\n  roman.to_mini(number)\n  number -= roman.value\n  roman",
  "  roman = \"\"\n  while number > 0\n    roman, number = roman.to_s + \"i\", number\
    \ - 1\n  end\n  roman\nend", "  result = ''\n  temp = 'M' * number\n  index =\
    \ 0\n  while number > 0\n    number -= 1\n    index = number % 5 + 1\n    result\
    \ += temp[index-1]\n  end\n  return result.downcase\nend", "  if number <= 0\n\
    \    raise_error(\"invalid input, integer must be positive\")\n  end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
