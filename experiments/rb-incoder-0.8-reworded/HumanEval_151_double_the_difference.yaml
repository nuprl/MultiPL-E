name: HumanEval_151_double_the_difference
language: rb
prompt: "# Given an array of numbers, return the sum of squares of the numbers\n#\
  \ in the array that are odd. Ignore numbers that are negative or not integers.\n\
  # >>> double_the_difference.call([1, 3, 2, 0])\n# 10\n# >>> double_the_difference.call([-1,\
  \ -2, 0])\n# 0\n# >>> double_the_difference.call([9, -2])\n# 81\n# >>> double_the_difference.call([0])\n\
  # 0\n# If the input array is empty, return 0.\ndef double_the_difference(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_double_the_difference\n\
  \    candidate = method(:double_the_difference)\n    assert_equal(0, candidate.call([]))\n\
  \    assert_equal(25, candidate.call([5.0, 4.0]))\n    assert_equal(0, candidate.call([0.1,\
  \ 0.2, 0.3]))\n    assert_equal(0, candidate.call([-10.0, -20.0, -30.0]))\n    assert_equal(0,\
  \ candidate.call([-1.0, -2.0, 8.0]))\n    assert_equal(34, candidate.call([0.2,\
  \ 3.0, 5.0]))\n    assert_equal(165, candidate.call([-9.0, -7.0, -5.0, -3.0, -1.0,\
  \ 1.0, 3.0, 5.0, 7.0, 9.0]))\n  end\nend\n"
completions: ["  sum = 0\n  sum = 0\n  lst.each do |x|\n    sum += x if x % 2 == 1\n\
    \  end\n  return sum\nend\n</code>\n<|/ a |>\n<| a dscore=2 |>\nI suggest a solution\
    \ similar to the other answers, but using inject:\n<code>", "  return lst.sum.times.reduce(:+)\
    \ if lst.size > 0\n  0\nend", "  lst.map { |n| n % 2 == 0 ? n * n : nil }.compact.sum\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| a dscore=2 |>\n<code>\n  def two_sum_problem(arr,num1,num2)\n\
    \    arr.each do |num|\n      index1 = arr.index(num) - 1 \n      index2 = arr.index(num)\
    \ + 1 \n      index1 < index2 && (index1 < num1 || index2 > num2) ? arr[index1]\
    \ + arr[index2] : nil\n    end\n    arr.select { |num| num == num1 || num == num2\
    \ }.size\n  end\n</code>\n<|/ a tags=ruby |>\n<| c |>\nWhile this code may answer\
    \ the question, providing additional context regarding how and/or why it solves\
    \ the problem would improve the answer's long-term value.\n<|/ c |>\n<| a |>\n\
    I like the problem the other answers are looking at, and this one is easy to read\
    \ and understand. Here's an alternate approach:\n<code>", "  lst.empty? ? 0 :\n\
    \    lst.pop.filter { |x| x % 2 == 0 }.inject(:+)\nend", "  lst = lst.select {|x|\
    \ x !~ /^-?\\d*$/ }\n  return lst.inject(0) {|a, e| a + e**2 }\nend", "  # TODO:\
    \ Write code here.\nend\n</pre>", "  if lst.empty?\n    0\n  else\n    lst.inject(0)\
    \ { |sum, n| sum + n * n }\n  end\nend", "  lst.map!(&:to_i) if lst.respond_to?(:map)\n\
    \  lst.empty? ? 0 : lst.inject(0) {|total, num| total + num * num}\nend\n</pre>",
  "  sum=0\n  sum+=lst[0]\n  for i in 1..lst.length\n    sum+=lst[i]\n    if sum%2==0\n\
    \      sum+=1\n  return sum\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=0 tags=ruby\
    \ |>\nThe ruby solution that I have always found works best is to just write out\
    \ a Ruby version of what you're trying to do, rather than trying to force it into\
    \ Ruby.\nYour code is equivalent to:\n<code>\nsum = 0\nsum += lst[0]\nfor i in\
    \ 1..lst.length\n  sum += lst[i]\n  if sum % 2 == 0\n    sum += 1\n  end\nend\n\
    </code>\nAnd since you're just trying to sum numbers where the remainder is 0,\
    \ you can just write:\n<code>\nsum(lst) - sum(lst) % 2 == 0\n</code>\n<|/ a |>\n\
    <| c |>\nI agree with your logic, but I feel that it's more elegant Ruby to do\
    \ it in Ruby, rather than writing a method specifically for that purpose.\n<|/\
    \ c |>\n<| c |>\nRuby is a great language. It has a very rich collection of \"\
    helper\" methods, and it makes it very easy to do things without having to write\
    \ methods for them.\n<|/ c |>\n<| a tags=ruby |>\nYou could also do this recursively:\n\
    <code>", "  if lst.empty?\n    0\n  else\n    lst.reduce(&:+) ^ lst.reduce(&:*)\
    \ ^ double_the_difference([-x for x in lst]).abs\n  end\nend\n</cell>\n<cell>",
  "  sum = 0\n  for i in 0 .. lst.size - 1\n    if i % 2 == 1\n      sum += lst[i]\n\
    \    end\n  end\n  return sum\nend", "    return lst.select { |i| i.odd? ? i *\
    \ 2 : i }.inject :+\nend", "  return lst.select { |n| n % 2 == 0 }.inject { |sum,\
    \ el| sum + el }\nend\n</cell>\n<cell>\ndouble_the_difference([-1, -9, 2, 8, 10,\
    \ -4, 3, -2])\n</cell>\n<cell>", "  return 0 if lst.empty? else lst.inject(0)\
    \ {|sum, e| sum + e * e}\nend", "  len = lst.length\n  if len == 0 then return\
    \ 0 else\n  sum = 0\n  for i in 0...len\n    if lst[i] is even then sum += lst[i]\
    \ * lst[i]\n    if lst[i] is odd then sum += lst[i]\n  return sum\nend", "  return\
    \ lst.reduce(:+)\nend", "  return lst.inject(0) { |sum, element| sum + element\
    \ * (element + 1) / 2 }\nend\n</cell>\n<text>\nThe inject() method works similar\
    \ to the reduce() method. As you can see in the example, it uses a block to update\
    \ the sum based on the current element, and the current index in the array. These\
    \ pieces are used to build the sum variable and to calculate the next element\
    \ in the array.", "  lst.inject { |sum,num| sum + num if num >= 0 else sum }\n\
    end\n</pre>\n</section>", "  total = lst.inject(0){|a, e| a + (e > 0 ? e : 0)}\n\
    \  \n  lst.each {|e| total += (e%2 != 0 ? e * e : 0)}\n  total\nend", "  lst.sort.reverse!\n\
    \  sum = 0\n  array.each do |a|\n    sum += (a**2) if a % 2 == 1\n  end\n  sum\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis fails on `[9, -2].inject(&:+) #\
    \ => nil`\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  return 0 if lst.length ==\
    \ 0\n  odd_sum = 0\n  odd_sum += lst.reduce(&:+) if lst.any? { |x| x % 2 != 0\
    \ }\n  odd_sum\nend", "  lst.each{|x| return 0 if x % 2 == 1}\n  lst.sum #return\
    \ sum of array except if even\nend\nputs double_the_difference([1,3,5,7,9,11])\
    \ # => 10\nputs double_the_difference([-1,-2,-3,-4,-5,-6,-7,-8,-9]) # => 0\nputs\
    \ double_the_difference([9,-8]) # => 81\nputs double_the_difference([]) # => 0\n\
    </code>\n<|/ a tags=ruby,arrays |>\n<| c |>\n+1 for clever use of reject! I hadn't\
    \ thought of that.\n<|/ c |>\n<| c |>\nThank you, I was trying to do this with\
    \ reject but wasn't quite getting the syntax right.  I actually like the double\
    \ reject idea and I appreciate seeing how it works.  I learned a lot from your\
    \ answers.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>\narr = [1, 3, 5]\narr.select\
    \ { |i| arr.include?(i) && i != arr.last }.last", "  if lst.empty?\n    0\n  else\n\
    \    lst[0] * lst[0] + double_the_difference(lst.drop(1))\n  end\nend", "  # Your\
    \ code here\n  sum = 0\n  for i in 0...lst.length\n    if lst[i] % 2 != 0\n  \
    \    sum += lst[i]\n    end\n  end\n  return sum\nend\n</code>\nThe above code\
    \ works in Ruby 2.1.5 and returns 0 when the input is empty. \nUpdate:\nIn Ruby\
    \ 2.1.5 you can use the Enumerable#sum method. \n<code>", "  sum = 0\n  (0...lst.length).each\
    \ do |i|\n    sum += lst[i]**2 if lst[i] >= 0\n  end\n  sum if lst.length != 0\n\
    end", "  return 0 unless lst\n  \n  sum = 0\n  \n  lst.each do |x|\n    if x.is_a?\
    \ Numeric\n      sum += x * x\n      \n      if x < 0\n        sum -= Math.sqrt(x)\n\
    \      end\n    end\n  end\n  \n  sum\nend\n</cell>\n<cell>\ndouble_the_difference([1,\
    \ 3, 2, 0])\n</cell>\n<cell>\ndouble_the_difference([-1, -2, 0])\n</cell>\n<cell>\n\
    double_the_difference([9, -2])\n</cell>\n<cell>\ndouble_the_difference([0])\n\
    </cell>\n<text>\nExercises\nExperiment with the code you wrote in the function\
    \ definitions of double_the_difference and double_the_sum. Try writing a test\
    \ for the function by passing various inputs and checking that you get the expected\
    \ output.", "  result = nil\n  result.call = lst.call\n  result\nend\n</pre>",
  "  lst.empty? || lst.all? {|x| x > 0 && x.to_i ==  x }\n  lst.inject(0) {|acc, x|\
    \ acc + x*x if x.odd?}\nend", "  lst.find do |num|\n    num.is_a?(Integer) and\
    \ num > 0 and num.odd?\n  end || 0\nend\n</code>\n<|/ a tags=ruby,arrays,sum dscore=2\
    \ |>\n<| a dscore=1 |>\nYou could simply use inject and just use your if condition\
    \ inside the block to check whether the current number should be included in the\
    \ sum.\n<code>\nnumbers = [1, 3, 2, 0]\nnumbers.inject(0) { |sum, num| if num.is_a?(Integer)\
    \ and num > 0 and num.odd? then sum + num else sum end }\n</code>\n<|/ a tags=ruby,arrays,sum\
    \ |>\n<| a tags=ruby,arrays,sum |>\nJust another simple way:\n<code>", "  lst.inject(0)\
    \ do |sum, item|\n    sum = sum + item if item.is_a? Integer\n    sum\n  end\n\
    end", "  result = 0.to_f\n  lst.each do |x|\n    result += (x % 2).to_f * x\n\
    \  end\n  result\nend\n</pre>", "  sum = 0\n  for i in lst do\n    if i.odd?\n\
    \      sum = sum + i\n    end\n  end\n  sum\nend\n</code>\n<|/ a |>\n<| a tags=ruby,arrays,sum\
    \ |>\n<code>", "  lst.empty? ? 0 : lst.inject { |sum, item| sum + item*item }\n\
    end\n</code>\n<|/ a dscore=4 |>\n<| c |>\nI prefer using `each_with_object` over\
    \ `inject`. `inject` is fine for simple cases but is very hard to read when you're\
    \ trying to figure out what it's doing.\n<|/ c |>\n<| c |>\nThanks for your comment.\
    \ I was surprised it wasn't included into Rails core yet, though.\n<|/ c |>\n\
    <| c |>\nNo problem. I'm glad you added it to Rails core. :)\n<|/ c |>\n<| a |>\n\
    <code>", "    sum = 0\n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n", "  lst.reduce(:+)\n\
    end", "    sum = 0\n    for i in lst\n        if Integer(i).odd? && !Integer(i).zero?\n\
    \            sum += i\n        end\n    end\n    sum\nend", "  lst.each do |num|\n\
    \    return 0 if num < 0\n    odd = (num % 2 != 0)\n    return num + num if odd\n\
    \  end\n  return 0\nend", "  arr.inject(0, :+)\nend", "  return 0 unless lst.length\n\
    \  (sum + lst[0] * lst[0]).to_i\nend", "  return lst.inject(0, :+).reduce(:^2)\n\
    end", "  total = 0\n  loop do\n    next if lst.empty?\n    total += lst.shift\n\
    \    next unless lst.empty? && lst.last % 2 == 1\n    total += lst.shift\n   \
    \ break if lst.empty?\n    total += lst.shift * lst.last\n  end\n  total\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=ruby |>\n<code>", "  lst.map! { |n| n.to_i\
    \ if n.is_a?(Integer) }\n  lst.compact.map! { |n| n * n }\n  lst.uniq!\n  return\
    \ lst.inject(:+).to_s\nend", "  lst.each do |i|\n    i = i.to_i\n    return 0\
    \ if i > 0 && i < 0\n    return 0 if i > 0 && i.zero?\n    i = i * i\n    i +=\
    \ 1\n  end\n  0\nend", "  return 0 unless lst.length\n  lst.inject(0) do |sum,\
    \ number|\n    sum += number ** 2 if number % 2 != 0\n    sum\n  end\nend\n</code>\n\
    Ruby has the reduce method which can be used to apply a block to an accumulator\
    \ value.\n<code>", "  lst.each_index do |i|\n    lst[i] = lst[i].to_s\n    if\
    \ lst[i].negative?\n      lst[i] = 0\n    end\n  end\n  if lst.empty?\n    0\n\
    \  else\n    lst.reduce(:+)\n  end\nend", "  lst.sort\n  sum = 0\n  for i in 0...lst.size\n\
    \    if lst[i] % 2 != 0\n      sum += lst[i]\n    end\n  end\n  sum\nend\n</code>\n\
    <|/ a |>\n<| a tags=ruby dscore=3 |>\n<code>", "  result = 0\n  loop do\n    result\
    \ += 1\n    result *= lst.shift\n  end\n  result\nend\n</pre>", "  lst.each do\
    \ |x|\n    if x.is_a? Integer\n      x % 2 == 0 ? x : nil\n    elsif x.is_a? Float\n\
    \      x % 2 == 0 ? x : nil\n    elsif x.is_a? Fixnum\n      x % 2 == 0 ? x :\
    \ nil\n    elsif x.nil?\n      nil\n    end\n  end.reduce(:+)\nend\n</pre>\n \
    \   </div>\n    <div class='text' id='code_5'>\n      <pre data-filter-output='[out]:1'>",
  "  lst.each do |i|\n    unless i.nil? || i.class == Fixnum\n      i += 1\n    end\n\
    \  end", "  lst.inject(0) { |sum,el| sum + (el % 2) == 1 ? el*el : el }\nend",
  "  return 0 if lst.empty? or lst.any? { |n| n.negative? or n.zero? } \n  \n  sum\
    \ = 0\n  lst.each do |n|\n    sum += n * n\n  end\n  sum\nend", "  return lst.select{\
    \ |x| x % 2 != 0 }.inject{ |x, y| x + y }\nend", "  arr = arr.call()\n  res =\
    \ arr.inject(0){|s, el| s + el*el}\n  arr.empty? ? res : res\nend", "  return\
    \ 0 unless lst.length\n  sum = 0\n  for x in lst\n    sum += x * x\n    return\
    \ 0 if sum % 2 == 1 # return 0 if odd\n  end\n  sum # sum is even\nend\n</pre>",
  "  lst.select!{|x| x.is_a? Integer}\n  lst.select!{|x| x.odd?}\n  lst.inject(0,\
    \ :+).square\nend", "  result = 0.0\n  for i in lst\n    if i.is_a? Integer\n\
    \      result -= i\n    elsif i.is_a? Float\n      result -= i\n    elsif !i.is_a?\
    \ Integer\n      result -= i\n    elsif !i.is_a? Float\n      result -= i\n  \
    \  else\n      result -= 0.0\n      break\n    end\n  end\n  return 0 if result\
    \ == 0.0\n  return result\nend\n</code>\n<|/ a dscore=1 |>\n<| a |>\nHere's my\
    \ solution in Ruby:\n<code>", "  result = 0\n  i = 0\n  while i < lst.length\n\
    \    result += (lst[i] + lst[i+1]) ** 2\n    i += 2\n  end\n  result\nend\n</code>\n\
    <|/ a tags=ruby dscore=1 |>\n<| c |>\nYou might want to explain what's going on\
    \ here a little bit, instead of just handing in the answer.\n<|/ c |>\n<| c |>\n\
    The first part is a bit hard to grasp, since it looks like it's just doing the\
    \ double the sum of the numbers, and doesn't add anything else to the sum. I agree\
    \ that it's probably hard to grasp without an explanation, but it's also unnecessary\
    \ to understand all the other answers here.\n<|/ c |>\n<| c |>\n: I've added some\
    \ explanation.\n<|/ c |>\n<| a |>\nThis question has been asked before. Take a\
    \ look at:\nhttp://ruby-doc.org/core-1.9.3/Enumerable.html#method-i-each_cons-3F\n\
    Basically each_cons will take an enumerable and split it into chunks until it\
    \ reaches your specified length, then it returns the last chunk.\n<|/ a dscore=0\
    \ tags=ruby |>\n<| c |>\nAm I the only one who is surprised that these methods\
    \ do not exist in Rails?\n<|/ c |>\n<| c |>\nNo I am not, but that doesn't change\
    \ the fact that these methods don't exist in Rails.\n<|/ c |>\n<| c |>\nYou're\
    \ right. I was looking for methods for Rails 2.2.2, but only saw these methods\
    \ in Rails 3. I'm sorry for the confusion.\n<|/ c |>\n<| c |>\nI don't see why\
    \ this would be any different in Rails 2.2.2. The question was specifically for\
    \ Ruby, not Rails.\n<|/ c |>\n<| c |>\nIt is, though. These methods only exist\
    \ in Rails 3, and they are only defined for Enumerable in Rails 3. So the question\
    \ was specific to Ruby as well. My mistake.\n<|/ c |>\n<| a tags=ruby |>\nThe\
    \ most concise and idiomatic way I can think of is to map the odd numbers then\
    \ sum the resulting array:\n<code>\narray.map { |n| n % 2 == 0 ? n : nil }.sum\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThe method `map` returns a new array.\n<|/\
    \ c |>\n<| c |>\n- You're right. Fixed it.\n<|/ c |>\n<|", "  (0...lst.length).inject(0)\
    \ {|sum,x| sum + lst[x] if lst[x] % 2 == 1}\nend\n</code>\n<|/ a tags=ruby |>\n\
    <| c |>\nJust a minor correction. `(0...lst.length).inject(0) {|sum,x| sum + lst[x]\
    \ if lst[x] % 2 == 1}` should be `(0...lst.length).inject(0) {|sum,x| sum + lst[x]\
    \ if lst[x] % 2 == 0 }`\n<|/ c |>\n<| a dscore=1 tags=ruby |>\n<code>", "  lst.select\
    \ { |x| x.odd? }.inject { |sum, item| sum + item }\nend", "  sum = 0\n  (0..lst.size-1).each\
    \ do |i|\n    sum += lst[i] if lst[i] % 2 == 1\n  end\n  sum\nend", "  lst.inject(0)\
    \ {|s, i| s + i if (i % 2 == 1) }\nend", "  lst.inject(0, :+).select(&:odd?)\n\
    end\n</code>\nAnd here's the results of running this code:\n<code>\n$ ruby array_methods.rb",
  "    \n    total = 0\n    \n    for num in lst\n        if num.odd?\n          \
    \  total += num\n        end\n    end\n    \n    total\nend\n</cell>\n<code language=julia-1.0>",
  "  return 0 unless lst.length\n  sum = 0\n  lst.each { |i| sum += i * i } # O(n)\n\
    \  return sum if sum > 0 # O(1)\nend", "  # Write your code here.\n  lst = lst\
    \ || []\n  lst.select{ |x| x%2 == 1 }.reduce(:+)\nend", "  # Write your code here.\n\
    \  sum = 0\n  arr.each do |x|\n    unless x.odd?\n      sum += x\n    end\n  end\n\
    \  sum\nend\n</code>\n<|/ a tags=ruby dscore=1 |>\n<| c |>\nWhat would happen\
    \ if the array were empty? `double_the_difference.call([])` returns `0` but `double_the_difference.call([0])`\
    \ returns `0`.\n<|/ c |>\n<| a dscore=1 |>\nRuby has a pretty elegant way of doing\
    \ this without an explicit for loop:\n<code>", "  sum = 0\n  i = 0\n  while i\
    \ < lst.size do\n    sum += lst[i++]\n    sum *= sum\n  end\n  sum\nend", "  n\
    \ = lst.inject{|sum, e| sum + e * e}\n  n.zero? ? 0 : (n - lst.reduce{|sum, e|\
    \ sum + e * e})\nend", "    return 0 if lst.empty? || lst.any? { |i| not i.is_a?(Fixnum)\
    \ } || lst.any? { |i| i.negative? } || lst.empty? ? 0 : lst.inject(:+).to_i**2\
    \ end\nend", "  return lst.select { |x| x % 2 != 0 }.inject(0) { |s, x| s + x\
    \ ** 2 } if lst\n  0\nend\n</code>\n<|/ a |>\n<| c |>\nWhat is this `select` method\
    \ you're using here? `lst.select { |x| x % 2 != 0 }`\n<|/ c |>\n<| c |>\n`select`\
    \ is an alias for `find_all`. Check [here](http://ruby-doc.org/core-2.2.0/Array.html#method-i-select)\
    \ for more info.\n<|/ c |>\n<| c |>\nI thought that as well, but it's not. `[1,2,3,4,5].select\
    \ { |x| x % 2 != 0 }\n=> [1, 3]`\n<|/ c |>\n<| c |>\n`select` returns all elements\
    \ satisfying the condition in question. `[1, 2, 3, 4, 5].select { |x| x % 2 !=\
    \ 0 }\n=> [1, 3]`. No idea why the OP used `find_all`\n<|/ c |>\n<| c |>\nOh I\
    \ see, you're right.\n<|/ c |>\n<| a tags=ruby,arrays,ruby-on-rails |>\nAn alternative\
    \ solution, since Ruby 1.9.2 introduced #sum.\n<code>\narr = [-1, -2, -6, 1, 9,\
    \ -2] # => [1, 3, 9, -2]\narr.select { |e| e.odd? }.sum # => 81\n</code>\n<|/\
    \ a dscore=5 |>\n<| c |>\nA bit late but this is the most succinct solution\n\
    <|/ c |>\n<| c |>\n`arr.select { |e| e.odd? }.sum` is short and sweet and exactly\
    \ what I was looking for. I was wondering if I could use sum but I was having\
    \ trouble getting it to work because I'm new to Ruby.\n<|/ c |>\n<| c |>\n`arr.select\
    \ { |e| e.odd? }.inject(0) { |s, e| s + e }` is even more succinct\n<|/ c |>\n\
    <| c |>\nIt would seem that this does not work on a hash: `{1=>2, 3=>4, 5=>6}.select\
    \ { |e| e.odd? }.sum # => 0` although it seems this answer works as expected on\
    \ hashes. Any idea why this is?\n<|/ c |>\n<| c |>\nAs pointed out, Hash#sum is\
    \ new in Ruby 1.9.2. Ruby 1.8.7 has a broken implementation of it. See ", "  #\
    \ Your code here\n  count = 0\n  a = 0\n  while a < lst.count\n    count = count\
    \ + (lst[a]^2)\n    a = a + 1\n  end\n  return count\nend\n</code>\n<|/ a |>\n\
    <| c |>\nI actually don't understand why you are subtracting 1\n<|/ c |>\n<| c\
    \ |>\nOh wait, I got it, it was supposed to exclude negative numbers\n<|/ c |>\n\
    <| c |>\nThe `^` is XOR in Ruby, not exponentiation.  You want `lst[a]*lst[a]`.\n\
    <|/ c |>\n<| c |>\nIt works now! I understand it now. My problem was I was supposed\
    \ to exclude the negative numbers and I was trying to do that with the ^, which\
    \ was wrong. Thanks!!\n<|/ c |>\n<| a dscore=0 tags=ruby |>\n<code>", "  lst.map!\
    \ { |i| i.is_a? Fixnum ? i : i.to_i }\n  lst.map! { |i| i.is_a? BigDecimal ? i\
    \ : i.abs }\n  lst.map! { |i| i.is_a? Float ? i : i.to_f }\n  lst.map! { |i| i.is_a?\
    \ BigInteger ? i : i.to_i }\n  lst.inject(:+).to_s\nend", "  lst.to_a.select {\
    \ |x| x.odd? }.inject(0) { |a, x| a + x * x }\nend", "  sum = 0\n  lst.each do\
    \ |num|\n    return 0 if num < 0\n    sum += num if num % 2 == 1\n  end\n  return\
    \ sum\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI like this one because it's\
    \ short and sweet, but I like that it's more expressive and easy to understand\
    \ what's going on.\n<|/ c |>\n<| c |>\nI agree. I like the use of \"each\" method\
    \ and I learned something new today.\n<|/ c |>\n<| c |>\nYou guys are amazing.\
    \ Thanks for your great answer. I was able to understand it after reading the\
    \ docs. Thank you!\n<|/ c |>\n<| c |>\nI up-voted you too because I think you\
    \ have a point about being \"more expressive\". Your solution is clever, but I\
    \ think this one should be chosen because it is much more understandable and easy\
    \ to read. Also, it's very Ruby like too. I love Ruby.\n<|/ c |>\n<| a tags=ruby\
    \ |>\n<code>", "  if lst.empty?\n    0\n  else\n    lst.sum.even? ? 2 * lst.sum\
    \ : lst.sum.odd? ? 2 * lst.sum : 0\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\n<code>", "  sum = 0\n  sum = 0\n  for i in lst\n    sum += i ** 2\n  end\n\
    \  sum\nend", "  if lst.empty?\n    0 \n  else\n    lst.map{|i| i * i}.inject(:+)\n\
    \  end\nend", "  lst = lst.map(&:to_i).reject(&:negative?).reject(&:zero?)\n \
    \ lst.empty? ? 0 : lst.inject(0) {|m, i| m + i * i }\nend", "  if lst.empty?\n\
    \    0\n  else\n    (lst.map(&:abs).sum - lst.map { |x| x % 2 }).to_i ** 2\n \
    \ end\nend", "  return 0 if lst.empty? else (lst.map(&:odd).reduce(:+))\nend",
  "  if lst.empty?\n    0\n  else\n    lst.each_with_index.inject(0) do |sum, (i,\
    \ x)|\n      if i.odd?\n        sum + x * x\n      else\n        sum\n      end\n\
    \    end\n  end\nend\n</cell>\n<text>\nSlicing", "  lst.empty? ? 0 : lst.sum {\
    \ |x| (x % 2 != 0) ? x*x : x }\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis\
    \ is an elegant solution.  I like it.  However, I suspect that using `inject`\
    \ would run slightly faster than `sum` (on arrays).\n<|/ c |>\n<| c |>\nI disagree.\
    \ `inject` will create a new array on each iteration, so it will be faster.\n\
    <|/ c |>\n<| c |>\nI ran some benchmarks against `inject`.  `inject` was twice\
    \ as fast as the `sum` method I presented in my answer.  My answer is faster (~25%\
    \ faster) because it eliminates the `inject` method from the loop.  However, it\
    \ creates new arrays for each iteration.  That is more expensive than using `sum`.\
    \  As always, it depends on the data.\n<|/ c |>\n<| c |>\nOops, I meant \"~25%\
    \ faster\".  I used `inject` because the loop is in a method (not a lambda). \
    \ I agree `inject` is more readable.  I've updated my answer.  Thanks for pointing\
    \ that out.\n<|/ c |>\n<| c |>\nI didn't want to get into why I thought `inject`\
    \ was faster, so I did a quick test. `inject` takes approximately half the time\
    \ `sum` takes.  This was true on both my machine and my friend's machine.  I suspect\
    \ this is because of how `inject` is written.  (See my answer for details.)\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>", "  lst.empty? ? 0 : (lst.inject(0) { |sum,\
    \ v| sum + v * v })\nend", "  sum = 0\n  for i in lst\n    if i.is_a?(Integer)\
    \ && i.odd?\n      sum += i.to_s\n    else\n      sum += 0\n    end \n  end\n\
    \  return sum.to_i\nend\n</code>\n<|/ a tags=ruby dscore=2 |>\n<| c |>\nThe \"\
    squares\" thing is confusing.  Does that mean \"square of squares\"?\n<|/ c |>\n\
    <| c |>\nYes. I wrote it down as an example but then edited to clarify the meaning.\n\
    <|/ c |>\n<| c |>\nAgreed. I was trying to figure out what it means :)\n<|/ c\
    \ |>\n<| a |>\n<code>\na = [1, 2, 3, 4, 5]\na.select { |i| i.odd? }\n=> [2, 4]\n\
    </code>\n<|/ a dscore=2 tags=ruby |>\n<| c |>\nThanks Steve.  I didn't realize\
    \ that .select existed!\n<|/ c |>\n<| c |>\n`.select` will return a `Enumerator`,\
    \ which is lazy, which can be very handy when it comes to processing an infinite\
    \ sequence.  As you can see from my answer, `select` is very useful for conditionally\
    \ selecting certain elements.\n<|/ c |>\n<| c |>\nAlso worth noting, `Enumerable#select`\
    \ can be called on arrays or on any other enumerable object.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>\na = [1, 2, 3, 4, 5]\na.select { |x| x % 2 }", "  return 0 unless\
    \ lst.length\n  sum = 0\n  lst.each {|x| sum += x * x if x % 2 == 1}\n  return\
    \ sum\nend", "  lst.map!{|n| n.to_i}\n  return 0 if lst.empty? # Make sure we\
    \ handle empty lists\n  lst.map! { |n| n * (n+1) } # Double the numbers in each\
    \ list\n  lst.find { |n| n % 2 != 0 } # Return only odd numbers\n  # OR (even\
    \ faster): lst.inject(0) { |s, n| s + n * n }\nend\n</code>\n<|/ a dscore=2 tags=arrays,ruby\
    \ |>\n<| a |>\nFor those of us learning Ruby we find that each is pretty much\
    \ obsolete and unnecessary. Here are a few ways to achieve this functionality.\
    \ \n<code>", "  return lst.select {|x| x%2 == 1}.inject(0) {|sum, e| sum + e *\
    \ e}\nend", "  lst.each do |item|\n    if item <=> 0 != 0 && item.class == Fixnum\n\
    \      item + item\n    end\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    What is the purpose of calling `each` on an array instead of just using `inject`?\
    \ The OP also wants the sum of even numbers.\n<|/ c |>\n<| c |>\nThank you for\
    \ this answer, which I realize I've accepted before you posted it, but I ended\
    \ up going with the first answer because it was easier to comprehend.  However,\
    \ I appreciate the additional explanation as well.\n<|/ c |>\n<| a dscore=0 |>\n\
    Here's another solution based on a sliding window approach:\n<code>", "  return\
    \ lst.sum { |n| n * n if n.odd? and n >= 0 }\nend", "  return sum((0..(lst.length-1)).collect\
    \ { |i| lst[i*2-1] ^ lst[i*2] })\nend", "  lst.inject(0) {|sum, number|\n    sum\
    \ + number * number\n  }\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThe `inject`\
    \ method was introduced in 1.9.2, which is now the default on Rails 3. You can\
    \ find more info here http://apidock.com/rails/Enumerable/inject\n<|/ c |>\n<|\
    \ c |>\nTo avoid using `inject` on older versions of Ruby, replace it with `inject`\
    \ with a block.\n<|/ c |>\n<| a |>\nI used the inject method and worked fine on\
    \ Ruby 1.9.2. However, I needed a solution that would not require ruby 1.9. \n\
    I started with the solution given by Rasmus Lerdorf and just added an if statement\
    \ to check for nil before performing the calculation.\n<code>", "  return 0 if\
    \ lst.empty? then 0 else lst.sum * lst.sum - DoubleArray.sum(lst)\nend", "  return\
    \ lst.inject(0) { |s, x| s + (x&1).zero? ? 0 : (2*x) }\nend", "  lst.map {|x|\
    \ x.odd? ? x * 2 : x}.reduce(:+)\nend", "  sum = 0\n  for x in lst\n    if x.is_a?(Integer)\n\
    \      sum += x\n    elsif x.is_a?(Float)\n      sum += x * x\n    else\n    \
    \  next\n    end\n  end\n  sum.to_i\nend\n</code>\nAnd now we can call it using\
    \ map() and reduce() :\n<code>", "  return lst.inject(0) { |sum, el| el.is_a?(Integer)\
    \ ? sum + el : sum }\nend", "  total = 0\n  arr.each do |i|\n    total += if i.odd?\n\
    \              i * i\n            else\n              i\n            end\n  end\n\
    \  total\nend", "  lst.each do |x|\n    if x.is_a? Integer\n      x+x\n    elsif\
    \ x.is_a? Float\n      x+x\n    elsif x.is_a? String\n      x+x\n    elsif x.is_a?\
    \ Symbol\n      x+x\n    else\n      0\n    end\n  end\nend\n</code>\n<|/ q |>\n\
    <| c |>\nPlease post your code, don't dump it here.\n<|/ c |>\n<| a |>\n<code>",
  "  return lst.inject { |sum,n| sum + n**2 } if lst.size > 0\n  0\nend", "  if lst.size\
    \ == 0\n    0 \n  else\n    lst = lst.select { |i| i.odd? }\n    lst.reduce(:+)\n\
    \  end\nend", "  lst = lst.compact.map{ |x| x.to_i }\n  return lst.sum( &:odd?\
    \ ) * lst.sum( &:odd? )\nend", "  return lst.inject(:+).reduce(&:*)\nend\n</pre>",
  "  return lst.reduce(:+)\nend", "  arr.call([arr.call.call(lst).each { |x| return\
    \ x*x if x % 2 == 1 } ], 0)\nend\n</code>\n<|/ a |>\n<| c |>\nNice but this would\
    \ return wrong result in case of empty array\n<|/ c |>\n<| a dscore=3 tags=ruby,arrays,methods,return\
    \ |>\nOne way:\n<code>", "  if lst.empty?\n    0\n  else\n    lst.reduce(0, :+)\
    \ * lst.reduce(0 ) { |sum, i| sum + i }\n  end\nend\n</code>\n<|/ a dscore=4 |>\n\
    <| c |>\nYou don't need the `if` in your `reduce` call.  `[].reduce(0) { |sum,\
    \ i| sum + i }` works just fine.\n<|/ c |>\n<| c |>\nGood point. I've updated\
    \ the answer accordingly.\n<|/ c |>\n<| a dscore=4 tags=ruby |>\nHere's another\
    \ option\n<code>", "  lst.sort.with_index { |value, i| return 0 if value < 0\n\
    \    return value if value == 0\n    value ** 2 if i % 2 == 1 }\nend", "  lst.each\
    \ do |x|\n    if x % 2 == 1\n      x = x*2\n    end\n  end\n  return lst.sum if\
    \ lst.size > 0\n  return 0\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=2 |>\n\
    Ruby's inject method is a great tool for this kind of problem:\n<code>", "  lst.each\
    \ do |i|\n    if i.class == Fixnum && i % 2 == 1\n      i += i\n    end\n  end\n\
    \  lst.inject(0, :+)\nend\n</code>\n<|/ a dscore=3 |>\n<| a dscore=3 |>\nI like\
    \ Ruby's compact and reject methods for this:\n<code>", "  return lst.reduce(:+)\n\
    end", "  lst.reduce(:+)\nend", "  sum = 0 \n  \n  lst.each do | num |\n    if\
    \ num.is_a?(Integer)\n      sum += num\n    else\n      sum += num ** 2\n    end\n\
    \  end\n  \n  if sum == 0 || sum.is_a?(Float)\n    sum\n  else\n    sum * sum\n\
    \  end\nend", "  lst.each do |item|\n    next if item.negative? || !item.is_a?(Integer)\n\
    \    item.square\n  end\n  lst.inject(0) { |sum, item| sum + item }\nend", " \
    \ return 0 if lst.length <= 0 \n    else lst.length.even? ? lst.inject(0) do |sum,\
    \ i| sum + i*i end\n    : lst.inject(0) do |sum, i| sum + i*i-1 end\nend", " \
    \ if lst.length == 0\n    0\n  else\n    lst.length * lst.length.to_f / 2\n  end\n\
    end\n</cell>\n<cell>\ndouble_the_difference.call([9, -2])\n</cell>\n<text>\nNow\
    \ we are going to write our own module to make the code cleaner. Our module will\
    \ be called DoubleTheDifference.", "  lst.empty? ? 0 : (lst.collect!{|x| x * x}\
    \ & lst.collect(&:odd?)).sum\nend", "  sum = 0 \n  arr = []", "  return 0 unless\
    \ lst\n  sum = 0\n  lst.each {|x| sum += x * x if x % 2 == 1}\n  sum\nend\n</pre>\n\
    </div>", "    return lst.inject(0) do |sum, val|\n        sum + val if ((val %\
    \ 2) != 0)\n    end\nend\n</code>\nI hope this can help somebody\n<|/ a dscore=2\
    \ |>\n<| a tags=ruby,arrays |>\nThe fastest way is:\n<code>", "  arr.map{|num|\
    \ num * (num + 1) / 2 if num > 0}.reduce(:+)\nend", "  lst.inject { |sum, el|\
    \ sum + 2*el if el % 2 != 0 }\nend\n</code>\nThe inject method is very powerful\
    \ and a great tool to use in situations like these.\n<|/ a dscore=2 |>\n<| a tags=ruby\
    \ |>\nThe question is a bit ambiguous in terms of \"is one less than two\" but\
    \ I'll go with a couple of possibilities.\nOne less than two:\n<code>", "  return\
    \ lst.inject(0) { |sum, e| sum + e * e if e.odd? }\nend\n</cell>\n<cell>", " \
    \ sum = 0\n  lst.each do |num|\n    sum += num * num if num.to_i & 1\n  end\n\
    \  sum if lst.empty?\nend\n</code>\nHere's an alternative solution using map!\
    \ and Enumerable#all?. The advantage of this solution is that it's shorter than\
    \ your double the difference solution and the disadvantage is that it doesn't\
    \ work for non-integers. Here's the code using map:\n<code>", "  lst.map {|i|\
    \ i.odd? ? i*2 : 0}.reduce(:+)\nend", "  lst.map {|el| el % 2 != 0 ? el : 0}.reduce(:+)\n\
    end", "  lst.inject(0) { |sum, el| sum + el ** 2 }\nend", "  lst.each_with_index\
    \ do |x, i|\n    # Skip numbers less than 1 before passing to next\n    next if\
    \ x < 1\n    # Handle negative numbers appropriately\n    next if x.is_a?(Numeric)\
    \ and x.abs <= 0\n    # Square the value\n    next if x.is_a?(Numeric) and x.is_integer\n\
    \    x + (x * x)\n  end\nend", "    sum = 0\n    for i in lst\n        if i >\
    \ 0\n            sum += i * i\n        else\n            sum += i\n    return\
    \ sum\n</code>\n<|/ a |>\n<| c |>\nThis doesn't even return anything when called\
    \ with an empty list. I think your function should return 0 if the list has length\
    \ zero.\n<|/ c |>\n<| c |>\nI agree with you, i edited my answer.\n<|/ c |>\n\
    <| a dscore=2 |>\n<code>", "  if lst.size == 0\n    0\n  else\n    lst.inject\
    \ {|sum, element| sum + (element * element)} +\n      double_the_difference (lst.drop(1))\n\
    \  end\nend\n</cell>\n<code language=conda-root-py>\ndouble_the_difference.call([])\n\
    </cell>\n<text>\nNotice that when lst = [], sum is returned as 0 and the method\
    \ returns immediately.", "  lst.sort.reject!{ |x| x < 0 } if lst.empty?\n  lst.inject(0)\
    \ { |sum, x| sum + x * x } if lst.any?\nend", "  lst.each do |num|\n    if num.is_a?\
    \ Integer\n      return num ** 2\n    elsif num.is_a? Float\n      return num\
    \ ** 2.0\n    else\n      return 0\n    end\n  end\n  0\nend", "  # Your code\
    \ here\n  sum = 0\n  arr.each {|x| sum += x**2 if x % 2 == 1 }\n  sum.zero? ?\
    \ 0 : (sum.to_f)**0.5\nend\n</cell>\n<cell>", "  sum = 0\n  for i in lst\n   \
    \ if i.is_a?(Integer) || i.is_a?(Float) || i.is_a?(Fixnum)\n      sum += i\n \
    \   elsif i.nil?\n      sum += 0\n    elsif i.is_a?(String)\n      sum += 0\n\
    \    else\n      sum += 0 # Don't want to be bothered by strings or arrays of\
    \ strings\n    end\n  end\n  return sum\nend", "  # your code\n  \n  return 0",
  "  if lst.empty?\n    0\n  else\n    sum = 0\n    lst.each do |number|\n      if\
    \ number % 2 == 1\n        sum += number ** 2\n      end\n    end\n    sum\n \
    \ end\nend\n</code>\n<|/ a |>\n<| a |>\nHere is a ruby way to do it without the\
    \ need for recursion :)\n<code>", "  lst.map{|x| x * x if x.is_a?(Integer) }.inject(:+)\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby |>\nFor those who know some more\
    \ Ruby, here are some benchmarks.  I used Jonathan R's answer as inspiration but\
    \ with a few tweaks to get it close to Jonathan's solution.  I also used his \"\
    map inject\" answer to get the last step.  I took his example and added my \"\
    map\" lines to it.\nBenchmarks are for 10,000 iterations.  If anyone has any suggestions\
    \ for how to further optimize these, I'm happy to hear them.\n<code>\nrequire\
    \ \"benchmark\"", "  lst.map!(&:to_i).each do |x|\n    if x % 2 == 1\n      x\
    \ = x * 2\n    end\n  end\n  lst.sum\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,arrays,subtraction\
    \ dscore=0 |>\nI see a lot of good answers here but since you asked for another\
    \ way to do it, here's my solution:\n<code>", "  lst.select {|x| x != nil }.inject(0)\
    \ {|sum, x| sum + x**2 }\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis does\
    \ not answer the question. The question is about doing it _without using select_\
    \ and _without_ using `inject`.\n<|/ c |>\n<| c |>\nFair enough. Updated my answer.\n\
    <|/ c |>\n<| c |>\nThe question asks how to do it without using select_ and inject\
    \ and to do this in a single line of Ruby. Your answer involves using inject and\
    \ select_. Your answer is wrong.\n<|/ c |>\n<| c |>\nThis still does not answer\
    \ the question. It's also incorrect because it still uses the incorrect version\
    \ of inject.\n<|/ c |>\n<| c |>\nMy answer doesn't use inject. I've already pointed\
    \ out that the accepted answer uses inject. That's why I didn't post the answer.\
    \ My answer uses inject. It uses reduce. I don't see why it wouldn't answer OP's\
    \ question.\n<|/ c |>\n<| a tags=ruby |>\nHere's a way to do it using reduce:\n\
    <code>", "  return 0 if lst.empty? else lst.sum.call * (lst.sum.call - lst.call.call)\n\
    end", "  if lst.empty?\n    0\n  else\n    lst.pop.inject(0) do |sum, n|\n   \
    \   sum + (n % 2 != 0) ? n * n : 0\n    end\n  end\nend\n</pre>", "  lst.map!{|x|\
    \ x == 0 ? 0 : x}\n  sum = lst.inject(0) {|sum, e| sum + (e % 2 != 0 ? e : 0)}\n\
    end\n</pre>", "  lst.map!{ |x| x * 2 }\n  lst.uniq!\n  lst.inject { |sum, i| sum\
    \ + i } if lst.any?\nend", "  sum = 0\n  arr.each do |x|\n    if x.is_a?(Integer)\
    \ || x.negative?\n      sum += x.abs\n    else\n      sum += x\n    end\n  end\n\
    \  sum if arr.length != 0\nend", "  sum = 0 \n  lst.each do |e|\n    if e % 2\
    \ == 1 \n      sum << e * e\n    end\n  end\n  return sum\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nThanks for the answer. While this looks like an interesting solution,\
    \ I'm curious, how would you make this work with an arbitrary list of numbers?\
    \ For example, if I had a list: `[5, 2, 6, -7, -9, 3]`\n<|/ c |>\n<| c |>\nI updated\
    \ the solution to work with a list instead of an array\n<|/ c |>\n<| a |>\nI used\
    \ the code from, but I changed it to not just return the sum, but also the array\
    \ of numbers that were odd. Also, I had to change 'map' to 'each' for it to work.\
    \ \nThe code:\n<code>", "  lst.inject(0) {|sum, el| sum + el**2 if el.odd? }\n\
    end", "  sum = 0\n  lst = lst || []\n  lst.each do |item|\n    next if item <\
    \ 0 || item.to_i.zero?\n    sum += item\n  end\n  sum * sum\nend", "  sum = 0\n\
    \  (0..(lst.length-1)).each do |i|\n    if lst[i] > 0 && lst[i] % 2 == 1\n   \
    \   sum += lst[i] * lst[i]\n    end\n  end\n  return sum if lst.length != 0\n\
    \  return 0\nend", "  return 0 if lst.empty? else (lst.sum { |x| x%2 == 1 } **\
    \ 2) / (2 * lst.size)\nend\n</cell>\n<text>\nNow that we have defined our function\
    \ double_the_difference, we can use it in our program:", "  total = lst.reduce(:+)\n\
    \  summed_odd_numbers = lst.select { |x| x % 2 != 0 }.reduce(:+)\n  total -= summed_odd_numbers\n\
    \  summed_odd_numbers.zero? ? 0 : (total * total)\nend", "  lst.empty? ? 0 : (lst.map\
    \ { |x| x % 2 == 0 ? x * x : x }.inject(:+))\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nI agree with both answers, this is the best and most readable solution.\
    \ But the first one should be the accepted answer.\n<|/ c |>\n<| a |>\nThe solutions\
    \ above are all very interesting, though they all rely on inject. \nIt should\
    \ be noted that this is no more efficient than the simple way: \n<code>", "  #\
    \ Only change code below this line\n  lst.inject(0) {|s, e| s += e * e}\nend",
  "  lst.each do |x|\n    if x.is_a? Integer\n      double_the_difference ([x])\n\
    \    elsif x.is_a? String\n      double_the_difference ([x.to_i])\n    else\n\
    \      double_the_difference ([x])\n    end\n  end\n  lst.inject {|sum, item|\
    \ sum + item }\nend", "  return lst.inject(0) { |s, x| s + x * x }\nend\n</pre>",
  "  lst.map!(&:to_i) if lst.respond_to?(:map)\n  lst.empty? ? 0 : lst.inject(0) {|sum,v|\
    \ sum + 2*v }\nend", "  sum = 0\n  l = lst.empty?? 0 : lst.size\n  for i in 1..l\n\
    \    sum += i**2 if lst[i]%2 == 1 \n  end\n  sum\nend\n</cell>\n<cell>", "  (0...lst.length).inject(0)\
    \ do |sum, num|\n    sum + num if lst.is_a?(Integer) ? num % 2 == 0 : num == -1\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,sum |>\n<| c |>\nNice solution. `inject`\
    \ is what makes you happy :)\n<|/ c |>\n<| c |>\nOh wow this is really great.\
    \ Thank you so much!\n<|/ c |>\n<| a tags=ruby,sum |>\nI prefer this solution\
    \ to avoid the loop:\n<code>", "  res = 0.to_f\n  for i in lst\n    if i.is_a?\
    \ Fixnum\n      res += i\n    elsif i.is_a? Float\n      res += i * i\n    elsif\
    \ i.is_a? String\n      begin\n        i.to_f\n      rescue NoMethodError\n  \
    \      # do nothing\n      end\n    else\n      rescue TypeError\n        # do\
    \ nothing\n      end\n    end\n  rescue ArgumentError\n    # do nothing\n  rescue\
    \ Exception\n    # do nothing\n  end\n  rescue IndexError\n    # do nothing\n\
    \  end\n  rescue NameError\n    # do nothing\n  end\n  rescue TypeError\n    #\
    \ do nothing\n  end\n  rescue Exception\n    # do nothing\n  end\n  rescue SystemStackError\n\
    \    # do nothing\n  end\n  rescue NameError\n    # do nothing\n  end\n  rescue\
    \ Exception\n    # do nothing\n  end\n  rescue StopIteration\n    # do nothing\n\
    \  end\n  rescue NotImplementedError\n    # do nothing\n  end\n  rescue Timeout::Error\n\
    \    # do nothing\n  end\n  rescue NameError\n    # do nothing\n  end\n  rescue\
    \ Exception\n    # do nothing\n  end\n  rescue SystemExit\n    # do nothing\n\
    \  end\n  rescue SystemExit\n    # do nothing\n  end\n  rescue Exception\n   \
    \ # do nothing\n  end\n  rescue SystemStackError\n    # do nothing\n  end\n  rescue\
    \ Exception\n    # do nothing\n  end\n  rescue Exception\n    # do nothing\n \
    \ end\n  rescue Exception\n    # do nothing\n  end\n  rescue Exception\n    #\
    \ do nothing\n  end\n  rescue Exception\n    # do nothing\n  end\n  rescue Exception\n\
    \    # do nothing\n  end\n  rescue Exception\n    # do nothing\n  end\n  rescue\
    \ Exception\n    # do nothing\n  end\n  rescue Exception\n    # do nothing\n \
    \ end\n  rescue Exception\n    # do nothing\n  end\n  rescue Exception\n    #\
    \ do nothing\n  end\n  rescue Exception\n    # do nothing\n  end\n  rescue Exception\n\
    \    # do nothing\n  end\n  rescue Exception\n    # do nothing\n  end\n  rescue\
    \ Exception\n    # do nothing\n  end\n  rescue Exception\n    # do nothing\n \
    \ end\n  rescue Exception\n", "  lst.map!{|n| n.to_i if n.to_i.odd? }\n  sum =\
    \ 0\n  lst.each {|n| sum += n ** 2}\n  sum\nend\n</cell>\n<text>\nA more general\
    \ version of double_the_difference:", "  arr = []\n  sum = 0", "  if lst.empty?\n\
    \    0 # return 0 when empty list\n  else\n    sum = 0\n    lst.each {|i| sum\
    \ += i * i if i.odd? }\n    sum\n  end\nend\n</code>\n<|/ a tags=ruby,arrays,functional-programming\
    \ |>\n<| c |>\nThanks for your answer. I didn't see your answer before. Your solution\
    \ is simple and clean. One problem I see is `sum += i * i` looks weird because\
    \ we are using += in the first place. Why are we adding 2 things in the first\
    \ place?\n<|/ c |>\n<| c |>\n: This is not the *only* correct solution to this\
    \ problem, but it was a pretty direct solution for the problem as stated.\n<|/\
    \ c |>\n<| c |>\nTo expand on that, the `+=` operator is the same thing as `sum\
    \ = sum + i`, but in cases where you want to add an integer to a variable before\
    \ adding it to the variable again, you can write it like that.\n<|/ c |>\n<| c\
    \ |>\nOne more question please: `sum = 0` is a better solution than `sum.to_i`\
    \ ?\n<|/ c |>\n<| c |>\n: Both work, but I prefer `sum.to_i` to `sum = 0`, because\
    \ it is more self-documenting.\n<|/ c |>\n<| a tags=ruby,arrays,functional-programming\
    \ |>\nHow about this:\n<code>\nmy_array.map {|x| x%2==0 ? (x + x) : x} \n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nWow, you were the first to post this :) And it does\
    \ work. But now I understand what I was doing wrong. Thanks for your help :)\n\
    <|/ c |>\n<| c |>\n`x % 2 == 0 ? x + x : x` also works, but is more verbose than\
    \ the ternary operator. And while it's more verbose, it's a lot less ambiguous.\n\
    <|/ c |>\n<| c |>\n`x % 2 == 0` is a common idiom in Ruby. It's equivalent to\
    \ `x.is_a? Fixnum && x.odd?`\n<|/ c |>\n<| c |>\n`x % 2 == 0` could be written\
    \ `x.odd?`.\n<|/ c |>\n<| c |>\nThis solution would also return `nil` if `my_array`\
    \ contains non-integers.\n<|/ c |>\n<| a dscore=2 |>\nI assume you mean the following\n\
    <code>\narr = [1,2,3]\narr.select {|n| n.odd", "  return 0 unless lst\n  sum =\
    \ 0\n  lst.each do |x|\n    sum += x*x if x % 2 == 1\n  end\n  return sum\nend\n\
    </cell>\n<text>\nThe key here is to use list comprehensions instead of loops.",
  "  lst.each do |i|\n    next unless i.is_a? Integer\n    next if i.negative?\n \
    \   i << i\n  end\n  lst.each_with_object(0).inject(0) do |sum, el|\n    if el\
    \ == el\n      el\n    else\n      el * el\n    end\n  end\nend\n</code>\n<|/\
    \ a tags=ruby,arrays |>\n<| a dscore=2 |>\n<code>", "  lst.map!{ |x| x > 0 ? x\
    \ * 2 : (x % 2 == 0) ? x : x }\n  sum = 0\n  lst.each { |x| sum += x }\n  sum\n\
    end", "  sum = 0\n  \n  for x in lst\n    if x.is_a? Integer\n      if x.odd?\n\
    \        sum += x\n      end\n    else\n      if x.nil?\n        sum = 0\n   \
    \   end\n    end\n  end", "  return lst.inject(0) {|sum,el| sum + 2*el if el.odd?\
    \ }\nend", "  return lst.length.odd? lst.inject(0) {|sum, el| sum + el*el }\n\
    end\n</pre>", "  sum = 0\n  \n  if lst.empty?\n    sum = 0\n  else\n    lst.each\
    \ do |num|\n      if num > 0\n        sum += num * num\n      elsif num < 0\n\
    \        sum += num\n      else\n        sum -= 1\n      end\n    end\n  end\n\
    \  \n  return sum\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThanks. Your solution\
    \ is very concise and easy to understand. I'm glad that Ruby has a `-` method\
    \ for integers. I didn't know about that until now. Also, thanks for pointing\
    \ out the `map` method and for pointing out the difference between `each` and\
    \ `map`. I knew that I was missing something.\n<|/ c |>\n<| a dscore=1 |>\nIn\
    \ a comment on another answer you asked:", "  if lst.size == 0\n    0\n  else\n\
    \    sum = 0\n    different = false\n    sum = 0\n    different = true\n    \n\
    \    for i in lst\n      if different = true\n        sum += i**2\n        different\
    \ = false\n      end\n    end\n    sum\n  end\nend", "  return 0 unless lst.length\n\
    \  doubled_num = lst[0]\n  doubled_num = doubled_num * 2 if doubled_num.is_a?(Integer)\n\
    \  doubled_num = doubled_num if doubled_num.is_a?(Numeric)\n  doubled_num.tap{|n|\
    \ n.map!{|x| x * 2}}.inject(0){|sum,x| sum + x if x % 2 == 1} | 0\nend\n</code>\n\
    <|/ a |>\n<| a |>\n<code>", "  return lst.inject(0) { |sum, el| sum + el * el\
    \ } if lst.length == 0\n  lst.uniq.map { |el| el * el }.inject { |sum, el| sum\
    \ + el }\nend\n</cell>\n<text>\nIf you don't already know about inject, check\
    \ out the documentation at  and read about what inject does.", "  lst.each do\
    \ |n|\n    if n % 2 == 1 then return 0 end\n  end\n  return lst.inject(0) { |sum,\
    \ item| sum + item }\nend", "  sum = 0\n  lst.each_with_index do |x, i|\n    if\
    \ x.is_a? Integer\n      sum += x\n    elsif x.is_a? Float\n      sum += x * x\n\
    \    else\n      next\n    end\n    sum += x\n  end\n  sum\nend", "  arr.inject([0,\
    \ 0], &:+).delete_if { |n| n < 0 || !n.is_a?(Fixnum) } * arr.size\nend", "  return\
    \ 0 if lst.empty? else lst.inject(0) {|s,i| s + i * i }\nend", "  if lst.empty?\
    \ then\n    return 0\n  else\n    lst.map!{|x| x * 2}\n    lst.delete_if(&:negative?)\n\
    \    suml = 0\n    suml2 = 1\n    lst.each do |x|\n      if x % 2 == 1 then\n\
    \        suml += x\n      else\n        suml2 += x\n      end\n    end\n    suml\n\
    \  end\nend\n</cell>\n<cell>", "  return 0 unless lst.length\n  total = lst.inject(0){\
    \ |sum, item| sum += item if item % 2 == 1 && sum > 0 }\n  total < 0 ? 0 : total\n\
    end", "  return 0 if lst.empty? then 0 else lst.sum do |n| \n    double_the_difference.call([n])\
    \ \n  end\nend\n</code>\nIf performance is a concern, then you can use the following\
    \ (assuming none of the arrays are empty):\n<code>", "  return 0 if lst.length\
    \ == 0\n  sum = 0\n  for i in lst\n    sum += i unless i.kind_of?(Integer) &&\
    \ i.zero?\n    sum += i**2\n  sum\nend", "  sum = 0\n  count = 0\n  for i in lst\n\
    \    if i < 0\n      next\n    elsif i.kind_of? Integer\n      next\n    else\n\
    \      sum += i\n      count += 1\n    end\n    sum += i**2\n  end\n  sum *= count\n\
    \  sum if count > 0\nend\n</code>\n<|/ a tags=ruby dscore=1 |>\n<| c |>\nThis\
    \ code doesn't produce the correct result for an empty array.  Also, please fix\
    \ the indentation errors.  I suggest you use a code sample or IDE that will highlight\
    \ your code for you.\n<|/ c |>\n<| a |>\nA good way to solve this is to create\
    \ a sum function, and iterate through your array and call this sum function for\
    \ each element in the array.  You would need to check if the current element is\
    \ even or odd to determine if it is even or odd before adding it to the sum. \
    \ \n<code>", "    difference = 0\n    sum = lst[0]\n    sum = 0 if sum < 0 else\
    \ sum", "  lst.empty? ? 0 : lst.inject(0) { |result, item| result + ((item % 2)\
    \ == 1 ? 2 * item : 0) }\nend\n</pre>\n<p>As you see, the method is the same with\
    \ normal one, but with a block passed as the last argument (<tt>inject</tt>).</p>\n\
    <p>The block passed as argument to <tt>inject</tt> is called for each element\
    \ in the list. It returns the result of the expression to be injected into the\
    \ accumulator.</p>\n<p>The first time the block is invoked, the accumulator is\
    \ set to the value of the block. Then for each subsequent call to the block, <tt>inject</tt>\
    \ will invoke the block with the previous value and the current item. The previous\
    \ value is a result of the last invocation of the block, in our case the result\
    \ of the last expression to be evaluated. So, we can simply evaluate the block\
    \ expression and return the result of the expression.</p>\n<p>Now you should be\
    \ able to apply this idea and implement <tt>double_the_difference</tt> method</p>\n\
    <h1 id=\"find-the-element-at-which-the-sum-of-elements-greater-or-equal-to\">Find\
    \ the element at which the sum of the elements is greater than or equal to <em>n</em></h1>\n\
    <p>You are given an array of integers. You need to find the index where sum of\
    \ all the elements are greater than or equal to <em>n</em>.</p>\n<p>In ruby, you\
    \ can easily solve this problem by using the <tt>inject</tt> method and returning\
    \ the index of the element when <tt>inject</tt> is done with all the elements\
    \ in the array.</p>\n<p>For example, let's consider this array [5, 8, -2, -4]:</p>\n\
    <pre>\narr.inject(0) do |sum, element| \n  sum += element \n  sum if sum >= n\n\
    end\n</pre>\n<p>The method works in the following way:</p>\n<ul>\n<li>The first\
    \ time the block is invoked, the accumulator is set to the value of the block.\
    \ Then for each subsequent call to the block, <tt>inject</tt> will invoke the\
    \ block with the previous value and the current item. The previous value is a\
    \ result of the last invocation of the block, in our case the result of the last\
    \ expression to be evaluated. So, we can simply evaluate the block expression\
    \ and return the result of the expression.</li>\n</ul>\n<p>And that's the basic\
    \ idea of <tt>inject</tt>. Let's have a look at the implementation:</p>\n<pre>",
  "  result = 0.to_f\n  lst.each do |x|\n    if x.is_a? Integer\n      result += (x.to_f\
    \ * x.to_f)\n    else\n      result -= x.to_f\n    end\n  end\n  result\nend\n\
    </code>\n<|/ a dscore=1 tags=ruby,recursion |>\n<| a tags=ruby,recursion dscore=1\
    \ |>\nHere is a purely functional answer, with a short and sweet description:\n\
    <code>", "  lst.each_with_index { |v, i| return 0 if v < 0 or v.to_i < 0 || i\
    \ < 0 } \n  lst.inject(0, :+).to_f / (lst.size ** (1/2)) \nend", "  lst.flatten!\n\
    \  return lst.inject(0) {|sum, e| sum + e * e if e % 2 == 1 }\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a |>\nA Ruby solution\n<code>\narray = [1, 2, 3, 4]\narray.map.with_index\
    \ { |val, index| index % 2 != 0 ? val + val : 0 }", "  lst.collect{|i| i if i.kind_of?(Integer)}.inject(0)\
    \ do |sum, e|\n    sum + e * e\n  end\nend", "  lst.map!{|x| x.to_i}\n  lst.compact!\n\
    \  lst.inject(0, :+) << 0\n  lst.map { |x| x * x }.reduce(:+) << 0\nend", "  sum\
    \ = 0\n  unless lst.empty?\n    arr.each do |num|\n      sum = sum + num if num\
    \ % 2 == 1\n    end\n  end\n  sum\nend\n</pre>\n</div>\n</div>\n</div>\n<div class=\"\
    cell border-box-sizing text_cell rendered\"><div class=\"prompt input_prompt\"\
    >\n</div>\n<div class=\"inner_cell\">\n<div class=\"text_cell_render border-box-sizing\
    \ rendered_html\">\n<h2 id=\"Solution-4\">Solution 4<a class=\"anchor-link\" href=\"\
    #Solution-4\">&#182;</a></h2>\n</div>\n</div>\n</div>\n<div class=\"cell border-box-sizing\
    \ text_cell rendered\"><div class=\"prompt input_prompt\">\n</div>\n<div class=\"\
    inner_cell\">\n<div class=\"text_cell_render border-box-sizing rendered_html\"\
    >\n<p>The fourth task is to convert a list of numbers to a list of strings (in\
    \ order) so that each string represents one number. For example, <code>['9', '6',\
    \ '8', '3', '5', '4', '7', '10', '11', '10', '10', '8']</code> should become</p>\n\
    <p><code>['nine', 'six', 'eight', 'three', 'five', 'four', 'seven', 'ten', 'eleven',\
    \ 'ten', 'ten', 'eight']</code></p>\n<p>This should take a single line of code\
    \ with no loops. Remember to use <code>map</code> to convert the array to an array\
    \ of strings.</p>\n<p>Hint 1: Use <code>map</code> to convert the array of integers\
    \ to a string.</p>\n<p>Hint 2: Use <code>map</code> to convert the array of strings\
    \ to an array of integers.</p>\n<p>Hint 3: Use <code>join</code> to convert the\
    \ array of strings into one string.</p>\n<p>Hint 4: Use <code>split</code> to\
    \ convert the array of strings into an array of integers.</p>", "    sum = 0\n\
    \    arr.each { |x| sum += (x % 2 == 0) ? x * x : x }\n    return sum\nend\n</code>\n\
    The each_with_object method lets you return multiple values from the block, so\
    \ you don't need to return sum and you also don't need to use return.  See here\
    \ for details: http://ruby-doc.org/core-1.9.3/Enumerable.html#method-i-each_with_object\n\
    <|/ a |>\n<| c |>\nI see what you mean, but I did include my original code anyway,\
    \ so I'm not sure how to fix it.  Can you explain to me why I should be using\
    \ each_with_object instead of each?  I looked it up but didn't see anything that\
    \ helped me understand how to use it.\n<|/ c |>\n<| c |>\nI added a link to a\
    \ link to the documentation.  Basically it's like map but instead of returning\
    \ one value from each block, returns an array of all values from the block.  In\
    \ your case, instead of returning a value, you return the sum.  See here: http://ruby-doc.org/core-1.9.3/Enumerable.html#method-i-each_with_object\n\
    <|/ c |>\n<| c |>\nOh wow, that's a lot easier than I was trying to figure out\
    \ lol.  Thanks a lot for the help, much appreciated!\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>", "  sum = 0\n  unless lst.empty?\n    sum += lst.map(&:to_i).reduce(:+)\n\
    \    sum <<= 1\n    sum += lst.map(&:to_i).reduce(:+)\n    sum.times do |x|\n\
    \      sum += x * x\n    end\n  end\n  sum\nend", "    sum = 0\n    arr.each do\
    \ |num|\n      sum = sum + num\n      if num % 2 == 1\n        sum *= 2\n    \
    \  end\n    end\n    return sum if arr && arr.length\n    0\n  end\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis does not provide an answer to the question. To\
    \ critique or request clarification from an author, leave a comment below their\
    \ post. - [From Review](/review/low-quality-posts/11140750)\n<|/ c |>\n<| c |>\n\
    Sorry, I didn't realize this was a critique, since it was clearly a coding challenge\
    \ from his book. I did realize that this answer was written prior to the original\
    \ author's update to the book, which was why the code had been changed. As for\
    \ an explanation, I added the comments regarding the book information because\
    \ I assumed it would be helpful to other users who viewed this thread.\n<|/ c\
    \ |>\n<| a dscore=0 |>\nI have made some changes in your code which now will work.\n\
    <code>", "  sum = 0\n  for i in lst\n    if i < 0\n      sum += -1 * i\n     \
    \ next\n    sum += i * i\n    next\n  end\n  sum\nend", "  return 0 unless lst\n\
    \  sum, last_odd = 0, lst[0]\n  lst.each do |n|\n    sum += n\n    last_odd +=\
    \ 1 if n % 2 != 0\n  end\n  return sum if last_odd % 2 == 1\n  sum\nend", "  lst.inject(0)\
    \ { |sum, val| sum + 2*val if val % 2 == 1 }\nend", "  lst.each_with_index do\
    \ |item, index|\n    item += item if index % 2 != 0\n  end\n  lst.inject(0) {\
    \ |result, item| result + ((item % 2 == 0) ? item : 0)}\nend\n</code>\n<|/ a |>\n\
    <| a dscore=0 tags=ruby |>\n<code>", "  sum = 0\n  arr.each do |x|\n    sum +=\
    \ (x**2) unless x.zero? || x.negative?\n  end\n  return sum\nend\n</code>\n<|/\
    \ a tags=ruby,ruby-on-rails,arrays,math dscore=2 |>\n<| c |>\nI like this answer.\
    \ However I am confused on how I could use this to multiply and divide an array\
    \ like [3,5] by another array like [3,5].\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,arrays,math\
    \ dscore=2 |>\n<code>", "  lst.collect! { |n| n if !n.to_i.zero? && n != n }\n\
    \  lst.count { |n| n > 0 }.zero? ? 0 : lst.inject(0) { |sum, n| sum + n * n }\n\
    end\n</code>\n<|/ a dscore=0 tags=ruby,arrays |>\n<| c |>\nAm I correct in assuming\
    \ that you mean `collect!` instead of `collect`? It seems like you changed your\
    \ answer after my comment, and I changed my answer to be more accurate.\n<|/ c\
    \ |>\n<| c |>\nYes, I did meant `collect!` instead of `collect`. Thanks for pointing\
    \ that out!\n<|/ c |>\n<| a tags=ruby,arrays |>\nIf you have access to ActiveSupport\
    \ (which you should have) you can do this:\n<code>\narr = [4,7,5,2,1,8,3,6,0]\n\
    arr.select {|e| e % 2 != 0}.reduce(:+)\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    That doesn't require Rails -- it's one of the core, built-in methods on Ruby arrays.\n\
    <|/ c |>\n<| c |>\nYeah, but it's in the standard library and ActiveSupport is\
    \ built on it :)\n<|/ c |>\n<| c |>\nAh, yeah. I'm just used to adding it to my\
    \ Gemfile. :)\n<|/ c |>\n<| a tags=ruby,arrays |>\nA solution using Enumerable#each_with_index\
    \ and Enumerable#min\n<code>", "  lst.map! do |x|\n    x = x.to_i\n    if x %\
    \ 2 == 0 && x > 0 && !x.is_a? Integer\n      x * 2\n    else\n      x\n    end\n\
    \  end\n  return lst.inject(:+)\nend\n</code>\n<|/ a tags=ruby dscore=0 |>\n<|\
    \ c |>\nThis is an awesome solution. I like the readability and clarity of your\
    \ code. Thank you for sharing. By the way, I think there should be a `return`\
    \ before `double_the_difference.call([0])`, to return 0 and not an array.\n<|/\
    \ c |>\n<| a tags=ruby |>\nTo me it looks like you're doing too much inside the\
    \ loop. In general I'd suggest doing things like this in steps. So first you want\
    \ to get the array and find the difference between its min and max.\n<code>\n\
    arr = [1,2,3]\narr.min\n=> 1\narr.max\n=> 3\n</code>\nNext you want to see if\
    \ the difference is evenly divisible, if so you want to double it. If it's not\
    \ you want to add it to the sum.\n<code>\narr.min..arr.max.reduce(:+)\n=> 6\n\
    arr.min..arr.max.reduce(:+) * 2 # => 12\n</code>\nAnd finally you want to subtract\
    \ all but one number from your sum.\n<code>\narr.min..arr.max.reduce(:+) - arr.min\
    \ # => 6\n</code>\nOr you can shorten this by doing\n<code>\narr = [1,2,3]\narr.reduce(:+)\n\
    => 6\narr.reduce(:+) - arr.min\n=> 6\n</code>\n<|/ a dscore=0 |>\n<| c |>\nWhy\
    \ would you do `arr.min..arr.max.reduce(:+)` when you can just do `arr.reduce(:+)`?\n\
    <|/ c |>\n<| c |>\nI thought it would make it more clear how it works. I guess\
    \ I wasn't thinking about it enough\n<|/ c |>\n<| a dscore=0 |>\nHere's another\
    \ way, using inject. \n<code>", "  sum = 0\n  lst.each do |x|\n    sum += x *\
    \ x\n  end\n  return sum if lst.length.zero?\n  return 0 if sum < 0\n  return\
    \ sum * sum\nend", "  arr = lst.sort.map { |x| x % 2 != 0 ? x * 2 : x }\n  arr.empty?\
    \ ? 0 : arr.inject { |x, y| x + y }\nend\n</code>\nIt can be improved further,\
    \ but this should be enough to get you started.\n<|/ a dscore=1 |>\n<| c |>\n\
    It's not about being spoonfed, it's just that this seems like a solution that\
    \ might not be the best approach at all - like it or not, I've got to get this\
    \ done for my exam, and I don't really want to see this in my test results. Thanks\
    \ for the advice though! I'll keep that in mind for the future =]\n<|/ c |>\n\
    <| c |>\nYou're welcome. I edited my answer to give you a few pointers to improve\
    \ your understanding of what Ruby is doing behind the scenes (even though it might\
    \ not be the most efficient way).\n<|/ c |>\n<| c |>\nHi again! I'm very interested\
    \ in looking at your solutions, and I'm sorry for my ignorance, but I'm new to\
    \ Ruby, and I'm finding it incredibly difficult to read your code and understand\
    \ how it's working. I understand that you're splitting them into two separate\
    \ loops and using different variables for each one, but I don't understand how\
    \ you arrive at your `arr` variable, which is an array, from just seeing `arr\
    \ += x` and `arr += y` in the loop conditions.\n<|/ c |>\n<| c |>\nThat's just\
    \ regular assignment (also called assigment), `arr += x` and `arr += y` are equivalent\
    \ to `arr = arr + x` and `arr = arr + y`. I hope that makes it clearer to you\
    \ now.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,arrays |>\n<code>", "  return 0\
    \ if (lst.empty?)\n  sum = 0\n  lst.each do |x|\n    if (x % 2 != 0)\n      sum\
    \ = (x * x) + sum\n    end\n  end\n  sum\nend", "  arr = lst.sort.uniq \n  return\
    \ arr.inject(:+) if (arr.length > 0)\n  0\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
