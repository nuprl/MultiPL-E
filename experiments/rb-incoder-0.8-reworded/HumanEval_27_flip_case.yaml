name: HumanEval_27_flip_case
language: rb
prompt: "# For a given string, flip lowercase characters to uppercase and uppercase\
  \ to lowercase.\n# >>> flip_case.call(\"Hello\")\n# \"hELLO\"\ndef flip_case(string)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_flip_case\n\
  \    candidate = method(:flip_case)\n    assert_equal(\"\", candidate.call(\"\"\
  ))\n    assert_equal(\"hELLO!\", candidate.call(\"Hello!\"))\n    assert_equal(\"\
  tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\", candidate.call(\"These violent delights\
  \ have violent ends\"))\n  end\nend\n"
completions: ["  string.downcase!\n  string.upcase!\n  string\nend", "  string.reverse\n\
    \  string\nend", "  string.downcase!\n  string.upcase!\n  string\nend", "  string\
    \ = string.dup\n  string.gsub! /[A-Z]/, /[a-z]/\n  string.gsub! /[a-z]/, /[A-Z]/\n\
    \  string\nend", "  return string.upcase\nend\n</code>\nAnd then we add these\
    \ two methods to our string class:\n<code>", "  string.downcase! if string.length\
    \ > 0\n  string\nend\n</code>\nSo the above method flips the case of the first\
    \ character only, and since Ruby strings are immutable this operation always returns\
    \ the same string. I also added the ! to the downcase! method which means \"downcase\"\
    \ now returns the new string.\n<code>", "  string.downcase!\n  string.upcase!\n\
    \  string\nend", "  string.downcase!\n  string.upcase!\nend", "  string.downcase!\n\
    \  string.upcase!\n  string\nend", "  string.downcase!\nend\n</cell>\n<text>\n\
    Ruby Style Guide\nCode is read from top to bottom, and is interpreted from left\
    \ to right. For example:", "  return string.gsub(/[a-z]/) {|s| s[0...2].upcase\
    \ + s[2..-1].downcase}\nend", "  string.downcase!\n  string.upcase!\n  string\n\
    end", "  string.upcase! && string.downcase!\n  string\nend", "  string[0].upcase\
    \ + string[1..-1].downcase\nend", "  string.downcase!\n  string.upcase!\n  string\n\
    end", "  string.downcase!\n  string.upcase!\n  string\nend", "  string.downcase!\n\
    \  string.upcase!\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=0 tags=ruby |>\n\
    String#capitalize will capitalize the first letter in any string.\n<code>\n\"\
    hELLO\".capitalize", "  case string\n  when /[a-z]/\n    string.gsub!(/[a-z]/)\
    \ { |char| char.ord > 96 ? char.ord - 32 : char.ord }\n  when /[A-Z]/\n    string.gsub!(/[A-Z]/)\
    \ { |char| char.ord < 65 ? char.ord + 32 : char.ord }\n  end\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nThanks for your answer. I am still trying to get it\
    \ working but your explanation really helped.\n<|/ c |>\n<| a dscore=1 tags=string,ruby\
    \ |>\n<code>", "  string.downcase!\n  string.upcase!\n  string\nend", "  string.upcase!\n\
    \  string.downcase!\n  string\nend\n</code>\nString#gsub and String#gsub! behave\
    \ like Ruby\u2019s tr, except they are global and affect all matches in the string,\
    \ and not just the first one.\n<code>", "  string.downcase!\n  string.upcase!\n\
    \  string\nend", "  string.downcase!\n  string.upcase!\n  string\nend\n</code>\n\
    <|/ a |>\n<| a |>\nHere's a very simple and straightforward way of doing it:\n\
    <code>", "  # Split string into an array of words and reverse the order of the\
    \ words.\n  words = string.split\n  words.reverse!", "  string.downcase!\nend",
  "  string.tr(\"A-Z\", \"b-ZA-Mn-z\")\nend", "    string.downcase!\n    string.upcase!\n\
    \    string\nend", "  string.gsub(/[a-z]/) do |word|\n    word.upcase + word.downcase\n\
    \  end\nend", "  string.downcase!\n  string.upcase!\n  string\nend", "  string.gsub(/./)\
    \ { |c| c.upcase != c.downcase ? c.downcase + c.upcase : c }\nend\n</code>\n<|/\
    \ a tags=ruby-on-rails,ruby,string dscore=5 |>\n<| c |>\nNice and compact (+1),\
    \ but I'd personally go with `gsub(/./, &:upcase)`.\n<|/ c |>\n<| a tags=ruby-on-rails,ruby,string\
    \ |>\nIn Ruby 1.8, String#tr is a very simple and fast solution:\n<code>\n'a'.tr('aeiou',\
    \ 'AEIOU')  #=> \"AEIOU\"\n</code>\n<|/ a dscore=4 |>\n<| c |>\n\"String#tr is\
    \ a very simple and fast solution\" -- I doubt that.\n<|/ c |>\n<| c |>\nAgreed.\
    \ I was thinking `'a'.tr('aeiou'.each_byte) {|c| c.upcase }`\n<|/ c |>\n<| c |>\n\
    : I think `'a'.tr('aeiou'.each_byte) {|c| c.upcase }` could be simplified to:\
    \ `'aeiou'.split('').map {|s| s.upcase }.join`.\n<|/ c |>\n<| c |>\nI used this\
    \ to convert a text field into a slug field for my Rails 4 app (on Heroku) https://github.com/davidcelias/string-utils\n\
    <|/ c |>\n<| c |>\n`'a'.tr('aeiou'.each_byte) {|c| c.upcase }` is not an efficient\
    \ solution in terms of memory, especially on large strings such as Gemini McDonald's\
    \ and Yelp.com.\n<|/ c |>\n<| a dscore=3 |>\nIf you already have an array of chars,\
    \ you can use the method String#gsub! to change each character in your string,\
    \ for example:\n<code>\narray = ['a', 'b', 'c', 'd', 'e']\narray.gsub!('a', 'z')\n\
    array.gsub!('e', 'y')\narray.gsub!('y', 'a')\n</code>\nYou can put this in a loop,\
    \ and it will replace each character in the array.\n<|/ a tags=ruby-on-rails,ruby,string\
    \ |>\n<| c |>\nThis only works if the character is unique in that array.  A more\
    \ robust answer will use gsub which will replace every occurrence of the character\
    \ in the array.\n<|/ c |>\n<| c |>\n`array.each{ |c", "  string.chars.map!{ |c|\
    \ c.upcase == c.downcase ? c.downcase : c.upcase }\n  string.downcase!\nend",
  "  return string.downcase\nend", "  string.gsub(/[a-z]/i) { |char| char.upcase }\n\
    \  string.gsub(/[A-Z]/i) { |char| char.downcase }\nend", "  string = string.downcase\n\
    \  string.upcase!\nend", "  string.gsub(/([a-z](?![A-Z]))/) { |c| c.upcase + c.downcase\
    \ }\nend\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| a dscore=0 |>\n<code>", " \
    \ string.downcase!\n  string.upcase!\n  string\nend\n</code>\nAnd now it's as\
    \ easy as calling the method as such:\n<code>", "  string.gsub(/\\w(?=\\w)/) {\
    \ |a| a.upcase }\nend\n</cell>\n<text>\nRecall that Ruby allows us to write methods\
    \ in terms of other methods using the dot notation. For example, let's look at\
    \ the case method.", "  return string.gsub(/([A-Z]+)[a-z]+/, '\\U\\1\\E').\n \
    \           gsub(/([a-z]+)[A-Z]+/, '\\U\\1\\E')\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nI'm curious. Why does `flip_case` not have `\\U` and `\\E` escapes\
    \ instead of `ucfirst` and `lcase` which do the same?\n<|/ c |>\n<| c |>\n: because\
    \ those are the escape sequences, not part of the regex. Ruby does have `Regexp.escape`,\
    \ but that's only for quoting regex metacharacters. It's not necessary here.\n\
    <|/ c |>\n<| c |>\n: And because those are both `String#gsub`, not `String#sub`.\
    \ Ruby does not have string interpolation, which would be necessary for string\
    \ escaping.\n<|/ c |>\n<| c |>\n: Okay, I see now. Thanks for the explanation.\n\
    <|/ c |>\n<| c |>\nI like this solution the best because it's simple, succinct,\
    \ clear, and doesn't require a library. Thanks for the great explanation!\n<|/\
    \ c |>\n<| a dscore=4 |>\nAnother solution (not using regular expressions) which\
    \ also handles non-ascii characters without converting them at all:\n<code>",
  "  string.to_s.gsub(/[a-z]/, { |s| s[0] <=> s[-1] }).\n    gsub(/[A-Z]/, { |s| s[0]\
    \ <=> s[1..-1] }).\n    tr(\" \", \"_\").\n    downcase\nend", "  string.gsub(/([a-z])/)\
    \ { $1.upcase }\nend\n</code>\nTo call this method, use flip_case(\"Hello\"),\
    \ for example.  \nI hope this helps!\n<|/ a |>\n<| a tags=ruby |>\n<code>", " \
    \ string.gsub(/[a-z]/) { |s| s.upcase }\n                .gsub(/[A-Z]/) { |s|\
    \ s.downcase }\nend", "  string.gsub(/./) { |s| s.upcase == s.downcase ? s.downcase\
    \ : s.upcase }\nend\n</pre>\n</div>", "  string.gsub(/./) {|c| c.upcase == c.downcase\
    \ ? c.downcase : c.upcase }\nend", "  string.downcase!\n  string.upcase!\n  string\n\
    end\n</code>\nNotice that you can chain downcase! and upcase!. By the way, if\
    \ you were dealing with an ActiveRecord model, it would be:\n<code>", "  string.gsub(/[a-z]/)\
    \ do |match|\n    match.upcase + match.downcase\n  end\nend", "  string.downcase.gsub!(/[a-z]/)\
    \ {|letter| letter == letter ? letter.upcase : letter}\n  string.upcase.gsub!(/[A-Z]/)\
    \ {|letter| letter == letter ? letter.downcase : letter}\n  return string\nend",
  "  string.to_s.downcase.tr('A-Z', 'a-z').tr('a-z', 'A-Z')\nend", "  string.gsub!(\
    \ /[a-z]/i ) { |match| match.downcase }\n  string.gsub!( /[A-Z]/i ) { |match|\
    \ match.upcase }\n  string\nend", "  return string.gsub(/./) do |char|\n    case\
    \ char\n    when 'a'\n      'A'\n    when 'A'\n      'a'\n    when 'B'\n     \
    \ 'b'\n    when 'b'\n      'B'\n    when 'C'\n      'c'\n    when 'c'\n      'C'\n\
    \    when 'D'\n      'd'\n    when 'd'\n      'D'\n    when 'E'\n      'e'\n \
    \   when 'e'\n      'E'\n    when 'F'\n      'f'\n    when 'f'\n      'F'\n  \
    \  when 'G'\n      'g'\n    when 'g'\n      'G'\n    when 'H'\n      'h'\n   \
    \ when 'h'\n      'H'\n    when 'I'\n      'i'\n    when 'i'\n      'I'\n    when\
    \ 'J'\n      'j'\n    when 'j'\n      'J'\n    when 'K'\n      'k'\n    when 'k'\n\
    \      'K'\n    when 'L'\n      'l'\n    when 'l'\n      'L'\n    when 'M'\n \
    \     'm'\n    when 'm'\n      'M'\n    when 'N'\n      'n'\n    when 'n'\n  \
    \    'N'\n    when 'O'\n      'o'\n    when 'o'\n      'O'\n    when 'P'\n   \
    \   'p'\n    when 'p'\n      'P'\n    when 'Q'\n      'q'\n    when 'q'\n    \
    \  'Q'\n    when 'R'\n      'r'\n    when 'r'\n      'R'\n    when 'S'\n     \
    \ 's'\n    when 'sS'\n      'S'\n    when 's'\n      's'\n    when 'T'\n     \
    \ 't'\n    when 't'\n      'T'\n    when 'U'\n      'u'\n    when 'u'\n      'U'\n\
    \    when 'V'\n      'v'\n    when 'v'\n      'V'\n    when 'W'\n      'w'\n \
    \   when 'w'\n      'W'\n    when 'X'\n      'x'\n    when 'x'\n      'X'\n  \
    \  when 'Y'\n      'y'\n    when 'y'\n      'Y'\n    when 'Z'\n      'z'\n   \
    \ when 'z'\n      'Z", "  string.gsub(/./) { |c| c.upcase <=> c.downcase }\nend",
  "  string.downcase! && string.upcase!\n  string\nend", "  string.gsub!(/[a-z](?![A-Z])/)\
    \ { |s| s.upcase }\n  string.gsub!(/[A-Z](?![a-z])/) { |s| s.downcase }\n  string\n\
    end\n</code>\n<|/ a tags=string,ruby |>\n<| a tags=string,ruby dscore=4 |>\nThis\
    \ can be done in a single gsub! call:\n<code>\n\"Hello\".gsub(/(?<=\\W)[A-Z]/,\
    \ '\\U\\1')\n</code>\nThis matches only uppercase characters that are preceded\
    \ by a non-word character, then replaces the match with the uppercase version\
    \ of that character (\\U\\1).\nThis also preserves uppercase characters that are\
    \ not immediately preceded with a non-word character (the lookbehind assertion).\n\
    <|/ a |>\n<| a tags=string,ruby dscore=3 |>\n<code>\n\"Hello\".gsub(/(?<=\\W)[A-Z]/,\
    \ '\\U\\1')\n</code>\n<|/ a |>\n<| c |>\nWhile this code may solve the question,\
    \ [including an explanation](//meta.stackexchange.com/q/114762) of how and why\
    \ this solves the problem would really help to improve the quality of your post,\
    \ and probably result in more up-votes. Remember that you are answering the question\
    \ for readers in the future, not just the person asking now. Please [edit] your\
    \ answer to add explanations and give an indication of what limitations and assumptions\
    \ apply.\n<|/ c |>\n<| a dscore=3 |>\n<code>\n\"Hello\".gsub(/(?<=\\w)[A-Z]/,'\\\
    U\\1')\n</code>\nExplain:\n<code>\n\"Hello\".gsub(/(?<=\\w)[A-Z]/,'\\U\\1')\n\
    => hELLO\n</code>\n<|/ a tags=string,ruby |>\n<| a tags=string,ruby dscore=2 |>\n\
    <code>\n\"Hello\".gsub(/([A-Z]{1})/, '\\U\\1')\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ doesn't seem to answer the question, which asks about uppercase letters surrounded\
    \ by non-word characters.\n<|/ c |>\n<| c |>\nThis still doesn't answer the question\
    \ - it just removes all the upper case characters. It should be `gsub!(/([A-Z]{1})/,\
    \ '\\U\\1')`, otherwise it wouldn't modify the string.\n<|/ c |>\n<| c |>\n`gsub!`\
    \ modifies the string in place and returns the modified string.\n<|/ c |>\n<| ",
  "  string.downcase! \n  string.upcase! \n  string\nend", "  return string.gsub(/[a-z]/)\
    \ do |char|\n    char = char.upcase unless char == char.downcase\n    char\n \
    \ end\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI like the solution, but I do\
    \ think that it should actually be `'A'.upcase + string + a.downcase`\n<|/ c |>\n\
    <| c |>\nActually I was trying to show that you can do anything you like in the\
    \ gsub block.  I remember trying to get downcase to work using it, but that didn't\
    \ work, so I gave up on it.\n<|/ c |>\n<| c |>\nI like this one. I'm going to\
    \ have to give it to you because I really like the gsub block solution.\n<|/ c\
    \ |>\n<| c |>\nI really like this solution too. I'm going to have to give it to\
    \ you because I really like the gsub block solution\n<|/ c |>\n<| a dscore=4 tags=ruby,string\
    \ |>\nTo complement answer: here is how you can implement this method in Rails\
    \ helpers so you can easily reuse it across your views:\n<code>", "  string.downcase!\n\
    \  string.upcase!\n  string\nend", "  string.gsub!(/[a-z]/i) do |match|\n    case\
    \ match\n    when 'a'\n      'A'\n    when 'e'\n      'E'\n    when 'i'\n    \
    \  'I'\n    when 'o'\n      'O'\n    when 'u'\n      'U'\n    else\n      match\n\
    \    end\n  end\n  string.gsub!(/[A-Z]/i) do |match|\n    case match\n    when\
    \ 'A'\n      'a'\n    when 'E'\n      'e'\n    when 'I'\n      'i'\n    when 'O'\n\
    \      'o'\n    when 'U'\n      'u'\n    else\n      match\n    end\n  end\n \
    \ string\nend\n</code>\n<|/ a tags=ruby-on-rails,ruby |>\n<| c |>\nThanks for\
    \ the quick response! I actually used the code from jagdeep's solution in my actual\
    \ code and it worked flawlessly!\n<|/ c |>\n<| a tags=ruby-on-rails,ruby |>\n\
    To avoid the case to lower case conversion:\n<code>", "  string.downcase!\n  string.upcase!\n\
    \  string\nend", "  string.gsub(/[a-z]/) { |m| m.upcase + m.downcase }\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThis only works with ASCII letters, but it\
    \ also works great with Unicode letters. Thanks!\n<|/ c |>\n<| c |>\nI wrote a\
    \ similar method to this that works on both ASCII letters and Unicode letters,\
    \ but it's less efficient than `downcase` and doesn't use `gsub`. Here it is:\
    \ http://pastebin.com/J4PqYZ9F\n<|/ c |>\n<| a dscore=2 |>\nI needed a case insensitive\
    \ version of downcase, and I dislike the solutions given so far (like using gsub).\
    \ Here is a function that will return a downcase version of a string without using\
    \ gsub or gsub!\n<code>", "  string.downcase!\n  string.upcase!\nend", "  string.chars.reverse_each.each.with_object(\"\
    \") do |character, out|\n    out << (case character.to_s.upcase)\n  end\nend\n\
    </code>\n<|/ a |>\n<| a dscore=2 |>\nHere's a more concise solution that uses\
    \ String#tr:\n<code>\ns = \"FooBar\"\ns.tr!('a', 'A')\ns.tr!('B', 'b')\ns.tr!('C',\
    \ 'c')\nputs s  # => FooBar\n</code>\nThis works because String#tr! reverses the\
    \ order of the characters in string, with the exception of the characters that\
    \ have been specified.\n<|/ a tags=ruby |>\n<| c |>\nThis reverses the order of\
    \ the characters, not the case of the characters. `\"foobar\".tr!(\"B\", \"A\"\
    ) == \"oofBa\"`, not `\"oofba\".tr!(\"B\", \"A\") == \"oofBa\"`.\n<|/ c |>\n<|\
    \ a tags=ruby |>\nAs far as I know, there's no built-in method in Ruby that does\
    \ this. You could write a method:\n<code>", "    string.gsub(/[a-z]/) do |letter|\n\
    \        letter == letter ? letter.toUpperCase() : letter\n    end\nend\n</cell>\n\
    <cell>", "  result = string.dup\n  string.downcase!\n  string.upcase!\n  result\n\
    end", "  string.downcase!\n  string.upcase!\n  string\nend", "  string.gsub(/./)\
    \ do |char|\n    case char\n    when 'a'\n      'A'\n    when 'b'\n      'B'\n\
    \    when 'c'\n      'C'\n    when 'd'\n      'D'\n    when 'e'\n      'E'\n \
    \   when 'f'\n      'F'\n    when 'g'\n      'G'\n    when 'h'\n      'H'\n  \
    \  when 'i'\n      'I'\n    when 'j'\n      'J'\n    when 'k'\n      'K'\n   \
    \ when 'l'\n      'L'\n    when 'm'\n      'M'\n    when 'n'\n      'N'\n    when\
    \ 'o'\n      'O'\n    when 'p'\n      'P'\n    when 'q'\n      'Q'\n    when 'r'\n\
    \      'R'\n    when 's'\n      'S'\n    when 't'\n      'T'\n    when 'u'\n \
    \     'U'\n    when 'v'\n      'V'\n    when 'w'\n      'W'\n    when 'x'\n  \
    \    'X'\n    when 'y'\n      'Y'\n    when 'z'\n      'Z'\n    when /\\d/\n \
    \     '9'\n    else\n      char\n    end\n  end\nend", "  string.tr!(\"a-z\",\
    \ \"A-Z\")\n  string.tr!(\"A-Z\", \"a-z\")\nend", "  string\n    .downcase!\n\
    \    .upcase!\nend", "  string.gsub(/./) { |c| c.downcase == c.upcase ? c.upcase\
    \ : c.downcase }\nend", "  string.downcase! \n  string.upcase! \nend", "  string.downcase!\n\
    \  string.upcase!\n  string\nend", "  string.downcase!\n  string\nend\n</code></pre>\n\
    <h3>String#reverse</h3>\n<pre class=\"highlight ruby\"><code><span class=\"k\"\
    >def</span> <span class=\"nf\">reverse</span>\n  <span class=\"kp\">self</span>.<span\
    \ class=\"ruby-identifier\">reverse</span>\n<span class=\"k\">end</span>\n</code></pre>\n\
    <h3>String#reverse!</h3>\n<pre class=\"highlight ruby\"><code><span class=\"k\"\
    >def</span> <span class=\"nf\">reverse!</span>\n  <span class=\"kp\">self</span>.<span\
    \ class=\"ruby-identifier\">reverse!</span>\n<span class=\"k\">end</span>\n</code></pre>\n\
    <h3>String#slice</h3>\n<pre class=\"highlight ruby\"><code><span class=\"k\">def</span>\
    \ <span class=\"nf\">slice</span>(<span class=\"ident\">start</span>, <span class=\"\
    ident\">length</span>)\n  <span class=\"kp\">self</span>[<span class=\"ident\"\
    >start</span>, <span class=\"ident\">length</span>]\n<span class=\"k\">end</span>\n\
    </code></pre>\n<h3>String#slice!</h3>\n<pre class=\"highlight ruby\"><code><span\
    \ class=\"k\">def</span> <span class=\"nf\">slice!</span>(<span class=\"ident\"\
    >start</span>, <span class=\"ident\">length</span>)\n  <span class=\"kp\">self</span>[<span\
    \ class=\"ident\">start</span>, <span class=\"ident\">length</span>]\n<span class=\"\
    k\">end</span>\n</code></pre>\n<h3>String#succ</h3>\n<pre class=\"highlight ruby\"\
    ><code><span class=\"k\">def</span> <span class=\"nf\">succ</span>\n  <span class=\"\
    kp\">self</span>.<span class=\"ruby-identifier\">succ</span>\n<span class=\"k\"\
    >end</span>\n</code></pre>\n<h3>String#succ!</h3>\n<pre class=\"highlight ruby\"\
    ><code><span class=\"k\">def</span> <span class=\"nf\">succ!</span>\n  <span class=\"\
    kp\">self</span>.<span class=\"ruby-identifier\">succ!</span>\n<span class=\"\
    k\">end</span>\n</code></pre>\n<h3>String#swapcase</h3>\n<pre class=\"highlight\
    \ ruby\"><code><span class=\"k\">def</span> <span class=\"nf\">swapcase</span>\n\
    \  <span class=\"kp\">self</span>.<span class=\"ruby-identifier\">swapcase</span>\n\
    <span class=\"k\">end</span>\n</code></pre>\n<h3>String#swapcase!</h3>\n<pre class=\"\
    highlight ruby\"><code><span class=\"k\">def</span> <span class=\"nf\">swapcase!</span>\n\
    \  <span class=\"kp\">self</span>.<span class=\"ruby-identifier\">swapcase!</span>\n\
    <span class=\"k\">end</span>\n</code></pre>\n<h3>String#title</h3>\n<pre class=\"\
    highlight ruby\"><code><span class=\"k\">def</span> <span class=\"nf\">title</span>\n\
    \  <span class=\"kp\">self</span>.<span class=\"ruby-identifier\">title</span>\n\
    <span class=\"k\">end</span>\n</code></pre>\n<h3>String#title!</h3>\n<pre class=\"\
    highlight ruby\"><code><span class=\"k\">def</span> <span class=\"nf\">title!</span>\n\
    \  <span class=\"kp\">self</span>.<span class=\"ruby-identifier\">title!</span>\n\
    <span class=\"k\">end</span>\n</code></pre>\n<h3>String#tr</h3>\n<pre class=\"\
    highlight ruby\"><", "  string.gsub(/[a-z]+/) { |x| x.upcase }\n    .gsub(/[A-Z]+/)\
    \ { |x| x.downcase }\nend\n</cell>\n<cell>", "  string.downcase!\nend", "  string.downcase!\n\
    \  string.upcase!\n  string\nend", "  # Replace uppercase with lowercase.\n  string.downcase!\n\
    \  # Replace lowercase with uppercase.\n  string.upcase!\n  # Return the string.\n\
    \  string\nend", "  string.downcase!\n  string.upcase!\nend\n</code>\n<|/ a |>\n\
    <| a |>\nIn Ruby, all strings have a downcase method. Just do my_string.downcase.\
    \ \nFor Ruby on Rails specifically:\n<code>", "  string.downcase!\n  string.reverse!\n\
    end\n</code>\n<|/ a tags=ruby,string |>\n<| a tags=ruby,string dscore=2 |>\nYou\
    \ could always use gsub! for that:\n<code>\nstr = \"HelloWorld\"\nstr.gsub!('H',\
    \ 'h').gsub!('W', 'w')\np str #=> \"hELlowrd\"\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ is not correct. You are going to replace 'W' with 'w' and 'h' with 'h'. But\
    \ the OP wants to replace upper case 'H' with lower case 'h' and upper case 'W'\
    \ with lower case 'w'\n<|/ c |>\n<| c |>\nHe said \"replace all lowercase H's\
    \ with uppercase h's\" and \"replace all uppercase W's with lowercase w's\"\n\
    <|/ c |>\n<| c |>\nYes it does make more sense now.\n<|/ c |>\n<| c |>\nYes, your\
    \ solution is correct. But my answer does not require a complex regex, just few\
    \ lines of code!\n<|/ c |>\n<| c |>\nAgreed. But what if he wants to replace lower\
    \ case with upper case and upper case with lower case?\n<|/ c |>\n<| a dscore=0\
    \ |>\nI like to replace upper case with lower case and lower case with upper case\
    \ using gsub. Here's my code:\n<code>", "  string.gsub(/([a-z]+)([A-Z]+)/, '\\\
    U\\2\\L\\1')\nend", "  string.downcase!\n  string.upcase!\n  string\nend", " \
    \   string.downcase!\n    string.upcase!\n    string\nend", "  string.gsub(/[a-z]+/)\
    \ { |m| m.upcase }\nend", "  string.gsub(/[a-z]/) { |s| s.downcase }.gsub(/[A-Z]/)\
    \ { |s| s.upcase }\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\n\
    Thanks for the suggestion. I am going to give it a try. :)\n<|/ c |>\n<| a |>\n\
    I used the solution provided by Antony Shirodabee but I wanted to refactor it\
    \ a little to make it more efficient.  I also added a few methods to make it easier\
    \ to reuse the functions.  I tested this against the accepted answer and it gave\
    \ me a difference of less than 10% when running a million tests with different\
    \ data.\nI wanted to make it more reusable and flexible so I wrote the following\
    \ class:\n<code>", "  string.downcase!\n  string.upcase!\n  string\nend", "  return\
    \ string.downcase + string.upcase\nend", "  string.downcase!\nend", "    string.downcase!\n\
    \    string.upcase!\n    string\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI\
    \ like this solution because it does not require a method.\n<|/ c |>\n<| c |>\n\
    Thanks for this, very helpful.\n<|/ c |>\n<| a dscore=5 |>\nAnother approach:\n\
    <code>", "  string.downcase!\n  string.upcase!\n  string\nend\n</code>\nThe first\
    \ thing you should do is make sure you've loaded the ActiveSupport gem in your\
    \ Gemfile and run bundle. Then, add the code above to your app/models/concerns/string_utilities.rb\
    \ file. The first two lines ensure that your class can call downcase and upcase\
    \ on string objects.\nNext, add the following method to your app/models/concerns/lower_case.rb\
    \ or config/initializers/lower_case.rb file:\n<code>", "  string.gsub!(/[a-z]/)\
    \ { |char| char.upcase }\n  string.gsub!(/[A-Z]/) { |char| char.downcase }\n \
    \ string\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis is a great solution for\
    \ Ruby 1.9 and above. I'm just trying to figure out if this is more memory efficient\
    \ than [my answer](http://stackoverflow.com/a/17665161/1148195)\n<|/ c |>\n<|\
    \ c |>\n, for my use case (a password reset token) this solution was about 30%\
    \ faster. Thanks.\n<|/ c |>\n<| c |>\nFYI the above solutions use a regular expression,\
    \ which are expensive. The solution I posted below uses string#tr which uses much\
    \ less memory and is faster on large strings. My solution takes ~80% less memory\
    \ and ~16% faster on large strings. Thanks for your solution.\n<|/ c |>\n<| a\
    \ dscore=2 |>\nHow about this?\n<code>", "  string.downcase!\n  string.upcase!\n\
    \  string\nend", "  string\n    .upcase\n    .gsub(/./) do |char|\n      case\
    \ char.downcase\n      when char.upcase\n        char\n      else\n        char.upcase\n\
    \      end\n    end\nend\n</code>\n<|/ a |>\n<| a |>\nThis should do it:\n<code>",
  "  string.downcase!\n  string.upcase!\n  string\nend\n</code>\n<|/ a dscore=2 tags=ruby\
    \ |>\n<| c |>\nThank you. Looks very nice. One question: why are you using a lambda?\
    \ It seems so straightforward to use `flip_case(my_string)` in the same way we\
    \ call any method. Is there a technical difference between calling `flip_case`\
    \ using a lambda vs a plain old method call? Why choose one over the other?\n\
    <|/ c |>\n<| c |>\n`flip_case` is an instance method, not a \"normal\" method,\
    \ which is why I made it a class method. When you call `flip_case` as `MyClass.flip_case`,\
    \ you are calling it as `flip_case` on `MyClass` itself, which is why it works.\
    \ When you call it as `flip_case.call` you are calling it as `flip_case` on a\
    \ `Fixnum` instance, which isn't defined.\n<|/ c |>\n<| c |>\nI understand that\
    \ flip_case is an instance method. My point is that the way you call flip_case\
    \ using MyClass.flip_case seems very natural. Why do we need flip_case.call if\
    \ flip_case is an instance method? Is there a technical difference between flip_case.call\
    \ and flip_case?\n<|/ c |>\n<| c |>\nYou don't need `flip_case.call`, since `flip_case`\
    \ itself already returns the result. Also, `flip_case.call` works only if the\
    \ string you're passing is a string literal in source code. Remember that the\
    \ `call` method takes an argument (in this case a string literal), converts it\
    \ to uppercase and lowercase (by modifying it) and returns it.\n<|/ c |>\n<| c\
    \ |>\nThanks. That makes sense. But if flip_case is an instance method why do\
    \ I need flip_case.call? I understand that flip_case itself returns the result.\
    \ My point is that the way you call flip_case using MyClass.flip_case seems very\
    \ natural. Why do we need flip_case.call if flip_case is an instance method? Is\
    \ there a technical difference between flip_case.call and flip_case?\n<|/ c |>\n\
    <| a dscore=2 |>\nYou can use the method String#tr:\n<code>\nmy_string.tr('abcdefghijklmnopqrstuvwxyz',\
    \ 'AbCdEfGhIjKlMnOpQrStUvWxYz')\n</code>\n<|/ a tags=ruby |>\n<| a |>\nHow about\
    \ this?\n<code>\nmy_string.gsub(/[aeiou]/", "    string.downcase!\n    string.upcase!\n\
    \    string\nend\n</code>\nThe first line downcase will change all characters\
    \ from lowercase to uppercase. The second line upcase will change all characters\
    \ from uppercase to lowercase. The last line return the string without any changes.\n\
    I hope you find this helpful.\n<|/ a tags=ruby |>\n<| c |>\nWhile this code snippet\
    \ may solve the problem, it doesn't explain why or how it answers the question.\
    \ Please [include an explanation for your code](//meta.stackexchange.com/q/114762/269535),\
    \ as that really helps to improve the quality of your post. Remember that you\
    \ are answering the question for readers in the future, and those people might\
    \ not know the reasons for your code suggestion. **Flaggers / reviewers:** [For\
    \ code-only answers such as this one, downvote, don't delete!](//meta.stackoverflow.com/a/260413/2747593)\n\
    <|/ c |>\n<| a tags=ruby dscore=1 |>\nThe String class has a method called upcase\
    \ and downcase that will convert all letters within the string to uppercase or\
    \ lowercase respectively. In Ruby 1.9+ there is also a method called upcase that\
    \ will do the same.\n<code>\n\"Hello World\".upcase\n=> \"HELLO WORLD\"\n</code>\n\
    <|/ a |>\n<| a |>\nYou can use the downcase and upcase methods of strings to convert\
    \ your string to lowercase/uppercase:\n<code>\n>> s = 'Hello World'\n=> \"Hello\
    \ World\"\n>> s.upcase\n=> \"HELLO WORLD\"\n>> s.downcase\n=> \"hello world\"\n\
    </code>\n<|/ a tags=ruby dscore=1 |>\n<| a tags=ruby dscore=1 |>\nIf you want\
    \ to change all letters in string use upcase and downcase methods:\n<code>\n>>\
    \ \"Hello World\".upcase\n=> \"HELLO WORLD\"\n>> \"Hello World\".downcase\n=>\
    \ \"hello world\"\n</code>\n<|/ a |>\n<| a tags=ruby |>\nupcase!\nConverts string\
    \ to uppercase. Returns self.", "  string\n    .gsub(/./) { |x| x.upcase }\n \
    \   .gsub(/./) { |x| x.downcase }\nend", "  return string.gsub(/[a-z]/) do |char|\n\
    \    char.upcase + char.downcase\n  end\nend", "  result = \"\"\n  input.upcase!(string)\n\
    \  input.downcase!(string)\n  result << string\n  result\nend\n</code>\nAs you\
    \ can see, there are many ways to do this. My personal favorite, is to use the\
    \ String#gsub method, passing the character we want to replace, as well as a block:\n\
    <code>", "  return string.gsub(/./) do |character|\n    case character\n    when\
    \ \"a\"\n      \"A\"\n    when \"b\"\n      \"B\"\n    when \"c\"\n      \"C\"\
    \n    when \"d\"\n      \"D\"\n    when \"e\"\n      \"E\"\n    when \"f\"\n \
    \     \"F\"\n    when \"g\"\n      \"G\"\n    when \"h\"\n      \"H\"\n    when\
    \ \"i\"\n      \"I\"\n    when \"j\"\n      \"J\"\n    when \"k\"\n      \"K\"\
    \n    when \"l\"\n      \"L\"\n    when \"m\"\n      \"M\"\n    when \"n\"\n \
    \     \"N\"\n    when \"o\"\n      \"O\"\n    when \"p\"\n      \"P\"\n    when\
    \ \"q\"\n      \"Q\"\n    when \"r\"\n      \"R\"\n    when \"s\"\n      \"S\"\
    \n    when \"t\"\n      \"T\"\n    when \"u\"\n      \"U\"\n    when \"v\"\n \
    \     \"V\"\n    when \"w\"\n      \"W\"\n    when \"x\"\n      \"X\"\n    when\
    \ \"y\"\n      \"Y\"\n    when \"z\"\n      \"Z\"\n    when \"A\"\n      \"a\"\
    \n    when \"B\"\n      \"b\"\n    when \"C\"\n      \"c\"\n    when \"D\"\n \
    \     \"d\"\n    when \"E\"\n      \"e\"\n    when \"F\"\n      \"f\"\n    when\
    \ \"G\"\n      \"g\"\n    when \"H\"\n      \"h\"\n    when \"I\"\n      \"i\"\
    \n    when \"J\"\n      \"j\"\n    when \"K\"\n      \"k\"\n    when \"L\"\n \
    \     \"l\"\n    when \"M\"\n      \"m\"\n    when \"N\"\n      \"n\"\n    when\
    \ \"O\"\n      \"o\"\n    when \"P\"\n      \"p\"\n    when \"Q\"\n      \"q\"\
    \n    when \"R\"\n      \"r\"\n    when \"S\"\n      \"s\"\n    when \"T\"\n \
    \     \"t\"\n    when \"U\"\n      \"u\"\n    when \"V\"\n      \"v\"\n    when\
    \ \"W\"\n      \"w\"\n    when \"X\"\n      \"x\"\n    when \"Y\"\n      \"y\"\
    \n    when \"Z\"\n      \"z\"\n", "  string.gsub(/./) { |s| s.upcase == s.downcase\
    \ ? s.downcase : s.upcase }\nend\n</code></pre>\n<ul>\n<li><strong>Ruby</strong>:\n\
    <pre><code class=\"ruby\"><span class=\"id\">irb</span> <code data-lang=\"ruby\"\
    >\n> flip_case(\"Hello\")\n => \"hELLO\" \n> flip_case(\"aBC\")\n => \"aBC\" \n\
    > flip_case(\"123\")\n => \"123\" \n> flip_case(123)\n => 123 \n> flip_case(12.3)\n\
    \ => 12.3 \n> flip_case(true)\n => true \n> flip_case(\"false\")\n => \"false\"\
    \ \n> flip_case(\"\")\n => \"\" \n> flip_case({})\n => {} \n> flip_case(nil)\n\
    \ => nil \n> flip_case(Date.new(2013, 3, 20))\n => &quot;2013-03-20&quot; \n>\
    \ flip_case(Time.new(2013, 3, 20, 1, 4, 15))\n => &quot;2013-03-20T13%3A04%3A15&quot;\
    \ \n</code></pre>\n</li>\n</ul>\n<hr>\n<h2 id=\"string+operation\">String Operation</h2>\n\
    <ul>\n<li><strong>JavaScript</strong>:\n<pre><code class=\"js\">\n// Replace all\
    \ occurrences of a given value in string\nvar replaceAll = string.replaceAll(value);\n\
    </code></pre>\n</li>\n</ul>\n<hr>\n<h2 id=\"string-operation-with-regex\">String\
    \ Operation with Regex</h2>\n<ul>\n<li><strong>JavaScript</strong>:\n<pre><code\
    \ class=\"js\">\n// Replace all occurrences of a given value in string\nvar replaceAllWithRegex\
    \ = string.replaceAllWithRegex(pattern, value);\n</code></pre>\n</li>\n</ul>\n\
    <hr>\n<h2 id=\"string-operation-with-function\">String Operation with Function</h2>\n\
    <ul>\n<li><strong>JavaScript</strong>:\n<pre><code class=\"js\">\n// Replace all\
    \ occurrences of a given value in string\nvar replaceAllWithFunction = string.replaceAllWithFunction(pattern,\
    \ functionToApply)\n</code></pre>\n</li>\n</ul>\n<hr>\n<h2 id=\"string-split\"\
    >String Split</h2>\n<ul>\n<li><strong>JavaScript</strong>:\n<pre><code class=\"\
    js\">\nvar result = string.split(separator, limit);\n</code></pre>\n</li>\n</ul>\n\
    <hr>\n<h2 id=\"string-split-with-regex\">String Split with Regex</h2>\n<ul>\n\
    <li><strong>JavaScript</strong>:\n<pre><code class=\"js\">\nvar result = string.splitWithRegex(pattern,\
    \ limit);\n</code></pre>", "  string.downcase!\n  string.upcase!\n  string\nend",
  "  return string.gsub(/[A-Z]/) do |match|\n    match == 'a' ? 'A' : ('A' << match[0].upcase).downcase\n\
    \  end\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=string,ruby |>\n<code>\n\"\
    hello world\".gsub(/./) { |x| x.upcase }.gsub(/./) { |x| x.downcase }\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=2 |>\nMy solution:\n<code>\nrequire 'active_support/core_ext/string'",
  "  string.downcase.gsub!(/./) { |char| char.upcase }\n  string.upcase.gsub!(/./)\
    \ { |char| char.downcase }\nend", "  return string.downcase\nend", "  string.downcase!\n\
    \  string.upcase!\nend", "  string.gsub(/[a-z](?![a-z])/,'\\U\\1')\nend", "  string\n\
    \    .downcase!\n    .upcase!\nend", "  string.downcase!\n  string.upcase!\n \
    \ string\nend", "  result = string.dup\n  result.tr!(\"abcdefghijklmnopqrstuvwxyz\"\
    , \"cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n  result.tr!(\"cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    , \"abcdefghijklmnopqrstuvwxyz\")\n  result\nend", "  string.upcase! if string.downcase?\n\
    \  string\nend\n</code>\n<|/ a |>\n<| a dscore=2 |>\nThis one is better suited\
    \ for the Rails world, since it uses ActiveSupport methods:\n<code>", "  string.gsub(/./)\
    \ do |char|\n    char.upcase == char.downcase ? char.downcase : char.upcase\n\
    \  end\nend", "  string.chars.each_char.map do |char|\n    char == char.upcase\
    \ ? char.downcase : char.upcase\n  end.join\nend\n</code>\nTo test this out in\
    \ irb, you need to do this:\n<code>\nirb\nrequire 'minitest/autorun'", "  string.gsub(/./)\
    \ {|char| char.upcase + char.downcase }\nend", "  string.gsub(/[^a-z]+/) { |char|\
    \ char.downcase + char.upcase }\nend\n</cell>\n<text>\nNow that we have these\
    \ functions defined, we can use them to solve the exercise.", "  string.chars.\n\
    \    join.\n    map { |c| c.upcase }.\n    join\nend\n</pre>\n<h3>\n<a id=\"user-content-how-do-i-use-it\"\
    \ href=\"#how-do-i-use-it\" id=\"how-do-i-use-it\">How do I use it?</a>\n</h3>\n\
    <p>\nThis plugin is currently available in the <tt>lib/</tt>\ndirectory, and will\
    \ make available for use in your Rails project\n(assuming you have added it to\
    \ your <tt>environment.rb</tt> file as\ndescribed above).\n</p>\n<pre class=\"\
    ruby\"><span class=\"ruby-keyword\">require</span> <span class=\"ruby-string\"\
    >'rubygems'</span>\n<span class=\"ruby-keyword\">require</span> <span class=\"\
    ruby-string\">'active_support/core_ext/string'</span>\n</pre>\n<p>\nThe plugin\
    \ has several methods, each of which can either be used in\na Rails project as\
    \ per the <tt>String</tt> class definition, or as a\nstand-alone Ruby method,\
    \ which you can invoke as:\n</p>\n<pre class=\"ruby\"><span class=\"ruby-keyword\"\
    >require</span> <span class=\"ruby-string\">'active_support/core_ext/string'</span>\n\
    <span class=\"ruby-keyword\">string</span> <span class=\"ruby-operator\">:lower</span><span\
    \ class=\"ruby-operator\">,</span> <span class=\"ruby-operator\">:upper</span>",
  "  string.to_s.downcase!\nend", "  string.downcase!\nend", "  string.downcase!\n\
    \  string.upcase!\n  string\nend", "  string.downcase!\n  string.upcase!\n  string.upcase!\n\
    end", "  string.downcase! unless string.empty?\n  string.upcase!\n  string\nend",
  "  string.split(//).map do |word|\n    word.include?(:upper) ? word[0].to_s.upcase\
    \ + word[1..-1] : word\n  end.join(\" \")\nend", "  string.downcase!\n  string.upcase!\n\
    \  string\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis does not handle the\
    \ empty string, and doesn't handle other non-alphabetic characters.\n<|/ c |>\n\
    <| c |>\n: It does handle an empty string. `flip_case.call(nil)` returns `nil`.\
    \ I don't understand your \"non-alphabetic characters\" comment.\n<|/ c |>\n<|\
    \ c |>\nApologies, I missed the `!` after `downcase` and `upcase`. And yes, `flip_case.call(nil)`\
    \ returns nil -- but that's probably not what was intended. It also doesn't handle\
    \ other non-alphabetic characters because you are allowing some non-alphabetic\
    \ characters. For example, if you wanted to exclude digits and punctuation, you\
    \ would be better off using [`String#swapcase`](http://ruby-doc.org/core-2.3.0/String.html#method-i-swapcase)\
    \ instead of writing your own custom method.\n<|/ c |>\n<| c |>\n: I agree, `swapcase`\
    \ is better here. I've removed my downvote and updated my answer.\n<|/ c |>\n\
    <| a |>\n<code>", "  string.gsub(/[a-z]/) { |c| c.downcase }\n  string.gsub(/[A-Z]/)\
    \ { |c| c.upcase }\nend", "  string.downcase!\nend", "  string.gsub(/([a-z]+)/i)\
    \ do |m|\n    \"#{m[0].upcase}#{m[1].downcase}\"\n  end\nend", "  string.split(//).inject([],\
    \ :zip).map { |a, e| [e.first, e.last.downcase] }.join\nend", "  string.gsub(/(?=[A-Z])/)\
    \ { |c| c.upcase }.\n           gsub(/(?<=[a-z])/) { |c| c.downcase }\nend\n</cell>\n\
    <cell>\nstring = \"The quick brown fox jumps over the lazy dog\"\n</cell>\n<cell>\n\
    string.gsub(/(?=[A-Z])/) { |c| c.upcase }.\n           gsub(/(?<=[a-z])/) { |c|\
    \ c.downcase }\n</cell>\n<text>\nReferences\nRuby 1.8.7 RegExp Reference\nRuby\
    \ 1.9.3 RegExp Reference\nRuby 1.9+ RegExp Reference", "  string.downcase!\nend\n\
    </pre>\n<p>\nThe <tt>string.downcase!</tt> modifier is used to flip the case of\
    \ a string\nin-place.  In this case we pass it the <tt>string</tt> variable that\
    \ we have already\nmodified.\n</p>", "  string.gsub(/[a-z](?![A-Z])/) { |s| s.upcase\
    \ }.gsub(/[A-Z](?![a-z])/) { |s| s.downcase }\nend\n</code>\n<|/ a |>\n<| c |>\n\
    Thanks so much for your answer and the links to resources, this is really helpful.\
    \ I am looking into Ruby more at the moment so this will be very useful to me.\n\
    <|/ c |>\n<| c |>\nI wish I could up-vote you more than once -- you just helped\
    \ me out in a Ruby problem I'm having, thanks!\n<|/ c |>\n<| c |>\n, Thanks. This\
    \ is my first question on Stack Overflow. Great to know that I was on the right\
    \ track.\n<|/ c |>\n<| a dscore=1 |>\nHere's my solution to this:\n<code>", " \
    \ string\n    .split(//)\n    .map { |char| char.downcase + char.upcase }\n  \
    \  .join\nend", "  return string.downcase + string.upcase\nend\n</pre>\n<p>\n\
    The <code>.upcase</code>, <code>.downcase</code> and\n<code>.capitalize</code>\
    \ methods are all new and undocumented in the 1.8.6\nrelease.\n</p>\n<p>\n<code>capitalize</code>\
    \ returns a copy of <code>string</code> with its\nfirst letter in lowercase, <code>upcase</code>\
    \ returns a copy of <code>string</code> with its\nfirst letter in uppercase, and\
    \ <code>downcase</code> returns a copy of <code>string</code> with its\nfirst\
    \ letter in uppercase. The method <code>capitalize</code> was introduced in Ruby\
    \ 1.8.7 and was not\nsupported in Ruby 1.8.6.\n</p>\n<p>\nRuby 1.8.7 introduced\
    \ <code>capitalize!</code>, which is a more \"in-place\" change\nof <code>capitalize</code>.\n\
    </p>\n<p>\n<code>capitalize!</code> was introduced in Ruby 1.9.2.\n</p>\n<h3>2.6.1\
    \ Unicode Support</h3>\n<p>\nUnicode has been fully supported for years in Ruby\
    \ 1.8.7+.\nFor older versions of Ruby, it depends on your operating system and\
    \ the application\nyou're working on.  Here are some pointers:\n</p>\n<ul>\n \
    \ <li>\n    For Windows, your operating system may have support for Unicode in\
    \ the\n    C Runtime Library or Windows APIs.  Ruby 1.8.7 fully supports Unicode.\n\
    \    Older versions do not.\n  </li>\n  <li>\n    If you are using the IronRuby\
    \ implementation, you may have Unicode support\n    on the Ruby side.\n  </li>\n\
    \  <li>\n    For JRuby and IronRuby, you may have Unicode support on the .NET\
    \ side.\n  </li>\n  <li>\n    If you are using RubyInstaller, you may have Unicode\
    \ support on your\n    Ruby side.\n  </li>\n</ul>\n<p>\nUnicode support, when\
    \ supported, can dramatically improve performance.  In a\nUnicode based system,\
    \ Ruby 1.8.7 is able to handle all characters in\nUnicode without needing to reload\
    \ the default encoding and the\n<code>Encoding::Compatibility</code> module. \
    \ This means that it is faster and also\nsaves a lot of memory. On the other hand,\
    \ with Ruby 1.8.7 Unicode support\nrequires the Ruby core to be recompiled, and,\
    \ as a result, the\n<code>Encoding::Compatibility</code> module is removed.\n\
    </p>\n<p>\nUnicode support was introduced in Ruby 1.9.2.\n</p>\n<h3>2.6.2 GC Effectiveness</h3>\n\
    <p>\nThe garbage collector has always been very effective.  The performance of\n\
    Ruby 1.8.7 is actually not that great.", "  string.gsub!( /([a-z])/, '\\U\\1'.upcase\
    \ )\n  string.gsub!( /([A-Z])/, '\\L\\1'.downcase )\n  string\nend", "  string.to_s.upcase.to_s.downcase\n\
    end", "  string.downcase!\n  string.upcase!\n  string\nend", "  string.downcase!\n\
    end", "  result = \"\"\n  string.chars.each do |char|\n    case char\n      when\
    \ 'a' then result += \"A\"\n      when 'A' then result += \"a\"\n      else result\
    \ << char\n    end\n  end\n  result\nend", "  string[0].upcase + string[1..-1].downcase\n\
    end\n</code>\nNotice that there are two methods defined for flip_case.  One that\
    \ returns the original string, and one that returns a string.  By defining the\
    \ method as flipped_case, we have a way to call the flipped_case method without\
    \ having to explicitly call flip_case.\n<|/ a tags=string,ruby,capitalization\
    \ |>\n<| a dscore=2 |>\nJust for fun. :)\n<code>", "  string.gsub(/./) { |c| c.upcase\
    \ + c.downcase }\nend", "  string.tr!(\"A-Z\", \"a-z\").tr!(\"a-z\", \"A-Z\")\n\
    \  string.downcase!\nend", "  string.downcase!\n  string.upcase!\n  string\nend\n\
    </code>\nIn addition to calling downcase and upcase on strings it also has some\
    \ nice string methods which make it easier:\n<code>", "  string.to_s.gsub(/([a-z])/)\
    \ { $1.upcase }\nend", "  string.gsub!(/[A-Z]/ => \"\\U0000\".upcase + $1.downcase\
    \ + \"\\U0000\".upcase)\n  string.gsub!(/[a-z]/ => \"\\U0000\".upcase + $1.upcase\
    \ + \"\\U0000\".upcase)\nend", "  string.downcase!\n  string.upcase!\n  string\n\
    end", "  string.downcase!\n  string.upcase!\n  string\nend", "  string.tr!('^a-z',\
    \ 'A-Z')\n  string.tr!('A-Z', 'a-z')\nend", "  return string.gsub(/[a-z]+/, '\\\
    &\\&').gsub(/[A-Z]+/) {|m| m.upcase }.gsub(/\\&\\&/, '#')\nend", "  return string.gsub(/([a-z])/)\
    \ { $1.upcase }\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis only flips the\
    \ lowercase to uppercase part\n<|/ c |>\n<| a dscore=3 tags=ruby |>\nI usually\
    \ use a method like this in my apps:\n<code>", "  string.upcase!\n  string.downcase!\n\
    \  string\nend", "  return string.gsub(/[a-z]/) do |match|\n    match[1] < match[2].toupper_case?\
    \ ? match[1].upcase : match[1].downcase\n  end\nend\n</code>\nLet's see what it\
    \ does:\n<code>\nflip_case.call(\"Hello\")", "  string.downcase!\n  string.upcase!\n\
    \  string\nend", "  string.downcase! \n  string.upcase! \nend\n</cell>\n<cell>\n\
    flip_case.call(\"hello\")\n</cell>\n<cell>", "  string.downcase!\n  string.upcase!\n\
    \  string\nend", "  string.downcase! && string.upcase!\nend\n</code>\nAs a rule,\
    \ always use Ruby's String#downcase and String#upcase when dealing with international\
    \ strings. When dealing with ASCII strings, use String#swapcase.\nAvoid using\
    \ String#gsub if possible. It can be quite inefficient on large strings or when\
    \ dealing with non-ASCII strings.\n<|/ a tags=ruby-on-rails,ruby |>\n<| c |>\n\
    I believe you made a typo (`swapcase!` instead of `swapcase`), but this was extremely\
    \ helpful. Thank you for the assistance.\n<|/ c |>\n<| a tags=ruby-on-rails,ruby\
    \ |>\nJust for fun I thought I'd throw my solution to the rails console...\n<code>\n\
    'abc'.gsub(/./) { |s| s.upcase - 'a'.ord; end", "    string.gsub!(/(.)/ do\n \
    \       $1.upcase + $1.downcase\n    end).downcase\nend", "  string.downcase!\n\
    \  string.upcase!\n  string\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-4\
    \ |>\n<| c |>\nI like this one more than the others because it doesn't modify\
    \ the original string\n<|/ c |>\n<| c |>\nThe downside of this is that you lose\
    \ the original string on exceptions. If you need it for further work, that might\
    \ be a problem.\n<|/ c |>\n<| c |>\nAgreed. But what if there is no exception,\
    \ is just empty? The above method also preserves empty string.\n<|/ c |>\n<| c\
    \ |>\nIt works for me even for empty strings. Do you mean you cannot use it like\
    \ that?\n<|/ c |>\n<| c |>\nThe reason I like this is that it allows me to use\
    \ it in my view (erb files) rather than in my models (where I typically have to\
    \ put a begin/rescue block in order to use this method.\n<|/ c |>\n<| a |>\n<code>\n\
    \"string\".downcase.upcase\n=> \"String\"\n</code>\n<|/ a dscore=5 tags=ruby,ruby-on-rails,ruby-on-rails-4\
    \ |>\n<| c |>\n\"The downcase and upcase methods are available on the String class\"\
    \ [http://ruby-doc.org/core-2.3.3/String.html#method-i-downcase](http://ruby-doc.org/core-2.3.3/String.html#method-i-downcase)\n\
    <|/ c |>\n<| c |>\nYes, but the OP was asking about a Rails method.\n<|/ c |>\n\
    <| c |>\nAh sorry, I misread. I thought they were asking about the string extensions\
    \ available in Rails.\n<|/ c |>\n<| c |>\nThis is not what op was asking\n<|/\
    \ c |>\n<| c |>\n\"The downcase and upcase methods are available on the String\
    \ class\" [http://ruby-doc.org/core-2.3.3/String.html#method-i-downcase](http://ruby-doc.org/core-2.3.3/String.html#method-i-downcase)\n\
    <|/ c |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-4 |>\nThere's also downcase!\
    \ and upcase! which doesn't modify the original string. The same can be accomplished\
    \ using gsub. For example:\n<code>\n\"FOO\".gsub!(/[[:upper:]]/) { |char| char.upcase\
    \ }\n=> \"Foo\"\n", "  string.gsub(/./) do |char|\n    char.upcase == char.downcase\
    \ ? char.downcase : char.upcase\n  end\nend", "  return string.gsub(/[a-z]/) {|a|\
    \ a.upcase + a.downcase }\nend", "  string.downcase! if string.downcase?\n  string\n\
    end", "  string.gsub!(/[a-z]/) { |match| match.upcase }\n  string.gsub!(/[A-Z]/)\
    \ { |match| match.downcase }\n  string\nend", "  string.downcase!\n  string.upcase!\n\
    end\n</code>\nNow, let's put it all together:\n<code>", "  string.gsub(/([a-z]{1}[a-z]+)/i)\
    \ { |match| match.upcase }.gsub(/([A-Z]{1})/i) { |match| match.downcase }\nend\n\
    </code>\n<|/ a tags=ruby,ruby-on-rails-3,ruby-on-rails |>\n<| a tags=ruby,ruby-on-rails-3,ruby-on-rails\
    \ |>\n<code>\n\"HeLLo WoRlD\".gsub(/./){|x| x.upcase }.gsub(/./){|x| x.downcase\
    \ }\n</code>\n<|/ a dscore=3 |>\n<| a |>\n<code>\n\"Hello\".gsub(/./) {|x| x.upcase\
    \ }.gsub(/./) {|x| x.downcase }\n=> \"hELLO\"\n</code>\n<|/ a dscore=3 tags=ruby,ruby-on-rails-3,ruby-on-rails\
    \ |>\n<| a dscore=2 tags=ruby,ruby-on-rails-3,ruby-on-rails |>\n<code>\nstring\
    \ = \"HeLLo WoRlD\"\np string.scan(/./).map { |c| c.upcase }.join + string.scan(/./).map\
    \ { |c| c.downcase }.join\n</code>\n<|/ a |>\n<| c |>\n`scan` will work nicely\
    \ here, but your second `map` will fail if your string contains any non-alpha-numeric\
    \ characters. You'll need `downcase` there, too.\n<|/ c |>\n<| c |>\nThanks, it\
    \ would be nicer if it was able to handle that case. I'll edit it to handle that.\n\
    <|/ c |>\n<| c |>\nIf you're going to use `scan`, it would be better to just do\
    \ it once and then iterate over the array rather than call `map` twice each time.\n\
    <|/ c |>\n<| c |>\n, this is just for demonstration purposes. I generally don't\
    \ recommend using `scan` as it's very inefficient and you end up doing twice the\
    \ work. Plus, it can have other side effects (like throwing away non-matching\
    \ elements).\n<|/ c |>\n<| c |>\nIt also modifies the original string. Perhaps\
    \ you wanted to `p string` at the end after `map` instead of `p` before the `join`.\n\
    <|/ c |>\n<| a |>\n<code>", "  string.downcase!\n  string\nend", "  string.downcase!\
    \ if string.length == string.length\n  string.upcase!\n  string\nend\n</cell>\n\
    <cell>", "  string.downcase!\nend", "  string.gsub!(\"(?i)([a-z])\".freeze, \"\
    \\\\U\\\\1\".freeze)\n  string.gsub!(\"(?i)([A-Z])\".freeze, \"\\\\1\".freeze)\n\
    \  string.tr!(\"A-Z\".freeze, \"A-Z\".freeze)\n  string.tr!(\"a-z\".freeze, \"\
    a-z\".freeze)\n  string\nend", "  string.downcase!\n  string.upcase!\n  string\n\
    end\n</code>\nTo use this method, invoke it on a string, and it will flip all\
    \ the characters in that string to be the other way.\n<code>\nflip_case(\"Hello\"\
    )", "  # @return [String]\n  return string.gsub(/./) { |c| c.upcase == c.downcase\
    \ ? c.downcase : c.upcase }\nend", "  string.gsub!( /[a-z]/ ){|s| s.upcase; s.downcase}\n\
    \  string.gsub!( /[A-Z]/ ){|s| s.downcase; s.upcase}\n  string.gsub!( /[^a-zA-Z0-9]/\
    \ ){ |s| s.upcase }\n  string\nend\n</code>\n<|/ a dscore=1 |>\n<| a |>\nJust\
    \ a little improvement to previous answer.\n<code>\n def normalize_name(name)\n\
    \   name = name.downcase \n   name[0,1].upcase + name[1..-1]\n end\n</code>\n\
    <|/ a dscore=1 tags=ruby,string,methods,ruby-on-rails |>\n<| a |>\n<code>", " \
    \ string.downcase!\nend", "  string.downcase!\n  string\nend", "  # Implement\
    \ the flip_case method here\n  return string\nend\n</cell>\n<text>\nTest Your\
    \ Solution", "  string.chars.inject(\"\", :+).upcase\nend", "  string.chars.map\
    \ do |c|\n    c =~ /[a-z]/i ? c.succ : c.succ\n  end.join\nend", "    string.chars.reverse_each\
    \ { |c| yield(c).upcase }.join\nend", "  # For each character in the string,\n\
    \  string.gsub(/./) {|c| c.upcase == c.downcase ? c.downcase : c.upcase }\nend\n\
    </pre>", "  string.downcase!\n  string.upcase!\n  string\nend\n</code>\n<|/ a\
    \ dscore=2 |>\n<| a tags=ruby,ruby-on-rails,activerecord |>\n<code>", "  string.upcase!\n\
    \  string.downcase!\nend", "    string.downcase!\n    string.upcase!\n    string\n\
    end\n</code>\n<|/ a dscore=2 tags=ruby-on-rails-4,ruby,ruby-on-rails |>\n<| a\
    \ tags=ruby-on-rails-4,ruby,ruby-on-rails |>\nIn Rails 4, you can easily use i18n\
    \ with your locale files (as in application.yml):\n<code>\nen:\n  greetings: Welcome\
    \ to my app!\n  foo: FOO\n  bar: BAR\n</code>\nAnd in your view template, you\
    \ can easily use I18n.t(\"greetings\") to get \"Welcome to my app!\" and I18n.t(\"\
    foo\") to get \"FOO\" and so on.\nIf you want the entire translation library available\
    \ in your views, you can also do something like this in your application.rb:\n\
    <code>\nconfig.i18n.load_path += Dir[Rails.root.join('config', 'locales', '**',\
    \ '*.{rb,yml}')]\n</code>\nThat will make the whole translation library available\
    \ in your views.  Just make sure to prefix your key names in your translation\
    \ files with your locale, eg en:greetings instead of greetings, to prevent collisions\
    \ with other locales.\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nYou can just add the\
    \ following code to your environment.rb:\n<code>", "  string.downcase.split(\"\
    \").zip(string.upcase.split(\"\")).map do |char, up|\n    char == up ? char.upcase\
    \ : char.downcase\n  end.join \"\"\nend\n</code>\nThis should help you write more\
    \ readable code.\n<|/ a |>\n<| c |>\nThis is very helpful. I am not seeing any\
    \ speed improvements though. I tried running it on a large file, and it didn't\
    \ seem to improve the time at all.\n<|/ c |>\n<| c |>\nAre you running the code\
    \ you posted or some other code with different requirements? The code you posted\
    \ has no reason to be slow in ruby 1.8. You may want to run it in a different\
    \ ruby version. Also, make sure you're using the latest version of the gems. I've\
    \ tested your code on 1.9.3-p125 (ruby 1.9.3p125 (2012-02-16 revision 34643) [x86_64-darwin11.0.0])\
    \ [i686-linux], 1.9.3-p194 (ruby 1.9.3p194 (2012-04-20 revision 35410) [x86_64-linux]).\
    \ Did you run your tests?\n<|/ c |>\n<| c |>\nI am running the code I posted.\
    \ I also added the code I used to test your speed improvements.\n<|/ c |>\n<|\
    \ c |>\nYou didn't answer my question - are you running the code I posted or some\
    \ other code? Can you post your test results? I've updated my answer with a few\
    \ extra notes on your code and tests.\n<|/ c |>\n<| c |>\nOh, I see that you are\
    \ running the code I posted. Did you change your input file? It's much faster\
    \ on mine. Also, did you run my tests? I'm curious to see how this compares to\
    \ what you were running before. It would help to know how the test results are\
    \ different for you.\n<|/ c |>\n<| a dscore=0 |>\nHere's another way to do this\
    \ that uses iterators and avoids string concatenation (which may actually be faster\
    \ if you're not using it a lot).\n<code>", "  string.downcase!\n  string.upcase!\n\
    \  string\nend", "  string.upcase!\n  string.downcase!\n  string\nend", "  string.downcase!\n\
    \  string.upcase!\nend", "  string.downcase! if string.downcase == string\n  string.upcase!\n\
    end", "  string.downcase!\n  string.upcase!\n  string\nend", "  string.downcase!\n\
    \  string.upcase!\n  string\nend\n</code>\nA more idiomatic way is to pass a block,\
    \ since blocks are closures and you can refer to local variables in the parent\
    \ scope:\n<code>", "    string.chars.map do |c| \n      if c == c.upcase then\
    \ c.downcase else c.upcase end\n    end.join(\"\")\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3,string,string\
    \ dscore=0 |>\n<| c |>\nI believe you're missing a closing `end` in the method\
    \ `flip_case`\n<|/ c |>\n<| a dscore=0 |>\nThis should work for you:\n<code>",
  "  string.downcase!\n  string.upcase!\n  string\nend\n</code>\nAs the documentation\
    \ says, the String#downcase! method \"makes the receiver lowercase and does not\
    \ affect the value of the receiver.\" So the call to upcase! doesn't affect any\
    \ value that could be set from the initial call to downcase!.\nLet's say you wanted\
    \ to change the string so that each word starts with a capital letter. You'd use\
    \ the String#gsub! method as follows:\n<code>", "  string.downcase!\n  string.upcase!\n\
    end\n</code>\nThis works because Ruby's String#downcase method and String#upcase\
    \ method both return self, and so you can call them on the return value of a method,\
    \ which is what we want.\nNow you can create a list of all permutations of an\
    \ array of characters. Ruby's Array class has many useful methods, including permutations:\n\
    <code>", "  return string.gsub(/[A-Z]+/, ' '.freeze).gsub(/[a-z]+/, ' '.freeze).gsub(/\\\
    s+/, ' '.freeze)\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\n\"flip lowercase characters\
    \ to uppercase and uppercase to lowercase\" can be simplified to \"flip all letters\
    \ to lowercase\".\n<|/ c |>\n<| a tags=ruby,uppercase,ruby-on-rails |>\nHere's\
    \ another way:\n<code>", "  string.downcase.gsub(/./) {|c| c < 'a' ? c.upcase\
    \ : c.downcase }\nend\n</pre>\n<p>\nRuby also provides some useful string manipulation\
    \ methods\nthat might come in handy. Check out the <a href=\"http://ruby-doc.org/core-1.9.3/String.html\"\
    >String</a> documentation for more\ninformation.\n</p>\n<h2>String Parsing & Formatting</h2>\n\
    <p>\nRuby has a powerful <tt>%</tt> operator that can format strings in various\
    \ ways.\nIt has three different kinds of format strings, <tt>%</tt>\n<tt>%s</tt>\
    \ <tt>%x</tt> <tt>%d</tt> and <tt>%q</tt>.\n<tt>%</tt> <tt>%s</tt> <tt>%x</tt>\
    \ <tt>%d</tt> and <tt>%q</tt> are all equivalent, but\nwith different semantics.\n\
    </p>\n<p>\n<tt>%</tt> <tt>%s</tt> <tt>%x</tt> <tt>%d</tt> <tt>%q</tt> format strings\
    \ all have three special modifiers:\n<tt>%</tt> <tt>%s</tt> <tt>%x</tt> <tt>%d</tt>\
    \ <tt>%q</tt> <tt>%</tt>\n<tt>%s</tt> <tt>%x</tt> <tt>%d</tt> <tt>%q</tt> <tt>%</tt>\
    \ <tt>%s</tt> <tt>%x</tt> <tt>%d</tt> <tt>%q</tt> <tt>%</tt>\n<tt>%s</tt> <tt>%x</tt>\
    \ <tt>%d</tt> <tt>%q</tt> <tt>%</tt> <tt>%s</tt> <tt>%x</tt> <tt>%d</tt> <tt>%q</tt>\
    \ <tt>%s</tt> <tt>%x</tt> <tt>%d</tt> <tt>%q</tt> <tt>%</tt>\n<tt>%s</tt> <tt>%x</tt>\
    \ <tt>%d</tt> <tt>%q</tt> <tt>%</tt> <tt>%s</tt> <tt>%x</tt> <tt>%d</tt> <tt>%q</tt>\
    \ <tt>%s</tt> <tt>%x</tt> <tt>%d</tt> <tt>%q</tt> <tt>%s</tt>\n<tt>%x</tt> <tt>%d</tt>\
    \ <tt>%q</tt> <tt>%</tt> <tt>%s</tt> <tt>%x</tt> <tt>%d</tt> <tt>%q</tt> <tt>%s</tt>\
    \ <tt>%x</tt> <tt>%d</tt> <tt>%q</tt> <tt>%s</tt> <tt>%x</tt> <tt>%d</tt> <tt>%q</tt>\
    \ <tt>%s</tt>\n<tt>%x</tt> <tt>%d</tt> <tt>%q</tt> <tt>%</tt> <tt>%s</tt> <tt>%x</tt>\
    \ <tt>%d</tt> <tt>%q</tt> <tt>%s</tt> ", "  string.downcase!\n  string\nend",
  "  string.downcase!\n  string.upcase!\n  string\nend", "  # Convert string to array\n\
    \  array = string.split(//)\n  # Flip elements in the array\n  array.map! do |element|\n\
    \    case element\n    when 'a'\n      'A'\n    when 'B'\n      'b'\n    when\
    \ 'C'\n      'C'\n    when 'D'\n      'd'\n    when 'E'\n      'e'\n    when 'F'\n\
    \      'f'\n    when 'G'\n      'g'\n    when 'H'\n      'h'\n    when 'I'\n \
    \     'I'\n    when 'J'\n      'j'\n    when 'K'\n      'k'\n    when 'L'\n  \
    \    'L'\n    when 'M'\n      'm'\n    when 'N'\n      'n'\n    when 'O'\n   \
    \   'O'\n    when 'P'\n      'p'\n    when 'Q'\n      'Q'\n    when 'R'\n    \
    \  'r'\n    when 'S'\n      's'\n    when 'T'\n      't'\n    when 'U'\n     \
    \ 'U'\n    when 'V'\n      'v'\n    when 'W'\n      'w'\n    when 'X'\n      'X'\n\
    \    when 'Y'\n      'y'\n    when 'Z'\n      'z'\n    when 'a'\n      'A'\n \
    \   when 'b'\n      'B'\n    when 'c'\n      'C'\n    when 'd'\n      'D'\n  \
    \  when 'e'\n      'E'\n    when 'f'\n      'F'\n    when 'g'\n      'G'\n   \
    \ when 'h'\n      'H'\n    when 'i'\n      'I'\n    when 'j'\n      'J'\n    when\
    \ 'k'\n      'K'\n    when 'l'\n      'L'\n    when 'm'\n      'M'\n    when 'n'\n\
    \      'N'\n    when 'o'\n      'O'\n    when 'p'\n      'P'\n    when 'q'\n \
    \     'Q'\n    when 'r'\n      'R'\n    when 's'\n      'S'\n    when 't'\n  \
    \    'T'\n    when 'u'\n      'U'\n    when 'v'\n      'V'\n    when 'w'\n   \
    \   'W'\n    when 'x'\n      'X'\n    when 'y'\n      '", "  string.gsub!(/./)\
    \ do |char|\n    case char\n    when \"a\"\n      \"A\"\n    when \"b\"\n    \
    \  \"B\"\n    when \"c\"\n      \"C\"\n    when \"d\"\n      \"D\"\n    when \"\
    e\"\n      \"E\"\n    when \"f\"\n      \"F\"\n    when \"g\"\n      \"G\"\n \
    \   when \"h\"\n      \"H\"\n    when \"i\"\n      \"I\"\n    when \"j\"\n   \
    \   \"J\"\n    when \"k\"\n      \"K\"\n    when \"l\"\n      \"L\"\n    when\
    \ \"m\"\n      \"M\"\n    when \"n\"\n      \"N\"\n    when \"o\"\n      \"O\"\
    \n    when \"p\"\n      \"P\"\n    when \"q\"\n      \"Q\"\n    when \"r\"\n \
    \     \"R\"\n    when \"s\"\n      \"S\"\n    when \"t\"\n      \"T\"\n    when\
    \ \"u\"\n      \"U\"\n    when \"v\"\n      \"V\"\n    when \"w\"\n      \"W\"\
    \n    when \"x\"\n      \"X\"\n    when \"y\"\n      \"Y\"\n    when \"z\"\n \
    \     \"Z\"\n    else\n      char\n    end\n  end\nend", "  string.downcase!\n\
    \  string.upcase!\n  string\nend\n</code>\n<|/ a dscore=5 tags=ruby |>\n<| c |>\n\
    This is a good solution, but I'd rather not have to define a new class just for\
    \ that.\n<|/ c |>\n<| c |>\nThat is a good point. I added a more \"pure\" ruby\
    \ solution to my answer.\n<|/ c |>\n<| c |>\nI think `string.upcase!` is better\
    \ for this purpose.\n<|/ c |>\n<| c |>\nstring.upcase! will change `Hello` to\
    \ `hELLO`, which is not what is wanted.\n<|/ c |>\n<| c |>\n`string.upcase!` won't\
    \ change the string, but will return a new string with the first letter capitalised.\
    \ You can check this with `p \"Hello\".upcase!` which will print `\"hELLO\"`\n\
    <|/ c |>\n<| a dscore=5 |>\nIn case anyone is interested in the method I used:\n\
    <code>", "  string.gsub(/./) do |char|\n    char.upcase == char ? char.downcase\
    \ : char\n  end\nend", "  return string.gsub(/([a-z])/) { $1.upcase + $1.downcase\
    \ }\nend", "  string.downcase!\n  string.upcase!\n  string\nend", "  string.downcase!\n\
    \  string.upcase!\n  string\nend", "  string.downcase!\nend", "  string.downcase!\n\
    \  string.upcase!\n  string\nend\n</code>\nTo flip all uppercase characters to\
    \ lowercase and vice versa:\n<code>", "    string.downcase!\n    string.upcase!\n\
    end", "  string.downcase! unless string.length <= 1\n  string.gsub(/./) { |c|\
    \ c.upcase }\nend", "  string.downcase!\n  string.upcase!\n  string\nend\n</code>\n\
    Finally, we can put it all together in a Rails console like this:\n<code>\nirb(main):015:0>\
    \ flip_case(\"Hello World!!! 123 !@#$%^&*()-=_+{}[]|\\;<>.,/?\")\n=> \"hELLO wORLD!!!\
    \ 123 !@#$%^&*()-=_+{}[]|\\;<>.,/?\"\n</code>\n<|/ a dscore=5 |>\n<| c |>\nIt's\
    \ a good idea, but it seems that Ruby has [a method to do this](http://www.ruby-doc.org/core-2.0.0/String.html#method-i-tr).\n\
    <|/ c |>\n<| c |>\nThanks for your answer. My intention is to implement it as\
    \ a gem and i didn't want to add another dependency to my ruby installation. The\
    \ accepted solution using String#tr is more elegant.\n<|/ c |>\n<| c |>\nThe tr!\
    \ method is available only in 2.3 but you can use the tr method if you install\
    \ the ruby-2.3 gem and require it.\n<|/ c |>\n<| c |>\nIt doesn't work if you\
    \ use symbols such as :lowercase or :uppercase to refer to method names.\n<|/\
    \ c |>\n<| c |>\nIf you're using Ruby 2.3, you can use `tr` instead of `tr!` so\
    \ you don't need to require `ruby-2.3`.\n<|/ c |>\n<| a tags=ruby |>\nUse a gem\
    \ like 'rails-transliterate'\n<code>\nrequire 'rails-transliterate'", "  string.downcase!\n\
    end\n</pre>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
