name: HumanEval_46_fib4
language: rb
prompt: "# The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece\
  \ that's defined as follows:\n# fib4(0) -> 0\n# fib4(1) -> 0\n# fib4(2) -> 2\n#\
  \ fib4(3) -> 0\n# fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n# Please\
  \ write a function to efficiently compute the n-th element of the fib4 number sequence.\
  \  Do not use recursion.\n# >>> fib4.call(5)\n# 4\n# >>> fib4.call(6)\n# 8\n# >>>\
  \ fib4.call(7)\n# 14\ndef fib4(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fib4\n\
  \    candidate = method(:fib4)\n    assert_equal(4, candidate.call(5))\n    assert_equal(28,\
  \ candidate.call(8))\n    assert_equal(104, candidate.call(10))\n    assert_equal(386,\
  \ candidate.call(12))\n  end\nend\n"
completions: ["  # Your code here\n  if n == 0\n    0\n  elsif n == 1\n    0\n  elsif\
    \ n == 2\n    2\n  elsif n == 3\n    0\n  else\n    fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4) \nend", "    fib4.n\nend\nfib4.n = 0\nfib4.call(n) # => 0\nfib4.n\
    \ = 1\nfib4.call(n) # => 0\nfib4.n = 2\nfib4.call(n) # => 2\nfib4.n = 3\nfib4.call(n)\
    \ # => 0\nfib4.n = 4\nfib4.call(n) # => 4", "  fib4.fib_cache = {}\n  if fib4.fib_cache.has_key?(n)\n\
    \    return fib4.fib_cache[n]\n  fib_n = 0\n  fib_n1 = 1\n  fib_n2 = 1\n  fib_n3\
    \ = 1\n  fib_n4 = 1\n  while n > 0\n     fib_n4 = fib_n3 - fib_n2 + fib_n1\n \
    \    fib_n3 = fib_n2\n     fib_n2 = fib_n1\n     fib_n1 = fib_n\n     fib_n =\
    \ fib_n4\n     fib4.fib_cache[n] = fib_n\n     n -= 1\n  fib4.fib_cache[n] = fib_n\n\
    \  return fib_n\n</cell>\n<cell>", "  fib = Array.new(n) {0}\n  fib[1] = 0\n \
    \ fib[2] = 0\n  fib[3] = 0\n  fib[4] = 0\n  ntimes = 5\n  while (ntimes > 0)\n\
    \    fib.push((fib[n-1] + fib[n-2] + fib[n-3] + fib[n-4]))\n    ntimes -= 1\n\
    \  end\n  return fib[4]\nend", "  fib4 = Array.new(n)\n  fib4[0] = 0\n  fib4[1]\
    \ = 0\n  fib4[2] = 1\n  fib4[3] = 2\n  fib4[4] = fib4[n-2] + fib4[n-3] + fib4[n-4]\n\
    \  return fib4[n]", '    return n', "  if n == 0\n    0\n  elsif n == 1\n    1\n\
    \  elsif n == 2\n    2\n  elsif n == 3\n    0\n  elsif n == 4\n    1\n  elsif\
    \ n == 5\n    2\n  elsif n == 6\n    3\n  elsif n == 7\n    4\n  else\n    fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend\n</cell>\n<code language=julia-1.0>",
  "  if n <= 0\n    0\n  else\n    fib(4 - n) + fib(3 - n) + fib(2 - n) + fib(1 -\
    \ n)\nend", "  return if n == 0 || n == 1\n  fib4.call(n - 1) + fib4.call(n -\
    \ 2) + fib4.call(n - 3) + fib4.call(n - 4)\nend", "  count = 0\n  while n < 0\n\
    \    n -= 1\n    count += 1\n  end\n  count += 1\n  while n < 0\n    n -= 1\n\
    \    count += 1\n  end\n  count += 1\n  while n < 0\n    n -= 1\n    count +=\
    \ 1\n  end\n  count += 1\n  return count\nend", '  return 0 if n == 0 then 0 else
    fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)', "  memo = Array.new(n)\n\
    \  memo[0] = memo[1] = memo[2] = memo[3] = memo[4] = 0\n  (1..n).each do |i|\n\
    \    memo[i] = memo[i-1] + memo[i-2] + memo[i-3] + memo[i-4]\n  end\n  memo[n]\n\
    end", "  (0..n).reduce(&:+) + (0..(n-1)).reduce(&:+).to_a[-1]\nend\n</cell>\n\
    <cell>", "  return 0 if n < 4 then n else fib4(n - 4) + fib4(n - 3) + fib4(n -\
    \ 2) + fib4(n-1)\nend", "  \n  return 0 unless n > 4", "  fib4.n = 0\n  fib4.result\
    \ = [0]\n  (fib4.n += 1) if n <= 0\n  (0..fib4.n-1).each do |i|\n    fib4.result[i]\
    \ = fib4.result[i-1] + fib4.result[i-2] + fib4.result[i-3] + (fib4.result[i-4])\n\
    \  end\n  return fib4.result[n]\nend", "  return 0 if n == 0 or n == 1 else fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend\n</cell>\n<code language=julia-1.1>\n\
    @time fib4.call(7)\n</cell>\n<text>\nExercise 5.3\nPlease write a function to\
    \ compute the factorial of a given number without using the factorial function.",
  "  n.downto(1) { |i| return fib4(i + 1).call(n - i) }\nend\n</cell>\n<cell>", " \
    \ if n == 0\n    0\n  elsif n == 1\n    0\n  elsif n == 2\n    2\n  elsif n ==\
    \ 3\n    0\n  elsif n == 4\n    4\n  else\n    fib4.call(n - 1) + fib4.call(n\
    \ - 2) + fib4.call(n - 3) + fib4.call(n - 4)\n  end\nend\n</cell>\n<code language=julia-0.6>",
  "  return (n==0)? 0:(n==1)? 0:(n==2)? 2:fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n\
    end", "  1.upto(n) do |x|\n    x += 1 unless x == n\n    x - 2 unless x == n\n\
    \  end\nend", "  n = 0 if n < 0 else n\n  if n < 4\n    fib4(n)\n  else\n    fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n  end\nend", "  # Your code here.\n  return\
    \ n if n < 3 else fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\nend",
  "  n\nend\nfib4.call(5)\nfib4.call(6)\nfib4.call(7)\nfib4.call(8)", "\tn0 = n /\
    \ 5\n\tn1 = n0 - 1\n\tn2 = n1 - 1\n\tn3 = n2 - 1\n\tn4 = n3 - 1\n\t\n\tfib4 =\
    \ n4\n\t\n\treturn fib4", "  fib4.call(n).call(n)\nend\nfib4.to_proc", "  return\n\
    end", "  n = n-1\n  fib4 = (n-1) if (n >= 0) and (n<4) else 0\n  fib4 += (n-2)\
    \ if fib4 > 0 and n < 4 else 0\n  fib4 += (n-3) if fib4 > 0 and n < 4 else 0\n\
    \  fib4 += (n-4) if fib4 > 0 and n < 4 else 0\n  fib4 += (n-5) if fib4 > 0 and\
    \ n < 4 else 0\n  fib4 += (n-6) if fib4 > 0 and n < 4 else 0\n  fib4 += (n-7)\
    \ if fib4 > 0 and n < 4 else 0\n  fib4 += (n-8) if fib4 > 0 and n < 4 else 0\n\
    \  fib4 += (n-9) if fib4 > 0 and n < 4 else 0\n  fib4 += (n-10) if fib4 > 0 and\
    \ n < 4 else 0\n  fib4 += (n-11) if fib4 > 0 and n < 4 else 0\n  fib4 += (n-12)\
    \ if fib4 > 0 and n < 4 else 0\n  fib4 += (n-13) if fib4 > 0 and n < 4 else 0\n\
    \  fib4 += (n-14) if fib4 > 0 and n < 4 else 0\n  fib4 += (n-15) if fib4 > 0 and\
    \ n < 4 else 0\n  fib4 += (n-16) if fib4 > 0 and n < 4 else 0\n  fib4 += (n-17)\
    \ if fib4 > 0 and n < 4 else 0\n  fib4 += (n-18) if fib4 > 0 and n < 4 else 0\n\
    \  fib4 += (n-19) if fib4 > 0 and n < 4 else 0\n  fib4 += (n-20) if fib4 > 0 and\
    \ n < 4 else 0\n  fib4 += (n-21) if fib4 > 0 and n < 4 else 0\n  fib4 += (n-22)\
    \ if fib4 > 0 and n < 4 else 0\n  fib4 += (n-23) if fib4 > 0 and n < 4 else 0\n\
    \  fib4 += (n-24) if fib4 > 0 and n < 4 else 0\n  fib4 += (n-25) if fib4 > 0 and\
    \ n < 4 else 0\n  fib4 += (n-26) if fib4 > 0 and n < 4 else 0\n  fib4 += (n-27)\
    \ if fib4 > 0 and n < 4 else 0\n  fib4 += (n-28) if fib4 > 0 and n < 4 else 0\n\
    \  fib4 += (n-29) if fib4 > 0 and n < 4 else 0\n  fib4 += (n-30) if fib4 > 0 and\
    \ n < 4 else 0\n  fib4 += (n-31) if fib4 > 0 and n < 4 else 0\n", "  fib4n.call(n,\
    \ 0)\nend", "  return 0 if n == 4 then 0 else if n == 5 then 0 else fib4(n - 1)\
    \ + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\nend", '  return n if n <= 4 && n
    == fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4) else 0', "  fib_4 = 0.0\n\
    \  fib4_n = 0.0\n  while fib4_n <= n\n    fib4_n = fib4_n + 1\n    fib_4 = fib_4\
    \ + fib4_n\n  end\n  fib4_n\nend", "  if n < 1 then return 0\n  if n == 1 then\
    \ return 0\n  if n == 2 then return 2\n  if n == 3 then return 0\n  fib4.helper(n-1,\
    \ fib4(n-2) + fib4(n-3) + fib4(n-4))\nend\nfib4.helper(1, 0)\nfib4.helper(2, 0)\n\
    fib4.helper(3, 0)\nfib4.helper(4, 0)\nfib4.helper(5, 2)\nfib4.helper(6, 8)\nfib4.helper(7,\
    \ 14)\nfib4.helper(8, 28)\nfib4.helper(9, 55)\nfib4.helper(10, 153)\nfib4.helper(11,\
    \ 434)\nfib4.helper(12, 1384)\nfib4.helper(13, 2226)\nfib4.helper(14, 8757)\n\
    fib4.helper(15, 36861)\nfib4.helper(16, 148024)\nfib4.helper(17, 427859)\nfib4.helper(18,\
    \ 139961)\nfib4.helper(19, 221704)\nfib4.helper(20, 88825)\nfib4.helper(21, 370284)\n\
    fib4.helper(22, 147161)\nfib4.helper(23, 429844)\nfib4.helper(24, 149749)\nfib4.helper(25,\
    \ 434841)\nfib4.helper(26, 152797)\nfib4.helper(27, 439444)\nfib4.helper(28, 155465)\n\
    fib4.helper(29, 440425)\nfib4.helper(30, 156715)\nfib4.helper(31, 441964)\nfib4.helper(32,\
    \ 158057)\nfib4.helper(33, 443228)\nfib4.helper(34, 159287)\nfib4.helper(35, 444175)\n\
    fib4.helper(36, 159925)\nfib4.helper(37, 444678)\nfib4.helper(38, 160976)\nfib4.helper(39,\
    \ 444841)\nfib4.helper(40, 162209)\nfib4.helper(41, 444994)\nfib4.helper(42, 163466)\n\
    fib4.helper(43, 445238)\nfib4.helper(44, 165145)\nfib4.helper(45, 445461)\nfib4.helper(46,\
    \ 166615)\nfib4.helper(47, 445773)\nfib4.helper(48, 167848)\nfib4.helper(49, 446024)\n\
    fib4.helper(50, 168351)\nfib4.helper(51, 446198)\nfib4.", "  Fib4.reset!\n  Fib4.fib4_cache[n-1]\n\
    end", "    if n < 0\n        puts \"fib4(#{n}) expects a positive integer as input\"\
    \n        return nil\n    if n == 0\n        return 0;\n    if n == 1\n      \
    \  return 0;\n    if n == 2\n        return 2;\n    if n == 3\n        return\
    \ 0;\n    if n == 4\n        return 0;\n    fib4 = fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4);\n    return fib4;\nend", "  if n == 0 then 0\n  elsif n == 1 then\
    \ 0\n  elsif n == 2 then 2\n  elsif n == 3 then 0\n  else fib4(n - 4) + fib4(n\
    \ - 3) + fib4(n - 2) + fib4(n - 1)\nend", "  if n == 0\n  0\n  else\n    n+4\n\
    \  end\nend", "  puts \"fib4(#{n})\" if debug\n  Fib4.call(n)\nend\n</code>\n\
    Part 2 of the exercise:\nWrite a function/method fib5 that takes an integer n\
    \ and computes the n-th element of the Fibonacci sequence (fib2).  Don't use recursion.\n\
    <code>", "  fib4.cache ||= []\n  fib4.cache << n\n  fib4.cache.compact.find {|n|\
    \ n == fib4.cache.last + fib4.cache.last}.last\nend", "  if n < 0\n    0\n  elsif\
    \ n == 0\n    1\n  elsif n == 1\n    1\n  elsif n == 2\n    2\n  elsif n == 3\n\
    \    0\n  elsif n == 4\n    4\n  else\n    fib4(n-1) + fib4(n-2) + fib4(n-3) +\
    \ fib4(n-4) + fib4(n-5)\nend\n</cell>\n<cell>", "  n >= 0 ? fib4(n-1) + fib4(n-2)\
    \ + fib4(n-3) + fib4(n-4) : 0\nend", "  case n < 0\n  when true\n    Fib4.call(4*n+4)\n\
    \  when false\n    Fib4.call(4*n+8)\n  end\nend\n</code>\n<|/ q dscore=2 |>\n\
    <| a tags=ruby |>\nRuby doesn't really have the concept of tail recursion, so\
    \ that's not going to work.  You'll need to use a while loop instead.\n<code>",
  "  # Answer begins with a base case, then a recursive call.\n  case n when n < 1\
    \ then 0 \n\twhen n == 1 then 0\n\twhen n == 2 then 2\n\twhen n == 3 then 0\n\t\
    else fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4) end\nend\n</cell>\n<text>\n\
    Exercise 3 - Write a recursive function\nThe Fibonacci series can be computed\
    \ recursively as follows:", "  fib4.cache[n] ||= (n<2 ? 0 : (fib4.cache[n-2] +\n\
    \                                 fib4.cache[n-1] + fib4.cache[n-3] +\n      \
    \                           fib4.cache[n-4]))\n  fib4.cache[n]\nend", "  fib4.result\
    \ = Fib4.result || 0\n  fib4.result = fib4.result + fib4.result if n <= 0 else\
    \ fib4.result + fib4.result + fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4) if\
    \ n > 0 \n  fib4.result\nend", "    fib4 = [0]\n    if n<4\n        fib4[0] =\
    \ 0\n        fib4[1] = 0\n        fib4[2] = 0\n        fib4[3] = 0\n        fib4[n]\
    \ = fib4[n-1] + fib4[n-2] + fib4[n-3] + fib4[n-4]\n    else\n        fib4[n] =\
    \ fib4[n-1] + fib4[n-2] + fib4[n-3] + fib4[n-4]\n    end\n    return fib4[n]\n\
    end", "  return 0 if (n<0) || n==0\n  return fib4.call(Fib4.call(Fib4.call(Fib4.call(Fib4.call(n-1)))\
    \ + Fib4.call(Fib4.call(n-2)) + Fib4.call(Fib4.call(n-3)) + Fib4.call(Fib4.call(n-4))))\n\
    end", "  return 0 if n < 3 then n else fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    end", "  1.upto(5).inject(0) do |fib4a,n|\n    if n==0\n      fib4a\n    else\n\
    \      fib4a + fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    end\n  end\n\
    end", "  if n == 0 then return 0\n  if n == 1 then return 0\n  if n == 2 then\
    \ return 2\n  if n == 3 then return 0\n  if n == 4 then return 1\n  \n  if n >\
    \ 4 then return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n  \n  return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend\n</cell>\n<code language=julia-1.0>",
  "  n = n.to_i\n  return n if n <= 5 || n >= 11 end\n  fib4 = n.to_i\n  while fib4\
    \ > 0\n    fib4 = (fib4 - 4 * (n-4) + 2) % 12\n    n -= 1\n  end\n  return fib4\n\
    end", "    if n == 0\n        0\n    elsif n == 1\n        0\n    elsif n == 2\n\
    \        2\n    elsif n == 3\n        0\n    elsif n == 4\n        8\n    else\n\
    \        fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend", "  begin\n    return\
    \ 0 if n < 3 \n    else fib4(n - 4) + fib4(n - 3) + fib4(n - 2) + fib4(n - 1)\n\
    \  end\nend", "  raise ArgumentError unless n >= 0\n  0 if n == 0 || n == 4 then\
    \ 0 \n  else 2 fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend", "  if n <\
    \ 0\n    raise(ArgumentError)\n  return if n < 0\n  fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\nend", "  case n when 0\n    0 \n  when 1\n    0 \n  when 2\n  \
    \  2 \n  when 3\n    0 \n  else\n    fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\
    \ \nend", "\t\nend", "  if n < 1\n    0\n  elsif n < 4\n    0\n  elsif n < 8\n\
    \    2\n  else\n    fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n  end\nend\n\
    </cell>\n<cell>", "  return 0 if n < 2 then 1 else fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\nend", "  return 0 if n < 4 else fib4(n - 1) + fib4(n - 2) + fib4(n\
    \ - 3) + fib4(n - 4)\nend\n</cell>\n<code language=julia-1.6>", "  # check if\
    \ n <= 0 or n >= 4\n  return fib4.call(n, 1) if n <= 4 else fib4.call(n, 1 + fib4.call(n-1,\
    \ 1) + fib4.call(n-2, 1) + fib4.call(n-3, 1) + fib4.call(n-4, 1))\nend", "  if\
    \ n < 4\n    1\n  else\n    fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).to_s\n\
    end", "  if n<=1\n    0\n  else\n    fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).",
  "\treturn 0 if n == 0 || n == 1 then 0 else fib4(n-1) + fib4(n-2) + fib4(n-3) +\
    \ fib4(n-4)\nend", "  fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend", " \
    \ n = (n-1)\n  return (n + n + n + n + n + n) unless n >= 0\n  1\nend", "  fib4.calls\
    \ ||= 0\n  if n == 0 then Fib4.calls += 1\n  else fib4.calls += 1\n  Fib4.calls\
    \ += 1\n  Fib4.calls += 1\n  Fib4.calls += 1\n  Fib4.calls += 1\n  Fib4.calls\
    \ += 1\n  Fib4.calls += 1\n  Fib4.calls += 1\n  return Fib4.calls\nend\nFib4.calls\
    \ = 0", "  0 until n do\n    fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4) \n  end\n\
    end\n</cell>\n<cell>", "    return n if n < 4 else fib4(n - 4) + fib4(n - 3) +\
    \ fib4(n - 2) + fib4(n - 1)\nend", "  return n if n < 4 then 0 else fib4(n-2)\
    \ + fib4(n-3) + fib4(n-4) end\n  ", "    return 0 if n < 4 else (n if n < 6 else\
    \ fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4))\n    # Please write your\
    \ answer in the block below.\nfib4", "  a = 0\n  b = 1\n  c = 1\n  d = 2\n  e\
    \ = 2\n  while n != 0\n    a+=1\n    b, c, d = c, d, a + b + c + d\n    n -= 1\n\
    \  end\n  e\nend\n</cell>\n<cell>", "  if n < 0 then\n    n\n  else if n = 1 then\n\
    \    0\n  else if n = 2 then\n    1\n  else\n    fib4(n - 1) + fib4(n - 2) + fib4(n\
    \ - 3) + fib4(n - 4)\nend", "  \nend\n</cell>\n<text>\nExercise 3\nRe-implement\
    \ the fib4 function using recursion.  Test your function on values 0 to 10.",
  "\tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\tif fib4.calls == n\n\t\treturn fib4.calls\n\
    \tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\
    \tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\
    \tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\
    \tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\
    \tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\
    \tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\
    \tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\
    \tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\
    \tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\
    \tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\
    \tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\
    \tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\
    \tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\
    \tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\
    \tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\tfib4.calls ||= 0\n\
    \tfib4.calls ", "  return if((n > 4) and (n < 5), (fib4((n-1) + (n-2) + (n-3)\
    \ + (n-4))),\n    if((n > 5) and (n < 6), (fib4((n-1) + (n-2) + (n-3) + (n-4)\
    \ + (n-5))),\n      if((n > 6) and (n < 7), (fib4((n-1) + (n-2) + (n-3) + (n-4)\
    \ + (n-5) + (n-6))),\n        if((n > 7) and (n < 8), (fib4((n-1) + (n-2) + (n-3)\
    \ + (n-4) + (n-5) + (n-6) + (n-7))),\n          if((n > 8) and (n < 9), (fib4((n-1)\
    \ + (n-2) + (n-3) + (n-4) + (n-5) + (n-6) + (n-7) + (n-8))),\n            if((n\
    \ > 9) and (n < 10), (fib4((n-1) + (n-2) + (n-3) + (n-4) + (n-5) + (n-6) + (n-7)\
    \ + (n-8) + (n-9))),\n              if((n > 10) and (n < 11), (fib4((n-1) + (n-2)\
    \ + (n-3) + (n-4) + (n-5) + (n-6) + (n-7) + (n-8) + (n-9) + (n-10))),\n      \
    \          if((n > 11) and (n < 12), (fib4((n-1) + (n-2) + (n-3) + (n-4) + (n-5)\
    \ + (n-6) + (n-7) + (n-8) + (n-9) + (n-10) + (n-11))),\n                  if((n\
    \ > 12) and (n < 13), (fib4((n-1) + (n-2) + (n-3) + (n-4) + (n-5) + (n-6) + (n-7)\
    \ + (n-8) + (n-9) + (n-10) + (n-11) + (n-12))),\n                    if((n > 13)\
    \ and (n < 14), (fib4((n-1) + (n-2) + (n-3) + (n-4) + (n-5) + (n-6) + (n-7) +\
    \ (n-8) + (n-9) + (n-10) + (n-11) + (n-12) + (n-13))),\n                     \
    \ if((n > 14) and (n < 15), (fib4((n-1) + (n-2) + (n-3) + (n-4) + (n-5) + (n-6)\
    \ + (n-7) + (n-8) + (n-9) + (n-10) + (n-11) + (n-12) + (n-13) + (n-14))),\n  \
    \                      if((n > 15) and (n < 16), (fib4((n-1) + (n-2) + (n-3) +\
    \ (n-4) + (n-5) + (n-6) + (n-7) + (n-8) + (n-9) + (n-10) + (n-11) + (n-12) + (n-13)\
    \ + (n-14) + (n-15)))\n                      end\n                    end\n  \
    \                end", "  if n < 0\n    raise(\"fib4 requires an integer greater\
    \ than or equal to 0\")\n  elsif n == 0\n    return 0\n  elsif n == 1\n    return\
    \ 0\n  elsif n == 2\n    return 2\n  elsif n == 3\n    return 0\n  elsif n ==\
    \ 4\n    return 0\n  else\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4) ",
  "\tif n == 0\n\t\t0\n\telsif n == 1\n\t\t0\n\telsif n == 2\n\t\t2\n\telsif n ==\
    \ 3\n\t\t0\n\telse\n\t\tfib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)", "  if\
    \ n==0\n    0\n  elsif n==1\n    1\n  elsif n==2\n    2\n  elsif n==3\n    0\n\
    \  elsif n==4\n    4\n  elsif n>4\n    fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    \  end\nend\n</cell>\n<text>\nExercise 2\nWrite a function to check whether a\
    \ given number is prime.  A prime number is a positive integer that is greater\
    \ than 1 that has no positive divisors other than 1 and itself.  You may use the\
    \ following property of prime numbers: $p \\in \\mathbb{N}_2 \\times \\mathbb{N}_2\
    \ \\times \\mathbb{N}_2 \\times \\mathbb{N}_2$ where $\\mathbb{N}_2$ is the set\
    \ of all positive integers less than or equal to $p$.\nFor a given number, say\
    \ $p$, we define $\\mathbb{N}_2$ as the set of all integers less than or equal\
    \ to $p$.\nWe can write $\\mathbb{N}_2 = {p \\mid p > 1}$.\nA prime number is\
    \ one that is greater than 1 that has no positive divisors other than 1 and itself.\n\
    For example, 5 is a prime number.  Note that 5 is itself a prime number!\nWrite\
    \ a function that determines whether the number is prime or composite:", "  fib4.cache[n,\
    \ 4] ||= fib4.cache[n, 4] = fib4.fib(n-1) + fib4.fib(n-2) + fib4.fib(n-3) + fib4.fib(n-4)\n\
    \  fib4.cache[n, 4]\nend", "  (n<=0)? nil\n  : fib4(n-2) + fib4(n-3) + fib4(n-4)\
    \ + fib4(n-5)\nend", "  0\nend\n  ", "  n\nend\n</cell>\n<text>\nTo test your\
    \ function, run the cell below.  If the expected result does not match the output,\
    \ then you did a good job!", "  # Your code here\n  ans = 0\n  for n in range(n):\n\
    \    ans += (n-1) * fib3(n-1) + fib3(n-2) + fib3(n-3) + fib3(n-4)\n  return ans\n\
    end", "  return 0 if n == 0 else 1 if n == 1 then 2 else fib4(n - 1) + fib4(n\
    \ - 2) + fib4(n - 3) + fib4(n - 4)\nend", "  fib4(n-1)+fib4(n-2)+fib4(n-3)+fib4(n-4)\n\
    end", "\tif n==0\n\t\t0\n\telsif n==1\n\t\t0\n\telsif n==2\n\t\t2\n\telsif n==3\n\
    \t\t0\n\telsif n==4\n\t\t4\n\telsif n>4\n\t\tfib4(4-n)+fib4(4-(n-1))+fib4(4-(n-2))+fib4(4-(n-3))+fib4(4-(n-4))\n\
    \tend\nend", "  if n < 0\n  then raise ArgumentError\n  else if n == 0\n  then\
    \ 0\n  else if n == 1\n  then 1\n  else fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\
    \ end\nend", "  fib4_sum = @memoize0 do |_fib4, _|\n    _fib4_sum = @memoize0\
    \ do |_fib4, _|\n      fib4_sum = _fib4[0] + _fib4[1] + _fib4[2] + _fib4[3] +\
    \ _fib4[4]\n    end\n    _fib4_sum\n  end\n  fib4_sum[n]\nend", "  if n == 0\n\
    \    0\n  elsif n == 1\n    1\n  elsif n == 2\n    2\n  elsif n == 3\n    0\n\
    \  elsif n == 4\n    fib4.call(n - 1) + fib4.call(n - 2) + fib4.call(n - 3) +\
    \ fib4.call(n - 4)\n  else\n    fib4.call(n - 1) + fib4.call(n - 2) + fib4.call(n\
    \ - 3) + fib4.call(n - 4)\nend", "  return n if n < 4 ? n : fib4(n - 4) + fib4(n\
    \ - 3) + fib4(n - 2) + fib4(n - 1)\nend\n</pre>\n<p>\nRuby supports some nice\
    \ patterns such as method chaining when you need to return a new object, but they\
    \ can be difficult to get working in situations like recursive functions where\
    \ you might need to use an accumulator variable.\n</p>\n<pre>", "  return fib4.call(n,0,1)\
    \ + (fib4.call(n,0,1) + (fib4.call(n,0,1) + (fib4.call(n,0,1))))\nend", "  if\
    \ n == 0 then 0\n  elif n == 1 then 0\n  elif n == 2 then 2\n  elif n == 3 then\
    \ 0\n  else fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4) end\nend", "  return\
    \ 0 if n==0 else fib4.call(n-1) + fib4.call(n-2) + fib4.call(n-3) + fib4.call(n-4)\n\
    end", "  if n == 0\n    0\n  elsif n == 1\n    1\n  elsif n == 2\n    2\n  elsif\
    \ n == 3\n    0\n  else\n    fib4.call(n-1) + fib4.call(n-2) + fib4.call(n-3)\
    \ + fib4.call(n-4)\nend", "  raise \"Not implemented\"\nend\n</code></pre>", " \
    \ fib = 0.0\n  if n == 0\n    fib = 0\n  elsif n == 1\n    fib = 1\n  elsif n\
    \ == 2\n    fib = 2\n  elsif n == 3\n    fib = 3\n  elsif n == 4\n    fib = 5\n\
    \  elsif n == 5\n    fib = 3\n  elsif n == 6\n    fib = 5\n  elsif n == 7\n  \
    \  fib = 3\n  elsif n == 8\n    fib = 7\n  elsif n == 9\n    fib = 5\n  elsif\
    \ n == 10\n    fib = 13\n  elsif n == 11\n    fib = 3\n  elsif n == 12\n    fib\
    \ = 7\n  elsif n == 13\n    fib = 11\n  elsif n == 14\n    fib = 11\n  elsif n\
    \ == 15\n    fib = 13\n  elsif n == 16\n    fib = 1\n  elsif n == 17\n    fib\
    \ = 5\n  elsif n == 18\n    fib = 3\n  elsif n == 19\n    fib = 7\n  elsif n ==\
    \ 20\n    fib = 11\n  elsif n == 21\n    fib = 1\n  elsif n == 22\n    fib = 5\n\
    \  elsif n == 23\n    fib = 3\n  elsif n == 24\n    fib = 7\n  elsif n == 25\n\
    \    fib = 11\n  elsif n == 26\n    fib = 1\n  elsif n == 27\n    fib = 5\n  elsif\
    \ n == 28\n    fib = 3\n  elsif n == 29\n    fib = 7\n  elsif n == 30\n    fib\
    \ = 11\n  elsif n == 31\n    fib = 1\n  elsif n == 32\n    fib = 5\n  elsif n\
    \ == 33\n    fib = 3\n  elsif n == 34\n    fib = 7\n  elsif n == 35\n    fib =\
    \ 11\n  elsif n == 36\n    fib = 1\n  elsif n == 37\n    fib = 5\n  elsif n ==\
    \ 38\n    fib = 3\n  elsif n == 39\n    fib = 7\n  elsif n == 40\n    fib = 11\n\
    \  elsif n == 41\n    fib = 1\n  elsif n == 42\n    fib = 5\n  elsif n == 43\n\
    \    fib = 3\n  elsif n == 44\n    fib = 7\n  elsif n == 45\n    fib = 11\n  elsi",
  "  if n == 0\n    0\n  else if n == 1\n    0\n  else if n == 2\n    2\n  else if\
    \ n == 3\n    0\n  else\n    fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend",
  "  if n < 0 || n > 4 then nil\n  else\n    Fib4.call(n)\n  end\nend", "  begin\n\
    \    if n == 0\n      0\n    elsif n == 1\n      0\n    elsif n == 2\n      2\n\
    \    elsif n == 3\n      0\n    elsif n == 4\n      4\n    else\n      fib4.call(n\
    \ - 1) + fib4.call(n - 2) + fib4.call(n - 3) + fib4.call(n - 4)\n  end\nend",
  "    fib4 = 0\n    if n == 0\n        fib4 = 0\n        return fib4\n    elif n\
    \ == 1\n        fib4 = 0\n        return fib4\n    elif n == 2\n        fib4 =\
    \ 2\n        return fib4\n    elif n == 3\n        fib4 = 0\n        return fib4\n\
    \    else:\n        fib4 = fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n   \
    \     return fib4", "  n<=0 return 0\n  n>=1 return 1\n  n>=2 return 2\n  n>=3\
    \ return 0\n  n>=4 return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  n>=5\
    \ return fib4(n-4) + fib4(n-3) + fib4(n-2) + fib4(n-1).\n  n>=6 return fib4(n-3)\
    \ + fib4(n-2) + fib4(n-1) + fib4(0).\n  n>=7 return fib4(n-2) + fib4(n-1) + fib4(0)\
    \ + fib4(1).", "  result = 0\n  if n == 0 then return 0\n  if n == 1 then return\
    \ 1\n  result = fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n  return\
    \ result\nend", "  \n  # Your code here\n  return n if n < 4 then 0 else fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend\n</cell>\n<text>\nTask 4: Fibbonaci\
    \ Sequence in Ruby\nHere are some Ruby exercises to help you get acquainted with\
    \ Ruby.  Please read these chapters thoroughly so you can get a full understanding\
    \ of Ruby syntax, and understand why you need to know it to be successful in solving\
    \ your problems.", "  p n\n  s = 0\n  if n > 0\n    s = fib4(n - 1) + fib4(n -\
    \ 2) + fib4(n - 3) + fib4(n - 4)\n  end\n  p s\n  s\nend", "  memo = {}\n  case\
    \ n\n  when 0,1 then 0\n  when 2,3 then 0\n  else memo[n] = fib4(n-1) + fib4(n-2)\
    \ + fib4(n-3) + fib4(n-4) end\n  memo[n]\nend\n</code>\nThe other function fib3\
    \ is basically the same as the fib4 function - except for no memoization is used,\
    \ and no base case is used. The key difference is that fib3 takes three parameters:\
    \ the nth term and two functions to compute the previous and next terms. For example,\
    \ fib3(5) evaluates to fib4(4) + fib4(3) and fib3(6) evaluates to fib4(7) + fib4(6)\
    \ and fib3(7) evaluates to fib4(8) + fib4(7). Using a memoization table, the function\
    \ is reusable and can be applied to any number:\n<code>", "  if n < 0\n    n =\
    \ 0\n  else\n    n = fib4.call(n - 1) + fib4.call(n - 2) + fib4.call(n - 3) +\
    \ fib4.call(n - 4)\n  return n", "  return n if n == 0 || n == 4 else fib4(n -\
    \ 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\nend", "  case n\n  when 0 then\
    \ 0\n  when 1 then 0\n  when 2 then 2\n  when 3 then 0\n  when n then fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n  end\nend", "  return fib4(n-1) + fib4(n-2)\
    \ + fib4(n-3) + fib4(n-4)\nend", "  fib4 = 0\n  fib4 += 1 if n < 2 \n  fib4 +=\
    \ 1 if n < 3 \n  fib4 += 1 if n < 4\n  fib4 += 1 if n < 5\n  fib4 += 1 if n <\
    \ 6\n  fib4 += 1 if n < 7\n  return fib4", "  case n\n  when 0\n    0\n  when\
    \ 1\n    1\n  when 2\n    2\n  when 3\n    0\n  else\n    (fib4.call(n-1) + fib4.call(n-2)\
    \ + fib4.call(n-3) + fib4.call(n-4))\n  end\nend", "  n < 0 ? 0 : (n < 4 ? n :\
    \ fib4(n - 4) + fib4(n - 3) + fib4(n - 2))\nend", "  if n < 4\n    0\n  elsif\
    \ n == 4\n    1\n  elsif n == 1\n    2\n  elsif n == 2\n    1\n  elsif n == 3\n\
    \    1\n  else\n    fib4(n-2) + fib4(n-3) + fib4(n-4) + fib4(n-5)\nend", "  fib4\
    \ = Array.new(n){ |i| fib4(i - 1) + fib4(i - 2) + fib4(i - 3) + fib4(i - 4) }\n\
    \  fib4[n]\nend\n</pre>\n          </section>\n          <section>\n         \
    \   <h2>The Fibonacci number sequence</h2>\n            <p>The Fibonacci sequence\
    \ is defined by the following relations:</p>\n            <ul>\n             \
    \ <li>fib(n) = fib(n-1) + fib(n-2) for all n&gt;0</li>\n              <li>fib(0)\
    \ = 0, fib(1) = 1</li>\n            </ul>\n            <p>For example, the fibonacci\
    \ sequence is defined by:</p>\n            <pre>fib(0) = 0\nfib(1) = 1\nfib(n)\
    \ = fib(n-1) + fib(n-2) for all n&gt;0</pre>\n          </section>\n         \
    \ <section>\n            <h3>Fibonacci sequences grow exponentially</h3>\n   \
    \         <p>The Fibonacci sequence grows exponentially because each term is calculated\
    \ as:</p>\n            <pre>fib(n) = fib(n-1) + fib(n-2)</pre>\n            <p>To\
    \ calculate the nth Fibonacci number you need to do 2n multiplications.</p>\n\
    \            <pre>fib(0) = 0\nfib(1) = 1\nfib(2) = 2\nfib(3) = 3\nfib(4) = 5\n\
    fib(5) = 8\nfib(6) = 13\nfib(7) = 21\nfib(8) = 34</pre>\n            <p>This grows\
    \ exponentially.  To compute the first n Fibonacci numbers, you need to do 2n\
    \ multiplications, where n is between 0 and 8.  That's 9 multiplications for Fibonacci\
    \ numbers up to 8.</p>\n          </section>\n          <section>\n          \
    \  <h3>Fibonacci sequences grow exponentially but do not use recursion</h3>\n\
    \            <p>To calculate each Fibonacci number you need to do 2 multiplications,\
    \ where n is between 0 and 8.  That's 9 multiplications for Fibonacci numbers\
    \ up to 8.</p>\n            <pre>fib0(0) = 0\nfib0(1) = 1\nfib0(2) = 2\nfib0(3)\
    \ = 3\nfib0(4) = 5\nfib0(5) = 8\nfib0(6) = 13\nfib0(7) = 21\nfib0(8) = 34</pre>\n\
    \            <p>To compute the first n Fibonacci numbers, you need to do 2n multiplications,\
    \ where n is between 0 and 8.  That's 9 multiplications for Fibonacci numbers\
    \ up to 8.</p>\n          </section>\n          <section>\n            <h2>An\
    \ algorithm to find the Fibonacci number</h2>\n            <p>An algorithm to\
    \ find the Fi", "  case n of\n    0 | 1 | 2 | 3 | n => n\n    n -> fib4(n - 4)\
    \ + fib4(n - 3) + fib4(n - 2) + fib4(n - 1)\n  end\nend", "  n < 0 ? 0 : 1\n \
    \ fib4.to_s.call(n - 4) + fib4.to_s.call(n - 3) + fib4.to_s.call(n - 2) + fib4.to_s.call(n\
    \ - 1)\nend", "  if n <= 0\n    0\n  elsif n == 1\n    1\n  elsif n == 2\n   \
    \ 2\n  elsif n == 3\n    0\n  elsif n == 4\n    1\n  else\n    fib4(n-1) + fib4(n-2)\
    \ + fib4(n-3) + fib4(n-4).", "  1.upto(n) {|i| return 0 if i > n then return n\
    \ else return fib.call(n - 1) + fib.call(n - 2) + fib.call(n - 3) + fib.call(n\
    \ - 4)}\nend", "    if n <= 0\n\t0\n    else\n\tfib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)", "\tn= n.to_i\n\ti = 1\n\tfib4 = 0\n\twhile i <= n\n\t\tfib4 +=\
    \ i\n\t\ti += 1\n\tfib4\nend", "\tif n == 0\n\t\t0\n\telsif n == 1\n\t\t0\n\t\
    elsif n == 2\n\t\t2\n\telsif n == 3\n\t\t0\n\telse\n\t\tfib4(n - 1) + fib4(n -\
    \ 2) + fib4(n - 3) + fib4(n - 4)", "  # Your code here.\n  raise NotImplementedError\n\
    end", "  raise 'Not implemented'", "  if n == 0 || n == 1 then\n    return 0\n\
    \  else\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n  end\nend",
  "  fibbonacci = Array.new(n) {|i| 0} \n  fib4 = [fibbonacci[0], fibbonacci[1], fibbonacci[2],\
    \ fibbonacci[3]]\n  fibbonacci[n].each {|a| fib4.push(a+fib4[n-1]+fib4[n-2]+fib4[n-3]+fib4[n-4])}\
    \ \n  return fib4[n]\nend", "  n = n.to_i\n  return 0 if n == 0 || n == 1 else\
    \ fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\nend", "  fibbonacci.call(n)\n\
    end", "  if(n==0)\n    0\n  elsif(n==1)\n    0\n  elsif(n==2)\n    2\n  elsif(n==3)\n\
    \    0\n  elsif(n<0)\n    raise(ArgumentError, \"fib4 argument must be non-negative\"\
    )\n  elsif(n==4)\n    4\n  elsif(n==5)\n    5\n  elsif(n==6)\n    8\n  elsif(n==7)\n\
    \    14\n  elsif(n==8)\n    16\n  elsif(n==9)\n    17\n  elsif(n==10)\n    34\n\
    \  else\n    fibo(n-4) + fibo(n-3) + fibo(n-2) + fibo(n-1)\nend\nfibbonacci =\
    \ Fib4.new()\nfib4.call(10)", "  raise NotImplementedError\nend\n</cell>\n<code\
    \ language=julia-1.6>\nfunction fib4(n)\n  fib4(n-1) + fib4(n-2) + fib4(n-3) +\
    \ fib4(n-4)\nend\n</cell>\n<code language=julia-1.6>\nfib4.call(5)\n</cell>\n\
    <text>\nProblem 5\nThe Fibonacci sequence is defined by the formula:\n$$\nFn =\
    \ \\begin{cases}\n    0 & n = 0 \\\\\n    1 & n = 1 \\\\\n    2 & n = 2 \\\\\n\
    \    1 & n \\geq 2 \\\n\\end{cases}\n$$\nwhere $ n $ can be any non-negative integer.\n\
    The first two terms will be:\n$$\n    F_0 = 0 \\\n    F_1 = 1 \\\n$$\nThe third\
    \ will be:\n$$\nF_{n-1} = Fn - F_{n-2}\n$$\nand the fourth term will be:\n$$\n\
    F_{n-2} = 1\n$$\nWrite a Julia function to compute the n-th element of the Fibonacci\
    \ sequence.  (Use this to practice recursion.)", "  ( n > 1 ) ? fib4(n - 1) +\
    \ fib4(n - 2) + fib4(n - 3) + fib4(n - 4) : n\nend\n</cell>\n<text>\nProblem 3:\
    \ Fibonacci sequence", "  n.times {Fib4.new + Fib4.new}\nend", "  fib4(n-1) +\
    \ fib4(n-2) + fib4(n-3) + fib4(n-4) + fib4(n-5)\nend\n</code>\nAnd one more example\
    \ (which you may find very helpful):\n<code>", "  case n\n    when 0..4 then 0\n\
    \    when 5..9 then 0\n    when 6..13 then 2\n    when 14..21 then 0\n    else\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n  end\nend", "    if n <= 4\n\
    \        return n\n    return fib4(n - 4) + fib4(n - 3) + fib4(n - 2) + fib4(n\
    \ - 1)\nend\n</cell>\n<cell>", "  fib = memoize{n} do\n    if n == 0 || n == 1\
    \ then\n      0\n    elsif n == 2 then\n      1\n    elsif n == 3 then\n     \
    \ 0\n    else\n      fib.call(n - 1) + fib.call(n - 2) + fib.call(n - 3) + fib.call(n\
    \ - 4)\n    end\n  end\nend", "  @assert n < 4\n  n+(n-1)*(n-2)*(n-3)*(n-4)\n\
    end", "\treturn 1 if n < 2 else fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    end", "  n<4? 0: (fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4))\nend\n\
    </code>\nMy first approach was to simply add the fibonacci numbers like so:\n\
    <code>", "  (0..(n+1)).inject(:+)\nend", "  0 if n < 1 then n else fib4.call(n\
    \ - 1) + fib4.call(n - 2) + fib4.call(n - 3) + fib4.call(n - 4)\nend", "\tresult\
    \ = 1\n\ti = 2\n\twhile i < n\n\t\tresult *= i\n\t\ti += 1\n\tresult\nend", " \
    \ fib4_num = (@fib4.to_i - 4) * (@fib4.to_i + 4) / 2\n  return fib4_num + fib4_num.call(n)\
    \ if n > 0 else 0\nend", "  case n\n  when 0 then 0\n  when 1 then 0\n  when 2\
    \ then 2\n  when 3 then 0\n  when n then fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    \  else raise \"fib4 number not implemented for n. n should be 0, 1, 2, 3, or\
    \ 4\"\nend", "  case n when 0..1 then 0\n  when 2..3 then 0\n  else fib4.call(n\
    \ - 1) + fib4.call(n - 2) + fib4.call(n - 3) + fib4.call(n - 4)\nend\n</cell>\n\
    <code language=julia-0.4>", "    \n    if n == 0\n        0\n    elsif n == 1\n\
    \        0\n    elsif n == 2\n        2\n    elsif n == 3\n        0\n    elsif\
    \ n == 4\n        1\n    else\n        fib4(n - 4) + fib4(n - 3) + fib4(n - 2)\
    \ + fib4(n - 1)\n    \nend", "    if n < 0\n        raise ArgumentError, 'fib4\
    \ called with argument %s, but fib4 only accepts positive integers.' % n\n   \
    \ if n == 0\n        return 0\n    if n == 1\n        return 0\n    if n == 2\n\
    \        return 2\n    if n == 3\n        return 0\n    if n == 4\n        return\
    \ 2\n    if n == 5\n        return 4\n    if n == 6\n        return 8\n    if\
    \ n == 7\n        return 14\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3)\
    \ + fib4(n - 4)", "\tfib4.call(n,0)\nend", "  a = 1\n  b = 2\n  c = 3\n  d = 4\n\
    \  return d\nend\n</cell>\n<cell>", "  (n<4) ? n : fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4) \nend", "  fib4 = [0,0,2,0,0,0]\n  fib4[n] = fib4[n-1] + fib4[n-2]\
    \ + fib4[n-3] + fib4[n-4] + fib4[n-5] + fib4[n-6]\n  return fib4[n]\nend", " \
    \ return 0 if (n < 0)\n  return n if (n < 4)\n  return fib4(n-1) + fib4(n-2) +\
    \ fib4(n-3) + fib4(n-4) if (n > 4)\nend", "  n <= 4? fib4.call(n-2)+fib4.call(n-3)\
    \ + fib4.call(n-4): fib4.call(n-1)+fib4.call(n-2)\nend", "  if n == 0\n    0\n\
    \  elsif n == 1\n    1\n  elsif n == 2\n    2\n  elsif n == 3\n    0\n  elsif\
    \ n == 4\n    1\n  else\n    fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).",
  "  if n==0 then 0\n  else if n==1 then 1\n  else fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\n  end\nend", "  seq = [0,1,1,2,2]\n  sum = 0\n  for i in (seq.length-1)..n\n\
    \    sum = sum + seq[i]\n  end\n  return sum\nend", "  ( 0..(n-1).to_a.max ).map\
    \ {|i| fib4(i+1).call(n-i)}[-1]\nend", "  fib4.num = [0,1,1,2,3,5]\n  fib4.next\
    \ = 5\n  fib4.num = fib4.num.step(n).next\n  return fib4.num\nend", "  case n\
    \ when 0..0 then 0\n  when 1..0 then 1\n  when 2..0 then 2\n  when 3..0 then 0\n\
    \  else fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).", "  if n == 0\n    0\n\
    \  elsif n == 1\n    1\n  elsif n == 2\n    2\n  elsif n == 3\n    0\n  elsif\
    \ n == 4\n    3\n  else\n    fib4(n - 4) + fib4(n - 3) + fib4(n - 2) + fib4(n\
    \ - 1)\nend", "  if n == 0\n    0\n  elsif n == 1\n    1\n  elsif n == 2\n   \
    \ 2\n  elsif n == 3\n    0\n  else\n    fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n\
    \  end if\nend function\n</pre>\n</div>\n</div>\n<div class=\"cell docutils container\"\
    >\n<div class=\"cell_input docutils container\">\n<div class=\"highlight-default\
    \ notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\"\
    >from</span> <span class=\"nn\">nbdev.export</span> <span class=\"k\">import</span>\
    \ <span class=\"n\">notebook2script</span>\n<span class=\"n\">notebook2script</span><span\
    \ class=\"p\">(</span><span class=\"s1\">&#39;lab_04.ipynb&#39;</span><span class=\"\
    p\">)</span>\n</pre></div>\n</div>\n</div>\n<div class=\"cell_output docutils\
    \ container\">\n<div class=\"output text_html\">\n<script type=\"text/x-mathjax-config\"\
    >MathJax.Hub.Config({\n    TeX: {\n        equationNumbers: {\n            autoNumber:\
    \ \"AMS\"\n        }\n    },\n    tex2jax: {\n        inlineMath: [ ['$','$'],\
    \ [\"\\\\(\",\"\\\\)\"] ],\n        displayMath: [ ['$$','$$'], [\"\\\\[\",\"\\\
    \\]\"] ],\n        processEscapes: true,\n        processEnvironments: true\n\
    \    },\n    // Center justify equations in code and markdown cells. Elsewhere\n\
    \    // we use CSS to left justify single line equations in code cells.\n    displayAlign:\
    \ 'center',\n    \"HTML-CSS\": {\n        styles: {'.MathJax_Display': {\"margin\"\
    : 0}},\n        linebreaks: { automatic: true }\n    }\n});\n</script><script\
    \ type=\"text/x-mathjax-config\">\nMathJax.Hub.Queue(function() {\n    var all\
    \ = MathJax.Hub.getAllJax(), i;\n    for(i = 0; i < all.length; i += 1) {\n  \
    \      all[i].SourceElement().parentNode.className += ' has-jax';\n    }\n});\n\
    </script>\n</div>\n</div>\n<div class=\"cell docutils container\">\n<div class=\"\
    cell_input docutils container\">\n<div class=\"highlight-default notranslate\"\
    ><div class=\"highlight\"><pre><span></span>!pip install -U watermark\n</pre></div>\n\
    </div>\n</div>\n<div class=\"cell_output docutils container\">\n<div class=\"\
    output stream highlight-none notranslate\"><div class=\"highlight\"><pre><span></span>Requirement\
    \ already satisfied: watermark in ./anaconda3/lib/python3.7/site-packages (from\
    \ papermill&gt;=0.1.0) (0.5.1)\nRequirement already satisfied: nbconvert-&gt;=5.5.0\
    \ in ./anaconda3/lib/python3.7/site-packages (from papermill&gt;=0.1.0) (5.6.0)\n\
    Requirement already satisfied: ipykernel&gt;=5.1.2 in ./anaconda3/lib/python3.7/site-packages\
    \ (from papermill&gt;=0.1.0) (5.1.2)\nRequirement already satisfied: traitlets&gt;=5.2.0\
    \ in ./anaconda3/lib/python3.7/site-package", "    puts \"Using recursion\"\n\
    \    fib4(n-1).call(@n).call(@n-2).call(@n-3).call(@n-4).call(@n-5).call(@n-6).call(@n-7).call(@n-8)\n\
    end", "  if n < 0\n    0\n  elsif n == 0\n    1\n  elsif n == 1\n    2\n  elsif\
    \ n == 2\n    1\n  elsif n == 3\n    1\n  elsif n == 4\n    0\n  else\n    fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n  end\nend", "  return 0 if n < 4 then\
    \ 1 else fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend\n  ", "\tfib4 = [0,1,1]\n\
    \tfor i in range(2, n+1)\n\t\tfib4.append(fib4[i-1] + fib4[i-2])\n\treturn fib4[n]",
  "  if n == 0\n    0\n  elsif n == 1\n    0\n  elsif n == 2\n    2\n  elsif n ==\
    \ 3\n    0\n  elsif n == 4\n    4\n  else\n    fib4(n - 1) + fib4(n - 2) + fib4(n\
    \ - 3) + fib4(n - 4)\nend", "  a = 0\n  b = 1\n  c = 1\n  d = 1\n  for i in range(n)\n\
    \    d = a + b + c + d\n    a = b\n    b = c\n    c = d\n  d\nend\n</cell>\n<cell>",
  "  if n < 0\n    raise RangeError, \"fib4 only defined for 0 <= n <= 4\"\n  \n \
    \ fib4 = 0.0\n  if n == 0\n    fib4\n  elsif n == 1\n    fib4\n  elsif n == 2\n\
    \    2\n  elsif n == 3\n    0\n  elsif n == 4\n    4\n  else\n    fib4 = (fib4\
    \ + fib4) + fib4\n  end\n  return fib4\nend", "  seq = (0..(n+1)).map { |i| i**4\
    \ }.inject { |a,b| a+b }\n  return seq if seq < 4\n  seq = seq - 4\n  fib4.call(seq)\
    \ if seq > 0\nend", "  case n\n  when 0 then 0\n  when 1 then 0\n  when 2 then\
    \ 2\n  when 3 then 0\n  else fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n\
    \ - 4)\n  end\nend", "  if n==0\n    0\n  elsif n==1\n    1\n  elsif n==2\n  \
    \  2\n  elsif n==3\n    0\n  elsif n==4\n    4\n  else\n    fib4(n-1)+fib4(n-2)+fib4(n-3)+fib4(n-4)\n\
    \  end\nend", "  if n <= 0\n    0\n  else\n    fib4(n - 1) + fib4(n - 2) + fib4(n\
    \ - 3) + fib4(n - 4)\nend", "  fib4_array.each do |i|\n    if n == 0\n      return\
    \ i\n    elsif n == 1\n      return 0\n    elsif n == 2\n      return 2\n    elsif\
    \ n == 3\n      return 0\n    end\n  end\nend", "    fib4 = [0, 1, 0, 3]\n   \
    \ fib4.each do |i|\n        fib4.push(fib4[i-2] + fib4[i-3] + fib4[i-4])\n   \
    \ end\n    fib4[n]\nend", "  fib4.cache[n] ||= (Fib4.new(4*n).call :+ Fib4.new(3*n-1).call\
    \ :+ Fib4.new(2*n-2).call :+ Fib4.new(n-3).call :+ Fib4.new(n-4).call)\nend",
  "  if n == 0\n    0\n  elsif n == 1\n    1\n  elsif n == 2\n    2\n  elsif n ==\
    \ 3\n    3\n  elsif n == 4\n    8\n  else\n    fib4(n - 4) + fib4(n - 3) + fib4(n\
    \ - 2) + fib4(n - 1)\nend\nputs fib4.call(5) # => 4\nputs fib4.call(6) # => 8\n\
    puts fib4.call(7) # => 14\n</cell>\n<text>\nQuestion 6", "  fib4.fib4.cache[n]\
    \ ||= 0\n  fib4.fib4.cache[n] += fib4.fib4.cache[n-1] + fib4.fib4.cache[n-2] +\
    \ fib4.fib4.cache[n-3] + fib4.fib4.cache[n-4]\n  fib4.fib4.cache[n]\nend", " \
    \ a, b = 0, 1\n  (1..n).each do |i|\n    a, b = b, a + b\n  end\n  return a\n\
    end", "  n = if n.nil? then 0 else n\n  1.upto(n-1).inject(0) do |fib4,n|\n  \
    \  fib4 + fib4 + fib4 + fib4\n  end\nend", "  fib4.memo[n] ||= fib4.memo[n-1]\
    \ + fib4.memo[n-2] + fib4.memo[n-3] + fib4.memo[n-4]\n  return fib4.memo[n]\n\
    end", "  if n==0 then return 0\n  if n==1 then return 1\n  return fib4(n-1)+fib4(n-2)+fib4(n-3)+fib4(n-4)\n\
    end\n</cell>\n<text>\nExercise", "  if(n<0)\n    raise \"fib4 error\"\n  if(n==0)\n\
    \    return 0\n  if(n==1)\n    return 0\n  if(n==2)\n    return 2\n  if(n==3)\n\
    \    return 0\n  return fib4(n-1)+fib4(n-2)+fib4(n-3)+fib4(n-4)\nend", "  if n\
    \ <= 0 \n    puts \"fib4(0) is not a valid argument.\"\n  elsif n <= 1 \n    puts\
    \ \"fib4(1) is not a valid argument.\"\n  elsif n <= 2 \n    2\n  elsif n <= 3\
    \ \n    0\n  elsif n <= 4 \n    fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n\
    \ - 4)\n  else\n    fib4(n - 4) + fib4(n - 3) + fib4(n - 2) + fib4(n - 1)\n  end\n\
    end", "  memo = Hash.new(0)\n  loop do\n    memo[memo.size - 1] << n\n    if memo.size\
    \ == 4\n      memo << \"0\"\n    else \n      memo << memo[-1] + memo[-2] + memo[-3]\
    \ + memo[-4] \n  end\n  memo[-1]\nend", "  if n <= 0\n    0\n  else\n    fib4.call(n-1)\
    \ + fib4.call(n-2) + fib4.call(n-3) + fib4.call(n-4)\nend", "\tfib4.call(4*n-2)\
    \ + fib4.call(4*n-3) + fib4.call(4*n-4) + fib4.call(4*n-1)\nend", "  return 0\
    \ if n < 4\n  a = fib4.call(n - 1) + fib4.call(n - 2) + fib4.call(n - 3) + fib4.call(n\
    \ - 4)\n  fib4.call(n) if n < 4\n  return a\nend", "  if n <= 0\n    0\n  else\n\
    \    n * fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n  end\nend\nputs\
    \ fib4.call(5)", "    one = fib4.one\n    two = fib4.two\n    three = fib4.three\n\
    \    four = fib4.four\n    if n == 0\n        return zero\n    elif n == 2\n \
    \       return two\n    elif n == 3\n        return three\n    elif n == 4\n \
    \       return four\n    elif n < 5\n        fib4.one = two\n        fib4.two\
    \ = three\n        fib4.three = four\n        fib4.four = one\n        return\
    \ fibo(n-1)+fibo(n-2)+fibo(n-3)+fibo(n-4)\n    else\n        return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\nfib4.one = zero\nfib4.two = zero\nfib4.three\
    \ = zero\nfib4.four = zero\nfib4.call(5)\nfib4.call(6)\nfib4.call(7)\nfib4.call(8)\n\
    fib4.call(9)\nfib4.call(10)\nfib4.call(11)\nfib4.call(12)\nfib4.call(13)\nfib4.call(14)\n\
    fib4.call(15)\nfib4.call(16)\nfib4.call(17)\nfib4.call(18)\nfib4.call(19)\nfib4.call(20)\n\
    fib4.call(21)\nfib4.call(22)\nfib4.call(23)\nfib4.call(24)\nfib4.call(25)\nfib4.call(26)\n\
    fib4.call(27)\nfib4.call(28)\nfib4.call(29)\nfib4.call(30)\nfib4.call(31)\nfib4.call(32)\n\
    fib4.call(33)\nfib4.call(34)\nfib4.call(35)\nfib4.call(36)\nfib4.call(37)\nfib4.call(38)\n\
    fib4.call(39)\nfib4.call(40)\nfib4.call(41)\nfib4.call(42)\nfib4.call(43)\nfib4.call(44)\n\
    fib4.call(45)\nfib4.call(46)\nfib4.call(47)\nfib4.call(48)\nfib4.call(49)\nfib4.call(50)\n\
    fib4.call(51)\nfib4.call(52)\nfib4.call(53)\nfib4.call(54)\nfib4.call(55)\nfib4.call(56)\n\
    fib4.call(57)\nfib4.call(58)\nfib4.call(59)\nfib4.call(60)\nfib4.call(61)\nfib4.call(62)\n\
    fib4.call(63)\nfib4.call(64)\nfib4.call(65)\nfib4.call(66)\nfib4.call(67)\n",
  "  fib = @fib4\n  fib.call(n - 1) + fib.call(n - 2) + fib.call(n - 3) + fib.call(n\
    \ - 4)\nend", "    if n == 0\n        0\n    else\n        fib4(n-1) + fib4(n-2)\
    \ + fib4(n-3) + fib4(n-4)\n    end\nend\n</cell>\n<text>\nQuestion 5\nA mathematical\
    \ function (a mathematical function of one argument) takes one argument and returns\
    \ another function of one argument.  For example, the Fib function takes a number\
    \ n and returns another function (a function) that takes a single argument x and\
    \ returns the value of the fib function at that argument.", "  # Your code here\n\
    \  return n", "  fib4.fib_cache[n, n] ||= fib4.fib_cache[n, n-1] + fib4.fib_cache[n,\
    \ n-2] + fib4.fib_cache[n, n-3] +fib4.fib_cache[n, n-4] + n\nend\nfib4.fib_cache\
    \ = {}", "  fib4 =\n  return fib4.call(n)\nend", '  raise NotImplementedError',
  "  n = (n % 4) ? n + 2 : n\n  fib4.cache[n] ||= fib4(n - 1) + fib4(n - 2) + fib4(n\
    \ - 3) + fib4(n - 4)\nend", "  if n <= 1\n    1\n  else\n    n*fib4(n - 1) + fib4(n\
    \ - 2) + fib4(n - 3) + fib4(n - 4)\n  end\nend", "  (0...n).inject(:+).reduce(:+)\n\
    end\n</cell>\n<cell>\nfib4(5) # 10\n</cell>\n<cell>\nfib4(6) # 21\n</cell>\n<cell>\n\
    fib4(7) # 51\n</cell>\n<text>\n5 (bonus)\nNow that you have some code defined,\
    \ it's time to add some tests for it. Write a test that tests fib4(2).  The test\
    \ should pass if you get back 0.  It should also pass if you get back 1 (or any\
    \ other number).  It should fail if you get back 2 or less, or anything else (including\
    \ 0).", "  if n <= 0\n    0\n  elsif n <= 2\n    0\n  elsif n <= 4\n    2\n  elsif\
    \ n <= 7\n    0\n  elsif n <= 9\n    0\n  else\n    fib4.call(n - 1) + fib4.call(n\
    \ - 2) + fib4.call(n - 3) + fib4.call(n - 4)\n  end\nend\n</cell>\n<text>\nExercise\
    \ 8\nNow that you've computed fib4, let's use it to get the 10-th element of the\
    \ sequence by calling the fib10 function.", "\tif n == 0 then\n\t\treturn 0\n\t\
    elsif n == 1 then\n\t\treturn 0\n\telsif n == 2 then\n\t\treturn 2\n\telsif n\
    \ == 3 then\n\t\treturn 0\n\telsif n > 3 then\n\t\treturn fib4(n-1) + fib4(n-2)\
    \ + fib4(n-3) + fib4(n-4)\n\tend\nend\n</cell>\n<text>\nProblem 5\nThe Fibonacci\
    \ sequence is defined by the formula:\nFn = F(n-1) + F(n-2) where F(0) = 1 and\
    \ F(1) = 1.  For example, F(3) = F(2) + F(1) = F(1) + F(0) = F(0) + F(1) = 1 +1\
    \ = 2.\nThe first few terms of the sequence are:"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
