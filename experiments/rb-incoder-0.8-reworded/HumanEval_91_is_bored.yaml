name: HumanEval_91_is_bored
language: rb
prompt: "# You'll be given a string of words, and your task is to count the number\n\
  # of boredoms. A boredom is a sentence that starts with the word \"I\".\n# Sentences\
  \ are delimited by '.', '?' or '!'.\n# For example:\n# >>> is_bored.call(\"Hello\
  \ world\")\n# 0\n# >>> is_bored.call(\"The sky is blue. The sun is shining. I love\
  \ this weather\")\n# 1\ndef is_bored(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_bored\n\
  \    candidate = method(:is_bored)\n    assert_equal(0, candidate.call(\"Hello world\"\
  ))\n    assert_equal(0, candidate.call(\"Is the sky blue?\"))\n    assert_equal(1,\
  \ candidate.call(\"I love It !\"))\n    assert_equal(0, candidate.call(\"bIt\"))\n\
  \    assert_equal(2, candidate.call(\"I feel good today. I will be productive. will\
  \ kill It\"))\n    assert_equal(0, candidate.call(\"You and I are going for a walk\"\
  ))\n  end\nend\n"
completions: ["  return s.start_with? \"I\"\nend\nis_bored = :is_bored", "  s = s.downcase\n\
    \  s.gsub!(/[.!?]/,'.')\n  s.gsub!(/[.!?]/,'.') while s.include? \"?\"\n  s.gsub!(/[.!?]/,'.')\
    \ while s.include? \"!\"\n  s.scan(/i.*/).length\nend\n</cell>\n<code language=julia-1.4>\n\
    is_bored(\"Hello world\")\n</cell>\n<code language=julia-1.4>\nis_bored(\"The\
    \ sky is blue. The sun is shining. I love this weather\")\n</cell>\n<text>\nExercise\
    \ 2: What is the probability that a randomly selected word from the dictionary\
    \ has a boredom?\n(Hint: Don't forget to convert the probability to an integer\
    \ so you don't get an error!)", "  s.gsub!(/[.!?]\\z/, '') # remove trailing punctuation\n\
    \  s.gsub!(/[^a-z]/i, '') # remove non-letters\n  s.downcase!\n  s.gsub!(/\\b(I)/i)\
    \ { |m| $1+1+$2.to_i }\n  s.gsub!(/\\b(you)/i) { |m| $1+1+$2.to_i }\n  s.gsub!(/\\\
    b(my)/i) { |m| $1+1+$2.to_i }\n  s.gsub!(/\\b(i)/i) { |m| $1+1+$2.to_i }\n  s.gsub!(/\\\
    b(it)/i) { |m| $1+1+$2.to_i }\n  s.gsub!(/\\b(they)/i) { |m| $1+1+$2.to_i }\n\
    \  s.gsub!(/\\b(their)/i) { |m| $1+1+$2.to_i }\n  s.gsub!(/\\b(she)/i) { |m| $1+1+$2.to_i\
    \ }\n  s.gsub!(/\\b(he)/i) { |m| $1+1+$2.to_i }\n  s.gsub!(/\\b(her)/i) { |m|\
    \ $1+1+$2.to_i }\n  s.gsub!(/\\b(him)/i) { |m| $1+1+$2.to_i }\n  s.gsub!(/\\b(its)/i)\
    \ { |m| $1+1+$2.to_i }\n  s.gsub!(/\\b(theirs)/i) { |m| $1+1+$2.to_i }\n  s.gsub!(/\\\
    b(myself)/i) { |m| $1+1+$2.to_i }\n  s.gsub!(/\\b(with)/i) { |m| $1+1+$2.to_i\
    \ }\n  s.gsub!(/\\b(that)/i) { |m| $1+1+$2.to_i }\n  s.gsub!(/\\b(which)/i) {\
    \ |m| $1+1+$2.to_i }\n  s.gsub!(/\\b(which)/i) { |m| $1+1+$2.to_i }\n  s.gsub!(/\\\
    b(what)/i) { |m| $1+1+$2.to_i }\n  s.gsub!(/\\b(what)/i) { |m| ", "  s.split('.').inject([true])\
    \ do |boredom, str|\n    if str[0] == 'I'\n      boredom = false\n    end\n  \
    \  boredom\n  end\nend", "  s.gsub!(/[^\\.!?]+/, \" \")\n  s.gsub!(/I\\b/, \"\
    I\")\n  return s.scan(/\\.|\\?|!/).length == 1\nend\n</code>\n<|/ a tags=ruby,regex,string\
    \ dscore=1 |>\n<| a dscore=0 tags=ruby,regex,string |>\nThis regex should do the\
    \ trick:\n<code>\ns.match(/(.*\\.|\\.\\?|\\.!)/).captures.flatten.size\n</code>\n\
    <|/ a |>\n<| a dscore=0 |>\n<code>", "  s.scan(/I[\\.\\?!]/)\n  return s.length\
    \ == 0\nend", "  s.split == '.' || s.split == '?' || s.split == '!'\nend", " \
    \   boredom_words = ['I']\n    count = 0\n    for word in s.split(' ')\n     \
    \   if word.startswith('I'):\n            count += 1\n    return count", "  s.gsub!(/[^\\\
    .\\?\\!]+/, '')\n  s.gsub!(/\\bI\\b/, 'I')\n  s.count('I')\nend", "  s.each_char.with_object(Hash.new(0))\
    \ {|c, h| h[c] += 1 }\n    .find { |c, h| h[c] == 0 }\nend\n</code>\nLet's see\
    \ how it works:\n<code>\nis_bored.call(\"Hello world\")", "  return s.split('.').all?\
    \ { |x| x.start_with? \"I\" }\nend", "    boredom = 0\n    i = 0\n    while i\
    \ < s.length\n        if s[i] == \"I\" then\n            boredom += 1\n      \
    \  i += 1\n    return boredom\nend\n</cell>\n<code language=julia-1.0>", "  #\
    \ +++your code here+++\n  s.split(\" \").each {|l| return 1 if l == \"I\"}\n \
    \ 0\nend", '    return s.count "I"', "  return s.gsub!(/\\.|^\\s+|\\?|^!/,'').length\
    \ == 0\nend", "    s = s.split(%r{[.?!]\\s+}, -1)\n    s.each { |w| puts w if\
    \ w.match(\"^I\") }\n    s.length\nend", "  sentences = s.split('.')\n  bored\
    \ = 0\n  \n  # Check for boredom, starting with 'I'\n  if sentences[0].strip ==\
    \ 'I'\n    bored = 1\n  \n  # Check for full sentence\n  sentence = sentences.pop\n\
    \  while sentence.strip\n    if sentence == '?'\n      bored = 1\n      sentence\
    \ = sentences.pop\n    elsif sentence == '!'\n      bored = 1\n      sentence\
    \ = sentences.pop\n    else\n      sentence = sentences.pop\n    end\n  end\n\
    \  \n  return bored\nend", "    bored = 0\n    s = s.chomp\n    s_array = s.split(\"\
    . \")\n    s_array[1].gsub!(/(\\.|\\?|\\!)/, \"\\n\")\n    s_array.each do |word|\n\
    \        if word.start_with? \"I\" then\n            bored = 1\n        end\n\
    \    end\n    return bored\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for\
    \ your help. I ran the program on several test cases and it seems that the bored\
    \ = 1.. is never getting executed. What am I missing?\n<|/ c |>\n<| c |>\nCan\
    \ you provide some examples of `s` and the output of `bored`?\n<|/ c |>\n<| c\
    \ |>\n`s=\"The sky is blue. The sun is shining. I love this weather!\"` `bored\
    \ = 0` `s = \"I\"` `bored = 1`\n<|/ c |>\n<| c |>\nI ran the program on my machine\
    \ and got `bored = 1`. Not sure what's wrong.\n<|/ c |>\n<| c |>\nAre you trying\
    \ to count how many sentences contain `I` or how many words start with `I`? I\
    \ think you want the second one. Have a look at my updated code.\n<|/ c |>\n<|\
    \ a |>\n<code>\ns=(\"The sky is blue. The sun is shining. I love this weather!\"\
    )", "  return s.count (\"I\") == 1 and s.index (\".\") < s.index (\"?\") and s.index\
    \ (\"!\") == 1\nend", "  s.downcase!\n  s.gsub!(/[\\.\\?!]/,\"\").gsub(/\\b(?:I|me|my|myself|we|us|our|ours|ourselves|you|your|yours|yourself|yourselves|he|him|his|himself|she|her|hers|herself|it|its|itself|they|them|their|theirs|themselves|what|which|who|whom|this|that|these|those|am|is|are|was|were|be|been|being|have|has|had|having|do|does|did|doing|will|would|should|can|cannot|could|would|should|can|cannot)\\\
    b/, \"\").downcase\n  s.gsub!(/\\s\\z/, \"\")\n  return s.count(\"i\") >= 2\n\
    end\n</code>\n<|/ a |>\n<| c |>\n+1 for effort...and for teaching me a little\
    \ about how regexes work in ruby...I was completely unaware of the \"non-greedy\"\
    \ qualifier\n<|/ c |>\n<| a tags=regex,ruby |>\nI made a small ruby script to\
    \ help me solve this problem:\n<code>", "  return s.chars.first(/I/ and !/[\\\
    .\\?\\!]/).nil?\nend", "  return s.scan(/\\b(I\\w*)\\b/).length == 0\nend", " \
    \ s.scan(/[\\.\\?\\!](I)/).size\nend", "  s.scan(/^I(.|\\?|!)$/)\n  s.length\n\
    end", "    count = 0\n    s.each do |word|\n        count = 1 if word.to_s.start_with?(\"\
    I\")\n    end\n    return count\nend", "  s.gsub!(/[.,!?]$/, '')\n  s.gsub!(/^\\\
    W+|\\W+$|[.,!?]\\W+/, '')\n  s.split(\" \").count(\"I\")\nend", "  return s.scan(/\\\
    b(I)/).size==1\nend", "  s.downcase!\n  s.gsub!(/([?!])[.!?]/, \"\\\\1\")\n  s.gsub!(/[I]/,\
    \ \"\\\\I\")\n  s.gsub!(/([a-zA-Z])([.?])([a-zA-Z])/, \"\\\\1\\\\3\\\\5\")\n \
    \ s.gsub!(/([a-zA-Z])[.?](\\\\1)([a-zA-Z])/, \"\\\\1\\\\2\\\\3\")\n  s.gsub!(/([a-zA-Z])[.?]/,\
    \ \"\\\\1\\\\2\")\n  s.gsub!(/([a-zA-Z])[?](\\\\1)[?]/, \"\\\\1\\\\2\")\n  s.gsub!(/([a-zA-Z])[!](\\\
    \\1)[!]/, \"\\\\1\\\\2\")\n  s.gsub!(/([a-zA-Z])[!]/, \"\\\\1\\\\2\")\n  s.gsub!(/([a-zA-Z])[?]([a-zA-Z])/,\
    \ \"\\\\1\\\\2\\\\3\")\n  s.gsub!(/([a-zA-Z])[?]/, \"\\\\1\\\\2\")\n  s.gsub!(/([a-zA-Z])[.]([a-zA-Z])/,\
    \ \"\\\\1\\\\2\")\n  s.gsub!(/([a-zA-Z])[.]/, \"\\\\1\\\\2\")\n  s.gsub!(/([a-zA-Z])[?]([.?])([a-zA-Z])/,\
    \ \"\\\\1\\\\3\\\\2\\\\5\")\n  s.gsub!(/([a-zA-Z])[?]([.?])/, \"\\\\1\\\\3\\\\\
    2\")\n  s.gsub!(/([a-zA-Z])[?]([.?])([.?])([.?])/, \"\\\\1\\\\3\\\\2\\\\5\\\\\
    7\")\n  s.gsub!(/([a-zA-Z])[?]([.?])([.?])/, \"\\\\1\\\\3\\\\2\")\n  s.gsub!(/([a-zA-Z])[?]([.?])([.?])([.?])([.?])([.?])([.?])([.?])/,\
    \ \"\\\\1\\\\3\\\\2\\\\5\\\\7\\\\9\\\\11\\\\13\\\\15\\\\17\\\\19\\\\21\\\\23\\\
    \\25\\\\27\\\\29\\\\31\\\\33\\\\35\\\\37\\\\39\\\\41\\\\43\\\\45\\\\47\\\\49\\\
    \\51\\\\53\\\\55\\\\57\\\\59\\\\61\\\\63\\\\65\\\\67\\\\69\\\\71\\\\73\\\\75\\\
    \\77\\\\79\\\\81\\\\83\\\\85", "  s.gsub!(/[.!?]/,\"\").gsub!(/I/,\"\").split(\"\
    .\").length\nend\n</cell>\n<cell>", "  s = s[1..-1]\n  s.gsub!(/\\.|\\?|\\!/,'')\n\
    \  s.gsub!(/I/,' ')\n  s.gsub!(/[\\ ]+/,'')\n  s.gsub!(/\\s$/,'')\n  s.count('I')\
    \ == 0\nend\n</code>\n<|/ a |>\n<| a |>\nThe Ruby way to do this would be using\
    \ the methods in the Enumerable module. Here's an example that returns whether\
    \ a given string is a bored or not:\n<code>", "  s.gsub!(/\\p{L}+/, '') # change\
    \ all non-ASCII letters to a single space\n  s.gsub!(/\\.\\p{L}+/, '.') # change\
    \ all dots to a single point\n  s.gsub!(/[.?!]\\p{L}+/, '') # change all question/exclamation\
    \ points to a single point\n  s.gsub!(/\\p{Z}+/, '') # change all non-ASCII letters\
    \ to a single space\n  s.gsub!(/\\s+/, ' ') # change all spaces to a single space\n\
    \  s.split.each do |word|\n    return 0 if word !~ /^I /\n    return 1 if word\
    \ =~ /^(bore|bored|boredom)\\b/\n    return 0 if word =~ /^(bore|bored|boredom)$/\n\
    \  end\n  0\nend\n</code>\n<|/ a dscore=3 |>\n<| a dscore=3 |>\nI wrote a small\
    \ ruby gem (boredom) that will do this for you:\n<code>\nrequire 'boredom'", " \
    \ s = s.split # Split s into an array\n  s.shift # Delete the first element\n\
    \  s.each do |word|\n    if word == \"I\"\n      result = true\n      break\n\
    \    end\n  end\n  result\nend", "  return s.start_with?(\"I\")\nend", "    return\
    \ s.index =~ /\\bI\\b/\nend", "  return s.chars.any? { |char| char == '.' || char\
    \ == '?' || char == '!' }\nend", "  s.downcase!\n  s.gsub!(/[.?!]/,\" \") # collapse\
    \ extra spaces\n  s.gsub!(/I/,\".\") # collapse \"I\"\n  s.gsub!(/ +/,\" \") #\
    \ collapse extra spaces\n  s.count(\".\")+s.count(\"?\")+s.count(\"!\")\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThis is great. I'm still having an issue\
    \ with it saying \"undefined method `split' for nil:NilClass\" when I run it\n\
    <|/ c |>\n<| c |>\n: you must have copied the code incorrectly. I edited my answer\
    \ to reflect your latest code.\n<|/ c |>\n<| a |>\nA simple ruby script will do:\n\
    <code>\nputs is_bored.call(\"Hello world\")\nputs is_bored.call(\"The sky is blue.\
    \ The sun is shining. I love this weather\")\nputs is_bored.call(\"Hello world\
    \ again\")\n</code>\nThe Ruby code is simple:\n<code>", "    words = s.split(\"\
    \ \")\n    bored_words = [\"I\"]\n    count = 0\n    for word in words:\n    \
    \    if word.lower() in bored_words:\n            count += 1\n    return count\n\
    </cell>\n<cell>", "  s.split('.').all? {|word| word =~ /^I/ }\nend", "  s = s.to_s\n\
    \  s.gsub!(/[.!?]+/, \" \") # add space between punctuation\n  s.gsub!(/\\bI\\\
    b/, \"I\") # make \"I\" begin with \"I\"\n  s.downcase!\n  s.gsub!(/([^A-Z])/)\
    \ { $1.upcase } # Upcase the first letter\n  s.count(\"I\")\nend\n</code>\nNotice\
    \ how we turned the string into lower case. That's because we're going to use\
    \ downcase to remove all capitals. We need to do this because the string \"I\"\
    \ doesn't match \"i\". If you don't do this step, then \"I\" won't match \"i\"\
    .\nNext, we have to remove punctuation from the string. I'll use Ruby's built-in\
    \ regular expressions to do this. The regular expression /[.!?]+/ says \"match\
    \ one or more of ., !, or ?\". That's a regular expression that matches any punctuation.\
    \ We use gsub to replace all matches of that expression with the given string.\
    \ I'll replace all punctuation with spaces in order to count the number of capital\
    \ \"I\"s.\nFinally, downcase all capitals in the string so they're all capital\
    \ \"I\"s.\nThen count the number of capital \"I\"s.\n<|/ a dscore=0 tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nI love it! Just one question, how do you return false if the string\
    \ is an empty string? If I pass it a string of just white space or no punctuation,\
    \ it gives me \"0\" for the boredom count, when it should be \"0\".\n<|/ c |>\n\
    <| c |>\n: Add `elsif` to the `if` statement: `elsif s.empty?` ... `end`\n<|/\
    \ c |>\n<| c |>\nOk I got that part. But I also need it to tell me \"no boredom\
    \ detected\" if the string is just whitespace. So when I pass it an empty string,\
    \ it just says \"0\".\n<|/ c |>\n<| c |>\n: Add `elsif s == \"\"`. That will be\
    \ executed if and only if the string is empty.\n<|/ c |>\n<| c |>\nOne last question.\
    \ How would I modify this code to include words like \"I\", \"you\", \"he\", and\
    \ \"she\" as well?\n<|/ c |>\n<| a dscore=0 |>\nThis should do:\n<code>", "  s\
    \ = s.split \".\" #or s.split \"?\"\n  s.each_with_index do |w,i|\n    if w[0]==\"\
    I\"\n      return 1 if i>0\n      return 0 if (s.count(\"!\"))\n      return 0\
    \ if (s.count(\"?\"))\n    end\n  end\n  return 0\nend", "    boredom = 0\n  \
    \  for w in s.split():\n        if w.startwith?(\"I\"):\n            boredom +=\
    \ 1\n    end\n    boredom\nend", "  s = \" \" + s + \" \"\n  s = s.split(\". \"\
    )\n  s = s.split(\"? \")\n  s = s.split(\"! \")\n  s.each do |sentence|\n    count\
    \ = 1\n    sentence.gsub(/[I]/) do |letter|\n      count += 1\n    end\n    return\
    \ count\n  end\nend", "  s.split('.').inject(0) {|sum, e| sum + 1 if e =~ /^I/\
    \ }\nend", "  return s.gsub(/(([Ii])\\.|(\\.\\?|\\!)|\\!\\?)[a-z]*/).size > 0\n\
    end", "  s.scan(/\\bI\\b/)\n  s.scan(/\\.|\\.\\?|\\.\\!/)\nend", "  s = s.to_s\n\
    \  s.chomp!('.')\n  s.chomp!('?')\n  s.chomp!('!')\n  s.empty?\n  s.start_with?('I')\n\
    end", "\ts.chars.each { |char| char == '.' || char == '?' || char == '!' ? return\
    \ false }\n\treturn true\nend", "    boredoms = (0...s.split().size - 1)\n   \
    \ boredoms.find {|i| s[i] == \"I\" } ? 1 : 0\nend", '  return s.count("I") >=
    4', "    count=0\n    sentence=s.split(\".\")\n    for i in sentence\n       \
    \ if i==\"I\"\n            count+=1\n    return count\n</code>\nThis can be done\
    \ using map() in Python3. map() takes two arguments function and list. In our\
    \ case, the function will be is_bored and the list will be the strings that needs\
    \ to be analyzed. map() will return a new list where each element is computed\
    \ by calling the function on each element of the list. It can also be used to\
    \ return a list of results instead of a single value.\n<code>", "    s = s.chomp\n\
    \    boredoms = ['I', 'it', 'the', 'its', 'they', 'their', 'theirs', 'our', 'ours',\
    \ 'ourselves', 'you', 'your', 'yours', 'yourself', 'yourselves']\n    return boredoms.count(s[0])\
    \ == 1 \nend", "    bored = s.start_with?(\"I\")\n    return bored ? 1 : 0\nend\n\
    </cell>\n<cell>", "  bored = s.split(\".\").map(&:capitalize).include?(\"I\")\n\
    \  bored ? 1 : 0\nend", "  s.count(\"I\") == 0\nend", "  s.split(\" \").count\
    \ {|w| w =~ /^I/ }\nend", "  s.split(\" \").map { |x| x =~ /^I/ ? 1 : 0 }.inject\
    \ { |x, y| x + y }\nend", "  return s.start_with?(\"I\") ? 1 : 0\nend", "  bored\
    \ = false\n  s = s[0,s.length]\n  if s[0] == \"I\" then bored = true\n  return\
    \ bored\nend", "  return s.index('I')==0 or s.index('.') > s.index('!')\nend",
  "  s = s.split(\". \")\n  if s[0] == \"I\"\n    s[1]\n  end\nend\n</pre>\n<p>Notice\
    \ the use of the 'end' keyword? When you use 'end', Ruby will stop executing any\
    \ code in the block. You do not have to explicitly close the block with 'end'.</p>\n\
    <p>Let's see how we could use this function with our test cases:</p>\n<pre class=\"\
    ruby\"><span class=\"ruby-keyword\">class</span> <span class=\"ruby-constant\"\
    >BoredomTest</span> <span class=\"ruby-operator\">&lt;</span> <span class=\"ruby-constant\"\
    >Test</span>\n  <span class=\"ruby-identifier\">context</span> <span class=\"\
    ruby-keyword\">do</span>\n    <span class=\"ruby-keyword\">def</span> <span class=\"\
    ruby-identifier\">test_boredom</span>\n      <span class=\"ruby-identifier\">is_bored?</span>(<span\
    \ class=\"ruby-string\">\"Hello world\"</span>)\n      <span class=\"ruby-identifier\"\
    >is_bored?</span>(<span class=\"ruby-string\">\"The sky is blue. The sun is shining.\
    \ I love this weather\"</span>)\n    <span class=\"ruby-keyword\">end</span>\n\
    \  <span class=\"ruby-keyword\">end</span>\n<span class=\"ruby-keyword\">end</span>",
  "  count = 0\n  s.split.each do |s|\n    if s[0] == \"I\" then\n      count += 1\n\
    \    end\n  end\n  return count\nend\n</code>\nThis code snippet assumes you will\
    \ be passing in a string that contains at least one sentence (otherwise it will\
    \ return 0). The code also assumes that each sentence is separated by a period,\
    \ question mark, or exclamation point.\nOnce you have a function like this in\
    \ place, it's easy to create a series of unit tests that test each possible scenario,\
    \ like so:\n<code>", "  s.split(\" \").select{ |s| s =~ /^[I].*/ }.count\nend",
  "  return s.split(\" \").all? {|w| w =~ /^I/ }\nend", "    bored_count = 0\n   \
    \ bored_list = []\n    bored_words = ['I', 'are', 'is', 'was', 'were', 'do', 'did',\
    \ 'would', 'will']\n    for word in s.split()\n        if bored_words.include?(word)\
    \  \n            bored_count += 1\n    end\n    bored_list.push bored_count\n\
    \    return bored_list\nend\n</code>\nNow the main function, bored_sentence()\
    \ will read in a file of sentences, and output a table of bored and non-bored\
    \ sentences. This is accomplished in two steps. First, each sentence is split\
    \ by '.', '?' or '!' (depending on the task at hand), and each word is checked\
    \ for bored status. Once we know how many bored sentences there are in a given\
    \ file, the bored_sentence method will loop through each sentence, splitting the\
    \ sentence by '.', '?' or '!' and counting the number of bored sentences in each\
    \ sentence. Finally, the bored_sentence method will put each sentence in a cell\
    \ of the resulting table. \n<code>\nbored_sentence = read_file(\"bored_sentences.txt\"\
    )", "  s.gsub!(/[.!?]+/, \" \")\n  s.gsub!(/([I])([.!?])/, '\\1\\2 ')\n  s.gsub!(/([I])([.!?])/,\
    \ '\\1\\2 ')\n  s.gsub!(/([I])([.!?])/, '\\1\\2 ')\n  s.count(\"I \")\nend", " \
    \ s = s.split(\". \")\n  s.each_index do |i|\n    if s[i] == \"I\"\n      return\
    \ i\n    end\n  end\n  0\nend", "  s.split('.')[0].start_with?('I')\nend", " \
    \ s.downcase!\n  return s.gsub(/([?!])/, \"\\\\1I\").split(\".\").count do |w|\n\
    \    w.chomp.downcase == \"i\"\n  end\nend\n</code>\nNow your task will be to\
    \ modify your original function so that it works on a given array of sentences\
    \ (i.e. not just a single sentence as you had before). This means making your\
    \ function into a method that takes an array of strings. \nTry this:\n<code>",
  "  return s.split(\".\")[0].start_with?(\"I\")\nend", "  s.split.grep(/^[I].*\\\
    .?/).length\nend", "  s.index(\"I\") == 0 or s.index(\"!\") == 0 or s.index(\"\
    ?\") == 0\nend", "  s.split\n  s.starts_with?('I')\nend", "  s = s.downcase\n\
    \  s.gsub!(/[^a-z]/i, '')\n  s.gsub!(/[\\.\\?!]/, '')\n  s.scan(/(?<=^|$)I[a-z]/)\n\
    \  s.count\nend", "  return s.split('.').length < 2\nend", "  s.scan(/^(I|You|She|He|It|They|I|You|Them)\\\
    ./)\n  s.scan(/^(You|I)\\.(I|You|It|You|Them)\\./)\n  s.scan(/^(You|I)\\.(I|You|Them)\\\
    ./)\n  s.scan(/^(I|You|I|You|I|You|I|You|Them)\\./)\n  s.scan(/^(You|I)\\.(I|You|I|You|I|You|I|You|Them)\\\
    ./)\n  s.scan(/^(You|I)\\.(I|You|I|You|I|You|I|You|I|You|Them)\\./)\n  s.scan(/^(I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|Them)\\\
    ./)\n  s.scan(/^(I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I|You|I",
  '    return s.split.include? "I".length', "    bored = 0\n    for w in s.split(\"\
    \ \"):\n        if w.startswith(\"I\"):\n            bored += 1\n    return bored",
  "  s.downcase!\n  s.gsub!(/\\.[!?]/,\".\")\n  s.gsub!(/\\?/,\".\")\n  s.gsub!(/!/,\"\
    .\")\n  s.split(\" \").map do |w|\n    w = w.strip\n    w = w.sub(\"^\",\"\")\n\
    \    w = w.sub(\" \",\"\")\n    w = w.gsub(\"^\",\".\")\n    w = w.gsub(\".$\"\
    ,\"\")\n    w = w.gsub(/\\.\\W/,\"\")\n    w = w.gsub(/\\.$/,\"\")\n    w = w.gsub(\"\
    \\?$\",\".\")\n    w = w.gsub(\"\\!$\",\".\")\n    w = w.gsub(/\\?\\.$/,\".\"\
    )\n    w = w.gsub(/\\!\\.$/,\".\")\n    w = w.gsub(\"^.\",\".\")\n    w = w.gsub(\"\
    $.\",\".\")\n    w = w.gsub(\".\\Z\",\"\")\n    w = w.gsub(\".\\W\",\"\")\n  \
    \  w\n  end.compact.uniq.count(\".\")\nend", "    count = 0\n    s = string.lower(s)\n\
    \    for i in s:\n        if i == \"i\" or i == \"!\":\n            count += 1\n\
    \    return count", "    \n    bored_words = boredom_words.keys\n    \n    # your\
    \ code here\n    \n    \n    return bored_words.count (s[0]) in bored_words",
  "    count = 0\n    for word in s.split(\" \"):\n        if word.startswith((\"\
    I\",\"i\",\"!\",\".\")):\n            count += 1\n    return count", "    bored\
    \ = 0\n    s.split(\".\") do |word|\n        if word[0] == \"I\" && !word.empty?\n\
    \            bored = bored + 1\n        end\n    end\n    return bored\nend",
  "  s.scan(/^(I)/).length\nend", "    # Split s into a list of words: [\"Hello\"\
    , \"world\"]\n    words = s.split\n    bored_count = 0\n    bored_word = \"I\"",
  "  return s.start_with?(\"I\")\nend", "  s.count(\"I\") == 0\nend", "  return s.start_with?(\"\
    I\")\nend\n</cell>\n<cell>", "  s.split(\". \").select{|x| x[0...0] == \"I\"}.length\
    \ == 1 \nend", "  s.gsub!(/\\.|!|\\?|\\./, \" \")\n  s.split(\" \").uniq.each\
    \ do |word|\n    if word =~ /^I/ then\n      next\n    else\n      return 0\n\
    \    end\n  end\n  return 1\nend", "  words = s.split(\" \")\n  words.each do\
    \ |word|\n    if word == \"I\"\n      return 0\n    end\n  end\n  return 1\nend",
  "  s.split('.').map {|word| word[0]}.reduce(0) {|s,w| w == \"I\" ? s + 1 : s}\n\
    end", "    boredoms = [\n        [\"I\", \"me\", \"I\"],\n        [\"You\", \"\
    are\", \"I\"],\n        [\"You\", \"are\", \"me\"],\n        [\"You\", \"are\"\
    , \"I\", \"am\"],\n        [\"I\", \"am\", \"I\"],\n        [\"I\", \"am\", \"\
    you\"],\n        [\"I\", \"am\", \"I\", \"am\"]\n    ]", "  boredoms = [\n   \
    \ \"I am\",\n    \"I was\",\n    \"I would\",\n    \"I will\",\n    \"I would\"\
    ,\n    \"Its\",\n    \"I can\",\n    \"I 'll\",\n    \"I don't\",\n    \"I don'\"\
    ,\n    \"I'd\",\n    \"I can't\"\n  ]\n  boredoms.each do |word|\n    return true\
    \ if s.start_with?(word)\n  end\n  return false\nend", "  s.downcase!\n  s.gsub!(/[\\\
    .\\?\\!]/, \" \")\n  s.split.each do |x|\n    if x == \"I\"\n      return 1\n\
    \    end\n  end\n  return 0\nend", "  count = 0\n  s.split(\".\").each do |sentence|\n\
    \    if sentence =~ /^I /\n      count += 1\n    end\n  end\n  count\nend\n</cell>\n\
    <cell>", "  s.gsub(/[^I].*/, \"\").count == \"I\"\nend", "  s.split(\".\").count(\"\
    I\") == 0 ? 0 : 1 end\n</cell>\n<cell>", "    boredom = false\n    s.split(\"\
    \ \").each do |w|\n        if w == \"I\"\n            boredom = true\n       \
    \ end\n    end\n    return boredom\nend", "  s, = s.split('.')\n  s.chars.grep(/(?<=^|\\\
    s)(i)(?=\\s|$|\\!)/)\nend", "  return is_bored?(s)\nend", "  s.gsub(/[\\.?!]\\\
    s*/,'').gsub(/^I/,'').length == 0\nend", "\ts.split(\" \").grep(/I./).size\nend",
  "  s.chars.each do |c|\n    if c.downcase == \"i\"\n      return 0 if c == \".\"\
    \ || c == \"!\" || c == \".\" || c == \"?\" || c == \".\" || c == \"!\"\n    end\n\
    \  end\n  1\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nYou don't need the `if`\
    \ statement.\n<|/ c |>\n<| c |>\nThe `if c == \".\" || c == \"!\" || c == \".\"\
    \ || c == \"?\" || c == \".\" || c == \"!\"` statement is there for a reason:\
    \ if it returns true, this means it's false and we still return 1.\n<|/ c |>\n\
    <| c |>\nThat was a silly oversight on my part. I edited my answer to use an `if`\
    \ statement for clarity.\n<|/ c |>\n<| a |>\nIf your ruby version is 1.8.6, then\
    \ you can use the select method:\n<code>", "  s.split('.').all? do |x|\n    if\
    \ x[0].downcase == \"i\"\n      return 1\n    end\n  end\n  0\nend", "  return\
    \ s.split(\".\")[0].include?(\"I\")\nend", "    return s.gsub(/^[Ii].*$/).size\
    \ > 0\nend", "  s = \" \" + s + \" \"\n  s.gsub!(/[.!?]\\s*\\n/, \"\")\n  s.gsub!(/I\
    \ /, \"I\\n\")\n  s.gsub!(/\\.\\s/, \".\")\n  s.gsub!(/\\?\\s/, \"?\\n\")\n  s.gsub!(/!\\\
    s/, \"!\\n\")\n  s.gsub!(/\\n$/, \"\")\n  s.gsub!(/\\n\\s/, \"\\n\")\n  s.gsub!(/\\\
    s*\\n/, \" \")\n  s.gsub!(/\\n\\s*\\n/, \"\\n\")\n  s.gsub!(/\\n\\s*/, \" \")\n\
    \  s.gsub!(/\\n/, \"\\n\")\n  s.gsub!(/\\s{1,}/, \" \")\n  s.gsub!(/\\.{2,}/,\
    \ \".\")\n  s.gsub!(/\\.{2,}/, \".\")\n  s.gsub!(/\\?\\{2,\\}/, \"?\")\n  s.gsub!(/\\\
    ?\\{2,\\}/, \"?\")\n  s.gsub!(/\\!{2,\\}/, \"!\")\n  s.gsub!(/\\!{2,\\}/, \"!\"\
    )\n  s.gsub!(/\\s*$/, \"\")\n  s.gsub!(/\\s*$/,\"\")\n  s.gsub!(/\\s+/, \" \"\
    )\n  s.gsub!(/\\s+/, \" \")\n  s.gsub!(/\\s+/, \" \")\n  s.gsub!(/\\s+/, \" \"\
    )\n  s.gsub!(/\\s+/, \" \")\n  s.gsub!(/\\s+/, \" \")\n  s.gsub!(/\\s+/, \" \"\
    )\n  s.gsub!(/\\s+/, \" \")\n  s.gsub!(/\\s+/, \" \")\n  s.gsub!(/\\s+/, \" \"\
    )\n  s.gsub!(/\\s+/, \" \")\n  s.gsub!(/\\s+/, \" \")\n  s.gsub!(/\\s+/, \" \"\
    )\n  s.gsub!(/\\s+/, \" \")\n  s.gsub!(/\\s+/, \" \")\n  s.gsub!(/\\s+/, \" \"\
    )\n  s.gsub!(/\\s+/, \" \")\n  s.gsub!(/\\s+/, \" \")\n  s.gsub!(/\\s+/, \" \"\
    )\n  s.gsub!(/\\s+/, \" \")\n  s.gsub!(/\\s+/, \" \")\n  s.gsub!(/\\s+/, \" \"\
    )\n  s.gsub!(/\\s+/, \" \")\n  s.g", "  s.chars.map {|word| word.downcase}.reject(&:blank?).grep(/^i/).length\n\
    end", "  s = s.to_s.gsub(/\\. /, \" . \").gsub(/? /, \" ? \").gsub(/!/, \" ! \"\
    ).split(\" \") \n  s.map!{|x| x.gsub(/[I]/, \"\") }\n  (s.map { |x| x.split.count\
    \ { |w| w == \"I\" } }).inject(:+)\nend", "  s = s.to_s\n  if s[0]=='I' && (s[1..-1].match?(/\\\
    .|\\.\\?|\\!/))\n    return 1\n  else\n    return 0\n  end\nend", "  return s.start_with?\
    \ \"I\"\nend\n</cell>\n<cell>", "  s = s.downcase\n  s.gsub!(/[\\?\\.\\!]*/,\"\
    \")\n  return s.start_with?(\"i\")\nend", '  return s.match(I)?1:0', "  s.gsub!(/(^|[\\\
    .\\?\\!])(I)/, '\\1bored\\2')\n  s.gsub!(/([\\.\\?\\!])(I)/, '\\1bored\\2')\n\
    \  s.gsub!(/(^|\\s)([I])(\\s|$)/, '\\1bored\\2')\n  s.count('bored')\nend", " \
    \   words = s.split(\" \")\n    count = 0\n    i = 0\n    while i < words.length\n\
    \        word = words[i]\n        if word == \"I\"\n            count += 1\n \
    \       i += 1\n    return count\n</code>\nA couple other comments:", "  s.split(\"\
    \ \").map{|s| s[0] == \"I\"}.count > 0\nend", "  s = s.split('.').map { |s| s.chomp.downcase\
    \ }\n  s.each do |word|\n    word = word.strip\n    return 1 if word == \"i\"\n\
    \    return 0 if word == word[0,1]\n  end\n  0\nend\n</cell>\n<cell>", "    boredoms\
    \ = [\"I\", \"you\", \"you\u2019re\", \"you\u2019ve\", \"your\", \"yours\", \"\
    yourself\", \"you\u2019ll\",\n        \"you\u2019ll\", \"yourself\", \"you\u2019\
    d\", \"you\u2019ll\", \"you\u2019d\", \"you\u2019ve\", \"you\u2019re\", \"I\u2019\
    m\",\n        \"I\u2019m\", \"I\u2019ve\", \"you\u2019re\", \"I\u2019ve\", \"\
    we\u2019re\", \"we\u2019re\", \"we\", \"you\u2019re\", \"I\u2019ve\",\n      \
    \  \"I\u2019s\", \"I\u2019m\", \"you\u2019ve\", \"I\u2019m\", \"I\u2019m\", \"\
    you\u2019ll\", \"we\u2019re\", \"we\u2019re\", \"we\u2019ve\",\n        \"we\u2019\
    ll\", \"we\u2019ll\", \"we\u2019d\"]\n    boredom_count = s.split(\".\").count\
    \ \"I\"\n    return boredom_count", "  return s.count(\"I\") == 3 or s.count(\"\
    .\")==1 or s.count(\"?\")==1 or s.count(\"!\") == 1\nend", "  return s.start_with?(\"\
    I\")\nend\n</cell>\n<cell>", "    boreds = s.count(\"I\")\n    return boreds #\
    \ 0 if the string contains no boredoms, 1 otherwise\nend", "  s.scan(/I\\b|\\\
    .|!/).size > 0\nend", "  return s[0,3]==\"I\"\nend", "  count = 0\n  s.split(\"\
    \ \").each do |word|\n    if word[0]==\"I\"\n      count += 1\n    end\n  end\n\
    \  count\nend", "  s.gsub!(/([?!])\\.([A-Z])/,'\\1\\.\\2')\n  s.gsub!(/([?!])\\\
    .([A-Z])/,'\\1\\.\\2')\n  s.gsub!(/([?!])\\.([A-Z])/,'\\1\\.\\2')\n  s.gsub!(/([?!])\\\
    .([A-Z])/,'\\1\\.\\2')\n  s.gsub!(/([?!])\\.([A-Z])/,'\\1\\.\\2')\n  s.gsub!(/([?!])\\\
    .([A-Z])/,'\\1\\.\\2')\n  s.gsub!(/([?!])\\.([A-Z])/,'\\1\\.\\2')\n  s.gsub!(/([?!])\\\
    .([A-Z])/,'\\1\\.\\2')\n  s.gsub!(/([?!])\\.([A-Z])/,'\\1\\.\\2')\n  s.gsub!(/([?!])\\\
    .([A-Z])/,'\\1\\.\\2')\n  s.gsub!(/([?!])\\.([A-Z])/,'\\1\\.\\2')\n  s.gsub!(/([?!])\\\
    .([A-Z])/,'\\1\\.\\2')\n  s.gsub!(/([?!])\\.([A-Z])/,'\\1\\.\\2')\n  s.gsub!(/([?!])\\\
    .([A-Z])/,'\\1\\.\\2')\n  s.gsub!(/([?!])\\.([A-Z])/,'\\1\\.\\2')\n  s.gsub!(/([?!])\\\
    .([A-Z])/,'\\1\\.\\2')\n  s.gsub!(/([?!])\\.([A-Z])/,'\\1\\.\\2')\n  s.gsub!(/([?!])\\\
    .([A-Z])/,'\\1\\.\\2')\n  s.gsub!(/([?!])\\.([A-Z])/,'\\1\\.\\2')\n  s.gsub!(/([?!])\\\
    .([A-Z])/,'\\1\\.\\2')\n  s.gsub!(/([?!])\\.([A-Z])/,'\\1\\.\\2')\n  s.gsub!(/([?!])\\\
    .([A-Z])/,'\\1\\.\\2')\n  s.gsub!(/([?!])\\.([A-Z])/,'\\1\\.\\2')\n  s.gsub!(/",
  "  s.gsub(/\\.|[!?.]/, \"\").empty?\nend", "  (0..s.size).each do |i|\n    if s[i]\
    \ == \".\" \n      p 0\n    elsif s[i] == \"?\"\n      p 1\n    elsif s[i] ==\
    \ \"!\"\n      p -1\n    else\n      p 0\n    end\n  end\nend\n</code>\n<|/ a\
    \ tags=ruby,ruby-on-rails,ruby-on-rails-3,rubygems |>\n<| a dscore=0 |>\n<code>\n\
    is_bored = \"Hello world. Today is sunny.\"\nis_bored.gsub(/[.?!]/).inject(0)\
    \ {|s,c| s+(c==\".\")*1 }\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3,rubygems\
    \ |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3,rubygems |>\nHere is another\
    \ solution that is faster than the other solutions in this thread but maybe not\
    \ the most elegant, but I think it can be easier to understand:\n<code>", "  return\
    \ s.index(\"I\") == 0 or s.index(\".\")\nend", "  s.chars.each{|c| return 0 unless\
    \ c == '.' && s.starts_with?(\"I\") }\n  s.count(\".\") + s.count(\"?\") + s.count(\"\
    !\")\nend", "  s.split('.').inject(0) do |n, s| \n    n.to_i + (s.to_s =~ /^I/\
    \ ? 1 : 0)\n  end\nend", "  s = string.gsub('.','',s)\n  s = string.gsub('?','',s)\n\
    \  s = string.gsub('!','',s)\n  if s.start_with?('I')\n    return 1\n  else\n\
    \    return 0\n  end\nend", "  boredom_chars = ['I', 'a']\n  boredom_words = [\"\
    hello\", \"hey\", \"hay\", \"howdy\", \"help\", \"hello\"]\n  word_count = 0\n\
    \  s = s[0..-2]", "  bored_words = %w[I she]\n  s.split(\" \").each_with_index\
    \ do |word, i|\n    if bored_words.include?(word)\n      s.split(\" \").size -\
    \ i - 1\n    end\n  end\nend", "    count=0\n    i=s.index(\"I\")\n    while i<=len(s)-1\
    \ and s[i]=='.' and s[i+1]=='.' and s[i+2]=='?' and s[i+3]=='!' and s[i+4]=='?'\
    \ and s[i+5]=='!' and s[i+6]=='?' and s[i+7]=='!' and s[i+8]=='?'\n        i+=8\
    \ #skip past all punctuation\n        i+=1 #skip past first punctuation mark\n\
    \        i+=1\n        i+=1 #skip past first punctuation mark\n        i+=1 #skip\
    \ past first punctuation mark\n        i+=1 #skip past first punctuation mark\n\
    \        i+=1 #skip past first punctuation mark\n        i+=1\n        i+=1\n\
    \        i+=1\n        i+=1\n        i+=1\n        i+=1\n        i+=1\n      \
    \  i+=1\n        i+=1\n        i+=1\n        i+=1\n        i+=1\n        i+=1\n\
    \        i+=1\n        i+=1\n        i+=1\n        i+=1\n        i+=1\n      \
    \  i+=1\n        i+=1\n        i+=1\n        i+=1\n        i+=1\n        i+=1\n\
    \        i+=1\n        i+=1\n        i+=1\n        i+=1\n        i+=1\n      \
    \  i+=1\n        i+=1\n        i+=1\n        i+=1\n        i+=1\n        i+=1\n\
    \        i+=1\n        i+=1\n        i+=1\n        i+=1\n        i+=1\n      \
    \  i+=1\n        i+=1\n        i+=1\n        i+=1\n        i+=1\n        i+=1\n\
    \        i+=1\n        i+=1\n        i+=1\n        i+=1\n        i+=1\n      \
    \  i+=1\n        i+=1\n        i+=1\n        i+=1\n        i+=1\n        i+=1\n\
    \        i+=1\n        i+=1\n        i+=1\n        i+=1\n        i+=1\n      \
    \  i+=1\n        i+=1\n        i+=1\n        i+=1\n        i+=1\n        i+=1\n\
    \        i+=1\n        i+=1\n        i+=1\n        i+=1\n        i+=1\n      \
    \  i+=1\n        i+=1\n        i+=1\n        i+=1\n        i+=1\n        i+=1\n\
    \        i+=1\n        i+=1\n        i+=1\n        i+=1\n        i+=1\n      \
    \  i+=1\n        i+=1\n        i+=1\n        i+=1\n        i+=1\n        i+=1\n\
    \        i+=1\n        i+", "  return s.index(\"I\") != 0 and s.index(\".\")\n\
    end", "  s.scan(/\\?+/)\n  s.scan(/\\./)\n  s.scan(/!+/)\n  s.scan(/[^.?!]+/)\n\
    end\n</cell>\n<text>\nNext we create a function called is_bored_to that will count\
    \ the boredoms by sentence. \nNote that is_bored takes a string and returns a\
    \ number. is_bored_to takes a sentence and returns the boredoms it contains.",
  "    count = 0\n    words = s.split(\" \")\n    words.each do |word|\n      if word\
    \ == \"I\"\n        count += 1\n      end\n    end\n    return count\nend", " \
    \ s.split('.').map.with_index{|s,i| s.start_with?(\"I\") && i%2 == 0}\nend", " \
    \ s.split(/(?=[.,!?])/).inject(0) { |count, word| count + (word.start_with?(\"\
    I\") ? 1 : 0) }\nend\n</pre>\n</div>", "  s.split('.').map { |w| w.start_with?(\"\
    I\") ? 1 : 0 }.reduce(:+)\nend\n</code>\n(Note that this code will give the right\
    \ answer for all inputs, but won't give the right answer for inputs with multiple\
    \ boredoms \u2014\_\"The sky is blue. The sun is shining. I love this weather.\"\
    \ would return 2, not 1).\nAs far as complexity goes, the code is fairly simple,\
    \ although I haven't tested it (I'm in a bit of a hurry!). It basically just counts\
    \ the number of occurrences of the boredom word in the sentence with the .split()\
    \ method, converts the array into an array of arrays by splitting on '.', '?',\
    \ and '!', and finds the sum of the sub-arrays whose strings start with \"I\"\
    , using the .start_with? method.\n(Incidentally, as far as complexity goes, your\
    \ original code does a lot of unnecessary work that is just complicating the code.\
    \ This code is pretty easy to read, and probably easy to understand.)\n<|/ a tags=ruby\
    \ dscore=1 |>\n<| c |>\nThanks for the explanation. Just to confirm: The complexity\
    \ of this function is O(n)?\n<|/ c |>\n<| c |>\nYes, this is O(n).\n<|/ c |>\n\
    <| c |>\n\"complexity of this function is O(n)?\" No it's not. It's O(n*m) where\
    \ m is the number of boredoms (which could be more than 1), which would be pretty\
    \ bad.\n<|/ c |>\n<| c |>\nOkay I see. I think we were all overthinking it. Thank\
    \ you all for the input!\n<|/ c |>\n<| a tags=ruby dscore=0 |>\nYou can use regular\
    \ expressions to search for patterns like this one :\n<code>\n /\\bi\\b/i\n</code>\n\
    and match a word between brackets.\n<|/ a |>\n<| a tags=ruby |>\nHow about this:\n\
    <code>", "  s.split(/(\\.|\\?|\\!)/).each do |word|\n    if word[0]==\"I\"\n \
    \     return 0\n    end\n  end\n  return 1\nend", "  s.scan(/I[\\S]*|\\.|!/)\n\
    end", "    # Remove white space and split into sentences based on deliminators\n\
    \    sentences = s.gsub(/[\\.\\?\\!]+/, \" \").split(\" \")\n    bored_count =\
    \ 0\n    bored_sentences = []\n    \n    # Go through each sentence\n    # If\
    \ the first letter of the sentence is 'I', then add it to the count of bored sentences\n\
    \    sentences.each do |sentence|\n        if sentence[0] =~ /I/\n           \
    \ bored_count += 1\n            bored_sentences << sentence\n        end\n   \
    \ end\n    \n    # Return the number of bored sentences\n    bored_count\nend",
  "  s.split\n  s.downcase\n  s.chomp\n  if s.starts_with?(\"i\")\n    1\n  else\n\
    \    0\n  end\nend\n</pre>", "  s.scan(/\\bI\\b/)\n  return s.length == 0\nend",
  "    bored = s.gsub(/^(I\\S+|\\.|\\?|!)+/, \"\")\n    return bored != \"\"\nend",
  "  # BEGIN SOLUTION\n  return 0 if s[0] == \"I\" else 1\n  # END SOLUTION", "  \
    \  boredoms = s[:s.index(\".\")]\n    if s.index(\"!\") != -1 and s.index(\"?\"\
    ) != -1 and s.index(\".\") != -1\n        boredoms = boredoms + \".\" + s[s.index(\"\
    !\") + 1:s.index(\"?\")] + \".\" + s[s.index(\"?\") + 1:s.index(\".\")]\n    end\n\
    \    return boredoms == boredom_words\nend", "    return s.count(\"I\") + s.count(\"\
    .\") + s.count(\"?\") + s.count(\"!\")\nend", "  s.gsub(/[\\.\\?\\!]*/, \"\").each_char.inject(0)\
    \ {|n,c| n + (c == \"I\" ? 1 : 0)}\nend", "  return 0 if s[0] == 'I' or s.count('.')\
    \ % 3 or s.count('?') % 3 or s.count('!') % 3 else 1\nend\n</cell>\n<code language=julia-1.5>",
  "  s.gsub(/\\W+/) do |word|\n    word == \"I\" ? 0 : 1\n  end\nend", "  bored =\
    \ 0\n  \n  # Your code here\n  s = s.split(\".\").grep(/./).grep(/[?!]/).map(&:strip).count\n\
    \  \n  \n  # Your code here\n  return bored", "  return s.split(/\\.|\\?|!/).length>1\n\
    end", "\tbored = 0\n\ti = 0\n\twhile i < s.length and s[i] == \" \" do\n\t\ti\
    \ += 1\n\twhile i < s.length do\n\t\tif s[i] == \"I\" or s[i] == \"i\" or s[i]\
    \ == \"a\" then\n\t\t\ti = i + 1\n\t\t\tif s[i] == \".\" or s[i] == \"?\" or s[i]\
    \ == \"!\" then\n\t\t\t\tbored = bored + 1\n\t\ti = i + 1\n\treturn bored\nend",
  "  return s.count('I') > 0", '  return 1 if s[0] == "I" and s[1] == "." else 0',
  "    boreds = Hash.new(0)\n    s.scan(/[a-z]\\.|[\\.?!]\\s?/) do |x|\n      if boreds[x]\n\
    \        boreds[x] += 1\n      else\n        boreds[x] = 1\n      end\n    end\n\
    \    boreds\nend\n</pre>\n<p>\nAnother way to do this is to use <tt>Hash.new</tt>\
    \ and <tt>merge</tt>. This\nis an alternative way of writing <tt>boreds</tt>:\n\
    </p>\n<pre class=\"ruby\">\nboreds = {}\ns.scan(/[a-z]\\.|[\\.?!]\\s?/) do |x|\n\
    \  boreds.merge(x) do |k, v|\n    (boreds.has_key?(k) ? boreds[k]+1 : 1)\n  end\n\
    end\n</pre>\n<p>\n<tt>Hash.new</tt> is a shortcut for <tt>Hash.new { |h,k| h[k]=0\
    \ }</tt>, which is\nan anonymous function that is passed a hash to fill in for\
    \ its default value.\nThe default value is returned if the key is not found.\n\
    </p>", "    boredoms = 0\n    words = s.split(\" \")\n    \n    if words[0] ==\
    \ \"I\"\n        return 1\n    else\n        return 0 \n    ", "    count_boredom\
    \ = 0\n    if s ~= nil and s !~ /^(\\.|[?!])/\n        count_boredom = s.split(\"\
    \ \").inject(0) {|c,v|(c+=1 if v==\"I\")}\n    end\n    return count_boredom\n\
    end", "  s.count(\"I\") == 0\nend", "  return s.match(/(^|\\s)I(^|\\s)/)\nend\n\
    </cell>\n<text>\nThe is_bored function will take the sentence \"Hello world\"\
    \ as an input, and return the number of times the word \"I\" is in the sentence,\
    \ which is 0. is_bored also takes an optional argument stop_words, which if given,\
    \ is a list of the words that are not to be counted. Stop words are words that\
    \ are rare and aren't important to our predictions. We'll talk about stop words\
    \ more in the next chapter.", "    count = 0\n    if s[0,1] == \"I\"\n       \
    \ count += 1\n    end\nend\n</code>\n<|/ a dscore=2 |>\n<| a |>\nI prefer the\
    \ below one. It only uses one line. No loops and no counter variable.\n<code>\n\
    str = \"The sky is blue. The sun is shining. I love this weather.\"\nstr.split(\"\
    \ \").count(\"I\".to_sym)\n</code>\n<|/ a tags=ruby dscore=2 |>\n<| a dscore=2\
    \ |>\nAs in Ruby 1.9 you can also use String#include?(other_str) to check if the\
    \ string contains the substring you are looking for:\n<code>\nif str.include?(\"\
    I\")\n    count += 1\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby dscore=2\
    \ |>\n<code>", "\ts.split(\" \").inject(0) { |sum,e| sum+1 if e == \"I\" } ==\
    \ 0\nend", "    # Split the string into a list\n    arr = s.split(\" \".join)",
  "  s.split.include? \"I\"\nend", "  s.split(\" \").each do |word|\n    if word =~\
    \ /I/ and word !~ /\\.?!?/\n      return 1\n    end\n  end\n  0\nend", "  s.scan(/\\\
    b(I(?:\\s+|\\.{1,})?|!?)/)\n  return s.scan(/\\b(?:I|!)\\b\\z/).size > 0\nend",
  "  if s.nil? then return 0 end\n  s = s.to_s\n  if s.start_with?('I')\n    count=0\n\
    \    s.gsub!(/I/,\"\").gsub!(/[.?!]/,'').split(//).each do |w|\n      if w.match(/\\\
    w+/) and w.to_i.between(1,10)\n        count=count+1\n      end\n    end\n   \
    \ return count\n  else\n    return 0\n  end\nend", "  s = s.chomp\n  return s.split(\"\
    . ? !\").inject(0) do |memo, word|\n    return memo if word.starts_with?(\"I\"\
    )\n    memo += 1\n  end\nend", "  s = s.to_s.split(%r{\\.\\.|\\?|\\!})\n  s.each\
    \ do |word|\n    if word[0,1] == \"I\"\n      return 1\n    end\n  end\n  return\
    \ 0\nend", "  s.split(\".\").each do |word|\n    return 1 if word == \"I\"\n \
    \ end\n  0\nend", "  s.gsub!(/\\..*?\\..*?/, '.')\n  s.gsub!(/\\?.*?\\?/, '?')\n\
    \  s.gsub!(/!.*!/, '!')\n  return s.split(\" \").map(&:capitalize).count(&:starts_with?(\"\
    I\"))\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails dscore=2 |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\n<code>", "  s.downcase!\n  s.gsub!('\\.','')\n  s.gsub!('\\?','')\n  s.gsub!('!','')\n\
    \  return s.downcase[0..1].to_i==s.downcase[0].to_i\nend", "  return s.index(\"\
    I\") != 0\nend", "  return 1 if s[0] == \"I\" else 0\nend", "  s = s.split(%r{\\\
    .|\\?|\\!})\n  s.each do |word|\n    if word == \"I\"\n      return 0\n    end\n\
    \  end\n  return 1\nend", "  s.gsub!(/[\\.\\?!]/,\"\") \n  s.start_with?(\"I\"\
    )\nend", "  words = s.split('.')\n  i = 0\n  while i < words.length do\n    if\
    \ words[i][0] == 'I'\n      return i\n    i += 1\n  end\n  return 0\nend", " \
    \ s = s.chomp\n  s = s[0].chomp\n  s.downcase!\n  return s.start_with?(\"i\")\n\
    end", "    # Split string into list by delimiter\n    tokens = s.split('.')",
  "  s = string.split(s)\n  return s.first(:condition, /^I$/) == nil\nend", "  return\
    \ s.index(\"I\") != 0\nend", "  s.scan(/I\\b/ do |m| return 1; end)\n  0\nend",
  "  bored_count = 0\n  s.gsub!(/([.?!])(I)/) {|s| bored_count +=1; s+\"+\"}\n  return\
    \ bored_count\nend", "  s.split(\" \").each do |word|\n    return 0 if word =~\
    \ /I|i|I+/\n  end\n  return 1\nend", "  s.split(\".\").inject([:count]) { |t,\
    \ c| t += 1 if c[0] == \"I\" }\nend\n</cell>\n<code language=julia-0.6>\nis_bored(x)\n\
    </cell>\n<text>\nThe @timed macro records how long a particular function took\
    \ to run by recording how long it takes to evaluate the expression in the parentheses\
    \ after the function name.", "  return s.count(\"I\") == 0 \nend", "    return\
    \ s.index('I') != 0\nend\n</cell>\n<cell>", "  s.gsub!(/[\\.\\?\\!]/,\"\")\n \
    \ s.gsub!(/I/,\"\")\n  s.scan(/[.?!]/)\nend", "    return s.index(\"I\") == 0\n\
    end", "\tboredoms = 0\n\tsplit_s = s.split(\".\")\n\tfor boredom_sentence in split_s\n\
    \t\tif boredom_sentence.start_with?(\"I\")\n\t\t\tboredoms += 1\n\t\tend\n\tend\n\
    \tboredoms\nend\nis_bored\n</cell>\n<cell>", "  (0..s.length).find { |i| s[i]\
    \ == \"I\" } == 0\nend", "    count = 0\n    boredoms = [ \"I\", \"me\", \"my\"\
    , \"myself\", \"we\", \"our\", \"ours\", \"ourselves\", \"you\", \"your\", \"\
    yours\", \"yourself\", \"yourselves\", \"he\", \"him\", \"his\", \"himself\",\
    \ \"she\", \"her\", \"hers\", \"herself\", \"it\", \"its\", \"itself\", \"they\"\
    , \"them\", \"their\", \"theirs\", \"themselves\", \"what\", \"which\", \"who\"\
    , \"whom\", \"this\", \"that\", \"these\", \"those\", \"am\", \"is\", \"are\"\
    , \"was\", \"were\", \"be\", \"been\", \"being\", \"have\", \"has\", \"had\",\
    \ \"having\", \"do\", \"does\", \"did\", \"doing\", \"a\", \"an\", \"the\", \"\
    and\", \"but\", \"if\", \"or\", \"because\", \"as\", \"until\", \"while\", \"\
    of\", \"at\", \"by\", \"for\", \"with\", \"about\", \"against\", \"between\",\
    \ \"into\", \"through\", \"during\", \"before\", \"after\", \"above\", \"below\"\
    , \"to\", \"from\", \"up\", \"down\", \"in\", \"out\", \"on\", \"off\", \"over\"\
    , \"under\", \"again\", \"further\", \"then\", \"once\", \"here\", \"there\",\
    \ \"when\", \"where\", \"why\", \"how\", \"all\", \"any\", \"both\", \"each\"\
    , \"few\", \"more\", \"most\", \"other\", \"some\", \"such\", \"no\", \"nor\"\
    , \"not\", \"only\", \"own\", \"same\", \"so\", \"than\", \"too\", \"very\", \"\
    s\", \"t\", \"can\", \"will\", \"just\", \"don\", \"should\", \"now\"]", "  s,\
    \ _, e = s.partition('.')\n  s, _, e = s.partition('?')\n  s, _, e = s.partition('!')\n\
    \  return e.nil?\nend", "  s.split(' ').select{|w| w =~ /^[Ii][a-zA-Z\\!\\?]+/}.count('I')\n\
    end", "  s.scan(/\\b[iI]\\b/i).length <= 1\nend", "    boredom = s.count(\"I\"\
    )\n    \n    return boredom\n</cell>\n<cell>\nis_bored.call(\"Hello world\")\n\
    </cell>\n<cell>\nis_bored.call(\"The sky is blue. The sun is shining. I love this\
    \ weather\")\n</cell>\n<cell>", "  s.chars.all? { |c| c == ?. or c == ?! or c\
    \ == . or c == ? }\nend", "  s.gsub!(/\\.{2,}/, \".\")\n  s.gsub!(/[?!]/, \"\"\
    )\n  if s =~ /^I\\w*/\n    0\n  else\n    1\n  end\nend\n</cell>\n<code language=julia-1.3>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
