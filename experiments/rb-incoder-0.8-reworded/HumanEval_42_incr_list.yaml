name: HumanEval_42_incr_list
language: rb
prompt: "# Return array with elements incremented by 1.\n# >>> incr_list.call([1,\
  \ 2, 3])\n# [2, 3, 4]\n# >>> incr_list.call([5, 3, 5, 2, 3, 3, 9, 0, 123])\n# [6,\
  \ 4, 6, 3, 4, 4, 10, 1, 124]\ndef incr_list(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_incr_list\n\
  \    candidate = method(:incr_list)\n    assert_equal([], candidate.call([]))\n\
  \    assert_equal([4, 3, 2], candidate.call([3, 2, 1]))\n    assert_equal([6, 3,\
  \ 6, 3, 4, 4, 10, 1, 124], candidate.call([5, 2, 5, 2, 3, 3, 9, 0, 123]))\n  end\n\
  end\n"
completions: ["  return l + ([0] * (l.size - l.count))\nend", "  l.each_with_index\
    \ do |element, index|\n    l[index + 1] = element\n  end\n  l\nend\n</code>\n\
    As I mentioned, I used each_with_index to avoid the need to reassign the variable\
    \ l back to its original value. You can then use that return value as the argument\
    \ to the incr_list function in other places.\nYou can then rewrite the incr_list\
    \ function to use map instead of each_with_index as follows:\n<code>", "  l.inject(1)\
    \ do |x, el| x + el end\nend\n</cell>\n<cell>", "  return [x + 1 for x in l]\n\
    end", "  return Array.new(l.length) { |i| l[i.to_i + 1] }\nend", "  return l.inject\
    \ { |m,x| m + 1 }\nend", "  l.inject(0) {|m, i| m += 1; [m, i]}\nend\n</code>\n\
    <|/ a tags=list,ruby |>\n<| c |>\nThis doesn't work for `incr_list([1, [2,3,4],\
    \ [4, 5]]);`\n<|/ c |>\n<| c |>\nIt works perfectly for `incr_list([1, [2,3,4],\
    \ [4, 5]])`, because the elements are of the same type. I think that should have\
    \ been stated in the question.\n<|/ c |>\n<| c |>\nI believe that OP wants the\
    \ result to be `[[1, 2], [2,3]]` and not `[[1, 3], [3,4], [4,5]]`. It's not clear\
    \ to me from the question whether it only counts the number of elements once.\n\
    <|/ c |>\n<| c |>\nYes, you are right, it should have been stated in the question.\
    \ Thank you for pointing out\n<|/ c |>\n<| c |>\nI believe that OP wants [2, 3,\
    \ 4] returned as [[1, 2], [2,3]] instead of [2, 3, 4]\n<|/ c |>\n<| a |>\n<code>",
  "  l.length += 1 # increment length by 1\n  l.slice!(0, l.length)\nend", "  l.each_with_index\
    \ { |x, i| l[i] = l[i] + 1 }\n  l\nend", "  l.inject(0, :+)\nend", "  return l.map(&:next)\n\
    end", "    l.each_index do |i|\n        l[i + 1] = l[i] + 1\n    end\n    l\n\
    end", "  l.each_index { |i| l[i] += 1; l[i] }\n  l\nend", "  return l + [1]\n\
    end", "  l.inject(0) { |sum, e| sum + e }\nend", "\tl.each do |i|\n\t\tl.push\
    \ i+1\n\tend\n\tl\nend", "  l.last.next = (l.last ? l.last.next.next : nil)\n\
    \  l.last\nend", "  l.concat l.map { |e| e + 1 }\nend\n</code>\nThis also demonstrates\
    \ why Ruby has a very concise way of expressing a range of the form (0..n-1).\n\
    <|/ a tags=ruby |>\n<| c |>\n`range` is also a very concise way of expressing\
    \ a range. It's only a very concise way of expressing a range. `1..5` would have\
    \ taken you less time to write than `0..5`. And it's easier to read than `(1..5).to_a`.\
    \ And it's easier to read than `[*1..5]`. But it's not as concise as `*1..5`.\
    \ And it's not as concise as `0..5`.\n<|/ c |>\n<| c |>\nThat's true, but `range`\
    \ is concise _and_ readable, especially when paired with `(1..5).to_a` as in the\
    \ example.  `range` also makes it clear that you mean to pass it to another method\
    \ that expects an array, whereas `*1..5` leaves it up to the reader to figure\
    \ out what the intent was.\n<|/ c |>\n<| a dscore=5 tags=ruby |>\nWhat you are\
    \ looking for is called splat operator", "  l.each_with_index do |e, i|\n    if\
    \ e != nil\n      l[i + 1] = e\n    end\n  end\n  l\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nThis doesn't actually return the array\n<|/ c |>\n<| c |>\nThis\
    \ isn't going to work, since `each_with_index` doesn't return anything. It just\
    \ passes the values along to some other method, which may or may not modify them.\n\
    <|/ c |>\n<| c |>\nIt does work, if you use the splat operator on the original\
    \ array. Also, `each_with_index` does return the array in its original state.\
    \ Why do you think it does not?\n<|/ c |>\n<| c |>\n: It still returns `nil` when\
    \ it does return, because it returns `nil`.\n<|/ c |>\n<| c |>\nAh, yes. I got\
    \ confused because the OP's example code was written to expect a mutable array.\
    \ I'd say it's bad design to try to force Ruby into doing something that it doesn't\
    \ want to do.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  return [].concat(l).each_with_index.map\
    \ { |e, i| i + e }\nend", "    l.map { |x| x + 1 }\nend\n</cell>\n<code language=julia-1.5>\n\
    @time incr_list(nlist)\n@time incr_list(llist)\n</cell>\n<code language=julia-1.5>\n\
    function incr_list_par(l)\n    for x in l\n        x + 1\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@time incr_list_par(nlist)\n@time incr_list_par(llist)\n\
    </cell>\n<code language=julia-1.5>\nfunction incr_list_par2($l)\n    $l\n    for\
    \ x in $l\n        x + 1\n    end\nend\n</cell>\n<code language=julia-1.5>\n@time\
    \ incr_list_par2(llist)\n</cell>\n<text>\nSlicing", "  l.each do |el|\n    next\
    \ el if el.is_a? Numeric\n    el = el.to_i\n    el += 1\n  end\n  l\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a |>\nA solution that uses Ruby's Enumerable methods -\n\
    <code>", "  if l[-1].is_a?(Integer)\n    l.length + l[-1]\n  else\n    l.length\n\
    \  end\nend", "  return l+[1, 1]\nend", "  l.call (l.map (&incr))\nend", "  return\
    \ l + [nil]\nend", "  l.reduce {|n, e| n + 1 }\nend", "  # Use reverse to guarantee\
    \ that values are shifted to the right in the incremented array.\n  l.reverse.shift(1)\n\
    \  l += [0]\n  l\nend", "\tsum = 1\n\tfor i in l\n\t\tsum *= i + 1\n\tsum\nend",
  "  l.call( l ) do |n|\n    n.next!\n  end\nend", "  l.each do |e|\n    e += 1\n\
    \  end\n  l\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| a dscore=2 |>\nJust for\
    \ fun, here's an iterative approach (with side effects!) that only uses the first\
    \ two items in the array (though it could easily be adapted to use any number\
    \ of items):\n<code>", "  l.map { |el| el + 1 }\nend", "  return l.reverse.each_cons(2).to_a.reverse\
    \ \nend", "  l.shift while l.size > 0\n  l\nend", "  return l.map{|x| x + 1}\n\
    end", "  return l + [1, 1]\nend", "  return l.each_with_index.map { |v, i| i +\
    \ 1 }.to_a\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis is a great answer.\
    \ One thing I would add is that if you need to pass an argument to the incr function,\
    \ you can do `incr(l, :some_arg)`\n<|/ c |>\n<| a tags=ruby,arrays dscore=5 |>\n\
    Ruby 1.9\n<code>\n[1,2,3].cycle.take_while { |x| x < 5 }", "  # Return the same\
    \ list instance with one element more\n  # than the current one.\n  # >>> incr_list.call([1,\
    \ 2, 3])\n  # [2, 3, 4]\n  # >>> incr_list.call([5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    \  # [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  l.length  += 1 \n  l.concat Array.wrap(l.first(l.length))\n\
    end", "  return l.incr(1)\nend", "  l.each_with_index {|e, i| l[i+1] = e}\n  l\n\
    end\n</code>\nTo apply the function to an array:\n<code>\nincr_list(arr).inspect\n\
    </code>\nOutput:\n<code>\n[\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"\
    8\", \"9\", \"10\", \"11\", \"12\"]\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby\
    \ |>\n<code>", "  l.each_with_index {|e, i| l[i+1] = e}\n  l\nend\n</code>\n<|/\
    \ a dscore=2 tags=ruby |>\n<| a |>\nAm I misunderstanding what you're trying to\
    \ do, or are you looking for something else?\n<code>", "  l.each do |item|\n \
    \   next if item.nil?\n    item += 1\n  end\n  l\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| a |>\nUsing a map should work:\n<code>", "  l.push (l.shift () + 1)\n\
    \  l\nend", "  return l.each_with_index.map { |e,i| i+1 }\nend", "  l = l.dup\n\
    \  l.inject(0, :+)\nend", "  l.each_with_index {|e, i| l[i] = l[i] + 1}\n  l\n\
    end", "    l.push( l.shift() + 1 )\n    return l\nend\n</cell>\n<cell>", "  #\
    \ TODO: Implement this function!\nend", "  l.map { |el| el + 1 }\nend", "  l.inject\
    \ { |sum, el| sum + el }\nend", "  return l + l[1..-1]\nend", "  return l.inject(0)\
    \ { |s, e| s + 1 }\nend", "  l.each do |i|\n    i = i + 1 unless i.odd?\n  end\n\
    \  l\nend\n</cell>\n<code language=julia-0.5>\nincr_list.(collect(1:12))\n</cell>\n\
    <code language=julia-0.5>\nincr_list.([1, 2, 3]) \n</cell>\n<code language=julia-0.5>\n\
    incr_list.([5, 3, 5, 2, 3, 3, 9, 0, 123])\n</cell>\n<text>\nPart 3 - Recursion",
  "  l.each { |i| l.delete i }\n  l.reject { |i| l.include?(i+1) }\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=1 |>\nHere's one more variation of Pavel's answer,\
    \ that doesn't require Ruby 1.9.1+ and doesn't require the use of delete_if. \n\
    <code>", "  l.reduce(0, :+)\nend\n</code>\nI realize this is an old thread, but\
    \ I thought I'd share my findings. \nBased on my tests, these solutions perform\
    \ relatively poorly and aren't very readable. Instead, I use these solutions when\
    \ working with large arrays that are not amenable to in-place modification.\n\
    <|/ a dscore=5 tags=ruby |>\n<| c |>\nYou do not need to add `end` to a class\
    \ definition.\n<|/ c |>\n<| c |>\nThat's really interesting. This seems pretty\
    \ smart, but I'm surprised it hasn't been done before. Is there a particular reason\
    \ you prefer the `each_with_index` approach to the `inject` one?\n<|/ c |>\n<|\
    \ c |>\n`each_with_index` makes it clear that we are working with indices rather\
    \ than values and it allows me to avoid an extra level of nesting.\n<|/ c |>\n\
    <| c |>\nThe performance of the each_with_index approach seems highly dependent\
    \ on the size of the array, e.g., `10000.to_a.each_with_index.inject(0) do |sum,\
    \ (el, i)| sum += el * i; sum #=> 9999` whereas the inject approach gives me `1.1715`\
    \ microseconds (and 1.1715 seconds respectively) for the same array size.  Do\
    \ you know why?\n<|/ c |>\n<| c |>\nI think it's because it creates a temp array\
    \ when it is done processing (just like in the other solutions). So it's actually\
    \ slower. In addition, if you have lots of elements in your array, using each_with_index\
    \ is actually more efficient than using inject. My benchmark is on arrays with\
    \ 10 elements and 5 million elements. It took 0.062 seconds to create an array\
    \ with 10 elements and use inject. 1.1715 seconds to do the same using each_with_index.\
    \ I suggest using each_with_index if you have more than 10 elements in your array\
    \ and you don't care about performance.\n<|/ c |>\n<| a tags=ruby |>\nFor those\
    \ of you that have some experience with inject, you may find this more readable.\
    \  It is more similar to each_with_index but also allows the index to be passed\
    \ in, if needed.\n<code>", "  return l[0] + incr_list(tail(l, 1))\nend", "  #\
    \ Using `each` means we can use lists whose contents don't change with\n  # their\
    \ indices.\n  l.each { |i| i.next! }\n  l\nend", "  l.length += 1 if l.length\
    \ >= 0 else 0\n  l.each { |x| x = x + 1 }\n  l\nend", "  # If l is empty return\
    \ an empty list.\n  return l ? l[-1] + 1 : []\nend", "  return Array.new(l + 1,\
    \ (l[1] || 0) + (l[2] || 0))\nend", "  return l + ( [ l[0] ] if l.size > 0 else\
    \ [] )\nend\n</cell>\n<code language=julia-0.6>\nincr_list([10, 8, 9])\n</cell>\n\
    <text>\nDefining functions\nDefining functions is the last bit of coding you need\
    \ to do. We've already seen the syntax for creating and calling functions, but\
    \ we haven't covered the syntax for defining functions.", "  l.each do |x| x +=\
    \ 1; yield x end\nend", "  l.map! {|n| n + 1} or raise ArgumentError, \"expected\
    \ list with increment\"\n  l\nend", "  return reduce(lambda x, y: x + 1, l, [])\n\
    end", "  l.push( l.shift )\nend\n</cell>\n<code language=julia-1.6>", "  l.length\
    \ += 1 if l else 0\nend", "  return l + l\nend", "  new_list = []\n  index = 0\n\
    \  while index < l.length\n    new_list.push l[index + 1]\n    index += 1\n  end\n\
    \  new_list\nend", "  return l.clone.zip(l).inject(:+).sort\nend", "  return l\
    \ + [1]\nend\nadd_method(Integer, 'call', incr_list)", "  result = []\n  i = nil",
  "\tn = l.size\n\tn.zero?\n\t\tl\n\telse\n\t\t(1..n).map { |i| l[i] }\n\tend\nend",
  "  return l + [nil]\nend", "  l.inject(0, :+)\nend", "  l.length\n  l.unshift l.length\
    \ +1\n  l\nend", "  return l.length\nend", "  l.each do |i|\n    i +=1\n  end\n\
    \  l\nend", "  l.each do |i|\n    l.push i + 1\n  end\n  l\nend", "\tl = l.to_a\
    \ if l and l.respond_to?(:to_a) rescue l\n\tl = l.to_a if l and l.respond_to?(:to_a)\
    \ rescue l\n\tl ||= []\n\tresult = 1\n\tl.each_with_index do |e, i|\n\t\tresult\
    \ += 1 if e != nil\n\t\tl[i] = l[i] || 0\n\t\tl[i] += result\n\tend\n\tl\nend",
  "    l.push(l.pop + 1)\nend", "  if l == nil\n    l = []\n  end\n  i = 0\n  while\
    \ i < l.length\n    l[i] = l[i] + 1\n    i += 1\n  end\n  return l\nend", "  l.each\
    \ do |x|\n    x += 1\n    yield x\n  end\nend", "  l.map!{|v| v + 1}\nend", " \
    \ l.push(l.shift)\n  l\nend", "  l.each_with_index { |x, i| l[i+1] = x + 1 }\n\
    \  l\nend", "  return l.inject(0, :+)\nend", "    l.each do |n|\n        n.succ\n\
    \    end\nend\n</cell>\n<text>\nExercise: Add two vectors, returning a new vector\
    \ that is the sum of the two vectors.", "  l[0], l[1] = l[1], l[0]+l[1]\n  return\
    \ l\nend\n@test incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123]) == incr_list([6, 4, 6,\
    \ 3, 4, 4, 10, 1, 124])", "  # Sum all elements of l, then add 1 for each element\
    \ of l that is not zero.\n  l.inject(0) {|sum, i| sum + i if i > 0} + 1\nend",
  "  return l.map(&:next).inject(:+)\nend\n</code>\nNow if you run this\n<code>\n\
    incr_list([1, 2, 3])", "  return [x + 1 for x in l]\nend", '  return l + l', " \
    \ return [x + 1 for x in l]\nend", "  i = nil\n  l.each_with_index do |n, i|\n\
    \    i += 1\n    l[i] = n\n  end\n  l\nend", "  l.push l.shift\n  l\nend", " \
    \   l.each_index { |i| l[i+1] = l[i].to_i + 1 }\n    l\nend\n</code>\n<|/ a dscore=1\
    \ tags=ruby |>\n<| c |>\nThis is an example of where Ruby's Enumerable mixin helps\
    \ reduce code complexity and make it more readable. An alternate solution would\
    \ involve a more complex object inheritance chain, though.\n<|/ c |>\n<| a |>\n\
    It's also possible to use a variable as an index.  In your loop, you could do\
    \ something like:\n<code>", "  l.each do |x|\n    x.succ!\n  end\n  l\nend", " \
    \ l.map {|x| x + 1}\nend\n</pre>", "  return l.reduce { |a, b| a + 1 }\nend",
  "  # Create a list with incremented elements.\n  return [*l].tap { |a| a.each_with_index\
    \ { |e, i| a[i + 1] = i + 1 } }\nend", "  l.map! { |x| x + 1 }\n  l\nend\n</code>\n\
    <|/ a |>\n<| a dscore=0 tags=ruby,increment,range |>\nI wrote this for a job interview\
    \ where I had to do something similar.\n<code>", "  l.map! { |x| x + 1 }\n  l\n\
    end", "  # Create list with initial elements l.\n  r = []\n  r.concat(l)\n  r.each\
    \ { |e| e += 1 }\n  return r\nend", "  return l.each_with_index.map { |e, i| i\
    \ + 1 }\nend", "  l.length\n  l.length.times {l.push l[l.length-1]+1; nil}\nend",
  "    l.inject(0, :+)\nend", "  l.length()\n  l.push( l.last() + 1 )\nend", "  @array_call\
    \ l\nend", "  l\nend", "  return l.map { |x| x + 1 }\nend", "  l.inject(0) do\
    \ |sum, element|\n    sum + element\n  end\nend\n</pre>\n</div>", "  l.inject(0,\
    \ :+).to_a\nend\n</code>\n<|/ a tags=ruby-on-rails,ruby |>\n<| a dscore=1 |>\n\
    Using Ruby 2.7.0 you can just do:\n<code>\n(1..5).map(&:succ)", "  l.length()\
    \ ? l + [1, *l] : [l]\nend", "    l.each_with_index { |e, i| l[i] = l[i] + 1 }\n\
    \    l\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI like your use of yield. Very\
    \ nice. Not quite sure where yield comes into this, as you're simply yielding\
    \ the value `i+1`. Not sure why your example would be better. I can see how this\
    \ would be useful, but as I understand it, it would be slower than a `for` loop\
    \ (because you're calling the function multiple times).\n<|/ c |>\n<| c |>\nI\
    \ added a second solution which shows how to do things in a functional way (more\
    \ like a map operation). You can always use the second solution if you don't need\
    \ a custom function.\n<|/ c |>\n<| c |>\nThanks for your reply. I was looking\
    \ for something like this but couldn't find it. I think it's because I wasn't\
    \ searching with the right terms. I knew it had to be something simple like this.\
    \ It's just that I'm new to Ruby. I've found a number of examples of creating\
    \ functions, but none that look like what I'm trying to do above.\n<|/ c |>\n\
    <| c |>\nI added a second solution which shows how to do things in a functional\
    \ way (more like a map operation). You can always use the second solution if you\
    \ don't need a custom function.\n<|/ c |>\n<| a tags=ruby,for-loop |>\nHere's\
    \ my take:\n<code>", "  l.each_with_index { |element, index| index += 1 }\n  l\n\
    end\n</code>\n<|/ a tags=ruby,arrays,indexing dscore=3 |>\n<| c |>\nThis is awesome,\
    \ thanks! I was unaware of the `.each_with_index` method.\n<|/ c |>\n<| a tags=ruby,arrays,indexing\
    \ dscore=2 |>\nYou could also use something like this:\n<code>", "  l.each_with_index\
    \ do |e, i|\n    l.insert(i + 1, e)\n  end\nend", "  l.empty? ? l : l.unshift(l.shift)\n\
    end", "  l.each do |n|\n    n += 1\n  end\nend", "  l.each do |i|\n    next if\
    \ i.nil?\n    i += 1\n  end\n  l\nend", '  return inject(l, :<<, 1); end', " \
    \ if l.is_a?(Array) and l.size == 0\n    []\n  else\n    l.map { |i| i + 1 }\n\
    \  end\nend\n</code>\nWith this implementation, you can simply do:\n<code>\narr\
    \ = (1..10).to_a\narr.incr\n</code>\n<|/ a dscore=5 tags=ruby |>\n<| c |>\nThis\
    \ is great! I love it!\n<|/ c |>\n<| a tags=ruby dscore=4 |>\nYou can just use\
    \ a counter.\n<code>\ncounter = [0, 1, 1, 1, 0 ... ]\n</code>\nNow you can call\
    \ incr on the counter:\n<code>\ncounter.incr\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ is not what `incr` does in terms of counting the number of times a value is\
    \ incremented. I think you need to specify what you want.\n<|/ c |>\n<| c |>\n\
    \"incr\" increments the value\n<|/ c |>\n<| c |>\nThe question is how do you increment/decrement\
    \ a value in place in ruby without creating a temporary variable.\n<|/ c |>\n\
    <| c |>\nWhat do you mean by \"increment\" in place? Are you trying to \"decrement\"\
    \ the value by one every time?\n<|/ c |>\n<| c |>\nYes, I am basically trying\
    \ to increment the value by one every time. I know I could write a loop but I\
    \ was wondering if there is a more ruby like way of doing this.\n<|/ c |>\n<|\
    \ a |>\nIt seems that incr and decr both work:\n<code>\n>> [1,2,3].incr\n=> [2,\
    \ 3, 4]\n>> [1,2,3].decr\n=> [1, 0, 2]\n</code>\n<|/ a tags=ruby dscore=4 |>\n\
    <| c |>\nNo, only `incr` increments the value by one. I guess you got confused\
    \ with [`Array#<<`](http://ruby-doc.org/core-2.2.0/Array.html#method-i-lshift).\n\
    <|/ c |>\n<| c |>\nOh, you meant `decr`?\n<|/ c |>\n<| c |>\nYes, that's what\
    \ I was looking for. Thanks!\n<|/ c |>\n<| c |>\nThe question was \"without creating\
    \ a temporary variable\". Hence the +1 from me.\n<|/ c |>\n<| a tags=ruby |>\n\
    You could use a Hash with a default value of 1\n<code>\narr = [1,2,3]\nhash =\
    \ Hash.new(1)\narr << hash # ", "  return l.inject(:+)\nend", "  l.size\n  l.map\
    \ { |x| x + 1 }\nend", "  l.each_with_index {|e, i| l[i] = l[i] + 1}\nend", " \
    \ @return [item+1, item for item in l]\nend", "  return l + [1]\nend", "  return\
    \ l.map(&:next).reduce(:+)\nend\n</cell>\n<cell>\nincr_list([1,2,3])\n</cell>\n\
    <cell>\nincr_list([5,3,5,2,3,3,9,0,123])\n</cell>\n<cell>", "  l.push l.shift\n\
    end", "  l.each_with_index do |v, i|\n    l[i] = v + 1 unless v.nil?\n  end\n\
    \  l\nend\n</cell>\n<cell>", "    l.append(l.pop(0)+1)\nend\n</cell>\n<text>\n\
    Calling incr_list on a list of length 123 works fine.", "  # We can't use Python's\
    \ increment_list because of its poor performance and\n  # failure for large lists.\
    \ Since we are not incrementing anything and just\n  # returning a new list with\
    \ incremented elements we can just use\n  # Ruby's map to increment the elements\
    \ in the given list.\n  l.map { |x| x + 1 }\nend\n</code>\n<|/ a tags=ruby,loops,ruby-on-rails\
    \ dscore=3 |>\n<| c |>\nNice! I never knew about that `map` method. Thank you!\n\
    <|/ c |>\n<| c |>\nYou could just do `l.map! { |x| x + 1 }` if you don't want\
    \ to mutate the original array.\n<|/ c |>\n<| c |>\n`map!` mutates the original\
    \ array. `map` doesn't though (`map` returns an enumerator). `map!` is safer and\
    \ more idiomatic, but won't work on an arbitrary number of arguments (unlike `map`)\n\
    <|/ c |>\n<| a |>\nYou can use the Enumerator class's map method and Enumerable#zip\
    \ method to get an iterator over multiple arrays.\n<code>", "  return l.map {\
    \ |n| n+1 }\nend", "  l.each_index do |i|\n    l[i+1] = l[i]+1\n  end\n  l\nend",
  "  return l[1..-1].inject(:+)\nend", "  @(l.is_a? Array) ? l.each_index { |i| l[i]\
    \ += 1 }\n                       : l += 1\n  l \nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nI like it, but this solution doesn't require an initialization\
    \ of an array. `incr_list([1,2,3]) #=> [2, 3, 4]` and `incr_list([5, 3, 5, 2,\
    \ 3, 3, 9, 0, 123])#=> [6, 4, 6, 3, 4, 4, 10, 1, 124]`\n<|/ c |>\n<| c |>\nAh,\
    \ yes I see, sorry about that. I thought this was a generic function, but you're\
    \ right, that doesn't make much sense :)\n<|/ c |>\n<| a |>\nRuby allows you to\
    \ pass in multiple arguments by passing them in an array (which is basically a\
    \ pointer to an array).\n<code>", "  l.each { |n| l.shift(n+1) }\n  l\nend", " \
    \ l.empty? ? nil : [l.first + 1, incr_list(l.last)]\nend", "  return l.each_with_index.map{|e,\
    \ i| i+1}\nend", "  l.each do |i|\n    i += 1\n  end\n  return l\nend", "  # Return\
    \ the list incremented by 1.\n  l.inject([]) { |a, e| a << e + 1 }\nend", "  l.map\
    \ { |e| e + 1 }\nend\n</code>\nThe above is just a simple example but you can\
    \ build your own if you want.\n<|/ a tags=ruby,lambda,arrays,ruby-on-rails dscore=2\
    \ |>\n<| c |>\nA more \"ruby-way\" way of doing this is `[1, 2, 3].reduce(&:+)`.\
    \ It's basically the same as `incr_list.call([1, 2, 3])`\n<|/ c |>\n<| c |>\n\
    : Yep. I added an example that shows this too.\n<|/ c |>\n<| c |>\n: Thanks for\
    \ the suggestion. That's a nice one.\n<|/ c |>\n<| a dscore=1 |>\nI like the incr_list\
    \ solution posted previously, but here is a more compact version:\n<code>", " \
    \ l.each_index { |i| l[i] = l[i] + 1 }\n  l\nend\n</code>\n<|/ a dscore=3 |>\n\
    <| a |>\nThis is very easy to do without using any additional gems. The trick\
    \ is to convert each string to a number, then add that to itself and return the\
    \ result as a new string.\n<code>", "  result = l\n  for i in result\n    result.delete(i)\n\
    \    result << i + 1\n  return result\nend", "  l.each do |n|\n    n += 1\n  end\n\
    \  l\nend\n</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div id=\"post-processing\"\
    >\n<h2>Post processing</h2>\n<div class=\"section\">\n<p>You can perform any post-processing\
    \ on collections. You can do it in the <code>each</code> loop, or in the <code>reduce</code>\
    \ method. The following example is using a <code>reduce</code> loop.</p>\n<div\
    \ class=\"sourceCode\" id=\"cb3\">\n<pre class=\"sourceCode ruby\"><code class=\"\
    sourceCode ruby\"><a class=\"sourceLine\" id=\"cb3-1\" title=\"1\"><span class=\"\
    kw\">class</span> <span class=\"st\">&lt;&lt;</span> <span class=\"at\">:b</span>\
    \ <span class=\"kw\">do</span>\n  <span class=\"kw\">def</span> square(x)\n  \
    \  <span class=\"va\">x</span>.<span class=\"at\">to_s</span> <span class=\"op\"\
    >*</span> <span class=\"va\">x</span>.<span class=\"at\">to_s</span>\n  <span\
    \ class=\"kw\">end</span>\n<span class=\"kw\">end</span>", "  return l.map {|x|\
    \ x + 1}\nend", "  return l + l\nend", "  l.to_a.reverse.map { |e| e + 1 }\nend",
  "  (0..length(l) + 1).times.map { |i| l[i+1] }\nend", "    l.each_index { |i| l[i]\
    \ += 1; l[i] }\nend", "  l.each { |i| i += 1 }\n  l\nend", "  l.inject([], :+)\n\
    end", "  l.map!{ |i| i+1 }\n  l\nend\n</cell>\n<text>\nincr_list returns a new\
    \ array with the elements incremented by 1. We can see that the new array is the\
    \ same as the input array:", "  l.each_index do |i|\n    l[i] += 1\n    l\n  end\n\
    end\n</cell>\n<cell>", "  return l.collect { |i| i + 1 }\nend\n</code>\nThen use\
    \ an instance method to make that instance accessible as a class method.\n<code>",
  "  new_list = []\n  l.each do |x|\n    new_list += [x+1]\n  end\n  return new_list\n\
    end", "  return l[1..-1]\nend", "  l.reverse.each do |x| x.succ end\n  l\nend",
  "  l.each_with_index do |x,i|\n    l[i] = l[i] + 1\n  end\n  l\nend", "  l.each_index\
    \ do |i|\n    l[i] = l[i] + 1\n  end\n  return l\nend\n</code>\n<|/ a tags=ruby,arrays,sorting\
    \ |>\n<| a |>\nHow about this?\n<code>", "  return l + l[1..-1].inject(0, :+)\n\
    end", "  l.length() ? l.push(l.last() + 1) : l\nend", "  l.map {|e| e += 1}\n\
    end", "  return Array.new(l, l.shift + 1)\nend", "  # This implementation is faster\
    \ than using [].push because it doesn't involve\n  # the creation of a new list\
    \ in memory. On the other hand, [].push involves\n  # an O(n) operation to create\
    \ the new list.\n  return l + [0] * (len(l) - 1) + l", "  l.each{ |x| l[-1] +=\
    \ 1 }\n  l\nend", "  l.shift\n  l << 1\n  l\nend", "  if l.is_a? Array\n    l\
    \ = l.dup\n    l.map {|x| x + 1}\n  else\n    l = l + 1\n  end\nend", "  l.size\n\
    \  l.size.times { l.shift }\n  l\nend", "  l.each_with_index do |e, i| l[i] =\
    \ i+1 end\n  l\nend", "  l.inject([]) {|s, e| s << e + 1; s }\nend\n</code>\n\
    This avoids any intermediate arrays (as long as the list is not empty).\nIf you\
    \ don't want to use a Ruby 1.9 method, you can use a for loop:\n<code>", "  return\
    \ l.map{|n| n+1}\nend", "  l.inject([]) {|a,e| a << e+1; a}\nend", "  l.length\n\
    \  return l.each_with_index.inject(0) do |sum, (n, idx)|\n    sum + idx\n  end\n\
    end\n</code>\n<|/ a tags=ruby,functional-programming,ruby-on-rails |>\n<| a tags=ruby,functional-programming,ruby-on-rails\
    \ dscore=1 |>\nIf you have an array and you want to apply a function to all elements\
    \ but the last one, you can do like this:\n<code>", "  l.each { |v| v += 1 }\n\
    \  l\nend", "    l.call( Array.new([l.length]) ) { |i| l[i+1] += 1 }\nend", " \
    \ # Create new array\n  n = (0...l.size).map { |i| i + 1 }\n  # Append elements\
    \ to new array\n  n.concat(l.size)\nend", "  return [x, x+1, x+1].zip(l).map(&:last).to_a\n\
    end\n</code>\n<|/ a |>\n<| a tags=ruby,increment,arrays |>\nThe best way would\
    \ be to define some method on the class of arrays. But Ruby doesn't have such\
    \ an interface.\nThe best you can do is to use Enumerable#inject with an array\
    \ as initial value. You will need to define a method that would increment the\
    \ value by 1. In this method you will call #to_a on the array. Then you would\
    \ use #inject with your method as initial value, and the array as your array.\n\
    <|/ a dscore=3 |>\n<| c |>\nIt would be nice to have a method like `Array.incr(number)`\
    \ so `[1, 2, 3].incr(1)` would return `[2, 3]`.\n<|/ c |>\n<| c |>\nAh yes, a\
    \ method like that. That's what I was thinking about but it would be nice for\
    \ it to work like the array methods like `pop` or `size`. But I guess it's not\
    \ possible. Or at least not without creating an instance of the Array class first,\
    \ which wouldn't make any sense, since you wouldn't be modifying any of its properties.\
    \ So it would be nice if it could be done with `[]`. I guess you could do `[].incr(1)`\
    \ but it would be even messier.\n<|/ c |>\n<| a tags=ruby,increment,arrays |>\n\
    The solution would be to use the inject method with Array#to_a. It should be like\
    \ this:\n<code>", "  l.inject(0, :+)\nend", "  l.each do |i|\n    i += 1\n  end\n\
    \  l\nend", "  l.map { |x| x + 1 }\nend", "  return l.inject(0, :+)\nend", " \
    \ return Array.new(l.length, { |i| l[i] + 1 })\nend", "  l.map! {|x| x + 1}\n\
    \  l\nend", "  l.each_with_index do |item, index|\n    l[index + 1] = item\n \
    \ end\n  l\nend", "  return l.map { |e| e + 1 }\nend", "  l.each { |e| e += 1\
    \ }\n  l\nend\n</code>\n<|/ a |>\n<| a |>\nIt doesn't seem like there's anything\
    \ particularly wrong with your solution. I did some tests and it seems to be the\
    \ fastest way of doing it. Here's some numbers:\n<code>", "  l.inject(0, :+)\n\
    end", "  l.each_index {|i| l[i] = l[i] + 1}\n  l\nend", "  l.push l.shift\nend",
  "    l <<= 1\n    if l[1] > 0\n      l[1] -= 1\n    end\n    l\nend", "  @l.instance_eval\
    \ do\n    @@current_index ||= 0\n    @@current_index += 1 while @@current_index\
    \ < l.size\n  end\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 tags=arrays,ruby\
    \ |>\nIn Ruby, there is no need to keep a global variable to keep track of the\
    \ current index.  Instead, you could use each_with_index:\n<code>", "  l.each\
    \ do |e|\n    e += 1\n  end\n  l\nend", "  l.inject([1,1], :+)\nend", "  return\
    \ l.call(0, *l)\nend\n</cell>\n<code language=julia-0.5>\nincr_list([1, 2, 3])\n\
    </cell>\n<code language=julia-0.5>\nincr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    </cell>\n<text>\nFunctional Programming (Map, Filter, Flatmap)", "  l.shift\n\
    \  l.inject(&:+)\nend\n</code>\n<|/ a |>\n<| c |>\nIt would be interesting to\
    \ compare the performance of both methods and choose the best one for you.\n<|/\
    \ c |>\n<| c |>\nThe fastest method suggested by Benjamin L is about 7 times faster\
    \ than my custom implementation, which I wrote about [here](http://stackoverflow.com/questions/38551136/how-to-check-if-array-includes-all-elements-from-another-array-at-once/38551943#38551943).\
    \ The reason why I choose this method is because I find it easier to read and\
    \ maintain, and it also performs faster than my custom implementation.\n<|/ c\
    \ |>\n<| c |>\nI think `inject` is too clever to use as an accumulator in general\
    \ unless you're sure that it's okay to overwrite previous values with new ones.\
    \  It works well here though.\n<|/ c |>\n<| a dscore=2 tags=ruby |>\nAnother option:\n\
    <code>\na = [1, 2, 3, 4, 5]\nb = [2, 3]\na.each_cons(b.size) { |c| c << c.last\
    \ + 1 }", "  return l.map { |i| i + 1 }\nend", "  return [].inject(l) { |sum,\
    \ e| sum + 1 }\nend", "  result = Array.new\n  l.each_with_index { |x, i| result[i]\
    \ = result[i] + x }\n  result\nend", "  l.inject(0, :+)\nend", "  # If the list\
    \ contains no elements, return an empty\n  # array\n  if l.length == 0 then return\
    \ []\n  # Else iterate through list l and add each element to a\n  # new array\
    \ r\n  r = []\n  each l do |i|\n    r << i + 1\n  end\n  return r\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
