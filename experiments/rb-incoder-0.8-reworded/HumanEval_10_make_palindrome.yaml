name: HumanEval_10_make_palindrome
language: rb
prompt: "# Find the shortest palindrome that begins with a supplied string.\n# Algorithm\
  \ idea is simple:\n# - Find the longest postfix of supplied string that is a palindrome.\n\
  # - Append to the end of the string reverse of a string prefix that comes before\
  \ the palindromic suffix.\n# >>> make_palindrome.call(\"\")\n# \"\"\n# >>> make_palindrome.call(\"\
  cat\")\n# \"catac\"\n# >>> make_palindrome.call(\"cata\")\n# \"catac\"\ndef make_palindrome(string)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_make_palindrome\n\
  \    candidate = method(:make_palindrome)\n    assert_equal(\"\", candidate.call(\"\
  \"))\n    assert_equal(\"x\", candidate.call(\"x\"))\n    assert_equal(\"xyzyx\"\
  , candidate.call(\"xyz\"))\n    assert_equal(\"xyx\", candidate.call(\"xyx\"))\n\
  \    assert_equal(\"jerryrrej\", candidate.call(\"jerry\"))\n  end\nend\n"
completions: ["  palindrome = find_longest_palindrome(string)\n  palindrome << string.reverse(palindrome)\n\
    end", "  length = string.size\n  postfix_length = length - 1\n  postfix_postfix\
    \ = nil\n  prefix_length = length\n  prefix_prefix_length = length", "  if string\
    \ == \"\"\n    return \"\"\n  l = string.rindex( string )\n  return string + string[l..-1]\n\
    end\n</code>\n<|/ a |>\n<| c |>\nI do not know how I missed this\n<|/ c |>\n<|\
    \ a |>\n<code>", "  new_string = \"\"\n  index = 0\n  while string != \"\"\n \
    \   new_string << string\n    index += 1\n    string = string[1..-1]\n    new_string\
    \ << string\n    string << string[0...index]\n  end\n  return new_string\nend",
  "  if string == \"\"\n    string\n  else\n    middle = string.length / 2\n    longest\
    \ = get_longest_palindrome_substring_reversed(string[0...middle])\n    string.insert(middle,\
    \ reverse(longest))\n    string\n  end\nend\n</code>\nThe function get_longest_palindrome_substring_reversed()\
    \ takes a string and reverses it and returns it as a string.\n<code>", "  string\
    \ = string.to_s\n  if string.length <= 1\n    return string\n  last_postfix =\
    \ string\n  postfix_length = len(string)\n  while postfix_length <= 2\n    postfix_length\
    \ = postfix_length * 2\n  end\n  last_postfix_reverse = last_postfix[0...postfix_length].reverse\n\
    \  return last_postfix_reverse + string\nend", "  string.chars.reverse_each.with_index.with_object(\"\
    \") do |(char, index), prefix|\n    unless index == 0\n      suffix = string.slice(index..-1).reverse\n\
    \      prefix << char << suffix\n    end\n  end\nend", "  string.reverse\n  prefix\
    \ =string.split('')\n  reversedPrefix = prefix.reverse\n  suffix = (string.reverse+reversedPrefix).split(\"\
    \")\n  result = reversedPrefix.concat(suffix)\n  result.to_s\nend\n</code>\n<|/\
    \ a tags=ruby,ruby-on-rails |>\n<| c |>\nThe `to_s` on the end isn't necessary\
    \ and isn't doing anything useful. You could just do `result = string.reverse;\
    \ string.concat(result); result`\n<|/ c |>\n<| c |>\nOh yeah that would also work,\
    \ I actually had tried it but must have had some typo while doing it. Thanks for\
    \ the suggestion!\n<|/ c |>\n<| a dscore=1 tags=ruby,ruby-on-rails |>\nA very\
    \ simple algorithm that I have worked on is shown below:\n<code>", "  if string.empty?\n\
    \    string\n  else\n    longest_palindrome = find_longest_palindrome(string.gsub!(/(?<=\\\
    A|\\z)\\z/, ''))\n    string.gsub!(longest_palindrome, longest_palindrome.gsub!(/(?<=\\\
    A|\\z)\\z/, ''))\n  end\nend", "  string = string.dup\n  string.chomp!\n  string.gsub!(/^(.*)/,\
    \ \"\\\\1\")\n  string.downcase!\n  longest_prefix_palindrome = get_longest_prefix_palindrome(string.tr('A-Za-z','a'))\n\
    \  string = longest_prefix_palindrome.sub(longest_prefix_palindrome.tr('a-z','A-Z'),\
    \ string).sub(longest_prefix_palindrome.reverse).tr('A-Za-z','a').downcase\nend",
  "  string.downcase!\n  prefix_and_suffix = string.scan(/(?=\\A|\\z)/)\n  prefix\
    \ = \"#{prefix_and_suffix[0]}#{string.reverse(prefix_and_suffix[0])}\"\n  suffix\
    \ = \"#{string.reverse(prefix_and_suffix[0])}#{prefix_and_suffix[-1]}\"\n  \"\
    #{prefix}#{suffix}\"\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 tags=palindrome,string,ruby\
    \ |>\n<code>", "  palindrome = \"\"\n  i = 1\n  while i > 0\n    if string ==\
    \ string.reverse\n      palindrome += string.reverse\n      break\n    else\n\
    \      i = i - 1\n  end\n  palindrome += string\n  return palindrome\nend\n</code>\n\
    <|/ a |>\n<| a |>\nThe answers here were all great; I wanted to try a different\
    \ approach that wasn't based on finding all palindromes, or all palindromes that\
    \ start with a specific string. So I remembered that my mom and dad's palindromes\
    \ were all the same length (14), so I started working on just finding the palindromes\
    \ with a specific first letter and then filtering those out. Here it is:\n<code>",
  "  if string.nil?\n    return string\n  elsif string == string.chars.reverse.first\n\
    \    return string\n  else\n    # Find the longest postfix that is a palindrome.\n\
    \    postfix = []\n    longest_palindrome = nil\n    longest_palindrome_length\
    \ = nil\n    string.chars.reverse.each_with_index do |char, i|\n      postfix.push(char)\n\
    \      length = longest_palindrome_length\n      if postfix.last == postfix.first\n\
    \        longest_palindrome_length = i\n        longest_palindrome = string[0,i].gsub(/./)\
    \ { |m| m[0] }\n      end\n    end\n    return longest_palindrome + postfix.reverse[0...longest_palindrome_length]\
    \ + postfix.last\n  end\nend", "  string = string.to_s\n  suffix  = []\n  postfix\
    \ = []\n  rev     = nil\n  i = 0", "  longest_postfix = string\n  longest_postfix\
    \ = find_longest_postfix(string, longest_postfix)\n  postfix = longest_postfix.reverse\n\
    \  postfix = postfix.upcase\n  postfix = postfix.reverse unless postfix.starts_with?(\"\
    A\")\n  return string+postfix\nend", "  string = string.to_s.gsub(/[^a-zA-Z0-9]/,\"\
    \")\n  if string.length == 0\n    string\n  else\n    prefix = [string[0...(string.length/2)]]\n\
    \    prefix = prefix.reverse\n    string[0...(string.length/2)] = prefix\n   \
    \ string.prepend(prefix)\n  end\nend\n</code>\n<|/ a tags=ruby,algorithm,ruby-on-rails,ruby-on-rails-3\
    \ |>\n<| a tags=ruby,algorithm,ruby-on-rails,ruby-on-rails-3 |>\nThis is what\
    \ I did and it seems to work well:\n<code>", "  length = (string.size + 1).to_i\n\
    \  reverse_length = (length - 1).to_i\n  new_string = string\n  new_string +=\
    \ string[0, reverse_length]\n  (length - (string.size + 1)).downto(0) { |i| new_string\
    \ += string[length - i - 1, i]}\n  new_string\nend\n</code>\n<|/ a |>\n<| c |>\n\
    Thanks for the effort but as I pointed out in another comment, the question specifically\
    \ says \"without using any loops\".\n<|/ c |>\n<| a dscore=0 |>\nThis is my take\
    \ on it:\n<code>", "  return string + string.gsub(/^(.+)((?<=[^a-zA-Z])(.{1})(?=[^a-zA-Z]))/,\
    \ '\\1\\2\\1\\3').split('').reverse.join('')\nend\n</code>\n<|/ a |>\n<| a tags=ruby\
    \ |>\n<code>", "  string.gsub(/./) { |char| char == char.reverse ? char.chr :\
    \ \"#{char.reverse}#{char}\"}\nend", "  string = string.dup\n  len = string.length\n\
    \  index = 0\n  while index < len\n    if string[index] == string[len-index]\n\
    \      # Found a palindrome suffix, so continue the loop.\n      index = index\
    \ + 1\n    else\n      # Found a non-palindrome prefix.\n      break\n    end\n\
    \  end\n  string[index...len] = string[len...index]\n  string\nend", "  \n  #\
    \ Make sure string is non-empty\n  string = string.strip\n  return string if string.empty?\
    \ || string == string.upcase else string + reverse_of_prefix(string, string[1..-1])\
    \ # Add reverse() to get back a string\nend", "  max_length = string.length\n\
    \  reverse_string = \"\"\n  index = string.length - 1\n  while index > 0\n   \
    \ reverse_string = reverse_string + string.slice(index, 1).reverse\n    index\
    \ = index - 1\n  end\n  \n  rev_string_index = max_length - reverse_string.length\n\
    \  if rev_string_index < 0\n    rev_string_index = 0\n  elsif rev_string_index\
    \ > string.length\n    rev_string_index = string.length\n  end\n  \n  rev_string\
    \ = reverse_string\n  rev_string.slice!(rev_string_index)\n  \n  rev_string =\
    \ rev_string.gsub(/[a-z]/i, \"\")\n  \n  result = string + rev_string\n  \n  result\n\
    end\n</cell>\n<cell>", "  palindrome = \"\"\n  prefix_length = 0\n  suffix_length\
    \ = 0\n  while prefix_length < string.length do\n    prefix_length = prefix_length\
    \ + 1\n    if string.chars.at(string.length - prefix_length) == string.chars.at(string.length\
    \ - suffix_length) then\n      palindrome = palindrome + string.chars.at(string.length\
    \ - prefix_length)\n    end\n    suffix_length = suffix_length + 1\n  end\n  return\
    \ palindrome\nend", "  length = string.size\n  palindrome = nil", "  new_string\
    \ = string.dup\n  while new_string =~ /\\w(\\w)\\1+/\n    new_string << $1\n \
    \ end\n  new_string << new_string[-2..-1].reverse\n  new_string\nend", "  string\
    \ = string.upcase\n  i = 0\n  j = -1\n  max_length = 0\n  while i < string.length\n\
    \    j = i\n    while j < string.length and string[j] != string[i]\n      j +=\
    \ 1\n    end\n    i += 1\n    max_length = j if j < j else max_length\n  end\n\
    \  max_length ||= 0\n  max_length -= 1\n  string = string.sub(/\\b[a-z]*/, '').gsub(/.[a-z]/,\
    \ \"\").reverse\n  string << (j - i) if j < i\n  string\nend", "  original = string\n\
    \  string = string.gsub(/\\w+/){|c| c if c !~ /\\d/}.downcase\n  puts string\n\
    \  string.gsub!(/[a-z]/,\"\")\n  string.gsub!(/[^a-z]/,\"-\")\n  string.gsub!(/\\\
    -{2,}/,\"-\")\n  string.gsub!(/\\-$/,\"-\")\n  string = string.gsub(/\\-$/,\"\
    -\")\n  puts string\n  string.gsub!(/\\//,\"-\")\n  string.gsub!(/[-]/,\"-\")\n\
    \  string.gsub!(/-$/,\"-\")\n  string.gsub!(/-/,\"/\")\n  string.gsub!(/\\//,\"\
    -\")\n  string = string.gsub(/\\//,\"-\")\n  puts string\n  string = (string.split(//)).map\
    \ {|s| s.reverse.downcase}.join\n  puts string\n  string.gsub!(/\\-$/,\"-\")\n\
    \  puts string\n  string.gsub!(/[a-z]/,\"\")\n  string.gsub!(/[^a-z]/,\"-\")\n\
    \  string.gsub!(/\\-{2,}/,\"-\")\n  string.gsub!(/\\-$/,\"-\")\n  string = string.gsub(/\\\
    -$/,\"-\")\n  puts string\n  string.gsub!(/\\//,\"-\")\n  string.gsub!(/[-]/,\"\
    -\")\n  string.gsub!(/-$/,\"-\")\n  string.gsub!(/-/,\"/\")\n  string.gsub!(/\\\
    //,\"-\")\n  string = string.gsub(/\\//,\"-\")\n  puts string\n  string = (string.split(//)).map\
    \ {|s| s.reverse.downcase}.join\n  puts string\n  string.gsub!(/\\-$/,\"-\")\n\
    \  puts string\n  string.gsub!(/[a-z]/,\"\")\n  string.gsub!(/[^a-z]/,\"-\")\n\
    \  string.gsub!(/\\-{2,}/,\"-\")\n  string.gsub!(/\\-$/,\"-\")\n  string = string.gsub(/\\\
    -$/,\"-\")\n  puts string\n  string.gsub!(/\\//,\"-\")\n  string.gsub!(/[-]/,\"\
    -\")\n  string.gsub!(/-$/,\"-\")\n  string.gsub!(/-/,\"/\")\n  string.gsub!(/\\\
    //,\"-\")\n  string = string.gsub(/\\//,\"-\")\n  puts string\n  string = (",
  "  reverse = string[1..-1].reverse\n  string << (reverse + string[0..-2])\nend",
  "  palindrome = string\n  while palindrome != string && string.length < 20\n   \
    \ palindrome = \"#{palindrome}#{string.reverse}\"\n  end\n  string\nend\n</code>\n\
    <|/ a tags=palindrome,ruby dscore=1 |>\n<| c |>\nGreat answer! I didn't know about\
    \ `string.reverse`, so thank you for that! Your `make_palindrome` will still have\
    \ some issues, though. Let's say I have `make_palindrome.call(\"abracadabra\"\
    )`. This will result in `\"abracadabrarabracadabra\"`.\n<|/ c |>\n<| c |>\nGood\
    \ catch! It was failing due to the fact that I added a return value to my method\
    \ and forgot to remove it. I've updated the answer. Thanks for your help!\n<|/\
    \ c |>\n<| a dscore=1 |>\nYou could take a recursive approach like this:\n<code>",
  "  return string if string.empty? || string.size <= 2\n  \n  # Pad the given string\
    \ with spaces to get the longest postfix of it.\n  # To check it we reverse the\
    \ first and last letters to check whether they are palindromes.\n  max_length\
    \ = (string.size + 1) - 2\n  pad_chars = \" \" * (max_length - string.size)\n\
    \  \n  prefix_postfix = []\n  \n  # Pad the original string\n  prefix_postfix.concat(pad_chars).concat(string.dup)\n\
    \  \n  # Pad the reversed first letter\n  prefix_postfix.concat(pad_chars).concat(prefix_postfix.last.reverse)\n\
    \  \n  # Pad the reversed last letter\n  prefix_postfix.concat(pad_chars).concat(prefix_postfix.first.dup.reverse)\n\
    \  \n  # Get the longest postfix string that is a palindrome.\n  postfix = prefix_postfix.reverse.scan(/(.)(.)/)\n\
    \  \n  # Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n  # Note: We could have used the string instead\
    \ of reversing first,\n  #       but here we reverse to preserve the code readability.\n\
    \  postfix.reverse_each {|(first, last)|\n    string.concat(first.dup.concat(last.dup.chars.reverse.first))\n\
    \  }\n  \n  string\nend\n</code>\n<|/ a dscore=3 |>\n<| a |>\nHere is an even\
    \ faster solution:\n<code>", "  string = string.dup\n  loop{ string += reverse\
    \ (string.slice!(0...string.length)) }\n  string\nend\n</code>\nThis is Ruby,\
    \ which makes life much easier when it comes to these things. Ruby also has a\
    \ nice method called reverse which reverses the order of characters in a string.\
    \ \n<code>\n\"abc\".dup.reverse\n=> \"cba\"\n</code>\nSo as you can see, in Ruby\
    \ you can simply write your original code as\n<code>", "  if string.empty?\n \
    \   return string\n  end\n  string = string.downcase\n  max_length = string.size\n\
    \  prefix_length = (max_length / 2).ceil\n  suffix_length = max_length - prefix_length\n\
    \  palindrome = \"\"\n  string[0..prefix_length].each_char.with_index do |char,\
    \ index|\n    char = char.downcase\n    if index == prefix_length\n      palindrome\
    \ << char\n    else\n      palindrome << char + string[index..-1]\n    end\n \
    \ end\n  reverse_string = \"\"\n  max_length - suffix_length + 1.downto(1).each\
    \ do |index|\n    reverse_string << string[prefix_length..suffix_length - index\
    \ + 1]\n  end\n  palindrome << reverse_string\nend\n</code>\n<|/ a dscore=4 tags=ruby\
    \ |>\n<| c |>\nThank you for this solution. Very nice. \nA couple of minor things\
    \ though. ", "  string.gsub(/\\w+/) { |p| p.reverse }\n  string.gsub(/(?<=^|$)/)\
    \ { |p| p.reverse }\nend", "  return \"#{ string }#{ string.chars.reverse.first\
    \ }\"\nend", "  string = string.gsub(/[^0-9A-Za-z]+/, '')\n  return string + string.split(//).reverse.join(//).sub(/^(.)(.*)/,'\\\
    1\\2').gsub(/[0-9]*/,'')\nend", "  string.chars.reverse!\n  postfix = string.chars.map\
    \ {|c| c }.join\n  string.chop!\n  string.concat(postfix.reverse.chars)\nend",
  "  postfix = find_longest_palindrome(string)\n  if postfix.empty?\n    postfix\n\
    \  else\n    postfix.reverse_concat(find_longest_palindrome(string[0, prefix.length]))\n\
    \  end\nend", "  string = string.dup\n  longest = find_longest_postfix(string)\n\
    \  longest.size > 0 && longest.reverse!\n  string[0, longest.size] = longest.reverse\n\
    \  string.slice!(0, longest.size)\n  string\nend", "  if string == \"\"\n    string\n\
    \  else\n    prefix_max = string.rjust(string.index(\"a\"), \"a\")\n    suffix\
    \ = string.rindex(\"a\")\n    string.insert(suffix, prefix_max[-suffix..-1] +\
    \ string.slice(-suffix)[-suffix..-1])\n  end\nend", "  if string.empty?\n    \"\
    \"\n  else\n    string_reversed = string.reverse", "  return string + (reverse_string(string).reverse\
    \ + string[0..-2]) if string.gsub!(/[^a-z]/,\"\").reverse == string\nend", " \
    \ return string unless string\n  half = string.length / 2\n  longest = palindrome(string,\
    \ half)\n  suffix = string.sub(half)\n  prefix_longest = string.sub(1, half).reverse\n\
    \  string[0, half] = prefix_longest + suffix\n  string\nend", "  # O(2N) (because\
    \ of the nested loops)\n  longest = 0\n  string.split(\"\").each do |char|\n \
    \   # O(2N)\n    next if char == char.reverse\n    longest = char.length if char.length\
    \ > longest\n  end\n  if longest < string.length\n    string.gsub!(/([^.]*\\.)([^.]*$)/,\
    \ \"\\\\1#{$1}\")\n  end\n  string.gsub!(/([^.]*\\.)([^.]*$)/, \"\\\\1#{char.reverse}\"\
    )\n  string\nend", "  string = string.to_s\n  longest = string[0,string.rindex(string)]\n\
    \  prefix = string[0...string.rindex(string)].reverse\n  suffix = string[string.rindex(string):]\n\
    \  \"#{longest}#{prefix}#{suffix}\"\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\nHere's an implementation in ruby:\n<code>", "  return string + \"#\" + reverse(string[string.size..-1])\n\
    end", "  min_length = -1\n  longest_postfix_palindrome = \"\"\n  longest_postfix_palindrome_palindrome\
    \ = \"\"\n  longest_postfix_palindrome_palindrome_palindrome = \"\"\n  string.split(\"\
    \").each do |letter|\n    # Find postfix palindrome.\n    # First check if length\
    \ is greater than minimum length found in a previous iteration.\n    if min_length\
    \ != -1 && min_length != letter.length\n      if longest_postfix_palindrome.length\
    \ >= min_length\n        # Found palindromic suffix.\n        longest_postfix_palindrome\
    \ += letter\n      end\n    end", "  prefix_length = string.length\n  suffixes_length\
    \ = string.length - 1", "  result    = \"\"\n  reverse_string = \"\"\n  string.gsub!(/([a-zA-Z])/)\
    \ do |letter|\n    reverse_string << letter\n    result        += letter\n  end\n\
    \  reverse_string.gsub!(/([a-zA-Z])/) do |letter|\n    result << letter\n  end\n\
    \  result\nend", "  longest, prefix, suffixes = longest_palindrome(string)\n \
    \ return prefix + string.reverse(suffixes.reverse) + suffix\nend", "  string.gsub!(/(.)(.)/){$1\
    \ + $2.reverse}\n  return string\nend\n  ", "  string.scan(/\\w+/).each do |word|\n\
    \    unless word.length == 1\n      prefix_to_end = find_prefix_to_end(word)\n\
    \      prefix_to_end.scan(/\\w+/).each do |prefix_word|\n        word = word.clone\n\
    \        word.prepend(prefix_word)\n        word.prepend(find_reversed_word(prefix_word))\n\
    \        break word if find_palindrome_word?(word)\n      end\n    end\n  end\n\
    \  string\nend", "    prefix  = string[0...-1]\n    suffix = string[-2..-1]\n\
    \    palindrome = string\n    while prefix != suffix do\n        postfix = suffix\n\
    \        reversed_suffix = suffix.reverse\n        suffix = reversed_suffix\n\
    \        postfix = postfix.reverse\n        palindrome  = palindrome + prefix\
    \ + postfix\n    end\n    palindrome\nend", "  string, length = string.to_s.split('').reverse,\
    \ string.length\n  return string + ((length + string.count('a')) % 2 ? string.chop\
    \ : string.chop)\nend", "  palindrome = string\n  max_length = 0\n  max_length\
    \ = max_length.to_s.length\n  min_length = max_length.to_s.length\n  \n  while\
    \ min_length > 0\n    \n    palindrome = string + \"#\" + palindrome\n    max_length\
    \ += 1\n    min_length = max_length.to_s.length\n    \n    if palindrome == string\n\
    \      max_length = max_length.to_s.length - 1\n      min_length -= 1\n      break\n\
    \    end\n  end\n  \n  max_length -= max_length.to_s.length\n  max_length -= max_length.to_s.length\n\
    \  \n  max_length -= max_length.to_s.length\n  \n  max_length = max_length.to_s.length\n\
    \  \n  max_length = max_length.to_s.length\n  \n  max_length = max_length.to_s.length\n\
    \  \n  max_length = max_length.to_s.length\n  \n  palindrome = string + \"#\"\
    \ + palindrome\n  palindrome.length = max_length.to_s\n  \n  while max_length\
    \ > 0\n    \n    palindrome = palindrome.split(//).reverse.join(//)\n    max_length\
    \ -= 1\n    max_length -= 1\n    max_length -= 1\n    \n    if palindrome == string\n\
    \      max_length -= 1\n      max_length -= 1\n      break\n    end\n  end\n \
    \ \n  palindrome.length = max_length.to_s\n  return palindrome\nend", "  len =\
    \ string.size\n  maxlen = len\n  i = 0\n  while i < len\n    j = i + 1\n    while\
    \ j < len\n      break if string[j] != string[i]\n      j += 1\n    end\n    maxlen\
    \ = j if j > i else i\n    i += 1\n  end\n  string[maxlen..maxlen] = string.reverse\n\
    \  return string\nend", "  if string == \"\"\n    string\n  else\n    prefix_reversed_string\
    \ = get_prefix_reversed_string(string)\n    prefix_reversed_string + get_prefix_reversed_string(string[-prefix_reversed_string.size..-1])\
    \ + string\n  end\nend", "  length = string.length\n  prefix = string[0...length]\n\
    \  suffix = string[(length-1)...-1]\n  reversed_prefix = prefix + reverse(prefix)\n\
    \  reversed_suffix = reverse(suffix)\n  max_length = length - prefix.length -\
    \ suffix.length - 1\n  if length > max_length\n    max_length = length\n  reversed_prefix.insert(max_length,\
    \ reversed_suffix)\n  reversed_prefix.insert(0, prefix)\n  reversed_prefix.reverse!\n\
    \  return reversed_prefix.to_s\nend", "  string = string.to_s\n  max_length =\
    \ 1\n  max_length_palindrome = 0\n  while string.length > max_length\n    if string[max_length]\
    \ == string[max_length - max_length_palindrome]\n      max_length_palindrome +=\
    \ 1\n    end\n    max_length += 1\n  end\n  max_length_palindrome -= 1\n  new_string\
    \ = string[0..max_length_palindrome].reverse\n  new_string += string[max_length_palindrome..-1]\n\
    \  new_string += string[0..max_length_palindrome].reverse\n  return new_string\n\
    end", "  length = string.size\n  maxLength = 0\n  result = \"\"\n  prefixes =\
    \ Array[]\n  suffixes = Array[]\n  for i in 0...length\n    current = string[i]\n\
    \    nextIndex = i\n    while nextIndex <= length -1\n      if next == string[nextIndex]\n\
    \        nextIndex += 1\n      else \n        break\n    \n    prefixes.push(current)\n\
    \    suffixes.push(nextIndex)\n  end\n  maxLength = length\n  while maxLength\
    \ > 0\n    currentPrefix = prefixes[0]\n    currentSuffix = suffixes[0]\n    nextPrefix\
    \ = prefixes[1]\n    nextSuffix = suffixes[1]\n    if currentSuffix - currentPrefix\
    \ + 1 > maxLength\n      break\n    \n    result = result + currentPrefix + string[currentSuffix\
    \ - 1] + string[nextSuffix]\n    maxLength = currentSuffix - currentPrefix + 1\n\
    \    prefixes.shift()\n    suffixes.shift()\n  end\n  result\nend\n</cell>\n<code\
    \ language=julia-0.4>\nmake_palindrome.call(\"\")\n</cell>\n<code language=julia-0.4>",
  "  length = string.length\n  return string[0,length-1] + string[length-1,length].reverse\
    \ + string\nend\n</code>\n<code>", "  max_length = 0\n  string_to_palindromize(string,\
    \ max_length)\n  while max_length > 1\n    max_length = max_length / 2\n    string_to_palindromize(string,\
    \ max_length)\n  end\n  string\nend", "  return string + \"a\" + reverse_string(string,\
    \ \"a\").chomp(\"a\")\nend", "  max_length = max_length_of_string(string)\n  prefix_reversed\
    \ = prefix_reversed_of_string(string, max_length)\n  return prefix_reversed+string+reversed_of_string(prefix_reversed,\
    \ max_length)\nend\n</code>\nPS : You can make the code look nicer by defining\
    \ some helper functions that would be used only once or twice in your program.\n\
    <|/ a tags=ruby |>\n<| c |>\nWhy not use `reverse_string` instead of `reversed_of_string`?\
    \ That would avoid the need to store the string in `reversed_of_string`.\n<|/\
    \ c |>\n<| c |>\nThanks. I didn't know that `reverse_string` existed.\n<|/ c |>\n\
    <| c |>\nThis is awesome. Thanks for posting it.\n<|/ c |>\n<| a |>\nThe original\
    \ code was very unreadable and inefficient. The following improvements make it\
    \ a bit easier to understand. \n<code>", "  min_length = string.length\n  max_length\
    \ = string.length - 1\n  max_length_palindromic = nil\n  string.each_char do |character|\n\
    \    break if character == character[max_length]\n    min_length = min_length\
    \ - 1\n    max_length = max_length - 1\n    max_length_palindromic = max_length\
    \ if max_length_palindromic == nil || max_length_palindromic < max_length\n  \
    \  if min_length > 0 && max_length <= 0 then\n      max_length_palindromic = max_length\n\
    \    else\n      max_length_palindromic = max_length\n    end\n  end\n  max_length_palindromic\
    \ + string[0...min_length].reverse\nend\n</code>\nThe above algorithm is O(n)\
    \ for the most part which isn't terribly bad, but you can do it in O(n * log n)\
    \ with a modified algorithm that is O(n) (assuming that the string was sorted).\n\
    The modified algorithm is as follows:\n<code>", "  start_index = indexof(string,\
    \ 1)\n  end_index = indexof(string, length(string))", "  string.slice!(0,1) if\
    \ string =~ /^(.).*?\\1/\n  suffix = (string.match(/((.)\\2|(.)\\2)$/) ? $2 :\
    \ \"\")\n  prefix = string.match(/(\\1)\\2/)\n  prefix = prefix ? $1\n  prefix\
    \ += suffix if string =~ /^(\\1\\2|\\2\\1)$/\n  prefix + suffix\nend\n</code>\n\
    It seems to me it could be made a bit more efficient by using a binary search\
    \ to find the longest postfix and prepend to it.\n<|/ a dscore=1 tags=ruby,palindrome,string\
    \ |>\n<| a |>\nYou can use this to solve your problem:\n<code>", "  max_length\
    \ = 0\n  min_length = 0\n  reverse = string\n  while true\n    break if min_length\
    \ == max_length\n    length =\n      1\n    while true\n      break if length\
    \ == max_length\n      break if string[length - 1] != string[max_length]\n   \
    \   length += 1\n    end\n    reverse[max_length] = string[max_length]\n    reverse[min_length...-1]\
    \ = string[min_length...-1]\n    max_length -= 1\n    min_length -= 1\n  end\n\
    \  reverse[0...max_length]\nend", "  string\n    .chars\n    .slice_before(string)\n\
    \    .map { |c| c.reverse }\n    .inject(string) { |s, s| s + s }\nend", "  string.length.times.with_index.with_object(\"\
    \") do |i, result|\n    result = i ? result + \"#{i}#{i}\" : result\n    if i.odd?\
    \ && i == 0\n      result\n    elsif i.even? && (result.to_s.length <= string.length\
    \ - string.rindex(result).to_s.length)\n      result.insert(-1, string[string.length\
    \ - result.rindex(result).to_s.length])\n    else\n      result.insert(-2, string[-result.rindex(result).to_s.length\
    \ + 1])\n    end\n  end\nend\n</code>\n<|/ a tags=ruby,algorithm |>\n<| a tags=ruby,algorithm\
    \ dscore=0 |>\nIn ruby you can do this with a recursive method:\n<code>", "  while\
    \ string != \"\"\n    # Find the longest postfix that is a palindrome.\n    postfix\
    \ = find_longest_postfix_with_palindromic_suffix_substr(string)\n    if postfix\
    \ = \"\"\n      # There is no postfix that is a palindrome, so we are done.\n\
    \      break\n    # Append the reverse of the postfix to the original string.\n\
    \    string << reversed_postfix_substr(postfix, 0, postfix.size)\n  end\n  return\
    \ string\nend", "  longest = find_longest(string)\n  suffix = \"#{string.reverse}#{longest}\"\
    \n  longest = find_longest(suffix)\n  prefix = string[0, longest.length]\n  suffix\
    \ += \"#{prefix}\"\n  return suffix\nend\nputs make_palindrome.call(\"cat\")\n\
    puts make_palindrome.call(\"cat\")\nputs make_palindrome.call(\"cat\")\nputs make_palindrome.call(\"\
    cata\")\nputs make_palindrome.call(\"cata\")\nputs make_palindrome.call(\"cat\"\
    )\nputs make_palindrome.call(\"cat\")\nputs make_palindrome.call(\"cat\")\nputs\
    \ make_palindrome.call(\"cat\")\nputs make_palindrome.call(\"cata\")\nputs make_palindrome.call(\"\
    cat\")\nputs make_palindrome.call(\"cata\")\nputs make_palindrome.call(\"cat\"\
    )\nputs make_palindrome.call(\"cat\")\nputs make_palindrome.call(\"cat\")\nputs\
    \ make_palindrome.call(\"cata\")\nputs make_palindrome.call(\"cat\")\nputs make_palindrome.call(\"\
    cata\")\nputs make_palindrome.call(\"cat\")\nputs make_palindrome.call(\"cat\"\
    )\nputs make_palindrome.call(\"cat\")\nputs make_palindrome.call(\"cat\")\nputs\
    \ make_palindrome.call(\"cat\")\nputs make_palindrome.call(\"cat\")\nputs make_palindrome.call(\"\
    cat\")\nputs make_palindrome.call(\"cat\")\nputs make_palindrome.call(\"cat\"\
    )\nputs make_palindrome.call(\"cat\")\nputs make_palindrome.call(\"cat\")\nputs\
    \ make_palindrome.call(\"cat\")\nputs make_palindrome.call(\"cat\")\nputs make_palindrome.call(\"\
    cat\")\nputs make_palindrome.call(\"cat\")\nputs make_palindrome.call(\"cat\"\
    )\nputs make_palindrome.call(\"cat\")\nputs make_palindrome.call(\"cat\")\nputs\
    \ make_palindrome.call(\"cat\")\nputs make_palindrome.call(\"cat\")\nputs ", " \
    \ beginning_of_string_index ||= 0\n  longest_postfix = 0 \n  longest_postfix_start\
    \ = 0\n  longest_postfix_end = 0\n  longest_postfix_string = \"\"\n  string.gsub!(/[a-zA-Z]/,\
    \ \"\") # remove all non letters\n  string.gsub!(/[^a-zA-Z]/, \"\") # remove all\
    \ non letters\n  string.gsub!(/\\s+/, \"-\") # Replace all spaces with dashes\n\
    \  string.gsub!(/-+/, \"-\")", "  if string.nil?\n    string\n  elsif string.length\
    \ < 2\n    string\n  else\n    string[0...-1] + string.reverse[1..-1] + string[0...-1]\n\
    \  end\nend", "  palindrome = string\n  begins_with_palindrome = false\n  longest_postfix\
    \ = 0\n  begins_with_longest_postfix = false\n  while string.length > 0\n    index\
    \ = string.rindex(\"a\")\n    if index != -1\n      longest_postfix = index\n\
    \      begins_with_longest_postfix = true\n    end\n    string = string[index..-1]\n\
    \  end\n  string.reverse!\n  string.reverse!\n  while string.length > 0\n    if\
    \ string.rindex(\"a\") == longest_postfix\n      palindrome << \"#{string}\"\n\
    \      string = string[(longest_postfix+1..-1]\n      break if begins_with_palindrome\
    \ && begins_with_longest_postfix\n      begins_with_palindrome = true\n      begins_with_longest_postfix\
    \ = false\n    else\n      palindrome << \"#{string}\"\n      string = string[(longest_postfix+1..-1]\n\
    \    end\n  end\n  palindrome\nend", "  raise \"Not implemented\"\nend", "  rev_str\
    \ = string.dup.reverse\n  begin = 0\n  begins = false\n  while begin < string.length\n\
    \    if string.chars[begin] == rev_str.chars[begin]\n      begin = true\n    \
    \  begins = true\n      break\n    else if begins\n      break\n    else begin\
    \ = false\n    end\n    begin += 1\n  end\n  if begins\n    prefix = string.slice(begin..(string.length\
    \ - 1))\n    reversed_prefix = reverse(string)\n    suffix = reversed_prefix.slice(0..(prefix.length))\n\
    \    reversed_suffix = rev_str.slice(0..(suffix.length))\n    reversed_suffix.concat(prefix)\n\
    \    reversed_suffix.concat(reversed_prefix.slice(prefix.length))\n    reversed_suffix\n\
    \  else\n    string\n  end\nend", "  string = string.to_s\n  if string.length\
    \ <= 1\n    string\n  else\n    prefix_reversed = string[0,string.length-1]\n\
    \    palindromic_suffix = string[string.length-1,string.length-1]\n    appended_reversed\
    \ = prefix_reversed + palindromic_suffix.reverse\n    appended_reversed\n  end\n\
    end", "  return string + (string[::-1][1...string.size]) if string && (string[1...string.size]\
    \ == string.reverse[1...string.size]) ? string : \"\"\nend\nputs make_palindrome(ARGV[0])",
  "  string_to_test = string.to_s.chars.reverse.join('')\n  while string_to_test.start_with?(string)\n\
    \    string_to_test = string_to_test.slice(0,string.index(string_to_test[/.*/].reverse))\n\
    \  end\n  string_to_test\nend", "  string.upcase!\n  prefix = string\n  while\
    \ prefix.chars.reverse!.empty?\n    prefix, prefix = prefix.chars.reverse!, prefix.insert(-1,\
    \ prefix.chars[-1])\n  end\n  string + prefix + prefix.chars.reverse!\nend", " \
    \ longest_palindrome = ''\n  longest_palindrome += string\n  \n  string.split(\"\
    \").reverse.each_with_index do |letter, index|\n    longest_palindrome += letter\n\
    \    if index != (string.length - 1).to_i\n      longest_palindrome += string[-index..-1]\n\
    \    end\n    \n    if longest_palindrome == string.downcase\n      longest_palindrome\n\
    \    end\n  end\nend", '  reversed_string = string.reverse', "  longest_prefix\
    \ = string.chars.reverse.chars.reverse\n  p =  longest_prefix + longest_prefix[0,\
    \ string.length]\n  p += string\n  p =  longest_prefix + (longest_prefix.reverse)[0,\
    \ string.length]\n  return p\nend", "  while string.length > 0\n    break if string.length\
    \ > 1 && ! string[0,1] == string[-1,0]\n    string << string[0,1]\n  end", " \
    \ begin = string.size >> 1\n  end = string.size - begin\n  middle = string.size\
    \ - end - 1\n  middle = middle if middle > 0 else 0\n  middle = middle<<1 >> 1\n\
    \  middle = middle if middle < string.size else string.size", "  max_length =\
    \ string.size\n  max_prefix = 0\n  postfix = \"\"", "  if string == nil\n    return\
    \ string\n  end\n  postfix = []\n  prefix_length = 0\n  until postfix.empty?\n\
    \    prefix_length += 1\n    postfix.unshift(string[prefix_length..-1].reverse)\n\
    \    if string[prefix_length..-1] == string[prefix_length..-1].reverse\n     \
    \ return string[prefix_length..-1]\n    end\n  end\nend", "  max_length = 0\n\
    \  max_length = longest_palindrome_postfix(string)", "  max_length = find_max_length(string)\n\
    \  prefix      = string[0..max_length].reverse\n  suffix      = string[-max_length..-1].reverse\n\
    \  longest_postfix = prefix + suffix\n  max_length    = find_max_length(longest_postfix)\n\
    \  prefix       = string[0..max_length].reverse\n  suffix       = string[-max_length..-1].reverse\n\
    \  postfix_palindrome = prefix + longest_postfix + suffix\n  return postfix_palindrome\n\
    end", "  if string.empty?\n    return \"\"\n  max_length = 0\n  longest_postfix\
    \ = 0\n  longest_postfix_str = \"\"\n  longest_prefix_str = \"\"\n  longest_prefix\
    \ = nil\n  longest_postfix = string.chars.rindex(\"-\")\n  longest_prefix_str\
    \ = string[0...longest_postfix]\n  longest_prefix_str = longest_prefix_str.chars.reverse\n\
    \  longest_prefix_str + string[longest_postfix+1..-1]\n  max_length = longest_prefix_str.length\n\
    \  while longest_postfix_str.length > max_length\n    max_length = longest_prefix_str.length\n\
    \    longest_postfix = longest_postfix - 1\n    longest_postfix_str = string[0...longest_postfix]\n\
    \    longest_postfix_str = longest_postfix_str.chars.reverse\n    longest_prefix_str\
    \ + longest_postfix_str\n  end\n  max_length = longest_prefix_str.length\n  while\
    \ longest_prefix_str.length > max_length\n    max_length = longest_prefix_str.length\n\
    \    longest_prefix = longest_prefix - 1\n    longest_prefix_str = string[0...longest_prefix]\n\
    \    longest_prefix_str = longest_prefix_str.chars.reverse\n    longest_prefix_str\
    \ + longest_prefix_str\n  end\n  return longest_prefix_str + longest_postfix_str\n\
    end", "  if string.empty?\n    \"\"\n  else\n    longest_prefix = find_longest_prefix_of_palindrome(string)\n\
    \    beginning_of_palindrome = longest_prefix + string[longest_prefix.length..-1]\n\
    \    string.replace(beginning_of_palindrome, beginning_of_palindrome.reverse)\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,algorithm,string |>\n<| c |>\nThis will\
    \ not work for the case `make_palindrome.call(\"acata\")`\n<|/ c |>\n<| c |>\n\
    I didn't test it with your test cases. Do you have any test cases that it fails\
    \ on? I'll update my answer if so.\n<|/ c |>\n<| c |>\n`make_palindrome.call(\"\
    ab\")` should return \"ab\".  Same for `make_palindrome.call(\"abaabc\")`.  My\
    \ answer is returning `\"abc\"`\n<|/ c |>\n<| c |>\nAh, I see your point. This\
    \ will work if we replace `string` with `string.reverse` on line 12 in the above\
    \ code snippet. I'll update my answer shortly.\n<|/ c |>\n<| a tags=ruby,algorithm,string\
    \ dscore=1 |>\nI think this can be solved simply by creating a function that will\
    \ return a palindrome of the string passed as an argument. For example:\n<code>",
  "  unless string.length > 0\n    return string\n  end\n  \n  beginning_with_substring\
    \ = string.slice(0,string.length/2)\n  \n  reverse_string_palindrome = string[string.length/2..-1]\n\
    \  \n  reverse_string_palindrome += beginning_with_substring.split(reverse_string_palindrome).reverse.join(\"\
    \")\n  \n  reverse_string_palindrome.reverse\nend", "  string.length >= 2 ? \n\
    \    string + (\"#\" + string.reverse.chars.take(string.index(\"#\")).join).reverse\
    \ : \n    \"\"\nend\n</cell>\n<cell>\n%debug\n</cell>\n<cell>\nmake_palindrome.call(\"\
    asdfas\")\n</cell>\n<cell>\n\"#\".length\n</cell>\n<cell>\n\"#\".length\n</cell>\n\
    <cell>", "  \n  return string.split(//).reverse.inject(\"\", &:+).reverse\nend",
  "  if string.length == 0\n    string\n  else\n    string.split(\"\").reverse.join(\"\
    \").split(\"\").reverse.join(string).split(\"\").reverse.join(\"\")\n  end\nend",
  "  max_len = find_max_length(string)\n  prefix = string.split[0...max_len].reverse.join\n\
    \  suffix = string.split[max_len..-1].join\n  postfix = prefix + suffix\n  max_len\
    \ = find_max_length(postfix)\n  postfix = postfix.split[0...max_len].reverse.join\n\
    \  postfix = postfix.split[max_len..-1].join\n  postfix = postfix.split[0...max_len].join.reverse\n\
    \  return postfix if max_len > 0 and prefix == postfix && postfix.reverse.chars.any?\
    \ {|c| c == c}\n  return nil\nend", "  if string.nil?\n    return string\n  else\n\
    \    prefix = string\n    suffix = string.reverse\n    suffix = suffix.chomp if\
    \ suffix.length >= string.length\n    prefix = prefix.reverse\n    prefix += suffix\
    \ unless prefix == string\n    return prefix\n  end\nend", "  longest, shortest\
    \ = \"\", \"\"\n  string.split(\"\").reverse.each do |char|\n    longest = longest\
    \ + char\n    longest = longest.upcase if longest.downcase == longest\n    shortest\
    \ = shortest + char\n    shortest = shortest.downcase if shortest.downcase ==\
    \ shortest\n    break if longest == shortest\n  end\n  longest.reverse! + shortest\n\
    \  longest\nend", "  length = string.length\n  return string.chars.reverse.join\
    \ if length < 2 || string[0,length].eql?(string[length,length]) \\\n    && (string[0,length-1]\
    \ == string[length-1,length-1]) \\\n    && (string.chars.reverse.join == string[0,string.length-1]).length\
    \ \\\n    && string.length >= 3 \\\n    && (string[0,length-1] == string[length-1,length-1])\
    \ \\\n    && (string.chars.reverse.join == string[0,string.length-1]).length \\\
    \n    && string.chars.reverse != nil \\\n    && (string[0,length-1] == string[length-1,length-1])\
    \ \\\n    && (string.chars.reverse.join == string[0,string.length-1]).length \\\
    \n    && string.chars.reverse != nil \\\n    && (string[0,length-1] == string[length-1,length-1])\
    \ \\\n    && (string.chars.reverse.join == string[0,string.length-1]).length \\\
    \n    && (string.chars.reverse == string[0,length-1].reverse)\nend", "  longest_palindrome\
    \ = string.dup\n  i = 1\n  while i < string.length\n    middle = string.slice(i..string.length)\n\
    \    if middle == middle.reverse\n      longest_palindrome[i - 1] = string[i -\
    \ 1]\n      i = i + 1\n      longest_palindrome << middle\n      i += 1\n    else\n\
    \      i += 1\n    end\n  end\n  return longest_palindrome\nend", "  # Base case.\n\
    \  return string if string.empty? # Nil is a palindrome\n  # Find longest postfix\
    \ that is a palindrome.\n  start_of_palindrome = nil # Start of the palindrome\
    \ suffix\n  i = string.size\n  while i > 0\n    char = string[i - 1]\n    j =\
    \ i\n    j = string.size - 1 while j < string.size\n    if char == string[j]\n\
    \      j += 1\n    end\n    length = j - i + 1\n    # Check if the longest palindrome\
    \ suffix of suffix starts with supplied string.\n    if string[start_of_palindrome\
    \ + length - 1].to_s == char.to_s\n      # If yes, we are done.\n      return\
    \ string\n      # Prepare the palindrome suffix starting with supplied string.\n\
    \      start_of_palindrome = start_of_palindrome + length\n      i = j\n    else\n\
    \      # Prepare the palindrome suffix ending with the longest palindrome suffix\
    \ of suffix starting with supplied string.\n      string = string.sub(\n     \
    \   i, j, char + string[start_of_palindrome..-1].reverse\n      )\n      start_of_palindrome\
    \ = start_of_palindrome - 1\n    end\n  end\n  # We are at the end of the string.\n\
    \  string\nend", "  return string + (reverse_suffix(make_postfix_from_string(string))\
    \ << make_postfix_from_string(string))\nend", "  longest_palindrome = find_longest_palindrome(string)\n\
    \  longest_palindrome.is_a?(String) ? longest_palindrome + reverse(string[longest_palindrome.size..-1])\
    \ : nil\nend\n</code>\nThis works well for a string of length 3 or less. If the\
    \ string is longer than that, however, the algorithm will fail with a 'no method\
    \ error'.\n<|/ a |>\n<| a |>\n<code>", "  length = (string.size + 1) * string.size\n\
    \  suffix_len = string.length\n  return reverse(string[0, suffix_len]) + string[0,\
    \ length]\nend", "  result = \"\"\n  result = (string + reverse(string)).strip\n\
    \  return result unless string.empty?\n  result = string.chars.take_while do |char|\n\
    \    char == result.chars.last\n  end\n  result += string.chars.drop(result.length)\n\
    \  result = make_palindrome(result.to_s)\n  result.insert(0,result)\nend", " \
    \ max_len = string.size\n  mid = string.size/2", "  return string.gsub(/(?<=\\\
    A|\\b)/, '').gsub(/(\\A|\\b)/) { |s| s.reverse }.join\nend", "  min_length = string.size\n\
    \  max_length = string.length\n  if string == string.upcase\n    return string\n\
    \  while max_length > min_length\n    min_length = min_length/2\n    max_length\
    \ = max_length/2\n    string = string[0, min_length] + string[0, max_length]\n\
    \    break if string.eql?(string.upcase)\n  return string\nend\n</code>\n<|/ a\
    \ dscore=4 |>\n<| c |>\nThis is the best solution. My other solutions (the ones\
    \ that use a `reverse` method) fail for some test cases.\n<|/ c |>\n<| c |>\n\
    This solution also fails for cases like \"aba\" as it will return \"a\"\n<|/ c\
    \ |>\n<| c |>\nI wonder if there's a way to avoid the `reverse_string` method\
    \ (which would just be one line instead of two) if we could just use recursion\
    \ to traverse the string.\n<|/ c |>\n<| c |>\n: I don't think there's a way to\
    \ avoid the `reverse_string` method other than writing it yourself (or writing\
    \ an extension method). It's actually a pretty nice solution.\n<|/ c |>\n<| c\
    \ |>\nI wrote an extension method that uses recursion. Check my answer.\n<|/ c\
    \ |>\n<| a dscore=4 tags=algorithm,ruby,palindrome |>\n<code>", "  \n  resulting_string\
    \ = string.dup\n  \n  if string.size <= 1\n    return string\n  else\n    prefix\
    \ = \"#{string[0, string.size - 1]}\"\n    postfix = string.reverse\n    \n  \
    \  resulting_string << postfix\n    \n    longest_postfix = postfix.size\n   \
    \ \n    postfix.reverse_each do |c|\n      resulting_string << prefix[c]\n   \
    \   longest_postfix = longest_postfix.abs if longest_postfix > c.size\n    end\n\
    \    \n    if longest_postfix < string.size\n      resulting_string << prefix[0,\
    \ longest_postfix - 1]\n    end\n    \n    return resulting_string\n  end\nend",
  "  if string.empty?\n    string\n  elsif string == reverse(string)\n    string\n\
    \  elsif !string.ends_with?(string.reverse)\n    string\n  else\n    string <<\
    \ reverse(string[0..(string.length-1)])\n  end\nend", "  string = string.split(//).reverse.join//\n\
    \  if string.length == 1\n    string\n  else\n    string[0..length-1..-1] + make_palindrome(string[0..length-1..-1])\
    \ + string[0..length-1..-1]\nend", "  return if string.empty?\n  longest = find_longest_prefix(string)\n\
    \  reverse_string = longest + reverse(string)\n  reverse(string)\n  string <<\
    \ reverse_string\nend", "  return string + \"~\" + reverse(string[1..-1]) if string\
    \ =~ /(?:(.)(?!\\1))(.)/m \n  ", "  longest, longest_index = [\"\", 0]\n  for\
    \ i in 0...string.length\n    index = string.index(i, longest_index) + 1\n   \
    \ longest = string[longest_index..index]\n    longest_index = index\n    break\
    \ if longest == string.reverse\n  longest\nend", '  longest_palindrome = nil',
  "  max_len = -1\n  while max_len <= 0\n    string.reverse\n    max_len = string.rindex(\"\
    0\") + 1\n    string[-max_len..-1]\n  end\n  string.join(\"\")\nend", "  s = string.dup\n\
    \  longest = longest_palindrome(s)\n  return s << longest\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nThanks I really like this idea. It would take me a while to translate\
    \ it into Ruby but I'm sure I could do it.\n<|/ c |>\n<| c |>\nIt looks like this\
    \ approach will work. I just have to get my head around recursive algorithms so\
    \ I can convert it to Ruby code quickly.\n<|/ c |>\n<| c |>\nThe only thing that\
    \ confuses me is that this code doesn't return the correct answer for my sample\
    \ test case that I put in the original question. ", "  return string if string\
    \ == reverse(string) else\n    string + reverse(string[0 .. (string.length - 1)])\n\
    end", "  result = ''\n  length = 1\n  while string != result\n    result << string[length..-1]\n\
    \    length += 1\n  end\n  result << string[length..-1]\n  result\nend", "  result\
    \ = \"#{string}#{string.reverse}\"\n  result[0...(string.length/2)] << result[(string.length/2)+1..-1]\n\
    \  return result\nend\n</code>\n<|/ a |>\n<| c |>\nJust a note: the reason you\
    \ got incorrect output in your original question is that you were using the string\
    \ \"cat\" as your example, but if you replace it with `\"\"`, it breaks. That's\
    \ because in Ruby, an empty string is equivalent to nil. Thus, if you call `make_palindrome.call(\"\
    cat\")` with your original code, you get `\"cat#{nil.reverse}\"`. This is the\
    \ correct version, though: replace `\"cat\"` with `\"\"`.\n<|/ c |>\n<| c |>\n\
    Very nice solution! Thank you!\n<|/ c |>\n<| c |>\nThank you. I used your logic\
    \ to find an even more efficient solution that was less readable, but also less\
    \ efficient. Will post it as an answer. :)\n<|/ c |>\n<| c |>\nCan you post your\
    \ solution as well? That would be interesting.\n<|/ c |>\n<| c |>\nPosted it as\
    \ an answer. :)\n<|/ c |>\n<| a tags=ruby,algorithm,string dscore=1 |>\nA more\
    \ efficient solution based on what suggested in their comments:\n<code>", "  if\
    \ string.empty?\n    string\n  elsif string.length <= 2\n    string\n  else\n\
    \    string[(string.length/2).downto(0).zip(string.chars.reverse).first].gsub!(/./)\
    \ { |e| e.downcase }\n    make_palindrome(string[(string.length/2).downto(0)..-1])\n\
    \  end\nend", "  palindrome = string.downcase\n  string.gsub!(/(\\W)/) { |p| palindrome[p]\
    \ }\n  string.reverse!\n  string << palindrome\nend", "  return string.length\
    \ >= 2 ? string + reverse(string[0...(string.length-1)]) : string\nend\n</code>\n\
    <|/ a tags=ruby,algorithm |>\n<| a |>\n<code>", "  reversed_string = reverse(string)\n\
    \  postfix_len = find_palindrome(string, :reverse, :postfix_length)\n  string.insert(0,\
    \ reversed_string)\n  string.insert(postfix_len, reversed_string)\n  string.strip!\n\
    end", "  palindromic = \"\"\n  length = string.length\n  prefix_length = length\
    \ - (length % 2)\n  prefix_string = \"\"\n  if prefix_length > 0\n    prefix_string\
    \ = string.slice(prefix_length)\n    prefix_string << string[prefix_length]\n\
    \    prefix_string.reverse_each do |char|\n      palindromic << char\n    end\n\
    \  end\n  postfix_length = length - (length % 3)\n  postfix_string = \"\"\n  if\
    \ postfix_length > 0\n    postfix_string = string[postfix_length]\n    postfix_string.slice!(0)\n\
    \  end\n  palindromic << prefix_string << postfix_string\n  palindromic\nend",
  "  unless string && string.length > 0\n    return string\n  end\n  \n  max_palindrome_length\
    \ = string.length\n  reverse_string = \"\"\n  \n  max_palindrome_length.times\
    \ do |i|\n    next_string = string.slice!(i)\n    reverse_string << next_string\n\
    \    if next_string == next_string.reverse!\n      break\n    end\n  end\n  \n\
    \  reverse_string << string.reverse!\n  \n  max_palindrome_length.times do |i|\n\
    \    next_string = string.slice!(i)\n    reverse_string << next_string\n    if\
    \ next_string == next_string.reverse!\n      break\n    end\n  end\n  \n  return\
    \ reverse_string\nend", "  suffixes = []\n  suffix_length = 0\n  for i in string.chars\n\
    \    if i.is_a?(Fixnum) || (i.is_a?(String) && i.empty?)\n      suffix_length\
    \ += 1\n    elsif i.is_a?(Fixnum) && i.odd?\n      suffixes.push i\n    elsif\
    \ i.is_a?(String) && i.empty?\n      suffixes.push i\n    elsif i.is_a?(String)\
    \ && i.length <= suffix_length\n      suffixes.push i\n    elsif i.is_a?(String)\
    \ && i.length < suffix_length && i.chars.reverse.include?(i)\n      suffixes.push\
    \ i\n    end\n  end\n  \n  suffix = suffixes.sort.last\n  \n  if suffix.is_a?(Fixnum)\n\
    \    string[suffix_length..-1] += string[0...suffix_length][suffix.to_i..-1]\n\
    \  else\n    string[suffix_length..-1] += string[0...suffix_length][suffix.to_s][0...suffix.to_s.length]\n\
    \  end\n  \n  string\nend", "  longest_postfix = longest_prefix_palindrome(string)\n\
    \  first_prefix = string.sub(longest_postfix, 0, longest_postfix)\n  first_postfix\
    \ = string.sub(longest_postfix, longest_postfix)\n  first_prefix = first_prefix\
    \ + first_postfix\n  first_prefix_reversed = first_prefix.reverse\n  result =\
    \ first_prefix_reversed + first_postfix\n  return result\nend", "  unless string.empty?\n\
    \    palindrome = string\n    prefix = \"\"\n    string.split(//).reverse.each\
    \ do |char|\n      suffix = char + palindrome\n      palindrome = suffix\n   \
    \   prefix = char + prefix\n    end # string.reverse.each\n    prefix += palindrome\n\
    \  end # unless string.empty?\n  return prefix\nend", "  string = string.split(//).map(&:capitalize).join(\"\
    \ \")\n  length = string.length\n  max_length = find_max_palindrome_length(string,\
    \ length)\n  max_length = max_length.nil? ? nil : max_length\n  first_half = string.sub(0,\
    \ max_length)\n  second_half = string.sub(max_length..-1)\n  first_half + second_half\
    \ + \"#{reverse_string(first_half)}\"\nend", "  return string + ((string =~ /\\\
    w+/).to_s * (string.length + 1).to_s.reverse).slice(-(string.length + 1)) if string.is_a?\
    \ String\nend", "  string\n  # If the string is empty or already a palindrome,\
    \ then simply return the string.\n  return string if string.empty? or is_palindrome(string)\
    \ \n  # Find the longest postfix of supplied string that is a palindrome.\n  postfix\
    \ = reverse(string)\n  # Append to the end of the string reverse of a string prefix\
    \ that comes before the palindromic suffix.\n  postfix = reverse(string[/\\w+\\\
    z/] ? string.match(/\\A\\w+\\z/ ) : string, postfix)\n  # Return the concatenation\
    \ of the longest postfix and the reverse of the supplied string prefix.\n  return\
    \ postfix.concat(string.slice(0,/\\w+\\z/] ? string.match(/\\A\\w+\\z/ ) : string))\n\
    end", "  max_len, max_char = string.size, string[0]\n  max_postfix_start = (max_char.size..max_len).to_a.find\
    \ { |i| string[-i..-1] == string[0..i] }\n  max_postfix_start = max_postfix_start.succ\
    \ if max_postfix_start\n  max_postfix_end =  max_postfix_start + (string[max_postfix_start..-1].size\
    \ + 1).to_a\n  max_postfix = string[0..max_postfix_start-1] + string[max_postfix_start...max_postfix_end]\n\
    \  max_postfix = max_postfix.reverse\n  return max_postfix + string[max_postfix_start...-1]\n\
    end\n</code>\nI should note that I did not test it on non-palindrome strings,\
    \ but I assume you know how to use make_palindrome.  I leave it to you to figure\
    \ out how to do that.\n<|/ a tags=ruby,string |>\n<| c |>\nWow. I'm surprised\
    \ that Ruby didn't include this feature in the standard library. Thanks for the\
    \ ideas. :)\n<|/ c |>\n<| c |>\nI guess it wasn't intentional that it would be\
    \ a palindrome-finding algorithm?  You just have to write it yourself.\n<|/ c\
    \ |>\n<| c |>\nI thought about doing that, but I thought I'd see if there's a\
    \ built-in way to do it. I guess it's possible that it's not worth it, but I wanted\
    \ to ask this question to see if I was missing something.\n<|/ c |>\n<| c |>\n\
    The built-in way is really just writing a method that takes a string and returns\
    \ it if it's a palindrome.\n<|/ c |>\n<| c |>\nI guess it's just because most\
    \ palindrome finding algorithms don't work so well on non-palindrome strings.\
    \  (The algorithm I wrote just assumes a palindrome is a string that has at least\
    \ two different characters, like \"racecar\")\n<|/ c |>\n<| a dscore=1 |>\n<code>",
  "  string.length.downto(0) do |i|\n    string.reverse.prepend(string.slice!(0, i).to_s)\n\
    \    break if string.length == 0\n  end\n  string\nend\n</code>\n<|/ a tags=ruby,string\
    \ dscore=0 |>\n<| c |>\nThanks, this was useful. I just wanted to show a recursive\
    \ solution to this problem, which is why I accepted that one as the answer, but\
    \ yours really helped me understand recursion.\n<|/ c |>\n<| a dscore=0 |>\n<code>",
  "  max_length = 0\n  max_length_of_longest_postfix = []\n  longest_postfix = []\n\
    \  postfix_to_be_appended = nil\n  string.split(//).each do |character|\n    postfix_to_be_appended\
    \ = \"\"\n    max_length_of_longest_postfix.each { |l| postfix_to_be_appended\
    \ << l }\n    postfix_to_be_appended << character\n    max_length = max_length\
    \ if character == postfix_to_be_appended.reverse\n    max_length_of_longest_postfix.push(character.length)\n\
    \    longest_postfix.push(postfix_to_be_appended)\n  end\n  return longest_postfix[0]\
    \ if max_length == max_length_of_longest_postfix[0]\n  return \"\"\nend", "  start_index\
    \ = find_longest_palindrome_postfix_index(string)\n  string.insert(start_index,\
    \ \"#\" + string.rjust(start_index, string.length, \"#\"))\n  string\nend", " \
    \ string = string.to_s\n  return string.chars.sort.join.downcase\nend", "  length\
    \ = string.size\n  i = 0\n  reversed = \"\"\n  while i < length\n    if string[i]\
    \ == string[length - i - 1]\n      i += 1\n    else\n      if i < length - 1\n\
    \        reversed += string[i]\n      end\n    end\n  end\n  reversed += string[i\
    \ - 1]\n  reversed += string[length]\n  return reversed\nend", "  max_len = string.size\n\
    \  longest = ''\n  suffix = ''", "  longest = longest_palindrome(string)\n  result\
    \ = string + longest.downcase\n  result + (longest.upcase + string).reverse\n\
    end", "  reverse_string = string.downcase\n  max_length = reverse_string.size\n\
    \  reverse_string[0..max_length].reverse\n  string = string + reverse_string\n\
    \  string[0..max_length]\nend", "  string.scan(/\\w/).each do |word|\n    if word.size\
    \ > string.length\n      string << word.reverse\n    end\n  end\n  string\nend",
  "    letters = string.split(\"\")\n    prefix_letters = letters.reverse.last\n \
    \   prefix_letters.prepend(letters)\n    letters.reverse.last\n    letters.join(\"\
    \")\nend", "  string.gsub(/(?<=^|$)|\\z|[^a-z]/).reverse!\n  string << string.gsub(/(.)(?!\\\
    1)/).reverse\nend", "  string.gsub(/^./) {|s| s + s[0..-2]}\n  string.gsub(/([a-z])([a-z])/)\
    \ {|s| $1 + $2 + $1 }.gsub(/([a-z])([a-z])([a-z])/) {|s| $1 + $2 + $1 + $2 }.gsub(/([a-z])([a-z])([a-z])([a-z])/)\
    \ {|s| $1 + $2 + $1 + $2 + $3 }.gsub(/([a-z])([a-z])([a-z])([a-z])([a-z])/) {|s|\
    \ $1 + $2 + $1 + $2 + $3 + $4 }\nend", "  return string if string.empty? || is_palindrome(find_palindrome(string))\
    \ else string + reverse_palindrome(find_palindrome(string))\nend", "  if string.empty?\n\
    \    string\n  else\n    prefix_length = string.rindex(\"a\") + 1\n    string\
    \ = prefix_length + string.dup.reverse[prefix_length..-1]\n    string.sub!(/^a/,\
    \ '')\n    string\n  end\nend", "    string_palindrome = \"\"\n    max_length\
    \ = 0\n    begin_index = 0", "  original_length = string.size\n  rev_string =\
    \ string.reverse\n  max_length = string.size - 1\n  prefix = \"\"", "  max_length\
    \ = string.length\n  max_length_postfix = max_length.to_s.length - 1\n  prefix\
    \ = ''\n  prefix_postfix = max_length_postfix - 1\n  suffix = ''\n  suffix_postfix\
    \ = max_length\n  while string.length > 0\n    if string[prefix_postfix] == \"\
    #\" || string[suffix_postfix] == \"#\" || (string[suffix_postfix] == string[suffix_postfix].upcase)\n\
    \      break\n    else \n      prefix << string[prefix_postfix]\n      suffix\
    \ << string[suffix_postfix]\n      max_length = max_length_postfix\n      max_length_postfix\
    \ = suffix_postfix\n      prefix_postfix -= 1\n      suffix_postfix -= 1\n   \
    \ end\n  end\n  string << \"#{suffix}\"\n  string << \"#\" << (string[suffix_postfix].upcase)\n\
    \  return string\nend\n</code>\n<|/ a tags=ruby,arrays,string,palindrome |>\n\
    <| a |>\nHere's a solution that doesn't use recursion:\n<code>", "  return string.gsub(/\\\
    A([a-z]+)(#{string}+[a-z]+)\\z/, '\\1\\2')\nend", "  # Pad string with spaces.\n\
    \  string += \" \"\n  # Find longest palindromic suffix.\n  suffixes_length =\
    \ string.split.map { |s| s[/[^a-z]+/].length }.max\n  # Convert string to array\
    \ of characters.\n  chars = string.split(\"\").map(&:ord)\n  # Convert postfix\
    \ to array of characters.\n  postfix = chars[0, suffixes_length]\n  # Append reverse\
    \ of postfix to the string.\n  string << chars.reverse.slice(postfix.size, -1).join\n\
    \  # Return the result.\n  string\nend\n</code>\n<|/ a dscore=1 tags=string,ruby\
    \ |>\n<| a tags=string,ruby dscore=0 |>\nI thought of a rather simple solution.\
    \ Maybe the most efficient in terms of space, but also the most complex in terms\
    \ of code. \n<code>", "  return string + \"#\" + string[0..(string.length - 1)].reverse\n\
    end\n    ", "  if string.empty?\n    \"\"\n  else\n    # Find longest palindrome\
    \ prefix of supplied string.\n    l = find_longest_palindrome_prefix_index(string)\n\
    \    # Append reverse of the string prefix to the end of this longest palindrome\
    \ prefix.\n    string << reverse(string[l, 1])\n    # Return the constructed string.\n\
    \    string\n  end\nend\n</code>\n<|/ a tags=algorithm,ruby |>\n<| c |>\nThanks,\
    \ but this is an O(n) solution, which is probably what OP wants as he wrote he\
    \ wants O(log n) solution.\n<|/ c |>\n<| c |>\n: Thanks, I've updated my answer\
    \ to reflect that - OP had a O(n) solution but needed a better O(log n) solution.\n\
    <|/ c |>\n<| a tags=algorithm,ruby dscore=1 |>\nYou want a solution that doesn't\
    \ use any regular expressions. Here is one in Ruby.\n<code>", '  string = string.to_s',
  "  # This will be the palindromic suffix.\n  suffix = \"a\"\n  while string.length\
    \ > 0\n    # We reverse the suffix and append it to the string.\n    suffix =\
    \ string.reverse.chop + suffix\n    string = string.reverse\n  end", "  result\
    \ = []\n  postfix = string.gsub(/[^A-Za-z]/, '')\n  postfix = postfix.reverse.gsub(/[^A-Za-z]/,\
    \ '')\n  if string.start_with?(postfix)\n    result << string.sub(postfix.length)\n\
    \    result << string\n  else\n    return string\n  end\n  result.join\nend",
  "  return string if string.empty? || string.length <= 2 || string.downcase.chars.sort.join(\"\
    \").reverse == string.downcase.chars.sort.join(\"\") ?\n  string :\n  string.downcase.gsub(/\\\
    W/).reverse + make_palindrome(string.downcase.gsub(/(?<=[a-z])([A-Z])/,\"\\1#{string.reverse[-1..-1]}\"\
    ))\nend\n  ", "  postfix_len = string.length\n  palindrome = \"\"", "  palindrome\
    \ = \"\"\n  i = 0\n  while i < string.length\n    j = i + string.length - i -\
    \ 1\n    palindrome << string.slice(i,j)\n    i =  j + 1 if j + 1 < string.length\
    \ else j\n  end\n  i = 1\n  while i < string.length\n    j = i + string.length\
    \ - i - 1\n    string = string.slice(i,j) + \"#\" + string.slice(j+1,string.length)\
    \ if j + 1 < string.length\n    i =  j + 1 if j + 1 < string.length else j\n \
    \ end\n  palindrome\nend\n</code>\n<|/ a tags=ruby,string,algorithm |>\n<| c |>\n\
    Your second algorithm is wrong: `palindrome` is not the smallest palindrome but\
    \ the last one. Also it takes about 5 times more time to finish than the first\
    \ one.\n<|/ c |>\n<| a tags=ruby,string,algorithm |>\nThis problem can be easily\
    \ solved using Ruby and the methods String#reverse, String#split and String#join\
    \ which allows us to make several operations on the string in one line.\n<code>",
  "  string.chars.sort.reverse!\n  string << string << string << string.chars.reverse.first\n\
    end", "  length = string.length\n  string.slice!(0, length)\n  suffix = string.reverse\n\
    \  return string + suffix\nend", "  if string.empty?\n    \"\"\n  elsif string.length\
    \ <= 1\n    string\n  else\n    suffix_length = string.length - 1\n    prefix_length\
    \ = suffix_length + suffix_length/2\n    prefix_end = string.index(string.first,\
    \ prefix_length)\n    prefix_start = prefix_end - prefix_length/2\n    prefix_substring\
    \ = string[prefix_start..prefix_end]\n    reversed_substring = prefix_substring.reverse\n\
    \    prefix_substring = prefix_substring.gsub(/\\W/, \"\") # remove special chars\n\
    \    reversed_substring.reverse!\n    string << \"#{prefix_substring}#{reversed_substring}\"\
    \n  end\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't seem to work for \"abc\"\
    \ => \"a##b\"\n<|/ c |>\n<| a dscore=1 tags=ruby,string |>\n<code>", "  return\
    \ string[0..(string.length+1)-1] + make_palindrome(string[string.length..-1])\n\
    end", "  length = string.length\n  max_postfix_len = 0\n  max_palindrome = \"\"\
    \n  \n  # Find longest postfix that is a palindrome\n  for i in 0...length\n \
    \   if string[-i] == string[-(length-1-i)] && (length-1-i)>0\n      max_postfix_len\
    \ = i\n      break\n    end\n  end\n  \n  # Build palindrome from longest postfix\
    \ and the prefix that comes before the palindromic suffix\n  for i in 0...(length-max_postfix_len)\n\
    \    max_palindrome << string[max_postfix_len+i]\n  end\n  \n  # Return palindrome\n\
    \  return max_palindrome\nend", "  length = (string.length)\n  index = 0\n  while\
    \ index < length/2\n    reversed_string = string.reverse\n    string_index = length\
    \ - index\n    string_palindrome = string[index...string_index]\n    string_palindrome.reverse!\n\
    \    string_palindrome += reversed_string\n    index += 1\n  end\n  string\nend\n\
    </code>\n<|/ a |>\n<| c |>\nIt's an awesome solution\n<|/ c |>\n<| a tags=ruby,palindrome,algorithm\
    \ |>\n<code>", "  max_length = 1\n  max_length_postfix = string.size\n  reverse_of_prefix_suffix\
    \ = \"\"\n  \n  while string.length > 0\n    string = string + \"0\"\n    \n \
    \   while string.length < max_length\n      max_length += 1\n      string = string\
    \ + \"0\"\n    end\n    \n    while string.length > max_length_postfix\n     \
    \ max_length_postfix += 1\n      string = string + \"0\"\n    end\n    \n    string\
    \ = string + \"0\"\n    \n    while string.length < max_length_postfix\n     \
    \ max_length_postfix += 1\n      string = string + \"0\"\n    end\n    \n    reverse_of_prefix_suffix\
    \ = string + reverse_of_prefix_suffix\n  end\n  \n  return reverse_of_prefix_suffix\n\
    end", "  string = string.to_s\n  \n  length = (string.length).to_i\n  \n  first_index\
    \ = (string.length - 1).to_i\n  \n  last_index = string.length.to_i\n  \n  for\
    \ i in 1..length\n    string = string + \"#\" + string[first_index..last_index]\n\
    \    first_index -= 1\n    last_index += 1\n  end\n  \n  string\nend", "  # Create\
    \ a regex to match longest palindrome prefix.\n  prefix = \"^\"\n  suffix = \"\
    \"\n  while string != \"\" and string.chars.reverse.empty?\n    # If the suffix\
    \ is empty, then find the longest palindrome prefix of the remaining string.\n\
    \    # Otherwise, append the longest palindrome prefix and the longest palindrome\
    \ suffix.\n    suffix += \"\\\\1\" + string + \"\\\\1\" + \"\\\\1\"\n    prefix\
    \ = prefix.reverse\n    string = string.chars.reverse\n  end\n  prefix += \"\\\
    \\1\" + string + \"\\\\1\" + \"\\\\1\"\n  prefix += \"$\"", "  string = string.to_s\n\
    \  length = string.length\n  palindrome = \"\"\n  for i in string.chars\n    palindrome\
    \ << i\n    p =string[-i..-1]\n    if p != palindrome[-i..-1]\n      palindrome[-i..-1]\
    \ = p\n    end\n  end\n  palindrome\nend", "  string.dup.\n    chars.\n    sort.\n\
    \    find { |char| char == string.rindex }.\n    each_char.\n    reverse.\n  \
    \  join\nend", "  reverse_of_longest_prefix_of_string_reverse_of_the_longest_postfix_of_string(string)\n\
    \  string + reverse_of_longest_prefix_of_string_reverse_of_the_longest_postfix_of_string(string).reverse\n\
    end", "  s = string.dup\n  return string.empty? or s.reverse.chars.all? { |c|\
    \ c == s.chars.last } ? string : s + make_palindrome(s[0...s.rindex {|s| s ==\
    \ s.reverse.chars.first }-1])\nend", "  longest = longest_palindrome_length(string)\n\
    \  prefix = (string.reverse.chars.to_a << longest).join\n  suffix = string.reverse.chars.to_a.join\n\
    \  string.join(prefix << suffix)\nend", "  longest_postfix = find_longest_postfix_for_palindrome(string)\n\
    \  if longest_postfix.nil? || longest_postfix.length > string.length\n    return\
    \ string\n  else\n    return string + longest_postfix.reverse.first(longest_postfix.length\
    \ - string.length)\n  end\nend", "  return string + reverse(string).sub(/#{string}#{string}/,\
    \ \"\")\nend", "  result = []\n  postfix = []\n  index = 0\n  len = string.length\n\
    \  loop do\n    loop do\n      break unless string[index] == string[len-index]\n\
    \      postfix.push string[len-index]\n    end\n    if string[len-index] == string[len-index-1]\n\
    \      result = \"#{string[0...len-index]}#{string[len-index..-1]}#{string[len-index..-1]}#{postfix}\"\
    \n      break\n    end\n    result << \"#{string[0...len-index]}#{postfix}\"\n\
    \  end\n  result\nend", "  string = string.dup\n  \n  string = longest_palindromic_prefix_of_string(string).downcase\n\
    \  string += string[0 , string.length -1 ].downcase\n  \n  return string\nend",
  "  str = \"\"\n  string.gsub!(/[aeiouy]+/i) { str << $&.chr }\n  string.gsub!(/[a-z]+/i)\
    \ { str << $&.chr }\n  string.gsub!(/[a-z]+/i) { str << $&.chr }\n  string.gsub!(/[a-z]+/i)\
    \ { str << $&.chr }\n  string.gsub!(/[a-z]+/i) { str << $&.chr }\n  string.gsub!(/[a-z]+/i)\
    \ { str << $&.chr }\n  string.gsub!(/[a-z]+/i) { str << $&.chr }\n  string.gsub!(/[a-z]+/i)\
    \ { str << $&.chr }\n  string.gsub!(/[a-z]+/i) { str << $&.chr }\n  string.gsub!(/[a-z]+/i)\
    \ { str << $&.chr }\n  string.gsub!(/[a-z]+/i) { str << $&.chr }\n  string.gsub!(/[a-z]+/i)\
    \ { str << $&.chr }\n  string.gsub!(/[a-z]+/i) { str << $&.chr }\n  string.gsub!(/[a-z]+/i)\
    \ { str << $&.chr }\n  string.gsub!(/[a-z]+/i) { str << $&.chr }\n  string.gsub!(/[a-z]+/i)\
    \ { str << $&.chr }\n  string.gsub!(/[a-z]+/i) { str << $&.chr }\n  string.gsub!(/[a-z]+/i)\
    \ { str << $&.chr }\n  string.gsub!(/[a-z]+/i) { str << $&.chr }\n  string.gsub!(/[a-z]+/i)\
    \ { str << $&.chr }\n  string.gsub!(/[a-z]+/i) { str << $&.chr }\n  string.gsub!(/[a-z]+/i)\
    \ { str << $&.chr }\n  string.gsub!(/[a-z]+/i) { str << $&.chr }\n  string.gsub!(/[a-z]+/i)\
    \ { str << $&.chr }\n  string.gsub!(/[a-z]+/i) { str << $&.chr }\n  string.gsub!(/[a-z]+/i)\
    \ { str << $&.chr }\n  string.gsub!(/[a-z]+/i) { str ", "  if string.nil? or string\
    \ == \"\"\n    return string\n  end\n  postfix, suffix = string.rpartition(string.chars.reverse.join\
    \ )\n  postfix.concat(suffix).concat(string.chars.reverse)\n  postfix.reverse\n\
    end", "  return string + (string.length == 1 ? \"\" : reverse_of_prefix_prefix_of_palindrome(string[1..-1]))\n\
    end", "  if string.length < 1\n    \"\"\n  elsif string.length == 1\n    string\n\
    \  else\n    suffix = \"#{string.length}#{string.reverse}\"\n    prefix_string\
    \ = string[0, string.length-1]\n    prefix_string = prefix_string.reverse\n  \
    \  prefix_string + suffix\n  end\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\n\"\
    Find the longest postfix of supplied string that is a palindrome.\" - This does\
    \ not take into account that the supplied string may be a palindrome.\n<|/ c |>\n\
    <| c |>\nYou're right - I missed that in the question.  I've added the necessary\
    \ conditional and updated my answer.\n<|/ c |>\n<| c |>\nThank you. I've added\
    \ a Ruby 1.9.3 version too if you prefer.\n<|/ c |>\n<| c |>\nNo reason to prefer\
    \ 1.9.3 or 1.8.7.  Ruby 1.8.7 has `String#reverse` built in.\n<|/ c |>\n<| c |>\n\
    Ruby 1.8.7 does not. Not for me. I've had to revert to 1.9.2 to get reverse to\
    \ work.\n<|/ c |>\n<| a |>\nIf it's only a matter of time for you to implement\
    \ this, here's a Ruby 1.9.3 version.  I won't comment on the correctness of it,\
    \ but it's fairly concise and readable to me in my opinion.  It has the following\
    \ advantages:", "  return string + make_palindrome(string.gsub(/(.)\\1/, \"\\\\\
    1\"))\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>", "  rev = string.split(\"\
    \").reverse.join\n  idx = string.index(string.split(\"\").reverse.join)\n  rev(string.slice(0,idx-1))+rev(string.slice(idx))\n\
    end", "  if string.empty?\n    string\n  else\n    reversed_string = \"\"\n  \
    \  post_fixes = string.split(//)\n    post_fixes.reverse.each do |post_fix|\n\
    \      reversed_string << post_fix <<\n        if string.start_with?(post_fix)\n\
    \          string[0, string.rindex(post_fix)]\n        else\n          post_fix\n\
    \        end\n    end\n    reversed_string\n  end\nend\n</code>\nThe algorithm\
    \ works by taking a string, finding it's longest postfix (the longest string that\
    \ is a palindrome), then appending it's reverse of the longest postfix to the\
    \ end of the supplied string. Now we can search for a palindrome by doing this:\n\
    <code>", "  if string.length < 2\n    return string\n  end\n  prefix_length =\
    \ (string.length - 1).downto(0)\n  suffix_length = (string.length - prefix_length).downto(0)\n\
    \  reverse_suffix = (string[suffix_length..-1].reverse + string[prefix_length..-1]).reverse\n\
    \  post_prefix_length = (string.length - suffix_length).downto(0)\n  final_string\
    \ = string[0..prefix_length]\n  final_string += reverse_suffix[1..post_prefix_length]\n\
    \  final_string += string[suffix_length..-1]\n  final_string\nend\n</code>\n<|/\
    \ a dscore=3 |>\n<| c |>\nThe algorithm has two issues. First, it is unnecessarily\
    \ complex, as it only checks half the string. The second issue is that it breaks\
    \ for input such as \"abbb\". In this case, it produces \"abba\" instead of \"\
    abbb\".\n<|/ c |>\n<| c |>\nI believe you meant to test that `prefix_length <\
    \ string.length - 1` rather than `prefix_length > string.length - 1`. Also, `suffix_length\
    \ > string.length - 1`\n<|/ c |>\n<| a |>\n<code>", "  return string.gsub(/(?:(\\\
    w)(\\w*)\\1){2}(?!\\2)/) { |p1, p2| p1 << \"#{$2}#{$1}\" }\nend", "  return string.chars.reverse.first\
    \ if string.chars.reverse.empty? && string =~ /^#{Regexp.quote(string.chars.reverse.first)}/\
    \ else string\nend\n</code>\n<|/ a |>\n<| a |>\nHere is a simple recursive solution\n\
    <code>", "  result = \"\"\n  \n  string.gsub!(/[^a-z]+/i, \"\")\n  \n  start_with_a_letter\
    \ = string.gsub!(/[a-z]/i, \"\")\n  \n  start_with_a_letter.gsub!(/[a-z]/i, \"\
    \") if start_with_a_letter != string\n  \n  start_with_a_letter.gsub!(/[a-z]/i,\
    \ \"\") if start_with_a_letter != string\n  \n  start_with_a_letter.gsub!(/[a-z]/i,\
    \ \"\") if start_with_a_letter != string\n  \n  start_with_a_letter.gsub!(/[a-z]/i,\
    \ \"\") if start_with_a_letter != string\n  \n  start_with_a_letter.gsub!(/[a-z]/i,\
    \ \"\") if start_with_a_letter != string\n  \n  start_with_a_letter.gsub!(/[a-z]/i,\
    \ \"\") if start_with_a_letter != string\n  \n  start_with_a_letter.gsub!(/[a-z]/i,\
    \ \"\") if start_with_a_letter != string\n  \n  start_with_a_letter.gsub!(/[a-z]/i,\
    \ \"\") if start_with_a_letter != string\n  \n  start_with_a_letter.gsub!(/[a-z]/i,\
    \ \"\") if start_with_a_letter != string\n  \n  start_with_a_letter.gsub!(/[a-z]/i,\
    \ \"\") if start_with_a_letter != string\n  \n  start_with_a_letter.gsub!(/[a-z]/i,\
    \ \"\") if start_with_a_letter != string\n  \n  start_with_a_letter.gsub!(/[a-z]/i,\
    \ \"\") if start_with_a_letter != string\n  \n  start_with_a_letter.gsub!(/[a-z]/i,\
    \ \"\") if start_with_a_letter != string\n  \n  start_with_a_letter.gsub!(/[a-z]/i,\
    \ \"\") if start_with_a_letter != string\n  \n  start_with_a_letter.gsub!(/[a-z]/i,\
    \ \"\") if start_with_a_letter != string\n  \n  start_with_a_letter.gsub!(/[a-z]/i,\
    \ \"\") if start_with_a_letter != string\n  \n  start_with_a_letter.gsub!(/[a-z]/i,\
    \ \"\") if start_with_a_letter != string\n  \n  start_with_a_letter.gsub!(/[a-z]/i,\
    \ \"\") if start_with_a_letter != string\n  \n  start_with_a_letter.gsub!(/[a-z]/i,\
    \ \"\") if start_with_a_letter != string\n  \n  start_with_a_letter.gsub!(/[a-z]/i,\
    \ \"\") if start_with_", "  longest_palindrome_prefix, reversed_longest_palindrome_prefix\
    \ = longest_palindrome_prefix_reversed(string)\n  longest_palindrome_suffix, reversed_longest_palindrome_suffix\
    \ = longest_palindrome_suffix_reversed(string)\n  return reversed_longest_palindrome_prefix\
    \ + reversed_longest_palindrome_suffix\nend", "  length = string.length\n  if\
    \ length < 2\n    return string\n  else\n    prefix = string[0,length-1]\n   \
    \ postfix = string[length-1,length]\n    mid = length/2\n    \n    while length>0\n\
    \      mid = length/2\n      \n      begin = string[mid-1,mid]\n      end = string[mid,mid+1]\n\
    \      \n      if begin == end\n        return string[0,mid] + make_palindrome(string[mid+1])\n\
    \      else\n        length = length - 1\n      end\n    end\n  end\nend", " \
    \ if string == \"\"\n    return string\n  mid = string.length / 2\n  palindrome\
    \ = string.dup\n  left = string[0...mid]\n  right = string[mid + 1...string.length]\n\
    \  left << right\n  while left == right\n    left[mid...string.length] << reverse(string[mid..string.length\
    \ - 1])\n    mid = string.rindex(\"a\", 0, string.length)\n  end\n  string <<\
    \ left << reverse(string[mid..string.length - 1])\n  string\nend", "  longest\
    \ = find_longest(string)\n  shortest = find_shortest(string)", "  prefix_length\
    \ = string.size\n  suffix_length = string.size\n  while suffix_length > 0\n  \
    \  suffix_length = string.size - prefix_length\n    prefix_length = string.size\
    \ - suffix_length\n    if string[prefix_length] == string[suffix_length]\n   \
    \   string = string[prefix_length..-1].reverse.prepend(string[prefix_length..-1].reverse)\n\
    \    end\n  end\n  string\nend", "  if string == \"\"\n    string\n  else\n  \
    \  string.downcase!\n    string.chomp!\n    i = string.rindex(string[-1])\n  \
    \  suffix = string[i..-1]\n    string.gsub!(suffix, \"#{suffix}#{suffix.reverse}\"\
    )\n    string\n  end\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks guys for\
    \ the solution. Just for the record, there are several posts already on this subject\
    \ and most of them are incorrect. For example, https://stackoverflow.com/questions/826810/ruby-is-it-possible-to-take-a-strings-reverse-without-making-a-copy-of-it\n\
    <|/ c |>\n<| c |>\nI didn't found any incorrect solution in the posts mentioned\
    \ in the links you mentioned. They don't take input reversal into account and\
    \ they don't take into account multiple matches for one input. Also, I don't agree\
    \ with their definition of shortest palindrome because it doesn't take into account\
    \ the case where palindrome ends before the string itself. For example, `abcba`\
    \ doesn't have length `3` because it doesn't have suffix of `b`. But it does have\
    \ suffix of `c`.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  length = (string.length\
    \ + 1).floor\n  new_string = \"\"\n  i = 0\n  while i < length\n    j = length\
    \ - 1\n    while j > 0\n      if string.slice[i, j] == string.slice[i, j + 1]\n\
    \        new_string << string.slice[i, j]\n        j -= 1\n      else\n      \
    \  break\n      end\n    end\n    i += 1\n  end\n  if new_string == string\n \
    \   new_string << string.reverse\n  end\n  return new_string\nend", "  string\
    \ = string.dup\n  result = []\n  i = 0\n  while i < string.length\n    j = i +\
    \ 1\n    k = j + 1\n    while j < string.length\n      result << string[j..k]\n\
    \      j += 1\n      k += 1\n    end\n    i = k\n  end\n  result.reverse!\n  result\
    \ << string[0...i]\n  result\nend", "  palindrome = string\n  palindrome[palindrome.size\
    \ - 1] = palindrome.chars.reverse.first\n  \n  palindrome[palindrome.size - 1]\
    \ = string[palindrome.size - 1]\n  \n  # Loops through the longest postfix of\
    \ supplied string\n  # and finds palindrome suffix\n  i = palindrome.size - 1\n\
    \  while i >= 0\n    string[i] = palindrome[i]\n    i -= 1\n    if i == 0\n  \
    \    break\n  end\n  \n  # If string is palindrome then remove it from the string\n\
    \  if string == palindrome\n    string.delete_at(palindrome.size - 1)\n  end\n\
    \  \n  return string\nend\n</cell>\n<cell>\n%load palindrome.ipynb\n</cell>\n\
    <text>\nWe are now ready to write a test for the make_palindrome function.", " \
    \ postfix = \"\"\n  length = string.length\n  max_length = 0\n  for i in 0..length-1\n\
    \    current = string[i]\n    next  = string[i+1]\n    postfix = postfix + current\n\
    \    if next == current\n      length = length + 1\n      if length > max_length\n\
    \        max_length = length\n    end\n  end\n  if postfix.length <= max_length/2\n\
    \    return string\n  end\n  palindrome = string\n  palindrome = palindrome[0..(max_length-1)]\n\
    \  for i in 0..(max_length-postfix.length)-1\n    palindrome = palindrome + string[max_length-(i+1)..(max_length-i-1)]\n\
    \  end\n  return palindrome\nend", "  string = string.to_s\n  while string.length\
    \ > 2\n    begin_index = string.rindex(\"p\")\n    middle_index = string.rindex(\"\
    p\", begin_index + 1)\n    end_index = string.rindex(\"p\", middle_index + 1)\n\
    \    if middle_index == -1\n      middle_index = string.rindex(\"p\")\n      end_index\
    \ = string.rindex(\"p\", begin_index + 1)\n    end\n    new_string = string[0,\
    \ middle_index] + string[middle_index + 1, end_index]\n    if new_string == string\n\
    \      return string\n    string = new_string\n  end\n  string\nend\n</cell>\n\
    <text>\nNext up, the test cases. These will come in handy when implementing your\
    \ functions. Run your function against the following test cases. Try to get a\
    \ passing test case before running your function against all of them."]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
