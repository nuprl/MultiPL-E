name: HumanEval_28_concatenate
language: rb
prompt: "# Concatenate array of strings into a single string\n# >>> concatenate.call([])\n\
  # \"\"\n# >>> concatenate.call([\"a\", \"b\", \"c\"])\n# \"abc\"\ndef concatenate(strings)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_concatenate\n\
  \    candidate = method(:concatenate)\n    assert_equal(\"\", candidate.call([]))\n\
  \    assert_equal(\"xyz\", candidate.call([\"x\", \"y\", \"z\"]))\n    assert_equal(\"\
  xyzwk\", candidate.call([\"x\", \"y\", \"z\", \"w\", \"k\"]))\n  end\nend\n"
completions: ["  strings.reduce(:+)\nend", "  strings.reduce(:+)\nend", "  return\
    \ strings.reduce(:+)\nend", "  return strings.length ? strings.join('') : \"\"\
    \nend\nfunction concatenate(strings)\n  return strings.length ? strings.join('')\
    \ : \"\"\nend", "  strings.reduce(:+)\nend", "  return strings.reduce(:+)\nend",
  "  return strings.reduce(:+)\nend", "  return strings.reduce(:<<)\nend", "  return\
    \ strings.inject(\"\", :+)\nend\n</cell>\n<text>\nNow let's test it!", "  strings.reduce(&:+)\n\
    end", "  strings.reduce(:+)\nend", "  strings.reduce(:+)\nend\n</code>\n<|/ a\
    \ tags=ruby,string,arrays,concatenation dscore=5 |>\n<| c |>\nI believe it should\
    \ be \"reduce\" instead of \"inject\". And strings should be an array. ", "  strings.reduce(:+)\n\
    end", "  result = \"\"\n  strings.each do |string|\n    if result.empty?\n   \
    \   result << string\n    else\n      result << \"#{result}#{string}\"\n    end\n\
    \  end\n  result\nend", "  strings.reduce(&:+) if strings && !strings.length.zero?\n\
    end\nalias :+ :concatenate\n</code>\n<|/ a |>\n<| c |>\n`Array#reduce` is an alias\
    \ for `Array#inject`, so why not use `Array#inject` instead? :)\n<|/ c |>\n<|\
    \ c |>\nYou're right, but I find `inject` easier to read and understand.\n<|/\
    \ c |>\n<| c |>\n`Array#inject` is also an alias for `inject`, which doesn't help\
    \ readability.\n<|/ c |>\n<| c |>\nYeah, I suppose I could change it to `inject`\
    \ :)  That makes sense to me and my co-workers, too.\n<|/ c |>\n<| c |>\nI use\
    \ `inject` for \"chaining\" functions (like `inject` and `map`). I think `reduce`\
    \ is clearer to read. `reduce` also lets you `return` from your block, allowing\
    \ you to write `return strings.reduce(&:+) if strings && !strings.length.zero?`\
    \ without having to add parenthesis to the end of the line.\n<|/ c |>\n<| a tags=ruby\
    \ dscore=1 |>\nOne can write it like this, which looks cleaner than's answer\n\
    <code>", "  strings.reduce!{|x, y| x + y }\nend", "  return strings.reduce(::+)\
    \ if strings.is_a? Array\n  return strings\nend", "  strings.inject(:+)\nend",
  "  strings.inject('', &:+)\nend", "  if strings.length > 0\n    strings[0, strings.length\
    \ - 1]\n  else\n    \"\"\nend", "  strings.reduce(:+) \nend", "  strings.reduce(:+)\
    \ || \"\"\nend", "  return strings.reduce(:+)\nend", "  return strings.join\n\
    end", "  strings.inject(\"\", &:+)\nend", "  strings.join\nend", "  if strings.empty?\n\
    \    \"\"\n  else\n    strings.map {|string| string.to_s}.join\n  end\nend", " \
    \ strings.join\nend", "  strings.join\nend\n</cell>\n<cell>\nconcatenate(\"a\"\
    , \"b\", \"c\")\n</cell>\n<text>\nFunctional Programming in Julia\nIn functional\
    \ programming, we typically use functions to transform objects into new objects.\
    \ A function in Julia is defined using function keyword.", "  strings.inject(\"\
    \", :<<)\nend", "  return strings.reduce(:<<)\nend", "  if strings.class == Array\n\
    \    strings.join\n  else\n    strings\n  end\nend\n</pre>\n<p>\nWe can see that\
    \ the method takes one parameter - an Array - and returns a String, which is then\
    \ concatenated to the other elements of the array using a +.\n</p>\n<p>\nThe second\
    \ method is quite similar in its name, except that it prepends the string to the\
    \ beginning of the array instead of concatenating it to the end.\n</p>\n<p>\n\
    The third method is an alternative approach to the first and second methods -\
    \ it prepends <em>all</em> of the strings to the beginning of the array, while\
    \ concatenating all of the strings to the end of the array.\n</p>\n<h2><a name=\"\
    section-26\"></a>Section 26 - Strings Conversions</h2>\n<p>\nIn Ruby, strings\
    \ are considered objects. To convert an object to a string, we use the to_s method.\
    \ For example, let's create a string\n</p>\n<pre>", "  return strings.reduce(:+)\n\
    end", "  return strings.reduce(:+) if strings.kind_of? Array\n  strings\nend",
  "  strings.reduce([]) { |result, string| result + string }\nend", "  strings.reduce(:+)\n\
    end", "  strings.reduce(:+)\nend", "  return strings.inject(\"\", :+)\nend", " \
    \ return strings.length ? strings.join('') : ''\nend", "  strings.reduce(:\"#{[]}\"\
    ).join\nend", "    strings.reduce(:+)\nend", "  strings.inject(\"\", :+)\nend",
  "  if strings.is_a? Array\n    strings.inject(\"\") do |accum, string|\n      accum\
    \ + string\n    end\n  else\n    strings\n  end\nend", "  strings.reduce(:+) ||\
    \ \"\"\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n`join` would be better than\
    \ `reduce`, since you aren't doing anything with your initial value (`\"\"`),\
    \ which may or may not be a `String`\n<|/ c |>\n<| c |>\nI think `reduce` was\
    \ originally added in Ruby 1.8.7 and then removed in 1.9.  I believe `join` is\
    \ more widely supported than `reduce` (although `reduce` is faster than `join`).\n\
    <|/ c |>\n<| c |>\n`join` is definitely more widely supported, `reduce` is only\
    \ available since Ruby 1.8.7 (and therefore also 1.9.2).\n<|/ c |>\n<| c |>\n\
    `join` is more widely supported than `reduce` because it is a core library method\
    \ since 1.8.7, and it is faster. `reduce` is only available in Ruby 1.8.7 and\
    \ 1.9.2.\n<|/ c |>\n<| a |>\nYou can do:\n<code>", "  return strings.reduce(:<<)\n\
    end", "  strings.reduce([]) { |array| array << yield(array) }\nend", "  strings.join\n\
    end", "  return strings.reduce(:<<)\nend", "  strings.reduce(:+)\nend", "  return\
    \ strings.reduce(:+)\nend", "  strings.join\nend", "  strings.reduce(:+)\nend",
  "  return strings.reduce(:+)\nend", "  strings.join\nend", "  strings.join\nend",
  "  strings.reduce(:+) unless strings.length == 1\nend", "  strings.reduce(:+)\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| c |>\nAhh this doesn't work unless the array\
    \ is empty of course. `reduce(:+, '')` works though.\n<|/ c |>\n<| c |>\n`reduce(:+,\
    \ '')` gives me an error. `reduce(:+, [])` gives me `nil`. But `reduce(:+, Array())`\
    \ gives me `\"\"`. Any ideas?\n<|/ c |>\n<| c |>\n`reduce(:+, Array())` returns\
    \ `\"0\"` (string) not `nil` (nil)\n<|/ c |>\n<| c |>\nYou have to specify the\
    \ starting value when your starting value is `nil`. `reduce(:+, nil)` returns\
    \ `nil`, not `\"\"`.\n<|/ c |>\n<| c |>\n: Ah okay, so it's more of a ruby thing,\
    \ not rails. I see it now. Thanks for your reply.\n<|/ c |>\n<| a |>\nIf it's\
    \ acceptable to use inject rather than reduce, here's one way that works:\n<code>",
  "  return strings.reduce(:+)\nend", "  strings.reduce(:+).chomp!\nend\n</code>\n\
    <|/ a dscore=0 tags=ruby-on-rails,string,concatenation,ruby |>\n<| c |>\n`string.join(\"\
    \")` does exactly the same job. `string.join` returns a string and `\"\".concat`\
    \ does a concatenation, which is just `+=`\n<|/ c |>\n<| a tags=ruby-on-rails,string,concatenation,ruby\
    \ dscore=0 |>\nIf you prefer a one liner, you can write:\n<code>\n[a,b,c].join\n\
    </code>\nor \n<code>\na.concat(b,c)\n</code>\n<|/ a |>\n<| c |>\nThe first method\
    \ creates a whole new string where as the second method modifies the existing\
    \ one\n<|/ c |>\n<| c |>\n`a.concat` modifies the existing string.\n<|/ c |>\n\
    <| a |>\n<code>", "  strings.inject(\"\") {|acc, s| acc << s; }\nend", "  strings.reduce(:+)\n\
    end", "  strings.reduce(:+)\nend", "  strings.inject { |s| s + \"\\n\" }\nend",
  "  strings.reduce(:+) || ''\nend", "  return strings.reduce(:<<)\nend", "    strings.inject(\"\
    \", :+)\nend", "  strings.inject(\"\") do |result, string|\n    result << string\n\
    \  end\nend\n</code>\n<|/ a |>\n<| c |>\nThanks so much for the details. I understand\
    \ it now. Just to make sure I understand this correctly, you used the method concatenate\
    \ from the example but changed `def concat` to `def concatenate`\n<|/ c |>\n<|\
    \ c |>\nYeah, it's because `concat` is the wrong name; `concatenate` is the correct\
    \ name for this method. I should note that `concatenate` has been included in\
    \ the Rails core for a while now (http://apidock.com/rails/String/concatenate),\
    \ so if you have Rails installed you should have the `rails` gem installed that\
    \ includes it.\n<|/ c |>\n<| a tags=ruby-on-rails,ruby |>\nYou can achieve the\
    \ same using inject method:\n<code>", "  return strings.reduce(:<<)\nend", " \
    \ strings.join(\"\")\nend\n</code>\n<|/ a |>\n<| a tags=ruby,string |>\n<code>\n\
    [a, b, c, d].join\n</code>\n<|/ a dscore=4 |>\n<| a dscore=4 tags=ruby,string\
    \ |>\n<code>\nstr = \"abc\"\nstr[0...2].upcase", "  strings.reduce(:+)\nend",
  "  if strings.length > 0\n    if strings.length == 1\n      strings[0]\n    else\n\
    \      strings.reduce(:+)\n  end\nend", "  return strings.reduce(:<<)\nend", " \
    \ strings.reduce(:+)\nend", "  result = \"\"\n  strings.each do |s|\n    result\
    \ << s\n  end\n  result\nend", "  strings.join\nend\n</code>\n<|/ a |>\n<| c |>\n\
    What about if i want to concatenate 2 strings and return 1 result? Say a variable\
    \ is called `a` and i want to concatenate `b` and `c` so that it is `\"abc\"`.\
    \ How would I go about doing that?\n<|/ c |>\n<| c |>\nYou wouldn't, at least\
    \ not if you need it for something other than printing. Concatenation is done\
    \ in Ruby, and you can't have two return values in Ruby.\n<|/ c |>\n<| c |>\n\
    I figured that out, I just need to figure out how to make the `result` variable.\n\
    <|/ c |>\n<| c |>\nOh, so if you just want the result to be `\"abc\"` then you\
    \ don't want to concatenate anything, you want to add `\"b\"` and `\"c\"` to `\"\
    abc\"`. You might want to open a new question for that.\n<|/ c |>\n<| c |>\nYeah,\
    \ I want to concatenate `\"b\"` and `\"c\"` into `\"abc\"`\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>", "  return strings.reduce(:+)\nend", "  strings.reduce(:+)\nend",
  "  return strings.join(\", \")\nend", "  result = \"\"\n  strings.each do |string|\n\
    \    result << string\n  end\n  result\nend", "  strings.join\nend\n</pre>\n<p>\n\
    Ruby also supports array literals. In Ruby 1.8, the syntax is:\n</p>\n<pre>\n\
    [1, 2, 3]\n</pre>\n<p>\nIn Ruby 1.9, Ruby now supports array literals with the\
    \ syntax of\n</p>\n<pre>\n[true, false, \"Hello World!\"]\n</pre>\n<p>\nRuby also\
    \ supports array literals with the syntax of\n</p>\n<pre>\n[true, \"Hello World!\"\
    , false]\n</pre>\n<p>\nIn Ruby 1.9, Ruby now supports array literals with the\
    \ syntax of\n</p>\n<pre>\n[\"Hello World!\", true]\n</pre>\n<p>\nRuby also supports\
    \ array literals with the syntax of\n</p>\n<pre>\n[true]\n</pre>\n<p>\nRuby also\
    \ supports array literals with the syntax of\n</p>\n<pre>\n[]\n</pre>\n<p>\nRuby\
    \ also supports array literals with the syntax of\n</p>\n<pre>\n[1, true, 3]\n\
    </pre>\n<p>\nThis syntax is also called a \"splat\". The splat operator also is\n\
    called a \"splat operator\".\n</p>\n<p>\nRuby also supports the splat operator\
    \ with the syntax of\n</p>\n<pre>\n[*[1, 2, 3]]\n</pre>\n<p>\nRuby also supports\
    \ the splat operator with the syntax of\n</p>\n<pre>\n[*1]\n</pre>\n<p>\nRuby\
    \ also supports the splat operator with the syntax of\n</p>\n<pre>\n[*]\n</pre>\n\
    <p>\nRuby also supports the splat operator with the syntax of\n</p>\n<pre>\n[*{}]\n\
    </pre>\n<p>\nRuby also supports the splat operator with the syntax of\n</p>\n\
    <pre>\n[*()]\n</pre>\n<p>\nRuby also supports the splat operator with the syntax\
    \ of\n</p>\n<pre>\n[*()]\n</pre>\n<p>\nRuby also supports the splat operator with\
    \ the syntax of\n</p>\n<pre>\n[*[1,2,3]]\n</pre>\n<p>\nRuby also supports the\
    \ splat operator with the syntax of\n</p>\n<pre>\n[*]\n</pre>\n<p>\nRuby also\
    \ supports the splat operator with the syntax of\n</p>\n<pre>\n[*{}]\n</pre>\n\
    <p>\nRuby also supports the splat operator with the syntax of\n</p>\n<pre>\n[*()]\n\
    </pre>\n<p>\nRuby also supports the splat operator with the syntax of\n</p>\n\
    <pre>\n[*()]\n</pre>\n<p>\nRuby also supports the splat operator with the syntax\
    \ of\n</p>\n<pre>\n[*[1,2,3]]\n</pre>\n<p>\nRuby also supports the splat ", " \
    \ return strings.reduce(:<<)\nend", "  strings = strings.join(\"\\n\")\n  strings.strip!\
    \ if strings.length.odd?\n  strings\nend", "  strings.join\nend\n</code>\n<|/\
    \ a tags=ruby,ruby-on-rails,ruby-on-rails-3,rubygems |>\n<| a |>\nRails 5 adds\
    \ a method String#concat:", "  return strings.inject(\"\") { |result, string|\
    \ result + string }\nend\n</code>\nTo answer the question you asked about a better\
    \ way to implement the concatenate, I think I'd go with what you've already written,\
    \ although I'd probably use the inject method above:\n<code>", "  strings.reduce(:+)\n\
    end", "  return strings.reduce(:+)\nend", "  # If no strings were passed in, just\
    \ return an empty string\n  return strings ? strings.join(\"\") : \"\"\nend",
  "  # Concatenate array of strings into a single string\n  strings.reduce(:+)\nend",
  "    strings.join\nend", "  strings.reduce(:+)\nend", "  return strings.reduce(:<<)\n\
    end", "  # Define a local variable to store the result\n  # We are calling the\
    \ local variable \"result\"\n  # The call \"result = ''\" initializes the local\
    \ variable \"result\" to the empty string\n  result = ''\n  # Loop over each string\
    \ in the array of strings\n  # For each string, we concatenate it to the local\
    \ variable \"result\"\n  # The call \"result += string\" concatenates string to\
    \ the local variable \"result\"\n  # The call \"result += 'a'\" concatenates \"\
    a\" to the local variable \"result\"\n  # The call \"result += 'b'\" concatenates\
    \ \"b\" to the local variable \"result\"\n  # The call \"result += 'c'\" concatenates\
    \ \"c\" to the local variable \"result\"\n  # Then we return the local variable\
    \ \"result\"\n  strings.each do |string|\n    result += \"#{string}\"\n  end\n\
    \  # Return the local variable \"result\"\n  result\nend\n</cell>\n<text>\nPutting\
    \ it all together", "  strings.reduce(:+)\nend", "  return strings.reduce(:+)\n\
    end", "  strings.reduce(:+)\nend", "  strings.reduce(:+)\nend", "  strings.reduce(:+)\n\
    end", "  strings.reduce(:+)\nend", "  strings.reduce(:+).to_s\nend", "  return\
    \ strings.reduce(:+)\nend", "  strings.reduce(:+)\nend", "  return strings.reduce(:<<)\n\
    end", "  strings.inject(\"\", :+)\nend", "  strings.reduce(:+)\nend\n</code>\n\
    <|/ a dscore=5 tags=ruby |>\n<| c |>\n`String` has a `<<` operator which does\
    \ just this :)\n<|/ c |>\n<| c |>\nThat said, using `<<` is a lot more readable\
    \ when concatenating strings in ruby.\n<|/ c |>\n<| c |>\n: I agree. I just find\
    \ `<<` more readable. I think the same could be said about `String`'s `concat`,\
    \ as well.\n<|/ c |>\n<| c |>\n: I agree with you regarding `String#concat`. I\
    \ think `String#<<` is more common, because it's idiomatic to ruby. The `<<` method\
    \ is more commonly used in other languages such as C#.\n<|/ c |>\n<| c |>\n\"\
    I find `<<` more readable\" doesn't make me happy :P\n<|/ c |>\n<| a dscore=5\
    \ tags=ruby |>\n<code>\n\"foo\" + \"bar\"\n</code>\nis pretty fast. \n<code>\n\
    \"foo\".concat \"bar\"\n</code>\nis pretty fast. \n<code>\n\"foo\" + \"bar\" +\
    \ \"baz\"\n</code>\nis pretty slow. \n<code>\n%w(foo bar baz).join\n</code>\n\
    is pretty fast. \n<code>\n%w(foo bar baz).map(&:upcase)\n</code>\nis pretty fast.\
    \ \n<code>\n%w(foo bar baz).map(&:upcase).join\n</code>\nis pretty slow. \n<code>\n\
    'foo'.upcase + 'bar'.upcase + 'baz'.upcase\n</code>\nis pretty slow. \n<code>\n\
    '%w(foo bar baz).join(&:upcase)'\n</code>\nis pretty slow. \n<code>\n'foo'.upcase.to_s\
    \ + 'bar'.upcase.to_s + 'baz'.upcase.to_s\n</code>\nis pretty slow. \n<code>\n\
    '%w(foo bar baz).map{|s| s.upcase}.join'\n</code>\nis pretty slow. \n<code>\n\
    'foo'.upcase.to_s + 'bar'.upcase.to_s + 'baz'.upcase.to_s\n</code>\nis pretty\
    \ slow. \n<code>\n'%w(foo bar baz).map(&:upcase).join'\n</code>\nis pretty slow.\
    \ \n<code>\n'foo'.upcase.to_s + 'bar'.upcase.to_s + 'baz'.upcase.to_s\n</code>\n\
    is pretty ", "  return strings.join.call(*strings)\nend", "  strings.inject(\"\
    \") do |result, value|\n    result + value\n  end\nend\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nThis is really cool. I didn't know you could use `inject()` like\
    \ that.\n<|/ c |>\n<| c |>\nIt should be noted that `inject` will mutate the original\
    \ array in Ruby, so you need to be careful not to call it on an enumerable that\
    \ you are looping over.\n<|/ c |>\n<| c |>\nThis does not work for me (using ruby\
    \ 2.4.1), I get a result of `[[\"hello\"]]`\n<|/ c |>\n<| c |>\nI've added a more\
    \ modern solution to my answer.\n<|/ c |>\n<| a tags=ruby dscore=5 |>\nThe solution\
    \ I found is quite easy. Just use Enumerable#map and Enumerable#join\n<code>\n\
    [\"foo\", \"bar\"].map { |item| item }.join\n</code>\n<|/ a |>\n<| c |>\nthis\
    \ works for me using ruby 2.1.2. What version of ruby are you using? I ran this\
    \ in 1.9.3\n<|/ c |>\n<| c |>\n: Ruby 1.9 doesn't have `map` (and `inject`).\n\
    <|/ c |>\n<| c |>\nYeah, `map` and `inject` are available since 1.9.\n<|/ c |>\n\
    <| c |>\n, Ruby 1.9+ has `inject`, but only if you include the Ruby Enumerable\
    \ module: ", "  strings.reduce(:+)\nend\n</code>\nAnd a little bit of RSpec:\n\
    <code>\ndescribe \"#concatenate\" do\n  it \"concatenates array of strings\" do\n\
    \    concatenate.call([\"a\", \"b\", \"c\"]).should == \"abc\"\n  end\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThe last method seems to concatenate an array of strings.\
    \ Is that correct?\n<|/ c |>\n<| c |>\nYes, you are right. But I thought the question\
    \ was more about getting rid of the `reduce` method call and having the code more\
    \ concise.\n<|/ c |>\n<| c |>\nThanks, that is exactly what I was looking for.\
    \ I'm new to ruby, and I didn't know reduce was an available method.\n<|/ c |>\n\
    <| c |>\nThe last method seems to concatenate an array of strings. Is that correct?\
    \ Can you please help me understand how the last method works?\n<|/ c |>\n<| c\
    \ |>\nI added a little bit of RSpec for you. I hope it helps.\n<|/ c |>\n<| a\
    \ |>\n<code>", "  strings.join(\"\")\nend", "  return strings.reduce(:+)\nend",
  "  strings.reduce(:+).to_s\nend\n</cell>\n<text>\nEjercicio 7\nCrea una funci\xF3\
    n que te d\xE9 una cadena de texto y la llamea con 3 o m\xE1s letras.", "  strings.join\n\
    end", "  strings.reduce(:+)\nend", "  strings.reduce(:+)\nend", "  return strings.inject(\"\
    \", :<<)\nend", "    strings.reduce(:+)\nend", "  return strings.reduce(:<<)\n\
    end", "  return strings.reduce(:<<)\nend", "  strings.join(\"\\000\")\nend", " \
    \ strings.reduce(:+) || \"\"\nend\nalias_method :<<, :concatenate", "  strings.inject(\"\
    \", :+) # inject merges arrays into strings.\nend", "  return strings.reduce(&:+)\
    \ if strings.is_a?(Array) \n  strings || \"\"\nend", "  result = \"\"\n  strings.each_with_index\
    \ { |str, idx|\n    result << str if idx > 0\n  }\n  result\nend", "  return strings.reduce(:<<)\n\
    end", "  return strings.reduce(:+)\nend", "  strings.reduce(:+)\nend", "  strings.reduce(:+)\n\
    end", "  strings.reduce(:+)\nend", "  strings.reduce(:+)\nend", "  strings.reduce(:+).to_s\n\
    end\n</code>\n<|/ a |>\n<| c |>\n`*strings` is a bit better than `strings(0)`\
    \ since `string(0)` is the same as `\"\"` and you're only iterating through the\
    \ string once.\n<|/ c |>\n<| c |>\nGood point, although I *think* that would only\
    \ work if you had one string. Otherwise you'd have to do `strings[0] + strings[1]\
    \ + strings[2]` instead of `strings[0] + strings[1] + strings[2] + strings[3]\
    \ + ... + strings[n]`\n<|/ c |>\n<| c |>\n`strings[0...n]` would do the same\n\
    <|/ c |>\n<| c |>\nNice, I like your use of reduce to reduce an array of strings\
    \ to a string.\n<|/ c |>\n<| a dscore=5 tags=ruby,string,concatenation |>\n<code>\n\
    \"abc\"+\"def\"\n</code>\nwill output abcdef\n<code>\n\"abc\"*3\n</code>\nwill\
    \ output \"abcabcabc\"\n<|/ a |>\n<| c |>\n`*` does some magic and can lead to\
    \ errors. You would have to use a combination of `to_s` on the end instead if\
    \ you want to avoid this.\n<|/ c |>\n<| c |>\nThis is not an answer. It is just\
    \ an addendum.\n<|/ c |>\n<| a tags=ruby,string,concatenation |>\n<code>\n\"a\"\
    \ + \"b\" + \"c\"\n</code>\nwill result in:\n<code>\n\"abc\"\n</code>\nor:\n<code>\n\
    \"a\"+\"b\"+\"c\"\n</code>\nwill result in:\n<code>\n\"abc\"\n</code>\n<|/ a dscore=5\
    \ |>\n<| a dscore=5 tags=ruby,string,concatenation |>\n<code>\na = %w(a b c)\n\
    a.join('')\n</code>\n<|/ a |>\n<| c |>\nThis does work, but is less readable than\
    \ the other answers and is slower if you have an array with many strings.\n<|/\
    \ c |>\n<| c |>\nI don't understand what you mean by \"less readable\". It's like\
    \ saying *\"This is how you do it\"* instead of *The Ruby Way is to do like this\"\
    *.\n<|/ c |>\n<| c |>\nThis actually has a higher runtime than the other solutions.\
    \ With this solution, you can concatenate a string with many strings and then\
    \ only call `join` once. With other solutions, you have to concatenate each string\
    \ separately, call `join` separately and then concaten", "  strings.reduce([].concat)\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis should be the accepted answer.\
    \ It's clear what the intent of the method is, and it's simple enough that a developer\
    \ can easily understand what's going on. Nicely done.\n<|/ c |>\n<| c |>\nI agree\
    \ with this method. Using Array#reduce is a good idea. Just to elaborate, `[1,2,3].reduce(:+)`\
    \ is the same as `3+2+1` where `3` is the starting value. Array#reduce is especially\
    \ useful when you want to apply a block of code to each element of an array and\
    \ have the result return as part of the array. Using #reduce in this way makes\
    \ it easy to return the result of the block as part of the array: `[1,2,3].reduce(:+)`\
    \ is equal to `1+2+3`\n<|/ c |>\n<| c |>\nThanks, that's a much more concise solution.\n\
    <|/ c |>\n<| c |>\nThanks, this is great! I needed to call a method that was expecting\
    \ a variable number of arguments, and this allowed me to do it in 1 line.\n<|/\
    \ c |>\n<| c |>\nThis is the best answer I have seen. Thanks!\n<|/ c |>\n<| a\
    \ tags=ruby,functional-programming |>\nIn Ruby, you can use inject to accomplish\
    \ this:\n<code>\n[1,2,3,4,5].inject(0) { |sum, i| sum + i }\n=> 15\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nThis answer is better than all the others here. Inject\
    \ is more intuitive, it's shorter than reduce and it's shorter to write than the\
    \ others posted here.\n<|/ c |>\n<| c |>\n`inject` is still the best answer for\
    \ Ruby newcomers.  Thanks for reminding me that Ruby has such a useful method!\n\
    <|/ c |>\n<| a tags=ruby,functional-programming |>\nRuby 1.9 introduced the Enumerable\
    \ module which includes a flatten method which does the same as this snippet:\n\
    <code>\n[1,2,3].flatten.inject(0){|sum, i| sum + i}\n</code>\n<|/ a dscore=5 |>\n\
    <| c |>\nI think it would be better if it used `inject` in this case rather than\
    \ `reduce`. `reduce` is good for summing things, but I think it would be better\
    \ to return the entire array rather than the sum.\n<|/ c |>\n<| c |>\nYeah, I\
    \ agree with you", "  strings.inject{|result,s| result+s}\nend", "  strings.reduce([])\
    \ do |memo, string|\n    memo << (string + \"\")\n  end.join\nend", "  strings.reduce(:+)\n\
    end", "  return strings.join.call('')\nend", "  strings.reduce(:+) # Use reduce\
    \ to concatenate all strings\nend", "  strings.inject(\"\") do |result, string|\n\
    \    result << string\n    result\n  end\nend", "  strings.join\nend\n</code>\n\
    And now you can do this:\n<code>\nputs concatenate(['this', 'that']).to_s\n</code>\n\
    <|/ a dscore=5 tags=ruby |>\n<| c |>\nThanks for your answer! I ended up doing\
    \ something similar to your solution. I'll edit my question to show what I did.\n\
    <|/ c |>\n<| c |>\nYou said \"And now you can do this:\" but you're not doing\
    \ anything with `strings` in your code. That's why you get nil.\n<|/ c |>\n<|\
    \ c |>\nAh yeah, my bad. Thanks for your help!\n<|/ c |>\n<| a |>\nRuby has a\
    \ handy Array#join method that is well suited for this\n<code>\n\"this\".join(\"\
    ,\").to_s #=> \"this\"\n</code>\n<|/ a tags=ruby dscore=5 |>\n<| c |>\nBut that\
    \ won't do what OP wants unless he adds `to_s` to `puts` (which is not mentioned\
    \ in his question).\n<|/ c |>\n<| c |>\n: You're right, and he didn't specify\
    \ that, but I assumed that he was just printing out his array for debugging purposes.\n\
    <|/ c |>\n<| a |>\nYou only need to convert your string array to a single string:\n\
    <code>\nputs.join\n</code>\nThat will also work with arrays of strings.\n<|/ a\
    \ dscore=5 tags=ruby |>\n<| a dscore=4 |>\nThe Array#join method does a pretty\
    \ good job at this, so you can also do this:\n<code>\nputs [\"this\", \"that\"\
    ].join \",\" #=> \"this,that\"\n</code>\n<|/ a tags=ruby |>\n<| a dscore=4 |>\n\
    <code>\nputs [\"this\", \"that\"].to_s.split(\",\")\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nThat's what i was looking for! Thanks\n<|/ c |>\n<| c |>\nThis\
    \ is nice. One note: if you're doing this for debugging, you want to strip out\
    \ quotes from elements inside your array: `puts [\"this\", \"that\"].to_s.split(',').map(&:strip)`\n\
    <|/ c |>\n<| a |>\nYou can also use Ruby string interpolation:\n<code>\nputs \"\
    %p, %p\" % [a, b, c]\n</code>\n<|/ a dscore=4 tags=ruby |>\n<| a dscore=3 |>\n\
    For completeness, you can also do this:", "  strings.join\nend", "  return strings.reduce(:+)\n\
    end", "  strings.reduce! {|result, str| result + str }\nend", "  return strings.join(\"\
    \")\nend", "  strings.inject(\"\") do |result, string|\n    result << string if\
    \ string\n  end\nend", "  strings.inject(\"\") do |string, strings|\n    string\
    \ + strings.join(\"\")\n  end\nend", "  strings.reduce(&:+)\nend\n</code>\nAnd\
    \ here's a way to handle a non-string argument and convert it to string:\n<code>",
  "  return strings.reduce(:+) unless strings.empty?\n  \"\"\nend", "  strings.join\n\
    end", "  strings.reduce(:+).to_s\nend\n</code>\nIt uses String#reduce to join\
    \ the strings with an empty string as the start value.\n<|/ a dscore=5 |>\n<|\
    \ c |>\nThis is a great answer. I'm adding it to my favorites.\n<|/ c |>\n<| c\
    \ |>\nThis answer has a bug in it. The first time through `first` will call `first`\
    \ and `last` which will call `first` again. The `reduce` call is skipped, and\
    \ the `first` call will call `first` again.\n<|/ c |>\n<| c |>\nThe `join` method\
    \ of String is now deprecated in favour of [`String#join`](http://ruby-doc.org/core/String.html#method-i-join).\n\
    <|/ c |>\n<| c |>\n: Thanks, I've updated the answer. I was using `join` when\
    \ I wrote this answer originally, but changed to `reduce` because it was a little\
    \ less verbose.\n<|/ c |>\n<| c |>\n`reduce(:+)` can also be written as `inject(:+)`.\n\
    <|/ c |>\n<| a dscore=5 tags=ruby,string |>\nRuby 2.2\n<code>\n\"Hello\".join(\"\
    \ \") #=> Hello \n</code>\nRuby 2.1 & 2.2\n<code>\n\"Hello\".join #=> \"Hello\
    \ \" \n</code>\nRuby 2.3\n<code>\n\"Hello\".join!(\"#\") #=> Hello \n</code>\n\
    <|/ a |>\n<| c |>\nPlease note that join! is not a method on String in ruby 2.3.\
    \ Instead it is called `update`, which was introduced in ruby 2.3.0.\n<|/ c |>\n\
    <| c |>\n, that's correct. But `join!` doesn't exist in Ruby 2.2 or earlier.\n\
    <|/ c |>\n<| c |>\n, `join!` is introduced in Ruby 2.3.0.\n<|/ c |>\n<| c |>\n\
    : That's true, but the `!` syntax was introduced in Ruby 2.1.7, which was released\
    \ just a few days before Ruby 2.3 was released. So unless you upgraded, your solution\
    \ isn't going to work.\n<|/ c |>\n<| c |>\n, that's true, `join!` is Ruby 2.3\
    \ feature. I'll edit my answer.\n<|/ c |>\n<| a dscore=5 |>\n<code>\n'a' + 'b'\
    \ + 'c'.to_s #=> \"abc\"\n'a'.to_s + 'b' + 'c'.to_s #=> \"abc\"\n", "  strings.join\n\
    end", "  return strings.reduce(:|, \"\")\nend\n</code>\n<|/ a dscore=3 |>\n<|\
    \ a tags=ruby |>\nHere's an answer which doesn't require a custom function, only\
    \ an extra require statement:\n<code>", "  strings.join('')\nend", "  strings.reduce(:+)\
    \ || \"\"\nend", "  return strings.reduce(:+) unless strings.nil?\n  return \"\
    \"\nend", "  return strings.join('')\nend", "  strings.reduce(:+)\nend", "  strings.join\n\
    end", "  return strings.reduce(:<<)\nend", "  strings.inject([\"\"]) do |results,\
    \ string|\n    results << string\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nWhy\
    \ not just use the [String#<< method](http://www.ruby-doc.org/core-1.9.3/String.html#method-i-3C-3C)?\n\
    <|/ c |>\n<| c |>\n`String#<<` is destructive and modifies the string you call\
    \ it on. If you want to avoid that and just append to a string without affecting\
    \ the original string, then use [String#+](http://www.ruby-doc.org/core-1.9.3/String.html#method-i-2B).\n\
    <|/ c |>\n<| a |>\nThe question has been answered so far but I thought I would\
    \ add my own two cents.\nThe Array#join method has been around for a long time.\
    \ While I understand how it works internally I do not find it very intuitive and\
    \ most of the times I end up writing a custom join method. \nHere is an example\
    \ of how I would implement a join method\n<code>\nmodule MyString\n  def join(delimiter=\"\
    \")\n    each_char.map { |c| c.to_s }.join(delimiter)\n  end\nend\n</code>\nThe\
    \ downside of using map is that it creates an array and makes it so your are iterating\
    \ over the characters. \nThe alternative is to use each_char and then join directly\n\
    <code>\nmodule MyString\n  def join(delimiter=\"\")\n    each_char.each { |c|\
    \ c }.join(delimiter)\n  end\nend\n</code>\nI feel this way is more intuitive.\
    \ \nI find myself writing my own join method every time I run into this issue\
    \ as I find it useful to know how this works internally. \nA few other things\
    \ you might want to know. \n<code>", "  return strings.reduce(:+)\nend", "  strings.reduce!{|s|\
    \ s << \"\"}\nend", "  strings.reduce(:+)\nend\n</code>\n<|/ a dscore=5 tags=ruby,arrays\
    \ |>\n<| c |>\nI like this one best\n<|/ c |>\n<| c |>\nI like this one. Easy\
    \ to read and understand\n<|/ c |>\n<| a |>\nI like to do:\n<code>\n['1','2','3'].join\n\
    </code>\n<|/ a tags=ruby,arrays dscore=5 |>\n<| c |>\nI like this one too, but\
    \ it seems kinda weird to me that join doesn't exist on arrays. I guess it's just\
    \ because it's so easy to do on strings? Perhaps they did this so they could extend\
    \ it further.\n<|/ c |>\n<| c |>\nHonestly, I didn't know what join did, until\
    \ I looked it up.  http://ruby-doc.org/core-2.0/Array.html#method-i-join\n<|/\
    \ c |>\n<| c |>\nI hate the ruby docs so much. I'd have never figured this out.\
    \ Maybe some people are just too busy teaching people to read a random blog post\
    \ and get frustrated that way.\n<|/ c |>\n<| c |>\nI think this should be the\
    \ accepted answer. One can do just that and learn what it does in no time\n<|/\
    \ c |>\n<| c |>\nThe method join is one of the most useful methods in Ruby. It\
    \ can easily be combined with other methods easily.\n<|/ c |>\n<| a |>\nI like's\
    \ solution, but if you need the array to only have one element or less, you can\
    \ do:\n<code>\n['1','2','3'].to_s\n</code>\n<|/ a tags=ruby,arrays dscore=5 |>\n\
    <| c |>\nBest answer for me - no methods to call.\n<|/ c |>\n<| c |>\nBest answer\
    \ for this question, since it actually shows you how to convert the array to a\
    \ string in one line.\n<|/ c |>\n<| c |>\nGreat solution for only having one element.\n\
    <|/ c |>\n<| a |>\n<code>\nputs [1,2,3].to_s\n</code>\n<|/ a tags=ruby,arrays\
    \ dscore=5 |>\n<| c |>\nIt was an example, it wouldn't work in any context. It's\
    \ equivalent to `puts [1,2,3].join`\n<|/ c |>\n<| a dscore=5 |>\nOne simple solution\
    \ is to use the splat operator (*).\n<code>\nputs [*[1,", "  return strings.inject(\"\
    \", :+)\nend", "  # Initialize our return string\n  result = ''\n  # For each\
    \ string passed in, add it to the result\n  strings.each do |string|\n    result\
    \ << string\n  end\n  # Return it\n  result\nend\n</code>\nThis code will concatenate\
    \ all the strings passed into it. The result would be an empty string if no string\
    \ was passed, or a single string if a single string was passed in.\n<|/ a tags=ruby\
    \ |>\n<| c |>\n`join('')` would be more concise than `call`. Also, `<<` would\
    \ be more concise.\n<|/ c |>\n<| c |>\nYes, those are very good points. I prefer\
    \ `join` over `call` because I find it more concise for readability. I also find\
    \ it more concise for memory management. I'll update my answer. Thanks!\n<|/ c\
    \ |>\n<| c |>\n`join` and `<<` are both very concise, but `join` uses Ruby's `concat`\
    \ method, which is an alias for `<<` -- they both have the same performance. `<<`\
    \ uses Ruby's `<<` method, which is an alias for `+=` -- they both have the same\
    \ memory usage. [Here](http://www.ruby-doc.org/core-1.9.3/String.html#method-i-concat)\
    \ is the doc for the `concat` method.\n<|/ c |>\n<| a |>\nThe \"canonical\" way\
    \ would be to use inject:\n<code>", "  return strings.reduce(:+)\nend", "  strings.reduce(:+)\n\
    end\n  ", "  strings.reduce(:<<)\nend", "  strings.reduce(:+)\nend", "  strings.inject(\"\
    \", :+)\nend", "  strings.inject('') do |buffer, string|\n    buffer << string\n\
    \  end\nend", "  return strings.join\nend", "  strings.reduce(:+) || \"\"\nend\n\
    </code>\nAs for \"#\", it means \"comment\" in the Ruby language (since Ruby 1.9).\
    \ In a comment, # is the start of a comment.\n<|/ a tags=ruby,regex,string,ruby-on-rails\
    \ |>\n<| c |>\n`String#split` doesn't need a block.\n<|/ c |>\n<| c |>\n: Good\
    \ point, I didn't know that. I've updated my answer.\n<|/ c |>\n<| c |>\nThanks\
    \ a lot :) This was really helpful!\n<|/ c |>\n<| c |>\nJust to make sure you\
    \ get the credit, you can make that method shorter (and even more efficient) by\
    \ changing `strings[0]` with `strings.first`. `first` returns a `nil` if the `strings`\
    \ array is empty which would cause the `or` to return `nil`.\n<|/ c |>\n<| c |>\n\
    : I thought about that too. I've added it to the answer. Thanks for the tip!\n\
    <|/ c |>\n<| a tags=ruby,regex,string,ruby-on-rails |>\nYou can use a block and\
    \ join like so:\n<code>\nstr = \"this is a string\"\nstr.join {|s| s.to_s}", " \
    \ if strings.empty?\n    \"\"\n  else\n    strings.reduce(:+).chomp!\n  end\n\
    end", "  strings.join\nend", "  return strings.inject(\"\", :<<)\nend", "  return\
    \ strings.reduce(:+)\nend", "  return strings.reduce(:+)\nend", "  return strings.reduce(:<<)\n\
    end", "  strings.reduce(:+)\nend\nRUBY\n      end", "  strings.reduce! do |string,\
    \ str|\n    string + str\n  end\nend", "  strings.reduce(:+)\nend", "  # Return\
    \ a single string with concatenated input strings\n  # @param array strings: array\
    \ of strings\n  # @return string: concatenated string\n  return strings.reduce(:+).to_s\n\
    end", "  strings.reduce(:+)\nend", "    \"\".concat(*strings)\nend", "  return\
    \ strings.join(\";\")\nend\n</cell>\n<code language=julia-0.6>", "  strings.inject(:+)\n\
    end", "  strings.reduce(:+)\nend", "  strings.reduce(:+)\nend", "  strings.reduce(:+).to_s\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThe original question did not include\
    \ Rails, so this answer does not address the question.\n<|/ c |>\n<| c |>\nThis\
    \ answer does not seem to address multiple string inputs.\n<|/ c |>\n<| c |>\n\
    I fixed the typo in the code (original code had concatenate instead of join),\
    \ thanks!\n<|/ c |>\n<| a |>\nIn Ruby 1.8.7+ you can also use:\n<code>\n\"string1\"\
    .concat(\"string2\")\n</code>\n<|/ a tags=ruby,string dscore=5 |>\n<| a |>\nThe\
    \ String class has a join method which should work nicely:\n<code>\na = \"hello\"\
    \nb = \"world\"\na.join(b) # => \"helloworld\"\n</code>\nIt's not strictly the\
    \ same as Ruby's String#+ method, which also concatenates strings but ignores\
    \ separators.\n<|/ a dscore=5 tags=ruby,string |>\n<| a dscore=4 |>\n<code>\n\"\
    string1\" + \"string2\"\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nRuby will\
    \ automatically concatenate them.\n<|/ c |>\n<| a tags=ruby,string |>\n<code>\n\
    \ \"string1\" + string2\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThe original question\
    \ did not include Rails, so this answer does not address the question.\n<|/ c\
    \ |>\n<| a dscore=3 |>\nYou can do this:\n<code>\n\"string1\" + string2\n</code>\n\
    <|/ a tags=ruby,string |>\n<| a tags=ruby,string |>\n<code>\n\"string1\".concat(\"\
    string2\")\n</code>\nOr another way is to use \"+\" method:\n<code>\n\"string1\"\
    \ + string2\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThe original question did not\
    \ include Rails, so this answer does not address the question.\n<|/ c |>\n<| a\
    \ dscore=3 tags=ruby,string |>\n<code>\n\"string1\".concat(string2)\n</code>\n\
    <|/ a |>\n<| a dscore=3 |>\nYou might want to use a function like:\n<code>", " \
    \ strings.reduce(:+)\nend", "  strings.reduce(:+)\nend", "  strings.join\nend",
  "  return strings.reduce(::Utils::String::Join)\nend", "  strings.inject(\"\", :+)\n\
    end", "  return strings.reduce(:+)\nend\n</code>\n<|/ a |>\n<| c |>\nFor some\
    \ reason, Ruby's `Array#*` doesn't play well with Rails 4's strong parameters.\
    \ `strings * 2` works just fine, but `strings * params[:foo]` doesn't.\n<|/ c\
    \ |>\n<| a tags=ruby,ruby-on-rails dscore=3 |>\nYou can use String#<<:\n<code>\n\
    \"some string\".join(' ') # => \"some string\"\n\"some string\".join(' ') << '\
    \ more' # => \"some string more\"\n</code>\n<|/ a |>\n<| c |>\nThis is what I'm\
    \ looking for, but it doesn't seem to work with Rails. I get a `NoMethodError:\
    \ undefined method '<<' for \"some string\":String`. I'm using Ruby 2.1.1 and\
    \ Rails 4.0.4.\n<|/ c |>\n<| c |>\nIt should work with Rails. Are you sure you're\
    \ calling it on the right object? `<<` is an instance method on `String`, which\
    \ means that `@some_string << ' '` will work.\n<|/ c |>\n<| a dscore=3 tags=ruby,ruby-on-rails\
    \ |>\n<code>", "  if strings.empty?\n    \"\"\n  else\n    strings.reduce(:+).to_s\n\
    \  end\nend", "  strings.inject(\"\") do |result, element|\n    result + element\n\
    \  end\nend", "  strings.join\nend", "  # TODO: Optimize\n  return strings.reduce(:+)\n\
    end", "  if strings.length == 0\n    \"\"\n  else\n    strings.reduce(:+)\nend",
  "  strings.reduce(:+)\nend\n</pre>\n</dd>\n<dt>Ruby <code>Array#join</code></dt>\n\
    <dd>\n<p>Concatenates all the elements into a single string using <code>\",\"\
    </code>.</p>\n<pre class=\"ruby\"><span class=\"ruby-comment\"># Concatenate array\
    \ of strings into a single string", "  strings.reduce(:+).to_s\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
