name: HumanEval_83_starts_one_ends
language: rb
prompt: "# Given a positive integer n, return the count of the numbers of n-digit\n\
  # positive integers that start or end with 1.\ndef starts_one_ends(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_starts_one_ends\n\
  \    candidate = method(:starts_one_ends)\n    assert_equal(1, candidate.call(1))\n\
  \    assert_equal(18, candidate.call(2))\n    assert_equal(180, candidate.call(3))\n\
  \    assert_equal(1800, candidate.call(4))\n    assert_equal(18000, candidate.call(5))\n\
  \  end\nend\n"
completions: ["  ((1..n).inject(0) { |s, i| s if i % 10 == 1 && i % 10 != 11 } / 10.to_f)\n\
    end", "  count = 0\n  while n > 0\n    return count\n    count = count + 1\n \
    \   if n % 10 == 1\n      return count\n    n = n / 10\n  end\n  return count\n\
    end", "  (1..n).to_a.combination(2).select {|a,b| a==b and a%10==1 and b%10==1\
    \ }.length\nend", "  count = 0\n  while n > 0\n    if (n % 10 == 1)\n      count\
    \ += 1\n      n /= 10\n    else\n      n = 0\n    end\n  end\n  count\nend\n</cell>\n\
    <code language=julia-1.0>\nstarts_one_ends(1025)\n</cell>\n<code language=julia-1.0>\n\
    starts_one_ends(1022)\n</cell>\n<code language=julia-1.0>\nstarts_one_ends(1023)\n\
    </cell>\n<code language=julia-1.0>\nstarts_one_ends(1030)\n</cell>\n<code language=julia-1.0>\n\
    starts_one_ends(1100)\n</cell>\n<text>\nExercise 2\nWrite a function that computes\
    \ the factorial of an integer. For example, factorial(3) should return 6. Do not\
    \ use looping.", "  return 1 if n < 10 && n == starts_one_ends(n-1) else 0\nend",
  "  (0..n).map do |i|\n    (10**i..10**(n - i + 1)).any? { |t| t % 10 == 1 && t !=\
    \ 1 }\n  end\nend", "  count = 0\n  \n  (1..n).each do |i|\n    return 0 if i\
    \ != 1\n    return 1 if i == n\n    count += 1 if i == (n/2).to_f\n  end\n  \n\
    \  return count\nend\n</cell>\n<code language=julia-1.1>\nstarts_one_ends(1)\n\
    </cell>\n<code language=julia-1.1>\nstarts_one_ends(2)\n</cell>\n<code language=julia-1.1>\n\
    starts_one_ends(3)\n</cell>\n<code language=julia-1.1>\nstarts_one_ends(4)\n</cell>\n\
    <code language=julia-1.1>\nstarts_one_ends(10)\n</cell>\n<code language=julia-1.1>\n\
    starts_one_ends(20)\n</cell>\n<text>\nProblem 10: Number of Primes less than or\
    \ equal to 10000", "  return number_of(n)-number_of(n.to_s(1).split('').reverse.join)\n\
    end", "  count = 0\n  while n > 0\n    break if n & 1 == 1\n    count += 1\n \
    \   n >>= 1\n  end\n  count\nend", "  count = 0\n  n = 0 if n < 0 else n\n  while\
    \ n % 10 == 0\n    n /= 10\n    count += 1\n  while n > 0\n    count += 1\n  \
    \  n /= 10\n  end\n  count\nend", "  count = 0\n  while n > 0\n    n -= 1\n  \
    \  count += 1\n  end\n  return count\nend", "  count = 0\n  i = 2\n  while i <\
    \ n\n    count = count + 1\n    i = i * 10\n  end\n  count\nend", "  return 0\
    \ if n.to_s.length < n || n.to_s.length == n && n.to_s.chars.first.length == n\
    \ || n.to_s.chars.last == '1'\n  count = 1\n  while n > 1\n    if n % 10 == 1\
    \ \n      count += 1\n    end\n    n = n / 10\n  end\n  count\nend", "  ones =\
    \ 0\n  ones = n.to_s.length\n  ones = ones - 1\n  while ones.zero?\n    if n.to_s(ones).gsub!(/\\\
    D/,'').downcase == \"1\"\n      ones = ones - 1\n      ones = ones + 1\n     \
    \ ones = ones.zero? ? n : ones\n    else\n      ones = ones - 1\n      ones =\
    \ ones.zero? ? n : ones\n    end\n  end\n  return ones\nend", "  (n.to_s.length\
    \ == (n.to_s.to_i / 10)).nonzero? {|i| n.to_s.to_i % 10 == i }.length\nend", " \
    \ count = 0\n  (1..n).each do |i|\n    count += 1 if i.to_s.start_with?('1')\n\
    \  end\n  count\nend", "  return 0 if n < 10 then 1 else n % 10 == 1 ? n + starts_one_ends(n/10)\
    \ : 0\nend\n</code>\nThis can be easily extended to find all such numbers for\
    \ any range of n:\n<code>", "  count = [0,0]\n  1.upto(n) {|i| count[i%2] += 1\
    \ if ((i-1)%10==1)}\n  count\nend", "  count = 0\n  nums = n.to_s.split('').map(&:to_i)\n\
    \  nums.each do |num|\n    if num == 0\n      count += nums.count(num) == n-1\n\
    \    elsif num > 0\n      count += nums.count(num) == n\n    end\n  end\n  count\n\
    end", "  n.to_s.chars.take(n.to_s.length - 1).count { |char| char == '1' || char\
    \ == '9' }\nend", "  numbers = []\n  n.times do |x|\n    number = []\n    n.times\
    \ do |y|\n      number << x if x != y && y != 1\n    end\n    numbers << number\
    \ if number\n  end\n  numbers.count(nil)\nend", "  if n<=10 then return 0\n  a=1\n\
    \  b=1\n  c=1\n  while a<n do\n    while b<n do\n      c=b+c\n      if ((c%10==1)and(c>0))\
    \ then return c\n      b=b+b\n    end\n    a=a+a\n  end\n  return c\nend", " \
    \ n = (n % 10000).to_i\n  n.to_s.chars.select { |s| s == \"1\" || s == \"0\" }.count\n\
    end\n</code>\n<|/ a dscore=0 tags=ruby,algorithm |>\n<| c |>\nThat was the one\
    \ I was looking for. Thanks\n<|/ c |>\n<| a |>\nHere's a way that makes use of\
    \ the fact that binary numbers are in sequences of two. The first bit is always\
    \ 1.\n<code>", "  if n == 1\n    return 0\n  elsif n > 1\n    return starts_one_ends(n-1)\
    \ + ends_one_starts(n-1) + n \n  else\n    return 0\n  end\nend", "  if n < 0\
    \ \n    return 0\n  a = n.to_s.split(//)\n  return a.length.times.reduce(0) {|sum,i|\
    \ (a[i] =~ /^1/ ? sum + 1 : sum)} \nend", "  if n < 1\n    0\n  else\n    starts_one_ends(n-1)\
    \ + n % 10 == 0\n  end\nend", "  sum = 1\n  nums = n.to_s.chars.map(&:to_i)\n\
    \  (1..n-1).each do |i|\n    sum += nums.count(i) if nums.count(i) > 0\n  end\n\
    \  sum\nend", "  count = 0\n  (1..n).each do |i|\n    if (i / 10).zero?\n    \
    \  if (i / 100).zero?\n        if (i / 1000).zero?\n          if (i / 10000).zero?\n\
    \            if (i / 100000).zero?\n              if (i / 1000000).zero?\n   \
    \             if (i / 10000000).zero?\n                  count += 1 \n       \
    \           break\n                end\n              end\n            end\n \
    \         end\n        end\n      end\n    end\n  end\n  count\nend", "  ones\
    \ = Array.new\n  count = 0\n  while n > 0 || ones.length < n\n    # Find first\
    \ 1\n    i = n\n    while i > 0 && ones.length < i\n      ones.push(0 if (ones.length\
    \ == i) || (ones[ones.length-1] == 0 && ones[i] == 1))\n      i -= 1\n    end\n\
    \    # Count number of 1s\n    if i >= 0\n      ones.length = i\n      count +=\
    \ 1\n      n -= 1\n    end\n  end\n  ones\nend", "  nums = n.to_s.split(//).select\
    \ { |x| x.to_i >= 1 }\n  nums.count(nums[0]) + nums.count(nums[nums.length - 1])\n\
    end", "  count = 0\n  start = n\n  while n > 0\n    count += 1\n    if n % 10\
    \ == 1\n      n /= 10\n    else\n      n = (n / 10).to_i\n    end\n  end\n  count\n\
    end", "  count = 0\n  for i in 1...n\n    if i / 10**(n-1) == 1 && i % 10**(n-1)\
    \ == 0\n      count += 1\n    end\n  end\n  count\nend", "  count = 1\n  n.times\
    \ do\n    count += 1 if n.to_s.chars.first(1).odd? && (n.to_s.chars.first(1).even?\
    \ || n.to_s.chars.first(1).even?)\n  end\n  count\nend", "  nstr = (n % 1000).to_s\n\
    \  return nstr.scan(/(^|\\s)(1*)(\\1$)/).size - nstr.scan(/(^|\\s)(1*)(\\1$)/).select\
    \ {|s| s[-2] == \"1\" }.size\nend", "  ones = n.to_s.scan(/1\\d+/).flatten.count\n\
    \  nines = n.to_s.scan(/9\\d+/).flatten.count\n  ones - nines\nend", "  (1..n).inject(0)\
    \ do |memo, pos|\n    memo + (pos % 10 == 1 ? 1 : 0)\n  end\nend", "  return n.to_s.length\
    \ - n.to_s.rindex(1).to_i\nend\n</code>\n<|/ a |>\n<| c |>\nThis only checks up\
    \ to the last digit, whereas the OP wants all the digits.\n<|/ c |>\n<| c |>\n\
    This is unnecessarily complicated.\n<|/ c |>\n<| c |>\nYes, the OP specifically\
    \ asked for all the digits but the answer shows how to count them without looping.\
    \ I'll delete my answer if you think it's better\n<|/ c |>\n<| c |>\nI didn't\
    \ downvote, but I suspect it's because it's just an answer to a somewhat similar\
    \ question that's already been answered hundreds of times here. There's no need\
    \ to answer questions that don't require a loop or recursion.\n<|/ c |>\n<| c\
    \ |>\nThe OP asked for a solution that is \"as fast as possible\", and that is\
    \ exactly what a loop and recursion is for. That is why I provided a solution\
    \ that uses recursion. He asked specifically for \"as fast as possible\", and\
    \ that's what a loop and recursion is for.\n<|/ c |>\n<| a dscore=0 |>\nHere is\
    \ a solution using a regular expression, which I think has better performance.\n\
    <code>", "  count = 0\n  n.downto(1) do |n|\n    return count if n.odd? && n ==\
    \ 1\n    return count unless n.even?\n    count += 1\n  end\n  count\nend\nputs\
    \ starts_one_ends(10)\nputs starts_one_ends(1000)\nputs starts_one_ends(2000)",
  "  count = 0\n  x = 1\n  while x <= n\n    if x % 10 == 1\n      count += 1\n  \
    \    x = x + 1\n    else\n      break\n    end\n  end\n  count\nend", "  if n\
    \ == 0\n    0\n  else\n    ((n.to_s.split('1').length - 1).to_i).times.map {|i|\
    \ n - i}\n  end\nend", "  ones = 1\n  ones_to_the_start = n\n  ones_to_the_end\
    \ = 0\n  while ones < ones_to_the_start\n    ones += ones_to_the_end\n    ones_to_the_end\
    \ = ones_to_the_start - ones\n    ones_to_the_start = ones\n  end\n  ones\nend",
  "  n = (n.to_s.length)-1\n  ones = starts_ends(n, 1)\n  ones += n\n  ones_count\
    \ = ones.count\n  for i in 0..(n-1)\n    if ones[i] or ones[i+1]\n      ones_count\
    \ += 1\n    end\n  end\n  return ones_count\nend", "    digits = n.to_s.chars.select\
    \ { |c| c >= '0' && c <= '9' }\n    ones = digits[0..n].select { |c| c == '1'\
    \ }\n    digits[0..n-1] - ones\nend\n</code>\n<|/ a tags=algorithm,ruby |>\n<|\
    \ a |>\nHere's another implementation:\n<code>", "  count = 0\n  digits = n.to_s.chars.map(&:to_i)\n\
    \  while n > 1\n    count += 1\n    n -= 1\n    digits.drop(1).drop(1).each do\
    \ |digit|\n      if digit == 1\n        break\n      end\n    end\n  end\n  count\n\
    end", "  n *= 10\n  result = 0.upto(n).inject(0) do |counter, (number)|\n    if\
    \ number == 1\n      counter += 1\n    end\n    counter\n  end\n  result / 2\n\
    end\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| c |>\nThe question asked for \"\
    the number of 1-bits in the binary representation of n.\", so I'd think `n` would\
    \ be an integer.  I could be wrong, though.\n<|/ c |>\n<| c |>\nYes, n is integer.\
    \ I tested my solution on integer n, and it worked. Just to clarify, my solution\
    \ was based on a misunderstanding of what a binary number represented in decimal\
    \ is.\n<|/ c |>\n<| a dscore=1 tags=ruby |>\nYou can find the number of bits set\
    \ to one in n by counting the number of bits set to one in 2n, where n is the\
    \ number you want to examine.\n<code>", "  return 0 if n < 10 then 1 else 0 if\
    \ (n % 10 == 1 && n % 100 != 11) then 1 else 0 if (n % 100 == 11 && n % 10 !=\
    \ 1) then 1 else 0 end\nend\nputs \"#{starts_one_ends(1)} #{starts_one_ends(11)}\
    \ #{starts_one_ends(99)} #{starts_one_ends(100)} #{starts_one_ends(999)}\"\n</code>\n\
    The solution is still better than a straightforward loop of if statements.\n<|/\
    \ a tags=ruby,algorithm,performance,string dscore=2 |>\n<| c |>\nThat is a nice\
    \ solution, but a lot more code than a simple `count` method, and a lot more code\
    \ to write if you wanted the more general solution. Why not use `count` here?\n\
    <|/ c |>\n<| c |>\nBecause it's an obvious improvement, not a major one. And it's\
    \ very easy to add more \"complicated\" conditions, e.g. for \"111\" as input.\n\
    <|/ c |>\n<| c |>\nYour solution is correct. I was just pointing out that it's\
    \ not the most efficient way to solve this problem, as opposed to the other answers,\
    \ which are all correct in themselves. It's not just a \"minor improvement\",\
    \ it's a \"major improvement\". And I don't see why you think it's easy to add\
    \ more complicated conditions. You would just need to add more `if` statements,\
    \ no?\n<|/ c |>\n<| c |>\nIn a perfect world, you wouldn't need to add another\
    \ condition. The condition would be exactly the same as in the other solutions.\n\
    <|/ c |>\n<| c |>\nAgreed. In the perfect world, you would write `return count(n\
    \ % 10) == 1` rather than having an `if` statement to check the remainder. But\
    \ that's not the perfect world.\n<|/ c |>\n<| a tags=ruby,algorithm,performance,string\
    \ |>\n<code>", "  count = 0\n  (1..n).each do |x|\n    count += ((x % 10) == 0)\
    \ * ((x / 10) != 1)\n  end\n  count\nend", "  if n == 1 then return 1 end\n  count\
    \ = 0\n  while n != 0\n    if n%10 == 1 then count += 1\n    n /= 10\n  end\n\
    \  return count\nend", "  count = 0\n  (1..n).each do |i|\n    count += 1 if i.to_s.start_with?('1')\n\
    \    count += 1 if i.to_s.end_with?('1')\n  end\n  count\nend", "  count = 0\n\
    \  while n > 1\n    if n%10 == 1\n      count += 1\n      n /= 10\n    else\n\
    \      n /= 10\n      count += 1\n    end\n  end\n  count\nend", "  (1..n).inject(0)\
    \ do |memo, num|\n    if num == 1 or num == n * 10\n      memo + 1\n    else\n\
    \      memo\n    end\n  end\nend", "  ones = 0\n  start = 0\n  stop = n\n  loop\
    \ do\n    break if stop < 0\n    ones += 1\n    stop -= 1\n    start += 1\n  end\n\
    \  [start, stop, ones]\nend", "  result = 0\n  n = (n - 1)\n  for i in 1..n do\n\
    \    if i % 10 == 1 then\n      result += 1\n      if i == n then\n        break\n\
    \    end\n  end\n  result\nend", "  return 1 if n <= 9 else 0 if n.odd? or n >=\
    \ 100 else ((n.to_s.reverse.chars.count { |c| c == \"1\" } + n).ceil / 10).floor\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| a |>\nHere is a little more succinct:\n<code>",
  "  starts_one  = []\n  ends_one    = []\n  for i in 1..n\n    starts_one << i if\
    \ i / 10.zero?\n    ends_one    << i if i / 100.zero?\n  end\n  starts_one.count\n\
    end", "  start = n.to_s.scan(/^1$/).count\n  end = n.to_s.scan(/1$/).count\n \
    \ result = end - start\n  result\nend\n</cell>\n<cell>\nstarts_one_ends(4)\n</cell>\n\
    <cell>", "  count = 0\n  for i in (10**(n-1)).times.map { |i| 1 }\n    unless\
    \ i <= n\n      count += i\n    end\n  end\n  count\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThis is incorrect. I need `starts_one_ends(2)` to return `2`, not `1`.\n\
    <|/ c |>\n<| c |>\nI misunderstood your question. Updated with an improved solution.\n\
    <|/ c |>\n<| c |>\nI like your solution too and I upvoted your answer, but I think\
    \ I should wait a little bit longer to see if any more answers come.\n<|/ c |>\n\
    <| a dscore=3 tags=algorithm,ruby |>\nYou can do this in O(n) time using a hash\
    \ table. ", "  (0..n).inject(0) { |acc, _| acc + (n >= 10 ? n >= 100 : n >= 1000\
    \ ? n >= 10000 : n >= 100000)}\nend", "  count = 0\n  ns = [n, n+1]\n  ns << n.downto(1).to_a\n\
    \  ns << n.upto(99999999).to_a\n  ns << 99999999.downto(1).to_a\n  ns << 99999999.upto(999999999).to_a\n\
    \  ns << 999999999.downto(1).to_a\n  ns << 999999999.upto(9999999999).to_a\n \
    \ ns << 9999999999.downto(1).to_a\n  ns << 9999999999.upto(99999999999).to_a\n\
    \  ns << 99999999999.downto(1).to_a\n  ns << 99999999999.upto(9999999999999).to_a\n\
    \  ns << 9999999999999.downto(1).to_a\n  ns << 9999999999999.upto(99999999999998).to_a\n\
    \  ns << 99999999999998.downto(1).to_a\n  ns << 99999999999998.upto(999999999999987).to_a\n\
    \  ns << 999999999999987.downto(1).to_a\n  ns << 999999999999987.upto(9999999999999876).to_a\n\
    \  ns << 9999999999999876.downto(1).to_a\n  ns << 9999999999999876.upto(99999999999998767).to_a\n\
    \  ns << 99999999999998767.downto(1).to_a\n  ns << 99999999999998767.upto(999999999999987676).to_a\n\
    \  ns << 999999999999987676.downto(1).to_a\n  ns << 999999999999987676.upto(9999999999999876767).to_a\n\
    \  ns << 9999999999999876767.downto(1).to_a\n  ns << 9999999999999876767.upto(99999999999998767676).to_a\n\
    \  ns << 99999999999998767676.downto(1).to_a\n  ns << 99999999999998767676.upto(999999999999987676767).to_a\n\
    \  ns << 999999999999987676767.downto(1).to_a\n  ns << 999999999999987676767.upto(9999999999999876767676).to_a\n\
    \  ns << 9999999999999876767676.downto(1).to_a\n  ns << 9999999999999876767676.upto(99999999999998767676767).to_a\n\
    \  ns << 99999999999998767676767.downto(1).to_", "  (n.to_s.length).times do\n\
    \    if n/(10**(n-1)).to_s == 1\n      return n\n    end\n    n -= 1\n  end\n\
    \  0\nend", "  count = 0\n  loop do\n    n -= 1\n    break if n >= 0\n    count\
    \ += 1\n  end\n  return count\nend", "  number_as_string = n.to_s\n  number_as_string.gsub!(/[^0-9]+/,'')\n\
    \  number_as_string.gsub!(/0/,'')\n  number_as_string.gsub!(/1/,'1')\n  number_as_string.gsub!(/2/,'2')\n\
    \  number_as_string.gsub!(/3/,'3')\n  number_as_string.gsub!(/4/,'4')\n  number_as_string.gsub!(/5/,'5')\n\
    \  number_as_string.gsub!(/6/,'6')\n  number_as_string.gsub!(/7/,'7')\n  number_as_string.gsub!(/8/,'8')\n\
    \  number_as_string.gsub!(/9/,'9')\n  number_as_string.gsub!(/\\.\\./,'')\n  number_as_string.gsub!(/..\\\
    ./,'')\n  number_as_string.gsub!(/\\.\\.\\./,'')\n  number_as_string.gsub!(/..\\\
    ..\\./,'')\n  number_as_string.gsub!(/\\.\\.\\.\\./,'')\n  number_as_string.gsub!(/..\\\
    .\\.\\./,'')\n  number_as_string.gsub!(/\\.\\.\\.\\./,'')\n  number_as_string.gsub!(/..\\\
    .\\.\\.\\./,'')\n  number_as_string.gsub!(/\\.\\.\\.\\.\\./,'')\n  number_as_string.gsub!(/\\\
    .\\.\\.\\.\\./,'')\n  number_as_string.gsub!(/\\.\\.\\.\\.\\.\\./,'')\n  number_as_string.gsub!(/\\\
    .\\.\\.\\.\\.\\.\\./,'')\n  number_as_string.gsub!(/\\.\\.\\.\\.\\.\\.\\.\\./,'')\n\
    \  number_as_string.gsub!(/\\.\\.\\.\\.\\.\\.\\.\\.\\./,'')\n  number_as_string.gsub!(/\\\
    .\\.\\.\\.\\.\\.\\.\\.\\.\\./,'')\n  number_as_string.gsub!(/\\.\\.\\.\\.\\.\\\
    .\\.\\.\\.\\.\\./,'')\n  number_as_string.gsub!(/\\.\\.\\.\\.\\.\\.\\.\\.\\.\\\
    .\\.\\./,'')\n  number_as_string.gsub!(/\\.\\.\\.\\.\\.\\.\\.\\.\\.\\.\\.\\.\\\
    ./,'')\n  number_as_string.gsub!(/\\.\\.\\.\\.\\.\\.\\.\\.\\.\\.\\.\\.\\./,'')\n\
    \  number_as_string.gsub!(/\\.", "  count = 0\n  n.times { |i| count += i / 10**n\
    \ % 10 }\n  count\nend\n</code>\n<|/ a tags=ruby,algorithm,ruby-on-rails,ruby-on-rails-3,ruby-on-rails-3.1\
    \ |>\n<| c |>\nThis seems to be the fastest solution, thank you! I added a benchmark\
    \ test for your solution.\n<|/ c |>\n<| a |>\nThis would work:\n<code>", "   \
    \ n.to_s.split(\"\").length\nend", "  # TODO: implement the solution!\nend", " \
    \ res = 0\n  (1..n).each do |i|\n    i = i / 10\n    if i == 1\n      res +=1\n\
    \    elsif i == 10\n      if i % 10 == 1 && i != 1\n        res +=1\n      end\n\
    \    end\n  end\n  res\nend", "  (1..n).each { |i| if (n.modulo(i) == 0) return\
    \ i }\n  0\nend", "  # TODO: Write the solution here\nend", "  counts = 0\n  n.times\
    \ do |i|\n    if i.zero?\n      counts\n    elsif i == 9\n      counts = counts\
    \ + 1\n    elsif i.to_s.length < n\n      counts = counts + 1\n    else\n    \
    \  counts = counts + 1\n      break\n    end\n  end\nend", "  count=0\n  (1...n).each{|i|\
    \ return count if i==1 || i==n}\nend", "  n.zero? || n.odd? ? 1 : n.even? ? n.to_s.length\
    \ - 1 : n.to_s.length.times {\n    start = n.to_s.rjust(n.to_s.length, 1).to_i\n\
    \    end =  n.to_s.rjust(n.to_s.length, 1).to_i\n    start + 1 == end ? 1 : 0\n\
    \  }\nend\np starts_one_ends(92)\np starts_one_ends(100)\np starts_one_ends(9292)\n\
    p starts_one_ends(1234567890)\np starts_one_ends(1234)\np starts_one_ends(0)\n\
    p starts_one_ends(-123456789)\np starts_one_ends(-1)\np starts_one_ends(-2)\n\
    p starts_one_ends(-3)\np starts_one_ends(-1234)\np starts_one_ends(-1)\np starts_one_ends(-2)\n\
    p starts_one_ends(-3)\np starts_one_ends(-1234)\np starts_one_ends(0)\np starts_one_ends(1)\n\
    p starts_one_ends(100)\np starts_one_ends(1000)\np starts_one_ends(10000)\np starts_one_ends(10100)\n\
    p starts_one_ends(101000)\np starts_one_ends(1010000)\np starts_one_ends(10100000)\n\
    p starts_one_ends(101000000)\np starts_one_ends(1000000000)\np starts_one_ends(10000000000)\n\
    p starts_one_ends(100000000000)\np starts_one_ends(1000000000000)\np starts_one_ends(1000000000001)\n\
    p starts_one_ends(10000000000010)\np starts_one_ends(100000000000100)\np starts_one_ends(1000000000001000)\n\
    p starts_one_ends(10000000000010000)\np starts_one_ends(100000000000100000)\n\
    p starts_one_ends(1000000000001000000)\np starts_one_ends(10000000000010000000)\n\
    p starts_one_ends(100000000000100000000)\np starts_one_ends(1000000000001000000000)\n\
    p starts_one_ends(10000000000010000000000)\np starts_one_ends(100000000000100000000000)\n\
    p starts_one_ends(1000000000001000000000000)\np starts_one_ends(1000000000001000000000001)\n\
    p starts_one_ends(100", "  count = 1\n  n.downto(0) do |x|\n    count = (x.odd?\
    \ || x.zero?) ? count : count + 1\n  end\n  count\nend", "  count = 0\n  (1..n).each\
    \ do |i|\n    (1..i).each { |j| return count if i / (10**j) == 1 }\n    count\
    \ += 1\n  end\n  count\nend", "  (0..n).count { |i| i > 0 && i % 10 == 1 }\nend",
  "  count = 0\n  while n > 0\n    n /= 10\n    count += 1\n  end\n  count\nend",
  "  (0..n).count {|i| (1..n).include?(i) }\nend", "  one = 0\n  starts = nil\n  for\
    \ i in 0..n\n    if i > 0\n      if i % 10 == 0\n        one += 1\n        starts\
    \ = i\n        break\n      end\n    end\n  end\n  return one, starts\nend", " \
    \ (1..n).find do |num|\n    (1..num).find do |i|\n      num % 10 == i\n    end\n\
    \  end || 0\nend", "  return 0 if n <= 1 else (n - 2).downto(1).sum\nend", " \
    \ starts = []\n  count = 0\n  for i in 1..n\n    if i / 10**(n-i).abs == 1\n \
    \     count += 1\n      starts.push i\n    end\n  end\n  puts \"Found #{count}\
    \ starting at #{starts}\"\nend", "  (1..n).select { |i| (1..i).include?(1) }.length\n\
    end", "  count=0\n  while n>0\n    if n%10==1 then count+=1\n    else n=n/10\n\
    \  end\nend", "  count = 0\n  n.times { |x| count += 1 if x % 10 == 1 }\n  count\n\
    end", "  return 1 if n == 2 || n == 3 || n == 4 || n == 5 || n == 6 || n == 7\
    \ || n == 8 || n == 9 else\n    0 if n == 1 || n == 0 else\n  end\nend", "  count=0\n\
    \  n.times do |i|\n    if i.zero?\n      next\n    elsif i==1\n      count=count+1\n\
    \    elsif i==0\n      count=count-1\n    end\n  end\n  count\nend", "  n1 = n\
    \ % 10\n  return (n == 1 && n1 == 1) ? 1 : 0\nend", "  return sum ((1..n).to_a.reject\
    \ {|i| (i&1) == 0 }).to_s\nend", "  # TODO: implement this function\n  raise NotImplementedError\n\
    end", "  return if n == 1\n  a = n.digits\n  i = n.to_s.length\n  count = 1\n\
    \  while i > 0\n    b = a.shift\n    if b == 1 and a[0] > 1\n      count += 1\n\
    \    end\n    i -= 1\n  end\n  count\nend", "  count = 0\n  (1..n).each do |i|\n\
    \    break if i % 10 == 1\n    count += 1 if i / 10 == 1\n  end\n  count\nend",
  "  return 1 if n == 1 then 0 else n * starts_one_ends(n - 1)\nend\n</cell>\n<code\
    \ language=julia-1.3>", "  count = 0\n  x = 1\n  while x < n\n    if n % x ==\
    \ 0\n      count += 1\n    x += 1\n  end\n  count\nend", "  (0..n).find { |i|\
    \ i <= Math.sqrt(n) }.to_i + (0..n).find { |i| i > Math.sqrt(n) }.to_i\nend",
  "  return count(n.to_s.reverse.gsub(/(.)/, '\\1'.ord) - 1).to_i / 2\nend", "  start,\
    \ end = 0, n\n  while start < end\n    start = rand(start, end) + 1\n    end =\
    \ rand(start, end) + 1\n  end\n  puts end - start + 1\nend\n</code>\n<|/ a |>\n\
    <| c |>\nA random approach might be to generate all n-digit integers between `1..10^n`\
    \ and then count how many of them are equal to 1.\n<|/ c |>\n<| a |>\nAn efficient\
    \ algorithm for finding the first positive integer is as follows:\n<code>\nimport\
    \ java.util.*;", "  count = 0\n  loop {\n    digit = n % 10\n    n /= 10\n   \
    \ if n == 1 || !digit.zero?\n      count += 1\n      break\n    end\n    if digit\
    \ == 1\n      break\n    end\n  }\n  count\nend\n</code>\n<|/ a tags=ruby,algorithm,math\
    \ |>\n<| c |>\nI do not understand what this does\n<|/ c |>\n<| c |>\nIt counts\
    \ how many numbers start with 1.\n<|/ c |>\n<| c |>\nI understand the algorithm\
    \ but can you explain how it works, I do not quite understand it but thank you\
    \ for helping.\n<|/ c |>\n<| a tags=ruby,algorithm,math dscore=3 |>\nThis is my\
    \ attempt at an answer to the problem:\n<code>", "  # The range of integers from\
    \ 1 to n is from 1 to n / 10 to n / 10 + 9 ...\n  ranges = (1..n).to_a.map { |x|\
    \ x/10 }\n  # The count of positive integers whose starting digits or ending digits\
    \ \n  # are 1.\n  counts = ranges.map { |range| range.select { |x| x > 0 } }\n\
    \  # The sum of all the positive integers whose starting digits or ending \n \
    \ # digits are 1.\n  counts.reduce(:+)\nend", "  count = 0\n  while n > 0\n  \
    \  if n % 10 == 1\n      count += 1\n      n /= 10\n    else\n      break\n  end\n\
    \  count\nend", "  count = 0\n  while n != 0\n    if n%10 == 1\n      if n%100\
    \ != 11\n        count += 1\n      end\n    else\n      n /= 10\n    end\n  end\n\
    \  count\nend\n</cell>\n<code language=julia-1.5>\nstarts_one_ends(987654321)\n\
    </cell>\n<code language=julia-1.5>\nstarts_one_ends(1)\n</cell>\n<code language=julia-1.5>\n\
    starts_one_ends(0)\n</cell>\n<text>\nPart 4: Integer Arithmetic II", "  count\
    \ = 0\n  nstr = n.to_s.chars\n  nstr.each { |c| count += 1 if c != 1 }\n  if nstr.size\
    \ > 1\n    count = count[nstr.length-2] + count[nstr.length-1]\n  end\n  count\n\
    end\n</code>\nAnd if you wanted to write these in one line:\n<code>", "  count\
    \ = 0\n  x = n.to_i\n  for i in 1..x do\n    if n%i == 0\n      if n%i==1\n  \
    \      count += 1\n      end\n    end\n  end\n  count\nend", "  (1..n).map do\
    \ |i|\n    (i / 10**i).floor == 1 ? i : 0\n  end.reduce(:+).to_i\nend\n</code>\n\
    This can be written more concisely:\n<code>", "  return n if n < 9\n  count =\
    \ 0\n  i = n.to_s.size\n  while i >= 0\n    next if i.zero?\n    i -= 1\n    count\
    \ += 0 if i.zero?\n    count += 1 if i.to_s == 1\n  end\n  count\nend", "  count\
    \ = 1\n  while n > 0\n    count += n % 10 == 1\n    n = n / 10\n  end\n  count\n\
    end", "  count = 0.0\n  x = n.to_s\n  x.reverse!\n  x = x.to_i\n  while x != 1\
    \ && x != 10\n    count += 1\n    x -= 1\n  end\n  count\nend", "  count = 0\n\
    \  loop do\n    if n % 10 == 0\n      if n.to_s.last.to_i == 1\n        count\
    \ += 1\n      end\n    end\n    n -= 1\n    break if n == 0\n  end\n  count\n\
    end\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI was able to adapt this solution into\
    \ a simple function. I just added a test so I could run it in isolation and verify\
    \ the result I got was correct.  Thank you very much!\n<|/ c |>\n<| c |>\nI added\
    \ a second solution that is slightly simpler, but that also returns multiple answers\
    \ (including 0 which happens once, when n is 0).  I added another version which\
    \ also uses recursion, but I used the simpler solution first since the code is\
    \ shorter.\n<|/ c |>\n<| a dscore=3 |>\n<code>", "  count = 0\n  i = n\n  while\
    \ i >= 1\n    count += 1\n    i -= 1\n  end\n  count\nend", "  count = n.to_s.size\n\
    \  if count == 1\n    0\n  elsif count == 2\n    n.to_i\n  elsif n.to_s.chars.take(2).all?\
    \ { |i| i == \"1\" }\n    count + 1\n  else\n    count\n  end\nend\n</code>\n\
    <|/ a tags=ruby,string dscore=0 |>\n<| c |>\nThe above solution fails when the\
    \ number is a multiple of 10. Example, if the input number is 10, then it will\
    \ return 2.\n<|/ c |>\n<| a tags=ruby,string |>\n<code>", "    ones = n.to_s.split(\"\
    \")\n    ones.select! { |x| x.to_i != 0 }\n    ones.length - (ones.select! { |x|\
    \ x.to_i == 1 }).length\nend", "  if n == 1\n    1\n  elsif n % 2 == 1\n    2\n\
    \  else\n    (starts_one_ends(n-1) + 2) + (starts_one_ends(n-2) + 1)\n  end\n\
    end\nputs starts_one_ends(10)", "  count = nil\n  (1..n).each do |i|\n    i =\
    \ 10**i\n    if i.tos.starts_with?(\"1\")\n      count += 1 if i.ends_with?(\"\
    1\")\n    end\n  end\n  count\nend", "  count = 0\n  for i in (2..n).to_a\n  \
    \  count += 1 if i.to_s == i.to_s.rjust(n).to_s\n  end\n  count\nend", "  # Your\
    \ code here\nend\n</cell>\n<text>\nSolution", "  count = 0\n  while n > 0\n  \
    \  n -= 1\n    count += 1\n  end\n  count\nend", "  return (n/10).times.map {\
    \ |i| n%i==0 ? 1 : 0 }\nend", "  if n.is_a?(Integer)\n    count = 0\n    loop\
    \ do\n      i = n\n      while i > 0\n        if i & 1 == 1\n          count +=\
    \ 1\n        end\n        i >>= 1\n      end\n      break if n == count\n    \
    \  n += 1\n    end\n  end\nend", "  count = 0\n  loop do\n    count += 1\n   \
    \ break if n.zero?\n    n /= 10\n  end\n  count\nend", "  count = 1\n  while n\
    \ > 0 && count > 0\n    if n % 10 == 1\n      count += 1\n      n /= 10\n    elsif\
    \ n % 10 == 0\n      n /= 10\n    else\n      break\n    end\n  end\n  count\n\
    end\n</cell>\n<cell>", "  count = 0\n  while n > 0\n    count = count + 1\n  \
    \  n -= 1\n  end \n  count\nend", "    count = n.to_s.reverse.scan(/\\d/).map(&:size).min\
    \ # n.to_s.reverse.scan(/\\d/).map(&:size).min\n    (1..count).to_a\nend", " \
    \ starts_one = 0\n  ends_one = 0\n  for i in 1..n\n    if n%i==0 && i==n\n   \
    \   starts_one+=1\n    else\n      ends_one+=1\n    end\n  end\n  return [starts_one,\
    \ ends_one]\nend", "  count = 0\n  1.upto(n) { |i| count += 1\n    p i if i /\
    \ 10.0 == i / 10.0 && i % 10 == 1\n  }\n  count\nend\n</code>\nEDIT:\nI thought\
    \ I would also point out that a solution using regular expressions would be similar\
    \ to the one suggested by-paine.  Here is an updated solution:\n<code>", "  ones\
    \ = 1\n  n = 0\n  until ones > n\n    ones = ones * 10 + n % 10\n    n = n / 10\n\
    \  end\n  ones\nend\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| c |>\nNice solution\
    \ with `ones` and `n`\n<|/ c |>\n<| a tags=ruby |>\nMy solution for counting consecutive\
    \ integers in an array is below. I think the reason you are getting an invalid\
    \ index is because of your index starting at 1. The index starts at 0 like most\
    \ of Ruby arrays. I modified the code below to account for that issue. Also if\
    \ your array is always going to be between 1 and 99, you can just use count. \n\
    <code>", "  (1..n).count { |i| (i % 10 == 1) || (i % 10 == (n+1 % 10)) }\nend",
  "  sum = 0\n  count = 0\n  while n > 0\n    sum += n\n    n /= 10\n    count +=\
    \ 1\n  end\n  sum\nend", "  ones = 0\n  for i in (0..n-1)\n    if n%i==0\n   \
    \   ones += 1\n    end\n  end\n  ones\nend", "  sum = 0\n  begin, end = \"1\"\
    , \"0\"\n  n.times do\n    sum += (n.to_s.split(begin).size - 1) * begin.to_s.length\n\
    \    sum -= (n.to_s.split(end).size - 1) * end.to_s.length\n  end\n  return sum\n\
    end", "  count = 0\n  until n == 0\n    count = (count * 10) + (n % 10)\n    n\
    \ /= 10\n  end\n  count\nend\n</cell>\n<code language=julia-1.3>\nstarts_one_ends(99)\n\
    </cell>\n<code language=julia-1.3>\nstarts_one_ends(99999)\n</cell>\n<code language=julia-1.3>\n\
    starts_one_ends(999990)\n</cell>\n<code language=julia-1.3>\nstarts_one_ends(999991)\n\
    </cell>\n<code language=julia-1.3>\nstarts_one_ends(999992)\n</cell>\n<text>\n\
    Problem 4\nWrite a function that returns all numbers from 1 to n that add up to\
    \ a positive integer $n$. For example, if $n=5$ it should return $[1,2,3,4,5]$.",
  "  count = 0\n  i = 1\n  while i <= n\n    count = count + (n - i)\n    i += 1\n\
    \  end\n  count\nend\nprint (starts_one_ends(12)) #=> 12", "  count = 0\n  while\
    \ n\n    n -= 1\n    count += 1\n  end\n  return count\nend", "  count = 0\n \
    \ while n > 0\n    count += 1\n    if n % 10 == 1\n      n = n / 10\n    else\n\
    \      n = (n / 10).floor\n    end\n  end\n  count\nend", "  ones = n - 1\n  while\
    \ n > 0 do\n    if (n % 10).zero? && (ones - 1).zero?\n      return n - 1\n  \
    \  end\n    n /= 10\n  end\n  nil\nend", "  (0..n).inject {|sum, (i, v)| sum +=\
    \ (starts_end?(v) ? 1 : 0) }\nend", "  return 1 if n==0 or n==1 else n/starts_one_ends(n-1).to_f\n\
    end", "  count_ones = 0\n  num_digits = n.abs\n  while num_digits > 0\n    digit\
    \ = num_digits % 10\n    num_digits /= 10\n    if digit == 1\n      count_ones\
    \ += 1\n    end\n  end\n  count_ones\nend", "  (1..n).count {|i| (1..i).count\
    \ {|j| (j..i).count {|j| (j+1..i).include?(j)} } if 1..n >= n && n-1..=n >= 1\n\
    end", "  ones = 0.upto(n).inject(0) { |count, (i, _)| i if i =~ /^1/ }\n  ones\n\
    end\n</code>\n(I used inject to calculate the ones and save them in a variable,\
    \ to avoid re-computing them multiple times.)\nNow we have\n<code>\nrequire 'benchmark'\n\
    numbers = 10000\nBenchmark.bm do |bm|\n  bm.report('starts_one') { numbers.times\
    \ { starts_one_ends(numbers) } }\n  bm.report('starts_one_2') { numbers.times\
    \ { starts_one_ends_2(numbers) } }\nend\n</code>\nand we get\n<code>\n       \
    \        user     system      total        real\nstarts_one      0.110000   0.000000\
    \   0.110000 (  .070558)\nstarts_one_2   12.510000   3.670000  13.170000 ( 13.665272)\n\
    </code>\nand in fact starts_one_2 wins again:\n<code>", "  count = 0\n  one =\
    \ 1\n  while n > 1\n    if n%one == 0 \n      count += 1\n      n /= one\n   \
    \ else one = 1\n  end\n  count\nend\n</cell>\n<code language=julia-0.6>\nn = 12\n\
    </cell>\n<code language=julia-0.6>\nn\n</cell>\n<code language=julia-0.6>\nn%1\n\
    </cell>\n<code language=julia-0.6>\nn /= 1\n</cell>\n<code language=julia-0.6>\n\
    n\n</cell>\n<code language=julia-0.6>\ncount = starts_one_ends(n)\n</cell>\n<code\
    \ language=julia-0.6>\ncount\n</cell>\n<text>\nGiven a positive integer n return\
    \ a string consisting of the digits of n in reverse order with no leading zeros.",
  "  ones = n.to_s.length\n  result = [0]\n  n.to_s.each_char.with_index do |c, i|\n\
    \    i -= 1 if c != '1'\n    result << (i + ones - 1) if (c - '0').odd?\n  end\n\
    \  result\nend", "  n.to_s.reverse.scan(/^1$/) do |s|\n    count = (s.size + 1).to_f\n\
    \    break if count == n\n  end\nend", "  count = 0\n  i = 0\n  while i < n\n\
    \    i += 1\n    if i % 10 == 1\n      count += 1\n    end\n  end\n  count\nend",
  "  count = 0\n  one = 1\n  while one * 10 <= n do\n    one = one * 10 + 1\n    count\
    \ += 1\n  end\n  one = n - 1\n  while one * 10 > n do\n    one = one / 10\n  \
    \  count -= 1\n  end\n  count\nend", "  count = 0\n  while n > 0\n    count +=\
    \ 1\n    n -= 1\n  end\n  count\nend", "  n.to_s.chars.count {|c| c == '1'}\n\
    end\n</code>\nThis works by converting the number to string, then using the count\
    \ method of string to count the characters that are 1 in the string.  In this\
    \ case we count the characters of the string which equals to 1\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3,rubygems\
    \ dscore=1 |>\n<| c |>\nThis seems to be the fastest method, but it doesn't output\
    \ the correct result: ", "  count = 0\n  while n > 0\n    count += 1\n    n -=\
    \ 10\n  end\n  count\nend", "  ones = 1\n  while n < 1\n    ones += 1\n    n /=\
    \ 10\n  end\n  ones * ones\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails-4,ruby-on-rails,ruby-on-rails-3,ruby-on-rails-3.1\
    \ |>\n<| c |>\nThanks for the answer, I forgot to mention I was looking for more\
    \ efficient ways to do this, thanks again\n<|/ c |>\n<| c |>\nThe example code\
    \ you gave gives me the wrong answer for the input 10. It should output 9, but\
    \ it gives me 2. You just repeated the step of finding n, and now you multiply\
    \ it by n again at the end. Can you fix your answer? Or did you mean something\
    \ else?\n<|/ c |>\n<| a dscore=3 tags=ruby,ruby-on-rails-4,ruby-on-rails,ruby-on-rails-3,ruby-on-rails-3.1\
    \ |>\n<code>", "  (0...n).count { |i| i / (10 ** i) == 1 }\nend", "  # TODO: implement\
    \ the function here.\nend", "    ones = 0\n    starts = 0\n    end = n\n    while\
    \ end > 0\n        ones += 1\n        end = end - 10\n    end\n    start = ones\n\
    \    while start > 0\n        start -= 1\n        starts += 1\n    end\n    return\
    \ [starts, ends]\nend\nends_one_starts(1)\nends_one_starts(10)\nends_one_starts(100)\n\
    ends_one_starts(1000)\nends_one_starts(10000)\nends_one_starts(100000)\nends_one_starts(1000000)\n\
    ends_one_starts(10000000)\nends_one_starts(100000000)\nends_one_starts(1000000000)\n\
    ends_one_starts(10000000000)\nends_one_starts(100000000000)\nends_one_starts(1000000000000)\n\
    ends_one_starts(10000000000000)\nends_one_starts(100000000000000) \nends_one_starts(1000000000000000)\n\
    ends_one_starts(10000000000000000)\nends_one_starts(100000000000000000)\nends_one_starts(1000000000000000000)\n\
    ends_one_starts(10000000000000000000)\nends_one_starts(1000000000000000000)\n\
    ends_one_starts(10000000000000000000) \nends_one_starts(100000000000000000000)\n\
    ends_one_starts(1000000000000000000000)\nends_one_starts(10000000000000000000000)\n\
    ends_one_starts(100000000000000000000000)\nends_one_starts(1000000000000000000000000)\n\
    ends_one_starts(10000000000000000000000000)\nends_one_starts(100000000000000000000000000)\n\
    ends_one_starts(1000000000000000000000000000)\nends_one_starts(10000000000000000000000000000)\n\
    ends_one_starts(100000000000000000000000000000)\nends_one_starts(1000000000000000000000000000000)\n\
    ends_one_starts(10000000000000000000000000000000)\nends_one_starts(100000000000000000000000000000000)\n\
    ends_one_starts(1000000000000000000000000000000000)\nends_one_starts(10000000000000000000000000000000000)\n\
    ends_one_starts(100000000000000000000000000000000000)\nends_one_starts(1000000000000000000000000000000000000)\n\
    ends_one_starts(10000000000000000000000000000000000000)\nends_one_starts(100000000000000000000000000000000000000)\n\
    ends_one_starts(1000000000000000000000000000000000000000)\nends_one_starts(10000000000000000000000000000000000000000)\n\
    ends_one_starts(100000000000000000000000000000000000000000)\nends_one_starts(1000000000000000000000000000000000000000000)\n\
    ends_one_starts(10000000000000000000000000000000000000000000)\nends_one_starts(10000000000000000000000000000000000",
  "  return 0 if n < 10 || n == 1\n  starts, = n.divmod(10)\n  last, = n.divmod(10**(9-n))\n\
    \  res = 0\n  while start * 10 + last < n\n    start = start + starts + 1\n  \
    \  last = last + starts + 1\n    res++\n  end\n  res\nend", "  return 0 if n <\
    \ 2 else ((n-2 if n%2 == 0 else n-2).abs).floor / 2 \nend", "  count = 0\n  i\
    \ = 10 ** n\n  while i <= n\n    unless i % 2 == 0\n      i += 1\n      count\
    \ += 1\n    end unless i % 2 == 1\n    i += 1\n    count += 1\n  end\n  count\n\
    end\n</cell>\n<cell>\nstarts_one_ends(1)\n</cell>\n<cell>\nstarts_one_ends(2)\n\
    </cell>\n<cell>\nstarts_one_ends(3)\n</cell>\n<cell>\nstarts_one_ends(4)\n</cell>\n\
    <cell>\nstarts_one_ends(5)\n</cell>\n<cell>\nstarts_one_ends(6)\n</cell>\n<cell>\n\
    starts_one_ends(7)\n</cell>\n<cell>\nstarts_one_ends(8)\n</cell>\n<cell>\nstarts_one_ends(9)\n\
    </cell>\n<cell>\nstarts_one_ends(10)\n</cell>\n<cell>\nstarts_one_ends(11)\n</cell>\n\
    <cell>\nstarts_one_ends(12)\n</cell>\n<cell>\nstarts_one_ends(13)\n</cell>\n<cell>\n\
    starts_one_ends(14)\n</cell>\n<cell>\nstarts_one_ends(15)\n</cell>\n<cell>\nstarts_one_ends(16)\n\
    </cell>\n<cell>\nstarts_one_ends(17)\n</cell>\n<cell>\nstarts_one_ends(18)\n</cell>\n\
    <cell>\nstarts_one_ends(19)\n</cell>\n<cell>\nstarts_one_ends(20)\n</cell>\n<cell>\n\
    starts_one_ends(21)\n</cell>\n<cell>\nstarts_one_ends(22)\n</cell>\n<cell>\nstarts_one_ends(23)\n\
    </cell>\n<cell>\nstarts_one_ends(24)\n</cell>\n<cell>\nstarts_one_ends(25)\n</cell>\n\
    <cell>\nstarts_one_ends(26)\n</cell>\n<cell>\nstarts_one_ends(27)\n</cell>\n<cell>\n\
    starts_one_ends(28)\n</cell>\n<cell>\nstarts_one_ends(29)\n</cell>\n<cell>\nstarts_one_ends(30)\n\
    </cell>\n<cell>\nstarts_", "  one_count = 0\n  one_start = false\n  one_end =\
    \ false\n  one = true\n  (1..n).each do |i|\n    if i > 0\n      one = false\n\
    \    end\n    if i % 10 == 1 && one\n      one = true\n      one_start = true\n\
    \      one_end = false\n    elsif i % 10 == 1 && one && !one_start && !one_end\n\
    \      one_start = false\n      one_end = true\n    end\n    if i % 10 == 0 &&\
    \ !one_start && !one_end\n      one_count = one_count + 1\n    end\n  end\n  one_count\n\
    end\np starts_one_ends(1)\np starts_one_ends(12)\np starts_one_ends(123)\np starts_one_ends(1234)\n\
    p starts_one_ends(123456)\np starts_one_ends(1234567)\np starts_one_ends(123456789)\n\
    p starts_one_ends(1234567890)\np starts_one_ends(12345678901)\np starts_one_ends(123456789012)\n\
    p starts_one_ends(1234567890123)\np starts_one_ends(12345678901234)\np starts_one_ends(123456789012345)\n\
    p starts_one_ends(1234567890123456)\np starts_one_ends(12345678901234567)\np starts_one_ends(123456789012345678)\n\
    p starts_one_ends(1234567890123456788)\np starts_one_ends(12345678901234567889)\n\
    p starts_one_ends(123456789012345678899)\np starts_one_ends(12345678901234567889810)\n\
    p starts_one_ends(12345678901234567889811)\np starts_one_ends(12345678901234567889812)\n\
    p starts_one_ends(12345678901234567889813)\np starts_one_ends(12345678901234567889814)\n\
    p starts_one_ends(12345678901234567889815)\np starts_one_ends(12345678901234567889816)\n\
    p starts_one_ends(12345678901234567889817)\np starts_one_ends(12345678901234567889818)\n\
    p starts_one_ends(12345678901234567889819)\np starts_one_ends(12345678901234567889820)\n\
    p starts_one_ends(12345678901234567889821)\np starts_one_ends(12345678901234567889822)\n\
    p starts_one_ends(12345678901234567889823)\np starts_one_ends(123456789", "  starts\
    \ = 0\n  ends = 0\n  (1..n).each do |i|\n    if i % 10 == 1 && i / 10 == 0\n \
    \     starts += 1\n    elsif i % 10 == 0 && i / 10 == 1\n      ends += 1\n   \
    \ end\n  end\n  [starts, ends]\nend", "  ones = 0\n  (n*(n+1)).times do |i|\n\
    \    ones += 1 if i % 10 == 0\n    ones += 1 if i >= 10\n  end\n  ones\nend",
  "  count = 0\n  (1..n).each do |i|\n    if i.to_s(10).start_with?(\"1\")\n     \
    \ count += 1\n    elsif i.to_s(10).end_with?(\"1\")\n      count += 1\n    end\n\
    \  end\n  return count\nend", "  count = n.to_s.size\n  while n > 0\n    n /=\
    \ 10\n    count += 1\n  end\n  count\nend\n</code>\nThe above methods would work\
    \ to find the number of all n-digit numbers starting with 1 or ending with 1.\n\
    The only additional methods are to_s and size.\n<|/ a |>\n<| a tags=ruby,string,regex\
    \ dscore=0 |>\nThis is a slight variant on nathanvda's answer.  It uses no regular\
    \ expressions.  \n<code>", "  count = 1\n  ones = 0\n  while ones < n && one <\
    \ n\n    one += 1\n    count += 1\n  end\n  one\nend", "  ndigits = n.to_s.size\n\
    \  count = 0\n  while ndigits > 0\n    num = n.to_s.delete(ndigits).to_i\n   \
    \ if num > 0\n      if num % 10 == 1 && num != 1\n        count += 1\n      end\n\
    \    end\n    ndigits -= 1\n  end\n  count\nend", "  one = 1\n  count = 0\n  \n\
    \  while one*10+one <= n\n    one = (one*10+one).to_i\n    count += 1\n  end\n\
    \  \n  return count\nend", "  count = 0\n  (1..n).each do |i|\n    next if i.to_s.chars.take(n).include?('1')\n\
    \    count += 1\n  end\n  count\nend", "  count = 0\n  while n > 0\n    n -= n\
    \ % 10\n    count += 1\n  end\n  count\nend", "  if n < 0 then\n    return 0\n\
    \  else\n    sum = 0\n    while n > 0 do\n      sum += 1\n      n -= 1\n    end\n\
    \  end\n  return sum\nend", "  return (n==1) ? 0 : 1\nend", "  count = 0\n  i\
    \ = 2\n  while i < n\n    count += 1 if digits_between(i, n).include?(1)\n   \
    \ i += 1\n  end\n  count\nend\n</code>\nThis has two advantages over your implementation:",
  "  nums = []\n  n.times do\n    i = rand(9) + 1\n    while i > 9 && i >= 1\n   \
    \   i = rand(9) + 1\n    nums << i\n  end\n  nums.sort!\n  nums.shift if nums.first.is_a?\
    \ Integer\n  nums.last if nums.first.is_a? Integer\n  nums.count{ |x| x == nums.first\
    \ }\nend\n</code>\nThe results of these benchmarks were:\n<code>\n user     system\
    \      total        real\n 0.000000   0.000000   0.000000 (  0.000779)\n 0.000000\
    \   0.000000   0.000000 (  0.000426)\n 0.000000   0.000000   0.000000 (  0.000139)\n\
    \ 0.000000   0.000000   0.000000 (  0.000483)\n 0.000000   0.000000   0.000000\
    \ (  0.000146)\n 0.000000   0.000000   0.000000 (  0.000192)\n 0.000000   0.000000\
    \   0.000000 (  0.000129)\n 0.000000   0.000000   0.000000 (  0.000172)\n 0.000000\
    \   0.000000   0.000000 (  0.000122)\n 0.000000   0.000000   0.000000 (  0.000151)\n\
    \ 0.000000   0.000000   0.000000 (  0.000149)\n 0.000000   0.000000   0.000000\
    \ (  0.000174)\n 0.000000   0.000000   0.000000 (  0.000117)\n 0.000000   0.000000\
    \   0.000000 (  0.000103)\n 0.000000   0.000000   0.000000 (  0.000133)\n 0.000000\
    \   0.000000   0.000000 (  0.000119)\n 0.000000   0.000000   0.000000 (  0.000146)\n\
    \ 0.000000   0.000000   0.000000 (  0.000172)\n 0.000000   0.000000   0.000000\
    \ (  0.000130)\n 0.000000   0.000000   0.000000 (  0.000131)\n 0.000000   0.000000\
    \   0.000000 (  0.000424)\n 0.000000   0.000000   0.000000 (  0.000146)\n 0.000000\
    \   0.000000   0.000000 (  0.000190)\n 0.000000   0.000000   0.000000 (  0.000131)\n\
    \ 0.000000   0.000000   0.000000 (  0.000153)\n 0.000000   0.000000   0.000000\
    \ (  0.000148)\n 0.000000   0.000000   0.000000 (", "  count = 0\n  digits = n.to_s.split(//).map(&:to_i)\n\
    \  digits.each do |digit|\n    if digit == 1\n      if digits.last == 1\n    \
    \    count += 1\n      else\n        count += 1\n        digits.last--\n     \
    \ end\n    end\n  end\n  count\nend", "  count = 0\n  (1...n).each { |i|\n   \
    \ if i / 10.0 == 1 && i % 10 != 1 then\n      count += 1\n    end\n  }\n  count\n\
    end", "  count = 0\n  for i in 1..n\n    if n % i == 0\n      count += 1\n   \
    \ end\n  end\n  count\nend", "  n.to_s.chars.each_cons(2).to_a.count { |a, b|\
    \ a == 1 && b == 1 }\nend", "  number_to_count = {1 => 0, 2 => 0, 3 => 0, 4 =>\
    \ 0, 5 => 0, 6 => 0, 7 => 0, 8 => 0, 9 => 0}\n  n.times do |n|\n    if n % 10\
    \ == 1 || n % 10 == 0 || n % 10 == 7\n      number_to_count[n] += 1\n    end\n\
    \  end\n  number_to_count\nend", "    one = n.to_s(2).count('1')\n    \n    two\
    \ = n.to_s(10).count('2')\n    \n    return (n/10).to_i + (n%10).to_i + one +\
    \ two\nend\n</cell>\n<cell>\nstarts_one_ends(120)\n</cell>\n<cell>\nstarts_one_ends(1234)\n\
    </cell>\n<cell>\nstarts_one_ends(123)\n</cell>\n<text>\nIt may be useful to have\
    \ a single function that returns the number of times n is a perfect power of 2:",
  "  count = n.to_s.size\n  if n.to_s == 1 || \"0\"\n  else\n    if n % 10 == 1\n\
    \      count += starts_one_ends(n.to_i).to_s.size\n    end\n  end\n  count\nend",
  "  count = 0\n  (1..n).each do |i|\n    break if i % 10 == 1\n    break if i % 10\
    \ == 1 && i != 1\n    count += 1 if i % 10 == 0 || i % 10 == 1 && i != 1\n  end\n\
    \  count\nend", "  n.downto(0) do |i|\n    return i if i / 10_00 == 1 && i % 10_00\
    \ == 0\n  end\n  return n\nend", "  digits = n.digits.reverse\n  result = 0\n\
    \  n.digits.each do |d|\n    result += 1 if d == 1\n    result += 1 if d == 0\n\
    \  end\n  return result\nend", "  count = 0\n  i = 1\n  while i <= n\n    j =\
    \ i + 1\n    while j <= n\n      if j % i == 0\n        count += 1\n      j +=\
    \ i\n    i += 1\n  end\n  count\nend", "  count = 0\n  (0..n).each do |i|\n  \
    \  if i&1 == 1\n      count += 1\n    end\n  end\n  count\nend", "  (0..n).any?\
    \ { |i| (0..n).all? { |j| i === j + 1 } }\nend", "  n.to_s.length.times.map {\
    \ |i| n.to_s.index(\"1\".to_i) }.reduce(:+).to_i\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| a tags=ruby |>\nYou could also use the regex pattern \\d$ to find the\
    \ last digit.\n<code>", "  count = 0\n  n = n.to_i\n  (1..n).each do |i|\n   \
    \ count += 1 if i == n.to_s.to_i\n    count += 1 if i == n.to_s.to_s.to_i\n  end\n\
    \  count\nend", "  n = n.to_i\n  (n/10**n).floor.times.map { |i| i + n/10**i }\n\
    end", "  count = 0\n  (1..n).each do |i|\n    i % (10**(count+1)) == 0\n    count\
    \ += 1\n  end\n  return count\nend\n</code>\n<|/ a dscore=2 tags=ruby |>\n<| c\
    \ |>\nWhy `(1..n).each` rather than just `n.times.each`?\n<|/ c |>\n<| c |>\n\
    : Am I missing something? The OP's problem statement specifically states that\
    \ the function must return a \"count\" which is an integer.\n<|/ c |>\n<| c |>\n\
    : Ah, I misread that. Fixed my answer.\n<|/ c |>\n<| c |>\nThanks for your answers,\
    \ it helped me to understand.\n<|/ c |>\n<| a dscore=1 tags=ruby |>\nThe other\
    \ answers given so far do very different things. Here is my version:\n<code>",
  "  if n == 0\n    return 0\n  end\n  ones = n.to_s.chars.take_while { |c| c =~ /^1/\
    \ }.count\n  tens = n.to_s.chars.take_while { |c| c =~ /^10/ }.count\n  hundreds\
    \ = n.to_s.chars.take_while { |c| c =~ /^100/ }.count\n  thousands = n.to_s.chars.take_while\
    \ { |c| c =~ /^1000/ }.count\n  millions = n.to_s.chars.take_while { |c| c =~\
    \ /^10000/ }.count\n  billions = n.to_s.chars.take_while { |c| c =~ /^100000/\
    \ }.count\n  trillions = n.to_s.chars.take_while { |c| c =~ /^1000000/ }.count\n\
    \  return ones + tens + hundreds + thousands + millions + billions + trillions\n\
    end", "  count = 1\n  for i in 1..n\n    count += i\n    if i == 10\n      break\n\
    \  end\n  return count\nend", "  count = 0\n  ones = 0\n  \n  while ones < n\n\
    \    return count\n  \n    ones += 1 # Move to the next number.\n    count +=\
    \ 1 # Count positive integers that start with this number.\n    ones += 1", " \
    \ count = 0\n  while n > 0\n    n -= 1\n    if n % 10 == 1\n      count += 1\n\
    \    end\n  end\n  count\nend", "  count = 0\n  (1..n).each do |i|\n    break\
    \ if i%10 == 1 or i%10 == -1\n    count += 1\n  end\n  count\nend\n</code>\n<|/\
    \ a tags=ruby,algorithm |>\n<| a dscore=0 |>\n<code>", "  # your code goes here\n\
    end", "  ones = 0\n  starts = 0\n  ends = 0\n  \n  n.times do |i|\n    if (i %\
    \ 10 == 1)\n      ones += i\n    else\n      if i == 11 || i == 12 \n        starts\
    \ += 1\n      else\n        if i == 13 || i == 14\n          ends += 1\n     \
    \   end\n      end\n    end\n  end\n  \n  return [ones, starts, ends]\nend", " \
    \ ones = n.to_s.chars.select { |c| c == '1' }\n  one_starts_ends = ones.map do\
    \ |n|\n    n.to_s.chars.slice_before '1'.to_a\n      .map(&:to_i)\n      .count\n\
    \  end\nend", "  count = 0\n  i = 2\n  while i <= n\n    count += n / i\n    i\
    \ += 2\n  end\n  count\nend", "  total = 0\n  (1..n).each do |i|\n    next if\
    \ i.to_s.chars.map(&:to_i).sort.reverse.first == 1\n    total += 1 if i.to_s.chars.map(&:to_i).sort.reverse.last\
    \ == 1\n  end\n  total\nend", "  count = n - 1\n  i = 1\n  while i < n do\n  \
    \  if starts_with?(i, 1) || starts_with?(i, -1)\n      count += 1\n    end\n \
    \   i += 1\n  end\n  return count\nend", "  return number_of_binary_combinations(n)\
    \ if n < 10**6 && n % 1 == 0 \n  number_of_binary_combinations(n)\nend", "  count\
    \ = 0\n  while n > 0\n    count += 1\n    n /= 10\n  end\n  count\nend\n</cell>\n\
    <code language=julia-1.6>", "  (1..n).inject([0,0], :+).first\nend", "  count\
    \ = 0\n  i = 2\n  while i <= n\n    if i >= n\n      count += n - i\n    else\n\
    \      count += 1\n    i += 1\n  end\n  count\nend", "  count = 1\n  n.times {\
    \ |i| count += 0 if 1..i < n }\n  count\nend", "  counts = {1 => 0, 2 => 0, 3\
    \ => 0, 4 => 0, 5 => 0, 6 => 0, 7 => 0, 8 => 0, 9 => 0}\n  (0..n).each do |i|\n\
    \    if i > 0\n      counts[(1..10).detect { |j| i % j == 0 }] += 1\n    end\n\
    \  end\n  counts\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
