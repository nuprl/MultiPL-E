name: HumanEval_63_fibfib
language: rb
prompt: "# The FibFib number sequence is a sequence similar to the Fibbonacci sequnece\
  \ that's defined as follows:\n# fibfib(0) == 0\n# fibfib(1) == 0\n# fibfib(2) ==\
  \ 1\n# fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n# Please write a function\
  \ to efficiently compute the n-th element of the fibfib number sequence.\n# >>>\
  \ fibfib.call(1)\n# 0\n# >>> fibfib.call(5)\n# 4\n# >>> fibfib.call(8)\n# 24\ndef\
  \ fibfib(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fibfib\n\
  \    candidate = method(:fibfib)\n    assert_equal(1, candidate.call(2))\n    assert_equal(0,\
  \ candidate.call(1))\n    assert_equal(4, candidate.call(5))\n    assert_equal(24,\
  \ candidate.call(8))\n    assert_equal(81, candidate.call(10))\n    assert_equal(274,\
  \ candidate.call(12))\n    assert_equal(927, candidate.call(14))\n  end\nend\n"
completions: ["  return 0 if n == 0 else fibfib(n - 1) + fibfib(n - 2) + fibfib(n\
    \ - 3)\nend", "  return 0 if n == 0 else fib.call(n-1) + fib.call(n-2) + fib.call(n-3)\n\
    end\n</cell>\n<text>\nConclusion\nNow that you've gone through this exercise,\
    \ let's recap what you learned in the previous week.", "  case n\n  when 0\n \
    \   0\n  when 1\n    0\n  when 2\n    1\n  when n\n    fibfib(n-1) + fibfib(n-2)\
    \ + fibfib(n-3)\n  end\nend", "  return n if n < 3 else fibfib(n-1) + fibfib(n-2)\n\
    end\n</cell>\n<cell>\n%%time", "  if n==0\n    FibFib(0)\n  elsif n==1\n    FibFib(1)\n\
    \  elsif n==2\n    FibFib(2)\n  else\n    FibFib(n-1) + fibfib(n-2) + fibfib(n-3)\n\
    end\n</code>\n<|/ q |>\n<| c |>\nThe algorithm is straight forward, and no \"\
    BigInt\" would be required. It's even an infinite loop if you try `fibfib(0)`.\
    \  Your problem is the infinite loop. Fix it, and you should be fine.\n<|/ c |>\n\
    <| c |>\nIt's not an infinite loop but it's just very slow compared to the normal\
    \ Fibonacci sequence. It's just too slow, especially on large numbers, for me\
    \ to understand what's going on.\n<|/ c |>\n<| c |>\nIt's not an infinite loop,\
    \ you just aren't computing values past index 5.  Fibonacci sequences are all\
    \ about computing past index 5; all others are just \"iterative\" solutions.\n\
    <|/ c |>\n<| c |>\n`fibfib` doesn't terminate until you call `FibFib(0)` so it's\
    \ an infinite loop anyway.\n<|/ c |>\n<| c |>\nI added an example of fibfib(n)\
    \ which shows the problem I am having.\n<|/ c |>\n<| a dscore=1 |>\nYou need to\
    \ change the last else clause to FibFib(n-1) + fibfib(n-2) - fibfib(n-3), so that\
    \ you include the last two numbers instead of just the last three.\n<|/ a tags=fibonacci,ruby,algorithm,bignum\
    \ |>\n<| c |>\nThat worked, thank you! Now I'm getting the \"wrong answer\" from\
    \ fibfib(0).  I'm going to edit the question to show that\n<|/ c |>\n<| c |>\n\
    If you just want the fibonacci sequence up to a certain value, you can simply\
    \ use recursion: fibfib(n) = fibfib(n-1) + fibfib(n-2) if n <= 1\n<|/ c |>\n<|\
    \ c |>\nI want to print the sequence up to a certain number without using recursion\
    \ or loops.  That's the whole point.\n<|/ c |>\n<| a dscore=1 |>\nYour problem\
    \ is that you are missing a return value in your else clause.\n<code>", "    if\
    \ n == 0\n        0\n    elsif n == 1\n        0\n    elsif n == 2\n        1\n\
    \    elsif n >= 3\n        fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n    else\n\
    \        puts \"Error\"\nend\n</code>\n<|/ a dscore=0 tags=ruby,fibonacci |>\n\
    <| c |>\n`fibfib` is very inefficient (O(n^3)). I'd use a different approach to\
    \ compute fibfib. One that uses memoization.\n<|/ c |>\n<| c |>\n: That might\
    \ be the wrong approach, since `memoize` is an `ActiveSupport` method.\n<|/ c\
    \ |>\n<| c |>\n: I added a version that doesn't use memoization. It's just plain\
    \ Ruby.\n<|/ c |>\n<| c |>\nI believe that memoization is still a better solution.\
    \ As you say, it's just plain Ruby, which means that it won't suffer from the\
    \ issues of concurrency, but it is still going to be O(n^3). Even though the current\
    \ answer is O(n^2) I believe that it's more efficient to calculate `fibfib` up\
    \ front. Also `fibfib` will still be O(n^3) even if you memoize it.\n<|/ c |>\n\
    <| c |>\n: That's a fair point. I wouldn't rely on anything Rails specific in\
    \ my answer though. :-) If you look at the history of my answer, you'll see I\
    \ added memoization back then. I'll add that approach back, too...\n<|/ c |>\n\
    <| a dscore=0 |>\nYour code works fine with Ruby 1.9.3. I ran into a problem with\
    \ it on Ruby 1.9.2 until I changed the last line of the function to this:\n<code>\n\
    puts fibfib(n)\n</code>\n<|/ a tags=ruby,fibonacci |>\n<| a dscore=0 |>\nJust\
    \ to add to the previous answers, here is a recursive version of the Fibonacci\
    \ sequence:\n<code>", "    if n == 0\n        return 0\n    if n == 1\n      \
    \  return 1\n    if n == 2\n        return 1\n    return fibfib(n-1) + fibfib(n-2)\
    \ + fibfib(n-3)\n        ", "  fibfibs = []\n  fibfibs << 0\n  fibfibs << 1\n\
    \  fibfibs << 2\n  fibfibs << 3\n  if n == 0\n    return fibfibs[0]\n  if n ==\
    \ 1\n    return fibfibs[1]\n  if n == 2\n    return fibfibs[2]\n  fibfibs << fibfib(n-1)\
    \ + fibfib(n-2) + fibfib(n-3)\n  return fibfibs[-1]\nend\n</cell>\n<text>\nProblem\
    \ 3\nA palindromic number reads the same both ways. The largest palindrome made\
    \ from the product of two 2-digit numbers is 9009 = 91 x 99.\nFind the largest\
    \ palindrome made from the product of two 3-digit numbers.", "  fibfib = (fib\
    \ + (fib - fib)^n) / n\n  puts fibfib\nend", "    fibfibnum = 0\n    if n == 0\n\
    \        fibfibnum = 0\n    elsif n == 1\n        fibfibnum = 0\n    elsif n ==\
    \ 2\n        fibfibnum = 1\n    elsif n > 2\n        fibfibnum = fibfib(n-1) +\
    \ fibfib(n-2) + fibfib(n-3)\n    end\n    return fibfibnum\nend", "  a = 0\n \
    \ b = 2\n  c = 1\n  while b <= n\n    a, b, c = b, a + b, c\n  end\n  return c\n\
    end", "  if n == 0\n    puts 0\n  elsif n == 1\n    puts 0\n  elsif n == 2\n \
    \   puts 1\n  else\n    fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n  end\nend",
  "  a, b = 0, 1\n  while n != 0\n    a, b = b, a+b\n    n -= 1\n  end\n  return b\n\
    end\n</cell>\n<cell>", "\treturn 0 if n < 2 else fibfib.call(n - 1) + fibfib.call(n\
    \ - 2)", "  n = 0 if n == nil then 0 else n\n  if n == 0 || n == 1 then\n    0\n\
    \  else\n    fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n  end\nend", "  if n ==\
    \ 0\n    0\n  elsif n == 1\n    1\n  elsif n == 2\n    1\n  else\n    fibbfib.call(n-2)\
    \ + fibbfib.call(n-3)\n  end\nend", "  if n<0\n    return 0\n  fibfib(n-1)+fibfib(n-2)+fibfib(n-3)\n\
    end", "  if n < 0\n    0\n  elsif n == 0\n    0\n  elsif n == 1\n    1\n  else\n\
    \    fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n  end\nend\n</cell>\n<cell>", "\t\
    return 0 if (n == 0)\n\t1 if (n == 1)\n\tfibfib.call(n-1) + fibfib.call(n-2) +\
    \ fibfib.call(n-3)\nend", "  return 0 if n == 0 else 1 + fibfib(n - 2) + fibfib(n\
    \ - 3)\nend", "  puts \"This fibfib(n) function requires 2 parameters.\"\n  puts\
    \ \"First parameter is expected to be an integer and represents the n-th element\
    \ of the Fibonacci sequence.\"\n  puts \"Second parameter is expected to be an\
    \ integer and represents the index of the element of the Fibonacci sequence to\
    \ return (index starts at 0).\"\n  puts \"Please use a try/catch block to test\
    \ your function and handle the scenario where you pass an invalid parameter.\"\
    \nend", "  sum = 0\n  if n == 0\n    return 0\n  sum = fibfib(n-1) + fibfib(n-2)\
    \ + fibfib(n-3)\n  return sum\nend", "  fibfib = [0, 1, 1]\n  return fibfib[n-1]\
    \ + fibfib[n-2] + fibfib[n-3]\nend\n</cell>\n<cell>", "  if n < 0\n    raise ArgumentError,\
    \ 'fibfib({:d})'.format(n)\n  ret = fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n\
    \  ret\nend", "  return 1 if n == 0 else fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n\
    end\nfibfib(1)\nfibfib(5)\nfibfib(8)\nfibfib(100)\nfibfib(10**10)\nfibfib(10**100)\n\
    fibfib(10**10**3)\nfibfib(10**10**4)\nfibfib(10**10**5)\nfibfib(10**10**6)\nfibfib(10**10**7)\n\
    fibfib(0)", "  if n == 0\n    0\n  elsif n == 1\n    0\n  elsif n == 2\n    1\n\
    \  else\n    fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\nend\n</cell>\n<cell>\nfibfib\n\
    </cell>\n<cell>\nfibfib.call(9)\n</cell>\n<text>\nProblem 4: Memoization\nMemoization\
    \ is a pattern used to speed-up computation that is often done in the single-input\
    \ case. Memoization is often used to speed up an algorithm that repeatedly takes\
    \ arguments and outputs the same result repeatedly. Memoization is also used to\
    \ speed up computation that would be horrendously slow to run every time the same\
    \ inputs occur.", '  return 0 if n < 2 else fibfib(n-1) + fibfib(n-2) + fibfib(n-3)',
  "  while n != 0\n    puts n\n    n -= 1\n  end\nend", "  if n < 3\n    n\n  else\n\
    \    fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\nend\nputs \"fibfib(0) == #{fibfib(0)}\"\
    \nputs \"fibfib(1) == #{fibfib(1)}\"\nputs \"fibfib(2) == #{fibfib(2)}\"\nputs\
    \ \"fibfib(n) == #{fibfib(n)} (fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3))\"",
  "  sum = 0\n  while n > 0\n    sum = sum + n\n    n = n-2\n  sum\nend\n</cell>\n\
    <cell>", "  # Your code here\n  if n == 0\n    0\n  elsif n == 1\n    0\n  elsif\
    \ n == 2\n    1\n  else\n    fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n  end\n\
    end", "  fib = [0]\n  \n  if n <= 1\n    fib [0] = 0\n  else\n    fib [0] = fibfib(n-1)\
    \ + fibfib(n-2) + fibfib(n-3)\n  end", "  n.times do\n    yield 0\n    yield 0\n\
    \    yield 1\n    yield n-1\n  end\n  fibfib.call(n+1).to_a[3].last\nend\n</cell>\n\
    <code language=ruby-1.9.3-p551>", "  case n\n    when 0 then 0\n    when 1 then\
    \ 0\n    when 2 then 1\n    else fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n  end\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nI tried to do this with recursion.\n\
    <code>", "  i = 1\n  result = 0\n  while i <= n do\n    result += i\n    i +=\
    \ 1\n  end\n  result\nend", "  if n == 0 || n == 1 then\n    0\n  else\n    fibfib(n-1)\
    \ + fibfib(n-2) + fibfib(n-3)\n  end\nend\n</cell>\n<cell>\n@assert fibfib(0)\
    \ == 0\n@assert fibfib(1) == 0\n@assert fibfib(2) == 1\n@assert fibfib(n) == fibfib(n-1)\
    \ + fibfib(n-2) + fibfib(n-3)\n</cell>\n<cell>", "  FibFib = 1\n  FibFib = 1\n\
    \  FibFib = 1\n  FibFib = 1\n  return FibFib\nend", "    fibfib = 0\n    fibfib\
    \ += fibfib\n    fibfib += fibfib\n    fibfib += fibfib\n    return fibfib", " \
    \ a, b = 0, 1\n  while n != 0\n    a, b = b, a + b\n    n -= 1\n  end\n  b\nend",
  "\tsum = 0\n\ti = 1\n\twhile i <= n:\n\t\tsum = sum + i\n\t\ti += 1\n\treturn sum",
  "\tif n < 3\n\t\t0\n\telsif n == 0\n\t\t0\n\telsif n == 1\n\t\t0\n\telsif n == 2\n\
    \t\t1\n\telse\n\t\tfibfib(n-1) + fibfib(n-2) + fibfib(n-3)\nend", "  \n  # check\
    \ if n greater than or equal to 0\n  if n < 0\n    return 0\n  \n  # check if\
    \ n equal to 0\n  if n == 0\n    return 0\n  \n  # check if n equal to 1\n  if\
    \ n == 1\n    return 1\n  \n  # compute the recursive value\n  fibfib_value =\
    \ fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n  \n  return fibfib_value\n</cell>\n\
    <cell>", "\ta = 0\n\tb = 1 \n\twhile a < n do\n\t\ta, b, c = a + b, a, b, c\n\t\
    end\n\treturn a\nend", "  return 0 if n == 0 else fibfib(n-1) + fibfib(n-2) +\
    \ fibfib(n-3)\nend", "  fibfib.memo[n] ||= begin\n    memo = Hash.new(0)\n   \
    \ memo[0] = 0\n    memo[1] = 1\n    memo[2] = 0\n    memo[3] = 2\n    n.times\
    \ do\n      memo[n] = memo[n-1] + memo[n-2] + memo[n-3]\n    end\n    fibfib.memo[n]\
    \ = memo[n]\n  end\n  fibfib.memo[n]\nend", "  return n if n <= 3 or fibfib(n-1)\
    \ + fibfib(n-2) == n\n  return fibfib(n-1) + fibfib(n-2)\nend", "  if n < 0 \n\
    \    puts \"fibfib(n) called with n<0\"\n    exit\n  end\n  \n  if n == 0\n  \
    \  0\n  elsif n == 1\n    0\n  elsif n == 2\n    1\n  else\n    fibfib(n-1) +\
    \ fibfib(n-2) + fibfib(n-3)\n  end\nend", "    sum = [0]*n\n    i = 1\n    while\
    \ i <= n do\n        sum[i] = sum[i-1] + sum[i-2] + sum[i-3]\n        i += 1\n\
    \    end\n    return sum[n]\nend\n</cell>\n<cell>\nfibfib(10)\n</cell>\n<text>\n\
    Part 4\n(10 points) (15 min)\nPart 4: Functions, variables, returns, ranges, maps,\
    \ ranges\nNow that you have defined the fibfib function and called the fibfib\
    \ function on some values, let's write some code to generate fibonacci numbers.\
    \ Please write functions to generate values from two given values. For example,\
    \ fibfib(2, 6) should generate 3, 5, 7, and so on. You may find it helpful to\
    \ use the map function and range function. Let's also use the range function and\
    \ see how it works.", "  return n if n < 3 else fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n\
    end", "  if n <= 0\n    0.0\n  else\n    fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n\
    \  end\nend", "  if n <= 1\n    0\n  else\n    fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n\
    \  end\nend", "  if n == 0\n    puts \"0\"\n  elsif n == 1\n    puts \"0\"\n \
    \ elsif n == 2\n    puts \"1\"\n  elsif n <= 3\n    puts fibfib(n-1) + fibfib(n-2)\
    \ + fibfib(n-3)\n  end\nend", "  fib = call(1)\n  while n > 1 do\n    fib1 = call(n-1)\n\
    \    fib = fib1 + call(n-2) + fib\n  end\n  fib\nend\n</code>\nThen let's try\
    \ this out! \n<code>\nfibfib(0)\nfibfib(1)\nfibfib(2)\nfibfib(3)\nfibfib(4)\n\
    fibfib(5)\nfibfib(6)\nfibfib(7)\nfibfib(8)\nfibfib(9)\nfibfib(10)\nfibfib(11)\n\
    fibfib(12)\nfibfib(13)\nfibfib(14)\nfibfib(15)\nfibfib(16)\nfibfib(17)\nfibfib(18)\n\
    fibfib(19)\nfibfib(20)\nfibfib(21)\nfibfib(22)\nfibfib(23)\nfibfib(24)\nfibfib(25)\n\
    fibfib(26)\nfibfib(27)\nfibfib(28)\nfibfib(29)\nfibfib(30)\nfibfib(31)\nfibfib(32)\n\
    fibfib(33)\nfibfib(34)\nfibfib(35)\nfibfib(36)\nfibfib(37)\nfibfib(38)\nfibfib(39)\n\
    fibfib(40)\nfibfib(41)\nfibfib(42)\nfibfib(43)\nfibfib(44)\nfibfib(45)\nfibfib(46)\n\
    fibfib(47)\nfibfib(48)\nfibfib(49)\nfibfib(50)\nfibfib(51)\nfibfib(52)\nfibfib(53)\n\
    fibfib(54)\nfibfib(55)\nfibfib(56)\nfibfib(57)\nfibfib(58)\nfibfib(59)\nfibfib(60)\n\
    fibfib(61)\nfibfib(62)\nfibfib(63)\nfibfib(64)\nfibfib(65)\nfibfib(66)\nfibfib(67)\n\
    fibfib(68)\nfibfib(69)\nfibfib(70)\nfibfib(71)\nfibfib(72)\nfibfib(73)\nfibfib(74)\n\
    fibfib(75)\nfibfib(76)\nfibfib(77)\nfibfib(78)\nfibfib(79)\nfibfib(80)\nfibfib(81)\n\
    fibfib(82)\nfibfib(", "    if n == 0\n        return 0\n    elif n == 1\n    \
    \    return 0\n    elif n == 2\n        return 1\n    else \n        return fibfib(n\
    \ - 1) + fibfib(n - 2) + fibfib(n - 3)\n    \nprint fibfib(0)\nprint fibfib(1)\n\
    print fibfib(2)\nprint fibfib(3)\nprint fibfib(4)\nprint fibfib(5)\nprint fibfib(6)\n\
    print fibfib(7)\nprint fibfib(8)\nprint fibfib(9)\n</cell>\n<text>\nExercise:\
    \ How many times does the Fibonacci number sequence converge?", "    if n < 0\n\
    \        puts \"FibFibError: negative numbers not supported\"\n    elsif n ==\
    \ 0\n        0\n    elsif n == 1\n        0\n    elsif n == 2\n        1\n   \
    \ elsif n < 0\n        puts \"FibFibError: negative numbers not supported\"\n\
    \    else\n        fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n    end\nend", '  return
    n if n < 3 or fibfib(n-1) + fibfib(n-2) == 3 else fibfib(n-1) + fibfib(n-2)',
  "  fibfib = (n.call(n-1) + n.call(n-2) + n.call(n-3)).to_i\nend\n</cell>\n<cell>",
  "  if(n == 0)\n    0\n  elsif(n == 1)\n    1\n  elsif(n == 2)\n    1\n  else\n \
    \   fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\nend", "  case n\n  when 0 then 0\n\
    \  when 1 then 0\n  when 2 then 1\n  else fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n\
    \  end\nend", '  return 0 if n == 0 else fibfib(n-1) + fibfib(n-2) + fibfib(n-3)',
  "    i = n\n    if i < 0 then\n        fibfib.call(-1)\n    else\n        if i==1\
    \ then\n            return(0)\n        else\n            if i==2 then\n      \
    \          return(1)\n            else\n                if i==3 then\n       \
    \             return(1)\n                else\n                    return(fibfib(i\
    \ - 1) + fibfib(i-2) + fibfib(i-3))\n        end\n    end\nend", "  begin\n  \
    \  return 0 if n < 2 then n else fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n  rescue\
    \ SystemStackError\n    n\n  end\nend", "  a, b = 0, 1\n  while n > 0\n    a,\
    \ b = b, a + b\n    n -= 1\n  end\n  b\nend", "\tfibfib_seq = 0\n\tfibfib_index\
    \ = 0\n\tfibfib_term = 2\n\tfibfib_term2 = 3\n\tfibfib_term3 = 0\n\tfibfib_index\
    \ = 0\n\tfibfib_term = 0\n\tfibfib_index = 0\n\tfibfib_term = 0\n\tfibfib_index\
    \ = 0\n\tfibfib_term = 0\n\tfibfib_index = 0\n\tfibfib_term = 0\n\tfibfib_index\
    \ = 0\n\tfibfib_term = 0\n\tfibfib_index = 0\n\tfibfib_term = 0\n\tfibfib_index\
    \ = 0\n\tfibfib_term = 0\n\tfibfib_index = 0\n\tfibfib_term = 0\n\tfibfib_index\
    \ = 0\n\tfibfib_term = 0\n\tfibfib_index = 0\n\tfibfib_term = 0\n\tfibfib_index\
    \ = 0\n\tfibfib_term = 0\n\tfibfib_index = 0\n\tfibfib_term = 0\n\tfibfib_index\
    \ = 0\n\tfibfib_term = 0\n\tfibfib_index = 0\n\tfibfib_term = 0\n\tfibfib_index\
    \ = 0\n\tfibfib_term = 0\n\tfibfib_index = 0\n\tfibfib_term = 0\n\tfibfib_index\
    \ = 0\n\tfibfib_term = 0\n\tfibfib_index = 0\n\tfibfib_term = 0\n\tfibfib_index\
    \ = 0\n\tfibfib_term = 0\n\tfibfib_index = 0\n\tfibfib_term = 0\n\tfibfib_index\
    \ = 0\n\tfibfib_term = 0\n\tfibfib_index = 0\n\tfibfib_term = 0\n\tfibfib_index\
    \ = 0\n\tfibfib_term = 0\n\tfibfib_index = 0\n\tfibfib_term = 0\n\tfibfib_index\
    \ = 0\n\tfibfib_term = 0\n\tfibfib_index = 0\n\tfibfib_term = 0\n\tfibfib_index\
    \ = 0\n\tfibfib_term = 0\n\tfibfib_index = 0\n\tfibfib_term = 0\n\tfibfib_index\
    \ = 0\n\tfibfib_term = 0\n\tfibfib_index = 0\n\tfibfib_term = 0\n\tfibfib_index\
    \ = 0\n\tfibfib_term = 0\n\tfibfib_index = 0\n\tfibfib_term = 0\n\tfibfib_index\
    \ = 0\n\tfibfib_term = 0\n\tfibfib_index = 0\n\tfibfib_term = 0\n\tfibfib_index\
    \ = 0\n\tfibfib_term = 0\n\tfibfib_index = 0\n\tfibfib_term = 0\n\tfibfib_index\
    \ = 0\n\tfib", "\traise NotImplementedError, \"fibfib(n) not implemented\"\nend\n\
    @test fibfib(0) == 0\n@test fibfib(1) == 0\n@test fibfib(2) == 1\n@test fibfib(n)\
    \ == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).", "\tfib = fibbonaci(n)\n\treturn\
    \ fib", "  fibfib = (@fibfib).dup\n  fibfib = (fibfib[-1] + fibfib[-2] + fibfib[-3]).dup\n\
    \  fibfib[-1]\nend", "  if n<0\n    return nil\n  else\n    fibfib(n-1)+fibfib(n-2)+fibfib(n-3)\n\
    \  end\nend", "  a = b = 0\n  while n\n    a = b\n    b = b + 2*a\n    n = n-1\n\
    \  end\n  a\nend", "  ret = 0\n  if n == 0\n    ret = 0\n  elsif n == 1\n    ret\
    \ = 1\n  elsif n == 2\n    ret = 1\n  else\n    ret = fibfib(n-1) + fibfib(n-2)\
    \ + fibfib(n-3)\n  end\n  puts(ret)\nend", "  fib_array = [0,0,1]\n  if n==0 then\
    \ return 0 end\n  if n==1 then return fib_array[2] end\n  fib_array[0] = fibfib(n-1)\
    \ + fibfib(n-2)\n  fib_array[1] = fibfib(n-1) + fibfib(n-3)\n  return fib_array[n]\n\
    end", "  result = 0\n  fibfib = (1..n).inject([0,1]) { |a,b| a+b }\n  fibfib[n\
    \ - 1]\nend", "\tsum = 0\n\twhile n > 0\n\t\tsum += 1\n\t\tn = n-1\n\tsum\nend\n\
    </cell>\n<cell>", "  return 0 if n == 0 else (fibfib(n-1) + fibfib(n-2) + fibfib(n-3))\n\
    \  ", "    a, b = 0, 1\n    while a < n\n        a, b = b, a + b\n    end\n  \
    \  b\nend\n</cell>\n<code language=julia-1.5>\n@time fibfib(2)\n</cell>\n<text>\n\
    Task\nWrite a function to compute $n^4$ using the Fibonacci sequence.", "  return\n\
    end", "  fibfib.stack = fibfib.stack || []\n  return fibfib.stack.pop || fibfib(n-1)\
    \ + fibfib(n-2) + fibfib(n-3)\nend", "  (n == 0 || n == 1) ? 0 : (fibfib(n-2)\
    \ + fibfib(n-1))\nend\n</cell>\n<cell>", "  fibfib_call(n) or return n\n  fibfib_call(n\
    \ - 1) + fibfib_call(n - 2) + fibfib_call(n - 3)\nend\nfibfib(n) or return n\n\
    fibfib(n-1) + fibfib(n-2) + fibfib(n-3)", "  if n <= 0\n    0\n  elsif n <= 1\n\
    \    1\n  elsif n == 2\n    1\n  else\n    fibfib.call(n-1) + fibfib.call(n-2)\
    \ + fibfib.call(n-3)\nend\n</cell>\n<cell>\nfibfib(1)\n</cell>\n<cell>\nfibfib(5)\n\
    </cell>\n<cell>\nfibfib(0)\n</cell>\n<cell>\nfibfib(5)\n</cell>\n<cell>\nfibfib(8)\n\
    </cell>\n<cell>\nfibfib(9)\n</cell>\n<cell>\nfibfib.call(9)\n</cell>\n<cell>\n\
    fibfib(1)\n</cell>\n<cell>\nfibfib(2)\n</cell>\n<cell>\nfibfib(3)\n</cell>\n<cell>\n\
    fibfib(0)\n</cell>\n<cell>\nfibfib(1)\n</cell>\n<cell>\nfibfib(2)\n</cell>\n<cell>\n\
    fibfib(0)\n</cell>\n<cell>\nfibfib(0)\n</cell>\n<cell>\nfibfib(0)\n</cell>\n<cell>\n\
    fibfib(0)\n</cell>\n<cell>\nfibfib(0)\n</cell>\n<cell>\nfibfib(0)\n</cell>\n<cell>\n\
    fibfib(0)\n</cell>\n<cell>\nfibfib(0)\n</cell>\n<cell>\nfibfib(0)\n</cell>\n<cell>\n\
    fibfib(0)\n</cell>\n<cell>\nfibfib(0)\n</cell>\n<cell>\nfibfib(0)\n</cell>\n<cell>\n\
    fibfib(0)\n</cell>\n<cell>\nfibfib(0)\n</cell>\n<cell>\nfibfib(0)\n</cell>\n<cell>\n\
    fibfib(0)\n</cell>\n<cell>\nfibfib(0)\n</cell>\n<cell>\nfibfib(0)\n</cell>\n<cell>\n\
    fibfib(0)\n</cell>\n<cell>\nfibfib(0)\n</cell>\n<cell>\nfibfib(0)\n</cell>\n<cell>\n\
    fibfib(0)\n</cell>\n<cell>\nfibfib(0)\n</cell>\n<cell>\nfibfib(0)\n</cell>\n<cell>\n",
  "  count = 0\n  if n <= 0\n    0\n  elsif n <= 1\n    1\n  elsif n <= 3\n    1\n\
    \  elsif n <= 5\n    2\n  elsif n <= 8\n    3\n  elsif n <= 15\n    5\n  elsif\
    \ n <= 21\n    8\n  elsif n <= 32\n    13\n  elsif n <= 45\n    21\n  elsif n\
    \ <= 58\n    34\n  elsif n <= 70\n    55\n  elsif n <= 84\n    89\n  else\n  \
    \  fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n  end\nend", "  return 0 if\
    \ n == 0 else fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\nend", "  fib = 0\n  i =\
    \ 2\n  while i < n\n    fib += fibfib(i)\n    i += 1\n  end\n  fib\nend", "  \
    \  if n == 0\n        0\n    elsif n == 1\n        0\n    elsif n == 2\n     \
    \   1\n    else\n        fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n    end\nend",
  "\traise NotImplementedError, \"fibfib(n) not implemented.\"\nend", "  if n<=1\n\
    \    0\n  elsif n<=3\n    1\n  elsif n<=5\n    2\n  else\n    fibfib(n-1) + fibfib(n-2)\
    \ + fibfib(n-3)\nend", "  if n == 0\n    0\n  else\n    fibfib.call(n-1) + fibfib.call(n-2)\
    \ + fibfib.call(n-3)\n  end\nend", "  result = 0\n  fibfib(n-1) if n > 1\n  fibfib(n-2)\
    \ if n > 2\n  fibfib(n-3) if n > 3\n  result\nend", "  i = 2\n  while i <= n do\n\
    \    i = i + 2\n  end\n  i\nend", "\t\n\treturn fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n\
    \t\nend\n</cell>\n<code language=julia-1.4>", "  result = 0\n  for i in 0..(n-1)\n\
    \    result += fibfib(i+1) * (n-i) * i\n  end\n  result\nend\n</cell>\n<text>\n\
    Problem 3\nThe Fibonacci numbers are defined by the recurrence relation defined\
    \ by the equation:\n$F(n) = \\begin{cases}\n      n & \\text{if } n \\equiv 0\
    \ \\\n      1 & \\text{if } n \\equiv 1 \\\n      F(n-1) + F(n-2) & \\text{if\
    \ } n > 1\n    \\end{cases}$\nwhere $F_n(x)$ denotes the n-th Fibonacci number.\
    \ This function definition defines the fibonacci sequence up to the $n$ th term,\
    \ however, we also need the full list of Fibonacci numbers less than or equal\
    \ to $n$.", "  sum = 0\n  if n == 0\n    sum == 0\n  else\n    sum = fibfib(n-1)\
    \ + fibfib(n-2) + fibfib(n-3)\n  end\n  return sum\nend", "    if n == 0\n   \
    \     return 0\n    if n == 1\n        return 0\n    if n == 2\n        return\
    \ 1\n    fibfib.call(n-1) + fibfib.call(n-2) + fibfib.call(n-3)\nend", '  fibfib.fibfibs
    = [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,102334155,165580141,267914296,433494437,701408733,1134903170,1836311903,3082374465,4592255765,7285023353,1219601084,18931126717,301238679,4543542967,7018087169,11407691416,18363119011,3082374466,4592255766,7285023356,12196010842,18931126717,3012386788,45435429678,7018087171,11407691417,18363119012,3082374467,4592255767,7285023357,12196010843,18931126718,3012386789,45435429679,7018087172,11407691418,18363119013,3082374468,4592255768,7285023358,12196010844,18931126719,3012386790,45435429679,7018087173,11407691419,18363119014,3082374469,4592255769,7285023359,12196010845,18931126720,3012386791,45435429679,7018087174,11407691420,18363119015,3082374470,4592255770,7285023360,12196010846,18931126721,3012386792,45435429679,7018087175,11407691421,18363119016,3082374471,4592255771,7285023361,12196010847,18931126722,3012386793,45435429679,7018087176,11407691422,18',
  "  \n  return 0 if n == 0 || n == 1 else fib(n - 1) + fib(n - 2)\nend", "  if n\
    \ < 0\n    raise ArgumentError, \"n must be a non-negative integer\"\n  if n ==\
    \ 0\n    0\n  elsif n == 1\n    1\n  elsif n == 2\n    1\n  else\n    fibfib(n-1)\
    \ + fibfib(n-2) + fibfib(n-3)\n  end\nend", "  fibfibs = [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987]\n\
    \  fibfibs.delete_at(n) if n < fibfibs.length\n  fibfibs[n]\nend", "  if n < 0\n\
    \    n = 0\n  end\n  if n == 0\n    0\n  elsif n == 1\n    1\n  elsif n == 2\n\
    \    1\n  elsif n == 3\n    2\n  else\n    fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n\
    \  end\nend", "  nfib = 0\n  if n == 0\n    0\n  elsif n == 1\n    1\n  else\n\
    \    nfib = fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n  end\n  return nfib\nend",
  "\ta = fibfib(n-1)\n\tb = fibfib(n-2)\n\tfibfib(n-1)\n\treturn a + b + fibfib(n-3)\n\
    end", "\ta = 0\n\tb = 1\n\twhile b <= n:\n\t\tc = a + b\n\t\ta = b\n\t\tb = c\n\
    \treturn b\n</cell>\n<cell>", "    \n    if n == 0\n        return 0\n    elif\
    \ n == 1\n        return 1\n    elif n == 2\n        return 1\n    else:\n   \
    \     return fibfib(n-1) + fibfib(n-2) + fibfib(n-3)", '  return 0 if n == 0 ||
    n == 1 else fibfib(n-1) + fibfib(n-2)', "  return 0 if n <= 1 then 0 else fibfib(n-1)\
    \ + fibfib(n-2) + fibfib(n-3)\nend\nputs \"1st fibfib(0) = #{fibfib(0)}\"\nputs\
    \ \"1st fibfib(5) = #{fibfib(5)}\"\nputs \"1st fibfib(8) = #{fibfib(8)}\"", " \
    \ a,b = 0,1\n  while n >= 1\n    a,b = b,a+b\n    n -= 1\n  end\n  a\nend", " \
    \ n <= 0 ? 0 : (fibfib(n-1) + fibfib(n-2) + fibfib(n-3))\nend", "  a = 0\n  b\
    \ = 1\n  while a <= n\n    b = a + b\n    a = b - a\n  end\n  return b\nend",
  "\traise NotImplementedError(\"fibfib(n) not implemented yet\")\n\tpass", "  i =\
    \ n - 1\n  fibfib = 0\n  while i > 1\n    fibfib = fibfib + i\n    i = i - 1\n\
    \  end\n  fibfib\nend", "  fibfib = [0,1]\n  fibfib[0] = 0\n  fibfib[1] = 1\n\
    \  for i in 2..n\n    fibfib[i] = fibfib[i-1] + fibfib[i-2] + fibfib[i-3]\n  end\n\
    \  return fibfib[n]\nend", "\tsum = 0\n\ti = 2\n\twhile i < n\n\t\tsum = sum +\
    \ i\n\t\ti = i + 2\n\tsum\nend", "  if n <= 1 \n    0\n  elsif n <= 2 \n    1\n\
    \  else\n    fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n  end\nend", "  if n<=2\n\
    \    0\n  else\n    fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n  end\nend", "  if\
    \ n < 3 then return 0 end\n  fibfib(n - 2) + fibfib(n - 1) + fibfib(n - 3)\nend\n\
    </cell>\n<text>\nProblem 8 - Fibonacci Sequence\nIn the Fibonacci sequence, the\
    \ numbers 0 to 9 come in two parts: 0 and 1.", "  i = 1\n  fibfibs = 0\n  while\
    \ i <= n\n    fibfibs = fibfibs + i\n    i = i + 1\n  end\n  fibfib\nend", " \
    \ return 0 if (n < 0) or n == 0\n  else (fibfib(n-1) + fibfib(n-2) + fibfib(n-3))\n\
    end\n</cell>\n<code language=julia-0.4>\nfibfib(0)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(1)\n</cell>\n<code language=julia-0.4>\nfibfib(2)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(-1)\n</cell>\n<code language=julia-0.4>\nfibfib(-2)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(-3)\n</cell>\n<code language=julia-0.4>\nfibfib(-4)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(-5)\n</cell>\n<code language=julia-0.4>\nfibfib(-6)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(-7)\n</cell>\n<code language=julia-0.4>\nfibfib(-8)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(-9)\n</cell>\n<code language=julia-0.4>\nfibfib(-10)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(-11)\n</cell>\n<code language=julia-0.4>\nfibfib(-12)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(-13)\n</cell>\n<code language=julia-0.4>\nfibfib(-14)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(-15)\n</cell>\n<code language=julia-0.4>\nfibfib(-16)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(-17)\n</cell>\n<code language=julia-0.4>\nfibfib(-18)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(-19)\n</cell>\n<code language=julia-0.4>\nfibfib(-20)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(-21)\n</cell>\n<code language=julia-0.4>\nfibfib(-22)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(-23)\n</cell>\n<code language=julia-0.4>\nfibfib(-24)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(-25)\n</cell>\n<code language=julia-0.4>\nfibfib(-26)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(-27)\n</cell>\n<code language=julia-0.4>\nfibfib(-28)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(-29)\n", "  count = 0\n  if n <= 1\n    count = 1\n  elsif n <= 2\n   \
    \ count = 0\n  elsif n > 2\n    count = fibfib(n - 1) + fibfib(n - 2) + fibfib(n\
    \ - 3)\n  end\n  count\nend", "  if n==0\n    0\n  elsif n==1\n    1\n  elsif\
    \ n==2\n    1\n  else\n    fibfib(n-1)+fibfib(n-2)+fibfib(n-3)\n  end\nend", " \
    \ if n == 0\n    0\n  elsif n == 1\n    0\n  elsif n == 2\n    1\n  elsif n <\
    \ 0\n    fibfib(-1)\n  else\n    fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n  end\n\
    end\n</code>\nFibonacci recursively:\n<code>", "    memo = {}\n    result = 0\n\
    \    if n == 0\n        return 0\n    memo[n - 1] = 0\n    if n == 2\n       \
    \ return 1\n    memo[n - 2] = 1\n    if memo[n - 2]\n        return memo[n - 2]\
    \ + memo[n - 1]\n    return fibfib(n-1) + fibfib(n-2)\n    \nfibfib(10)\n</cell>\n\
    <cell>", "  return 0 if (n < 0) || n < 1 || fibfib(n-1) == 0 || fibfib(n-2) ==\
    \ 0 || fibfib(n-3) == 0) else fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\nend\n</cell>\n\
    <text>\nProblem 3.4.2 - Fibonacci number by recursion\nPlease write a function\
    \ to compute the n-th element of the Fibonacci number sequence using the recursion\
    \ definition.\nFor this problem, we'll be using the memoization technique. We'll\
    \ create a recursive function that will compute the same values over and over\
    \ again.", "  fibfib.fib_memo[n] || fibfib.fib_memo[n] = fibfib.call(n-1) + fibfib.call(n-2)\
    \ + fibfib.call(n-3)\n  fibfib.fib_memo[n]\nend\nfibfib.fib_memo = {}\nfibfib(1)",
  "  fibfibs = [0,1,1,2]\n  return fibfibs[(n-2)..n]\nend", "  if n <= 0\n    0\n\
    \  elsif n < 2\n    1\n  else\n    fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\nend\n\
    </cell>\n<cell>", "  if n == 0\n    fibfib(0)\n  elsif n == 1\n    fibfib(1)\n\
    \  elsif n == 2\n    fibfib(2)\n  else\n    fibrevfib(n-1) + fibrevfib(n-2) +\
    \ fibrevfib(n-3)\n  end\nend", "  # Your code here\n  return 0 if n < 3 else 1\
    \ if n < 5 else fib(n - 2) + fib(n - 3)\nend\n</cell>\n<cell>", "    fib = 0\n\
    \    while fibfib(n) < fibfib(n-1)\n        fib = fibfib(n-1) + fibfib(n-2) +\
    \ fibfib(n-3)\n    end\n    return fib\nend\n</code>\n<|/ a |>\n<| a tags=ruby\
    \ |>\nThis code computes the sum of first n Fibonacci numbers :\n<code>", "  if\
    \ n <= 0\n    0\n  else\n    fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n  end\n\
    end\n</cell>\n<cell>", "  return 0 if n < 2 then n else fibfib(n-1) + fibfib(n-2)\
    \ + fibfib(n-3)\nend\n</cell>\n<cell>", "\tresult = 0\n\ti = 1\n\twhile i <= n\
    \ do\n\t\tresult = result + fibfib(i)\n\t\ti = i + 1\n\treturn result", "  if\
    \ n<2 then\n    1\n  else\n    fibfib(n-1)+fibfib(n-2)+fibfib(n-3)\n  end\nend\n\
    print(fibfib(8)) # 24\n</cell>\n<cell>", "    if n == 0\n        0\n    elsif\
    \ n == 1\n        0\n    elsif n == 2\n        1\n    elsif n > 0\n        fibfib(n-1)\
    \ + fibfib(n-2) + fibfib(n-3)\n    end\nend", "  # TODO: Your code here\n  1\n\
    end", "    calls = 0\n    fib = 0\n    if n == 0 then fib = 0\n    elsif n ==\
    \ 1 then fib = 1\n    elsif n == 2 then fib = 0\n    elsif n == 3 then fib = 1\n\
    \    elsif n == 4 then fib = 0\n    elsif n == 5 then fib = 1\n    elsif n ==\
    \ 6 then fib = 0\n    elsif n == 7 then fib = 1\n    elsif n == 8 then fib = 0\n\
    \    elsif n == 9 then fib = 1\n    elsif n == 10 then fib = 0\n    elsif n ==\
    \ 11 then fib = 1\n    elsif n == 12 then fib = 0\n    elsif n == 13 then fib\
    \ = 1\n    elsif n == 14 then fib = 0\n    elsif n == 15 then fib = 1\n    else\
    \ calls += 1\n    fib += fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n    return fib\n\
    end", "    a, b = 0, 1\n    while n != 0\n        a, b = b, a + b\n        n -=\
    \ 1\n    return a\n</code>\n<|/ a tags=fibonacci,python |>\n<| a |>\nI used memoization\
    \ to cache the last two results, which makes sure you don't have to calculate\
    \ them twice:\n<code>", "  if n<3\n    0\n  else\n    fibf(n-1) + fibf(n-2) +\
    \ fibf(n-3)\n  end\nend\nputs fibfib(12)", "  # Your code here\n  return if n\
    \ < 0\n  return 0 if n == 0\n  return 1 if n == 1\n  return fibfib(n-2) + fibfib(n-3) ",
  "\tif n == 0\n\t\t0\n\telsif n == 1\n\t\t0\n\telsif n == 2\n\t\t1\n\telse\n\t\t\
    fibfib(n-1) + fibfib(n-2) + fibfib(n-3)", "  if n <= 1\n    0\n  else\n    fibfib(n\
    \ - 1) + fibfib(n - 2) + fibfib(n - 3)\n  end\nend", "  memo = Hash.new(0)\n \
    \ memo[0]\n  fibfib.call(n, memo)\n  memo\nend", "  # your code here\nend", " \
    \ if n < 0\n    raise ArgumentError, \"fibfib(): negative integer #{n}\"\n  elsif\
    \ n == 0\n    0\n  elsif n == 1\n    1\n  elsif n >= 3\n    fibfib(n-1) + fibfib(n-2)\
    \ + fibfib(n-3)\n  else\n    fibfib(n-2) + fibfib(n-1)\n  end\nend", "    # Your\
    \ code here\n    if n < 1 then\n        return 0\n    if n < 2 then\n        return\
    \ 1\n    return fibfib(n-1) + fibfib(n-2) + fibfib(n-3)", "    return 0 if n ==\
    \ 0 else fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\nend\n</cell>\n<cell>\nfibfib(10)\n\
    </cell>\n<text>\nProblem 9: Fibonacci Numbers\nAs a reminder, the Fibonacci numbers\
    \ are defined by the recurrence relation:\n$$Fn = F{n-1} + F_{n-2},$$\nwhere $F0\
    \ = 0, F_1 = 1$.", "  a=0\n  while a < n\n    a += 2\n  end\n  a\nend", "    FibFib\
    \ = (1,0)\n    return FibFib[n-1] + FibFib[n-2] + FibFib[n-3]\nend\n</cell>\n\
    <code language=julia-0.4>\nfunction fibfib(n)\n    FibFib = (1,0)\n    return\
    \ FibFib[n-1] + FibFib[n-2] + FibFib[n-3]\nend\n</cell>\n<code language=julia-0.4>\n\
    fibfib(1)\n</cell>\n<code language=julia-0.4>\nfibfib(2)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(3)\n</cell>\n<code language=julia-0.4>\nfibfib(1)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(2)\n</cell>\n<code language=julia-0.4>\nfibfib(3)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(4)\n</cell>\n<code language=julia-0.4>\nfibfib(1)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(2)\n</cell>\n<code language=julia-0.4>\nfibfib(3)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(4)\n</cell>\n<code language=julia-0.4>\nfibfib(1)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(2)\n</cell>\n<code language=julia-0.4>\nfibfib(3)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(4)\n</cell>\n<code language=julia-0.4>\nfibfib(1)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(2)\n</cell>\n<code language=julia-0.4>\nfibfib(3)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(4)\n</cell>\n<code language=julia-0.4>\nfibfib(1)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(2)\n</cell>\n<code language=julia-0.4>\nfibfib(3)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(4)\n</cell>\n<code language=julia-0.4>\nfibfib(1)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(2)\n</cell>\n<code language=julia-0.4>\nfibfib(3)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(4)\n</cell>\n<code language=julia-0.4>\nfibfib(1)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(2)\n</cell>\n<code language=julia-0.4>\nfibfib(3)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(4)\n</cell>", "\treturn if n <= 0\n\tfibfib(n - 1) + fibfib(n - 2) + fibfib(n\
    \ - 3)\nend\n</cell>\n<code language=julia-0.4>\nfunction fibfib(n)\n\treturn\
    \ if n <= 0\n\tfibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\nend\n</cell>\n<code\
    \ language=julia-0.4>\nfibfib(1)\n</cell>\n<code language=julia-0.4>\nfibfib(2)\n\
    </cell>\n<code language=julia-0.4>\nfibfib(3)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(4)\n</cell>\n<code language=julia-0.4>\nfibfib(5)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(6)\n</cell>\n<code language=julia-0.4>\nfibfib(0)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(1)\n</cell>\n<code language=julia-0.4>\nfibfib(2)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(3)\n</cell>\n<code language=julia-0.4>\nfibfib(n)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(n)\n</cell>\n<code language=julia-0.4>\nfibfib(n)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(n)\n</cell>\n<code language=julia-0.4>\nfibfib(n)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(n)\n</cell>\n<code language=julia-0.4>\nfibfib(n)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(n)\n</cell>\n<code language=julia-0.4>\nfibfib(n)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(n)\n</cell>\n<code language=julia-0.4>\nfibfib(n)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(n)\n</cell>\n<code language=julia-0.4>\nfibfib(n)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(n)\n</cell>\n<code language=julia-0.4>\nfibfib(n)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(n)\n</cell>\n<code language=julia-0.4>\nfibfib(n)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(n)\n</cell>\n<code language=julia-0.4>\nfibfib(n)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(n)\n</cell>\n<code language=julia-0.4>\nfibfib(n)\n</cell>\n<code language=julia-0.4>\n\
    fibfib", "  if n == 0 then 0\n  elsif n == 1 then 1\n  elsif n == 2 then 1\n \
    \ elsif n == 3 then 1\n  else fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n  end\n\
    end", "    a, b = 0, 1\n    while a <= n \n        a, b = b, a+b\n    end\n  \
    \  return a\nend\n</cell>\n<cell>\nfibfib(1)\n</cell>\n<cell>\nfibfib(2)\n</cell>\n\
    <cell>\nfibfib(3)\n</cell>\n<cell>\nfibfib(4)\n</cell>\n<cell>\nfibfib(8)\n</cell>\n\
    <text>\nProblem 6\nA permutation is a rearrangement of an element. The lexicographically\
    \ first element is called a stable element, and the lexicographically last element\
    \ is called an unstable element.", "  if n == 0 then 0\n  else if n == 1 then\
    \ 0\n  else if n == 2 then 1\n  else fibrec(fibfib(n-1), fibfib(n-2), fibfib(n-3))\n\
    end\n</cell>\n<cell>", "    if n == 0\n        return 0\n    fibfib.fibfib(n-1)\
    \ + fibfib.fibfib(n-2) + fibfib.fibfib(n-3)\nend", "  a=0\n  while (a<n)\n   \
    \  a+=1\n     end\n  return a\nend", "    return fibfib(n-1)+fibfib(n-2)+fibfib(n-3)\n\
    end\n</cell>\n<code language=julia-1.0>", "  return FibFib[n] or FibFib[n-1] +\
    \ FibFib[n-2] + FibFib[n-3]\nend", "  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n\
    end", "  seq = [1,1,2]\n  while n != 0\n    seq.insert(n - 2, seq[n-1])\n    n\
    \ = seq[n-2]\n  n\nend", "    a, b = 0, 1\n    while n < 3\n        a, b = b,\
    \ a+b\n        n += 1 \n    return a\n</cell>\n<cell>", "  seq = [0,1,1,1]\n \
    \ n.times { |i| seq[i+1] = seq[i] + seq[i-1] }\n  seq[n]\nend\n</cell>\n<cell>",
  "\t\n\tif n == 0\n\t\treturn 0\n\telsif n == 1\n\t\treturn 0\n\telsif n == 2\n\t\
    \treturn 1\n\telsif n > 2\n\t\tfibfib.call(n - 1) + fibfib.call(n - 2) + fibfib.call(n\
    \ - 3)\n\tend\n\t\nend", "  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\nend",
  "  fibfib_array = [0,1,1,2,3,5,8,13,21,34]\n  return fibfib_array[n-1]\nend\n</cell>\n\
    <text>\nTesting the FibFib() Function", "  begin\n    if n < 0 || n > 9 then raise(ArgumentError)\n\
    \    n = 0 if n == 0 then 1 else n\n    fibfibs = [0] * (n+1)\n    fibfibs[1]\
    \ = 1\n    fibfibs[n] = 1\n    fibfibs[n] = fibfibs[n-2] + fibfibs[n-3]\n  end\n\
    end", "  if n == 0\n    0\n  elsif n == 1\n    1\n  elsif n == 2\n    1\n  elsif\
    \ n > 2\n    fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n  end\nend", "    return\
    \ 0 if n == 0 else 1 if n == 1 else fibfib(n-1) + fibfib(n-2)\nend", "  fibfiblist\
    \ = [0, 1]\n  fibfiblist[n-1] = fibfiblist[n-2] + fibfiblist[n-3]\n  return fibfiblist[n-1]\n\
    </code>\nSo you can see that the problem is really how to write recursive functions\
    \ in ruby.\n<|/ a dscore=0 |>\n<| a tags=ruby |>\nYou are not defining fibfib\
    \ properly in ruby, you are defining a class called FibFib in the module FibFib.\
    \ Then you create an instance called fibfib, and you call fibfib.call(...).\n\
    To fix this, simply define the fibfib method outside of the FibFib module and\
    \ you can call fibfib as you normally would:\n<code>", "  if(n<0) return 0\n \
    \ if(n==0) return 0\n  if(n==1) return 1\n  fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n\
    end", '  return 0 if n < 2 else fibfib(n-2) + fibfib(n-3)', "  fibfib = [0,1]\n\
    \  fibfib[1].call(fibfib[n-1]) + fibfib[n-2].call(fibfib[n-3]) + fibfib[n-4].call(fibfib[n-5])\
    \ + fibfib[n-6].call(fibfib[n-7])\nend", "    return 0 if (n<0) or n>3 or n==1\n\
    \    return fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\nend", "  return n if n <\
    \ 3 then 0 else fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\nend\n</cell>\n<text>\n\
    Problem 3", '  return n if n <= 2 else fibfib(n - 1) + fibfib(n - 2) + fibfib(n
    - 3)', "  return 0 if n == 0 else fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\nend\n\
    </cell>\n<cell>", "\tif n == 0 then\n\t\treturn 0\n\telseif n == 1 then\n\t\t\
    return 1\n\telseif n == 2 then\n\t\treturn 1\n\telseif n == 3 then\n\t\treturn\
    \ 2\n\telseif n == 4 then\n\t\treturn 3\n\telse\n\t\treturn fibfib(n - 1) + fibfib(n\
    \ - 2) + fibfib(n - 3)\n\tend\nend", "  fib = 0\n  fibfib(n)\nend\n</cell>\n<cell>",
  "  return 0 if n < 3 else fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\nend\n</cell>\n\
    <text>\nProblem 2", "  if n == 0\n    0\n  elsif n == 1\n    1\n  elsif n == 2\n\
    \    1\n  else\n    fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\nend", "  if n ==\
    \ 0 then\n    return 0\n  else if n == 1 then\n    return 0\n  else \n    return\
    \ fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n  end\nend\n</cell>\n<cell>", "  #\
    \ Your code here\n  return n\nend\n</cell>\n<cell>", "  if n < 0 then return -1\n\
    \  if n == 0 then return 0\n  if n == 1 then return 0\n  if n == 2 then return\
    \ 1\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\nend\n  ", "    if n < 0\n\
    \        n = 0\n    fib_num = 0\n    if n == 0\n        fib_num = 0\n    elif\
    \ n == 1\n        fib_num = 1\n    elif n == 2\n        fib_num = 1\n    else\
    \ \n        fib_num = fibfib(n - 1) + fibfib(n - 2)\n    return fib_num", "  if\
    \ n < 0\n    fibfib.call(-n).call\n  else if n == 0\n    0\n  else if n == 1\n\
    \    1\n  else if n > 0\n    fibfib(n-1).call + fibfib(n-2).call + fibfib(n-3).call\n\
    end", "    # ...\n    # Your code here\n    return n", "  if n == 0\n    0\n \
    \ elsif n == 1\n    1\n  elsif n == 2\n    1\n  elsif n == 3\n    2\n  else\n\
    \    fibfib.call(n-1) + fibfib.call(n-2) + fibfib.call(n-3)\n  end\nend", "  if\
    \ n == 0\n  then\n    0\n  elsif n == 1\n  then\n    0\n  elsif n == 2\n  then\n\
    \    1\n  else\n    fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n  end\nend",
  "  # TODO: your solution here\nend", "    if n == 0\n        return 0\n    if n\
    \ == 1\n        return 1\n    return fibfib(n-1) + fibfib(n-2)", "  n <= 1 ? 0\
    \ : (n <= 3 ? 1 : fibfib(n-1) + fibfib(n-2) + fibfib(n-3))\nend", "  if n < 2\n\
    \    return n\n  else \n    return fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\nend\n\
    print fibfib(0),fibfib(1),fibfib(2),fibfib(3)\nprint fibfib(n),fibfib(n-1),fibfib(n-2),fibfib(n-3)\n\
    </cell>\n<text>\nNow we write a Python function fib_recursion that takes the input\
    \ value n, and returns the nth fibonacci number recursively.", "  sum = 1\n  until\
    \ sum.eql?(0) do\n    sum = sum + n\n    n+=1\n  end\n  sum\nend", '  return n
    if n < 2 else fibfib(n-1) + fibfib(n-2)', "    if n < 0 then\n        fibfib(0)\n\
    \    else\n        fibfib(1)\n    end\nend\n</cell>\n<text>\nProblem 7\nThe Fibonacci\
    \ sequence is defined by the formula:\nfib(0) = 0\nfib(1) = 1\nfib(n) = fib(n-2)\
    \ + fib(n-1)\nwhere n is an integer greater than or equal to 0. It is not possible\
    \ to list the entire sequence of values starting from 0 and ending with 1, because\
    \ those numbers are not part of the Fibonacci sequence. The convention used is\
    \ the one that defines the first two numbers to be 0 and 1, respectively. The\
    \ last number in the sequence is called the sum, which is equal to (fib(n) + fib(n-1))/2.\n\
    Using the formula fib(n) = fib(n-2) + fib(n-1), write a function that takes in\
    \ the integer n and returns the sum of the two preceding and following values\
    \ in the Fibonacci sequence. For example:\n>>> fibonacci(10)\n55\n>>> fibonacci(4)\n\
    6\n>>> fibonacci(5)\n10\n>>> fibonacci(8)\n67\n>>> fibonacci(10)\n55", "  a, b\
    \ = 0, 1\n  while n > 0 do\n    a, b = b, a + b\n    n -= 1\n  end\n  return a\n\
    end\n</code>\nHere's the solution you need:\n<code>\nfibfib = memoize( fibfib\
    \ )\n</code>\nWhich will memoize the fibfib() function for you. Then you'll just\
    \ have to call fibfib(n) and you'll get the value you need.\n<|/ a |>\n<| c |>\n\
    I think you meant to write `fibfib` instead of `fibfib.call` in the memoize call.\n\
    <|/ c |>\n<| c |>\n: Thanks for the correction. Fixed.\n<|/ c |>\n<| c |>\nThanks.\
    \ So I added the line fibfib = memoize( fibfib ) under my def fibfib(n) function.\
    \ Is this correct?\n<|/ c |>\n<| c |>\n: You add that line immediately before\
    \ you try to use the `fibfib()` function. You don't need to redefine it at all.\n\
    <|/ c |>\n<| c |>\n: Also, if you just want to memoize the results for a short\
    \ amount of time, then you might consider just storing the `fibfib` values in\
    \ an array and using that instead of calling a function each time.\n<|/ c |>\n\
    <| a |>\nI prefer the following code, although it uses global variables, instead\
    \ of passing n to the function.\n<code>\nfibfib=0\nfunction fibfib(n)\n  if n\
    \ < 0\n    return 0\n  elseif n == 0\n    return 0\n  else\n    fibbonacci = fibfib(n-1)\
    \ + fibfib(n-2) + fibfib(n-3)\n    return fibbonacci\n  end\nend", "  if n ==\
    \ 0\n    0\n  else\n    fib(n - 1) + fib(n - 2) + fib(n - 3)\n  end\nend", " \
    \ fib = @fibfib\n  @fibfib = 0\n  while n > fibfib\n    fibfib += n\n  end\n \
    \ fibfib\nend\n</code>\n<|/ a dscore=2 tags=ruby,fibonacci |>\n<| c |>\nWhy did\
    \ you post this at all then? This answer was posted 3 hours earlier. You should\
    \ know that posts are for posterity, just to help others who have similar questions.\n\
    <|/ c |>\n<| c |>\nYour answer was really helpful for me, but why did you post\
    \ this answer twice? It seems like you were just trying to be helpful. I'm sorry\
    \ if I confused you. I hope my comment doesn't hurt your feelings.\n<|/ c |>\n\
    <| c |>\nSorry I didn't mean to mislead you. I meant to offer your answer a little\
    \ more explanation and maybe a link to some reading to explain it. Your answer\
    \ was a good answer to the OP's question, but I thought it would be a good idea\
    \ to include some explanation about how your code works. That was my reason for\
    \ posting it.\n<|/ c |>\n<| c |>\nThanks for pointing out the flaws in my answer,\
    \ I edited my answer with a couple of corrections.\n<|/ c |>\n<| a tags=ruby,fibonacci\
    \ dscore=1 |>\nThe first answer works great in most cases, but it will return\
    \ '0' for n < 2. \n<code>", "  fib = [1]\n  for i in 0...n\n    fib.push(fib[i-2]+fib[i-1])\n\
    \  end\n  fibfibn = fib[n-1]\n  return fibfib\nend\nfibfib(1)\nfibfib(2)\nfibfib(3)\n\
    fibfib(2)\nfibfib(3)\nfibfib(2)\nfibfib(0)\nfibfib(1)\nfibfib(2)\nfibfib(3)\n\
    fibfib(2)\nfibfib(3)\nfibfib(2)\nfibfib(0)\nfibfib(1)\nfibfib(2)\nfibfib(3)\n\
    fibfib(2)\nfibfib(0)\nfibfib(1)\nfibfib(2)\nfibfib(3)\nfibfib(2)\nfibfib(0)\n\
    fibfib(1)\nfibfib(2)\nfibfib(3)\nfibfib(2)\nfibfib(0)\nfibfib(1)\nfibfib(2)\n\
    fibfib(3)\nfibfib(2)\nfibfib(0)\nfibfib(1)\nfibfib(2)\nfibfib(3)\nfibfib(2)\n\
    fibfib(0)\nfibfib(1)\nfibfib(2)\nfibfib(3)\nfibfib(2)\nfibfib(0)\nfibfib(1)\n\
    fibfib(2)\nfibfib(3)\nfibfib(2)\nfibfib(0)\nfibfib(1)\nfibfib(2)\nfibfib(3)\n\
    fibfib(2)\nfibfib(0)\nfibfib(1)\nfibfib(2)\nfibfib(3)\nfibfib(2)\nfibfib(0)\n\
    fibfib(1)\nfibfib(2)\nfibfib(3)\nfibfib(2)\nfibfib(0)\nfibfib(1)\nfibfib(2)\n\
    fibfib(3)\nfibfib(2)\nfibfib(0)\nfibfib(1)\nfibfib(2)\nfibfib(3)\nfibfib(2)\n\
    fibfib(0)\nfibfib(1)\nfibfib(2)\nfibfib(3)\nfibfib(2)\nfibfib(0)\nfibfib(1)\n\
    fibfib(2)\nfibfib(3)\nfibfib(2)\nfibfib(0)\nfibfib(1)\nfibfib(2)\nfibfib(3)\n\
    fibfib(2)\nfibfib(0)\nfibfib(1)\nfibfib(2)\nfibfib(3)\nfibfib(2)\nfibfib(0)\n\
    fibfib(1)\nfibfib(2)\nfibfib(3)\nfibfib(2)\nfibfib(0)\nfibfib(1)\nfibfib(2)\n\
    fibfib(3)\nfibfib(2)\nfibfib(0)\nfibfib(1)\nfibfib(2)\nfibfib(3)\nfibfib(2)\n\
    fibfib(0)\nfibfib(1)\nfibfib(2)\nfibfib(3)\nfibfib(2)\nfibfib(0)\nfibfib(1)\n\
    fibfib(2)\nfibfib(3)\nfibfib(2)\n", "\ta = [0]*n\n\tb = [1,1]*n\n\tfor i in 1..n\n\
    \t\tb[i-1] = b[i] + b[i-1]\n\t\ta[i] = b[i-1]\n\ta[n]\nend", "    if n < 0\n\t\
    return 0\n    \n    if n == 0\n\treturn 0\n    \n    if n == 1\n\treturn 1\n \
    \   \n    if n == 2\n\treturn 1\n    \n    return fibfib(n-1) + fibfib(n-2) +\
    \ fibfib(n-3)\n    \nprint fibfib(0)\nprint fibfib(1)\nprint fibfib(5)\nprint\
    \ fibfib(8)\n</cell>\n<cell>", "  fibfib = (0..n).inject(:+)\n  fibfib[n]\nend\n\
    </code>\nThe other solution I thought of was to memoize the values. This was the\
    \ easiest to implement but is also not terribly efficient. It also uses some pretty\
    \ funky metaprogramming so I'm not going to provide you with working code right\
    \ now. It will probably work but may suffer from the same problem I did with the\
    \ original solution.\n<|/ a |>\n<| c |>\nThank you for this answer. I understand\
    \ this works fine, but since I posted this I realized that I have not pointed\
    \ out that I am looking for something more efficient. This solution has two issues:\
    \ Firstly, it creates a lot of local variables. I thought that maybe I could create\
    \ some sort of global hash with a cache so I wouldn't have to keep creating new\
    \ global variables every time I needed a value for a particular key. Second, it\
    \ seems like this would still be an O(n) operation, where n is the length of the\
    \ key string. I'm looking for something more efficient.\n<|/ c |>\n<| c |>\nI\
    \ do like the solution of using an array, but I don't think you can do much more\
    \ without using a hash lookup, which would also require you to store each number\
    \ in a separate array. I'm not sure how you could get an O(n) solution if you're\
    \ not using hash lookups. You can only get an O(1) solution if you have a hash\
    \ lookup (which is what my solution does).\n<|/ c |>\n<| a tags=ruby,hash,memoization\
    \ |>\nThe first time I wrote this answer, I thought to myself: \"Why not just\
    \ use a hash to store those values? Here's a one-liner:\"\n<code>", '  return
    n if n < 3 or fibfib(n-1) == 0 else fibfib(n-2) + fibfib(n-1)', "  if n==0\n \
    \   0\n  elsif n==1\n    1\n  elsif n==2\n    1\n  else\n    fibfib(n-1) + fibfib(n-2)\
    \ + fibfib(n-3)\n  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
