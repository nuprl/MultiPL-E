name: HumanEval_147_get_max_triples
language: rb
prompt: "# You are given a positive integer n. You have to create an integer array\
  \ a of length n.\n# For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i\
  \ - i + 1.\n# Return the number of triples (a[i], a[j], a[k]) of a where i < j <\
  \ k, \n# and a[i] + a[j] + a[k] is a multiple of 3.\n# Example :\n# >>> get_max_triples.call(5)\n\
  # 1\n# Explanation: \n# a = [1, 3, 7, 13, 21]\n# The only valid triple is (1, 7,\
  \ 13).\ndef get_max_triples(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_max_triples\n\
  \    candidate = method(:get_max_triples)\n    assert_equal(1, candidate.call(5))\n\
  \    assert_equal(4, candidate.call(6))\n    assert_equal(36, candidate.call(10))\n\
  \    assert_equal(53361, candidate.call(100))\n  end\nend\n"
completions: ["  a = (1..n).to_a\n  sum = 0\n  \n  a.each do |i|\n    sum = sum +\
    \ (a[i] * i - i + 1)\n  end\n  \n  return sum % 3 == 0 ? n : nil\nend\n</cell>\n\
    <code language=julia-1.6>\n@assert get_max_triples(2) == 1\n@assert get_max_triples(3)\
    \ == 2\n@assert get_max_triples(5) == 3\n@assert get_max_triples(6) == 4\n@assert\
    \ get_max_triples(7) == 6\n@assert get_max_triples(8) == 3\n@assert get_max_triples(10)\
    \ == 5\n@assert get_max_triples(11) == 7\n@assert get_max_triples(12) == 9\n@assert\
    \ get_max_triples(13) == 11\n@assert get_max_triples(14) == 13\n@assert get_max_triples(15)\
    \ == 15\n@assert get_max_triples(16) == nil\n</cell>\n<text>\nPart III - Combinatorics",
  "  a = [1, 2, 3, 4, 5, 6, 7]\n  count = 0\n  for i in (1..n)\n    count = count\
    \ + a.count {|i| (i + j + k) <= n}\n    a.delete(i..a.count)\n  end\n  count\n\
    end\n</code>\n<|/ a tags=ruby,arrays,math |>\n<| c |>\nI tried to run your algorithm\
    \ but it's giving me `wrong answer`  on [this test case](http://rubyfiddle.com/riddles/9252/0).\
    \ Can you help me with that?\n<|/ c |>\n<| c |>\nIt doesn't work. Look at the\
    \ example at the bottom of the answer. [Here is your fiddle](http://rubyfiddle.com/riddles/9252/1)\n\
    <|/ c |>\n<| a dscore=1 |>\nIn case anyone needs the answer in Python, here is\
    \ my version:\n<code>", "  count = 0\n  result = []\n  a.push(n)\n  result = []\n\
    \  for i in 1..n\n    j = a.shift\n    if i % j == 0 && j > 0\n      count +=\
    \ 1\n      result.push([i, j,n])\n    end\n  end\n  \n  return count\nend\n</code>\n\
    <|/ a tags=ruby,loops |>\n<| c |>\nI like the `result` array being re-initialized\
    \ on every call\n<|/ c |>\n<| a tags=ruby,loops |>\n<code>", "  a = Array.new(n)\n\
    \  for i in 0...n\n    k = i\n    j = i\n    while j >= 1\n      j -= 1\n    \
    \  if j > k\n        if a[k] + a[j] + a[j] == i * i\n          puts a[k], a[j],\
    \ a[j]\n        end\n      end\n    end\n  end\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nThanks, that is really great and I learned new things\n<|/ c |>\n\
    <| c |>\nNo problem :) If it works please accept the answer so others know it\
    \ works as well.\n<|/ c |>\n<| c |>\nI didn't know that was possible, I'm new\
    \ to StackOverflow and still learning how to accept answers. Thanks for the help\n\
    <|/ c |>\n<| c |>\nNo worries at all. The acceptance is also done by clicking\
    \ the checkmark next to an answer :)\n<|/ c |>\n<| c |>\n, Your answer is very\
    \ helpful and it is the only solution that I understand. Although it is easy to\
    \ understand and I still don't know how it works. But thanks a lot\n<|/ c |>\n\
    <| a tags=ruby |>\nHere are a few more answers. \nThis can be done in O(n) time.\n\
    <code>", "    \n    answer = []\n    \n    if n <= 1\n        answer = 0\n   \
    \ else \n        answer.push(n.times.map {|i| i * i - i + 1 })\n        \n   \
    \     answer.max_by {|i| i[answer.length-1]}\n    \n    return answer.length\n\
    end\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| c |>\nI do not see how this code\
    \ returns \"the number of triples (a[i], a[j], a[k]) of a where i < j < k\", but\
    \ your code only returns \"the largest number\". Is that a typo? Your code is\
    \ certainly more concise and efficient, but I fail to see why your algorithm produces\
    \ those results.\n<|/ c |>\n<| c |>\nI see what you meant. My algorithm is incorrect.\
    \ I edited my post to include an example that shows why my algorithm does not\
    \ work.\n<|/ c |>\n<| c |>\nWhat is the purpose of `answer = []`?\n<|/ c |>\n\
    <| c |>\nBecause I need to store the values of the triples. Otherwise, I cannot\
    \ access the value by accessing the last index of the array. For example, when\
    \ I do `a[0]` it returns \"13\", not \"1\". I also need to store the values if\
    \ I do `a.length -1` since I need the index to access the value at `a[index]`\n\
    <|/ c |>\n<| a dscore=0 |>\nA solution in Ruby 1.8.7 using Array#permutation and\
    \ a generator (which generates triples one at a time):\n<code>\nrequire 'generator'",
  "    hash = {}\n    for i in 1..n\n      hash[i] = false\n    end\n    count = 0\n\
    \    for i in 1..n\n      hash[i] = true\n      if a[i] > 0 then\n        count\
    \ += 1\n        j = i + 1\n        while j <=n\n          if hash[j] == true then\n\
    \            hash[j] = false\n            count += 1\n            j = j + 1\n\
    \          else\n            break\n          end\n        end\n      end\n  \
    \  end\n    return count\nend", "  a = []\n  for i in 1..n\n    a.push(i)\n  end\n\
    \  a.each_index do |i|\n    if i < a.length - 1\n      j = i + 1\n      while\
    \ j < a.length\n        k = j + 1\n        while k < a.length\n          if a[i]\
    \ + a[j] + a[k] % 3 == 0\n            return 1 + 2*(a.length-i+1)\n          end\n\
    \          k += 1\n        end\n        j += 1\n      end\n    end\n  end\n  return\
    \ -1\nend", "    tri = 0\n    a.each { |i| tri += (i*i)-i+1 }\n    return tri\n\
    end", "  array.new(:int, n)\n  3.times.each do\n    array[0,0] = 1\n  end\n  array.each_index\
    \ do |i|\n    array[i,i] = 2\n  end\n  array[0,1] = 3\n  array.each_with_index\
    \ do |x, i|\n    array[i+1,i] = 4\n  end\n  array.each_with_index do |x, i|\n\
    \    array[i+2,i] = 1\n  end\n  array.each_with_index do |x, i|\n    array[i+3,i]\
    \ = 1\n  end\n  array.each_with_index do |x, i|\n    array[i+4,i] = 1\n  end\n\
    \  array[0,2] = 5\n  array.each_with_index do |x, i|\n    array[i+1,i+1] = 6\n\
    \  end\n  array.each_with_index do |x, i|\n    array[i+2,i+2] = 2\n  end\n  array.each_with_index\
    \ do |x, i|\n    array[i+3,i+3] = 2\n  end\n  array.each_with_index do |x, i|\n\
    \    array[i+4,i+4] = 2\n  end\n  array.each_with_index do |x, i|\n    array[i+5,i]\
    \ = 1\n  end\n  array.each_with_index do |x, i|\n    array[i+6,i] = 1\n  end\n\
    \  array.each_with_index do |x, i|\n    array[i+7,i] = 1\n  end\n  array.each_with_index\
    \ do |x, i|\n    array[i+8,i] = 1\n  end\n  array[0,3] = 7\n  array.each_with_index\
    \ do |x, i|\n    array[i+1,i+2] = 8\n  end\n  array.each_with_index do |x, i|\n\
    \    array[i+2,i+3] = 8\n  end\n  array.each_with_index do |x, i|\n    array[i+3,i+4]\
    \ = 8\n  end\n  array.each_with_index do |x, i|\n    array[i+4,i+5] = 8\n  end\n\
    \  array.each_with_index do |x, i|\n    array[i+5,i+6] = 8\n  end\n  array.each_with_index\
    \ do |x, i|\n    array[i+6,i+7] = 8\n  end\n  array.each_with_index do |x, i|\n\
    \    array[i+7,i+8] = 8\n  end\n  array.each_with_index do |x, i|\n    array[i+8,i]\
    \ = 8\n  end\n  array[0,4] = 9\n  array.each_with_index do |x, i|\n    array[i+1,i+2]\
    \ = 10\n  end\n  array.each_with_index do |x, i|\n", "    a.clear\n    a[0] =\
    \ 1\n    \n    for i in 1..n\n        a[i] = i * i - i + 1\n    end\n    \n  \
    \  a.sort\n    \n    for i in 1..n-1\n        if a[i] > a[i+1]\n            if\
    \ a[i] > a[i-1]\n                return a[i] + a[i+1] + a[i-1]\n            else\n\
    \                return a[i] + a[i+1]\n            end\n        else\n       \
    \     if a[i] > a[i-1]\n                return a[i] + a[i-1] + a[i+1]\n      \
    \      else\n                return a[i] + a[i-1]\n            end\n        end\n\
    \    end\nend", "  i = 0\n  j = 1\n  k = 2\n  a = []\n  while i < n and j < n\
    \ and k < n do\n    a.push i*i - i + 1\n    i = i + 1\n    j = j + 1\n    k =\
    \ k + 1\n  end\n  return a.count{|i| i + j + k == 3 && a.index(i)}\nend", "  a\
    \ = []\n  for i in range(1, n)\n    a.push(0); \n    \n  for i in 1..n\n    for\
    \ j in 1..n\n      if a[i] + a[j] >= a[n]\n        a.push(3 * a[i] + a[j] + a[n]);\
    \ \n      end\n    end\n  end\n  \n  a.length\nend", "  a = [1] * n\n  i = 2\n\
    \  while (i * i - i + 1) < n\n    a[i] = i * i - i + 1\n    i += 1\n  while i\
    \ < n\n    a[i] += a[i + 1]\n    i += 1\n  return a.find {|a| a % 3 == 0}\nend\n\
    </code>\nThe test passes\n<code>\nputs get_max_triples.call(5)", "  i = 0\n  a\
    \ = []\n  loop do\n    i += 1 \n    i += 1\n    a.push i\n    break if a.length\
    \ >= n\n  end\n  loop do\n    i += 1\n    i += 1\n    a.push i\n    break if a.length\
    \ >= n\n  end\n  a.each do |i|\n    i = i\n    loop do\n      i += 1 \n      i\
    \ += 1\n      a.push i\n      break if a.length >= n\n    end\n    loop do\n \
    \     i += 1\n      i += 1\n      a.push i\n      break if a.length >= n\n   \
    \ end\n  end\n  a[0].to_i * a[0].to_i + a[1].to_i * a[1].to_i + a[2].to_i * a[2].to_i\n\
    end", "  a = Array.new(n)\n  a.each_index do |i|\n    i += 1\n    j =  i + 1\n\
    \    k = i + 1\n    while j <  n\n      j += 1\n      k+=1\n      while k < n\
    \ \n        k+=1\n      end\n    end\n    break if a.uniq.length == n\n    break\
    \ if a[i-1] + a[j-1] + a[k-1] % 3 == 0\n  end\n  a\nend\n</code>\n<|/ a |>\n<|\
    \ a |>\nHere's one iterative solution that checks each triple; it avoids redundant\
    \ checks:\n<code>", "  a=[]\n  for i in 1..n\n    a.push(i * i - i + 1)\n  a.sort\n\
    \  return a.count{|a| (a%3)==0}\nend", '  return 0 # your code', "    n.times\
    \ do |i|\n        a.push(i * i - i + 1)\n    end\n    a.uniq.length.times do |i|\n\
    \        a.each_index { |j| a.delete([i..j].min) }\n    end\nend", "  max_triples\
    \ = 0\n  array = []\n  1.upto(n) do |i|\n    array.push(i)\n  end", "  a = []\n\
    \  a.length(n)\n  a.each_with_index do |i,index|\n    a.each_with_index do |j,index2|\n\
    \      a.each_with_index do |k,index3|\n        a.each_with_index do |m,index4|\n\
    \          break if index+index2+index3 == index4\n          break if index+index2+index3\
    \ == index\n          break if index+index2+index3 == index2\n          a.delete(m)\n\
    \          break if index+index2+index3 == index3\n        end\n      end\n  \
    \  end\n  end\n  a.length\nend", "  if n < 1 then return 0 end\n  a = (1..n).to_a\n\
    \  a.each do |i|\n    a, b = a.next.next, a.next.next.next\n    a[i] > b and a[j]\
    \ > b and a[k] > b and a[i] < a[j] and a[i] < a[k] and a[j] < a[k]\n  end\n  return\
    \ a.size\nend\n</cell>\n<code language=julia-0.4>", "  a = Array.new(n) \n  a[1]\
    \ = 1\n  (0..(n-1)-1).each {|i|\n    a[i] = i * (i - 1) + 1\n    puts \"a[#{i+1}]\
    \ = #{a[i]}\"\n  }", "  a = [1,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]\n\
    \  a.each_with_index { |i, index| a[index] += i ** 2 }\n  a.each_with_index {\
    \ |i, index| a[index] += i ** 2 }\n  a.each_with_index { |i, index| a[index] +=\
    \ i ** 2 }\n  a.each_with_index { |i, index| a[index] += i ** 2 }\n  a.each_with_index\
    \ { |i, index| a[index] += i ** 2 }\n  a.each_with_index { |i, index| a[index]\
    \ += i ** 2 }\n  a.each_with_index { |i, index| a[index] += i ** 2 }\n  a.each_with_index\
    \ { |i, index| a[index] += i ** 2 }\n  a.each_with_index { |i, index| a[index]\
    \ += i ** 2 }\n  a.each_with_index { |i, index| a[index] += i ** 2 }\n  a.each_with_index\
    \ { |i, index| a[index] += i ** 2 }\n  a.each_with_index { |i, index| a[index]\
    \ += i ** 2 }\n  a.each_with_index { |i, index| a[index] += i ** 2 }\n  a.each_with_index\
    \ { |i, index| a[index] += i ** 2 }\n  a.each_with_index { |i, index| a[index]\
    \ += i ** 2 }\n  a.each_with_index { |i, index| a[index] += i ** 2 }\n  a.each_with_index\
    \ { |i, index| a[index] += i ** 2 }\n  a.each_with_index { |i, index| a[index]\
    \ += i ** 2 }\n  a.each_with_index { |i, index| a[index] += i ** 2 }\n  a.each_with_index\
    \ { |i, index| a[index] += i ** 2 }\n  a.each_with_index { |i, index| a[index]\
    \ += i ** 2 }\n  a.each_with_index { |i, index| a[index] += i ** 2 }\n  a.each_with_index\
    \ { |i, index| a[index] += i ** 2 }\n  a.each_with_index { |i, index| a[index]\
    \ += i ** 2 }\n  a.each_with_index { |i, index| a[index] += ", "  a = (0..(n-1)).to_a\n\
    \  a.each_index do |i|\n    a.each_index do |j|\n      a.each_index do |k|\n \
    \       return i if a[i] < a[j] < a[k] && a[i] + a[j] + a[k] == 3\n      end\n\
    \    end\n  end\n  return 0\nend\n</code>\n<|/ a dscore=3 tags=ruby |>\n<| c |>\n\
    Am I missing something or is the inner `a.each_index` redundant if you use `each_with_index`?\
    \ Also, the last return should be `return i if a[i] < a[j] < a[k]`, because `a[k]\
    \ == 3` only happens when the sum is 3.\n<|/ c |>\n<| c |>\n`each_with_index`\
    \ won't work if you're trying to find the highest sum when you have multiple numbers\
    \ to sum.\n<|/ c |>\n<| c |>\nThanks for pointing it out. Yeah, `each_with_index`\
    \ is redundant, and I wasn't paying attention to that part. I actually took that\
    \ line out while I was trying something to find the highest sum.\n<|/ c |>\n<|\
    \ c |>\nI actually wanted to find all triples. I will update the question. Thanks\
    \ again!\n<|/ c |>\n<| a tags=ruby dscore=3 |>\nTo get all triples that sum up\
    \ to a multiple of 3 or higher, you could:", "  a = []\n  a.length(n)\n  for i\
    \ in 1..n\n    a.push(0 * i - i + 1)\n  a.sort\n  i = 0\n  j = 1\n  k = 2\n  while\
    \ i < n and j < n and k < 3\n    if a[i] + a[j] + a[k] = 3\n      break\n    i\
    \ += 1\n    j += 1\n    k += 1\n  end\n  puts k.to_s + 1\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nThe question is about Ruby, not Python.\n<|/ c |>\n<| c |>\n- That's\
    \ true. I didn't think about the tag at the time. I updated my answer accordingly.\n\
    <|/ c |>\n<| a dscore=2 tags=ruby,python,algorithm |>\n<code>\n>>> def get_max_triples(n):\n\
    ...     return 3 if n*(n-1)/2==(n+1)*(3+n)\n...     return 1 + get_max_triples(n-1)\
    \ if n>1\n...     return 0\n... \n>>> get_max_triples(5)\n3\n</code>\n<|/ a |>\n\
    <| a tags=ruby,python,algorithm |>\n<code>", "  a = []\n  i = 0\n  while i < n\n\
    \    a.push i*i-i+1\n    i += 1\n  result = 0\n  i = 0\n  while i < n-1\n    j\
    \ = i+1\n    while j < n\n      k = j+1\n      while k < n\n        if a[i] <\
    \ a[j] && a[j] < a[k]\n          result = result + 1\n        k += 1\n      j\
    \ += 1\n    i += 1\n  end\n  result\nend\nputs get_max_triples.call(5)\nputs get_max_triples.call(20)\n\
    puts get_max_triples.call(100000)", "  a = Array.new(n) \n  1.upto(n){|i| a[i]\
    \ = i * i - i + 1\n  \n  count = 0\n  a.each_with_index do |i,j| \n    count +=\
    \ (a[i] + a[j] + a[k]) % 3 == 0\n  end\n  count \n  }\nend", "    a = [1,3,7,13,21]\n\
    \    i = 0\n    count = 0\n    while i < n do\n        j = i + 1 #i+1 ==> i+2\n\
    \        k = i + 2 #i+2 ==> i+3\n        count = count + 1\n        if a[i] <\
    \ a[j] && a[i] < a[k]\n            puts (a[i], a[j], a[k])\n        end\n    \
    \    i = j\n    end\n    puts count\nend", "  a = []\n  for i in (1..n)\n    a.push(i*i\
    \ - i + 1)\n    puts a.inspect if a.length % 3 == 0\n  sum(a.reduce(:+))\nend",
  "  return n*(n+1)/2 - 1 - get_triples(n)\nend", "    array = []\n    for i in 1..n\n\
    \        array.push(i * (i - 1) + 1)\n    return array.max_by {|x| x}\nend", " \
    \ a=[]\n  for i in (1..n)\n    a << i * i - i + 1\n  a.uniq.size\nend\n</cell>\n\
    <cell>\nget_max_triples.call(4)\n</cell>\n<cell>", "  \n  # Your code here\n \
    \ a = [n.to_s] * n\n  i = a.index(n) + 1\n  j = a.index(n) - 1\n  k = a.index(n\
    \ - 1) + 1\n  if i >= j and i >= k and j >= k\n    count = 0\n  else\n    count\
    \ = a.index(n - 1)\n  end\n  \n  return count\nend\nget_max_triples.call(5)\n\
    </cell>\n<cell>", "  a = []\n  for i in 1..n\n    a.push(i * (i-1) + 1)\n  end\n\
    \  a.sort!\n  a.reduce do |sum, cur|\n    next if cur < 2\n    sum += 1 if cur\
    \ % 3 == 0\n    sum\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,arrays,algorithm\
    \ |>\nI find it interesting that this question has so many variations.\nI started\
    \ with this, but I started off thinking that I was writing it incorrectly. Then\
    \ I went back to think about it and it seemed to make sense and I realized that\
    \ this is the easiest way to do it.\n<code>", "    a = []\n    for i in 1..n\n\
    \        a.push(i * i - i + 1)\n    return a.max_by { |x| (x * x * x) }\nend",
  "  a = []\n  for i in 1..n\n    a.push(i*i - i + 1)\n  end\n  return a.select {|x|\
    \ x.modulo(3) == 0 }.size\nend", "    a, i = 0, 0\n    while i < n\n        i\
    \ += 1\n        while i < n\n            i += 1\n            while i < n\n   \
    \             i += 1\n                if i == n \n                    puts a\n\
    \                end\n            end\n        end\n    end\nend", "  array =\
    \ []\n  for i in (1..n).to_a\n    array.push(i * i - i + 1)\n  array.each_with_index\
    \ do |i, index|\n    if index < n\n      return(array[index], array[index + 1],\
    \ array[index + 2])\n    end\n  end\nend", "  a = []\n  for i in 1..n\n    a.push\
    \ i * i - i + 1\n  end\n  a.length.times do\n    triple = a.sort.slice_after {\
    \ |i| i < a.length }.first\n    return 1 if triple\n  end\n  return 0\nend", " \
    \ a = Array.new(n) { |i| i * i - i + 1 }\n  a.size.times do |i|\n    a.delete_at(a.index\
    \ {|x| x == a[i].to_s }[0])\n  end\n  a.size - a.index {|x| x == a[0].to_s }\n\
    end\n</cell>\n<cell>", "  a = Array.new(n)\n  \n  for i in 0..n\n    a[i] = i*i\
    \ - i+1\n  end\n  \n  for i in 0..n-1\n    for j in i+1..n\n      if a[i] + a[j]\
    \ + a[k] % 3 == 0\n        return a[i], a[j], a[k]\n      end\n    end\n  end\n\
    end", "  a =Array.new(n)\n  a[0] = 1\n  a[1] = a[0] + a[0] - a[1]\n  for i in\
    \ 2..n\n    a[i] = a[i] + a[i-1] - a[i] + a[i-2]\n  end\n  a.sort.select{|x| x.modulo(3).zero?}.size\n\
    end\n</code>\n<|/ a tags=ruby,arrays |>\n<| a tags=ruby,arrays |>\nI guess this\
    \ is what you want.\n<code>", "  a = Array.new(n)\n  (1..n).each do |i|\n    a[i]\
    \ = i * i - i + 1\n  end", "  a = Array.new(n)\n  n.times { |i| a[i] = i * i -\
    \ i + 1 }\n  a.uniq.sort\n  return a.uniq.select {|i| a[i] == i*i - i+1 }.length\n\
    end\n</cell>\n<cell>", "  triples = []\n  a.each_with_index { |v, i| triples <<\
    \ v if v < a[i] + a[j] + a[k] }\n  triples.uniq.count { |triple| triples.count(triple)\
    \ % 3 == 0 }\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,ruby-on-rails,algorithm\
    \ |>\nHere is a solution using Ruby 1.8.7 methods:\n<code>", "  a = []\n  for\
    \ i in 1..n\n    a.push(i*i-i+1)\n  end\n  a.each_with_index do |e,i|\n    if\
    \ i < (a.length-1)\n      if a[i] < a[i+1]\n        if a[i] < a[i+2]\n       \
    \   return 1\n        end\n      end\n    end\n  end\n  0\nend\n</code>\n<|/ a\
    \ tags=math,algorithm,ruby,arrays dscore=1 |>\n<| a dscore=1 tags=math,algorithm,ruby,arrays\
    \ |>\nHere is another solution:\n<code>", "  a = (1..n).to_a\n  triples = 0\n\
    \  for i in a\n    for j in a\n      for k in a\n        if i+j+k <= n && a[i]\
    \ + a[j] + a[k] % 3 == 0\n          triples += 1\n        end\n      end\n   \
    \ end\n  end\n  return triples\nend\n</cell>\n<text>\n\_Exercise 3\nCreate a function\
    \ that takes three integers $a$, $b$ and $c$ as parameters and computes the minimum\
    \ number of operations needed to compute $a^2 + b + c$.", "  a = []\n  for i in\
    \ (1..n)\n    a.push( ((i * i) - i + 1) / 3 )\n  a.uniq!\n  a.size.times{ |i|\
    \ return i }\nend", "  if n < 2 \n    then return 0\n  else \n    max = -1\n \
    \   a.clear\n    a.push(1)\n    a.push(n)\n    \n    while a.length > 2\n    \
    \  \n      i = a.pop\n      j = a.pop\n      k = a.pop", "  a = [1, 3, 7, 13,\
    \ 21]\n  count = 0\n  for i in 1...n\n    count += (i+1).times.reduce(:+)\n  end\n\
    \  return count\nend\nprint get_max_triples.call(5) # => 2", "  \n  if n % 3 ==\
    \ 0\n    # Return the number of triples (a[i], a[j], a[k]) of a where i < j <\
    \ k, \n    # and a[i] + a[j] + a[k] is a multiple of 3.\n    return n * (n+1)\
    \ >> 2\n  \n  # If n is a perfect square, return 1.\n  i = 2\n  while i * i <=\
    \ n\n    i += 1\n  if i == n\n    return 1\n  \n  # Initialize a with values from\
    \ i to n by subtracting i from each number.\n  a = (i * i - i + 1 ... n)\n  \n\
    \  k = n - 1\n  \n  # While there are k elements in the array that are smaller\
    \ than n.\n  while k > 0\n    # If a[k] is a multiple of 3, increment k by 1.\n\
    \    if a[k] % 3 == 0\n      k += 1\n    # If a[k] is greater than n, increment\
    \ i by 1.\n    elseif a[k] > n\n      i += 1\n    else\n      break\n  end\n \
    \ \n  # Return the number of triples (a[i], a[j], a[k]) of a where i < j < k.\n\
    \  return k\nend", "    a, b = Array.new(n), Array.new(n)\n    return a.size +\
    \ b.size.upto(1).inject(0) { |i,j| i==j ? (a[i], a[j], a[i]) : (a[i], a[j], a[i]\
    \ - a[j] + 1) }\nend\n</cell>\n<code language=julia-1.0>\n@test get_max_triples(5)\
    \ == 3\n</cell>\n<text>\nTribonacci numbers\nAs a mathematician, you are a researcher\
    \ and you study tribonacci numbers. You want to write a function to calculate\
    \ the value of $n$-th tribonacci number. \n$$\nn\\left(3\\right) = \\left(6\\\
    right)^n\\left(3\\right) = \\left(27\\right)^n\\left(3\\right) = \\left(5463\\\
    right)^n\\left(3\\right) = \\ldots\n$$\nThe first two tribonacci numbers are $n$-th\
    \ tribonacci numbers and $n$-th tribonacci numbers, respectively.\nThe $n$-th\
    \ tribonacci number is given by $$\n\\begin{equation}\nn\\left(3\\right) = \\\
    left(5463\\right)^n\\left(3\\right) = 5463^n\\left(3\\right) = 5463^0 + 5463^1\\\
    ldots\n\\end{equation}\n$$\nand the first two tribonacci numbers are given by\
    \ $$\n\\begin{equation}\nn\\left(3\\right) = \\left(6\\right)^n\\left(3\\right)\
    \ = 6^n\\left(3\\right) = 6^0 + 6^1\\ldots\n\\end{equation}\n$$\nWrite a function\
    \ to calculate $n$-th tribonacci number by $O(1)$ time complexity.", "  a = Array.new(n)\
    \ do |i|\n    i*i-1+i\n  end\n  triplets = 0\n  for i in (1..n)\n    for j in\
    \ (i+1..n)\n      for k in (j+1..n)\n        if a[i] + a[j] + a[k] == 3*i\n  \
    \        triplets +=1\n        end\n      end\n    end\n  end\n  return triplets\n\
    end\n</code>\n<|/ a tags=ruby dscore=1 |>\n<| a tags=ruby |>\nHere you go\n<code>\n\
    a = []\n(1..n).each do |i|\n  (1..n).each do |j|\n    (1..n).each do |k|\n   \
    \   a.push(a[j] + a[k])\n    end\n  end\nend", "  a = []\n  for i in 1..n\n  \
    \  a.push(i*i-i+1)\n  a.sort\n  count = 0\n  for i in 0..n-1\n    for j in 0..n-1\n\
    \      for k in 0..n-1\n        if i+j+k == a[i] && a[i] + a[j] + a[k] == 3*(i+j+k)\n\
    \          count+=1\n        end\n      end\n    end\n  end\n  return count\n\
    end\nend\n</code>\n<|/ a |>\n<| c |>\nHow would you do this without loops?\n<|/\
    \ c |>\n<| c |>\n`@Akhilesh` can you explain what you mean by \"without loops\"\
    \n<|/ c |>\n<| c |>\nAkhilesh , i mean without using loops , sorry if that was\
    \ not clear .\n<|/ c |>\n<| c |>\nWell I gave you the answer you wanted, so I\
    \ guess that's the answer you want. Since you asked for it, I will update my answer\
    \ to get rid of the loops part.\n<|/ c |>\n<| c |>\nNo worries, thank you for\
    \ your answer!\n<|/ c |>\n<| a tags=arrays,ruby,ruby-on-rails dscore=2 |>\n<code>",
  "  a=[]\n  for i in 1..n\n    a << i*i\n  end\n  return a.each_cons(3).inject(0)\
    \ { |sum, triple| sum + triple.inject(0) { |sum, item| sum + item } }\nend", " \
    \ n = n.to_i\n  \n  a = (1..n).to_a.collect\n  \n  triples = 0\n  \n  a.each do\
    \ |i|\n    a.each do |j|\n      a.each do |k|\n        triples += 1 if i != j\
    \ && i != k && j != k && a.include?(a[i] + a[j] + a[k])\n      end\n    end\n\
    \  end\n  \n  triples.to_i\nend\n</cell>\n<text>\nWe can now test our function\
    \ by calling the function get_max_triples with a parameter 5 to see how many triples\
    \ our function returns.", "  a.clear\n  n.times do |i| \n    a[i] = i * i - i\
    \ + 1\n  end\n  a.length\nend", "    # Write your code in Ruby here\n    res =\
    \ 1\n    for i in 1..n\n        until i > (n-i)\n            a[i] = i * i - i\
    \ + 1\n        end\n        until a[i] % 3 == 0\n            a.shift\n       \
    \ end\n        res += a.length - i\n    end\n    return res\nend", "  a = Array.new(n)\n\
    \  1.upto(n) { |i| a[i] = i * i - i + 1 }\n  1.upto(n) { |i| a[i] = a[i].abs }\n\
    \  a.each { |i| return i if i.is_a? Integer }\n  0\nend", "  a = Array.new(n)\n\
    \  a.each_index do |i|\n    \n    if i < a.length\n      while j < a.length\n\
    \        while k < a.length\n          \n          i = i * i - i + 1\n       \
    \   j = j * j - j + 1\n          k = k * k - k + 1\n          if i > 0 && j >\
    \ 0 && k > 0 && a[i] > 0 && a[j] > 0 && a[k] > 0 && a[i] > a[j] && a[j] > a[k]\n\
    \            return i + 1\n          end\n          k -= 1\n        end\n    \
    \    j -= 1\n      end\n      i -= 1\n    end\n  end\n  return 0\nend", "  return\
    \ get_max_triple_count(n)\nend", "  a = []\n  for i in (1..n)\n    a.push(i*i\
    \ - i + 1)\n  a.compact.find { |n| n % 3 == 0 }\nend", "    a = Array.new(n)\n\
    \    1.upto(n-1) do |i|\n        1.upto(n-1) do |j|\n            1.upto(n-1) do\
    \ |k|\n                if j<k && i==j && j==k\n                    a[i] = i*i-i+1\n\
    \                    i = k\n                end\n            end\n        end\n\
    \    end\n    a.select{|x| x > 3 }.size\nend\n</code>\n<|/ a tags=ruby |>\n<|\
    \ a dscore=0 tags=ruby |>\nHere is my solution using Ruby 2.3.1.\n<code>", " \
    \ a = [1,3,7,13,21]\n  a.each do |i|\n    a.each do |j|\n      a.each do |k|\n\
    \        if i+j+k == a[i*i+j*j+k] && a[i]+a[j]+a[k] == i*i*i\n          puts i\n\
    \          break\n        end\n      end\n    end\n  end\nend", "  max_triples\
    \ = 0\n  for i in (1..n)\n    triples = 0\n    for j in (1..n)\n      if i < j\n\
    \        triples += a[j] * a[j]\n      end\n      if i == j\n        triples +=\
    \ a[i]\n      end\n      if i == j && j > i\n        triples += a[i] # not valid\n\
    \      end\n      if triples > max_triples\n        max_triples = triples\n  \
    \    end\n    end\n  end\n  return max_triples\nend", "  a = []\n  for i in 1..n\n\
    \    a.push(i*i-i+1)\n    a.push(i*i-1)\n    a.push(i*i+1)\n  end\n  a.each {\
    \ |x| puts x }\n  a.sort.each { |x| puts x }\n  a.uniq.length == (a.length * 3).to_i\n\
    end\n</code>\n<|/ a tags=ruby,algorithm |>\n<| c |>\nI'm sorry, I don't understand\
    \ how this is supposed to return the triple.\n<|/ c |>\n<| c |>\nThe OP asked\
    \ for the value of each triple, and it can be done by iterating through the array\
    \ and comparing it with its neighbors. But this code is definitely more elegant\
    \ :)\n<|/ c |>\n<| c |>\nI updated my answer to include a method which prints\
    \ the triples. I tested the code and it works perfectly for me. I hope it helps.\n\
    <|/ c |>\n<| a dscore=0 tags=ruby,algorithm |>\n<code>", "  a = [1] * n\n  a.each\
    \ { |i| a[i] = i * i - i + 1 }\n  a.select { |i| i < a.min { |j| a[j] - a[i] }\
    \ }.length\nend", "  a = []\n  (1..n).each do |i|\n    a[i] = i * i - i + 1\n\
    \  end\n  a.sort.uniq.map{|x| [x,x,x]}.count{|x| x[0].modulo(3) }\nend\nprint\
    \ get_max_triples(5)", "  a.push(1) while a.size < n\n  return a.size - 2\nend",
  "\ta = Array.new(n) {|i| i*i - i + 1}\n\tfor i in 1..n\n\t\tif a[i] < 0 || a[i]\
    \ % 3 == 0\n\t\t\tputs \"The only valid triple is #{a[i]}\"\n\t\t\tbreak\n\t\t\
    else\n\t\t\ta[i] = a[i] - 1\n\t\tend\n\tend\n\tputs a.select{|i| i % 3 == 0}.length\n\
    end\nputs get_max_triples.call(5)\n</code>\n<|/ a dscore=2 |>\n<| c |>\nHi, I\
    \ wonder why this isn't the top answer for the question. While this is very short,\
    \ it seems like it answers the question correctly, and the only answer that uses\
    \ `select` - I guess it is also a short and sweet solution.\n<|/ c |>\n<| c |>\n\
    This answer doesn't seem to have anything to do with what the question is asking\
    \ for. It doesn't use the concept of triple in the question. It doesn't even call\
    \ out that it is doing the same thing as what the question is asking for. It merely\
    \ uses `select` to find the count of triples. That's an easy solution but it doesn't\
    \ even attempt to address the conceptual problem.\n<|/ c |>\n<| a tags=ruby |>\n\
    Here is a slightly more concise solution that uses Enumerable#each_cons.\n<code>",
  "  a = Array.new(n){|i| i * i - i + 1}\n  max_val = 0\n  max_i = 0\n  max_j = 0\n\
    \  max_k = 0\n  for i in 0..n-1\n    for j in i+1..n\n      for k in j+1..n\n\
    \        if a[i] > max_val\n          max_val = a[i]\n          max_i = i\n  \
    \        max_j = j\n          max_k = k\n        end\n      end\n    end\n  end\n\
    \  max_i * max_j + max_k\nend\n</code>\n<|/ a |>\n<| a dscore=0 tags=ruby |>\n\
    <code>", "  n = n.to_i\n  a = [n] * n\n  result = 0\n  i = 0\n  j = 1\n  k = 2\n\
    \  while i < n && j < n && k < n\n    result += (i < j && i < k && a[i] < a[j]\
    \ && a[j] < a[k]) ? 1 : 0\n    i += 3 \n    j += 1\n    k += 3\n  return result\n\
    end", "  a = Array.new(n)\n  a[0] = a[1] = a[2] = 1\n  for i in 1..n\n    for\
    \ j in i..n\n      a[j] += a[i-1]\n    a[i] -= a[i-1]\n  end\n  return a[n]\n\
    end\nputs(get_max_triples.call(ARGV.first))", "  arr = Array.new(n)\n  for i in\
    \ 0...n\n    arr[i] = i * i - i + 1\n  max = -1\n  for i in 0...n\n    for j in\
    \ 0...i\n      k = j + 1\n      while k <= n\n        sum += arr[i] + arr[j] +\
    \ arr[k]\n        if sum > max\n          max = sum\n        k += 1\n  return\
    \ max\nend", "  return 0 if n < 3 then return n else return get_max_triples(n-1)\
    \ + get_max_triples(n-2) + get_max_triples(n-3) + n\nend\n</cell>\n<text>\nThis\
    \ solution is better. Now it uses memoization.", "  a_arr = Array.new(n)\n  a_arr.fill(0)\
    \ \n  a.length.times do |i| \n    a_arr[i] += i*i - i + 1 \n  end \n  a_arr.each_with_index.select\
    \ { |triple, i| \n    triple[0] == triple[1] && triple[0] == triple[2]\n  } \n\
    \  a_arr.select { |triple, i| \n    triple[0] + triple[1] + triple[2] == i * i\
    \ * i\n  } \nend", "    a = []\n    a.push(1)\n    a.push(3)\n    a.push(7)\n\
    \    a.push(13)\n    a.push(21)\n    \n    a.each_with_index do |e,i|\n      a.shift\n\
    \      a.shift\n      a.shift\n      break if (i > a.length-1) || ((e-a[i-1])\
    \ % 3 == 0)\n    end\n    return a.length\nend", "  a, b = Array.new(4), Array.new(4)\n\
    \  a[0], a[1], a[2], a[3] = n, n, n, n\n  b[0], b[1], b[2], b[3] = 0, 0, n, n\n\
    \  for i in 1..n\n    (a[i] += a[i-1]).succ!\n    b[i] += b[i-1]\n  end\n  (a[0]+a[1]+a[2]).zero?\
    \ || b[0]+b[1]+b[2] == 0 || b[0]+b[1]+b[2] == (a[0]+a[1]+a[2]).zero? \n  ? 1\n\
    \  : (a + b).sum % 3\nend\n</code>\n<|/ a tags=algorithm,ruby,arrays |>\n<| c\
    \ |>\nThis code doesn't work with negative integers. Also, please add some explanation.\n\
    <|/ c |>\n<| a |>\nI do not know any Ruby language, but here is my solution in\
    \ Python:\n<code>", "  a.length(n) # create an array a of length n\n  a.each_index\
    \ { |i| a[i] = i * i - i + 1 } # fill in the values from 0 to n-1", "  a = []\n\
    \  a[0] = 1\n  for i in (1..n-1)\n    a[i] = i*i - i+1\n    i += 1\n  a.each_with_index\
    \ do |v,i|\n    if v % 3 == 0\n      a.delete_at(i)\n      break\n    end\n  end\n\
    \  a.length\nend", "  a = (0...n).to_a\n  a.each_index do |i|\n    a.delete_at(i)\n\
    \    break if a.size < 3\n  end\n  a.size\nend\n</code>\n<|/ a |>\n<| c |>\nHi,\
    \ I appreciate the answer. But I must use Ruby 2.5.1. Can you please suggest a\
    \ solution for Ruby 2.5.1?\n<|/ c |>\n<| c |>\n, The main problem with that Ruby\
    \ version is that `each_with_index` method does not exist there. You could try\
    \ with `each_with_index`  or just iterate manually and add those elements to a\
    \ hash by its index, then check the hash.\n<|/ c |>\n<| a dscore=2 |>\nJust in\
    \ case...\nI thought I'd put an answer that doesn't depend on each_with_index\
    \ and doesn't use hashes (which I like in Ruby but I don't like in Python), but\
    \ only loops.\n<code>", "  max = -1\n  result = 0\n  for i in (1 .. n)\n    result\
    \ = 3 * a[i] + result\n    if result % 3 == 0\n      result = 0\n      max = i\
    \ if result > max else result\n    end\n  end\n  return max\nend", "  a = [n for\
    \ i = (1..n)]\n  sum = 0\n  for i in a\n    if i % 3 == 0\n      sum += i\n  \
    \  end\n  end\n  return sum\nend", "  a = Array.new(n)\n  for i in 0...n\n   \
    \ a[i] = i * i - i + 1\n    \n  sum = 0\n  for i in 0...n-1\n    for j in i+1...n\n\
    \      k = j + 1\n      sum += (a[i] + a[j] + a[k])\n      \n    if sum % 3 ==\
    \ 0\n      return sum\n    end\n  end\nend", "  a = [i for i in (1..n)]\n  a.sort\n\
    \  sum = 0\n  a.each do |i|\n    sum += 1\n    a.each do |j|\n      sum += 2\n\
    \      a.each do |k|\n        if sum > n*n and i*i + j*j + k*k == n*n and i*i\
    \ + j*j + k*k == i*i + j*j + k*k then return sum\n      end\n    end\n  end\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a tags=algorithm,ruby |>\nI know it might\
    \ be late, but for anyone else looking, I made a little method that can do this\
    \ for you in Ruby:\n<code>", "  sum = 0\n  a = []\n  for i in 0..n\n    a[i] =\
    \ i * i - i + 1\n  end\n  a.each_with_index do |val, i|\n    sum += (val + a[i\
    \ + 1] + a[i + 2]) % 3\n  end\n  sum % 3 == 0\nend", "  a, count = [0]*n, 0\n\
    \  (0...n).each do |i|\n    a.push(i * i - i + 1)\n    count += 1 if a[i] % 3\
    \ == 0\n  end\n  count\nend", "  a = [1,3,7,13,21]\n  \n  result = 0\n  i = 0\n\
    \  while i < n\n    if i < n-1\n      result += a[i] + a[i+1]\n      i += 1\n\
    \    else\n      result += a[i]\n    end\n  end\n  \n  return result\nend\n</cell>\n\
    <code language=julia-1.5>\n@time get_max_triples(5000)\n</cell>\n<text>\n5. Write\
    \ a Julia function count_to_100(number) that takes an integer number n and returns\
    \ the number of integers from 1 to n that have exactly 100 digits.", "  a = Array.new(n)\
    \ {|i| i * i - i + 1}\n  i = 0\n  j = n\n  k = 0\n  while i < n and j < n and\
    \ k < 3\n    i, j, k = [a[i], a[j], a[k]].min\n  end\n  return k if k % 3 == 0\n\
    \  0\nend", "  a = [1, 2, n+1]\n  \n  triples = 0\n  \n  for i in 0...n\n    j\
    \ = i+1\n    k = n\n    \n    while i < n && j < n && k < n\n      while i < n\
    \ && a[i] < j && a[j] < k\n        i += 1\n      while j < n && a[j] < i && a[k]\
    \ < j\n        j -= 1\n      while k < n && a[k] < i && a[i] < k\n        k +=\
    \ 1\n      \n      if i < n && j < n && k < n\n        triples += 1\n      \n\
    \      i += 1\n      j -= 1\n      k -= 1\n    end\n    \n    i += 1\n    j +=\
    \ 1\n    k += 1\n  end\n  \n  puts triples \nend\n</code>\n<|/ a tags=ruby |>\n\
    <| c |>\nGreat answer! My only suggestion to make the code more efficient is to\
    \ redefine each loop iteration as a separate method as opposed to putting it all\
    \ in one big while loop. Also, you can declare variables that you then use in\
    \ more than one place by using an array. `arr = Array.new(n+1)` then `for i in\
    \ 0...n; arr[i] = i+1; end`\n<|/ c |>\n<| a dscore=0 |>\nHere's a solution in\
    \ JavaScript:\n<code>\nfunction threeSum(n) {\n    let a = [];\n    let aMax =\
    \ [];\n    for(let i = 0; i < n; i++){\n        for(let j = i+1; j < n; j++){\n\
    \            for(let k = j+1; k < n; k++){\n                if(i + j + k == n){\n\
    \                    a.push([i,j,k]);\n                    aMax.push([i,j,k]);\n\
    \                    break;\n                }\n                if(i + j + k >\
    \ n){\n                    break;\n                }\n                if(aMax.length\
    \ == 3){\n                    break;\n                }\n                if(aMax[aMax.length\
    \ - 1] == [i,j,k]){\n                    aMax.push([i,j,k]);\n               \
    \     break;\n                }\n            }\n        }\n    }\n    return a;\n\
    }\n</code>\n<|/ a tags=ruby |>\n<| a dscore=0 tags=ruby |>\n<code>", "  a.delete_if\
    \ do |i| i.negative?\n  a.each_cons(3) { |i| triples += i }\n  triples.to_i\n\
    end", "  a = Array.new(n)\n  (0..n-1).step(0) { |i| a[i] = i*i-i+1 }\n  \n  (0..n-1).step(1)\
    \ { |i| a[i] = i*i-1+i }\n  (0..n-1).step(2) { |i| a[i] = i*i-2+i }\n  \n  (0..n-1).step(3)\
    \ { |i| a[i] = i*i-3+i }\n  (0..n-1).step(4) { |i| a[i] = i*i-4+i }\n  \n  (0..n-1).step(5)\
    \ { |i| a[i] = i*i-5+i }\n  \n  sum = 0\n  (0..n-1).step(1) { |i| sum += a[i]\
    \ + a[j] + a[k] }\n  return sum\nend", "  return 1 if n % 3 == 0 else get_max_triples(n\
    \ / 3) + 1\nend\n</cell>\n<code language=julia-1.0>", "  a = [1, 3, 7, 13, 21]\n\
    \  count = 0\n  i = 0\n  j = 1\n  k = n\n  while i < j && j < k\n    if a[i] <\
    \ a[j] && a[j] < a[k]\n      count += 1\n    i += 1\n    j += 1\n    k += 1\n\
    \  end\n  puts \"count = #{count}\"\n  \n  count += (a[i] - a[j] + a[k])\nend",
  "    a.fill(n*n - n + 1)\n    \n    count = 0\n    for i in 1..n\n      j = i +\
    \ 1\n      k = 1\n      while k < n do\n        if a[i] > a[j] and a[i] > a[k]\n\
    \          return count\n        else\n          count += 1\n          k += 1\n\
    \        end\n      end\n    end\n    \n    return count\nend", "  a = Array.new(n)\n\
    \  for i in 1..n\n    a[i] = i * i - i + 1\n  count = 0\n  for i in 1..n\n   \
    \ j = n - i\n    for k in 1..i\n      if a[i] < a[j] && a[j] < a[k]\n        count\
    \ += 1\n      end\n    end\n  end\n  count\nend\n</code>\n<|/ a |>\n<| c |>\n\
    The question is asking for an O(1) solution, which would take advantage of knowing\
    \ that the sum of any three numbers is an increasing number. As far as I know,\
    \ there's no way to find an increasing number with an O(1) algorithm. I could\
    \ be wrong though.\n<|/ c |>\n<| c |>\nIt is not correct. You are assuming that\
    \ the sum of the given numbers is an increasing number (which is *not* a correct\
    \ assumption). For instance, `sum(1..n) = n`. The sum of any three numbers can\
    \ never be an increasing number, but you cannot prove that it will be the case\
    \ for numbers in the range `1..n`.\n<|/ c |>\n<| c |>\nYes, I assumed that they\
    \ were just talking about positive numbers. You're right, of course. I'll edit\
    \ the answer to be correct now.\n<|/ c |>\n<| c |>\nYes, it worked! I actually\
    \ just wrote a program to find it for you and I was trying to understand it and\
    \ then write my own answer. But you used the function I wrote and explained it\
    \ so well that I thought you might not have seen it yet. Thanks a lot! I feel\
    \ like i should learn more about functions. I thought that all I needed was a\
    \ looping statement that would do the same thing as a nested for loop, but it\
    \ seems that I just needed to figure out how to increment an array. Thanks again!\n\
    <|/ c |>\n<| a |>\nThis is just an expansion on my original answer which was wrong\
    \ since it didn't take into account that the sum of any three numbers is an increasing\
    \ number. Since that's not the case, my original answer has been removed.\nThe\
    \ way I read your question is that you're given a single integer (n) and you're\
    \ trying to find how many triples sum to n, which can be found by adding up all\
    \ numbers from 1 to n and subtracting n-1, which can be done in O(1).\nFor example\
    \ if n = 10, then we can add 1 to 10 to get the numbers 1 to 10, and 10 - 1 to\
    \ get 9. 9 + 9 = 18, then 18 - 9 = 3. There are 3 triples of numbers from 1 to\
    \ 10 - 1. We can find the number of triples from 1 to 10 by subtracting 9 from\
    \ the total number of triples from 1 to 9 and dividing by the number of triples\
    \ from 1 to 10 (", "  a = (0..n).to_a\n  \n  puts \"#{n} #{a} #{a.uniq.length}\"\
    \n  a.uniq.each {|i| puts \"#{i} #{i*i} #{i*i+1}\" }\n  puts a.map {|i| i*i*i\
    \ }.length\nend", "  a = Array.new(n) do |index|\n    index\n  end\n  a.each_with_index\
    \ do |value, index|\n    a[index] = value * value - value + 1\n  end\n  \n  count\
    \ = 0\n  a.each_with_index do |value, index|\n    count += 1\n    if index < (a.length\
    \ - 1) && a[index] == a[index + 1] + a[index + 2]\n    end\n  end\n  \n  count\n\
    end", "  a = []\n  for i in (1..n)\n    a.push i*i-i+1\n  a.uniq.each do |i|\n\
    \    k = i - 1\n    while k > 0\n      if a[k] > a[k-1]\n        break\n     \
    \ else\n        k -= 1\n      end\n    end\n    if a[k] == a[k-1]\n      a[k]\n\
    \    end\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThe question is not\
    \ asking for a solution. Please, see the last sentence.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\n<code>\na = [1, 3, 7, 13, 21]\na.uniq.select { |x| a.count(x) > 1 }", " \
    \ a = []\n  for i in 1...n\n    a.push(i*i - i+1)\n  end\n  a = a.sort\n  a.each_with_index\
    \ do |a,i|\n    return i+1 if a%3 > 0 \n  end\n  return 0\nend\n</code>\n<|/ a\
    \ tags=ruby |>\n<| c |>\nWhile this code may answer the question, providing additional\
    \ context regarding why and/or how this code answers the question improves its\
    \ long-term value.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  count=0\n  i=0\n\
    \  a=Array.new(n-1)\n  a.each{|e|e=0}\n  while i<=n-1\n    i+=1\n    j=0\n   \
    \ k=i\n    while j<=i-1\n      j+=1\n      count+=1 if a[j]==a[k] && (a[j]+a[k])\
    \ % 3 == 0\n    end\n    k+=1\n  end\n  count\nend", "  a.length.times do |i|\
    \ a[i]=i*i-i+1 end \n  \n  max_triples = 0\n  for i in 1..n-1 do\n    break if\
    \ a[i]+a[i+1] > a[i+2]\n    max_triples += a[i]+a[i+1]+a[i+2] > max_triples ?\
    \ 1 : (max_triples - a[i]-a[i+1]-(a[i+2]-a[i+1])*(a[i+2]-a[i+1]))\n  end\n  max_triples\n\
    end", "  return find_triples(n).size\nend\n</cell>\n<code language=julia-0.6>\n\
    get_max_triples(10)\n</cell>\n<code language=julia-0.6>\n@code_warntype get_max_triples(10)\n\
    </cell>\n<code language=julia-0.6>\n@code_warntype find_triples(10)\n</cell>\n\
    <text>\nExercice 3 - S\xE9lection de pairs al\xE9atoires dans un array\nUtiliser\
    \ pour ce exercice la m\xE9thode randperm(M) de Base.Random.\nLa m\xE9thode randperm(M)\
    \ permet de g\xE9n\xE9rer un ensemble d'indices al\xE9atoires de M entiers de\
    \ 1 \xE0 M. \nLe r\xE9sultat doit \xEAtre un vecteur de taille M en entiers.",
  "  arr = Array.new(n)\n  i = 1\n  while i < n\n    arr[i] = i*i - i + 1\n    i +=\
    \ 1\n  end\n  arr.each_with_index do |i, index|\n    if index != 0\n      j =\
    \ index - 1\n      k = index + 1\n      while j != 0\n        if arr[j] + arr[k]\
    \ == i\n          return i\n        end\n        j += 1\n      end\n    end\n\
    \  end\n  return 0\nend", "  array.init(n, Array.new(n).fill(0))\n  a.length.times\
    \ do |i|\n    a.map { |j| i + j }.each do |j|\n      a.map { |k| i + j + k }.each\
    \ do |k|\n        arr[k] = a.find { |i| i + j + k == n }\n        arr[k] = nil\
    \ unless arr[k] > arr[k]\n      end\n    end\n  end\n  arr.count.times.map { |i|\
    \ arr[i] }.count\nend", "  a = []\n  for i in 1..n\n    a.push(i*i-1)\n  end\n\
    \  a.map!{|i| i*i-1}\n  a.uniq!\n  a.uniq.sort!\n  a.uniq.map!{|i| i*i-1}\n  a.uniq.count{|x|\
    \ x*x+1 > 0}\nend\n</code>\n<|/ a tags=ruby,arrays,algorithm |>\n<| c |>\nThis\
    \ doesn't return the max of the triples.\n<|/ c |>\n<| c |>\n: Thanks for pointing\
    \ out, I was fixing it right after, I will edit it now\n<|/ c |>\n<| c |>\nI still\
    \ don't get why you think it returns the max of the triples.\n<|/ c |>\n<| c |>\n\
    : Oh I see what you meant now. I was thinking of `max(arr)` when I posted this.\
    \ I was thinking of a single number, not an array of numbers. I fixed it now.\n\
    <|/ c |>\n<| a dscore=1 |>\nHere's my stab at it (it's not an efficient solution\
    \ but it's clear and readable):\n<code>", "    \n    if n <= 0\n        return\
    \ 0\n    \n    a = [0] * n\n    \n    for i in 1..n\n        a[i] = i * i - i\
    \ + 1\n    end\n    \n    count = 0\n    for i in 1..n\n        for j in (i +\
    \ 1)..n\n            if a[i] < a[j] + a[k] && a[i] != a[j] and a[i] != a[k]\n\
    \                count = count + 1\n            end\n        end\n    end\n  \
    \  \n    return count\nend\n</cell>\n<code language=julia-1.0>\n@time get_max_triples(5)\n\
    </cell>\n<code language=julia-1.0>\n@time get_max_triples(10000000)\n</cell>\n\
    <code language=julia-1.0>\n@time get_max_triples(100000000)\n</cell>\n<code language=julia-1.0>\n\
    @time get_max_triples(1000000000)\n</cell>\n<code language=julia-1.0>\n@time get_max_triples(10000000000)\n\
    </cell>\n<text>\nRewrite the function using two loops. The code will be more readable\
    \ and faster.", "  count = 0\n  a = Array.new(n)\n  for i in 0...n\n    a[i] =\
    \ i * i - i + 1\n  end\n  for i in 0...n\n    for j in 0...n\n      count += 1\n\
    \      if a[i] + a[j] + a[k] == 0\n        break\n      end\n    end\n  end\n\
    \  return count\nend", "  n = n.to_i\n  a = []\n  for i in 1..n\n    a.push(i.*(2*i-1))\n\
    \  a.sort.each_with_index do |t,i|\n    j = i\n    k = a.length-1\n    break if\
    \ j >= k\n    if t == 3*(i+1)\n      return 1\n    end\n  end\n  return 0\nend",
  "  a = Array.new(n)\n  for i in (0..n-1)\n    a[i] = i * i - i + 1\n  end\n  a.sort.each\
    \ do |x|\n    if a[x] == a[x] + a[x] + a[x] && a[x] != 0\n      return a[x]\n\
    \    end\n  end\n  return 0\nend", "    a.fill 0\n    a.push n\n    for i in 1..n\n\
    \        a[i] = i*i-1+i+1\n    for i in 1..n-1\n        for j in i+1..n-1\n  \
    \          if a[i] + a[j] + a[k]  % 3 == 0\n                return 1+k-1\n   \
    \ return 0\nend\n</cell>\n<code language=julia-1.0>\nget_max_triples(5)\n</cell>\n\
    <code language=julia-1.0>\nget_max_triples.call(5)\n</cell>\n<text>\nProblem 9",
  "\tarray = []\n\tfor i in 1..n\n\t\tarray.push(i * i - i + 1)\n\tarray.uniq.map\
    \ {|i| array[i] + array[i + 1] + array[i + 2]}\nend", "  a = [1,3,7,13,21]\n \
    \ a.sort!\n  triples = 0\n  for i in (0..n-1)\n    triples += (a[i] + (a[i+1]\
    \ + a[i-1])) % 3 == 0\n  end\n  return triples.to_i\nend", "  a = Array.new(n)\n\
    \  1.upto(n) do |i|\n    1.upto(n) do |j|\n      1.upto(n) do |k|\n        if\
    \ i > j && i > k && a[j] + a[k] + a[i] > a[j] + a[k] + a[i]\n          a[i] =\
    \ a[j] + a[k] + a[i]\n        end\n      end\n    end\n  end\n  return a.count\n\
    end\nputs get_max_triples.call(20)", "    sum = 0\n    a = []\n    for i in 1..n\n\
    \        a.push i * i - i + 1\n    end\n    a.uniq\n    a.each do |i|\n      \
    \  a.each_with_index do |j,i|\n            if j > i and j + i > sum\n        \
    \        sum = sum + j + i\n            end\n        end\n    end\n    return\
    \ sum\nend", "  a = []\n  for i in 0...n\n    a[i] += 1\n  a += [n]\n  for i in\
    \ 0...n-1\n    for j in i+1...n\n      a[j] -= a[i]\n  return a[1...n].max - (a.min..a.max).inject(0)\
    \ {|sum,x| sum + x % 3}.max % 3\nend", "  a = []\n  for i in (1..n)\n    a.push\
    \ i * (i - 1) / 2 + i\n  a.reduce(0) do |i, j, k|\n    i += 1\n    j += i\n  \
    \  k += j\n    k % 3 == 0 ? k : nil\n  end\nend\n</code>\n<|/ a |>\n<| c |>\n\
    thanks for your answer, but it doesn't return the right answer. \nThe right answer\
    \ is 1 but i got 3\n<|/ c |>\n<| c |>\nsorry for that, I've updated the answer\
    \ with some explanation\n<|/ c |>\n<| c |>\nthanks for your explanation, now I\
    \ know the complexity of reduce method :)\n<|/ c |>\n<| c |>\nNo problems. I think\
    \ it is quite efficient in terms of memory usage.\n<|/ c |>\n<| c |>\nThis was\
    \ actually the fastest solution in my tests (on a large array), but I'm surprised\
    \ that it's so fast on smaller arrays.  It feels like it might have a big memory\
    \ impact, as it stores the intermediate numbers (which have already been calculated\
    \ in the prior steps).  Is there a better way to do this without having to store\
    \ all the intermediate results?\n<|/ c |>\n<| a tags=ruby dscore=1 |>\n<code>",
  "  a = []\n  for i in 1..n\n    a.push i*i-i+1\n  end\n  a.sort!\n  a\n  a.length\n\
    end", "    a_array = [nil] * n\n    count = 0\n    a_array.each do |i|\n     \
    \   a_array.each do |j|\n            a_array.each do |k|\n                count\
    \ += ((i ** 2) + (j ** 2) + (k ** 2)) % 3 == 0\n                count += ((a[i]\
    \ - (a[j] + a[k])) % 3) == 0\n            end\n        end\n    end\n    puts\
    \ count if count\nend\n</code>\n<|/ a dscore=2 tags=ruby,arrays |>\n<| a |>\n\
    I guess this could be easily done using recursion without using ruby's methods.\
    \ \nI see three cases : ", "  a = [i for i in 1..n]\n  a.sort!\n  count = 0\n\
    \  for i in 0..(n-1)\n    if a[i+1] < a[i] + 1 && a[i+1] < a[i+2] + 1 && a[i+2]\
    \ < a[i] + 1\n      count += 1\n    end\n  end\n  return count\nend", "  a = Array.new(n)\n\
    \  n.times do |i|\n    a.push(i*i - i + 1)\n  end\n  triples = Array.new(n)\n\
    \  a.each do |i|\n    triples.each do |j|\n      triples.each do |k|\n       \
    \ if i + j + k >= n\n          return 1\n        end\n      end\n    end\n  end\n\
    end", "  a = []\n  for i in 1...n\n    if a[i]\n      j = i * i - i + 1\n    \
    \  k = i * i + i\n      a.push([i, j, k])\n    end\n  end\n  a.delete_at(a.find_index\
    \ { |x| x.product == 0 })\n  a.count\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1\
    \ |>\nOne of the tricky things about this problem is that the array can have duplicates.\
    \ \nLet's say you have a list of integers with duplicates.\n<code>\na = [1, 3,\
    \ 7, 7, 11, 13, 21]\n</code>\nTo find all three numbers that sum to 3 you need\
    \ to loop through each element. \n<code>\na.each do |n|\n  if n % 3 == 0\n   \
    \ puts n \n  end\nend\n</code>\nAnd for what we need, we can just check with sum\n\
    <code>\na.each do |n|\n  if sum(n) == 3\n    puts n \n  end\nend\n</code>\nThe\
    \ tricky part is that the array can have duplicates. \n<code>\na = [1, 3, 7, 7,\
    \ 11, 13, 21]\n</code>\nAnd we want only the numbers that sum to 3. \nSo you need\
    \ to check to see if each element in the array is the same and if not, skip it.\n\
    <code>\na.each do |n|\n  next if n.sum != 3 \n  puts n \nend\n</code>\n<|/ a tags=ruby,loops,arrays\
    \ |>\n<| a dscore=1 tags=ruby,loops,arrays |>\nMy solution\n<code>", "  a.fill(0)\n\
    \  puts a\n  for i in 1..n\n    a.push(i * i - i + 1)\n  end\n  puts a\n  a.sort!\n\
    \  puts a\n  a.each_with_index do |triple, index|\n    next if index < 2\n   \
    \ puts triple\n    puts a[index+1]\n    puts a[index+2]\n  end\n  return a.first\n\
    end\nputs get_max_triples.call(5)\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI like\
    \ the answer, but please explain why this would work.\n<|/ c |>\n<| c |>\nThanks\
    \ for your comment. Yes, I am looking for a faster solution than O(n^2), although\
    \ I prefer not using sort.\n<|/ c |>\n<| c |>\nWhy would this be faster ? Do you\
    \ mean `O(n)` instead of `O(n^2)` ?\n<|/ c |>\n<| c |>\nYes, O(n) instead of O(n^2).\
    \ I tried it and it seems almost identical to the sorting method I wrote, though\
    \ not as efficient.\n<|/ c |>\n<| c |>\n`O(n) instead of O(n^2)` Why?\n<|/ c |>\n\
    <| a dscore=1 |>\nFor a given number n, you need to check all pairs from 1 to\
    \ n and check whether they are triples of numbers that are multiples of 3.\nSince\
    \ you can only get up to sqrt(n) numbers, you can solve this in time complexity\
    \ O(sqrt(n)) - in other words, it takes O(sqrt(n)) steps to find the first such\
    \ pair.\nYou then need to check whether that pair is of length 3 or greater -\
    \ if it is, then the answer is trivially true.\n<|/ a tags=arrays,ruby |>\n<|\
    \ c |>\nThanks for your answer. Could you please explain the steps?\n<|/ c |>\n\
    <| c |>\nJust as I explained in my answer, I find the first such pair. I check\
    \ whether it is three or more numbers, and if it is, then the answer is true.\n\
    <|/ c |>\n<| c |>\nThanks for your answer. I am not quite sure how you check for\
    \ the first such pair. Can you please explain? Thank you.\n<|/ c |>\n<| a dscore=1\
    \ tags=arrays,ruby |>\n<code>\nn = 3\na = [1,3,7,13,21]", "\tsum = 0\n\ta = Array.new(n)\n\
    \t1.upto(n) do |i|\n\t\t1.upto(n) do |j|\n\t\t\t1.upto(n) do |k|\n\t\t\t\tsum\
    \ = a[i] + a[j] + a[k]\n\t\t\t\tif sum % 3 == 0\n\t\t\t\t\tputs sum\n\t\t\t\t\
    end\n\t\t\tend\n\t\tend\n\tend\nend\nputs get_max_triples(5)", "  a = Array.new(n)\
    \ { |x| x*x-1+1 }\n  n.times.each_with_index do |i,j|\n    begin\n      k = j+1\n\
    \      while k <= n && a[k] % 3 == 0\n        k += 1\n      end\n      a << a[j]\
    \ + a[k]\n    rescue\n    end\n  end\n  a.max\nend", "  a = Array.new(n)\n  for\
    \ i in (1..n)\n    a.push(i * i - i + 1)\n  end\n  count = 0\n  for i in (1..n)\n\
    \    j = i + 1\n    k = n - 1\n    while j > 0\n      if a[i] >= a[j] + a[k]\n\
    \        j = j - 1\n      else\n        k = k - 1\n      end\n    end\n    count\
    \ = count + 1\n  end\n  return count\nend", "  a = Array.new(n) { |i| i * i -\
    \ i + 1 }\n  a.each_with_index.each_with_index do |tri, i|\n    j, k = tri.divmod(n\
    \ - i)\n    if i < j\n      j += 1\n    end\n    if j < k\n      k += 1\n    end\n\
    \    break unless j > k\n    p [j, k, tri]\n  end\nend", "  a = []\n  for i in\
    \ 1..n\n    a << i * i - i + 1\n  end\n  a.uniq.select {|n| n % 3 == 0}.length\n\
    end\nprint get_max_triples.call(4)", "  a = (0..n).to_a\n  a.map { |i| i * i -\
    \ i + 1 }\n  a.each_cons(n).select { |i| i.inject { |s,t| s + t + i } }\n  .map\
    \ { |i| i && (i.reduce(:+) || i) }\n  .count { |i| i % 3 == 0 }\nend\n</pre>\n\
    </div>\n</div>\n</div>\n<div class=\"cell border-box-sizing text_cell rendered\"\
    ><div class=\"prompt input_prompt\">\n</div><div class=\"inner_cell\">\n<div class=\"\
    text_cell_render border-box-sizing rendered_html\">\n<h2 id=\"Part-2\">Part 2<a\
    \ class=\"anchor-link\" href=\"#Part-2\">&#182;</a></h2><p>Let's do a question\
    \ which is not covered in the lecture.</p>\n<p>Given an array <code>nums</code>\
    \ of integers <code>1 &lt;&lt; nums.length</code> and an integer <code>k</code>.\
    \ Find out the sum of all the numbers that are divisible by <code>k</code> using\
    \ <a href=\"http://en.wikipedia.org/wiki/Modulo_operation\">mod operation</a>.</p>\n\
    <p>It should return the sum of all <code>nums</code> mod <code>k</code>.</p>\n\
    <p><code>", "    a = []\n    for i in 1..n\n        a[i] ||= i * i - i + 1\n \
    \   end\n    a.map { |x| x * x - x }.reduce(:+) == 0\nend", "  a = []\n  (1..n).each\
    \ do |i|\n    a.push(i * i - i + 1)\n  end\n  a.length\nend", "  a = [1] * n\n\
    \  \n  a.map do |i|\n    i = i\n    (a[i] = i * i - i + 1)\n  end\n  \n  a.map\
    \ do |i|\n    i = i\n    (a[j] = i * i - j + 1)\n  end\n  \n  a.map do |i|\n \
    \   i = i\n    (a[k] = i * i - k + 1)\n  end\n  \n  a.map do |i, j, k|\n    i\
    \ + (j + k) == (a[0] * a[2] * a[4])\n  end.length\nend", "  a = []\n  for i in\
    \ (1..n)\n    a.push(3 * i - i + 1)\n    a.push(3 * i + 1)\n  a.push(a.max)\n\
    \  a.delete_if {|n| n < 0}\n  a.size\nend", "  max_triples = 0\n  a = Array.new(n)\
    \ { |i| i * i - i + 1 }\n  (0...n).each do |i|\n    if i < n and j < n and k <\
    \ n\n      triples_count = 0\n      a.each do |j|\n        if j < n and k < n\n\
    \          a.each do |k|\n            triples_count = j + k + 1 if a[j] * a[k]\
    \ * 3 == i * i - i + 1\n          end\n        end\n      end\n      if triples_count\
    \ > max_triples\n        max_triples = triples_count\n      end\n    end\n  end\n\
    \  max_triples\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like the elegance\
    \ of your solution, I just want to point out that you can also just use an `if`\
    \ statement in the middle of your `each` block to shorten the entire thing down\
    \ to a single line (but that would be an aesthetic issue, not a correctness issue).\n\
    <|/ c |>\n<| c |>\nSure, but that would only be relevant if the input were guaranteed\
    \ to be integers. A slightly more robust approach would be to keep a running sum\
    \ of the multiples of 3, then if the running sum is greater than the max triples,\
    \ update it. If it's less than the max triples, don't update the running sum.\n\
    <|/ c |>\n<| c |>\nYeah, that would definitely work, especially since you said\
    \ `get_max_triples.call(5)` should return 1, and I believe that `get_max_triples.call(6)`\
    \ should return 3, since 1 + 3 + 7 = 13.\n<|/ c |>\n<| a |>\nTry this one:\n<code>",
  "  a = [1,3,7,13,21]\n  count = 0\n  for i in 1..n\n    for j in 2..n\n      if\
    \ a[j] - a[i] > 0\n        if a[j] + a[i] > 3\n          count +=1\n        end\n\
    \      end\n    end\n  end\n  count\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    I think this is going to take more than O(n), because this is going to loop over\
    \ all valid triplets once, instead of three times.\n<|/ c |>\n<| c |>\nYou are\
    \ right, I edited the answer to take three loops\n<|/ c |>\n<| a tags=ruby,algorithm,arrays,ruby-on-rails\
    \ |>\nThe solution using Ruby's built-in Array class\n<code>", "  a = []\n  a.push(1)\n\
    \  a.push(3)\n  a.push(7)\n  a.push(13)\n  a.push(21)\n  a.each{|i| \n    a.push(i*i-i+1)\n\
    \  }\n  a.each{|j| \n    a.push(j)\n  }\n  a.each{|k| \n    a.push(k)\n  }\n \
    \ a = a.uniq.sort\n  a.each{|i| \n    a.push(a[i]+a[j]+a[k])\n  }\n  a.each{|i|\
    \ \n    if i % 3 == 0\n      return i\n    end\n  }\nend\n</code>\n<|/ a |>\n\
    <| c |>\nI don't think this is correct. In the sample data, the correct answer\
    \ is 6 and it returns 5 for `get_max_triples(5)`. Also, I believe he is asking\
    \ for the number of triplets and not just the sum of the triples.\n<|/ c |>\n\
    <| c |>\n- Sorry I was wrong and you are right about the question and now I fixed\
    \ my answer. I was trying to keep it simple and use the array sort method but\
    \ I was wrong. Thank you for your comment.\n<|/ c |>\n<| a tags=ruby dscore=0\
    \ |>\nI wrote this in Ruby 1.9.2. I think this should work.\n<code>", "  a = [0,1]\n\
    \  (1..n).each do |i|\n    (1..n).each do |j|\n      a[i] += j\n      (1..n).each\
    \ do |k|\n        a[j] += k\n        if a[i..j].sum == a[i..k].sum && a[j..k].sum\
    \ == a[k..i].sum\n          return i+1\n        end\n      end\n    end\n  end\n\
    \  return nil\nend", "  \nend", "  a = []\n  for i in  1..n\n    a.push(i*i -\
    \ i + 1)\n  a.uniq { |i| i*i - i + 1 }.length.to_s\nend", "  count = 0\n  a =\
    \ []\n  (0...n).to_a.map { |i| a[i] = i * i - i + 1 }\n  a.each { |i| count +=\
    \ a.find_all { |j| j <  i && a[j] + a[j] % 3 == i }.length }\n  count\nend\n</cell>\n\
    <code language=other-env>\nget_max_triples(20)\n</cell>\n<code language=other-env>\n\
    get_max_triples.call(10)\n</cell>\n<code language=other-env>\nget_max_triples.call(100)\n\
    </cell>\n<code language=other-env>\n%timeit get_max_triples(10)\n%timeit get_max_triples.call(10)\n\
    %timeit get_max_triples.call(100)\n</cell>\n<code language=other-env>", "  a =\
    \ [1, 3, 7, 13, 21]\n  result = 1\n  for i in 2..n\n    if a[i] + a[j] + a[k]\
    \ != i * i * i - i * i + i\n      result = 0\n      break\n    end\n  end\n  result\n\
    end", "    a = Array.new(n) {|i| i * i - i + 1}\n    i = 0\n    puts a.inspect\n\
    \    while i < n\n        j = (i + 1) % n\n        k = n - 1\n        puts j.inspect\n\
    \        puts k.inspect\n        until j > i\n            puts a[i].inspect\n\
    \            puts a[j].inspect\n            puts a[k].inspect\n            if\
    \ a[i] < a[j] && a[i] < a[k]\n                return i + 1\n            elsif\
    \ a[j] < a[i] && a[j] < a[k]\n                return j + 1\n            elsif\
    \ a[k] < a[i] && a[k] < a[j]\n                return k + 1\n            end\n\
    \            i += 1\n        end\n    end\n    puts \"-1\"\n    puts a.inspect\n\
    \    puts n\n    puts i\n    puts j\n    puts k\n    puts (a[i] + a[j] + a[k]).inspect\n\
    \    return -1\nend", "  a = []\n  for i in 1..n\n    a[i] = i * i - i + 1\n \
    \ end\n  a.sort.uniq.inject(0){|n, (a,b,c)| if b + c + 3*a > n; then n else b\
    \ + c + 3*a end}\nend", "  a = (1..n).to_a\n  a.each_with_index do |x,i|\n   \
    \ j = i + 1\n    k = i + 2\n    if j + 1 < n && k + 1 < n && a[i] + a[j] + a[k]\
    \ == x\n      a.delete(x)\n    end\n  end\n  return a.size\nend\n</code>\n<|/\
    \ a |>\n<| a tags=algorithm |>\nFor a problem like this, I like to try and solve\
    \ it mathematically. This might sound a bit weird, but if you had to solve this\
    \ problem, what would you do? You could start with an array of integers a = [1,\
    \ 2, 3, 4] and go through all of the possibilities of adding 1 to each index until\
    \ you get an array. There are a couple reasons why this approach is valid:", " \
    \   a, i = 0,1\n    p =0\n    while i < n do \n        a, i = i + 2, i*i\n   \
    \     p += a\n    p /= 3\n    return p \n</cell>\n<code language=julia-0.4>\n\
    get_max_triples.call(5)\n</cell>\n<text>\nProblem 3\nGiven the array of positive\
    \ integers arr, return true if any number is strictly greater than the absolute\
    \ sum of its digits.", "  trip_count = 0\n  a = Array.new(n)\n  for i in 1..n\n\
    \    a[i] = i * i - i + 1\n  end\n  for i in 1..n-1\n    j = n-1\n    while j\
    \ > i && a[j] + a[i] < a[j]\n      trip_count += 1\n      j -= 1\n    end\n  end\n\
    \  return trip_count\nend", "  # TODO: Write your code here.\n  triples = 0\n\
    \  for i in 1..n\n    if a[i] + a[j] + a[k] % 3 == 0\n      triples += 1\n  end\n\
    \  return triples\nend", "  a = [1] * n\n  for i in 0..(n-1)\n    a[i] = i * i\
    \ - i + 1\n  return a.max{|a, b| a + b == 3}\nend", "  a = [1, 3, 7, 13, 21]\n\
    \  count = 0\n  a.each do |i|\n    a.each do |j|\n      a.each do |k|\n      \
    \  a.each do |l|\n          count += 1 if i + j + k + l == i * i * i * i\n   \
    \     end\n      end\n    end\n  end\n  count\nend", "  a = Array.new(n)\n  for\
    \ i in 1..n\n    a[i] = i * i - i + 1\n  end\n  a.sort!\n  triples = 0\n  for\
    \ i in 0...n\n    for j in i...n\n      if i < j\n        triples += ((a[j] -\
    \ a[i]) > 0)\n      end\n    end\n  end\n  triples\nend", "  a = Array.new(n)\n\
    \  for i in 0...n-1\n    a[i] = i*i - i + 1\n    \n  a.sort\n  sum = 0\n  count\
    \ = 0\n  \n  for i in 0...n-1\n    j = i+1\n    k = n-1\n    \n    while j<k\n\
    \      if a[i] + a[j] + a[k] == 3\n        count += 1\n        j += 1\n      \
    \  k -= 1\n      else\n        break\n    end\n  end\n  \n  return count\nend\n\
    </cell>\n<code language=julia-1.3>\nget_max_triples(5)\n</cell>\n<code language=julia-1.3>\n\
    get_max_triples(6)\n</cell>\n<text>\nRecursion\nA recursive function is one that\
    \ is able to call itself. This function is called a recursive function because\
    \ it calls itself over and over again in its body to compute an answer. Recursive\
    \ functions are useful when computing big numbers or looping over arrays or doing\
    \ some kind of iterative process", "  a.clear\n  a[1] = 1\n  for i in 2..n\n \
    \   a[i] = i*i - i + 1 \n  result = 0\n  for i in 0..(n-1)\n    for j in i..n\n\
    \      if a[i] == a[j] + a[k]\n        result += 1\n  end\n  return result\nend",
  "  a = []\n  1.upto(n) {|i| a << (i * i - i + 1)}\n  a.sort.each {|i| return i if\
    \ a[i] % 3 == 0}\nend", "\ta = Array.new(n) {|i| i * i - i + 1}\n\ttriples = 0\n\
    \tfor i in 1..n\n\t\tfor j in i..n\n\t\t\tfor k in i..n\n\t\t\t\tif a[i] + a[j]\
    \ + a[k] == i * i * i\n\t\t\t\t\ttriples += 3\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\
    \tend\n\ttriples\nend", "  a = (1..n).to_a\n  a.each_with_index do |i, k|\n  \
    \  a.each {|j| a[j] = j*j-i+1}\n    a.each_with_index do |j, l|\n      a.each\
    \ {|k| a[k] = k*k-j+1}\n      break if ((i+j+k) % 3 == 0)\n    end\n  end\n  a.count{|x|\
    \ x%3 == 0}\nend", "  a = Array.new(n) { |i| i * i - i + 1 }\n  triples = 0\n\
    \  (0..n).each do |i|\n    next if i == 0 || i == n || a[i] < 0 || a[i] % 3 ==\
    \ 0\n    (1..n).each do |j|\n      next if j == 0 || j == i || a[j] < 0 || a[j]\
    \ % 3 == 0\n      a[j] -= a[i]\n      next if a[j] % 3 == 0\n      triples +=\
    \ 1\n    end\n  end\n  triples\nend", "    h = [0] * n\n    h_max = [0] * n\n\
    \    h_max_size = 0\n    h_max_count = 0\n    \n    for i in 1...n\n        h[i]\
    \ = i * i - i + 1\n        \n        if h[i] > h_max[i]\n            h_max = h\n\
    \            h_max_size = i\n            h_max_count = i\n        end\n    end",
  "  a = Array.new(n + 1).fill(0) # initialize array a\n  \n  for i in 1..n\n    a[i]\
    \ = a[i] + i - i + 1 # a[i] = i * i - i + 1\n  end\n  \n  for i in 1..n\n    for\
    \ j in 1..n\n      for k in 1..n\n        if a[i] + a[j] + a[k] == 3\n       \
    \   return i\n        end\n      end\n    end\n  end\nend", "  result = 0\n  a\
    \ = Array.new(n)\n  for i in 0...n\n    a[i] = i * i - i + 1\n  end\n  for i in\
    \ 0...n\n    for j in 0...n\n      for k in 0...n\n        result += ((a[i] +\
    \ a[j] + a[k]) % 3 == 0)\n      end\n    end\n  end\n  result\nend", "  if n <\
    \ 1\n    return 0\n  a = Array.new(n)\n  for i in 1..n\n    a[i] = i * i - i +\
    \ 1\n  end\n  n = a.length\n  return n if n % 3 == 0\n  n -= n % 3\n  max_triples\
    \ = 0\n  for i in 0..n\n    for j in 0..n\n      for k in 0..n\n        trip_a\
    \ = a[i] + (a[j] + a[k]) < 0 ? (-a[i], -a[j], -a[k]) : 0\n        if trip_a <\
    \ 0\n          trip_a = 0\n        end\n        max_triples |= (trip_a > 0) <<\
    \ (i * j * k)\n      end\n    end\n  end\n  max_triples\nend", "  result = 0\n\
    \  for i in 0..n\n    result += 3*i\n  result\nend", "  a = [n] * n\n  puts a\n\
    \  a.map do |i| \n    # print(a.inspect)\n    (i+1).times do |j| \n      # print(a.inspect)\n\
    \      j = (j+1)%n\n      k = j+1\n      # print i, j, k\n      puts [i, j, k]\
    \ if ((a[i] < j && a[j] < k) && a[k] % 3 == 0)\n    end\n  end\nend", "    i =\
    \ 0\n    while i < n\n        a[i] = i * i - i + 1\n        i = i + 1\n    \n\
    \    return a.inject(0) { |sum, i| sum + i } % 3\nend", "    count = 0\n    \n\
    \    a.fill(0)\n    \n    for i in 1...n\n        if a[i] % 3 == 0\n         \
    \   count += 1\n            \n            for j in i..n\n                if a[j]\
    \ % 3 == 0\n                    count += 1\n                    \n           \
    \         for k in i...n\n                        if a[k] % 3 == 0\n         \
    \                   count += 1\n    end\nend\n</cell>\n<code language=julia-1.6>",
  "  a = [0] * n\n  (1..n).each do |i|\n    (i .. i).each do |j|\n      (i .. i).each\
    \ do |k|\n        if i < j && j < k && a[i + j + k] == i*i - i + 1 \n        \
    \  return i+j+k\n        end\n      end\n    end\n  end\nend\n</code>\n<|/ a tags=ruby,arrays,algorithm\
    \ |>\n<| c |>\nThis looks promising. I will try it out and report back.\n<|/ c\
    \ |>\n<| c |>\nLooks like it is working. The problem is it is taking too long\
    \ to run. Thank you!\n<|/ c |>\n<| c |>\nI added a version that uses no loops\
    \ and should take ~3sec. to run on my machine.\n<|/ c |>\n<| c |>\nI appreciate\
    \ it. I will give it a shot now.\n<|/ c |>\n<| c |>\nYou are missing some brackets\
    \ on the second `each`.\n<|/ c |>\n<| a dscore=1 |>\nHere's my solution:\n<code>",
  "    # write your code here\n    return n-1\nend\n</cell>\n<cell>", "  a = []\n\
    \  a.push(1)\n  until a.length == n\n  for i in 0...n\n    a.push(i*i-i+1)\n \
    \ a.sort\n  a.length\nend", "  array.fill([], n)\n  array.fill([], n+1)\n  array.fill([],\
    \ n+2)\n  array.fill([], n+3)\n  array.fill([], n+4)\n  array.fill([], n+5)",
  "  a = Array.new(n - 1)\n  for i in 1..n - 1\n    a[i] = i * i - i + 1\n  end\n\
    \  trip_count = a.select{|x| x > 3 }.size\n  return trip_count\nend", "  a = Array.new(n)\n\
    \  a[0] = a[1] = a[2] = 1\n  (0...n).each do |i|\n    a[i] = i*i - i + 1 \n  end.select\
    \ { |i, j| i <= j && j <= i && a[i] + a[j] + a[k] % 3 == 0 }.length\nend", " \
    \ n = n.to_i\n  a = Array.new(n)\n  for i in 1..n\n    j = n - i\n    a[i] = i\
    \ * i - i + j\n  end\n  i = 0\n  while i < n\n    j = n - i\n    k = n - i - j\n\
    \    if a[i] < a[j] and a[i] < a[k]\n      return i\n    end\n    i += 1\n  end\n\
    \  0\nend", "  return 0 if n == 0 else 1\nend", "  a = Array.new(n)\n  for i in\
    \ 0...n\n    a[i] = i * i - i + 1\n  max_triples = 1\n  for i in 0...n\n    for\
    \ j in 0...n\n      if i + j < n\n        sum = sum(a[i + j])\n        if sum\
    \ > max_triples\n          max_triples = sum\n    end\n  end\n  return max_triples\n\
    end", "  arr = [0 for i in range(n)]\n  a = [0 for i in range(n)]\n  c = 0\n \
    \ for i in range(1, n-1)\n    arr[i] = i * i - i + 1\n  for i in arr\n    a[c]\
    \ = i\n    c += 1\n  c = 0\n  for i in range(n-1)\n    if a[i] % 3 == 0\n    \
    \  a[i] = 0\n  for i in range(n-1)\n    for j in range(n-1)\n      if i != j\n\
    \        if a[j] == 0\n          return 1\n        c += 1\n  return 0\nend", " \
    \   arr = Array.new(n)\n    arr.each do |i|\n        arr[i] = i * i - i + 1\n\
    \    end\n    arr.each do |i|\n        arr.each do |j|\n            arr.each do\
    \ |k|\n                if (i != j) && (i != k) && (j != k) && (i * i + j * j +\
    \ k * k == 0)\n                    arr[i] -= i\n                    arr[j] -=\
    \ j\n                    arr[k] -= k\n                    return arr.size # Number\
    \ of triples found\n                end\n            end\n        end\n    end\n\
    end", "  a = Array.new(n)\n  for i in 0...n\n    a[i] = i * i - i + 1 \n  res\
    \ = 1\n  for i in 0...n - 1\n    for j in i+1...n\n      for k in j+1...n\n  \
    \      if a[j] + a[k] == a[i] \n          res +=1\n      end\n    end\n  end\n\
    \  res\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nWhat does this mean? `For each\
    \ i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.`\n<|/ c |>\n<| c\
    \ |>\nThe value of a can be calculated using the formula `a[i] = i * i - i + 1`,\
    \ where i is the index of a element in a array\n<|/ c |>\n<| c |>\nI edited my\
    \ answer, I believe this one is more understandable now\n<|/ c |>\n<| c |>\nThis\
    \ seems like a great solution but I don't understand it. Can you explain what\
    \ each step is doing? I believe it would be more beneficial for me to understand\
    \ it myself instead of having to ask my professor.\n<|/ c |>\n<| a tags=algorithm,ruby\
    \ dscore=0 |>\nThe problem is how to solve this puzzle and to find out how many\
    \ of the possible triple of numbers fit in the given range and which one is the\
    \ largest.\nLet's assume that the given range is n (n is the size of your array)\
    \ and that the array has numbers from 0 to n-1. Let's also assume that you know\
    \ that n+1 is the biggest number that can be added to get another number in our\
    \ range. \nThe first thing to do is find out what is the biggest number that can\
    \ be added in our range.\nIf n is 3, the biggest number that can be added is 2,\
    \ so it's easy to check that the next number would be 3. Now, what if n is 6?\
    \ What is the biggest number that can be added? Well, it's also 2, so that's also\
    \ easy. The biggest number that can be added is 5. So we can also check that the\
    \ next number would be 5 and so on...\nTo find the biggest number that can be\
    \ added we first need to know what is the biggest number that can be added in\
    \ the range of our array. Let's find out it for n=3. We know that 2+3 is 6, so\
    \ we can check that for n=6 we will have to do some math, let's start by assuming\
    \ that n is 6 and that we have numbers 0 to 5 (numbers starting with 0). Next,\
    \ we must know what is the biggest number that can be added in the range 0 to\
    \ 4 (numbers starting with 0). We know that we can add 2 to get the biggest number,\
    \ so we can check ", "  # write your code here\n  sum = 0\n  for i in 1..n\n \
    \   sum += i * i - i + 1\n  sum % 3 == 0\nend\n</cell>\n<text>\nLet's see if it\
    \ works on an example!", "  a = Array.new(n)\n  for i in 0...n-1\n    a[i] = i\
    \ * i - i + 1\n  \n  triples = 0\n  for i in 0...n-1\n    for j in i+1...n\n \
    \     k = i+j\n      \n      while true\n        if a[i] < a[j] and a[j] < a[k]\n\
    \          triples += 1\n          break\n        end\n        \n        if a[i]\
    \ < a[k]\n          break\n        end\n      end\n    end\n  end", "  a = Array.new(n)\
    \ do |i| i * i - i + 1 end\n  a.each_index do |i|\n    k = i + 1\n    until (k\
    \ <= n) do\n      j = (k - 1) + (k - 2) + (k - 3)\n      if (a[j] - a[k]) % 3\
    \ == 0\n        return k\n      end\n      k = k + 1\n    end\n  end\n  return\
    \ nil\nend", "  a = Array.new(n)\n  for i in 0...n\n    a.push(i*i - i + 1)\n\
    \  \n  a.select{|x| x % 3 == 0}\nend", "  a = []\n  a.length(n)\n  puts a.length(n)\n\
    \  a.fill(0)\n  a.each_with_index do |i,j|\n     return i if j > i\n   end\nend",
  "    a = (1..n).to_a\n    a.sort.each_with_index do |x, i|\n        k = i+1\n  \
    \      j = k-1\n        begin\n            next if j > n\n            if x ==\
    \ a[i...k] && x == a[j...k] && a[x] == a[i...j] && a[x] == a[j...k]\n        \
    \        puts x\n                return x\n            end\n        end\n    end\n\
    \    puts \"No triples\"\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThe question\
    \ is about a challenge in codewars called \"Triple Sum\". It is not an interview\
    \ question by any means. You can find the challenge here: https://www.codewars.com/kata/triple-sum/train/ruby\n\
    <|/ c |>\n<| c |>\nThanks for your response. This solution works only for positive\
    \ integers. In the challenge you are allowed to use negative integers as well.\
    \ I've updated the question to include that requirement.\n<|/ c |>\n<| c |>\n\
    Your code does not return the correct answer. For example, it should return 3\
    \ but returns 2. `get_max_triples.call(10)` returns 3. Also `get_max_triples.call(20)`\
    \ returns 3. `get_max_triples.call(5)` returns 2. All the other solutions return\
    \ 0. These are the tests that need to pass: https://drive.google.com/file/d/1gRY4Y9v7VVrOiG4Q-GJ1I6x9hI0J1qGJ/view?usp=sharing\n\
    <|/ c |>\n<| c |>\nI misunderstood your question. I thought you were asking for\
    \ the max number of triples. You are correct, my solution is incorrect and I can't\
    \ figure out why. Thanks for pointing that out\n<|/ c |>\n<| a |>\n<code>", " \
    \ a = Array.new(n)\n  (1..n).each{|i| a[i] = i * i - i + 1}\n  i = 0\n  j = 1\n\
    \  k = 2\n  \n  while i < j and j < k and k <= n\n    if a[i] < a[j] + a[k]\n\
    \      i += 1\n    elsif a[j] < a[j] + a[k]\n      j += 1\n    else\n      k +=\
    \ 1\n    end\n  end", "  a = []\n  for i in 1..n\n    a.push(i*i-i+1)\n  a.uniq.select{|i|\
    \ i%3==0}.length\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThat would be a good\
    \ idea, but doesn't work, because you don't have any idea how to count the elements\
    \ in the array. You know that `a[i] = i * i - i + 1` but the other elements are\
    \ all unknown to you.\n<|/ c |>\n<| c |>\nAh, thanks for pointing that out. I\
    \ didn't know that `uniq` could operate on ranges, sorry for missing that. Now\
    \ I see what you mean.\n<|/ c |>\n<| c |>\nI have updated my answer. Please check\
    \ whether it works for you or not.\n<|/ c |>\n<| c |>\nSorry, I do not understand.\
    \ Your code is wrong: you do not know what is in range 1 ..n. The only valid triples\
    \ are in the range 1 ..n-1: a[0], a[1], a[n-1].\n<|/ c |>\n<| c |>\nI believe\
    \ that my code is still correct because I first count all elements in the array\
    \ and then I check the count for only valid triples. Please check the second code\
    \ that I posted.\n<|/ c |>\n<| a dscore=0 tags=ruby,arrays,algorithm,range |>\n\
    Your question is misleading because you say \"The only valid triple is (1, 7,\
    \ 13).\" which makes it seem like you are expecting it to return 1, when in reality\
    \ it returns 3, because 13 != 3*3 + 1\nIf you are looking to find out the number\
    \ of ways to place three objects in an array such that the sum of the values equal\
    \ a particular number, then the solution is really just to iterate through all\
    \ the possible combinations of three elements and count how many satisfy the desired\
    \ condition.\nIn Ruby:\n<code>", "  a = []\n  for i in 1...n\n    a.push(i*i-i+1)\n\
    \  result = 0\n  \n  for i in a\n    for j in a\n      for k in a\n        if\
    \ i < j < k && a[i] + a[j] + a[k] == i*i*i\n          result += 1 \n    end\n\
    \  end\n  \n  result\nend\n</cell>\n<text>\nExercise\nUse the code above to write\
    \ a function that returns the number of quadruples of numbers \nwhere all numbers\
    \ are positive.", "    max = 1 \n    for i in range(1, n)\n        if i * i >\
    \ n * n * n\n        max = Math.max(max, i * i - i + 1)\n    return max\n</code>\n\
    <|/ a tags=algorithm,ruby |>\n<| c |>\nThanks for the help but I'm having trouble\
    \ understanding your code. I would really appreciate it if you could explain what\
    \ exactly is going on in the code. Thanks!\n<|/ c |>\n<| c |>\nThe explanation\
    \ should be in the code comments. Did you check the explanation in the code comments?\
    \ Let me know if you have any further questions.\n<|/ c |>\n<| c |>\nI just want\
    \ to let you know that I really appreciate your help! I'm fairly new to programming\
    \ so it's all a bit over my head. Do you mind explaining how you got the idea\
    \ to create an array with length n? I understand the concept but I don't understand\
    \ the syntax of the code you wrote. Thanks!\n<|/ c |>\n<| c |>\nBasically, the\
    \ range operator in ruby will loop from 0 to n-1 for you. So, `i = 1` for the\
    \ first iteration, `i = 2` for the second iteration, `i = 3` for the third iteration\
    \ and so on. The loop condition checks that the value of `i * i` doesn't exceed\
    \ the value of `n*n*n`. So, `i` will loop from 1 to `n` and the condition will\
    \ check `i * i > n*n*n`. Hence, `max` will equal `i*n*n-i` when the loop terminates.\n\
    <|/ c |>\n<| c |>\nI understand that the loop will terminate as soon as it exceeds\
    \ the value of n*n*n. But, how did you get n*n*n? I mean, shouldn't the loop stop\
    \ when the value of n*n is less than that?\n<|/ c |>\n<| a dscore=2 |>\n<code>",
  "  a = []\n  (1..n).each do |i|\n    (1..i).each do |j|\n      (1..i).each do |k|\n\
    \        if j > k && a.include?(i + a[j] + a[k]) && (a[i] + a[j] + a[k]) % 3 ==\
    \ 0\n          puts a[i] + a[j] + a[k]\n          break\n        end\n      end\n\
    \    end\n  end\n  puts \"No solution\"\nend", "  if n == 0 \n    0\n  elsif n\
    \ == 1\n    1\n  else\n    max_triples = [0]\n    for i in 1...n\n      min_triples\
    \ = nil\n      for j in i+1...n\n        if i + j - 2 * min_triples > max_triples\n\
    \          max_triples = [i + j - 2 * min_triples]\n        end\n      end\n \
    \     max_triples << min_triples\n    end\n    max_triples.max\n  end\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\nHere is my solution:\n<code>", "  a = [0,\
    \ *1, *2..n]\n  a.sort.each_cons(n) do |k|\n    break if k.sum % 3 == 0\n  end\n\
    \  a\nend", "  a = Array.new(n)\n  n.times do |i|\n    i.times do |j|\n      j\
    \ + 1.times do |k|\n        if a[i] < a[j] && a[j] < a[k]\n          a[i] += 1\n\
    \          a[j] += 1\n          a[k] += 1\n        end \n      end \n    end \n\
    \  end \n  a.count{|x| x%3==0 }\nend \n</cell>\n<code language=julia-0.4>", " \
    \ a = Array.new(n)\n  for i in 1..n\n    a[i] = i * i - i + 1\n  result = 0\n\
    \  for i in 1..n\n    for j in 1..n\n      for k in 1..n\n        if i + j + k\
    \ == a[i] && a[j] + a[k] == a[i] && a[i] + a[j] + a[k] == 3*a[i] && a[j] + a[k]\
    \ + a[i] == 3*a[k] && \n          i != j && j != k && i != k\n          result\
    \ += 1\n        end\n      end\n    end\n  end\n  return result\nend", "  # Your\
    \ code here\n  return 0\nend", "  a = []\n  i = 0\n  while i <= n\n    a.push\
    \ i * i - i + 1\n    i = i + 1\n  end", "  a = Array.new(n) {|i| i*i-1+1}\n  a.each_cons(3)\
    \ { |i,j,k|\n    p i+j+k if i+j+k == a[i]+a[j]+a[k]\n  }\n  a.size\nend", "  a\
    \ = Array.new(n)\n  a.each_index { |i| a[i] = i * i - i + 1 }\n  a.each_cons(3).count\
    \ { |a,b,c| a + b + c == 9 }\nend\n</code>\n<|/ a dscore=3 |>\n<| a dscore=3 tags=ruby\
    \ |>\nYou can use Enumerable#slice_when:\n<code>\nrequire 'enumerator'", "  array.size(n)\n\
    \  array.max(n)\n  \nend\n</cell>\n<code language=julia-1.5>", "  result = 0\n\
    \  a = []", "  a = Array.new(n)\n  for i in 0..(n-1)\n    a[i] = i * i - i + 1\n\
    \  end\n  triples = 0\n  for i in 0..(n-1)\n    for j in (i+1)..(n)\n      if\
    \ a[i] < a[j] and a[i] < a[j+1]\n        triples += 1\n      end\n    end\n  end\n\
    \  puts triples\nend\n</cell>\n<text>\nDay 20 : Odd & Even Numbers\nInput: An\
    \ integer n\nOutput: All odd integers from 1 to n, or all even integers from 1\
    \ to n except the number itself.", "    a = Array.new(n)\n    a.fill(0)\n    a[0]\
    \ = n\n    a.each do |i|\n        (a[i*i-1] + a[i] + a[i+i]) % 3 == 0 ? a[i] +=\
    \ 1: a[i] = 0\n    end\n    a.sum\nend\n</cell>\n<code language=julia-1.0>\n@code_warntype\
    \ get_max_triples(3)\n</cell>\n<text>\nExercise 4\nImplement the get_max_triples\
    \ function using Array", "    arr = (1..n).to_a\n    arr.each_index do |i|\n \
    \     arr[i] = 3*(arr[i]+1)*(arr[i]+2+1)\n    end\n    arr.each do |i|\n     \
    \ arr[i] += arr[i-1]\n    end\n    arr.each do |i|\n      arr[i] = arr[i] % 3\
    \ == 0 ? arr[i] : nil\n    end\n    arr.uniq.length\n  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
