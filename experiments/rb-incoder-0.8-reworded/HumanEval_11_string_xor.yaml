name: HumanEval_11_string_xor
language: rb
prompt: "# Input are two strings a and b consisting only of 1s and 0s.\n# Perform\
  \ binary XOR on these inputs and return result also as a string.\n# >>> string_xor.call(\"\
  010\", \"110\")\n# \"100\"\ndef string_xor(a, b)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_string_xor\n\
  \    candidate = method(:string_xor)\n    assert_equal(\"010010\", candidate.call(\"\
  111000\", \"101010\"))\n    assert_equal(\"0\", candidate.call(\"1\", \"1\"))\n\
  \    assert_equal(\"0101\", candidate.call(\"0101\", \"0000\"))\n  end\nend\n"
completions: ["  return String.new(\"\\001\" * a.size + b.size)\nend", "  bin1 = \"\
    \"\n  bin2 = \"\"\n  \n  # Split strings by 0 and 1, convert them to binary and\
    \ add them to the binaries.\n  a.split(//).map{|i| bin1 += i[/[01]/]}\n  b.split(//).map{|i|\
    \ bin2 += i[/[01]/]}\n  \n  # Return the result as string consisting of binary\
    \ xor.\n  bin1.to_i(2) ^ bin2.to_i(2) \nend\n</cell>\n<code language=julia-0.5>\n\
    string_xor(\"010\", \"110\")\n</cell>\n<text>\nExercise 2\nImplement your string_xor\
    \ function using Julia's inline macro. You should get similar performance as with\
    \ your manual implementation.", "  result = \"\"\n  a.each_byte {|x| result <<\
    \ x.to_s(2) }\n  b.each_byte {|x| result << x.to_s(2) }\n  return result\nend\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nSorry, I just wanted to give this more\
    \ of a \"code golf\" style to show an alternate approach to string concatenation.\
    \ I would not do that in production.\n<|/ c |>\n<| c |>\nThis does not provide\
    \ an answer to the question. To critique or request clarification from an author,\
    \ leave a comment below their post.\n<|/ c |>\n<| c |>\n: I disagree. As I commented\
    \ on his answer, I'm aware that this is an XY problem. My answer does provide\
    \ an answer, even if the problem is unsolvable with Ruby's basic strings. My answer\
    \ is \"no\", and I do not believe this to be an XY problem. Furthermore, my answer\
    \ does *not* contain code golf.\n<|/ c |>\n<| c |>\nI'm sorry I misread your answer,\
    \ you're right. My comment was meant as a response to OP's comment on my answer.\
    \ You did provide a solution that does solve the problem, so I upvoted it.\n<|/\
    \ c |>\n<| c |>\nThank you for providing an answer that does solve the problem.\
    \ However, this answer does *not* answer the question. I'm sorry if my comment\
    \ was not clear. I'm simply pointing out this answer is an XY problem.\n<|/ c\
    \ |>\n<| a tags=ruby |>\nThe other answers posted here don't answer the question,\
    \ they do provide a solution to an XY problem, which I find very poor.\nThe real\
    \ solution is to stop using the string concatenation operator, which is for Strings\
    \ to join together, not for numbers to convert to string. Ruby's core library\
    \ offers String#to_s which is designed for converting a number to a string. \n\
    <code>\na = \"1\"\nb = \"0\"\na ^ b", "  return String.new(a) ^ String.new(b)\n\
    end", "  result = \"\"\n  a.each_byte { |byte| result << (byte ^ b.byte) }\n \
    \ result\nend", "\tbina = binary_converter(a);\n\tbinb = binary_converter(b);\n\
    \tbina_arr = bina.split('');\n\tbinb_arr = binb.split('');\n\tres = [];\n\tfor\
    \ i in 0...bina_arr.length\n\t\tres.push(bina_arr[i] ^ binb_arr[i]);\n\treturn\
    \ res.join(\"\");\nend", "  a = a.to_s\n  b = b.to_s\n  result = \"\"\n  a.each_byte\
    \ do |char| \n    result << char\n    result << (b.include?(char) ? char : char)\n\
    \  end\n  return result.to_s\nend", "  result = []\n  xor_count = 0\n  for a in\
    \ a.chars\n    b = '' if b == 0 else\n      b ^ a\n    result.concat(b.to_s.chars)\n\
    \    xor_count += 1\n  result.concat('').chars.to_a\n  result.reduce(:^)\nend",
  "  return a.unpack('C*').inject(b) { |s, x| s ^ x }\nend", "  a.each_char do |char|\n\
    \    (b.index(char) ? b : a) << char\n  end\nend", "  return a.to_s(2) ^ b.to_s(2)\n\
    end", "  a = a && \"0\" || \"1\"\n  b = b && \"0\" || \"1\"\n  a = [a]\n  b =\
    \ [b]\n  result = \"\"\n  for i in 0..a.length-1\n    result << a[i]\n  end\n\
    \  for i in 0..b.length-1\n    result << b[i]\n  end\n  return result\nend", " \
    \ if a.length != b.length\n    raise \"a and b should have same length\"\n  ret\
    \ = ''\n  for i in 0...a.length\n    ret << a[i] ^ b[i]\n  end\n  return ret\n\
    end\n    ", "  a.upcase!\n  b.upcase!\n  result = \"\"\n  a.each_byte do |x|\n\
    \    b.each_byte do |y|\n      result << x ^ y\n    end\n  end\n  result.upcase!\n\
    \  result\nend\n</code>\nTo check that the above works, I have used the following\
    \ tests:\n<code>\nrequire \"test/unit\"", "  a += ''\n  b += ''\n  x = ''\n  for\
    \ i in 0...a.length\n    x += (a[i] + b[i]).to_s(2).slice!(0, 2)\n  end\n  x\n\
    end", "  a.xor(b).to_s\nend", "  a = string_to_integer(a)\n  b = string_to_integer(b)\n\
    \  return to_s(xor_op(a, bits_to_string(b)))\nend", "  a.unpack(\"C*\").inject(\"\
    \", :^)\nend", "  a = to_s(a)\n  b = to_s(b)\n  size = a.length + b.length\n \
    \ result = \"\"\n  i = 0\n  while i < size\n    if a[i] != b[i]\n      result\
    \ = result + (a[i..i-1] * 0 + b[i..i-1] * 1)\n    end\n    i += 1\n  end\n  result\n\
    end", "  a = a.to_s\n  b = b.to_s\n  a = a.to_i\n  b = b.to_i\n  return a.xor(b).to_s\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nPlease don't post only code as an answer,\
    \ but also provide an explanation of what your code does and how it solves the\
    \ problem of the question. Answers with an explanation are usually more helpful\
    \ and of better quality, and are more likely to attract upvotes\n<|/ c |>\n<|\
    \ c |>\nThis is not the best answer. The reason for that is the use of `each`\
    \ here, which is not needed. You don't need `each` here at all. Just use a comprehension\
    \ instead which would make more sense. `return [string_xor(a, b) for a, b in zip(a,\
    \ b)]`\n<|/ c |>\n<| c |>\nI agree, there are many different solutions to this,\
    \ and I pointed out the most straight-forward one, which uses `zip`.\n<|/ c |>\n\
    <| a dscore=0 |>\nThe function below will give the required output for any length\
    \ of given input string. \n<code>", "  bina = to_binary(a)\n  binb = to_binary(b)\n\
    \  bina.reverse!\n  binb.reverse!\n  return to_binary(bina ^ binb)\nend", "  res\
    \ = a\n  res.succ!\n  while b != \"0\"\n    b = b[1..-1]\n    if a % 2 == 0\n\
    \      a = a / 2\n      res = res + a\n    else\n      a = a * 3 + 1\n      res\
    \ = res + a\n    end\n  end\n  res.succ!\nend", "  a.unpack('C*').pack('CC*')\
    \ ^ b.unpack('C*').pack('CC*')\nend", "  a = a.to_s(2)\n  b = b.to_s(2)\n  c =\
    \ Array.new(b.length, 0)\n  a.each_byte { |c| c[0] = c[0] ^ b[0] }\n  a.each_byte\
    \ { |c| c[1] = c[1] ^ b[1] }\n  c = c.join.to_s(2)\n  c.length == 2 ? c : nil\n\
    end", "  a ^ b\nend", "  a_bin = \"\"\n  b_bin = \"\"\n  a.each_byte { |x| a_bin\
    \ << x.to_s(2) }\n  b.each_byte { |x| b_bin << x.to_s(2) }\n  a_bin.xor(b_bin).to_s(2)\n\
    end", "  a_bin = to_bin(a)\n  b_bin = to_bin(b)\n  bina_bin = to_bin(a_bin ^ b_bin,\
    \ 2)\n  bina_bin[/^1/] = \"\"\n  return bina_bin\nend", "  return a.gsub(/(..)(..)/,'\\\
    1\\2').gsub(/(..)(..)/,'\\1\\2').gsub(/(..)(..)/,'\\1\\2')\nend", "  a.reverse\
    \ if a.size < b.size\n  b.reverse if a.size < b.size\n  a = a.join # convert string\
    \ to array\n  b = b.join # convert string to array\n  result = []\n  a.each_index\
    \ do |i|\n    b.each_index do |j|\n      result << a[i] ^ b[j]\n    end\n  end\n\
    \  result.join # convert array to string\nend\n</code></pre>\n<h2>\n<a id=\"response-examples\"\
    >Response Examples</a>\n</h2>\n<pre class=\"highlight shell tab-shell\"><code><span\
    \ class=\"c\"># Get a review on a code comment you own</span>\n$ curl <span class=\"\
    s2\">\"https://api.github.com/repos/octokit/octokit.rb/issues/comments/1?access_token=ghgh\"\
    </span>\n<span class=\"err\"># or</span>\n$ curl <span class=\"s2\">\"https://api.github.com/repos/octokit/octokit.rb/issues/comments/1?access_token=ghgh\"\
    </span> -H<span class=\"s2\">\"Accept: application/vnd.github.groot-preview\"\
    </span>\n{\n  <span class=\"s2\">\"id\"</span>: <span class=\"m\">1</span>,\n\
    \  <span class=\"s2\">\"node_id\"</span>: <span class=\"s2\">\"MDExOkNvbW1hbmQgU3RyaW5n\"\
    </span>,\n  <span class=\"s2\">\"path\"</span>: <span class=\"s2\">\"/repos/octokit/octokit.rb/issues/comments/1\"\
    </span>,\n  <span class=\"s2\">\"body\"</span>: <span class=\"s2\">\"Test comment\"\
    </span>,\n  <span class=\"s2\">\"html_url\"</span>: <span class=\"s2\">\"https://github.com/octokit/octokit.rb/issues/1\"\
    </span>,\n  <span class=\"s2\">\"user\"</span>: {\n    <span class=\"s2\">\"login\"\
    </span>: <span class=\"s2\">\"octokit\"</span>,\n    <span class=\"s2\">\"id\"\
    </span>: <span class=\"m\">1</span>,\n    <span class=\"s2\">\"node_id\"</span>:\
    \ <span class=\"s2\">\"MDQ6VXNlcjE=\"</span>,\n    <span class=\"s2\">\"avatar_url\"\
    </span>: <span class=\"s2\">\"https://github.com/images/error/octocat_happy.gif\"\
    </span>,\n    <span class=\"s2\">\"gravatar_id\"</span>: <span class=\"s2\">\"\
    \"</span>,\n    <span class=\"s2\">\"url\"</span>: <span class=\"s2\">\"https://api.github.com/users/octokit\"\
    </span>,\n    <span class=\"s2\">\"html_url\"</span>: <span class=\"s2\">\"https://github.com/octokit\"\
    </span>,\n    <span class=\"s2\">\"followers_url\"</span>: <span class=\"s2\"\
    >\"https://api.github.com/users/octokit/followers\"</span>,\n    <span class=\"\
    s2\">\"following_url\"</span>: <span class=\"s2\">\"https://api.github.com/users/octokit",
  "  a.to_i(2).xor_with(a.to_i(2))\n  b.to_i(2).xor_with(b.to_i(2))\n  a.to_s(2).reverse.xor(b.to_s(2).reverse).reverse\n\
    end", "  a.each_byte { |b| result << b ^ a.bytes[0,1] }\n  result\nend", "  return\
    \ [a.bxor(b), a.length].pack(\"A*\")\nend", "  return ((a ^ b).to_s + \"0\" *\
    \ (len(a) - len(b))).rstrip\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=0 |>\n\
    <code>\na = \"0\" * 3 + \"1\" * 3\nb = \"0\" * 3 + \"1\" * 3\nputs b.gsub(/0/,\
    \ \"0\") + (a[0,2].chars.to_a + a[3,5].chars.to_a + a[6,8].chars.to_a).join\n\
    </code>\n<|/ a tags=ruby |>\n<| a tags=ruby |>\nIn case you want to avoid regular\
    \ expressions, here's another way to do it that might be easier to understand:\n\
    <code>", "  a = a.to_s(2)\n  b = b.to_s(2)\n  result = (a^b).to_s(2)\n  result\
    \ += (result.length < a.length ? \"0\" : \"\")\n  return result\nend", "  a.each_byte\
    \ { |x| a << 1 if (a ^ x) == x }\n  b.each_byte { |x| a << 1 if (b ^ x) == x }\n\
    \  a\nend", "    return (\"{:b}\".format(bin(int(a, 2) ^ int(b, 2)).translate(None,\
    \ string.whitespace)))\nend", "  c = \"\"\n  \n  a.each_char do |char|\n    if\
    \ char ^ b.include?(char)\n      c << char\n    end\n  end\n  c\nend", "  a ^\
    \ b\nend", "  a.each_char.inject(\"\") do |s, c| s << c ^ b end\nend", "  return\
    \ \"\"\nend", "    return xor2int(a.to_i(2), b.to_i(2))\nend", "  r = \"\"\n \
    \ i = 0\n  while i < a.length && i < b.length\n    if (a[i..i+1] == b[i..i+1])\n\
    \      r += a[i..i+1]\n      i += 1\n    end\n    i += 1\n  end\n  return r\n\
    end", "  a.each_byte {|c| a << 1 if (c ^ b.byte) != 0 }\n  a.reverse\n  a\nend",
  "  result = \"\"\n  a.each_byte { |b| result += b.chr if b == 0 }\n  b.each_byte\
    \ { |b| result += b.chr if b == 0 }\n  result\nend", "  return b.unpack('C*').map\
    \ { |x| a ^ x }\nend", "  result = a\n  a.each_byte { |c| result = result ^ c\
    \ }\n  result\nend", "  a = to_binary(a)\n  b = to_binary(b)\n  result = ''\n\
    \  i = 0\n  while i < a.length\n    c = a[i]\n    d = b[i]\n    result << ((c^d)\
    \ & 0x1)\n    i +=1\n  end\n  return result\nend", "  a ^ b\nend", "  return a.unpack('C*').map\
    \ { |b| (a.include?(b) ? b : '0') }.pack('C*')\nend", "  return a ^ b\nend", " \
    \ result = xor(a, b)\n  result = result + a[result]\n  result << 1\n  result <<\
    \ 2\n  result.to_s\nend", "  a_bin = binary_to_base(a, 2)\n  b_bin = binary_to_base(b,\
    \ 2)\n  xor = Array.new\n  for i in 0..a.length\n    xor << (a_bin[i]) ^ (b_bin[i])\n\
    \  end\n  result = binary_to_base(xor, 2)\n  return result\nend", "  return a.chars.sort.inject(\"\
    \") do |carry, c|\n    carry += (c == \"1\") ? b : c\n  end\nend", "  result =\
    \ \"\"\n  \n  for i in (0..(length(a) - 1))\n    result += (Integer(a[i])^Integer(b[i])).to_s\n\
    \  end\n  \n  return result\nend", "  a ^= b\n  a.to_s(2).reverse.gsub(/./) {\
    \ |s| s.zero? ? \"1\" : \"0\" }.to_s\nend", "  return a.gsub(/1/, \"0\").gsub(/0/,\
    \ \"1\").gsub(/0/, \"1\")\nend", "  a.unpack('C*').join(a.unpack('C*').map{|e|\
    \ (e ^ b.unpack('C*').first)}) rescue \"1\"\nend", "  string_to_int = lambda string:\
    \ string == \"1\".to_i ? 1 : 0\n  a_in_bytes = a.to_s.split(\"\").map(&:to_i)\n\
    \  b_in_bytes = b.to_s.split(\"\").map(&:to_i)\n  result = \"\"", "  string_to_binary(a).xor_string(b).to_s\n\
    end", "  return \"#{a.gsub(/./, \"*\")} #{b.gsub(/./, \"*\")}\"\nend", "    a.each_char\
    \ do |c|\n        b << c if b[c] == '1'\n    end\n    b = b.join # convert to\
    \ string\n    a.each_char do |c|\n        b << c if b[c] == '0'\n    end\n   \
    \ b = b.join # convert to string\n    return b\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nI like this one. Not sure why I didn't think of this. Thanks!\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>", "  # convert input to binary string\n  a_int\
    \ = binary_to_int(a)\n  b_int = binary_to_int(b)", "  a.each_byte { |x| a ^= x\
    \ }\n  b.each_byte { |x| b ^= x }\n  a.to_s\nend", "  binstring = 0\n  binstring\
    \ = (b << 1) ^ a\n  binstring = binstring.to_s(2)\n  binstring = binstring[0..1]\n\
    \  binstring = \"0\" * (4 - binstring.length) + binstring\n  binstring = binstring.ljust(4,\"\
    0\")\n  puts binstring\nend", "  if a.length != b.length\n    raise(ArgumentError,\
    \ \"Arguments must be of same length.\")\n  result = ''\n  for i in 0...a.length\n\
    \    result << (a.charAt(i) ^ b.charAt(i))\n  end\n  return result\nend", "  result\
    \ = 0\n  for i in (0..a.length)\n    result = result + (a[i..i] + b[i..i]) <<\
    \ (i*2)\n  return result\nend", "  return a.gsub(/./, \"1\").gsub(/./, \"0\").gsub(/./,\
    \ \"1\").gsub(/./, \"0\").gsub(/./, \"1\").gsub(/./, \"0\").gsub(/./, \"1\").gsub(/./,\
    \ \"0\")\nend", "  return a.xor(b)\nend", "  a, b = (a + \"0\") * 8, (b + \"0\"\
    ) * 8\n  c = a.unpack(\"C*\") ^ b.unpack(\"C*\")\n  c.pack(\"C*\")\nend", "  a\
    \ = a.to_s.split(\"\").map { |x| x.to_i }\n  b = b.to_s.split(\"\").map { |x|\
    \ x.to_i }\n  a.reduce(:^)\nend\n  ", "  return [a[0].to_s(2).reverse, a[1].to_s(2).reverse].\n\
    \    map{|x| x.reverse.inject(&:^)}.join(\"\")\nend\n</pre>\n</div>", "  xor =\
    \ a.xor b\n  return xor\nend", "  a = a.to_s\n  b = b.to_s\n  xor = [\n    a.count(0).to_s\
    \ + b.count(0).to_s,\n    a.count(1).to_s + b.count(1).to_s,\n    a.count(2).to_s\
    \ + b.count(2).to_s\n  ].max\n  \"#{xor}\".to_i(2).to_s(2).reverse\nend", "  xor(a,b).to_s\n\
    end", "  result = a.unpack('C*')\n  result[0] = result[0] ^ b.unpack('C*')\n \
    \ result.pack('C*')\nend", "  if a.size != b.size\n    raise ArgumentError, \"\
    The string size must be same for both a and b\"\n  end", "  return a.xor(b).to_s\n\
    end", "  xor(a, b)\nend", "\ta = a.to_s.gsub(/[^01\\s]/, \"\")\n\tb = b.to_s.gsub(/[^01\\\
    s]/, \"\")\n\treturn binary.call(a, b, :bitwise => :xor)\nend", "  a = binary_to_dec(a)\n\
    \  b = binary_to_dec(b)\n  c = []\n  for i in 0..31\n    c[i] = a ^ b\n    a =\
    \ a >> 1\n    b = b >> 1\n  return dec2bin( c[0] )\nend", "  result = \"\"\n \
    \ a.each_byte { |x| result << \"1\" if (x ^ b).zero? }\n  b.each_byte { |x| result\
    \ << \"0\" if (x ^ a).zero? }\n  result\nend\n</code>\n<|/ a tags=ruby,xor,bitwise-xor,bit-manipulation,algorithm\
    \ |>\n<| a dscore=1 |>\nI like to use the String#unpack method for this sort of\
    \ thing, particularly for longer strings:\n<code>", "  a, b = a.to_s.chars.map(&:ord),\
    \ b.to_s.chars.map(&:ord)\n  (a[0] ^ b[0]).chr\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThis looks more like some sort of hack.\n<|/ c |>\n<| c |>\nYeah, this\
    \ isn't really the most efficient way of doing it.  A simple loop will be much\
    \ faster (especially on large strings) than this `map` call.\n<|/ c |>\n<| c |>\n\
    : It is indeed a hack. While it works, it does so by converting the strings to\
    \ arrays of characters and then doing a carry-over XOR on the elements of the\
    \ arrays. This is indeed a fairly costly operation and so is not the most optimal\
    \ solution.\n<|/ c |>\n<| c |>\n: I agree that this is probably not very efficient.\
    \  It is a useful exercise though, and I was curious what the most efficient way\
    \ would be to solve this problem.  I believe that a simple loop is probably the\
    \ best way to go for now, and I'll also see if I can come up with a more efficient\
    \ solution later.\n<|/ c |>\n<| a |>\nHere's another solution with recursion:\n\
    <code>", "    a.unpack(\"C*\") || raise(TypeError, \"Invalid type of arguments\
    \ for xor.\")\n    b.unpack(\"C*\") || raise(TypeError, \"Invalid type of arguments\
    \ for xor.\")\n    a.unpack(\"C*\") && b.unpack(\"C*\") || raise(TypeError, \"\
    Invalid type of arguments for xor.\")\n    a.unpack(\"C*\") ^= b.unpack(\"C*\"\
    ) || \"Invalid type of arguments for xor.\"\n    return a.unpack(\"C*\").join.chr\n\
    end", "  c = a.unpack('C*').map{|e| e ^ b.unpack('C*').first}\n  c.pack('C*')\n\
    end\n</pre>\n</div>", "    a.each_char.map { |i| i.to_s(2).xor(b.to_s(2)).to_s(2)\
    \ }.join\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThat should probably be `a.each_char.map(&:to_s).join('')`\n\
    <|/ c |>\n<| a dscore=1 |>\nHere's a very short Ruby implementation:\n<code>",
  "  return b.gsub(/./) do |char|\n    if a.include? char\n      \"1\"\n    else\n\
    \      \"0\"\n    end\n  end\nend\n</cell>\n<text>\nNow define the call method\
    \ that we just defined earlier for the above two strings.", "  xor = a.to_i(2)\
    \ ^ b.to_i(2) \n  (xor == 0 ? \"0\" : ((xor < 10 ? \"0\" : \"1\") + xor.to_s(2))).to_s(2)\n\
    end", "  a.each_byte { |b| a_bit_xor.push(b) }\n  b.each_byte { |a| a_bit_xor.push(a)\
    \ }\n  a_bit_xor.reverse.join\nend", "  result = \"\"\n  i = j = 0\n  while i\
    \ < a.length && j < b.length\n    case a[i] <=> b[j]\n    when -1\n      result\
    \ << 0\n    when 0\n      result << 1\n    when 1\n      result << 1\n    end\n\
    \    i += 1\n    j += 1\n  end\n  return result\nend", "  return a ^ b\nend",
  "  a.xor_b b\nend", "  return bin(a ^ b).reverse.strip.gsub(\"1\",'0').gsub(\"0\"\
    ,'1').reverse\nend", "  xor_a = xor_with_bits(a, b)\n  xor_b = xor_with_bits(b,\
    \ a)\n  xor_result = xor_with_bits(xor_a, xor_b)\n  xor_result.upcase!\n  xor_result\n\
    end", "  return \"#{a[0, b.size]}.#{b[0, a.size]}\"\nend", "  a = a.to_s(2).reverse\n\
    \  b = b.to_s(2).reverse\n  a << b\n  a.each_byte {|c| return c if xor a, c }\n\
    end", "  bin1 = a.unpack(\"C*\").reverse.pack(\"C*\")\n  bin2 = b.unpack(\"C*\"\
    ).reverse.pack(\"C*\")\n  bin1.each { |x| bin2.each { |y| x ^ y } }\n  bin1.unpack(\"\
    C*\").join\nend", "    binX = a[0]\n    binY = b[0]\n    x = \"\"\n    y = \"\"",
  "  return '1' ^ '0' ^ a ^ '0' ^ b\nend", "  result = 0\n  for i in 0..(size(a) -\
    \ 1) do\n    result |= (ord(a[i]) ^ ord(b[i]))\n  end\n  return result\nend",
  "    a.gsub!(/0/) { 1 }\n    b.gsub!(/0/) { 1 }\n    a.gsub!(/1/) { 0 }\n    b.gsub!(/1/)\
    \ { 0 }\n    a.reverse!\n    b.reverse!\n    a.reverse!\n    b.join.reverse!\n\
    \  end\nend", "  a.each_byte { |x| b << x.to_s }\n  b.each_byte { |x| a << x.to_s\
    \ }\n  a.join\nend\n</pre>\n<p>We can test our function like this:</p>\n<pre class=\"\
    code\">", "  return a.xor b\nend", "    return a.to_s(2).xor b.to_s(2).to_s(2)\n\
    end", "  b = b.to_s(2)\n  a = a.to_s(2)\n  bin = a.chars.inject(\"\"){|a, e| a\
    \ << e ^ b}\n  result = bin.to_s(2).rjust(8, 0)\n  puts result\nend", "  xor_chars\
    \ = 0..31\n  xor = 0\n  xor_sum = 0\n  a.each_byte do |char_a|\n    b.each_byte\
    \ do |char_b|\n      xor_chars[xor_chars.index(char_a) + xor_chars.index(char_b)]\
    \ += char_a * char_b\n      xor_sum += char_a * char_b\n    end\n  end\n  xor_chars.each_index\
    \ do |idx|\n    xor += xor_chars[idx] * xor_sum\n  end\n  xor = xor.to_s(2)\n\
    \  if xor.length != b.length\n    xor = b.clone\n  end\n  return xor\nend\nmodule_function\
    \ :string_xor", "    \n    # convert binary strings to corresponding ASCII and\
    \ XOR\n    # ASCII of empty string is 0\n    a_bin_ascii_arr = a.split(//).map\
    \ { |i| i.to_i.to_s(2) }\n    b_bin_ascii_arr = b.split(//).map { |i| i.to_i.to_s(2)\
    \ }\n    \n    result = a_bin_ascii_arr.zip(b.split(//)).map { |i, j| i ^ j }.join(\"\
    \")\n    \n    return result\nend", "  a = \"0\" + a if a.length < 4 else a\n\
    \  b = \"0\" + b if b.length < 4 else b\n  (a.length < 4 ? a : a + \"0000\")^(b\
    \ < \"0\" : b + \"0000\")\nend", "  xor = a.unpack('C*').map {|x| x^b.unpack('C*').first}.join(\"\
    \").reverse\n  xor.length.times.reduce(\"\", xor)\nend\n</code>\nThe method call\
    \ is used as follows:\n<code>\nstring_xor('010', '110')\n=> \"100\"\n</code>\n\
    Note that in Ruby 2.3 or earlier, this implementation would use unpack('C*').map\
    \ {|x| x ^ b.first}.join, since String#^ was introduced as a synonym for String#|.\n\
    <|/ a |>\n<| c |>\nRuby 2.3 or earlier: use `String#unpack('C*').map {|x| x ^\
    \ b.first}.join`, since `String#^` was introduced as a synonym for `String#|`.\n\
    <|/ c |>\n<| c |>\nthanks, that's definitely better. I've edited my answer accordingly.\n\
    <|/ c |>\n<| a |>\nA little bit late, but for posterity, here's a solution using\
    \ recursion and a bit of metaprogramming:\n<code>", "  a.unpack(\"C*\").inject(:^).pack(\"\
    C*\")\nend", "  result = 0\n  a.each_byte do |x| result |= x ^ b end\n  result\n\
    end", "  a = a.to_s\n  b = b.to_s\n  return a.each_byte.inject(\"\") do |s, byte|\n\
    \    s << (byte ^ b.shift) if (byte ^ b.shift) != 0\n    s\n  end\nend", "  a.each_char.map\
    \ { |c| b & c }.join\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nThanks\
    \ for that Ruby Wayland mention! :)\n<|/ c |>\n<| a tags=ruby,string |>\n<code>",
  "  result = \"\"\n  \n  a.each_byte do |char|\n    result << char if char == \"\
    1\"\n  end\n  b.each_byte do |char|\n    result << char if char == \"1\"\n  end\n\
    \  \n  return result\nend\n</cell>\n<cell>", "  return a.unpack(\"U*\").pack(\"\
    C*\") ^ b.unpack(\"U*\").pack(\"C*\") \nend\nalias_method :^, :string_xor", " \
    \ a.each_byte { |c| return c ^ b.shift }\n  \"\"\nend", "  return \"\".dup.concat(\n\
    \    a.chars.map{ |e| e ^ b }.map { |e| e.to_s(2).upcase }.join )\nend", "  result\
    \ = a.clone\n  a.each_char do |char|\n    result = char.to_s + result if char.to_s\
    \ == \"1\"\n  end\n  b.each_char do |char|\n    result = char.to_s + result if\
    \ char.to_s == \"1\"\n  end\n  return result.to_s\nend", "  a_bin = a.to_s(2)\n\
    \  b_bin = b.to_s(2)\n  return \"#{a_bin ^ b_bin}\"\nend", "  a = a.to_s\n  b\
    \ = b.to_s\n  out = \"\"\n  (length(a) + length(b)).times do\n    out += (a[rand(length(a))].to_i\
    \ ^ b[rand(length(b))].to_i)\n  end\n  out << rand(26)\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThis doesn't seem like an answer to the question \"What's the fastest\
    \ way?\", it seems to be a solution to an issue which was more easily solved by\
    \ another solution which is also faster.\n<|/ c |>\n<| c |>\nI agree. The question\
    \ was how to improve the existing solution. I provided a solution with that solution\
    \ in mind, because I assumed that they were looking for speed and was only interested\
    \ in an approach that would be reasonably fast and not take up too much memory\
    \ for the input. I also thought that my solution was simple, easy to understand\
    \ and easy to implement. However, the OP has provided their own solution, which\
    \ they want to improve on. I had assumed that my solution would be the easiest\
    \ to implement, which is why I posted it. I agree that my solution would be much\
    \ more complicated to implement.\n<|/ c |>\n<| c |>\nThis isn't faster, it's slower,\
    \ it's less readable, it's slower.\n<|/ c |>\n<| c |>\nI agree with that, but\
    \ I felt that my solution would solve the problem the way I intended it to.\n\
    <|/ c |>\n<| c |>\nI agree that my solution would solve the problem, but I don't\
    \ think that it's really an answer to the question. If it was a real answer I'd\
    \ have upvoted it instead.\n<|/ c |>\n<| a dscore=1 tags=encryption,string,ruby\
    \ |>\nI went ahead and made a little script to test various versions:\n<code>\n\
    require 'benchmark'\nrequire 'digest/sha2'", "  xor_a = binary_xor a.to_i(2),\
    \ a.to_i(2).to_s(2)\n  xor_b = binary_xor b.to_i(2), b.to_i(2).to_s(2)\n  return\
    \ xor_a xor xor_b\nend", "  a && a.reverse || a\n  b && b.reverse || b\n  a =\
    \ [a].pack(\"B*\")\n  b = [b].pack(\"B*\")\n  c = \"\"\n  a.each_byte{|b| c <<\
    \ (b.xor(b).to_s(2))}\n  b.each_byte{|b| c << (b.xor(b).to_s(2))}\n  c.reverse\n\
    end", "    a.to_i(2).xor b.to_i(2).to_s(2)\nend", "  a.xor b\nend", "  return\
    \ a ^ b\nend\n</cell>\n<text>\nTask 7: Create and use your own module for string\
    \ operations - string length operation. Implement following string length operations:",
  "\ta.upcase!\n\tb.upcase!\n\tx = \"\"\n\tfor i in 0...a.length\n\t\tif a.slice!(i).to_i(2)\
    \ ^ b.slice!(i).to_i(2)\n\t\t\tx.concat!(i)\n\t\tend\n\tend\n\tx\nend\n</cell>\n\
    <cell>", "  s = ''\n  a += b.upcase\n  b = b.upcase\n  a.each_char { |e| s +=\
    \ (e^b) }\n  return s\nend\n</cell>\n<text>\nWrite a program to print the ASCII\
    \ values of the characters in string s \ncontaining only 1s and 0s.", "  result\
    \ = \"\"\n  a_int = a.to_i(2).to_s(2)\n  b_int = b.to_i(2).to_s(2)\n  a_int.each_char\
    \ { |v| result += v * (b_int.index(v) * 2) }\n  result\nend", "  a ^ b\nend",
  "  a = a.to_s\n  b = b.to_s", "  return a.chars.zip(b.chars).inject(:^)\nend\n</pre>\n\
    </td>\n</tr>\n<tr>\n<td class=\"docs\">\n<pre>", "  return a^b\nend", "  a ^ b\n\
    end", "  result = xor(a, b)\n  result = \"\" + result\n  return result\nend",
  "  a = a.to_s # String -> String\n  b = b.to_s # String -> String\n  a = a.chars\
    \ # Array -> Array\n  b = b.chars # Array -> Array\n  a.map!{|e| e.to_i}\n  b.map!{|e|\
    \ e.to_i}\n  puts a.map { |e| e ^ b[e] }.join('')\nend\n</cell>\n<cell>", "  s\
    \ = \"\"\n  a.each_char.with_index do |ch, i|\n    s += (ch ^ b[i])\n  end\n \
    \ s\nend", "  a.each_byte { |c| a << c ^ b }\n  a\nend\nputs string_xor.call(\"\
    010\", \"110\")", "  a.each_byte { |x| a << x }\n  b.each_byte { |x| b << x }\n\
    \  a.each_byte { |x| b << x }\n  b.each_byte { |x| a << x }\n  return a.join\n\
    end\n</pre>\n<p>\nThis code runs four binary XOR operations. There are two loops,\
    \ each of which runs a binary XOR operation on a\nbyte, which in Ruby is done\
    \ by taking the bitwise XOR of each byte in both strings. The results are then\
    \ collected\ninto a new string and returned to the caller.\n</p>\n<p>\nIn each\
    \ loop, the loop is run to collect the output from the binary XOR operation and\
    \ append it to the output string.\nThe first loop is run twice to perform the\
    \ two binary XOR operations on a, then on b. Finally, the last loop\nis run to\
    \ perform the two binary XOR operations on b, and a again. Since this is done\
    \ to ensure the strings are\nmutually exclusive, this is done in three loops.\
    \ Three loops are required because a single loop would result in\nan infinite\
    \ loop if the two strings were identical. Note that the third loop is performed\
    \ twice and does not do any\nactual processing.\n</p>", "  result = \"\"\n  a.each_byte\
    \ {|bit| result += bit.to_s(2).to_i(2) ^ b.each_byte {|bit| bit.to_s(2).to_i(2)\
    \ }  }\n  result\nend\nputs string_xor(\"010\", \"110\")\n</code>\n<|/ a tags=encryption,ruby,ruby-on-rails,python,algorithm\
    \ |>\n<| a tags=encryption,ruby,ruby-on-rails,python,algorithm dscore=1 |>\n<code>",
  "    a,b = b.to_i, a.to_i\n    return (a.to_s(2) ^ b.to_s(2)).zfill(4)\nend", " \
    \ if a.length == 0 || b.length == 0\n    raise \"String lengths must be non-zero\"\
    \n  end\n  if a.length != b.length\n    raise \"String lengths must be equal\"\
    \n  end\n  result = []\n  for i in 0...a.length\n    result.push(a[i] ^ b[i])\n\
    \  end\n  result.reverse\n  return result.join('')\nend", "  a = a.chars\n  b\
    \ = b.chars\n  return a.inject(:^) do |result, char|\n    result + char if char\
    \ == '1' || char == '0'\n  end\nend\n</cell>\n<text>\nIn the next cell, we define\
    \ two functions that will be used to solve the problem. We will first define the\
    \ function check_valid_answer and then define check_valid_question.", "  result\
    \ = \"\"\n  a.each_char do |char|\n    result << char.to_s ^ b.chars.to_s << char\n\
    \  end\n  result\nend", "  a = a.to_s.split(\"1\").map { |c| c == c ? \"1\" :\
    \ \"0\" }\n  b = b.to_s.split(\"1\").map { |c| c == c ? \"1\" : \"0\" }\n  a.reverse.zip\
    \ b.reverse.map { |a, b| a ^ b }.join(\"1\").gsub(/1/, \"0\")\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a |>\n<code>\nfunction xor(a,b) {\n   var a_bits = a.match(/[01]+/g);\n\
    \   var b_bits = b.match(/[01]+/g);\n   return a_bits.reduce((p,c,i) => (p^b_bits[i])\
    \ ? c : p ).join('');\n}", "  result = \"\"\n  a.each_byte { |c| result << (c^b)\
    \ }\n  result\nend", "  return a.to_i(2).xor(b.to_i(2)).bin\nend", "\txor_a  =\
    \ xor(a, b)\n\txor_b = xor_a ^ a\n\txor_c =  xor_b ^ b\n\txor_d =  xor_c^b\n\t\
    xor_e =  xor_d ^ a\n\txor_f =  xor_e^a\n\treturn xor_f\nend", "  return (a^b).to_s\n\
    end", "  result = \"0\"\n  a = a.to_s\n  b = b.to_s\n  a.each_char { |x| result\
    \ += \"1\" if x != b.at(a.length - 1) }\n  result + \"0\"\nend", "  return [a.chars.zip(b.chars).map\
    \ { |c| c.reduce(:^) }].join\nend", "    bin1 = bin(a)\n    bin2 = bin(b)\n  \
    \  return \"#{i:>4}x#{j:>4} #{bin1}#{bin2}\" unless bin1 == bin2\n    bin1.reverse!\n\
    \    bin2.reverse!\n    bin1.zip(bin2).map { |x, y| x ^ y }.reverse!\n    \"#{i:>4}x#{j:>4}\
    \ #{bin1}#{bin2}\"\nend", "  b.each_byte {|b| a << b if b == 1}\n  a.join '' \n\
    end\n    ", "  a.each_char.map { |c| c ^ b.shift }.join\nend", "  return a.xor(b).to_s\n\
    end", "  xor = String.new\n  xor.length(a.length)\n  a.each_byte do |a_char|\n\
    \    b.each_byte do |b_char|\n      xor[xor.size-1] ^= (a_char ^ b_char)\n   \
    \ end\n  end\n  xor\nend", "  return a.to_s.gsub(/[^01]/, '').xor(b.to_s.gsub(/[^01]/,\
    \ '')).to_s\nend", "  a.to_i(2).xor b.to_i(2).to_s(2).to_i(2).to_s(2)\nend", " \
    \ return String.new([a,b].map { |x| x ^ b }.join)\nend", "  return \"#{a[0..-1]}#{b[0..-1]}\"\
    \nend", "  if a.to_s.length != b.to_s.length\n    raise ArgumentError, \"XOR:\
    \ incompatible lengths\"\n  a = a.to_s\n  b = b.to_s\n  s = \"\"\n  for i in 0...a.length\n\
    \    s << (a[i] ^ b[i])\n  end\n  s\nend", "  # Only support binary operations\
    \ with strings.\n  # Raise if these inputs are not strings.\n  raise \"Only support\
    \ binary operations with strings.\" unless a.class == String\n  raise \"Only support\
    \ binary operations with strings.\" unless b.class == String\n  return a.unpack(\"\
    b*\").inject(:^).pack(\"b*\")\nend", "  a = a.to_s\n  b = b.to_s\n  if a.length\
    \ == b.length\n    a.each_char.with_index do |char, index|\n      a << char if\
    \ a[index] != b[index]\n    end\n    a\n  else\n    \"invalid inputs\"\n  end\n\
    end", "  result = \"\"\n  i = 0\n  while i < a.length\n    result << a.slice!(0,\
    \ 1) ^ b.slice!(0, 1)\n    i += 1\n  end\n  result\nend", "\tstring_xor.call(a,b)\n\
    end", "  c = a ^ b\n  d = c.to_s\n  e = \"\"\n  for i in d\n    e = e.concat(i)\n\
    \  return e\nend", "  a ^ b\nend", "  a ^= b\n  a = \"0\" if (a < 10) else a.to_s.rjust(2,\
    \ '0')\n  b ^= a\n  b = \"0\" if (b < 10) else b.to_s.rjust(2, '0')\n  return\
    \ a + b\nend", "  result = []\n  a_array = a.to_s.split(\"\")\n  b_array = b.to_s.split(\"\
    \")\n  result = []\n  a_array.each_with_index do |char1, i|\n    b_array.each_with_index\
    \ do |char2, j|\n      result << char1 ^ char2 if i == j\n    end\n  end\n  result.join\
    \ \"\"\nend\n</code>\nWe can also use the same logic with the XOR method from\
    \ bitwise gem:\n<code>", "  xor_result = a.unpack(\"C*\").map { |e| e ^ b.unpack(\"\
    C*\").first }\n  result = xor_result.pack(\"C*\")\n  if result == \"\"\n    \"\
    \"\n  else\n    result\n  end\nend", "    a, b = [x.to_i(2) for x in [a, b]]\n\
    \    a ^= b\n    b = a.to_s(2)\n    a = b.to_i(2) if a.to_s(2) == b\n    return\
    \ a.to_s(2)\nend", "  a ^ b\nend\n\"\"\"\nfunction string_xor(::Nothing,\n   \
    \                 ::Nothing,\n                    kwargs...)\n  raise ArgumentError,\
    \ \"all arguments must be strings\" if type(a) != String\n  raise ArgumentError,\
    \ \"all arguments must be strings\" if type(b) != String\n  a  = convert(String,\
    \ a)\n  b = convert(String, b)\n  raise ArgumentError, \"'a' and 'b' must be the\
    \ same length\" unless length(a) == length(b)\n  raise ArgumentError, \"all arguments\
    \ must be strings\" if a.chars.sort.uniq.length == 0 || b.chars.sort.uniq.length\
    \ == 0\n  raise ArgumentError, \"string contains invalid characters\" unless a.chars.sort.uniq.size\
    \ == b.chars.sort.uniq.size\n  raise ArgumentError, \"all arguments must be valid\
    \ numbers\" if !(a.chars.sort.uniq.count + b.chars.sort.uniq.count) == 0 # or\
    \ a.chars.sort.uniq.size + b.chars.sort.uniq.size == 0\n  if a.chars.sort.uniq.size\
    \ != b.chars.sort.uniq.size\n    raise ArgumentError, \"'a' and 'b' must be the\
    \ same length\"\n  end\n  \n  x = a\n  y = b\n  while true\n    raise ArgumentError,\
    \ \"all arguments must be valid numbers\" if !x.chars.sort.uniq.count + y.chars.sort.uniq.count\
    \ == 0\n    raise ArgumentError, \"'a' and 'b' must be the same length\" unless\
    \ length(x) == length(y) \n    raise ArgumentError, \"'a' must be a number or\
    \ string\" if x.chars.sort.uniq.size != 1 || x.chars.sort.uniq.count != 1\n  \
    \  raise ArgumentError, \"'b' must be a number or string\" if y.chars.sort.uniq.size\
    \ != 1 || y.chars.sort.uniq.count != 1\n    raise ArgumentError, \"'a' must be\
    \ a number or string\" if !is_number(x) || !is_number(y)\n    raise ArgumentError,\
    \ \"'a' must be a number\" if !is_number(x) \n    raise ArgumentError, \"'b' must\
    \ be a number\" if !is_number(y) \n    raise ArgumentError, \"'a' must be a number\"\
    \ if !is_number(a) || !is_number(b)\n    raise ArgumentError, \"'b' must be a\
    \ number\" if !is_number(b) || !is_number(a)\n    raise ArgumentError, \"'a' must\
    \ be a number\" if !is_number(a) || !is_number(b)\n    raise ArgumentError, \"\
    'b' must be a number\" if !is_number(b) || !is_number(a)\n    raise ArgumentError,\
    \ \"'a' must be a number\" if !is_number(a) || !is_number(b)\n    raise ArgumentError,\
    \ \"'b' must be a ", "  # Split a and b\n  aSplit = a.split(\"\")\n  bSplit =\
    \ b.split(\"\")\n  # Perform XOR on all chars in aSplit with corresponding chars\
    \ in bSplit.\n  # This assumes that all chars in aSplit are represented with digits\
    \ and \n  # all chars in bSplit are represented with digits.\n  # XOR operation\
    \ is performed by applying the XOR operation on the corresponding \n  # chars.\n\
    \  # This assumes that the character representation for digits is \n  # same as\
    \ that for corresponding chars. i.e. if the character representation of \n  #\
    \ a is \"5\", then there will be a char representation for \"5\" which is \"0000101\"\
    .\n  xStr = \"\"\n  for i in range(0, aSplit.length):\n    xStr += aSplit[i] ^\
    \ bSplit[i]\n  return xStr\nend\n</code>\nHere are some test cases:\n<code>",
  "  xor = a.unpack('C*').inject(:^)\n  xor = xor.to_s.reverse.unpack('C*').inject(:^)\n\
    \  xor = xor.to_s.reverse.unpack('C*').inject(:^)\n  return xor\nend", "  a =\
    \ a.to_s(2)\n  b = b.to_s(2)\n  c = (a^b).to_s(2)\n  return c\nend", "  # Convert\
    \ strings to list of integers\n  a = a.split(\"\")\n  b = b.split(\"\")\n  # Perform\
    \ XOR for each pair of corresponding characters in the strings\n  result = \"\"\
    \n  a.each_with_index do |a_c, i|\n    b.each_with_index do |b_c, j|\n      result\
    \ << a_c ^ b_c\n    end\n  end\n  return result\nend", "  a = a.to_s\n  b = b.to_s\n\
    \  result = \"\"\n  a.each_byte { |c| result += b ^ c }\n  return result\nend",
  "  a, b = a.to_i(2), b.to_i(2) # Convert strings to integers\n  xor_value = a.xor\
    \ b # xor operation on integers\n  xor_result = xor_value.to_s(2) # Convert integer\
    \ to string and return\n  xor_result.to_i(2) # Convert the result back to integer\n\
    end\n</cell>\n<text>\nTo check if a string is palindrome or not we need to do\
    \ XOR of its characters with it's reverse characters. If XOR of two strings is\
    \ same in their characters, then strings represent palindrome.", "  a.unpack(\"\
    C*\") + b.unpack(\"C*\").map { |e| (e ^ 0xFF).chr}.join\nend", "  xor_res = \"\
    \"\n  a.each_char do |e|\n    xor_res << e ^ b.shift\n  end\n  xor_res.reverse!\n\
    \  return xor_res.reverse\nend", "    bina = [*a.to_i(2).to_s(2)]\n    binb =\
    \ [*b.to_i(2).to_s(2)]\n    ans = \"\"\n    bina.each_index { |i| ans << (binb[i]\
    \ ? \"1\" : \"0\") }\n    ans\nend\n</pre>\n</div>", "  return \"#{a[0,b.length]}{b[0,a.length]}\"\
    \nend", "  a ^ b\nend", "  return a.gsub(/(\\d)/) { |m| a[$1.to_i].xor b[$1.to_i].to_s}\n\
    end\n</code>\n<|/ a tags=ruby,regex |>\n<| c |>\nThis is exactly the kind of response\
    \ that I was hoping for.  Thanks for the thorough explanation as well as providing\
    \ an example that I was not able to figure out. I'm new to Ruby so this was really\
    \ helpful.\n<|/ c |>\n<| c |>\nOne thing to note is that this doesn't work for\
    \ hexadecimal numbers.\n<|/ c |>\n<| a dscore=3 tags=ruby,regex |>\nRuby's built-in\
    \ gsub method accepts a block:\n<code>", "  return [a,b].pack(\"S*\").reverse.unpack(\"\
    C*\").join(\"0\")\nend", "  a ^= b\n  a = \"%0*b\" % [a.length, a]\n  return a\n\
    end", "  result = \"\"\n  loop do\n    c1 = a.slice!(0, 1) == \"1\"\n    c2 =\
    \ b.slice!(0, 1) == \"1\"\n    result << \"1\" if c1 == c2\n    break if a.length\
    \ == 0 or b.length == 0\n    result << \"0\"\n  end\n  return result\nend", " \
    \ a = a.to_s\n  b = b.to_s\n  if a.length != b.length then return nil\n  result\
    \ = \"0\"*(a.length)\n  (0...a.length).each do |i|\n    result[i] = (a[i] ^ b[i])\n\
    \  end\n  return result\nend\n</pre>", "  xor = a.unpack(\"c*\").inject(0) do\
    \ |sum, item|\n    sum ^ item\n  end\n  xor = xor ^ b.unpack(\"c*\").inject(0)\
    \ do |sum, item|\n    sum ^ item\n  end\n  xor = xor.to_s(2)\nend\n</cell>\n<cell>",
  "  case a\n  when string\n    case b\n    when string\n      # Convert both strings\
    \ to binary, then XOR and convert back to string.\n      a = binary.call(a)\n\
    \      b = binary.call(b)\n      xor = (a.xor(b)).to_s(2)\n      xor.upcase!\n\
    \      xor\n    else\n      raise ArgumentError.new(\"Expected a string, got #{a.inspect}.\"\
    )\n    end\n  else\n    raise ArgumentError.new(\"Expected a string, got #{a.inspect}.\"\
    )\n  end\nend", "  c = a.unpack(\"C*\")\n  c = b.unpack(\"C*\")\n  result = []\n\
    \  result.unshift(a.unpack(\"C*\"))\n  result.unshift(b.unpack(\"C*\"))\n  for\
    \ bytes in result\n    bytes[0] = bytes[0] ^ bytes[1]\n    bytes[1] = bytes[1]\
    \ ^ bytes[0]\n    bytes[0] = bytes[0] & bytes[1]\n    bytes[1] = bytes[1] & bytes[0]\n\
    \    bytes[0] = bytes[0].to_s(2)\n    bytes[1] = bytes[1].to_s(2)\n  end\n  result\
    \ = result.join(\"\").chomp\nend", "  if a.length != b.length\n    raise ArgumentError,\
    \ \"String sizes are not equal.\"\n  result = ''\n  for x in 0...a.length\n  \
    \  result << ((a[x] ^ b[x]) & 0xff)\n  end\n  return result\nend", "  b.each_byte\
    \ { |b| a << b }\n  a.to_s\nend", "  a = a.to_s\n  b = b.to_s\n  if a.length <>\
    \ b.length\n    raise ArgumentError, \"Strings must have equal length\"\n  (a.length,\
    \ b.length).each {|size|\n    raise ArgumentError, \"String must be exactly #{size}\
    \ chars\" if size != a.length\n  }\n  return \"\" if a.length == 0\n  a = a.dup\n\
    \  b = b.dup\n  while a.length != 0\n    i =\n      case a[0]\n      when '0'\
    \ then 0\n      when '1' then 1\n      else raise ArgumentError, \"Invalid string\
    \ in XOR\"\n      end\n    a[0] = b[0] ^ i\n    b.shift\n  end\n  return a\nend",
  "  puts \"StringXor[#{a}, #{b}] = #{binary(a, b) ^ binary(b, a)}\"\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nJust a note that `[a, b].pack('C*') => a^b` is probably\
    \ faster than `binary(a, b)`\n<|/ c |>\n<| c |>\nAnd note that `[a, b].pack('C*').ord.to_s(2)\
    \ => \"100\"` will give the same result as `binary(a, b)`.\n<|/ c |>\n<| c |>\n\
    I benchmarked using `[a, b].pack('C*').ord.to_s(2)` and got `2.610000   0.000000\
    \   2.610000 (  2.626363)` on my MacBook Pro Intel Core2 Duo 2.6 GHz\n<|/ c |>\n\
    <| a dscore=4 |>\nA little benchmark to show that packing into a single byte array\
    \ and then converting it to hex has more overhead:\n<code>\nrequire 'digest/sha1'",
  "  a = \"0\" + a\n  b = \"0\" + b\n  c = [a[0, 2], a[0, 1], a[0, 0], a[2, 2], a[2,\
    \ 1], a[2, 0], a[2, 2], a[2, 1], a[2, 0], a[2, 2], a[2, 1], a[2, 0], a[2, 2],\
    \ a[2, 1], a[2, 0], a[2, 2], a[2, 1]]\n  d = []\n  for i in [0, 4, 6, 2, 5]\n\
    \    d << c[i]\n  e = [b[0, 2], b[0, 1], b[0, 0], b[2, 2], b[2, 1]]\n  for i in\
    \ [0, 4, 6, 2, 5]\n    e << e[i]\n  d = [d[-1, 3], d[-2, 3], d[-3, 3], d[-1, 2],\
    \ d[-2, 2], d[-3, 2], d[-4, 3], d[-1, 1]]\n  e = [e[-3, 3], e[-4, 3], e[-3, 2],\
    \ e[-4, 2], e[-5, 3], e[-3, 1], e[-4, 1], e[-5, 2], e[-4, 0]]\n  for i in [0,\
    \ 4, 6, 2, 5]\n    d << d[i]\n  e = [e[-3, 3], e[-4, 3], e[-3, 2], e[-4, 2], e[-5,\
    \ 3], e[-3, 1], e[-4, 1], e[-5, 2], e[-4, 0]]\n  for i in [0, 4, 6, 2, 5]\n  \
    \  e << e[i]\n  d = [d[-1, 3], d[-2, 3], d[-3, 3], d[-1, 2], d[-2, 2], d[-3, 2],\
    \ d[-4, 3], d[-1, 1]]\n  e = [e[-3, 3], e[-4, 3], e[-3, 2], e[-4, 2], e[-5, 3],\
    \ e[-3, 1], e[-4, 1], e[-5, 2], e[-4, 0]]\n  for i in [0, 4, 6, 2, 5]\n    d <<\
    \ d[i]\n  e = [e[-3, 3], e[-4, 3], e[-3, 2], e[-4, 2], e[-5, 3], e[-3, 1], e[-4,\
    \ 1], e[-5, 2], e[-4, 0]]\n  for i in [0, 4, 6, 2, 5]\n    e << e[i]\n  d = [d[-1,\
    \ 3], d[-2, 3], d[-3, 3], d[-1, 2], d[-2, 2], d[-3, 2], d[-4, 3], d[-1, 1]]\n\
    \  e = [e[-3, 3], e[-4, 3], e[-3, 2], e[-4, 2], e[-5, 3], e[-3, 1], e[-4, 1],\
    \ e[-5, 2], e[-4, 0]]\n  for i in [0, 4, 6, 2, 5]\n    d << d[i]\n  e = [e[-3,\
    \ 3], e[-4, 3], e[-3, 2], ", "  a.unpack(\"C*\").inject(\"\\x00\") { |c, x| c\
    \ ^ x }\nend\nmodule_function :string_xor", "  return a.unpack('c*').inject(:^).pack('c*')\n\
    end", "  return a.xor(b)\nend", "  a_bytes = a.encode\n  b_bytes = b.encode\n\
    \  \n  raise ArgumentError if a_bytes.length != b_bytes.length\n  \n  result =\
    \ []\n  \n  for i in 0..(a_bytes.length-1)\n    v = a_bytes[i] + b_bytes[i]\n\
    \    \n    result.unshift(v.chr)\n  end\n  \n  result.join\nend", "  a = a.to_s\n\
    \  b = b.to_s\n  return a.each_char.with_index.with_object(\"\") do |(char, index),\
    \ result|\n    if char == b[index]\n      result << char\n    else\n      result\
    \ << char\n    end\n  end.join\nend", "  xor = a.unpack('C*') - b.unpack('C*')\
    \ # convert the strings into byte arrays and subtract them\n  xor = String.new(xor).unpack('C*')\
    \ # convert the byte array back to a string\n  xor = xor.map(&:to_s).join('')\
    \ # convert back to a string\n  return xor\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
