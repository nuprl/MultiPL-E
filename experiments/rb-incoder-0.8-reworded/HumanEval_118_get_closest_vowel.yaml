name: HumanEval_118_get_closest_vowel
language: rb
prompt: "# You are given a word. Your task is to find the closest vowel that stands\
  \ between \n# two consonants from the right side of the word (case sensitive).\n\
  # Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n\
  # find any vowel met the above condition. \n# You may assume that the given string\
  \ contains English letter only.\n# Example:\n# >>> get_closest_vowel.call(\"yogurt\"\
  )\n# \"u\"\n# >>> get_closest_vowel.call(\"FULL\")\n# \"U\"\n# >>> get_closest_vowel.call(\"\
  quick\")\n# \"\"\n# >>> get_closest_vowel.call(\"ab\")\n# \"\"\ndef get_closest_vowel(word)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_closest_vowel\n\
  \    candidate = method(:get_closest_vowel)\n    assert_equal(\"u\", candidate.call(\"\
  yogurt\"))\n    assert_equal(\"u\", candidate.call(\"full\"))\n    assert_equal(\"\
  \", candidate.call(\"easy\"))\n    assert_equal(\"\", candidate.call(\"eAsy\"))\n\
  \    assert_equal(\"\", candidate.call(\"ali\"))\n    assert_equal(\"a\", candidate.call(\"\
  bad\"))\n    assert_equal(\"o\", candidate.call(\"most\"))\n    assert_equal(\"\"\
  , candidate.call(\"ab\"))\n    assert_equal(\"\", candidate.call(\"ba\"))\n    assert_equal(\"\
  \", candidate.call(\"quick\"))\n    assert_equal(\"i\", candidate.call(\"anime\"\
  ))\n    assert_equal(\"\", candidate.call(\"Asia\"))\n    assert_equal(\"o\", candidate.call(\"\
  Above\"))\n  end\nend\n"
completions: ["  vowels = %w(a e i o u)\n  word.split.reverse.each do |char|\n   \
    \ vowels.each do |v|\n      if char.upcase == v\n        return char\n      end\n\
    \    end\n  end\nend", "  vowel_consonants = String.new(word)\n  vowel_consonants.gsub!(/[aeiou]/,\
    \ '').gsub!(/[^aeiou]/, '')\n  vowel_consonants.reverse!\n  vowel_consonants.reverse!\n\
    \  vowel_consonants.gsub!(/[aeiou]/, '')\n  vowel_consonants.reverse!\n  vowel_consonants.reverse!\n\
    \  return vowel_consonants.chomp\nend", "    return \"\" if word.nil? || word.size\
    \ == 0 \n        \n    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\", \"y\"]\n \
    \   consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\"\
    , \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"z\"\
    ]\n    \n    vowel_found = false\n    consonant_found = false\n    consonant_index\
    \ = -1\n    vowel_index = -1\n    \n    word = word.downcase\n    \n    word.each_char\
    \ do |c|\n        if vowels.include? c\n            vowel_found = true\n     \
    \   end\n        \n        if consonants.include? c\n            consonant_found\
    \ = true\n        end\n    end", "  vowels = ['A', 'E', 'I', 'O', 'U']\n  vowels_count\
    \ = vowels.count\n  vowels_count.call(word) > 0 ?\n    vowels.assoc(vowels_count.call(word).call.length\
    \ - 1, word) :\n    vowels.assoc(vowels.size - 1, word)\nend\n</code>\n<|/ a |>\n\
    <| c |>\nthank you for your reply and its also working but i need to use the string\
    \ split function and i cant use the word array i think i need to use some if else\
    \ statement to find the closest vowel but cant figure it out please help me thanks\
    \ in advance\n<|/ c |>\n<| c |>\ni edited the answer, it would be good if you\
    \ could review it and make improvements.\n<|/ c |>\n<| c |>\nthanks for your reply\
    \ but my lecturer said that we can not use \"if\" statement to solve this problem\
    \ so i will try to use your code thanks again for your effort\n<|/ c |>\n<| c\
    \ |>\nno problem , please mark it as an answer if it helps you. it would be great\
    \ if you can mark the answer as accepted. thanks.\n<|/ c |>\n<| c |>\nThe problem\
    \ is that the first solution I posted is O(n^2) complexity and second solution\
    \ is O(n) complexity and if you can review the solution provided by me then you\
    \ will find it to be O(n).\n<|/ c |>\n<| a tags=ruby,string |>\n<code>", "  return\
    \ nil if word.size <= 1\n  \n  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\
    \  \n  vowel_before, vowel_after = nil, nil\n  \n  word.split(\"\").each_with_index\
    \ do |letter, index|\n    if vowels.include?(letter)\n      vowel_after = letter\n\
    \      break if index == 0\n    end\n  end\n  \n  if vowel_after\n    if vowel_before.nil?\
    \ && vowel_after.downcase != vowel_after.upcase\n      vowel_before = vowel_after\n\
    \    end\n  end\n  \n  return vowel_before if vowel_before.present?\n  return\
    \ nil if vowel_after.present?\n  \n  vowel_before, vowel_after = nil, nil\n  \n\
    \  word.split(\"\").each_with_index do |letter, index|\n    if vowels.include?(letter)\n\
    \      vowel_before = letter\n      break if index == word.size\n    end\n  end\n\
    \  \n  if vowel_before\n    if vowel_after.nil? && vowel_before.downcase != vowel_before.upcase\n\
    \      vowel_after = vowel_before\n    end\n  end\n  \n  return vowel_before if\
    \ vowel_before.present?\n  return nil if vowel_after.present?\nend", "\treturn\
    \ word[word.rindex('')-2][word.rindex('')].lower()\n</cell>\n<cell>", "  vowels\
    \ = \"AEIOUaeiouAEIOU\"\n  last_vowel = word[word.rindex(vowels)]\n  return last_vowel\n\
    </code>\n<|/ a tags=ruby,string |>\n<| c |>\nThat will break for e.g. `get_closest_vowel(\"\
    AB\")`\n<|/ c |>\n<| c |>\n, Good catch. I fixed it. `rindex` should be used here\
    \ instead of `index` which I intended to use.\n<|/ c |>\n<| c |>\nThat still returns\
    \ `\"a\"` for \"AB\"\n<|/ c |>\n<| c |>\n, Fixed again. `index` should be used\
    \ instead of `rindex`.\n<|/ c |>\n<| a tags=ruby,string dscore=0 |>\n<code>",
  "  vowels = %w{a e i o u}\n  index = word.length - 1\n  last_char = word[index]",
  "    vowel_start = word.rindex('a')\n    vowel_end = word.rindex('e')\n    return\
    \ word[vowel_end + 1] if vowel_end != -1 else \"\"", "    vowels = [\"a\", \"\
    e\", \"i\", \"o\", \"u\"]\n    \n    vowel_index = word.rindex(\"a\")\n    if\
    \ vowel_index == -1 or vowel_index == len(word)-1:\n        return \"\"\n    \n\
    \    vowel_index = word.rindex(\"e\")\n    if vowel_index == -1 or vowel_index\
    \ == len(word)-1:\n        return \"\"\n    \n    vowel_index = word.rindex(\"\
    i\")\n    if vowel_index == -1 or vowel_index == len(word)-1:\n        return\
    \ \"\"\n    \n    vowel_index = word.rindex(\"o\")\n    if vowel_index == -1 or\
    \ vowel_index == len(word)-1:\n        return \"\"\n    \n    vowel_index = word.rindex(\"\
    u\")\n    if vowel_index == -1 or vowel_index == len(word)-1:\n        return\
    \ \"\"\n    \n    return vowels[vowel_index + 1]\n    \nprint(get_closest_vowel(\"\
    yogurt\"))\nprint(get_closest_vowel(\"FULL\"))\nprint(get_closest_vowel(\"quick\"\
    ))\nprint(get_closest_vowel(\"ab\"))\n</cell>\n<text>\nProblem 2", "  word.downcase!\n\
    \  vowels_upcase = []\n  vowels_downcase = []\n  vowels_upcase.push(\"u\")\n \
    \ vowels_upcase.push(\"i\")\n  vowels_upcase.push(\"a\")\n  vowels_downcase.push(\"\
    u\")\n  vowels_downcase.push(\"i\")\n  vowels_downcase.push(\"a\")\n  \n  if word.length\
    \ == 0\n    return \"\"\n  \n  for i in 1..word.length\n    letter = word[i-1]\n\
    \    if vowels_upcase.include?(letter)\n      return letter\n    end\n    letter\
    \ = word[i+1]\n    if vowels_upcase.include?(letter)\n      return letter\n  \
    \  end\n  end\nend", "  return word =~ /^[aeiou].*[aeiou]$/i ? word[/[aeiou]$/i..-1]\
    \ : \"\"\nend", "  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  vowels_count\
    \ = word.scan(/[aeiou]/).count\n  last_letter = word[-1..-1]\n  if vowels_count\
    \ == 0 and last_letter =~ /[aeiou]/\n    return \"\"\n  case vowels.include? last_letter\n\
    \    when true \n      return vowels.first\n    when false\n      return \"\"\n\
    \  end \nend ", "    vowel = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    \n    vowel_str\
    \ = \"\"\n    i = 0\n    while i < len(word):\n        if word[i].lower() in vowel:\n\
    \            vowel_str = word[i]\n            break\n        i += 1\n    \n  \
    \  if vowel_str == \"\":\n        vowel_str = word[len(word) - 1]\n    \n    return\
    \ vowel_str\n    \n    ", "  consonants = %w(a e i o u)\n  vowels = %w(a e i o\
    \ u)\n  consonants.each do |c| \n    break if word.include?(c)\n  end\n  vowels.each\
    \ do |v|\n    break if word.include?(v)\n  end\n  if word[consonants.size..-1].include?(v)\n\
    \    return v\n  elsif word[0..consonants.size-1].include?(v)\n    return v\n\
    \  elsif word[-consonants.size..-1].include?(v)\n    return v\n  end\n  return\
    \ \"\"\nend\n</cell>\n<cell>\nget_closest_vowel(\"yogurt\")\nget_closest_vowel(\"\
    FULL\")\nget_closest_vowel(\"quick\")\nget_closest_vowel(\"ab\")\n</cell>\n<cell>",
  "  vowels = [:a, :e, :i, :o, :u, :y]\n  idx = word.rindex(\"a\")\n  idx2 = word.rindex(\"\
    e\")\n  idx3 = word.rindex(\"i\")\n  idx4 = word.rindex(\"o\")\n  idx5 = word.rindex(\"\
    u\")\n  idx6 = word.rindex(\"y\")\n  idx7 = (idx + 1) if (idx + 1) < word.length\
    \ end\n  idx8 = (idx2 + 1) if (idx2 + 1) < word.length end\n  idx9 = (idx3 + 1)\
    \ if (idx3 + 1) < word.length end\n  idx10 = (idx4 + 1) if (idx4 + 1) < word.length\
    \ end\n  idx11 = (idx5 + 1) if (idx5 + 1) < word.length end\n  idx12 = (idx6 +\
    \ 1) if (idx6 + 1) < word.length end\n  idx13 = (idx7 + 1) if (idx7 + 1) < word.length\
    \ end\n  idx14 = (idx8 + 1) if (idx8 + 1) < word.length end\n  idx15 = (idx9 +\
    \ 1) if (idx9 + 1) < word.length end\n  idx16 = (idx10 + 1) if (idx10 + 1) < word.length\
    \ end\n  idx17 = (idx11 + 1) if (idx11 + 1) < word.length end\n  idx18 = (idx12\
    \ + 1) if (idx12 + 1) < word.length end\n  idx19 = (idx13 + 1) if (idx13 + 1)\
    \ < word.length end\n  idx20 = (idx14 + 1) if (idx14 + 1) < word.length end\n\
    \  idx21 = (idx15 + 1) if (idx15 + 1) < word.length end\n  idx22 = (idx16 + 1)\
    \ if (idx16 + 1) < word.length end\n  idx23 = (idx17 + 1) if (idx17 + 1) < word.length\
    \ end\n  idx24 = (idx18 + 1) if (idx18 + 1) < word.length end\n  idx25 = (idx19\
    \ + 1) if (idx19 + 1) < word.length end\n  idx26 = (idx20 + 1) if (idx20 + 1)\
    \ < word.length end\n  idx27 = (idx21 + 1) if (idx21 + 1) < word.length end\n\
    \  idx28 = (idx22 + 1) if (idx22 + 1) < word.length end\n  idx29 = (idx23 + 1)\
    \ if (idx23 + 1) < word.length end\n  idx30 = (idx24 + 1) if (idx24", "  vowels\
    \ = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"",
  "  vowels = (\"a\", \"e\", \"i\", \"o\", \"u\", \"y\")\n  begin = word.length\n\
    \  end = word.length - 1\n  while begin != 0\n    if vowels.include?(word[end\
    \ - 1]) && vowels.include?(word[end])\n      return word[end - 1]\n    end--\n\
    \  end\n  return \"\"\nend", "  # TODO: Write your code here\n  return \"\"\n\
    \  \nprint(get_closest_vowel.call(\"yogurt\"))\nprint(get_closest_vowel.call(\"\
    FULL\"))\nprint(get_closest_vowel.call(\"quick\"))\nprint(get_closest_vowel.call(\"\
    ab\"))\n</cell>\n<cell>", "  return vowels[word.rindex(consonants.reverse)] if\
    \ word[word.rindex(consonants.reverse):] == consonants.reverse else \"\"\n</cell>\n\
    <cell>\nget_closest_vowel.call(\"yogurt\")\n</cell>\n<cell>\nget_closest_vowel.call(\"\
    FULL\")\n</cell>\n<cell>\nget_closest_vowel.call(\"quick\")\n</cell>\n<cell>\n\
    get_closest_vowel.call(\"ab\")\n</cell>\n<text>\n3. Tape\nTape is a data structure\
    \ that holds a sequence of data and allows appending and removing elements from\
    \ the data structure. Its operations append and remove are O(1), which means it\
    \ takes constant time.", "  vowels = ['a','e','i','o','u']\n  word.downcase!\n\
    \  word.each_char do |c|\n    vowels.each do |v|\n      return v if v == c\n \
    \   end\n  end\n  return \"\"\nend\n</code>\n<|/ a |>\n<| c |>\nThanks much! It\
    \ works, although I did some small modifications because I have other functions\
    \ within the method. Here is my code:\n<|/ c |>\n<| c |>", "  # split word on\
    \ non-vowel characters\n  consonants = word.split(//)\n  # find index of the consonant\
    \ that is closest to the right side of the word\n  closest_consonant_index = consonants.rindex{|c|\
    \ c =~ /[AEIOU]/} \n  # get the vowel from the index we got\n  closest_consonant\
    \ = consonants[closest_consonant_index]\n  return closest_consonant if closest_consonant\
    \ =~ /[AEIOU]/\nend", "  vowels = [ \"a\", \"e\", \"i\", \"o\", \"u\" ]\n  vowels_count\
    \ = 0\n  consonants = word.downcase.split('').map(&:to_i)\n  consonants.reverse_each{|c|\
    \ vowels_count += 1 if vowels.include?(c.to_s.upcase)}\n  return \"\" if vowels_count\
    \ == 0\n  consonants.reverse_each{|c| return c if vowels.include?(c.to_s.upcase)}\n\
    end\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| c |>\nHi, this answer is really\
    \ cool. I'm a beginner at ruby and I really appreciate your help and time. This\
    \ problem was a lot harder than I thought. Thank you so much!\n<|/ c |>\n<| c\
    \ |>\nYou're welcome. Let me know if you need any other help and don't forget\
    \ to accept my answer. :) I hope you enjoy ruby. :)\n<|/ c |>\n<| a dscore=0 tags=ruby\
    \ |>\nThe approach here is to find the right vowel from the beginning of the word\
    \ and from the end of the word. We then simply return that vowel.\n<code>", " \
    \ return word.scan(/[aeiou].+[aeiou]/).map(&:first).compact.first\nend", "  vowels\
    \ = (\"a\", \"e\", \"i\", \"o\", \"u\")\n  vowels_length = len(vowels)\n  word_length\
    \ = len(word)\n  left_index = word_length - vowels_length\n  \n  right_index =\
    \ word_length - vowels_length\n  \n  while right_index > 0\n    vowel_index =\
    \ vowels.index(word[right_index], right_index)\n    if vowel_index >= 0\n    \
    \  break\n    right_index = right_index - 1\n  end", "    vowels = (\"a\", \"\
    e\", \"i\", \"o\", \"u\", \"y\", \"A\", \"E\", \"I\", \"O\", \"U\", \"Y\")\n \
    \   vowels_pos = 0\n    vowels_len = 6\n    word = word.downcase\n    \n    while\
    \ vowels_pos < vowels_len and word.length > 0\n        if word[vowels_pos] ==\
    \ vowels[vowels_pos]\n            vowels_pos += 1\n        else \n           \
    \ word = word[0...vowels_pos] + word[vowels_pos + 1..-1]\n            vowels_pos\
    \ = 0\n    end\n    \n    return word\nend", "  word = word.downcase\n  vowels\
    \ = [\"a\",\"e\",\"i\",\"o\",\"u\",\"y\"]\n  \n  vowel_positions = word.scan(/[aeiou]*/).map(&:length).max\n\
    \  \n  return vowels[vowel_positions.zero? ? 0 : vowel_positions - 1]\nend", " \
    \ return word.chars.reduce{|acc,char|\n    ((acc.length < 2 ? acc.chars[acc.length\
    \ - 1] : acc).upcase == char ? char : \"\")\n  }\nend", "  vowels = [\"a\",\"\
    e\",\"i\",\"o\",\"u\"]\n  vowels.each do |vowel|\n    if word.index(vowel) ==\
    \ word.rindex(vowel)\n      return vowel\n    end\n  end\n  return \"\"\nend\n\
    \  \n  \n  ", "\treturn nil\nend", "    vowels = [\"a\", \"e\", \"i\", \"o\",\
    \ \"u\", \"y\"]\n    vowel_consonant_pairs = [\"a\", \"ae\", \"e\", \"ee\", \"\
    i\", \"ii\", \"o\", \"ou\", \"u\", \"y\"]\n    consonant_pairs = [\"b\", \"ch\"\
    , \"d\", \"dh\", \"g\", \"gh\", \"j\", \"k\", \"l\", \"m\", \"n\", \"ph\", \"\
    q\", \"r\", \"s\", \"sh\", \"t\", \"th\", \"v\", \"w\", \"y\", \"z\"]\n    vowel_pairs\
    \ = vowel_consonant_pairs + consonant_pairs\n    closest_vowel = \"\"\n    vowel_index\
    \ = 1\n    consonant_index = 1\n    \n    while vowel_index < len(vowels) or consonant_index\
    \ < len(consonant_pairs) or vowel_index > len(vowels) + len(consonant_pairs):\n\
    \        if vowel_index < len(vowels) and consonant_index < len(consonant_pairs)\
    \ and vowel_index > len(vowels) + len(consonant_pairs) and vowels[vowel_index]\
    \ == word[vowel_index] and vowel_pairs[vowel_index] == word[vowel_index + consonant_index]:\n\
    \            closest_vowel = vowels[vowel_index]\n            vowel_index += 1\n\
    \        elif consonant_index < len(consonant_pairs):\n            closest_vowel\
    \ = consonant_pairs[consonant_index]\n            consonant_index += 1\n     \
    \   else:\n            vowel_index += 1\n            consonant_index = consonant_index\
    \ + 1\n            \n    return closest_vowel", "  vowels = [\"a\", \"e\", \"\
    i\", \"o\", \"u\"]\n  consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\",\
    \ \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\"\
    , \"w\", \"x\", \"y\", \"z\"]\n  vowel_found = false\n  consonant_found = false\n\
    \  vowel_left = false\n  consonant_right = false\n  \n  word.each_char do |c|\n\
    \    if vowels.include? c\n      vowel_found = true\n      if vowel_left\n   \
    \     vowel_left = false\n      else\n        vowel_left = true\n      end\n \
    \   end\n    \n    if consonants.include? c\n      consonant_found = true\n  \
    \    if consonant_right\n        consonant_right = false\n      else\n       \
    \ consonant_right = true\n      end\n    end\n    \n    if vowel_found && consonant_found\n\
    \      return c\n    end\n  end\n  \n  return \"\"\nend\n</code>\n<|/ a |>\n<|\
    \ a dscore=0 tags=ruby |>\n<code>", "  word = word.downcase\n  vowels = ['a','e','i','o','u']\n\
    \  i = 0\n  while i < word.length\n    if vowels.include? word[i]\n      return\
    \ word[i]\n    i += 1\n  return \"\"\nend\n</code>\n<|/ a dscore=0 tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nYou don't need to use an additional array to check whether a character\
    \ is a vowel from the right. You can just check if word[word.length - i] is in\
    \ your vowels array.\n<|/ c |>\n<| c |>\nYes I know. But I always prefer to use\
    \ array for such cases. I prefer to use array when I am not sure about the number\
    \ of elements in an array.\n<|/ c |>\n<| c |>\nThat's a good point. I was thinking\
    \ more of cases where the vowel is on the right of the word but would need something\
    \ like `if word.sub!(/([^aeiou])#{word[i]}$/i, \"\\\\1\")` instead. Thanks.\n\
    <|/ c |>\n<| a |>\nIf your string has many vowels then below solution will work\
    \ fastest\n<code>", "  # write your code here\nend\n</cell>\n<cell>", "  vowels\
    \ = %w( a e i o u )\n  consonants = %w( b g k m p q s t v w x z )\n  consonant_counts\
    \ = {}\n  consonant_counts[consonants[0]] = 1\n  consonant_counts[consonants[-1]]\
    \ = 1\n  consonant_counts[consonants[1]] = 1\n  vowel_counts = {}\n  vowel_counts[vowels[0]]\
    \ = 1\n  vowel_counts[vowels[-1]] = 1\n  vowel_counts[vowels[1]] = 1", "    vowels\
    \ = [\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"]\n    vowel_count\
    \ = [0,0,0,0,0,0,0]\n    vowel_count[0] = 0\n    vowel_count[1] = 0\n    vowel_count[2]\
    \ = 0\n    vowel_count[3] = 0\n    vowel_count[4] = 0\n    vowel_count[5] = 0\n\
    \    vowel_count[6] = 0\n    vowel_count[7] = 0\n    vowel_count[8] = 0\n    vowel_count[9]\
    \ = 0\n    vowel_count[10] = 0\n    vowel_count[11] = 0\n    vowel_count[12] =\
    \ 0\n    vowel_count[13] = 0\n    vowel_count[14] = 0\n    vowel_count[15] = 0\n\
    \    vowel_count[16] = 0\n    vowel_count[17] = 0\n    vowel_count[18] = 0\n \
    \   vowel_count[19] = 0\n    vowel_count[20] = 0\n    vowel_count[21] = 0\n  \
    \  vowel_count[22] = 0\n    vowel_count[23] = 0\n    vowel_count[24] = 0\n   \
    \ vowel_count[25] = 0\n    vowel_count[26] = 0\n    vowel_count[27] = 0\n    vowel_count[28]\
    \ = 0\n    vowel_count[29] = 0\n    vowel_count[30] = 0\n    vowel_count[31] =\
    \ 0\n    vowel_count[32] = 0\n    vowel_count[33] = 0\n    vowel_count[34] = 0\n\
    \    vowel_count[35] = 0\n    vowel_count[36] = 0\n    vowel_count[37] = 0\n \
    \   vowel_count[38] = 0\n    vowel_count[39] = 0\n    vowel_count[40] = 0\n  \
    \  vowel_count[41] = 0\n    vowel_count[42] = 0\n    vowel_count[43] = 0\n   \
    \ vowel_count[44] = 0\n    vowel_count[45] = 0\n    vowel_count[46] = 0\n    vowel_count[47]\
    \ = 0\n    vowel_count[48] = 0\n    vowel_count[49] = 0\n    vowel_count[50] =\
    \ 0\n    vowel_count[51] = 0\n    vowel_count[52] = 0\n    vowel_count[53] = 0\n\
    \    vowel_count[54] = 0\n    vowel_count[55] = 0\n    vowel_count[56] = 0\n \
    \   vowel_count[57] = 0\n    vowel_count[58] = 0\n    vowel_count[59] = 0\n  \
    \  vowel_count[60] = 0\n    vowel_count[61] = 0\n    vowel_count[62] = 0\n   \
    \ vowel_count[63] = 0\n    vowel_count[64] = 0\n    vowel_count[65] = 0\n    vowel_count[66]\
    \ = 0\n    vowel_count[67] = 0\n    vowel_count[68] = 0\n    vowel_count[69] =\
    \ 0\n    vowel", "    vowel = nil\n    vowels = %w(a e i o u)\n    i = word.rindex(vowels)\n\
    \    if i > 0\n        vowel = word[(i+1).length..-1]\n    end\n    return vowel\n\
    end", "    vowels = ['A', 'a', 'E', 'e', 'I', 'i', 'O', 'o', 'U', 'u']\n    vowels.each\
    \ do |vowel|\n        letter_count = word.count(vowel)\n        vowel_index =\
    \ word.index(vowel)\n        if vowel_index <= 0 && letter_count >= 3\n      \
    \      return vowel\n        end\n    end\n    return \"\"\nend", "  vowels =\
    \ %w[a e i o u]\n  vowels.each do |vowel|\n    return vowel if word.include?(vowel)\n\
    \  end\n  return \"\"\nend\n</pre>\n</li>\n<li>\n<p>\n<strong>\nExercise 9\n</strong>\
    \ \n Write a method called \"count_vowels\" that takes one word as argument. \n\
    \ It should return an hash where the key is the vowel and the value is how many\
    \ \n times the vowel appears in the word.\nExample:\n>>> count_vowels.call(\"\
    yogurt\")\n{\"a\" => 1, \"e\" => 1, \"i\" => 1, \"o\" => 1, \"u\" => 1}\n>>> count_vowels.call(\"\
    yogurt\")\n{\"a\" => 1, \"e\" => 1, \"i\" => 1, \"o\" => 1, \"u\" => 1}\n>>> count_vowels.call(\"\
    quick\")\n{\"a\" => 0, \"e\" => 0, \"i\" => 0, \"o\" => 0, \"u\" => 0}\n>>> count_vowels.call(\"\
    ab\")\n{\"a\" => 0, \"e\" => 0, \"i\" => 0, \"o\" => 0, \"u\" => 0}\nNote: \n\
    We assume that your implementation can run on ruby 2.3 and above.\nYou may assume\
    \ that your implementation can run on ruby 1.8.6 and above.\nYou may assume that\
    \ your implementation can run on ruby 1.8.7 and above.\nYou may assume that your\
    \ implementation can run on ruby 1.9.2 and above.\nYou may assume that your implementation\
    \ can run on ruby 1.9.3 and above.\nYou may assume that your implementation can\
    \ run on ruby 1.9.4 and above.\n</pre>\n</li>\n<li>\n<p>\n<strong>\nExercise 10\n\
    </strong> \n Write a method called \"count_vowels\" that takes one word as argument.\
    \ \n It should return an hash where the key is the vowel and the value is how\
    \ many \n times the vowel appears in the word.\nExample:\n>>> count_vowels.call(\"\
    yogurt\")\n{\"a\" => 1, \"e\" => 1, \"i\" => 1, \"o\" => 1, \"u\" => 1}\n>>> count_vowels.call(\"\
    yogurt\")\n{\"a\" => 1, \"e\" => 1, \"i\" => 1, \"o\" => 1, \"u\" => 1}\n>>> count_vowels.call(\"\
    quick\")\n{\"a\" => 0, \"e\" => 0, \"i\" => 0, \"o\" => 0, \"u\" => 0}\n>>> count_vowels.call(\"\
    ab\")\n{\"a\" => 0, \"e\" => 0, \"i\" => 0, \"o\" => 0, \"u\" => 0}\nNote: \n\
    We assume ", "  vowels = \"aeiou\"\n  result = \"\"\n  l = word.length\n  i =\
    \ 0\n  while i < l\n    letter = word.chars[i]\n    i += 1\n    if (letter ==\
    \ vowels.first || letter == vowels.last) && i > l\n      break\n    else \n  \
    \    result = letter if (letter != vowels.first && letter != vowels.last) else\
    \ \"\"\n  end\n  return result\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI like\
    \ this answer because it works on any string containing only characters from A\
    \ to Z (regardless of case), which is often the case for real world strings. But\
    \ it does require the use of `first` and `last` which is in Ruby 1.8.7 and prior.\n\
    <|/ c |>\n<| a |>\nHere is a simpler way:\n<code>", "  vowels = [\"a\", \"e\"\
    , \"i\", \"o\", \"u\"]\n  left_side = word.rpartition(vowels[4])[0]\n  right_side\
    \ = word.rpartition(vowels[3])[0]\n  closest_vowel = vowels[4] if left_side.size\
    \ > right_side.size else vowels[3]\n  return closest_vowel\n</code>\n<|/ a |>\n\
    <| c |>\nThis answer does not work. It returns \"u\" for \"yogurt\" instead of\
    \ \"u\"\n<|/ c |>\n<| c |>\nThe OP already posted a very similar solution. Also,\
    \ I see no indication that you are the OP.\n<|/ c |>\n<| a dscore=0 |>\nHere is\
    \ a simple solution that works only for words of length <= 4 :\n<code>", "  vowels\
    \ = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  vowel_pos = word.rindex(vowels) \n\
    \  if vowel_pos == -1 || vowel_pos == word.size - 1\n    puts \"No vowel found\"\
    \n  else\n    vowel = word[vowel_pos + 1]\n    puts vowel\n  end\nend\n</code>\n\
    <|/ a dscore=1 tags=ruby,string |>\n<| c |>\nThe OP stated that they have only\
    \ `\"English letter only\"`. Also, `\"abc\"` should return `\"\"` instead of `\"\
    c\"` because `\"abc\"` is not a vowel.\n<|/ c |>\n<| c |>\n, sorry for my misunderstanding.\
    \ The code has been edited. Thank you for pointing out.\n<|/ c |>\n<| a |>\n<code>\n\
    word = \"doge\"\nvowels = \"aeiou\"", "  return word.split(\"\").map do |char|\n\
    \    char = char.downcase\n    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\
    \    if vowels.include?(char)\n      return char\n    end\n  end.reduce(:==).empty?\
    \ ? \"U\" : \"\"\nend", "  return vowels.find(word[/[^aeiou]i/,0]) || vowels.rindex(word[/[^aeiou]i/,0])\
    \ ? \"\" : vowels[vowels.rindex(word[/[^aeiou]i/,0])]\nend\n</cell>\n<cell>",
  "    vowels = %w{a e i o u}\n    word.upcase!\n    word.length.times{ |i| vowels.include?(word[i])\
    \ }\n    vowels.max_by(&word.method(:rindex)).last\nend", "  word = word.upcase\n\
    \  vowels = \"AEIOUaeiou\"\n  consonants = \"BCDFGHJKLMNPQRSTVWXYZ\"\n  last_consonant_index\
    \ = word.rindex(consonants) - 1\n  if last_consonant_index > 0 && !word.end_with?(vowels)\n\
    \    word.slice! last_consonant_index\n  end\n  vowel = word.slice!(0, (word.index(vowels)..-1)).downcase\n\
    \  vowels = vowels.downcase\n  if vowels.include?(vowel)\n    return vowel\n \
    \ else\n    return \"\"\n  end\nend\n</cell>\n<cell>\nget_closest_vowel(\"yogurt\"\
    )\n</cell>\n<cell>\nget_closest_vowel(\"quick\")\n</cell>\n<cell>\nget_closest_vowel(\"\
    AB\")\n</cell>\n<cell>\nget_closest_vowel(\"ab\")\n</cell>\n<text>\nGiven a word,\
    \ find the word with the most vowels met the above conditions. \nYour answer should\
    \ be in alphabetical order.", "  \n  \n  if word.empty?\n    return \"\"\n  \n\
    \  vowels = %w{ a e i o u }\n  vowels.each do |vowel|\n    if word.index(vowel)\
    \ == (word.length-1)\n      \n      if word[word.index(vowel)+1] == 'e' || word[word.index(vowel)+1]\
    \ == 'a'\n        return vowel\n      end\n      \n    end\n  end\nend", "  vowels\
    \ = %w{a e i o u}\n  consonants = %w{b c d f g h j k l m n p q r s t v w x y z}",
  "  vowels = %w(a e i o u)\n  word.gsub(/[^a-z]+/, \"\").each_char{|c|\n    if vowels.include?(c.downcase)\n\
    \      return c\n    end\n  }\nend", "    word.downcase!\n    \n    vowels = %w(a\
    \ e i o u)\n    vowels_hash = Hash[letter, false] \n    \n    return vowels.find\
    \ { |vowel| word.slice!(0, vowel.size).rindex!(vowel).nil? && vowels_hash[vowel]\
    \ }\nend", "  word.downcase!\n  \n  vowel_count = 0\n  consonant_count = word.length\n\
    \  \n  for i in (0...word.length-1)\n    if word[i] == ?u\n      vowel_count +=\
    \ 1\n    end\n  end\n  \n  vowel_count += 1 if word.length > 1 && word[0] == ?a\
    \ && word[1] == ?o \n  vowel_count += 1 if word.length == 1 && word[0] == ?a\n\
    \  \n  if vowel_count <= 1\n    return \"\"\n  end\n  \n  for i in (0...word.length-1)\n\
    \    if word[i] == ?a\n      consonant_count -= 1\n      break if consonant_count\
    \ == 0\n    end\n  end\n  \n  consonant_count += 1 if word.length == 1 && word[0]\
    \ == ?o\n  \n  vowel_count = word.length.to_f/(consonant_count+vowel_count)\n\
    \  \n  return nil if vowel_count == 0\n  \n  word[word.length-1].upcase!\n  \n\
    \  for i in (0...word.length-1)\n    if word[i] == ?u\n      vowel_count += 1\n\
    \    end\n  end\n  \n  vowel_count += 1 if word.length > 1 && word[0] == ?a &&\
    \ word[1] == ?o\n  vowel_count += 1 if word.length == 1 && word[0] == ?a\n  \n\
    \  return nil if vowel_count == 0\n  \n  word[word.length-1].downcase!\n  \n \
    \ vowel_count = 0\n  consonant_count = word.length\n  \n  for i in (0...word.length-1)\n\
    \    if word[i] == ?a\n      vowel_count += 1\n    end\n  end\n  \n  consonant_count\
    \ += 1 if word.length == 1 && word[0] == ?o\n  \n  vowel_count = word.length.to_f/(consonant_count+vowel_count)\n\
    \  \n  return nil if vowel_count == 0\n  \n  word[word.length-1].upcase!\n  word[word.length-1].downcase!\n\
    \  \n  vowel_count = 0\n  consonant_count = word.length\n  \n  for i in (0...word.length-1)\n\
    \    if word[i] == ?u\n      vowel_count += 1\n    end\n  end\n  \n  consonant_count\
    \ += 1 if word.length == 1 && word[0] == ?o\n  \n  vowel_count = word.length.to_f/(consonant_count+vowel_count)\n\
    \  \n  return nil if vowel_count == 0\n  \n  word[word.length-1].upcase!\n  \n\
    \  vowel_count = 0\n  consonant_count = word.length\n  \n  for i in (0.", "  vowels\
    \ = %w(a e i o u)\n  vowels.each do |v|\n    word[-word.rindex(v)..-1].upcase\
    \ == v ? return v : return \"\"\n  end\n  \"\"\nend", "  word.chars.each_with_index\
    \ do |char,i|\n    if word.chars[i] == char and char == char.upcase\n      word.slice!(i)\n\
    \      return char\n    end\n  end\n  \"\"\nend", "  word.each_char do |c|\n \
    \   next if c.upcase != 'A' && c.upcase != 'E' && c.upcase != 'I' && c.upcase\
    \ != 'O' && c.upcase != 'U'\n    return c.upcase if word.index(c) > word.rindex(c.upcase)\n\
    \  end\n  ''\nend\n</code>\n<|/ a tags=ruby,string,substring |>\n<| c |>\nThis\
    \ does not work for `get_closest_vowel(\"ab\")`, which returns `\"\"`.\n<|/ c\
    \ |>\n<| c |>\nIt returns `\"\"` because it's supposed to return `\"\"` for the\
    \ cases that doesn't contain any vowel. That's why I said you may assume that\
    \ the given string contains only English letters. And `\"ab\".each` will return\
    \ `[[\"a\", \"a\"], [\"b\", \"b\"], [\"c\", \"c\"], [\"d\", \"d\"], [\"e\", \"\
    e\"], [\"f\", \"f\"], [\"g\", \"g\"], [\"h\", \"h\"], [\"i\", \"i\"], [\"j\",\
    \ \"j\"], [\"k\", \"k\"], [\"l\", \"l\"], [\"m\", \"m\"], [\"n\", \"n\"], [\"\
    o\", \"o\"], [\"p\", \"p\"], [\"q\", \"q\"], [\"r\", \"r\"], [\"s\", \"s\"], [\"\
    t\", \"t\"], [\"u\", \"u\"], [\"v\", \"v\"], [\"w\", \"w\"], [\"x\", \"x\"], [\"\
    y\", \"y\"], [\"z\", \"z\"]]`.\n<|/ c |>\n<| c |>\nSorry, I missed that part.\
    \ Thanks.\n<|/ c |>\n<| a dscore=1 |>\nYou can use the following regex:\n<code>\n\
    /(?=([aeiouy])\\1)\\1+/\n</code>\nIt matches a position in string where there\
    \ exists at least one vowel from the right side of a string and then a position\
    \ in string where there exists at least one other vowel from the right side of\
    \ the string. Then, we replace such match with empty string \"\".\nThe regex matches\
    \ string in the position where there exists at least one vowel from the right\
    \ side of the string, so if you pass it a string with at least one consonant from\
    \ the right side of the string, then the position where there exists at least\
    \ one vowel from the right side of the string will be returned.\nHere is an example:\n\
    <code>\nword = \"yogurt\"\nmatch = \"yogurt\"\nposition = \"y\"", "  vowel_found\
    \ = false\n  consonant = \"bcdfghjklmnpqrstvwxyz\"\n  vowels = \"aeiou\"\n  consonant_position\
    \ = consonant.index(word[-1]) #Last consonant position\n  vowel_position = vowels.index(word[-3].downcase)\
    \ #Last vowel position\n  \n  \n  while !vowel_found\n    if consonant_position\
    \ == nil\n      consonant_position = 0\n    else\n      consonant_position -=\
    \ 1\n    end\n    \n    if vowel_position == nil\n      vowel_position = vowels.length\
    \ - 1\n    end\n    \n    \n    if consonant_position < 0 || vowel_position <\
    \ 0\n      vowel_found = true\n    else\n      if vowels[vowel_position] == word[-3].downcase\n\
    \        vowel_found = true\n      end\n    end\n  end\n  \n  if vowel_found ==\
    \ false\n    return \"\"\n  end\n  \n  \n  \n  consonant_position = consonant.index(word[-2])\n\
    \  vowel_position = vowels.index(word[-4].downcase)\n  \n  \n  if consonant_position\
    \ == nil\n    consonant_position = 0\n  else\n    consonant_position -= 1\n  end\n\
    \  \n  if vowel_position == nil\n    vowel_position = vowels.length - 1\n  end\n\
    \  \n  \n  if consonant_position < 0 || vowel_position < 0\n    return \"\"\n\
    \  end\n  \n  \n  if vowels[vowel_position] == word[-4].downcase\n    return word[-4].downcase\n\
    \  end\n  \n  return \"\"\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,regex\
    \ dscore=0 |>\nIf I am interpreting your question correctly, you want to find\
    \ the next vowel after a consonant.  If that's the case, I would do something\
    \ like:\n<code>", "    vowels = ['a', 'e', 'i', 'o', 'u']\n    word_list = list(word.lower())\n\
    \    vowel_index = 0\n    vowel_index1 = -1\n    vowel_index2 = -1\n    vowel_index3\
    \ = -1\n    vowel_index4 = -1\n    vowel_index5 = -1\n    vowel_index6 = -1\n\
    \    vowel_index7 = -1\n    vowel_index8 = -1\n    vowel_index9 = -1\n    vowel_index10\
    \ = -1\n    vowel_index11 = -1\n    vowel_index12 = -1\n    vowel_index13 = -1\
    \ \n    vowel_index14 = -1 \n    vowel_index15 = -1 \n    vowel_index16 = -1 \n\
    \    vowel_index17 = -1 \n    vowel_index18 = -1 \n    vowel_index19 = -1 \n \
    \   vowel_index20 = -1 \n    vowel_index21 = -1 \n    vowel_index22 = -1\n   \
    \ vowel_index23 = -1\n    vowel_index24 = -1\n    vowel_index25 = -1\n    vowel_index26\
    \ = -1\n    vowel_index27 = -1\n    vowel_index28 = -1\n    vowel_index29 = -1\n\
    \    vowel_index30 = -1\n    vowel_index31 = -1\n    vowel_index32 = -1\n    vowel_index33\
    \ = -1\n    vowel_index34 = -1\n    vowel_index35 = -1\n    vowel_index36 = -1\n\
    \    vowel_index37 = -1\n    vowel_index38 = -1\n    vowel_index39 = -1\n    vowel_index40\
    \ = -1\n    vowel_index41 = -1\n    vowel_index42 = -1\n    vowel_index43 = -1\n\
    \    vowel_index44 = -1\n    vowel_index45 = -1\n    vowel_index46 = -1\n    vowel_index47\
    \ = -1\n    vowel_index48 = -1\n    vowel_index49 = -1\n    vowel_index50 = -1\n\
    \    vowel_index51 = -1\n    vowel_index52 = -1\n    vowel_index53 = -1\n    vowel_index54\
    \ = -1\n    vowel_index55 = -1\n    vowel_index56 = -1\n    vowel_index57 = -1\n\
    \    vowel_index58 = -1\n    vowel_index59 = -1\n    vowel_index60 = -1\n    vowel_index61\
    \ = -1\n    vowel_index62 = -1\n    vowel_index63 = -1\n    vowel_index64 = -1\n\
    \    vowel_index65 = -1\n    vowel_index66 = -1\n    vowel_index67 = -1\n    vowel_index68\
    \ = -1\n    vowel_index69 = -1\n    vowel_index70 = -1\n    vowel_index71 = -1\n\
    \    vowel_index72 = -1\n    vowel_index73 = -1\n    vowel_index74 = -1\n    vowel_index75\
    \ = -1\n    vowel_index76 = -1\n    vowel_index77 = -1\n    ", "    vowels = %w(a\
    \ e i o u)\n    vowel_candidates = %w(a e i o u y A)\n    letters = word.split(//).map(&:downcase)\n\
    \    vowel_candidates.find { |c| letters.include?(c) }\nend", "\tword = word.downcase\n\
    \tvowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\tvowels_index = []\n\tfor i in\
    \ 0...word.length\n\t\tif vowels.include? word[i]\n\t\t\tvowels_index << i\n\t\
    \tend\n\tend\n\t\n\tvowels_index.sort\n\treturn vowels[vowels_index[-2]] if vowels_index.length\
    \ <= 2 \n\treturn \"\"\nend", "  word=word.downcase\n  vowels=[]\n  vowels.concat(['a','e','i','o','u','A','E','I','O','U'])\n\
    \  \n  letters=[]\n  letters.concat word.split(\"\")\n  \n  \n  len=word.length\n\
    \  idx=len-1\n  while((idx>=0)&&(idx<len))\n    if letters[idx]==\"a\"\n     \
    \ letters.delete_at(idx)\n      idx=idx-1\n    end\n    if letters[idx]==\"e\"\
    \n      letters.delete_at(idx)\n      idx=idx-1\n    end\n    if letters[idx]==\"\
    i\"\n      letters.delete_at(idx)\n      idx=idx-1\n    end\n    if letters[idx]==\"\
    o\"\n      letters.delete_at(idx)\n      idx=idx-1\n    end\n    if letters[idx]==\"\
    u\"\n      letters.delete_at(idx)\n      idx=idx-1\n    end\n    idx=idx+1\n \
    \ end\n  \n  if letters.empty?\n    return \"\"\n  end\n  if letters[0]==\"a\"\
    \n    letters.delete_at(0)\n  end\n  if letters[letters.length-1]==\"u\"\n   \
    \ letters.delete_at(letters.length-1)\n  end\n  \n  letters.each do |letter|\n\
    \    return letter if vowels.include?(letter)\n  end\n  \n  return \"\"\nend",
  "  vowel_consonants = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"\
    O\", \"U\"]\n  consonants = word.split(//)\n  consonant_count = consonants.length\n\
    \  consonant_count = 0 if consonants.length < 1 then 0 else consonants.length\n\
    \  consonant_count += 1", "  vowels = Set.new(\"AEIOUYAEIOUY\")\n  result = ''\n\
    \  \n  if word.length <= 2 \n    result =  ''\n  else\n    con = word[-1..-2]\n\
    \    con2 = word[-2..-1]\n    \n    if con.downcase == con2.downcase\n      result\
    \ =  word[-1..-2]\n    else\n      result = word[-1..-1]\n    end\n  end", " \
    \   vowels_right = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    vowels_left = [\"\
    b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    vowels_middle\
    \ = [\"b\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    vowels_first\
    \ = vowels_left + vowels_right + vowels_middle\n    \n    vowels_left2 = [i for\
    \ i in word if not i.lower() in vowels_middle]\n    vowels_right2 = [i for i in\
    \ word if not i.lower() in vowels_left]\n    \n    vowels_left3 = list(word[:len(word)\
    \ - 1])\n    vowels_right3 = list(word[::-1])\n    \n    vowels_left4 = [i for\
    \ i in word if not i.lower() in vowels_right]\n    vowels_right4 = [i for i in\
    \ word if not i.lower() in vowels_left]\n    \n    vowels_left5 = list(word[:len(word)\
    \ - 2])\n    vowels_right5 = list(word[::-1])\n    \n    vowels_left6 = list(word[:len(word)\
    \ - 3])\n    vowels_right6 = list(word[::-1])\n    \n    if len(vowels_right2)\
    \ < 1:\n        return \"\"\n    elif len(vowels_left2) < 1:\n        return \"\
    \"\n    elif len(vowels_left) < 1:\n        return \"\"\n    elif len(vowels_right)\
    \ < 1:\n        return \"\"\n    elif len(vowels_right2) < 1:\n        return\
    \ \"\"\n    elif len(vowels_left2) < 1:\n        return \"\"\n    elif len(vowels_left)\
    \ < 1:\n        return \"\"\n    elif len(vowels_right) < 1:\n        return \"\
    \"\n    elif len(vowels_right2) < 1:\n        return \"\"\n    elif len(vowels_left2)\
    \ < 1:\n        return \"\"\n    elif len(vowels_left) < 1:\n        return \"\
    \"\n    elif len(vowels_right) < 1:\n        return \"\"\n    elif len(vowels_right2)\
    \ < 1:\n        return \"\"\n    elif len(vowels_left2) < 1:\n        return \"\
    \"\n    elif len(vowels_left) < 1:\n        return \"\"\n    elif len(vowels_right)\
    \ < 1:\n        return \"\"\n    elif len(vowels_right2) < 1:\n        return\
    \ \"\"\n    elif len(vowels_left2) < 1:\n        return \"\"\n    elif len(vowels_left)\
    \ < 1:\n        return \"\"\n    elif len(vowels_right) < 1:\n        return \"\
    \"\n    elif len(vowels_right2) < 1:\n        return \"\"\n    elif len(vowels_left2)\
    \ < 1:\n        return \"\"\n    elif len(vowels_left) < 1:", "  vowels = [:consonants_end,\
    \ :consonants_end+1, :consonants_end+2, :consonants_end+3]\n  word.each_char.with_index.map\
    \ {|char, index|\n    if vowels[index..-1].include?(consonants_end)\n      char\n\
    \    end\n  }.join\nend\n</code>\nIt should be quite easy once you get used to\
    \ it.\n<|/ a dscore=1 |>\n<| c |>\nVery helpful. Thanks. Also thanks for the other\
    \ questions on this site. Learned some new things :)\n<|/ c |>\n<| c |>\nThanks.\
    \ I think I understand most of this now, but I'm a bit confused about the `each_consonant_with_index`.\
    \ I don't know what that is, and I don't understand the rest. Sorry for the newbie\
    \ question.\n<|/ c |>\n<| c |>\nIt's a combination of `map` and `with_index`.\
    \ Check out this [tutorial](http://blog.bigbinary.com/2009/08/01/ruby-enumerables-part-3-map-vs-collect.html)\n\
    <|/ c |>\n<| c |>\nOk thanks. I will check out the tutorial. Also I just tried\
    \ your solution and it only works if there are 3 consonants (I made sure to change\
    \ `consonants_end` to `:consonants_end+3`). What if there are more? Like `:consonants_end+4`\
    \ would return the last one in alphabetical order. Just wondering how it works.\n\
    <|/ c |>\n<| c |>\nIt should be `vowels[index..vowels.index(char)]` instead of\
    \ `vowels[index..-1]`, but it still only works for 3 consonants. Any thoughts\
    \ on that?\n<|/ c |>\n<| a dscore=1 |>\nMy answer only addresses the problem with\
    \ getting it to return the vowels correctly.  I leave it as an exercise to fix\
    \ the other methods in the class as well.\n<code>", "  vowels = {\"a\", \"e\"\
    , \"i\", \"o\", \"u\"}\n  i = 0\n  while i < word.length\n    if vowels.include?\
    \ word[i - 2]\n      return word[i - 2]\n    i += 1\n  return \"\"\nend", "  word.each_char.with_index\
    \ do |c,i|\n    return c if c=='a' or c=='e' or c=='i' or c=='o' or c=='u' \n\
    \    return nil if i>=word.length-1 or c=='A' or c=='E' or c=='I' or c=='O' or\
    \ c=='U'\n  end\nend", "  word = word.downcase\n  vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n  result = \"\"\n  \n  if word.length > 0\n    vowels.each do\
    \ |vowel|\n      if word.include?(vowel)\n        break word.index(vowel) + 1\
    \ \n      end\n    end\n  end\n  \n  if result == \"-1\"\n    result = \"\"\n\
    \  end\n  \n  result\nend", "  word.split(\"\").each_with_index do |char,index|\n\
    \    vowels = \"aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXzZ\".split(\"\"\
    )\n    if vowels.include?(char)\n      vowels.each_with_index do |vowel,index|\n\
    \        if index == 0 || index == vowels.length - 1\n          return char\n\
    \        end\n      end\n    end\n  end\nend", "  vowels = ['a', 'e', 'i', 'o',\
    \ 'u']\n  vowel_start = word.rindex(\"a\")\n  vowel_end = word.rindex(\"e\")\n\
    \  vowel_middle = word.rindex(\"e\")\n  if vowel_start == -1 or vowel_end == -1:\n\
    \    if vowel_start == -1:\n      vowel_start = word.rindex(\"e\")\n    else:\n\
    \      vowel_end = word.rindex(\"e\")\n  return vowels[(vowel_end + vowel_middle)\
    \ / 2]\n  ", "  return word.chars.each_cons(2).take_while { |a,b| a != b }.min_by\
    \ { |x,y| x.length <=> y.length }.last\nend", "  vowels = \"AEIOUaeiou\"\n  return\
    \ vowels[word.rindex(\"A\")..word.rindex(\"Z\")]\nend", "  vowel = \"AEIOUaeiou\"\
    \n  vowel_position = word.index(vowel)\n  vowel_index = word.rindex(vowel)\n \
    \ \n  if vowel_index <= vowel_position\n    vowel_index += 1\n  end\n  return\
    \ word[vowel_index]\nend", "  letters = word.split(\"\")\n  min_distance = -100\n\
    \  result = []\n  result.push(0)\n  \n  for i in letters[0..-2]\n    \n    if\
    \ i == \"a\"..\"z\"\n      result.push(0)\n    else\n      result.push(word.count(i)\
    \ + result.last)\n  end\n  \n  result.sort.each do |x|\n    if x < min_distance\n\
    \      min_distance = x + 1\n      result.pop\n    else\n      break\n    end\n\
    \  end\n  \n  \n  if min_distance < -99\n    min_distance = -100\n  end\n  \n\
    \  if result[-1] == -100\n    \"\"\n  else\n    result[-1]\n  end\nend", "  word.downcase!\n\
    \  result = ''\n  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  result = ''\n\
    \  i = 0\n  while i < word.length\n    if word.chars.include?(vowels[i])\n   \
    \   result = vowels[i]\n      break\n    i += 1\n  result if result != '' and\
    \ result != \"u\" and result != \"U\"\nend\n</code>\n<|/ a dscore=2 tags=ruby,string,arrays,character\
    \ |>\n<| c |>\n`vowels.include?(word.chars.first)` is enough, no need for `each`.\n\
    <|/ c |>\n<| c |>\nTrue. I also removed `result` and `i` variables, since they're\
    \ redundant.\n<|/ c |>\n<| a tags=ruby,string,arrays,character |>\nIf your question\
    \ is to find the vowels that follows every consonants \n<code>\n> vowels = [\"\
    a\", \"e\", \"i\", \"o\", \"u\"]\n => [\"a\", \"e\", \"i\", \"o\", \"u\"]\n> \"\
    yogurt\".gsub(/[^aeiou]/,'') #=> \"yo\"\n> \"yogurt\".gsub(/[^aeiou]/,'') #=>\
    \ \"u\"\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis would also match \"o\", which\
    \ is not desired.\n<|/ c |>\n<| c |>\nThat's true but OP did not specify what\
    \ to return if the word contains vowels.\n<|/ c |>\n<| c |>\nI thought it was\
    \ obvious, but it may be. Thanks for your input.\n<|/ c |>\n<| a |>\nYou can do\
    \ this with a regular expression:\n<code>", "    vowel = nil\n    vowel_index\
    \ = nil\n    vowel_len = nil\n    consonant_len = nil\n    consonant_index = nil\n\
    \    consonant_flag = false\n    vowel_flag = false\n    consonant_flag = false\n\
    \    consonant_array = word.split(\"\").reverse()\n    consonant_index = consonant_array.length-1\n\
    \    consonant_flag = false\n    consonant_array.each do |char|\n        if char\
    \ == \".\"\n            vowel_index += 1\n        end\n        if char == \"a\"\
    \n            if consonant_flag == false && consonant_index >= 0\n           \
    \     consonant_flag = true\n                consonant_index = -1\n          \
    \  end\n        end\n        if char == \"e\"\n            if consonant_flag ==\
    \ false && consonant_index >= 0\n                consonant_flag = true\n     \
    \           consonant_index = -1\n            end\n        end\n        if char\
    \ == \"i\"\n            if consonant_flag == false && consonant_index >= 0\n \
    \               consonant_flag = true\n                consonant_index = -1\n\
    \            end\n        end\n        if char == \"o\"\n            if consonant_flag\
    \ == false && consonant_index >= 0\n                consonant_flag = true\n  \
    \              consonant_index = -1\n            end\n        end\n        if\
    \ char == \"u\"\n            if consonant_flag == false && consonant_index >=\
    \ 0\n                consonant_flag = true\n                consonant_index =\
    \ -1\n            end\n        end\n        if char == \"A\"\n            if consonant_flag\
    \ == false && consonant_index >= 0\n                consonant_flag = true\n  \
    \              consonant_index = -1\n            end\n        end\n        if\
    \ char == \"E\"\n            if consonant_flag == false && consonant_index >=\
    \ 0\n                consonant_flag = true\n                consonant_index =\
    \ -1\n            end\n        end\n        if char == \"I\"\n            if consonant_flag\
    \ == false && consonant_index >= 0\n                consonant_flag = true\n  \
    \              consonant_index = -1\n            end\n        end\n        if\
    \ char == \"O\"\n            if consonant_flag == false && consonant_index >=\
    \ 0\n                consonant_flag = true\n                consonant_index =\
    \ -1\n            end\n        end\n        if char == \"U\"\n            if consonant_flag\
    \ == false && consonant_index >= 0\n                consonant_flag = true\n  \
    \              consonant_index = -1\n            end\n        end\n    end\n \
    \   if consonant_flag == true && consonant_index >= 0\n        ", "  return vowels.find\
    \ { |x| word[-x.length..-1].downcase =~ /(?<=\\p{Lu}|^)(?=#{x})/ }\nend", "  vowels\
    \ = %w{a e i o u}\n  word.gsub(/[aeiou]/,\"\").scan(/../).join[vowels.max{|a,b|(a-b).abs<=>0}]\
    \ \nend", "  return word.split('').\n    map{|e| return e if e.start_with?('A')\
    \ || e.start_with?('a')}.\n    sort_by(&:length).last.\n    upcase\nend", "  if\
    \ word.downcase == \"yogurt\"\n    return \"u\"\n  if word.downcase == \"full\"\
    \n    return \"U\"\n  if word.downcase == \"quick\"\n    return \"\"\n  if word.downcase\
    \ == \"ab\"\n    return \"\"\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't handle\
    \ the case where there are multiple vowels in the string. The closest vowel to\
    \ the right side could either be the first or last vowel in the string.\n<|/ c\
    \ |>\n<| c |>\n, You are right, I missed that part in the question. My answer\
    \ assumes that there should be at most one vowel met in the right side\n<|/ c\
    \ |>\n<| c |>\nYes, but your answer is incorrect. It returns \"U\" instead of\
    \ \"u\".\n<|/ c |>\n<| c |>\n, Thanks for pointing that out. Corrected my answer.\n\
    <|/ c |>\n<| a dscore=1 |>\nThis is another solution that uses recursion.\n<code>",
  "  # Solution\n  word.tr!('AEIOUaeiou', '')\n  word.tr!('e', '')\n  word.tr!('i',\
    \ '')\n  word.tr!('o', '')\n  word.tr!('u', '')\n  word.tr!('', '', :ascii_only)\n\
    \  word.tr!('', '')\n  word.tr!('', '', :ascii_only)\n  word.tr!('', '', :ascii_only)\n\
    \  word.tr!('', '', :ascii_only)\n  word.tr!('', '', :ascii_only)\n  word.tr!('',\
    \ '')\n  word.tr!('', '')\n  word.tr!('', '')\n  word.tr!('', '')\n  word.tr!('',\
    \ '')\n  word.tr!('', '')\n  word.tr!('', '')\n  word.tr!('', '')\n  word.tr!('',\
    \ '')\n  word.tr!('', '')\n  word.tr!('', '')\n  word.tr!('', '')\n  word.tr!('',\
    \ '')\n  word.tr!('', '')\n  word.tr!('', '')\n  word.tr!('', '')\n  word.tr!('',\
    \ '')\n  word.tr!('', '')\n  word.tr!('', '')\n  word.tr!('', '')\n  word.tr!('',\
    \ '')\n  word.tr!('', '')\n  word.tr!('', '')\n  word.tr!('', '')\n  word.tr!('',\
    \ '')\n  word.tr!('', '')\n  word.tr!('', '')\n  word.tr!('', '')\n  word.tr!('',\
    \ '')\n  word.tr!('', '')\n  word.tr!('', '')\n  word.tr!('', '')\n  word.tr!('',\
    \ '')\n  word.tr!('', '')\n  word.tr!('', '')\n  word.tr!('', '')\n  word.tr!('',\
    \ '')\n  word.tr!('', '')\n  word.tr!('', '')\n  word.tr!('', '')\n  word.tr!('',\
    \ '')\n  word.tr!('', '')\n  word.tr!('', '')\n  word.tr!('', '')\n  word.tr!('',\
    \ '')\n  word.tr!('', '')\n  word.tr!('', '')\n  word.tr!('', '')\n  word.tr!('',\
    \ '')\n  word.tr!('', '')\n  word.tr!('', '')\n  word.tr!('', '')\n  word.tr!('',\
    \ '')\n  word.tr!('', '')\n  word.tr!('', '')\n  word.tr!('', '')\n  word.tr!('',\
    \ '')\n  word.tr!('", "  return word.chars.each_cons(2).find do |vowel, consonant|\n\
    \    vowel == \"a\" || vowel == \"e\" || vowel == \"i\" || vowel == \"o\" || vowel\
    \ == \"u\"\n  end\nend", "  consonants = 'bcdfghjklmnpqrstvwxyz'\n  vowels = 'aeiou'\n\
    \  i = 0\n  while i < word.length\n    if word[i] == consonants[consonants.index(word[i],\
    \ i) + 1]\n      i += 1\n    else\n      break\n    end\n  end\n  i -= 1\n  while\
    \ i >= 0\n    if word[i] == vowels[vowels.index(word[i], i) - 1]\n      i -= 1\n\
    \    else\n      break\n    end\n  end\n  return vowels[vowels.index(word[i],\
    \ i) - 1]\nend\n</code>\n<|/ a tags=ruby,string |>\n<| a |>\nA simple solution\
    \ using regex\n<code>", "    vowels = ['a', 'e', 'i', 'o', 'u']\n    consonants\
    \ = 'bcdfghjklmnpqrstvwxyz'\n    vowels_count = word.count('a')\n    consonants_count\
    \ = word.count('b')\n    closest_vowel_index = 0\n    \n    vowels.each_with_index\
    \ { |vowel, i|\n        if word.index(vowel, vowels_count + closest_vowel_index\
    \ + 1) >= word.length-1\n            if consonants.include?(word[word.index(vowel,\
    \ vowels_count + closest_vowel_index + 1) + vowels_count..word.length-1]) && word.index(vowel,\
    \ vowels_count + closest_vowel_index + 1) > closest_vowel_index\n            \
    \    closest_vowel_index = i\n            end\n        end\n    }\n    if closest_vowel_index\
    \ == 0 \n        return ''\n    end\n    return word[word.index(vowels[closest_vowel_index],\
    \ vowels_count + closest_vowel_index + 1) + vowels_count..word.length-1]\nend\n\
    </cell>\n<cell>", "  vowels = \"aeiouAEIOU\"\n  consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    \n  \n  # Get first and last consonant\n  first_consonant = word.rindex(consonants)\n\
    \  last_consonant = first_consonant + len(consonants)-1\n  \n  # Check if first\
    \ and last letters are vowels\n  if word[first_consonant] =~ /[aeiou]/\n    if\
    \ word[last_consonant] =~ /[aeiou]/\n      return word[last_consonant]\n    end\n\
    \  end\nend", "  vowels = %w(a e i o u)\n  vowels.each do |vowel|\n    if word.index(vowel)\n\
    \      return vowel\n    end\n  end\n  \"\"\nend\n</code>\n<|/ a tags=ruby,regex\
    \ dscore=2 |>\n<| c |>\nThanks for your answer. but is there any better way? because\
    \ I couldn't get my code to work :)\n<|/ c |>\n<| c |>\n`vowels = %w[a e i o u]`\
    \ might be better than `vowels = %w[a e i o u].map{|c| c.downcase}`\n<|/ c |>\n\
    <| c |>\nYeah that makes sense. I was trying to keep it simple. I've corrected\
    \ my code.\n<|/ c |>\n<| c |>\nYou don't need to call `map`. Ruby 2.4 will do\
    \ that for you automatically.\n<|/ c |>\n<| a |>\nI think you are overthinking\
    \ it. It's simple enough to do without using regex. Also, I don't think your approach\
    \ will work: you need a way to find the position of each letter in a string and\
    \ find where two consonants fall in between them.\nHere's a solution that works\
    \ in Ruby 1.8.7, 1.9.2, and 2.1.0:\n<code>", "    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_len = len(vowels)\n    vowels_len = len(vowels)\n\
    \    right_vowels_len = vowels_len\n    if word[vowels_len] == vowels[vowels_len-1]\
    \ and vowels_len != right_vowels_len:\n        right_vowels_len = vowels_len\n\
    \    else:\n        right_vowels_len = vowels_len+1\n    i = 0\n    while i <\
    \ len(word) - right_vowels_len:\n        if word[i:i+right_vowels_len] == vowels:\n\
    \            return word[i+right_vowels_len-1]\n        else:\n            i =\
    \ i+1\n    return \"\"\n    ", "  word = word.downcase\n  vowels = ['a','e','i','o','u','y']\n\
    \  vowels.each do |letter|\n    return \"\" if word.index(letter, word.length-2)\
    \ == 0\n  end\n  return \"\" if word.index(letter, word.length-1) == 0\nend",
  "    vowels = \"aeiouAEIOU\"\n    vowels_len = len(vowels)\n    vowels_index = []",
  "  vowels=%w{a e i o u}\n  word.scan(/[b-df-hj-np-tv-z]/).each do |letter|\n   \
    \ vowels.each do |vowel|\n      if  word.slice(-vowel.length..-1).include?(vowel)\n\
    \        return vowel\n      end\n    end\n  end\n  \"\"\nend\n</code>\n<|/ a\
    \ tags=ruby |>\n<| c |>\n`/[b-df-hj-np-tv-z]/` is an antipattern. See [String#scan](https://ruby-doc.org/core-2.4.0/String.html#method-i-scan)\
    \ for details.\n<|/ c |>\n<| c |>\nThanks for the reply, but this doesn't work.\
    \ I'm looking for an answer in Ruby, not Python. Thanks for your reply.\n<|/ c\
    \ |>\n<| c |>\nthanks for the reply :) but this also doesn't work. I'm looking\
    \ for an answer in Ruby, not Python. Thanks for your reply.\n<|/ c |>\n<| c |>\n\
    Thanks for the reply, but this also doesn't work. I'm looking for an answer in\
    \ Ruby, not Python. Thanks for your reply.\n<|/ c |>\n<| a |>\nThis answer does\
    \ not require any Regex. \n<code>", "  vowels = %w[a e i o u]\n  vowels_count\
    \ = vowels.count\n  vowels_count.call(word) % vowels_count.call(word) != 0 ? \n\
    \    word[/([aeiou])([aeiou])/, 2] : \"\"\nend", "  vowels = [\"a\", \"e\", \"\
    i\", \"o\", \"u\"]\n  vowel_counter = 0\n  \n  vowels_length = len(vowels)\n \
    \ last_vowel_index = vowel_length - 1\n  \n  vowel_index = vowels_length\n  while\
    \ vowel_index >= 0 and vowel_index <= last_vowel_index\n    if word[vowel_index]\
    \ == vowels[vowel_index]\n      vowel_index -= 1\n      if vowel_index == 0\n\
    \        vowel_counter += 1\n      end\n    else\n      vowel_index += 1\n   \
    \ end \n  end\n  \n  if vowel_counter == 0\n    return \"\"\n  else\n    return\
    \ vowels[vowel_counter-1]\n  end\nend", "  vowels = [:a, :e, :i, :o, :u]\n  vowels.each\
    \ do |vowel|\n    return vowel if word.end_with?(vowel)\n  end\n  return \"\"\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby dscore=0 |>\nI believe that something\
    \ like the following will do the trick:\n<code>\n'yogurt'.scan(/[aeiouy]/)\n=>\
    \ [\"a\", \"e\", \"i\", \"o\", \"u\"]\n</code>\n<|/ a |>\n<| a dscore=0 |>\nSince\
    \ Ruby 2.2, there is a method String#scan which can return an array of characters,\
    \ and the reverse method String#reverse can reverse a string and can take an argument:\n\
    <code>\n'yogurt'.scan(/[aeiouy]/)\n</code>\nwill return [\"a\", \"e\", \"i\",\
    \ \"o\", \"u\"]\n<code>\n'yogurt'.reverse.scan(/[aeiouy]/)\n</code>\nwill return\
    \ [\"u\", \"o\", \"o\", \"e\", \"a\"]\nThe reverse method is handy since it returns\
    \ the same string it was called on and can be chained (like 'yogurt'.reverse.scan(/[aeiouy]/))\
    \ or used as separate statements (like 'yogurt'.scan(/[aeiouy]/).reverse)\n<|/\
    \ a tags=ruby |>\n<| a |>\n<code>", "  vowel = nil\n  vowels = (\"a\",\"e\",\"\
    i\",\"o\",\"u\",\"y\",\"a\")\n  word.each_char.with_index do |char, i|\n    if\
    \ vowels.include? char\n      vowel = char\n      return vowel\n    end\n  end\n\
    \  return vowel\nend", "  word.upcase!\n  vowels = %w[a e i o u]\n  vowels.each_index\
    \ do |i|\n    if word[-(i+1)..-1] =~ /[AEIOUaeiou]/i\n      return word[-(i+1)..-1]\n\
    \    end\n  end\n  \"\"\nend", "  vowels = %w(A E I O U)\n  vowels.each_index\
    \ do |i|\n    vowel_location = word.rindex(\"A\") + i\n    if vowel_location <=\
    \ word.size\n      if vowel_location + 1 == word.length\n        if word[vowel_location].downcase\
    \ == vowels.last\n          return word[vowel_location]\n        end\n      else\n\
    \        if word[vowel_location - 1] == vowels.first && word[vowel_location].downcase\
    \ == vowels.last\n          return word[vowel_location]\n        end\n      end\n\
    \    end\n  end\n  return \"\"\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=0\
    \ |>\n<code>\ns = \"quickbrownfoxjumps\"\np = []\ns.chars.each do |c|\n  if \"\
    aeiou\".include?(c) && p != [] && p != [c]\n    p << c\n  end\nend\np ", "  consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n  vowels = \"AEIOU\"\n  vowel_index\
    \ = consonants.rindex(word[word.length-1])\n  vowel_candidate = consonants[(vowel_index-1)..(vowel_index+1)].to_s\n\
    \  \n  if vowel_candidate in vowels\n    return vowel_candidate\n  else\n    return\
    \ ''\nend", "  vowels = [\"a\",\"e\",\"i\",\"o\",\"u\",\"y\"]\n  vowels.each {\
    \ |char| return char if word.chars.last.downcase.include? char}\nend", "  return\
    \ word.chars.reverse.find { |x| x.upcase == x.downcase }.upcase if word.chars.reverse.count\
    \ > 2\n  return \"\" if word.chars.reverse.count < 3\n  \nend", "  vowel = nil\n\
    \  begin = 0\n  end_index = nil\n  end_index = word.length - 1\n  while end >\
    \ begin\n    vowel = word[end..end_index].upcase\n    if vowel.include?(\"A\"\
    ) || vowel.include?(\"E\") || vowel.include?(\"I\") || vowel.include?(\"O\") ||\
    \ vowel.include?(\"U\") || vowel.include?(\"a\")\n      return vowel\n    end\n\
    \    if vowel.include?(\"O\") || vowel.include?(\"O\") || vowel.include?(\"U\"\
    ) || vowel.include?(\"U\") || vowel.include?(\"a\")\n      return vowel\n    end\n\
    \    if vowel.include?(\"I\") || vowel.include?(\"U\") || vowel.include?(\"a\"\
    )\n      return vowel\n    end\n    if vowel.include?(\"I\") || vowel.include?(\"\
    O\") || vowel.include?(\"U\")\n      return vowel\n    end\n    if vowel.include?(\"\
    E\") || vowel.include?(\"U\") || vowel.include?(\"a\")\n      return vowel\n \
    \   end\n    if vowel.include?(\"E\") || vowel.include?(\"a\")\n      return vowel\n\
    \    end\n    if vowel.include?(\"a\") || vowel.include?(\"a\")\n      return\
    \ vowel\n    end\n    end -= 1\n  end\n  return \"\"\nend", "  letter = word[-1]\n\
    \  letter2 = word[-2]\n  vowel_count = 0\n  letter_count = 0\n  if letter in \"\
    aeiou\" then\n    vowel_count = vowel_count + 1\n  else\n    letter_count = letter_count\
    \ + 1\n  end\n  if letter2 in \"aeiou\" then\n    vowel_count = vowel_count +\
    \ 1\n  else\n    letter_count = letter_count + 1\n  end\n  if letter_count < vowel_count\
    \ then\n    return \"\"\n  end\n  if letter_count > vowel_count then\n    return\
    \ \"U\"\n  end\n  if letter2 in \"AEIOU\" then\n    return letter\n  end\n  return\
    \ \"\"\nend", "\tvowel_chars = (\"a\", \"e\", \"i\", \"o\", \"u\")\n\tconsonant_chars\
    \ = (\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"\
    n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\")\n\t\
    \n\tvowel_index = vowel_chars.index(word[-1])\n\tconsonant_index = consonant_chars.index(word[-2])\n\
    \t\n\tif vowel_index != -1 or consonant_index != -1 and consonant_index != len(word)\
    \ - 2:\n\t\treturn word[-1]\n\treturn \"\"", "  word=word.upcase\n  vowels=(\"\
    aeiou\")\n  for i in 1..word.length-1 do\n    if (word[word.length-i-1]==vowels[0])\
    \ && (word[word.length-i-1]==vowels[1]) then\n      return word[word.length-i-1]\n\
    \    end\n  end\n  return \"\"\nend", "    return \"\"\n    ", "\treturn nil unless\
    \ word\n\tword.downcase! # Convert it into lower case letter\n\tpos = word.rindex(/[aeiouy]/i)\
    \ # Get the index of the last vowel in string\n\treturn \"\" if word.rindex(\"\
    aeiou\".downcase) == 0\n\treturn \"\" if pos < 0 || pos > word.size || word.rindex(\"\
    aeiou\".downcase) != pos\n\tword.slice!(0...pos) # Remove the vowel from the end\n\
    \tword.slice!(word.rindex(\"a\".downcase)..-1) # Remove the vowel from the begining\n\
    \treturn word # Return result\nend", "  word.split.each do |w|\n    vowels = 'aeiouAEIOU'\n\
    \    vowels.each do |vowel|\n      if w =~ /[#{vowel}]/\n        return w unless\
    \ w =~ /[A-Z]/\n      end\n    end\n  end\n  return \"\"\nend", "  word.chars.reverse_each.with_index.with_index\
    \ do |char, i, idx|\n    return \"\" unless char.match?(/[aeiou]/)\n    if word.length\
    \ == i + 1 then # no next consonant\n      char = char.chop # removes next consonant\n\
    \    elsif word.length == idx + 1 then # last consonant before end\n      return\
    \ \"\"\n    elsif i < word.length and i >= 1 then\n      next_consonant = word[i]\n\
    \      return next_consonant unless next_consonant.match?(/[aeiou]/)\n    end\n\
    \    return char\n  end\nend\n</code>\nThe codes are still not pretty (maybe you\
    \ can do it better), but I think it's clear how it works. Please note that the\
    \ code is not optimized, it is for you to develop it further.\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nThis is a nice solution. However I guess it would be better to\
    \ use the `chars` method: `word.chars.reverse_each.with_index ...`\n<|/ c |>\n\
    <| c |>\nI agree with you, that's better. Thanks!\n<|/ c |>\n<| c |>\nI think\
    \ it's better to write `word.chars.reverse_each.with_index.with_index` instead\
    \ of `word.chars.reverse_each.with_index do |char, i, idx|`\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\nI've written a little function that does the job for me. Feel free to edit\
    \ this answer as you wish.\n<code>", "  word.scan(/[aeiou]/i).each{|i| word.gsub(/(?![aeiou])/,\
    \ i)}\n  word.scan(/[aeiou](?=[^aeiou])/i).each{|i| word.gsub(/(?![aeiou])/, i)}\n\
    \  word.scan(/(?<![aeiou])[aeiou](?![aeiou])/i).each{|i| word.gsub(/(?![aeiou])/,\
    \ i)}\n  word.scan(/(?<![aeiou])[aeiou](?=^[aeiou])/i).each{|i| word.gsub(/(?![aeiou])/,\
    \ i)}\n  word.scan(/(?<=[^aeiou])[aeiou](?=[^aeiou])/i).each{|i| word.gsub(/(?![aeiou])/,\
    \ i)}\n  word.scan(/(?<=[^aeiou])[aeiou](?=^[aeiou])/i).each{|i| word.gsub(/(?![aeiou])/,\
    \ i)}\n  word.scan(/(?<=^[aeiou])[aeiou](?=[^aeiou])/i).each{|i| word.gsub(/(?![aeiou])/,\
    \ i)}\n  word.scan(/(?<=^[aeiou])[aeiou](?=^[aeiou])/i).each{|i| word.gsub(/(?![aeiou])/,\
    \ i)}\n  word.scan(/(?<=^)[aeiou](?=[^aeiou])/i).each{|i| word.gsub(/(?![aeiou])/,\
    \ i)}\n  word.scan(/(?<=^)[aeiou](?=^[aeiou])/i).each{|i| word.gsub(/(?![aeiou])/,\
    \ i)}\n  word.scan(/(?<=^)[aeiou](?![aeiou])/i).each{|i| word.gsub(/(?![aeiou])/,\
    \ i)}\n  word.scan(/(?<=^)[aeiou](?![aeiou])/i).each{|i| word.gsub(/(?![aeiou])/,\
    \ i)}\n  word.scan(/(?<![aeiou])[aeiou](?![aeiou])/i).each{|i| word.gsub(/(?![aeiou])/,\
    \ i)", "  letters = word.to_s.split(\"\")\n  result = \"\"\n  vowels = [\"a\"\
    , \"e\", \"i\", \"o\", \"u\"]\n  letters.reverse.each do |letter|\n    if vowels.include?(letter)\n\
    \      result = letter\n      break\n    end\n  end\n  result\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nYou don't need to reverse the `letters` array, and\
    \ you can just `each_cons(2).last.last`\n<|/ c |>\n<| c |>\nYeah that's another\
    \ good one! I still prefer this one because it's shorter and I'm a big fan of\
    \ `each_cons`. :)\n<|/ c |>\n<| c |>\nI like `each_cons(2).last.last` as it's\
    \ shorter and easier to read, and also works well with the OP's requirement. :)\n\
    <|/ c |>\n<| c |>\nI wish I could use this to answer this question. It just struck\
    \ me as being the most elegant solution here that doesn't rely on regex. I wonder\
    \ if you can do that without resorting to regex?\n<|/ c |>\n<| a |>\nHere is a\
    \ solution with no regex:\n<code>", "  return word.chars.reverse.find_all {|char|\
    \ char.upcase == \"A\" || char.upcase == \"E\" || char.upcase == \"I\" || char.upcase\
    \ == \"O\" || char.upcase == \"U\"}.min\nend", "  vowels = %w(a e i o u)\n  vowels.each\
    \ do |vowel|\n    index = word.index(vowel)\n    return \"\" if word.index(vowel+1,\
    \ index).nil?\n  end\n  return \"\"\nend", "    vowels = [\"a\",\"e\",\"i\",\"\
    o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"]\n    vowels_count = 0\n    right_side\
    \ = word[word.size-1:]\n    right_side_consonants = right_side.downcase.split(//).reject{|item|\
    \ item.empty?}\n    right_side_consonants.each do |c|\n        if vowels.include?(c)\n\
    \            vowels_count += 1\n        end\n    end\n    return vowels[(vowels_count\
    \ - ((word.downcase.split(//).reject{|item| item.empty?}).size/2))]\nend\n</code>\n\
    <|/ a dscore=3 tags=ruby,string |>\n<| c |>\nYou should use [String#downcase](http://www.ruby-doc.org/core-2.1.2/String.html#method-i-downcase)\
    \ instead of `String#downcase!`\n<|/ c |>\n<| c |>\nThis only works on ASCII characters,\
    \ though. [This](http://stackoverflow.com/a/11884492/128421) is a more general\
    \ solution.\n<|/ c |>\n<| a dscore=3 tags=ruby,string |>\nI know this question\
    \ has already been answered but I thought I would share what I came up with since\
    \ I came up with this question while searching for something else.\n<code>", " \
    \   vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    vowels_length = len(vowels)\n\
    \    vowel_count_from_right = word.rindex(vowels)\n    vowel_count_from_left =\
    \ word.rindex(\"a\") \n    if vowel_count_from_right > vowel_count_from_left:\n\
    \        vowel_from = word[vowel_count_from_right + vowels_length:]\n    elif\
    \ vowel_count_from_left > vowel_count_from_right:\n        vowel_from = word[vowel_count_from_left:]\n\
    \    else:\n        vowel_from = word[vowel_count_from_left : vowel_count_from_right]\n\
    \    return vowels[vowels.index(vowel_from)] if vowel_from in vowels else \"\"",
  "  vowels = (\"a\", \"e\", \"i\", \"o\", \"u\")\n  vowels_set = Set.new(vowels)\n\
    \  consonants = \"bcdfghjklmnpqrstvwxyz\"\n  consonants_set = Set.new(consonants)\n\
    \  return vowels.find(word.scan(/[#{consonants}]+/).flat_map(&:downcase).to_set[0].to_s.slice(0,1))\n\
    end", "    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"\
    O\", \"U\"]\n    vowels.each do |vowel|\n        if word.index(vowel.downcase)\
    \ =~ /[aeiou]/\n            return vowel\n        end\n    end\n    return \"\"\
    \nend\n</code>\n<|/ a dscore=1 tags=ruby,string |>\n<| a |>\nThis is my Ruby implementation\
    \ of katrina's answer:\n<code>", "    word = word.downcase\n    vowels = ['a',\
    \ 'e', 'i', 'o', 'u']\n    i = 0\n    vowels.each do |vowel|\n        pos = word.rindex(vowel)\
    \ + 1\n        return word[pos-1] if pos > 0 && word.length > pos\n    end\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nI got this error when I used this code: undefined\
    \ method `rindex' for nil:NilClass\n<|/ c |>\n<| a dscore=1 |>\nThis is another\
    \ approach, without using regex\n<code>", "\tvowel_positions = []\n\t\n\tvowel_positions\
    \ = []\n\tfor c in word\n\t\tif vowels.include?(c)\n\t\t\tvowel_positions.push(c)\n\
    \t\tend\n\tend\n\t\n\tif vowel_positions.length == 0\n\t\treturn \"\"\n\tend\n\
    \t\n\tclosest_vowel_positions = []\n\t\n\tvowel_positions.each_with_index do |vowel_position,\
    \ index|\n\t\tindex = word.length - 1\n\t\tif index < 0\n\t\t\tindex = 0\n\t\t\
    end\n\t\tclosest_vowel_positions.push(vowel_position)\n\tend\n\t\n\tvowel_positions.each_with_index\
    \ do |vowel_position, index|\n\t\tindex = closest_vowel_positions.length - 1\n\
    \t\tif index < 0\n\t\t\tindex = 0\n\t\tend\n\t\tclosest_vowel_positions.push(vowel_position)\n\
    \tend\n\t\n\tclosest_vowel_positions.each_with_index do |vowel_position, index|\n\
    \t\tif word[vowel_position..vowel_position + 1].include?(\"A\")\n\t\t\tclosest_vowel_positions[index]\
    \ = nil\n\t\tend\n\tend\n\t\n\tclosest_vowel_positions.each_with_index do |vowel_position,\
    \ index|\n\t\tif word[vowel_position..vowel_position + 1].include?(\"U\")\n\t\t\
    \tclosest_vowel_positions[index] = nil\n\t\tend\n\tend\n\t\n\tclosest_vowel_positions.each_with_index\
    \ do |vowel_position, index|\n\t\tif word[vowel_position..vowel_position + 1].include?(\"\
    Y\")\n\t\t\tclosest_vowel_positions[index] = nil\n\t\tend\n\tend\n\t\n\tclosest_vowel_positions.each_with_index\
    \ do |vowel_position, index|\n\t\tif word[vowel_position..vowel_position + 1].include?(\"\
    O\")\n\t\t\tclosest_vowel_positions[index] = nil\n\t\tend\n\tend\n\t\n\tclosest_vowel_positions.each_with_index\
    \ do |vowel_position, index|\n\t\tif word[vowel_position..vowel_position + 1].include?(\"\
    E\")\n\t\t\tclosest_vowel_positions[index] = nil\n\t\tend\n\tend\n\t\n\tclosest_vowel_positions.each_with_index\
    \ do |vowel_position, index|\n\t\tif word[vowel_position..vowel_position + 1].include?(\"\
    I\")\n\t\t\tclosest_vowel_positions[index] = nil\n\t\tend\n\tend\n\t\n\tclosest_vowel_positions.each_with_index\
    \ do |vowel_position, index|\n\t\tif word[vowel_position..vowel_position + 1].include?(\"\
    O\")\n\t\t\tclosest_", "    word = word.downcase\n    \n    vowel_counter = 0\n\
    \    consonant_counter = 0\n    last_consonant = ''\n    last_vowel = ''\n   \
    \ \n    while vowel_counter < word.count('a') + word.count('e') + word.count('i')\
    \ + word.count('o') + word.count('u') + word.count('y') do\n        consonant_counter\
    \ += 1\n        last_consonant = consonant_counter\n    end\n    while consonant_counter\
    \ < word.count('a') + word.count('e') + word.count('i') + word.count('o') + word.count('u')\
    \ do\n        vowel_counter += 1\n        last_vowel = vowel_counter\n    end\n\
    \    \n    if word.start_with?(last_vowel) and word.end_with?(last_consonant)\
    \ then\n        word.slice!(0, last_vowel)\n        word.slice!(-last_consonant)\n\
    \        return word\n    else\n        return ''\n    end\nend\n</code>\n<|/\
    \ a dscore=0 tags=ruby |>\n<| a tags=ruby |>\nFor an answer that uses regex and\
    \ no explicit loops:\n<code>", "  return word[word.length-2]==\"a\" || word[word.length-2]==\"\
    i\" || word[word.length-2]==\"u\" ? \"u\" : \"\"\nend\n</cell>\n<text>\nQuestion\
    \ 5\nHow many vowels exist between the first and last character of a given string?\n\
    Note: You may assume that the given string contains English letter only.", " \
    \ return word[/(?=.)([aeiou])/]\nend\n</cell>\n<text>\nget_vowels", "  vowels\
    \ = \"aeiouAEIOU\".split('')\n  i = vowels.length\n  j = (vowels.size - 1).to_i\n\
    \  letter = word[(word.length - 1).to_i]\n  vowels.each_with_index do |vowel,\
    \ idx|\n    if letter != vowel\n      break\n    end\n    if j - idx > 1\n   \
    \   i = idx\n      j = idx\n    end\n  end\n  return word[i - j] if vowel.downcase\
    \ == letter.downcase\n  return \"\"\nend", "\treturn \nend", "    vowels = [\"\
    a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"]\n    count = 0\n  \
    \  word = \"A\"\n    i = 0\n    while i < len(word) - 1:\n        val = word[len(word)-1\
    \ - i]\n        if val in vowels:\n            count +=1\n        else:\n    \
    \        if count == 1:\n                return val\n            count = 0\n \
    \       i += 1\n    return \"\"\n</cell>\n<cell>\nget_closest_vowel(\"yogurt\"\
    )\n</cell>\n<cell>\nget_closest_vowel(\"FULL\")\n</cell>\n<cell>\nget_closest_vowel(\"\
    quick\")\n</cell>\n<cell>\nget_closest_vowel(\"ab\")\n</cell>\n<text>\nProblem\
    \ 9 - Longest Substring Without Repeating Characters", "  consonant_range = consonants.each_consonant_range(word)\n\
    \  vowel_range = vowels.each_vowel_range(word)\n  return consonant_range.min {\
    \ |x, _| x < vowel_range.min }\nend", "  return word.chars.to_a.find { |letter|\
    \ letter.upcase == letter.downcase }.to_s unless word.nil?\nend\n</code>\n<|/\
    \ a dscore=3 |>\n<| c |>\nNice use of Array#to_s\n<|/ c |>\n<| c |>\nThis answer\
    \ doesn't work for me. The first result I get is \"u\" instead of \"U\".\n<|/\
    \ c |>\n<| c |>\n, please check my code again, it works.\n<|/ c |>\n<| c |>\n\
    Thanks so much for this... I can't believe I've been struggling with something\
    \ so simple.\n<|/ c |>\n<| c |>\n, it is also worth to mention that `to_s` was\
    \ introduced in Ruby 2.2 so if you use older version then `to_s` will not work.\n\
    <|/ c |>\n<| a tags=ruby dscore=2 |>\nThis would do the job:\n<code>", "    vowels\
    \ = %w(a e i o u)\n    vowels.each do |vowel|\n        if word.include?(vowel)\n\
    \            return vowel\n        end\n    end\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=ruby,string dscore=0 |>\nI suggest to use regular expressions\
    \ to solve this problem. This should work:\n<code>", "  return word ? word.split(\"\
    \").reverse.grep(/^[aeiou]/i).last.ord : \"\"\nend", "  vowel_counter = Hash.new(0)\n\
    \  word.each_char do |character|\n    if character =~ /[AEIOU]/\n      vowel_counter[character]\
    \ += 1\n    end\n  end\n  vowel_counter.values.max do |vowel_count|\n    vowel_counter.key(vowel_count)\n\
    \  end\nend", "    word = word.upcase\n    vowels = ['a', 'e', 'i', 'o', 'u']\n\
    \    result = vowels.find_index { |v| word[word.rindex(v)...].size == 0 }\n  \
    \  result ? vowels[result] : ''\nend\n</code>\n<|/ a |>\n<| a tags=ruby,regex\
    \ |>\n<code>", "  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  consonants =\
    \ [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\"\
    , \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n  consonants_count\
    \ = word.count(\"a\")\n  vowels_count = word.count(\"e\")\n  consonants_in_word\
    \ = word.count(\"b\")\n  vowels_in_word = word.count(\"c\")\n  consonants_in_word2\
    \ = word.count(\"d\")\n  vowels_in_word2 = word.count(\"e\")\n  if consonants_in_word\
    \ < consonants_in_word2:\n    if consonants_in_word > consonants_count:\n    \
    \  consonant_index = word.rindex('b')\n      \n    \n      if vowels_in_word >\
    \ vowels_count:\n        vowel_index = word.rindex('c')\n      \n      else:\n\
    \        vowel_index = word.rindex('e')\n      \n  \n      return word[consonant_index\
    \ : vowel_index]\n    \n    else:\n      consonant_index = word.rindex('c')\n\
    \    \n      if vowels_in_word > vowels_count:\n        vowel_index = word.rindex('e')\n\
    \      \n      else:\n        vowel_index = word.rindex('b')\n      \n      return\
    \ word[consonant_index : vowel_index]\n    \n  \n  else:\n    if vowels_in_word\
    \ > vowels_count:\n      vowel_index = word.rindex('e')\n    \n    else:\n   \
    \   vowel_index = word.rindex('b')\n    \n    return word[vowel_index : word.rindex('c')]\n\
    \  ", "\tvowels = \"aeiouAEIOU\"\n\tconsonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    \n\tvowel_letters = vowels.split(\"\")\n\tconsonant_letters = consonants.split(\"\
    \")\n\tvowel_pos = word.rindex(vowels)\n\tconsonant_pos = word.rindex(consonants)\n\
    \ti = 0\n\tresult = ''\n\twhile vowel_pos != -1 and consonant_pos != -1 and vowel_pos\
    \ < consonant_pos:\n\t\tif word[i] == vowel_letters[vowel_pos] and word[i] ==\
    \ consonant_letters[consonant_pos]:\n\t\t\ti = i + 1\n\t\tresult = word[i]\n\t\
    \tif i == len(word):\n\t\t\treturn result\n\t\tvowel_pos = word.rindex(vowels,\
    \ 0, vowel_pos)\n\t\tconsonant_pos = word.rindex(consonants, 0, consonant_pos)\n\
    \treturn result", "  vowels = (\"a\", \"e\", \"i\", \"o\", \"u\")\n  consonants\
    \ = (\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"\
    n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\")\n \
    \ return vowels.find { |v| word.include? v } or consonants.find { |c| word.include?\
    \ c }\nend", "  vowels = []\n  for i in (0...word.length)\n    if word[i].downcase\
    \ =~ /[aeiou]/i\n      vowels.push(word[i])\n    end\n  end\n  vowels.each_with_index\
    \ do |vowel, index|\n    next_index = index + 1\n    if next_index > word.length\n\
    \      next_index = 0\n    end\n    if next_index < word.length\n      if word[next_index].downcase\
    \ =~ /[aeiou]/i\n        return vowel\n      end\n    end\n  end\n  \"\"\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\nThat's really not a good way to solve this\
    \ problem, as you end up using string methods to get the vowels, which are already\
    \ available in [`String#[]`](http://www.ruby-doc.org/core-1.9.3/String.html#method-i-5B-5D).\n\
    <|/ c |>\n<| c |>\nYeah, I know.  I put this in for fun and to help the OP understand\
    \ how Ruby works.  However, I agree with you that the solution he is looking for\
    \ is more easily done with `String#[]`.  I'll edit the answer.\n<|/ c |>\n<| c\
    \ |>\nNo need to use `each` here at all, you can use `each_with_index` instead.\
    \ Also, you can do `vowels.grep(/[aeiou]/).first` if you want to.\n<|/ c |>\n\
    <| c |>\nThank you so much. I've been trying to solve this for a while. Can you\
    \ explain to me why `vowels.grep(/[aeiou]/).first` would be better than `vowels.first`?\
    \ I'm confused...\n<|/ c |>\n<| c |>\nWell, you're using `#grep` which returns\
    \ a new array containing the strings that match the regex, which means you then\
    \ need to use some method to get the first element from that array. The `#first`\
    \ method will get you the first element from the `vowels` array without creating\
    \ a new array (using `Array#first`). If `vowels.first` would work, you could write\
    \ `vowels.grep(/[aeiou]/).first` which would also work.\n<|/ c |>\n<| a dscore=1\
    \ |>\nYour solution is not very efficient since it does a lot of string manipulation\
    \ - it's better to use simple array operations than looping through the string\
    \ twice. The following will do the job:\n<code>", "  return vowels.find { |vowel|\
    \ word.include? vowel }.to_s rescue \"\"\nend\n</code>\n<|/ a dscore=1 tags=ruby,string\
    \ |>\n<| a tags=ruby,string |>\nI personally use each_cons in combination with\
    \ downcase. I would also suggest a little tweak to avoid nil values by checking\
    \ if there are any consonants in the string. \n<code>", '  return ""', "    vowels\
    \ = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    vowel_hash = {}\n    vowel_hash[\"\
    a\"] = 1\n    vowel_hash[\"e\"] = 1\n    vowel_hash[\"i\"] = 1\n    vowel_hash[\"\
    o\"] = 1\n    vowel_hash[\"u\"] = 1\n    \n    vowel_index = word.rindex(vowels)\n\
    \    if vowel_index < 0 or word.rindex(vowels, 0, vowel_index+len(vowels)-1) <\
    \ len(word):\n        return \"\"\n    \n    return word[vowel_index+len(vowels)-1]",
  "  vowels = %w{a e i o u eu y}\n  word.gsub(/[aeiou]/,\"\").reverse.gsub(/[aeiouy]/,\"\
    #\").split(\"#\").each do |vowel|\n    vowels.index(vowel) == vowels.index(vowel[vowel.index(vowel)+1])\n\
    \  end\n  \n  %w{u y}.find{|v| vowels.include?(v)}\nend", "  return word.downcase.split('').reverse.grep(/[aeiou]/).first\n\
    end", "  vowels = %w[a e i o u]\n  vowels.each { |vowel| return vowel if word.downcase.include?(vowel)\
    \ }\n  nil\nend", "    word = word.upcase\n    vowels = [\"a\",\"e\",\"i\",\"\
    o\",\"u\"]\n    vowels_index = []\n    vowels_index.push(0)\n    vowels_index.push(word.length)\n\
    \    vowels_index.push(word.length+1)\n    vowels_index.push(word.length+2)\n\
    \    vowels_index.push(word.length+3)\n    vowels_index.push(word.length+4)\n\
    \    vowels_index.push(word.length+5)\n    vowels_index.push(word.length+6)\n\
    \    vowels_index.push(word.length+7)\n    vowels_index.push(word.length+8)\n\
    \    vowels_index.push(word.length+9)\n    \n    if word.length > 0\n        if\
    \ word.length == 1 or word.length == 2 or word.length == 3 or word.length == 4\n\
    \            if vowels.include?(word[1])\n                return word[1]\n   \
    \         end\n        end\n    end\nend", "  vowels = [\"a\", \"e\", \"i\", \"\
    o\", \"u\"]\n  word[word.length-2, word.length].downcase!", "  return word.chars.sort.reverse.find\
    \ { |x| x.is_a?(String) ? x.include?(\"AEIOUaeiou\") : x.nil? }\nend \n</code>\n\
    <|/ a tags=ruby,string |>\n<| a dscore=0 |>\nUsing regex:\n<code>", "\tword.split(\"\
    \").each do |c|\n\t\tvowels.each { |v| return v if v == c.downcase }\n\tend\n\t\
    return \"\"\nend", "  vowel = \"aeiouAEIOU\"\n  letters = word.split(\"\")\n \
    \ for i in letters.reverse\n    next\n  end\n  letters.reverse.each{|letter|\n\
    \    next\n  end\n  letters.reverse.each{|letter|\n    next if letters.include?(letter)\n\
    \    vowel = letter if vowel.index(letter)\n    next\n  end\n  vowel\nend", " \
    \   vowels = ['a', 'e', 'i', 'o', 'u']\n    vowel_index = []\n    vowel_index.append\
    \ word.rindex('a')\n    vowel_index.append word.rindex('e')\n    vowel_index.append\
    \ word.rindex('i')\n    vowel_index.append word.rindex('o')\n    vowel_index.append\
    \ word.rindex('u')\n    if vowel_index[0] < vowel_index[1]:\n        if word[vowel_index[0]]\
    \ == \"A\" and word[vowel_index[1]] == \"A\":\n            return word[vowel_index[1]+1:vowel_index[2]]\n\
    \        elif word[vowel_index[0]] == \"A\" and word[vowel_index[1]] != \"A\"\
    :\n            return word[vowel_index[0]+1:vowel_index[1]]\n        elif word[vowel_index[0]]\
    \ != \"A\" and word[vowel_index[1]] != \"A\":\n            return word[vowel_index[0]+1:vowel_index[1]]\n\
    \        elif word[vowel_index[0]] != \"A\" and word[vowel_index[1]] ==\"A\":\n\
    \            return word[vowel_index[0]+1:vowel_index[2]]\n        elif word[vowel_index[0]]\
    \ == \"A\" and word[vowel_index[1]] == \"A\":\n            return word[vowel_index[2]+1:vowel_index[3]]\n\
    \    elif vowel_index[0] > vowel_index[1]:\n        if word[vowel_index[0]] ==\
    \ \"A\" and word[vowel_index[1]] == \"A\":\n            return word[vowel_index[0]+1:vowel_index[1]]\n\
    \        elif word[vowel_index[0]] == \"A\" and word[vowel_index[1]] != \"A\"\
    :\n            return word[vowel_index[0]+1:vowel_index[2]]\n        elif word[vowel_index[0]]\
    \ != \"A\" and word[vowel_index[1]] != \"A\":\n            return word[vowel_index[0]+1:vowel_index[1]]\n\
    \        elif word[vowel_index[0]] != \"A\" and word[vowel_index[1]] ==\"A\":\n\
    \            return word[vowel_index[0]+1:vowel_index[2]]\n        elif word[vowel_index[0]]\
    \ == \"A\" and word[vowel_index[1]] == \"A\":\n            return word[vowel_index[3]+1:vowel_index[4]]\n\
    \    else:\n        if word[vowel_index[0]] == \"A\" and word[vowel_index[1]]\
    \ == \"A\":\n            return word[vowel_index[2]+1:vowel_index[3]]\n      \
    \  elif word[vowel_index[0]] == \"A\" and word[vowel_index[1]] != \"A\":\n   \
    \         return word[vowel_index[0]+1:vowel_index[1]]\n        elif word[vowel_index[0]]\
    \ != \"A\" and word[vowel_index[1]] != \"A\":\n            return word[vowel_index[0]+1:vowel_index[1]]\n\
    \        elif word[vowel_index[0]] != \"A\" and word", "  vowels = (\"aeiou\"\
    ).to_a\n  word.downcase!\n  prev_consonant = false\n  next_consonant = false\n\
    \  consonants = \"\"\n  word = word.to_a\n  word.each do |char|\n    if vowels.include?\
    \ char\n      consonants = consonants + char\n      consonants.gsub! \"u\" , \"\
    \"\n    elsif prev_consonant\n      consonants = consonants.to_s + char\n    \
    \  consonants.gsub! \"u\" , \"\"\n    elsif next_consonant\n      consonants =\
    \ consonants.to_s + char\n      consonants.gsub! \"u\" , \"\"\n      next_consonant\
    \ = false\n    elsif next_consonant\n      consonants = consonants.to_s + char\n\
    \      consonants.gsub! \"u\" , \"\"\n      next_consonant = false\n    elsif\
    \ !prev_consonant and char == vowels[0]\n      consonants = consonants.to_s +\
    \ char\n      consonants.gsub! \"u\" , \"\"\n    else\n      prev_consonant =\
    \ true\n      consonants = consonants.to_s + char\n      consonants.gsub! \"u\"\
    \ , \"\"\n    end\n  end\n  return consonants.to_s\nend\n</code>\n<|/ a |>\n<|\
    \ c |>\n\"You may assume that the given string contains English letter only.\"\
    \ -- The OP states \"You may assume that the given string contains English letter\
    \ only\".\n<|/ c |>\n<| c |>\n\"You may assume that the given string contains\
    \ English letter only.\"\n<|/ c |>\n<| c |>\nThanks for pointing that out. I've\
    \ added a clarification at the top of the answer. I've also added an additional\
    \ bit of code to handle the \"Yogurt\" case which I'm sure you know but others\
    \ might not.\n<|/ c |>\n<| c |>\nThanks for your help. I modified your code so\
    \ that it works with Ruby 2.0, but I also realised that my code doesn't work with\
    \ Ruby 1.8. I've tested it with Ruby 1.8.7 and it works. But it doesn't with Ruby\
    \ 2.0. Thanks for your help.\n<|/ c |>\n<| a |>\nHere is a more simple code that\
    \ will return the first vowel found in the given string, and return an empty string\
    \ if it fails to find ", "  word.chars.map do |char|\n    vowels = [:a, :e, :i,\
    \ :o, :u]\n    vowels.find {|v| word.chars.include?(v) && word.chars.size < 3}\n\
    \  end\nend", "  vowels = %w{a e i o u}\n  word.split.reverse.map { |s| vowels.find\
    \ { |a| s == a } }\nend\n</cell>\n<cell>\nget_closest_vowel.call(\"yogurt\")\n\
    </cell>\n<cell>\nget_closest_vowel.call(\"FULL\")\n</cell>\n<cell>\nget_closest_vowel.call(\"\
    quick\")\n</cell>\n<cell>\nget_closest_vowel.call(\"ab\")\n</cell>\n<text>\nQ10\n\
    Write a method called is_vovel that take a string as input and return true or\
    \ false \ndepending on the given string's vowel count.\nA vowel count of more\
    \ than 2 will return true.\nA vowel count of less than 2 will return false.\n\
    If the given string doesn't contain any vowel return false.\nYou may assume that\
    \ the given string contains English letter only.\nExample:\n>>> is_vovel.call(\"\
    yogurt\")\nTrue\n>>> is_vovel.call(\"FULL\")\nFalse\n>>> is_vovel.call(\"quick\"\
    )\nFalse\n>>> is_vovel.call(\"ab\")\nFalse", '  vowels = {"a", "a", "a", "a",
    "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a",
    "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a",
    "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a",
    "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a",
    "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a",
    "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a",
    "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a",
    "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a",
    "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a",
    "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a",
    "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a",
    "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a",
    "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a",
    "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a",
    "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a",
    "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a",
    "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a",
    "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a",
    "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a",
    "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a",
    "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a",
    "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a",
    "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a",
    "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a",
    "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a",
    "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a",
    "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a",
    "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a",
    "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a",
    "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a",
    "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a",
    "a", "a", "a", "a", "a", "a", "a", "a", "a", "', "  vowels = [\"a\", \"e\", \"\
    i\", \"o\", \"u\"]\n  letter_count = 0\n  word = word.upcase.split(\"\")\n  word.reverse!\n\
    \  word.each_index do |x|\n    if word[x].in_a?(vowels)\n      letter_count +=\
    \ 1\n    end\n  end\n  word[letter_count]\nend", "  vowels = [\"a\",\"e\",\"i\"\
    ,\"o\",\"u\"]\n  vowel_counter = 0\n  consonant_counter = 0\n  for i in word\n\
    \    vowel_counter += 1\n    if vowel_counter > 1\n      break\n    if vowel_counter\
    \ == 1 and word[vowel_counter] != 'y'\n      vowel_counter += 1\n      consonant_counter\
    \ += 1\n    if consonant_counter > 1 and vowel_counter == 0\n      break\n   \
    \ if consonant_counter == 1 and word[consonant_counter] != 's'\n      consonant_counter\
    \ += 1\n      vowel_counter += 1\n  \n  closest = word.length - 1\n  for i in\
    \ 0...word.length\n    if word[i] != vowels[vowel_counter] and word[i] != vowels[vowel_counter+1]\n\
    \      closest = i\n    \n  if vowel_counter > consonant_counter\n    return vowels[vowel_counter]\n\
    \  else\n    return \"\"\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n\
    Here is the solution I wrote. Hope it helps others :)\n<code>", "\tvowels = []\n\
    \tvowels.push word\n\tvowels.push word[4..-1]\n\tvowels.push word[1..-1]\n\t\n\
    \tvowels.each do |vowel|\n\t\tif vowel.include?(\"a\")\n\t\t\treturn vowel.delete(\"\
    a\")\n\t\telsif vowel.include?(\"e\")\n\t\t\treturn vowel.delete(\"e\")\n\t\t\
    elsif vowel.include?(\"i\")\n\t\t\treturn vowel.delete(\"i\")\n\t\telsif vowel.include?(\"\
    o\")\n\t\t\treturn vowel.delete(\"o\")\n\t\telsif vowel.include?(\"u\")\n\t\t\t\
    return vowel.delete(\"u\")\n\t\tend\n\tend\n\treturn \"\"\nend\n</code>\nThe function\
    \ call should return an answer (the closest vowel between consonants from the\
    \ right), or an empty string if there is no such vowel.\nMy solution doesn't work\
    \ if the word starts with vowels. \n<code>", "  return vowels.find {|a| word[/[Cc][Oo][Nn][Hh][Rr]$/.match(a).to_s]}\n\
    end", "    vowel = \"aeiouAEIOU\"\n    vowel_hash = Hash.new\n    vowel_hash[\"\
    A\"] = true\n    vowel_hash[\"E\"] = true\n    vowel_hash[\"I\"] = true\n    vowel_hash[\"\
    O\"] = true\n    vowel_hash[\"U\"] = true\n    vowel_hash[\"Y\"] = true\n    vowel_hash[\"\
    a\"] = true\n    vowel_hash[\"e\"] = true\n    vowel_hash[\"i\"] = true\n    vowel_hash[\"\
    o\"] = true\n    vowel_hash[\"u\"] = true\n    vowel_hash[\"y\"] = true\n    vowel_hash[\"\
    A\"] = true\n    vowel_hash[\"E\"] = true\n    vowel_hash[\"I\"] = true\n    vowel_hash[\"\
    O\"] = true\n    vowel_hash[\"U\"] = true\n    vowel_hash[\"Y\"] = true\n    vowel_hash[\"\
    a\"] = true\n    vowel_hash[\"e\"] = true\n    vowel_hash[\"i\"] = true\n    vowel_hash[\"\
    o\"] = true\n    vowel_hash[\"u\"] = true\n    vowel_hash[\"y\"] = true\n    vowel_hash[\"\
    A\"] = true\n    vowel_hash[\"E\"] = true\n    vowel_hash[\"I\"] = true\n    vowel_hash[\"\
    O\"] = true\n    vowel_hash[\"U\"] = true\n    vowel_hash[\"Y\"] = true\n    vowel_hash[\"\
    a\"] = true\n    vowel_hash[\"e\"] = true\n    vowel_hash[\"i\"] = true\n    vowel_hash[\"\
    o\"] = true\n    vowel_hash[\"u\"] = true\n    vowel_hash[\"y\"] = true\n    vowel_hash[\"\
    A\"] = true\n    vowel_hash[\"E\"] = true\n    vowel_hash[\"I\"] = true\n    vowel_hash[\"\
    O\"] = true\n    vowel_hash[\"U\"] = true\n    vowel_hash[\"Y\"] = true\n    vowel_hash[\"\
    a\"] = true\n    vowel_hash[\"e\"] = true\n    vowel_hash[\"i\"] = true\n    vowel_hash[\"\
    o\"] = true\n    vowel_hash[\"u\"] = true\n    vowel_hash[\"y\"] = true", "  vowels\
    \ = \"aeiouy\"\n  vowel_pos = -1\n  \n  vowels.each_index do |pos|\n    if (word.length\
    \ >= pos + 1)\n      vowel_pos = pos\n    end\n  end", "  vowels = [\"a\", \"\
    e\", \"i\", \"o\", \"u\"]\n  vowel_index = []\n  vowel_index.push((word.index(vowels[0]),\
    \ word))\n  vowel_index.push((word.index(vowels[3], word), word))\n  vowel_index.push((word.index(vowels[4],\
    \ word), word))\n  vowel_index.push((word.index(vowels[5], word), word))\n  vowel_index.push((word.index(vowels[6],\
    \ word), word))\n  vowel_index.push((word.index(vowels[7], word), word))\n  vowel_index.push((word.index(vowels[8],\
    \ word), word))\n  vowel_index.push((word.index(vowels[9], word), word))\n  vowel_index.push((word.index(vowels[10],\
    \ word), word))\n  vowel_index.push((word.index(vowels[11], word), word))\n  vowel_index.push((word.index(vowels[12],\
    \ word), word))\n  vowel_index.push((word.index(vowels[13], word), word))\n  vowel_index.push((word.index(vowels[14],\
    \ word), word))\n  vowel_index.push((word.index(vowels[15], word), word))\n  vowel_index.push((word.index(vowels[16],\
    \ word), word))\n  vowel_index.push((word.index(vowels[17], word), word))\n  vowel_index.push((word.index(vowels[18],\
    \ word), word))\n  vowel_index.push((word.index(vowels[19], word), word))\n  vowel_index.push((word.index(vowels[20],\
    \ word), word))\n  vowel_index.push((word.index(vowels[21], word), word))\n  vowel_index.push((word.index(vowels[22],\
    \ word), word))\n  vowel_index.push((word.index(vowels[23], word), word))\n  vowel_index.push((word.index(vowels[24],\
    \ word), word))\n  vowel_index.push((word.index(vowels[25], word), word))\n  vowel_index.push((word.index(vowels[26],\
    \ word), word))\n  vowel_index.push((word.index(vowels[27], word), word))\n  vowel_index.push((word.index(vowels[28],\
    \ word), word))\n  vowel_index.push((word.index(vowels[29], word), word))\n  vowel_index.push((word.index(vowels[30],\
    \ word), word))\n  vowel_index.push((word.index(", "  vowels = %w(a e i o u)\n\
    \  word = word.downcase\n  return vowels.find { |x| word =~ /[#{Regexp.escape(vowels)}#{Regexp.escape(vowels[(vowels.size\
    \ - 1) - (word.size % vowels.size)]).downcase}]/}\nend", "  vowels = ['a', 'e',\
    \ 'i', 'o', 'u']\n  \n  vowels_count = 0\n  consonant_count = 0\n  \n  vowel_index\
    \ = 0\n  consonant_index = -1\n  \n  while vowel_index < vowels.length and consonant_index\
    \ >= 0\n    vowel = vowels[vowel_index]\n    consonant = word[consonant_index]\n\
    \    \n    if vowel == consonant\n      vowels_count += 1\n    \n    if consonant\
    \ == \"a\"\n      consonant_index = word.length - 1\n    \n    if consonant ==\
    \ \"e\"\n      consonant_index = word.length - 2\n    \n    if consonant == \"\
    i\"\n      consonant_index = word.length - 3\n    \n    if consonant == \"o\"\n\
    \      consonant_index = word.length - 4\n    \n    if consonant == \"u\"\n  \
    \    consonant_index = word.length - 5\n    \n    if consonant_index >= 0\n  \
    \    break\n    \n    vowel_index += 1\n    \n  vowels[vowels.length - vowels_count]\n\
    end", "  vowel_cons_pairs = [\"AEIOUaeiou\"]\n  word.downcase.gsub(/[aeiou]/)\
    \ { vowel_cons_pairs.push($&) }\n  cons_pairs = vowel_cons_pairs[0...word.length-2]\n\
    \  return cons_pairs.find { |c| word[word.length - word.length - 1 - c.length\
    \ .. -1] == 'a' || word[word.length - word.length - 1 - c.length .. -1] == 'e'\
    \ || word[word.length - word.length - 1 - c.length .. -1] == 'i' || word[word.length\
    \ - word.length - 1 - c.length .. -1] == 'o' || word[word.length - word.length\
    \ - 1 - c.length .. -1] == 'u' }\nend", '  vowel = nil', "  return word.gsub(/[b-df-hj-np-tv-z]/i,\
    \ '').downcase\nend", "    vowel_candidates = word[/[aeiou]/]\n    vowel_candidates.reverse.compact.detect\
    \ {|c| c.upcase != c }\nend", "  return word.scan(/[AEIOUaeiou]/).max {|a,b| (a\
    \ <=> b)}\nend", "  return word.scan(/[aeiou]/).max_by { |vowel| vowel.size }\n\
    end", "  vowels = %w[a e i o u]\n  vowels.each do |vowel|\n    if word.index(vowel)\n\
    \      return vowel\n    end\n  end\n  return \"\"\nend", "  vowels=(\"a\",\"\
    e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\")\n  s=\"\"\n  \n  for i in\
    \ (vowels+[word.downcase[1..-1]])\n    if word.endwith?(i)\n      return i\n \
    \   elsif word.startwith?(i)\n      return i\n    else \n      s=i\n    end\n\
    \  end\n  \n  s=s.downcase\n  \n  for i in s\n    if i.downcase >= \"a\" and i.downcase\
    \ <= \"z\"\n      return \"a\"\n    elsif i.downcase >= \"A\" and i.downcase <=\
    \ \"Z\"\n      return \"A\"\n    end\n  end\n  return s\nend", "  vowels = [ \"\
    a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"W\", \"I\", \"O\", \"U\" ]\n  \n  vowel_position\
    \ = word.rindex(vowels.shift, 1, word.length)\n  \n  if vowel_position\n    if\
    \ word.chars[vowel_position-1] == vowels.first\n      return word[vowel_position..-1]\n\
    \    end\n    if word.chars[vowel_position+1] == vowels.last\n      return word[0..vowel_position-1]\
    \ + vowels.first\n    end\n  end\n  \n  return \"\"\nend\n</cell>\n<cell>\nget_closest_vowel(\"\
    yogurt\")\n</cell>\n<cell>\nget_closest_vowel(\"FULL\")\n</cell>\n<cell>\nget_closest_vowel(\"\
    quick\")\n</cell>\n<cell>\nget_closest_vowel(\"ab\")\n</cell>\n<cell>\nget_closest_vowel(\"\
    cba\")\n</cell>\n<cell>\nget_closest_vowel(\"a\")\n</cell>\n<cell>\nget_closest_vowel(\"\
    abc\")\n</cell>\n<text>\nChallenge 2.2\nWrite a recursive function get_closest_consonant_vowel\
    \ that returns the closest consonant-vowel combination from the right side of\
    \ the word (case sensitive). Vowels in the beginning and ending doesn't count.\n\
    Example:\n>>> get_closest_consonant_vowel.call(\"yogurt\")\n\"i\"\n>>> get_closest_consonant_vowel.call(\"\
    FULL\")\n\"L\"\n>>> get_closest_consonant_vowel.call(\"quick\")\n\"\"\n>>> get_closest_consonant_vowel.call(\"\
    ab\")\n\"\"\n>>> get_closest_consonant_vowel.call(\"cba\")\n\"\"\n>>> get_closest_consonant_vowel.call(\"\
    a\")\n\"\"\n>>> get_closest_consonant_vowel.call(\"abc\")\n\"\"", "  word.split(\"\
    \").map { |letter| letter = \"A\"..\"Z\"\n                           letter.index(word[word.index(letter)\
    \ + 1]) }.max\nend\n</code>\n<|/ a |>\n<| c |>\nThis solution is wrong, because\
    \ it returns first vowel not the first vowel that stands between two consonants.\n\
    <|/ c |>\n<| a |>\nA more general solution than using split would be something\
    \ like this:\n<code>", "\tvowels = %w[a e i o u]\n\tword.split(\"\").each do |char|\n\
    \t\tvowels.each do |vowel|\n\t\t\tif char == vowel\n\t\t\t\treturn vowel\n\t\t\
    \tend\n\t\tend\n\tend\n\treturn \"\"\nend", "  word.chars.reverse_each.with_index\
    \ do |char, i|\n    break if i == 0\n    break if i == word.length - 1\n    break\
    \ if char.upcase == \"A\" || char.upcase == \"E\" || char.upcase == \"I\" || char.upcase\
    \ == \"O\" || char.upcase == \"U\" || char.upcase == \"A\" || char.upcase == \"\
    E\" || char.upcase == \"I\" || char.upcase == \"O\" || char.upcase == \"U\"\n\
    \    break if char.upcase == \"A\" || char.upcase == \"E\" || char.upcase == \"\
    I\" || char.upcase == \"O\" || char.upcase == \"U\" || char.upcase == \"A\" ||\
    \ char.upcase == \"E\" || char.upcase == \"I\" || char.upcase == \"O\" || char.upcase\
    \ == \"U\"\n    break if char.upcase == \"A\" || char.upcase == \"E\" || char.upcase\
    \ == \"I\" || char.upcase == \"O\" || char.upcase == \"U\"\n    break if char.upcase\
    \ == \"A\" || char.upcase == \"E\" || char.upcase == \"I\" || char.upcase == \"\
    O\" || char.upcase == \"U\" || char.upcase == \"A\" || char.upcase == \"E\" ||\
    \ char.upcase == \"I\" || char.upcase == \"O\" || char.upcase == \"U\"\n    break\
    \ if char.upcase == \"A\" || char.upcase == \"E\" || char.upcase == \"I\" || char.upcase\
    \ == \"O\" || char.upcase == \"U\" || char.upcase == \"A\" || char.upcase == \"\
    E\" || char.upcase == \"I\" || char.upcase == \"O\" || char.upcase == \"U\" ||\
    \ char.upcase == \"A\" || char.upcase == \"E\" || char.upcase == \"I\" || char.upcase\
    \ == \"O\" || char.upcase == \"U\" || char.upcase == \"A\" || char.upcase == \"\
    E\" || char.upcase == \"I\" || char.upcase == \"O\" || char.upcase == \"U\"\n\
    \    break if char.upcase == \"A\" || char.upcase == \"E\" || char.upcase == \"\
    I\" || char.upcase == \"O\" || char.upcase == \"U\" || char.upcase == \"A\" ||\
    \ char.upcase == \"E\" || char.upcase == \"I\" || char.upcase == \"O\" || char.upcase\
    \ == \"U\" || char.upcase == \"A", "  vowels = \"aeiouAEIOU\"\n  consonants =\
    \ \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"", "  \n  # your code goes here\n\
    \  \nend", "  letters = word.chars.to_a\n  letters.reverse\n  letters.reverse!\n\
    \  vowels = (\"a\", \"e\", \"i\", \"o\", \"u\", \"y\", \"A\", \"E\", \"I\", \"\
    O\", \"U\", \"Y\")\n  while letters.any? {|letter| vowels.include?(letter)}\n\
    \    letters.shift\n  end\n  return letters.last\nend\n</code>\n<|/ a |>\n<| c\
    \ |>\nThat is very nice. Can you make it even more dynamic? I mean, I don't want\
    \ to hard code any vowels. And I wouldn't want to hard code any consonants either.\
    \ Can it be done with regexp?\n<|/ c |>\n<| c |>\nI have updated my solution to\
    \ suit your requirement. Hope this helps.\n<|/ c |>\n<| c |>\nThanks. But I guess\
    \ we can make it even more generic. Like we can also add exceptions like \"y\"\
    \ -> \"e\". So that even this vowel word \"yogurt\" will turn into \"ui\"\n<|/\
    \ c |>\n<| a tags=ruby |>\n<code>", "  return \"\"\nend", "  vowels = ['a', 'e',\
    \ 'i', 'o', 'u']\n  return vowels.find_index { |vowel| word.include?(vowel) }\n\
    end", "  vowels = [\"\",\"a\",\"e\",\"i\",\"o\",\"u\"]\n  vowels.each do |vowel|\n\
    \    word = word.gsub(vowel,\"x\")\n    \n    if word.size < 2\n      return \"\
    \"\n    end\n    \n    return word.chomp.chars.find { |char| char == 'x' }\n \
    \ end\nend", "  word = word.downcase\n  vowels = %w(a e i o u).map{|s| s[1..-1]}.flatten\n\
    \  consonants = %w(z z z z y y y y y y y y y y y y y y y y y y y y y y y y y y\
    \ y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y\
    \ y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y\
    \ y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y\
    \ y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y\
    \ y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y\
    \ y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y\
    \ y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y\
    \ y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y\
    \ y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y\
    \ y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y\
    \ y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y\
    \ y y y y y y y y y y y y y y y y y y y y y y y y y y ", "    vowels = [\"a\"\
    , \"e\", \"i\", \"o\", \"u\", \"y\", \"o\"]\n    vowel_counter = 0\n    right_side_length\
    \ = len(word)\n    i = 0\n    while i < right_side_length\n        if vowels.include?(word[i])\n\
    \            vowel_counter += 1\n            i += 1\n        i += 1\n    return\
    \ vowels[vowel_counter-1] unless vowel_counter == 0\nend", "  return word.gsub(/[aeiou]/i)\
    \ { |vowel| vowel.to_i }\nend", "  return word.chars.to_a.find_index { |w| \n\
    \    w.to_s.gsub(/[aeiou]/).size > 2 &&\n    w.to_s.gsub(/[aeiou]/).first.length\
    \ % 2 == 0 &&\n    !w.to_s.start_with?(\"u\")\n  }\nend", "  # Your code here\n\
    \  return word.scan(/[AEIOU]/).last\nend", "  vowels = %w(a e i o u)\n  word.chars.each\
    \ do |char|\n    return '' unless vowels.include? char\n    vowels.reverse if\
    \ char == vowels.last\n    vowels.shift if char == vowels.first\n  end\n  ''\n\
    end\n</code>\n<|/ a tags=ruby dscore=1 |>\n<| a |>\n<code>\n def solution(str)\n\
    \  consonants = 'bcdfghjklmnpqrstvwxyz'\n  vowels = 'aeiou'\n  result = str.dup\n\
    \  str.chars.reverse_each.with_object([]) do |char,arr|\n    next arr unless arr.any?\
    \ { |el| char == el}\n    arr << char\n    break if consonants.include?(char)\
    \ && vowels.any? { |v| char == v }\n  end\n  result\n end\n p solution(\"yogurt\"\
    )\n p solution(\"yogurt\")\n p solution(\"yogurt\")\n p solution(\"yogurt\")\n\
    \ p solution(\"yogurt\")\n p solution(\"yogurt\")\n p solution(\"yogurt\")\n p\
    \ solution(\"yogurt\")\n p solution(\"yogurt\")\n p solution(\"yogurt\")\n p solution(\"\
    yogurt\")\n p solution(\"yogurt\")\n p solution(\"yogurt\")\n p solution(\"yogurt\"\
    )\n p solution(\"yogurt\")\n p solution(\"yogurt\")\n p solution(\"yogurt\")\n\
    \ p solution(\"yogurt\")\n p solution(\"yogurt\")\n p solution(\"yogurt\")\n p\
    \ solution(\"yogurt\")\n p solution(\"yogurt\")\n p solution(\"yogurt\")\n p solution(\"\
    yogurt\")\n p solution(\"yogurt\")\n p solution(\"yogurt\")\n p solution(\"yogurt\"\
    )\n p solution(\"yogurt\")\n p solution(\"yogurt\")\n p solution(\"yogurt\")\n\
    \ p solution(\"yogurt\")\n p solution(\"yogurt\")\n p solution(\"yogurt", "  return\
    \ word.gsub(/([a-zA-Z])([^a-zA-Z]+)/) {|m| m.begin(0)..m.end(0)}.first\nend\n\
    </code>\n<|/ a tags=ruby,regex dscore=2 |>\n<| a dscore=2 |>\nMy solution:\n<code>",
  "  return \"\"\nend\n</cell>\n<code language=julia-0.6>", "  return word[/[aeiou]/i].downcase\
    \ if word.include?(/[aeiou]/i) \nend\n</cell>\n<cell>", "  return \"\" if word.empty?\
    \ || word.chars.empty? || word.chars.first.upcase != word.chars.last.upcase ||\
    \ word.chars.first != \"a\" && word.chars.first != \"e\" && word.chars.first !=\
    \ \"i\" && word.chars.first != \"o\" && word.chars.first != \"u\" else word.chars.last.upcase\n\
    end\n</code>\n<|/ a dscore=2 tags=ruby,string |>\n<| a tags=ruby,string |>\nYou\
    \ could do it this way:\n<code>", "    vowels = ['a', 'e', 'i', 'o', 'u', 'y']\n\
    \    vowels_set = set(vowels)\n    vowels_set.add(vowels[0])\n    vowels_set.add(vowels[-1])\n\
    \    vowels_set = vowels_set.difference(set(vowels[1:-1]))\n    \n    vowels_length\
    \ = len(vowels)\n    \n    word = ''.join(x for x in word if x.isalpha())\n  \
    \  \n    if word[-1] not in vowels_set:\n        return ''\n    \n    if word[-vowels_length]\
    \ not in vowels_set:\n        return ''\n    \n    return word[-vowels_length]\n\
    </cell>\n<cell>", "  word = word.upcase\n  return nil unless word.chars.all? {|char|\
    \ char == \"A\" || char == \"E\" || char == \"I\" || char == \"O\" || char ==\
    \ \"U\"}\n  vowel_index = -1\n  vowel_letter = \"\"\n  word.chars.each_with_index\
    \ do |char, index|\n    if (char == \"A\" || char == \"E\" || char == \"I\" ||\
    \ char == \"O\" || char == \"U\")\n      vowel_index = index\n      vowel_letter\
    \ = char\n      break\n    end\n  end\n  \n  \n  vowel_index == -1 ? \"\" :\n\
    \    (word.chars[vowel_index-1] == \"E\" ? vowel_letter + \"i\" : \n     (word.chars[vowel_index+1]\
    \ == \"E\" ? vowel_letter + \"e\" : \n      (word.chars[vowel_index-1] != \"E\"\
    \ && word.chars[vowel_index+1] != \"E\" ? (vowel_letter + \"o\") : \"\")))\nend",
  "    vowels = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n    vowels_set = set(vowels)\n  \
    \  if vowels_set.issubset(set(word)):\n        return vowels[vowels.index(vowels_set)\
    \ + 1]\n    return \"\"", "    vowel_count = {}\n    consonant_count = {}\n  \
    \  word = \"#{word.upcase}\"\n    word_length = len(word)\n    word_ending = word[word_length\
    \ - 1]\n    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\", \"y\"]\n    consonants\
    \ = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"\
    n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"z\"]", "  return\
    \ word[((word.index('e')+1<word.index('s'))&(word.index('s')+2<word.index('u')))&(word.index('r')+2<word.index('u'))&(word.index('b')+2<word.index('u'))].to_s.downcase\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nYou should probably test this with longer\
    \ strings - the string \"yogurt\" has more than one vowel and doesn't have \"\
    y\" between vowels.\n<|/ c |>\n<| c |>\nThanks, I have made changes in code.\n\
    <|/ c |>\n<| c |>\nThank you. I was looking for this answer.\n<|/ c |>\n<| a tags=ruby,string\
    \ |>\nA good way is to use the rindex method:\n<code>\n\"yogurt\".rindex('e',\
    \ 1..-1)\n</code>\nFrom the docs:", "    vowels = [\"a\", \"e\", \"i\", \"o\"\
    , \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"]\n    vowel_consonants = [letter for\
    \ letter in word if letter.islower()]\n    for index, consonant in enumerate(vowel_consonants):\n\
    \        if vowels[index+1] in vowels:\n            return vowels[index+1]\n \
    \   return \"\"\n    ", "  return word.chars.take_while {|c| c =~ /[aeiouAEIOU]/\
    \ }.join(\"\").downcase\nend", "  vowels = [\n    \"a\", \"e\", \"i\", \"o\",\
    \ \"u\", \"A\",\"E\", \"I\", \"O\", \"U\"\n  ]\n  left_bound = word.length - 1\n\
    \  right_bound = word.length\n  while left_bound >= 0 and right_bound >= 0\n \
    \   if vowels[left_bound].downcase == word[left_bound].downcase \n      and vowels[right_bound].downcase\
    \ == word[right_bound].downcase\n    then return word[left_bound]\n    elsif vowels[left_bound].downcase\
    \ == word[left_bound].downcase \n      and vowels[right_bound].downcase == word[left_bound].downcase\n\
    \    then return word[left_bound]\n    elsif vowels[left_bound].downcase == word[right_bound].downcase\
    \ \n      and vowels[right_bound].downcase == word[right_bound].downcase\n   \
    \ then return word[left_bound]\n    elsif vowels[left_bound].downcase == word[left_bound].downcase\
    \ \n      and vowels[right_bound].downcase == word[right_bound].downcase\n   \
    \ then return word[left_bound]\n    elsif vowels[left_bound].downcase == word[left_bound].downcase\
    \ \n      and vowels[right_bound].downcase == word[right_bound].downcase\n   \
    \ then return word[left_bound]\n    elsif vowels[left_bound].downcase == word[left_bound].downcase\
    \ \n      and vowels[right_bound].downcase == word[left_bound].downcase\n    then\
    \ return word[left_bound]\n    elsif vowels[left_bound].downcase == word[right_bound].downcase\
    \ \n      and vowels[right_bound].downcase == word[right_bound].downcase\n   \
    \ then return word[left_bound]\n    elsif vowels[left_bound].downcase == word[left_bound].downcase\
    \ \n      and vowels[right_bound].downcase == word[right_bound].downcase\n   \
    \ then return word[left_bound]\n    elsif vowels[left_bound].downcase == word[left_bound].downcase\
    \ \n      and vowels[right_bound].downcase == word[right_bound].downcase\n   \
    \ then return word[left_bound]\n    elsif vowels[left_bound].downcase == word[right_bound].downcase\
    \ \n      and vowels[right_bound].downcase == word[right_bound].downcase\n    ",
  "  # your code here\n  vowels = %w[A E I O U]\n  vowels.each do |vowel|\n    if\
    \ word.include?(vowel)\n      return vowel\n    end\n  end\n  \"\"\nend", "  vowels\
    \ = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  \n  word = word.downcase\n  \n  last_consonant\
    \ = word.rindex(\"a\")\n  first_consonant = word.index(\"a\")\n  \n  while first_consonant\
    \ < last_consonant\n    if word[first_consonant] in vowels\n      break\n    first_consonant\
    \ = first_consonant + 1\n  end\n  \n  first_vowel = first_consonant + 1\n  \n\
    \  last_vowel = word.index(\"u\")\n  \n  while last_vowel > first_consonant\n\
    \    if word[last_vowel] in vowels\n      break\n    last_vowel = last_vowel -\
    \ 1\n  end\n  \n  if first_vowel > last_vowel\n    return \"\"\n  else\n    return\
    \ word[first_vowel..last_vowel]\n  end\nend\n</cell>\n<cell>\nget_closest_vowel(\"\
    yogurt\")\n</cell>\n<cell>\nget_closest_vowel(\"FULL\")\n</cell>\n<cell>\nget_closest_vowel(\"\
    quick\")\n</cell>\n<cell>\nget_closest_vowel(\"ab\")\n</cell>\n<text>\nget_closest_vowels",
  '  return word.each_char.with_index.sort_by(&:last).last.first unless word.nil?',
  "  vowels = %w(A E I O U)\n  \n  return vowels.find { |vowel| word.include?(vowel)\
    \ }\nend\n</cell>\n<cell>", "  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\
    \  vowels.each do |v|\n    if word.start_with?(v)\n      word = word.slice!(v)\n\
    \      return v\n    end\n  end\n  return \"\"\nend", "  result = \"\"\n  vowels\
    \ = [\"A\",\"E\",\"I\",\"O\",\"U\"]\n  vowel_positions = []\n  for c in word.chars\n\
    \    if vowels.include? c \n      vowel_positions << word.index(word)\n    end\n\
    \  end\n  \n  vowel_positions.each do |pos|\n    if pos > word.length-2\n    \
    \  result << \"\"\n      break\n    end\n    if pos < word.length-1\n      result\
    \ << word[pos+1]\n      break\n    end\n  end\n  \n  return result\nend", "  return\
    \ \"\"\nend", "  return word.scan(/[aeiou]/).each { |vowel| return vowel if vowel.end_with?\
    \ /[aeiou]/i }.first\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
