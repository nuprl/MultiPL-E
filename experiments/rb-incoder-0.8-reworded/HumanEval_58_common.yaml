name: HumanEval_58_common
language: rb
prompt: "# Return sorted unique common elements for two arrays.\n# >>> common.call([1,\
  \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n# [1, 5, 653]\n# >>> common.call([5,\
  \ 3, 2, 8], [3, 2])\n# [2, 3]\ndef common(l1, l2)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_common\n\
  \    candidate = method(:common)\n    assert_equal([1, 5, 653], candidate.call([1,\
  \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n    assert_equal([2, 3], candidate.call([5,\
  \ 3, 2, 8], [3, 2]))\n    assert_equal([2, 3, 4], candidate.call([4, 3, 2, 8], [3,\
  \ 2, 4]))\n    assert_equal([], candidate.call([4, 3, 2, 8], []))\n  end\nend\n"
completions: ["  l1.uniq, l2.uniq\n  i1, i2 = l1.first(l2), l2.first(l1)\n  return\
    \ [] if i1.nil? || i2.nil? or i1.eql?(i2) or i2.eql?(i1) or i1.size != i2.size\
    \ or l1.size != l2.size or l1.size > l2.size or l1.size < 2\n  i = i1.size\n \
    \ while i > 0\n    if i1.first(i2).nil?\n      i -= 1\n      i2 += l1[i1]\n  \
    \  else\n      i -= 1\n      i2 += l2[i2]\n    end\n  end\n  i1, i2\nend", " \
    \ return [ v for v in l1 if v in l2 ]\nend", "  l1.zip(l2).to_a().uniq.sort\n\
    end", "  l1.each do |x|\n    l2.delete_if { |y| x == y }\n  end\n  l2.uniq\nend",
  "  a1 = Array(l1)\n  a2 = Array(l2)\n  a1.each do |x|\n    a2.each do |y|\n    \
    \  return x if x == y\n    end\n  end\n  nil\nend", '  return l1[common_index(l1,
    l2)] if l1.size == l2.size else []', "  l1.zip(l2).select { |e1, e2| e1 == e2\
    \ }.map(&:first)\nend\n</code>\n<|/ a |>\n<| c |>\n`common` does not use only\
    \ elements that are in both lists, it uses every element in each list except the\
    \ ones that are present in both lists, i.e. `common([1,2,3], [2,3])` returns `[3,3]`.\n\
    <|/ c |>\n<| c |>\nThanks, I fixed it now\n<|/ c |>\n<| c |>\nThis solution is\
    \ more efficient than my own in some cases. But it seems that it is not robust\
    \ to duplicate elements, so `common([1,2,3], [1,2,4])` returns `[]`\n<|/ c |>\n\
    <| c |>\n, thanks for your comment! I added it to my answer.\n<|/ c |>\n<| a tags=arrays,ruby\
    \ |>\nThis code will find the first common element and remove it from both arrays:\n\
    <code>", "  common = Set.new\n  l1.each do |e|\n    l2.each do |f|\n      common\
    \ << e if e == f\n    end\n  end\n  common\nend", "  result = l1\n  l1.each do\
    \ |e|\n    l2.each do |f|\n      break if e == f\n    end\n  end\n  result\nend",
  "  l1.zip(l2).select { |e1,e2| e1 == e2 }.map{|e| e.first}\nend", "  u = []\n  common\
    \ = []\n  l.each do |i|\n    j += 1\n    l << i if l2.include?(i)\n    common\
    \ << i if u.include?(i)\n    break if j == l.length\n    u << i\n  end\n  common\n\
    end\n</code>\n<|/ a dscore=0 tags=ruby,arrays |>\n<| c |>\nWhile this code may\
    \ answer the question, providing additional context regarding how and/or why it\
    \ solves the problem would improve the answer's long-term value.\n<|/ c |>\n<|\
    \ c |>\nThis code has O(n\xB2) complexity, which is too slow. An O(n) algorithm\
    \ would be `l1.merge(l2).uniq`.\n<|/ c |>\n<| a |>\n<code>", "  if l1.size ==\
    \ 0 or l2.size == 0\n    return []\n  \n  l1 = l1.sort\n  l2 = l2.sort\n  result\
    \ = []\n  while l1.first != l2.first\n    if l1.first == l2.first\n      result\
    \ << l1.first\n      l1.shift, l2.shift\n    else \n      break unless l1.first\
    \ == l2.first\n      result << l1.first\n      l1.shift until l1.first == l2.first\n\
    \      l2.shift until l1.first == l2.first\n      break\n  end\n  result\nend",
  "  sorted = common.reduce(l1, l2)\n  uniq = uniq.call(sorted, [])\n  uniq.compact!\n\
    \  uniq\nend", "  # Sort lists to prevent unstable sorting\n  l1.sort!\n  l2.sort!\n\
    \  \n  # Initialize result array\n  result = []\n  \n  # Iterate through list\
    \ 1 comparing it with list 2\n  l1.each do |l|\n    # Add list 1 element to result\
    \ list if list 2 element is not in list 1\n    result << l if l2.include?(l)\n\
    \  end\n  \n  # Return sorted unique common elements\n  result.sort!\nend", " \
    \ common = []\n  l1.each { |x| common << x if l2.include?(x) }\n  common.sort!\n\
    \  common\nend", "  common_elements = []\n  l1.each do |element|\n    l2.each\
    \ do |element2|\n      next if element == element2\n      common_elements << element\
    \ if element < element2\n    end\n  end\n  common_elements\nend", "  return l1[l1.index(l1.intersect(l2)[0])]\
    \ if l1.length == l2.length else []\nend", "  l1.each_with_index do |e,i|\n  \
    \  if l2.include? e\n      l1.delete e if l1.include? e\n      l2.delete e if\
    \ l2.include? e\n    end\n  end\n  l1 + l2\nend", "  c = l1[0]\n  i = 1\n  j =\
    \ 1\n  while i <= l1.length and j <= l2.length\n    if l1[i] == l2[j]\n      i\
    \ += 1\n      j += 1\n    else\n      if c < l2[j]\n        i += 1\n      else\n\
    \        j += 1\n    end\n  end\n  if j > l2.length\n    j = l2.length\n  end\n\
    \  if i > l1.length\n    i = l1.length\n  end\n  return c..j\nend", "  l1.sort!\n\
    \  l2.sort!\n  l1.each_with_index do |e, i|\n    return i if l2.include?(e)\n\
    \  end\n  -1\nend\n</code>\n<|/ a |>\n<| c |>\nThis has quadratic complexity,\
    \ making it not really a good solution.\n<|/ c |>\n<| a tags=ruby dscore=4 |>\n\
    This is probably more efficient than some of the others:\n<code>", "  if l1 ==\
    \ [] or l2 == []\n    []\n  else\n    if l1[0] == l2[0]\n      l1[0...1] + common(l1[2...length],\
    \ l2[2...length])\n    else\n      common(l1[2...length], l2[2...length])\n  end\n\
    end\n</cell>\n<cell>", "  a = l1.to_a\n  b = l2.to_a\n  common = []\n  while a.any?\
    \ && b.any?\n    common.push(a.shift) while a.first == b.first && a.last == b.last\
    \ && common.size > 1\n    common.push(b.pop) while b.first == a.first && b.last\
    \ == a.last && common.size > 1\n  end\n  common\nend", "  sorted = Sort(l1, l2)\n\
    \  common = sorted.common\n  return common\nend", "  l1 = l1\n  l2 = l2\n  common\
    \ = []\n  while l1.length > 0\n    l2 = l2[0...l1.length]\n    if l2.empty? or\
    \ l1.first != l2[0]\n      common << l1.first\n      l1 = l1[0...l1.length - 1]\n\
    \    else\n      break\n    end\n  end\n  common << l1\n  common\nend", "  o =\
    \ {}\n  for i in l1\n    o[i] = nil\n  end\n  for j in l2\n    o[j] = nil\n  end\n\
    \  o.keys\nend", "  return l1 + l2- l1.index(l2).count\nend", "  l1 = l1.to_a\n\
    \  l2 = l2.to_a\n  n1 = l1.length\n  n2 = l2.length\n  common = []\n  common_i\
    \ = 0\n  while (n1 && n2)\n    if (l1[n1-1] == l2[n2-1])\n      common[common_i]\
    \ = l1[n1-1]\n      n1 -= 1\n      n2 -= 1\n      common_i += 1\n    elsif (l1[n1-1]\
    \ > l2[n2-1])\n      n1 -= 1\n    else # if (l1[n1-1] < l2[n2-1])\n      n2 -=\
    \ 1\n  end\n  common[0...common_i] = l1[1...n1] + l2\n  common[n1...n1+n2] = l2[1...n2]\
    \ + l1\n  common\nend", "    k = min(l1.length, l2.length)\n    i = 0\n    answer\
    \ = []\n    while i < k\n        if l1[i] < l2[i]\n            answer.push l1[i]\n\
    \            i += 1\n        else answer.push l2[i]\n            i += 1\n    answer\n\
    end\n</code>\n<|/ a |>\n<| c |>\n`k` = `min(a.length, b.length)`\n<|/ c |>\n<|\
    \ a dscore=3 |>\nHere is a Ruby one-liner:\n<code>\na = [1,2,3,4]\nb = [5,6,7,8]",
  "  # l1 and l2 are sorted\n  return _common(l1, l2, SortedSet)\nend", "  l1 = Array(l1)\n\
    \  l2 = Array(l2)\n  common = Array.new\n  l1.each do |e|\n    l2.each do |f|\n\
    \      if e == f\n        common << e\n      end\n    end\n  end\n  common\nend",
  "  return l1.to_a - l2.to_a & l1.to_a\nend", "  l1.zip(l2).select { |a, b| a ==\
    \ b }.map(&:first)\nend", "  return uniq(sort(l1).intersect(sort(l2)))\nend",
  "  l1.zip(l2).flatten.compact.reject { |x,y| x != y }\nend", "  # For Python 2.6\n\
    \  import operator\n  result = {}\n  mapfn = operator.methodcaller(\"has_key\"\
    , \"intersection\")\n  for e in l1:\n    i = mapfn(l2, e)\n    if i not in result:\n\
    \      result[i] = []\n    result[i].append(e)\n  return result.values()\nend",
  "  l1 = l1[0..-1] if l1.is_a?(Array) \n  l2 = l2[0..-1] if l2.is_a?(Array) \n  l1.each_with_index\
    \ do |x, i|\n    if l2.include? x\n      l2.delete_at(i)\n      return\n    end\n\
    \  end\n  l1\nend", "  a = l1\n  b = l2\n  while a.length and b.length\n    first\
    \ = a.shift\n    last = b.shift\n    return first unless last and first == last\n\
    \    if first == last and first != nil\n      yield first\n    end\n    if first\
    \ != last and first != nil\n      yield last\n    end\n  end\n  while a.length\n\
    \    yield a.shift\n  end\n  while b.length\n    yield b.shift\n  end\nend", " \
    \ l1 = l1.to_a\n  l2 = l2.to_a\n  l1.zip(l2).select do |e1,e2|\n    e1.first ==\
    \ e2.first\n  end\nend", "  l1.each do |item|\n    l2.each do |item2|\n      return\
    \ item if item == item2\n    end\n  end\n  nil\nend", "  m1, m2 = l1.length, l2.length\n\
    \  return l1.zip(l2).select do |x, y|\n    (x - y).abs < m1 * m2\n  end.sort{|a,\
    \ b| a.first <=> b.first}\nend", "  common = []\n  l1.each do |element|\n    common\
    \ << element if l2.include?(element)\n  end\n  common\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| a dscore=0 |>\nTo find common elements:\n<code>\na = [\"cat\", \"dog\"\
    , \"pig\", \"dog\", \"pig\"]\nb = [\"cat\", \"dog\", \"pig\"]", "  common = []\n\
    \  l1.each do |item|\n    l2.each do |i|\n      if item == i\n        common <<\
    \ item\n      end\n    end\n  end\n  common\nend", "  h1 = Hash.new\n  h2 = Hash.new\n\
    \  l1.each do |x|\n    h1[x] = 1\n  end\n  l2.each do |x|\n    h2[x] = 1\n  end\n\
    \  h2.keys.each do |x|\n    return x if h1[x] == 1\n  end\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nThis is *exactly* what I was thinking of posting. I was just about\
    \ to post my solution, though.\n<|/ c |>\n<| c |>\nI added my own solution to\
    \ my answer.\n<|/ c |>\n<| c |>\nNice! And thanks for linking me to that article.\
    \ I had no idea what that hash did.\n<|/ c |>\n<| c |>\nI didn't know what a Hash\
    \ did until I looked at it... it just took a quick glance. Thanks for letting\
    \ me know it exists.\n<|/ c |>\n<| a tags=ruby,sorting |>\nOne possible solution\
    \ is to first sort the arrays and then use a custom comparison function to determine\
    \ which one is the shorter array:\n<code>", "  return commonArray(l1, l2)\nend",
  "  return l1 & l2 & l1.sort + l2.sort\nend", "  l1.sort_by { |e| e }\n  l2.sort_by\
    \ { |e| e }\n  l1.uniq.reject { |e| l2.include?(e) }\nend", "  s = Set.new\n \
    \ s1.each do |x|\n    s.add x\n  end\n  s2.each do |x|\n    s.add x\n  end\n \
    \ s.to_a\nend", "  c = {}\n  l1.each do |item1|\n    l2.each do |item2|\n    \
    \  c[(item1.to_s << item2.to_s).to_sym] ||= []\n      c[(item1.to_s << item2.to_s).to_sym]\
    \ << item1\n      c[(item1.to_s << item2.to_s).to_sym] << item2\n    end\n  end\n\
    \  c.values.flatten\nend", "  l1 = l1 || []\n  l2 = l2 || []\n  l1.sort\n  l2.sort\n\
    \  intersection = l1.select { |x| l2.include?(x) }\n  intersection.sort\nend",
  "  a1 = l1.sort!\n  a2 = l2.sort!\n  m = (a1 + a2).min\n  i1 = 1\n  i2 = a2.length\n\
    \  result = a1.dup\n  while i2 < m\n    s1 = a2.slice!(i2, m).sort!\n    while\
    \ i1 < m && a1[i1] == s1[i1]\n      i1 += 1\n    result << a1[i1]\n    i1 += 1\n\
    \    i2 += s1.length\n  end\n  result\nend", "  l1 = l1[1..-1].sort\n  l2 = l2[1..-1].sort\n\
    \  common = []\n  i = 0\n  while i < l1.size && i < l2.size\n    if l1[i] == l2[i]\n\
    \      common << l1[i]\n      i += 1\n    else\n      break\n  end\n  return common\n\
    end", "  l1.uniq! if l1.kind_of? Array\n  l2.uniq! if l2.kind_of? Array\n  common\
    \ = Set.new\n  l1.each do |elem|\n    common << elem if l2.include? elem\n  end\n\
    \  common.sort!\n  common\nend", "  l1.each do |e|\n    l2.each do |f|\n     \
    \ return e if e == f\n    end\n  end\n  []\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThank you for the quick answer. Very nice.\n<|/ c |>\n<| c |>\nI have\
    \ another question. Why does it output an array with an empty string? I am sorry\
    \ if this is a noob question but i don't quite get it.\n<|/ c |>\n<| c |>\nThe\
    \ empty string `''` is returned by the `return` statement when the if statement\
    \ evaluates to false. Since `common([1,2,3], [2])` returns `[]`, `''` is returned.\n\
    <|/ c |>\n<| c |>\nWhat about if the numbers are not sorted?\n<|/ c |>\n<| c |>\n\
    If `l1` and `l2` are not sorted, `common` will return an empty array. Try it out.\
    \ :)\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,algorithm dscore=0 |>\n<code>", " \
    \   l1 & l2 | (l1 ^ l2)\nend", "  l1.each do |x|\n    l2.each do |y|\n      if\
    \ x == y\n        x.next\n        break\n      end\n    end\n  end\n  l1\nend",
  "  if l1.length <> l2.length\n    l1 = l1[0...l1.length]\n    l2 = l2[0...l2.length]\n\
    \  l1 = l1[1..l1.length]\n  l2 = l2[1..l2.length]\n  i = 0\n  j = 0\n  while i\
    \ < l1.length && j < l2.length\n    if l1[i] <> l2[j]\n      break\n    i += 1\n\
    \    j += 1\n  while i < l1.length\n    l1.delete_at(i)\n    i += 1\n  while j\
    \ < l2.length\n    l2.delete_at(j)\n    j += 1\n  if l1.length <> l2.length\n\
    \    l1 = l1[1..l1.length]\n    l2 = l2[1..l2.length]\n  end\n  return l1, l2\n\
    end", "  l1 = l1.sort\n  l2 = l2.sort\n  l1.length<l2.length ? l2.reverse! : l1.reverse!\n\
    \  (l1+l2).uniq.sort\nend", "  # Find all elements in `l1` that are not in `l2`.\n\
    \  l1c = l1.clone\n  l2c = l2.clone\n  l1c[l1c == nil] = nil\n  l2c[l2c == nil]\
    \ = nil", "  uniq = Set.new\n  uniq.update(l1)\n  uniq.update(l2)\n  uniq.sort!\n\
    \  uniq\nend", "  l1.uniq.sort | l2.uniq.sort\nend", "  return sorted.common(l1,\
    \ l2).to_a\nend", "  # Sort the arrays to make them easier to compare.\n  l1.sort!\n\
    \  l2.sort!\n  \n  # Start with an empty list of possible matches.\n  matches\
    \ = []", "  return l1 & l2\nend", "  l1.each_with_index do |x, i|\n    l2.each_with_index\
    \ do |y, j|\n      if x == y\n        l1.delete_at(i)\n        l2.delete_at(j)\n\
    \        break\n      end\n    end\n  end\n  l1 + l2\nend", "  l1 += l2\n  l2\
    \ = l2.uniq\n  l1.delete_if { |i| !l2.include? i }\nend", "  l1.clone\n  l2.clone\n\
    \  l1.sort do |x, y|\n    return -1 if x < y\n    return 1 if x > y\n    0\n \
    \ end\n  l2.sort do |x, y|\n    return -1 if x < y\n    return 1 if x > y\n  \
    \  0\n  end\n  l1.find do |elm|\n    l2.include?(elm)\n  end\nend", "  uniq =\
    \ unique(l1, l2)\n  commons = uniq.select { |x| l1.count(x) == l2.count(x) }\n\
    \  commons.uniq.sort { |a, b| a <=> b }\nend\n</code>\n<|/ a |>\n<| c |>\nI wish\
    \ I could vote you up twice. Great work! :)\n<|/ c |>\n<| c |>\n, Thanks mate,\
    \ this is working perfectly and fast\n<|/ c |>\n<| c |>\nThe second algorithm\
    \ can be sped up a bit by using a hashset of each item in the first array. For\
    \ example: common([1, 1, 1], {1, 2, 2}) will return [1, 2] instead of [2, 1].\n\
    <|/ c |>\n<| c |>\n, I agree with you, but I didn't find it necessary in this\
    \ case. I just wanted to keep it simple.\n<|/ c |>\n<| a dscore=3 |>\nI used the\
    \ answer provided by Joshua Taylor to solve this problem. However, I added a few\
    \ tweaks to it. This is the code I used:\n<code>", "  l1.zip(l2).select { |e|\
    \ e[0] == e[1] }.flatten.uniq\nend", "  a1, a2 = l1\n  b1, b2 = l2\n  common =\
    \ []\n  i = 0\n  j = 0\n  while i < a1 and j < b1\n    if a1.eql? a2.first &&\
    \ a1.first < b1.first\n      common.push(a1.first)\n      i += 1\n    elsif a2.eql?\
    \ a1.first && a2.first < b1.first\n      common.push(a2.first)\n      j += 1\n\
    \    elsif a1.eql? b2.first && a1.first < b2.first\n      common.push(a1.first)\n\
    \      i += 1\n    elsif a2.eql? b2.first && a2.first < b2.first\n      common.push(a2.first)\n\
    \      j += 1\n    else\n      i += 1\n      j += 1\n    end\n  end\n  common\
    \ = (common[0...a1] + a2)\n  common.uniq\nend", "  c1 = Hash.new\n  c2 = Hash.new\n\
    \  (l1..l2).each do |e|\n    c1[e] ? c2[e] = c1[e] : c1[e] = e\n  end\n  c1.sort.map\
    \ { |k, v| v }\nend", "  if l1.size > l2.size\n    l1.sort!\n    l2.sort!\n  \n\
    \    i = l1[0]\n    while i < l2[-1]\n      while i < l2[-1] and l2[i] < i\n \
    \       i += 1\n        break unless i\n      while i < l1.size and l1[i] < i\n\
    \        i += 1\n      end\n      i += 1\n    end\n    \n    l1[0...i]\n  else\n\
    \    l2.sort!\n  \n    i = l1[-1]\n    while i < l2[0]\n      while i < l2[0]\
    \ and l2[i] > i\n        i += 1\n        break unless i\n      while i < l1.size\
    \ and l1[i] > i\n        i += 1\n      end\n      i += 1\n    end\n    \n    l1[0...i]\n\
    \  end\nend\nend", "  return [item for item in l1 if item in l2] or [item for\
    \ item in l2 if item in l1]\nend\n  ", "  return unique((x for x in l1 if x in\
    \ l2), true)\nend", "  l1.each_with_index do |v1,i|\n    l2.each_with_index do\
    \ |v2,j|\n      return v1 if v1 == v2 and j > i\n    end\n  end\n  nil\nend",
  "  l1.each_with_index do |e, i|\n    return l2 if l2.indexOf(e) == i\n  end\n  []\n\
    end", "  l1.sort.product(l2.sort).uniq\nend", "  l1.sort.zip(l2.sort).each do\
    \ |a|\n    return a if a.any? {|e| e == a.first}\n  end\n  nil\nend\n</code>\n\
    For this code, I'm assuming that you don't have any duplicates in your arrays.\n\
    <|/ a tags=ruby,arrays dscore=0 |>\n<| c |>\nNot sure why the downvote, but this\
    \ is definitely the fastest and simplest answer so far.\n<|/ c |>\n<| a |>\n<code>",
  "    common = []\n    common_map = {}\n    n = 0\n    while n < l1.size && n < l2.size\n\
    \        common_map[l1[n]] = l2[n]\n        n += 1\n    end\n    n = 0\n    while\
    \ n < l1.size\n        common << common_map[l1[n]]\n        n += 1\n    end\n\
    \    n = 0\n    while n < l2.size\n        common << common_map[l2[n]]\n     \
    \   n += 1\n    end\n    common\nend", "  # Add elements to a set.\n  common_elements\
    \ = Set.new\n  l1.each { |e| common_elements << e }\n  l2.each { |e| common_elements\
    \ << e }", "  if l1.length < l2.length then\n    l1, l2 = l2, l1\n  end\n  l1[l1.length-l2.length+1].each_index\
    \ do |i|\n    return l2[i] if l1[i] != l2[i]\n  end\n  return nil\nend", "  if\
    \ l1 == l2 then return l1\n  l3 = []\n  l4 = l1.dup\n  l4.each_index { |i| l3.push(l4[i])\
    \ }\n  l4.each_index { |i| l3.push(l4[i]) }\n  l4.uniq\nend", "    i = 0\n   \
    \ j = l1.size\n    common = []\n    while(i<j) do\n        if(l1[i]==l2[i]) do\
    \ common = common+[i]; i=i+1; end\n        i=i+1\n    end\n    return common\n\
    end", "    diff = []\n    if l1 == nil or l2 == nil\n        return diff\n   \
    \ head = l1[0]\n    tail = l2\n    while head != nil\n        tail = tail.first\n\
    \        head = head.next\n    tail = l2\n    while tail != nil\n        if head\
    \ == tail\n            diff = diff.cons(head).last\n        tail = tail.next\n\
    \    end\n    return diff\nend\n</code>\n<|/ a tags=arrays,ruby |>\n<| c |>\n\
    This is not good because you are using global variables and thus is not very idiomatic.\n\
    <|/ c |>\n<| c |>\nHi guys thanks for your comments guys I got the solution based\
    \ on what i wanted\n<|/ c |>\n<| a dscore=0 |>\nThe most idiomatic way in Ruby\
    \ to implement a list that supports appending to it (also the most efficient,\
    \ according to my measurements), is to create a new array and push new values\
    \ into it. This will also automatically call .each and .to_a on the new array\
    \ (which might save you some cycles if the original array is very large):\n<code>",
  "  a1 = l1.sort_by(&:to_s).to_a\n  a2 = l2.sort_by(&:to_s).to_a\n  a1 & a2\nend",
  "  l1.length==l2.length && ((l2.first+l2.last+1).length==l1.length ||\n    l1.last==l2.first\
    \ ||\n    common(l1.last, l2)==l1.first)\nend", "  common = []\n  l1.each_with_index\
    \ do |el, i|\n    l2.each_with_index do |el2, j|\n      if el == el2\n       \
    \ common << i\n      end\n    end\n  end\n  common\nend", "  h = {}\n  l1.each\
    \ do |i|\n    if h2(i) in h\n      h[h2(i)] += 1\n    else\n      h[h2(i)] = 1\n\
    \    end\n  end\n  l2.each do |i|\n    if h2(i) in h\n      h[h2(i)] -= 1 \n \
    \   end\n  end\n  return h.keys.sort\nend", "  u1, u2 = Set.uniq([].concat(l1,\
    \ l2)), Set.uniq([].concat(l2, l1))\n  return Set.subtract(u1, u2)\nend", "  l1.each\
    \ do |x|\n    l2.each do |y|\n      return x if x == y\n    end\n  end\n  return\
    \ []\nend", "    l1.each do |i|\n        l2.each do |j|\n            if i == j\n\
    \                next i\n            end\n            break if j\n        end\n\
    \        break if i\n    end\n    return l1\nend", "  sorted = l1.sort { |a, b|\
    \ a <=> b }\n  sorted.uniq!\n  sorted.each { |i| l2.delete i }\n  sorted.each\
    \ { |i| l1.delete i }\n  l1\nend", "  l1.zip(l2).find { |e1, e2| e1 == e2 }\n\
    end", "  return l1.to_a - l2.to_a\nend", "  l1.zip(l2).map {|x, y| x <=> y}.uniq.sort\n\
    end", "  common = []\n  l1.each do |i|\n    l2.each do |j|\n      common << i\
    \ if i == j\n    end\n  end\n  common\nend", "  return [e for e in l1 if e in\
    \ l2]\nend\n</cell>\n<code language=julia-1.0>", "  return l1[l1..l2].uniq\nend",
  "    l1.each_with_index do |x, i|\n        l2.each_with_index do |y, j|\n      \
    \      if x == y\n                l2[j + 1] = nil\n            end\n        end\n\
    \    end\n    l2.each_with_index do |x, i|\n        l1.each_with_index do |y,\
    \ j|\n            if x == y\n                l1[j + 1] = nil\n            end\n\
    \        end\n    end\n    l1.uniq\n    l2.uniq\nend\n</code>\n<|/ a |>\n<| a\
    \ |>\n<code>\n def common_elements\n a = array.sort { |a,b| a.to_i <=> b.to_i\
    \ }\n b = []\n b.push(a[0]) if a.size < 2\n a.each_with_index do |x,index|\n \
    \   b.push(x) if b.size < 2\n    next if b.last.include?(x)\n    b.push(x)\n end\n\
    \ b\n end\n</code>\n<|/ a dscore=2 tags=ruby |>\n<| a tags=ruby |>\nHere's my\
    \ solution:\n<code>\narray = [1,4,3,34,653,2]", "  l1 = (l1.sort.uniq.sort_by\
    \ {|e| e}) + l1\n  l2 = (l2.sort.uniq.sort_by {|e| e}) + l2\n  l1.each_with_index\
    \ do |e, i|\n    j = l2.index(l2.index(e) + 1)\n    if j != nil\n      l2.delete_at(j)\n\
    \      break\n    end\n    l2.insert(i, e)\n  end\n  l1\nend\n</code>\n<|/ a tags=arrays,ruby,ruby-on-rails\
    \ dscore=0 |>\n<| c |>\nThank you for your help, but my arrays are already sorted\
    \ and they have no repetitions. I only need to get the \"new\" array with the\
    \ common elements. I'll edit the question with some examples to clarify the question.\n\
    <|/ c |>\n<| a dscore=0 |>\nThe accepted answer from is elegant and efficient,\
    \ but I wanted to offer a more verbose implementation.\nThe idea is that each\
    \ time a common element is found in l1, the value at that index in l2 is spliced\
    \ out and removed from the array.  So you end up with 2 arrays, l1 and l2 which\
    \ now only contain common values.\n<code>", "  result = []\n  l1.each do |e|\n\
    \    if l2.include?(e)\n      result << e\n    end\n  end\n  result\nend", " \
    \ if l1 == [] or l2 == []\n    []\n  el1 = l1.first\n  el2 = l2.first\n  res =\
    \ []\n  while el1 != nil and el2 != nil\n    if el1 == el2\n      el1 = l1.next\n\
    \      el2 = l2.next\n      res << el1\n    else\n      el1 = l1.next\n      el2\
    \ = l2.next\n      res << el1 if el1 <=> el2 != 0\n    end\n  end\n  res\nend",
  "  l = l1.clone\n  l1.shift\n  l2.shift\n  while l1.first && l2.first\n    if l1.first\
    \ == l2.first\n      l << l1.first\n      l1.shift\n      l2.shift\n    else\n\
    \      l << l1.first\n      l1.shift\n    end\n  end\n  l\nend", "  l1 = l1.sort\
    \ { |a, b| b <=> a }\n  l2 = l2.sort { |a, b| b <=> a }\n  l1.zip(l2).find { |a,\
    \ b| a == b }.last\nend", "  l = l1.to_a | l2.to_a\n  l.uniq\nend", "  l1.each\
    \ do |item1|\n    l2.each do |item2|\n      if item1 == item2\n        return\
    \ item1\n      end\n    end\n  end", "  common = []\n  l1, l2 = l1..l2, l2..l1\n\
    \  l1.each { |e| common << e }\n  l2.each { |e| common << e }\n  common.uniq\n\
    end", "  if l1 == []\n  else\n    if l2 == []\n    else\n      common(l1[0], l2[0])\n\
    \      common(l1[1:], l2[1:])\n    end\n  end\nend", "  l1.uniq(&:itself)\n  l2.uniq(&:itself)\n\
    \  common = Set.new(l1).intersection(Set.new(l2))\n  common.is_a?(Array) ? common.to_a\
    \ : common\nend", "  if l1 and l2\n    a1 = []\n    a2 = []\n    for el1 in l1\n\
    \      for el2 in l2\n        if el1 == el2\n          a1 << el1\n          a2\
    \ << el2\n        end\n      end\n    end\n    a1.flatten!\n    a2.flatten!\n\
    \    a1.uniq!\n    a2.uniq!\n    a1 & a2\n  else\n    []\n  end\nend", "  return\
    \ l1 + l2 - l1.find {|x| l2.include? x}\nend\n</code>\n<|/ a dscore=5 tags=arrays,ruby\
    \ |>\n<| c |>\nJust a small remark: this will be O(n^2) if both lists are too\
    \ big. That's probably what OP wants but maybe not necessarily.\n<|/ c |>\n<|\
    \ c |>\nYes, the difference is negligible in most cases. My only concern is that\
    \ in the general case the algorithm can be optimised, but that's a little harder\
    \ to explain and get right...\n<|/ c |>\n<| c |>\nI think you meant `common([1,\
    \ 2, 3], [1, 5, 3])`.\n<|/ c |>\n<| c |>\n: Thanks, fixed it.\n<|/ c |>\n<| c\
    \ |>\nI like the `+` method. The `include?` method might not be the most efficient,\
    \ but it should also perform better than `Hash`s in certain circumstances.\n<|/\
    \ c |>\n<| a |>\nI did a benchmark test (using Ruby 1.9.3 on Mac OS X 10.5.7)\
    \ for this code:\n<code>", "  l1 = [l1].flatten\n  l2 = [l2].flatten\n  a = l1\n\
    \  b = l2\n  sorted = false\n  while !sorted\n    sorted = true\n    a = a.sort\n\
    \    b = b.sort\n    sorted = sorted && a.uniq.size == b.uniq.size\n    sorted\
    \ = sorted && a.uniq.uniq.size == b.uniq.uniq.size\n  end\n  a\nend", "  h1 =\
    \ Hash.new()\n  h2 = Hash.new()\n  h1.merge(*l1)\n  h2.merge(*l2)\n  h1.each{|k,v|\
    \ h2.delete(k) if h1.has_key?(k)}\n  h2.keys\nend\n</code>\n<|/ a dscore=4 tags=algorithm,ruby,hash,ruby-on-rails,arrays\
    \ |>\n<| c |>\nNice. Thanks for sharing. Just a question, how would you benchmark\
    \ this and which approach is faster?\n<|/ c |>\n<| c |>\nYeah, it's pretty nice.\
    \ I had to add a `break` statement after `h2.delete(k) if h1.has_key?(k)`\n<|/\
    \ c |>\n<| c |>\n: I tested this on two arrays of 1,000,000 random integers. The\
    \ results were:", "  l1.each { |elem| l2.delete(elem) }\n  l2.each { |elem| l1.delete(elem)\
    \ }\n  l1.uniq\nend\n</code>\nThe first step removes duplicates from each list\
    \ using .delete. The second step removes duplicates from each list using .delete.\n\
    The third step removes duplicates from both lists using .uniq\n<|/ a dscore=3\
    \ |>\n<| c |>\nThis is a much more elegant solution.\n<|/ c |>\n<| c |>\nThe [Set](http://ruby-doc.org/core-2.4.1/Set.html)\
    \ module implements the Set data type, which has methods for adding elements,\
    \ and for removing elements. It's also faster than Hash#\n<|/ c |>\n<| c |>\n\
    The second one should be `l2.delete` to avoid an exception when `l2` is empty.\n\
    <|/ c |>\n<| c |>\n`l2.delete_if` and `l2.reject { ... }` are more concise ways\
    \ to get the same result.\n<|/ c |>\n<| c |>\nIt's also less concise because they\
    \ create a new array/set/whatever and then delete the original array/set/whatever.\
    \  Also, `delete_if` doesn't work on a frozen set.\n<|/ c |>\n<| a tags=ruby |>\n\
    <code>", "  return l1[common_index(l1, l2)] if l1.size <= l2.size then l1 else\
    \ l2\nend", "    size = min(l1.size, l2.size)\n    common_elements = (0..size\
    \ - 1).to_a\n    l1.zip(l2).each do |e|\n        common_elements << e[0] if e[1]\
    \ == e[1]\n    end\n    common_elements.sort!\n    return common_elements\nend\n\
    </code>\n<|/ a dscore=2 tags=ruby,sorting |>\n<| a |>\n<code>\ncommon_elements\
    \ = [1,2,3,4,5].sort.uniq.join if [1,2,3,4,5].sort == [1,2,3,4,5]\n</code>\nThis\
    \ works too\n<|/ a dscore=2 tags=ruby,sorting |>\n<| c |>\nI like the look of\
    \ this answer! I personally would have used the block form of the `uniq` method\
    \ to get the result but this was the simplest example I could come up with off\
    \ the top of my head.\n<|/ c |>\n<| a tags=ruby,sorting |>\n<code>", "  l1.each\
    \ do |x|\n    l2.each do |y|\n      return x if x == y\n    end\n  end\n  nil\n\
    end", "  l1.zip(l2).group_by(&:first).values\nend", "  if l1 == l2\n    return\
    \ l1\n  l1.sort!\n  l2.sort!\n  return [item for item in l1 if item in l2]\nend",
  "  l1.length.times.zip(l2.length.times).find do |i1, i2|\n    l1[i1] == l2[i2]\n\
    \  end\nend", "  m = {}\n  common = []", "  # Return sorted unique common elements\
    \ for two arrays.\n  common = {}\n  n1 = l1[0].length\n  n2 = l2[0].length\n \
    \ i = 0\n  while i < n1 do\n    common[l1[i]] = true\n    i += 1\n  end\n  i =\
    \ 0\n  while i < n2 do\n    common[l2[i]] = true\n    i += 1\n  end\n  i = 0\n\
    \  while i < n1 do\n    if common[l1[i]] then\n      common[l1[i]] = false\n \
    \     i += 1\n    else\n      break\n    end\n  end\n  i = 0\n  while i < n2 do\n\
    \    if common[l2[i]] then\n      common[l2[i]] = false\n      i += 1\n    else\n\
    \      break\n    end\n  end\n  i = 0\n  while i < n1 do\n    if common[l1[i]]\
    \ then\n      common[l1[i]] = false\n      i += 1\n    else\n      break\n   \
    \ end\n  end\n  i = 0\n  while i < n2 do\n    if common[l2[i]] then\n      common[l2[i]]\
    \ = false\n      i += 1\n    else\n      break\n    end\n  end\n  i = 0\n  while\
    \ i < n1 do\n    if common[l1[i]] then\n      common[l1[i]] = true\n      i +=\
    \ 1\n    else\n      break\n    end\n  end\n  i = 0\n  while i < n2 do\n    if\
    \ common[l2[i]] then\n      common[l2[i]] = true\n      i += 1\n    else\n   \
    \   break\n    end\n  end\n  i = 0\n  while i < n1 do\n    if common[l1[i]] then\n\
    \      common[l1[i]] = true\n      i += 1\n    else\n      break\n    end\n  end\n\
    \  i = 0\n  while i < n2 do\n    if common[l2[i]] then\n      common[l2[i]] =\
    \ true\n      i += 1\n    else\n      break\n    end\n  end\n  return common\n\
    end", "  l1 = l1[1..-1] if l1.class == Array else l1\n  l2 = l2[1..-1] if l2.class\
    \ == Array else l2\n  (l1, l2).uniq.sort\nend", "  # Sort and remove duplicates\n\
    \  l1.sort!\n  l2.sort!\n  common = []\n  \n  while l1.length > 0 and l2.length\
    \ > 0\n    if l1[0] != l2[0]\n      common << l1[0]\n      l1.shift\n    else\n\
    \      common << l2[0]\n      l2.shift\n    end\n  end\n  \n  if l1.length > 0\n\
    \    common << l1[0]\n    l1.shift\n  elsif l2.length > 0\n    common << l2[0]\n\
    \    l2.shift\n  end\n  \n  common\nend", "    l1_count = {}\n    l2_count = {}\n\
    \    common = []\n    \n    for e in l1\n        if e in l1_count\n          \
    \  l1_count[e] += 1\n        else\n            l1_count[e] = 1\n            \n\
    \    for e in l2\n        if e in l2_count\n            l2_count[e] += 1\n   \
    \     else\n            l2_count[e] = 1\n            \n    for e in l1\n     \
    \   if e in l2_count\n            if l2_count[e] == l1_count[e]\n            \
    \    common << e\n            else\n                common << e\n            \
    \    \n    for e in l2\n        if e in l1_count\n            if l1_count[e] ==\
    \ l2_count[e]\n                common << e\n            else\n               \
    \ common << e\n    \n    common.sort # Sort the array.\n    \n    return common\n\
    end", "  s = Set.new\n  l1.each{|x| s.add(x.to_i)}\n  l2.each{|x| s.add(x.to_i)}\n\
    \  s.to_a\nend", "\tl1.each_with_index do |a, i|\n\t\tl2.each_with_index do |b,\
    \ j|\n\t\t\ti <=> j\n\t\tend\n\tend\nend\n</code>\n<|/ a |>\n<| c |>\nIt seems\
    \ this only gives the top 5 matching items.  I tried running it on some larger\
    \ lists, and it seems to work slowly as you go down, but then hangs up on small\
    \ lists.  Can anyone explain why?\n<|/ c |>\n<| c |>\n: My guess is that the `<=>`\
    \ operator is expensive.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  return l1.zip(l2).to_a.select\
    \ { |x,y| x==y }.flatten\nend", "  if l1 == [] or l2 == []\n    return []\n  end",
  "  # return l1 + l2 - set.intersection(l1, l2)\n  common = []\n  l1, l2 = l1, l2\
    \ if l1.size == l2.size else [l2, l1]\n  l1.each_index do |i|\n    if l2[i]\n\
    \      common << l2[i]\n      l2.delete_at i\n    end\n  end\n  common.reverse.each_index\
    \ { |i| l1.delete_at i }\n  common.reverse! if l1.size < l2.size\n  return common\n\
    end", "  return l1[i1] - l2[i1] if i1 < i2 else l1[i2] - l2[i2]\nend\n</cell>\n\
    <text>\nLet's see how it works:", "  i1 = -1\n  i2 = -1\n  result = []\n  while\
    \ (i1 < l1.length) && (i2 < l2.length)\n    if l1[i1] == l2[i2]\n      result\
    \ << l1[i1]\n      i1 += 1\n      i2 += 1\n    elsif l1[i1] < l2[i2]\n      i1\
    \ += 1\n    else\n      i2 += 1\n    end\n  end\n  result\nend", "  common_elements\
    \ = []\n  l1, l2 = l1.sort, l2.sort\n  \n  until l1.empty? or l2.empty? do\n \
    \   smallest = l1.shift if l1.empty? then break end\n    largest = l2.shift if\
    \ l2.empty? then break end\n    \n    next if smallest == largest\n    \n    common_elements\
    \ << smallest\n  end\n  \n  common_elements\nend", "  return l1.sort_by { |e|\
    \ l2.find_index{ |e2| e == e2 } }\nend", "  us = []\n  l1.each do |i|\n    us\
    \ << i if l2.include?(i)\n  end\n  us\nend", "  l1 = l1.sort\n  l2 = l2.sort\n\
    \  return l1[0...l1.find_index(l2[1...l2.size])]\nend", "  common = []\n  l1.each\
    \ { |i| common << i }\n  l2.each { |j| common << j unless common.include?(j) }\n\
    \  common.sort!\n  common\nend\n</code>\n<|/ a |>\n<| a tags=ruby,arrays |>\n\
    I solved my problem with the following function:\n<code>", "  return [] if l1\
    \ == [] or l2 == [] or (l1 & l2).length == 0 else (l1 & l2).to_a\nend", "  common_elements\
    \ = []\n  for i in l1\n    if l2.include? i\n      common_elements << i\n    end\n\
    \  end\n  common_elements\nend\n</code>\nIt takes two arrays, it checks if they\
    \ are the same size, if they are it goes through each element and adds it to a\
    \ new array if they appear in both arrays. \nThen it calls common to return a\
    \ new array with the common elements removed.\n<|/ a dscore=3 tags=arrays,ruby,algorithm\
    \ |>\n<| a dscore=2 |>\n<code>", "  u1 = unique(l1)\n  u2 = unique(l2)\n  u1.each\
    \ do |el|\n    u2.each do |el2|\n      return el if el2 != el\n    end\n  end\n\
    \  nil\nend", "  l1.uniq\n  l2.uniq\n  l1.sort == l2.sort # Ensure sorting is\
    \ not stable.\n  l1.sort != false && l2.sort != false # Ensure that both arrays\
    \ have a sort\n  return l1.select { |x| l2.include?(x) }\nend", "  l1.each_with_index\
    \ do |e, i|\n    return nil if l2.index(e) != i\n  end\n  []\nend", "  l1.each\
    \ do |el|\n    l2.each do |el2|\n      next if el == el2\n      break\n    end\n\
    \    break\n  end\n  l1\nend\n</code>\n<|/ a tags=ruby,arrays,unique |>\n<| c\
    \ |>\nI really like this solution, and have implemented it myself, but it's O(N^2)\
    \ (two for loops) in time, which could be too slow for large lists. I was hoping\
    \ for O(N log N) solution.\n<|/ c |>\n<| c |>\n: There's no better solution. Ruby's\
    \ set class doesn't have a way to remove an element from an arbitrary index. It\
    \ can only remove an element by value.\n<|/ c |>\n<| c |>\n: I guess I figured\
    \ out a more efficient way to do it. It's O(N + M), where N is the array size\
    \ and M is the number of distinct values you want to remove from the array.\n\
    <|/ c |>\n<| a dscore=5 |>\nYou could use Hash#delete_if for removing duplicates\
    \ and then sort and uniq the result:\n<code>\narray = [1,2,3,4] # => [1,2,3,4]\n\
    array.delete_if { |e| array.count(e) == 1 }\narray # => [2,3]\narray.uniq.sort",
  "  l1 = l1.to_a\n  l2 = l2.to_a\n  l1.sort.to_a.concat(l2.sort.to_a).uniq\nend",
  "  l1.each { |e| l2.delete(e) }\n  l1 + l2\nend", "  return l1[1..-1].uniq - l2[1..-1].uniq\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a |>\nI know that there are a lot of ways\
    \ to do this, and this may not be the most elegant, but I found this solution\
    \ by going through all the permutations of the 2 arrays. It's not the most elegant\
    \ solution, but it gets the job done in reasonable time.\n<code>", "  s = Set.new()\n\
    \  (l1 + l2).each do |x|\n    s.add(x)\n  end\n  s.to_a\nend", "  common_elements\
    \ = []\n  common_element_count = 0\n  common_index = 0\n  \n  while common_index\
    \ < l1.length && common_index < l2.length\n    common_element = l1[common_index]\
    \ | l2[common_index]\n    common_elements.push common_element\n    common_element_count\
    \ += 1\n    common_index += 1\n  end\n  \n  if common_index >= l1.length && common_index\
    \ >= l2.length\n    return common_elements if common_element_count > 0\n  end\n\
    \  \n  if common_index >= l1.length\n    return common_elements[0...common_element_count]\
    \ if common_element_count > 0\n  end\n  \n  if common_index >= l2.length\n   \
    \ return common_elements[0...common_element_count] if common_element_count > 0\n\
    \  end\n  \n  return common_elements\nend", "  return l1[0..-2].reject do |el|\n\
    \    l2[-2..-1].include?(el)\n  end\nend", "  l1.sort.each do |l|\n    break if\
    \ l2.any? { |l| l == l }\n    l2.shift\n  end\n  l1\nend\n</code>\n<|/ a tags=ruby,arrays,sorting,ruby-on-rails\
    \ dscore=2 |>\n<| a dscore=2 |>\nOne way to do this is to first sort the arrays,\
    \ then concatenate them. Something like this:\n<code>\na1, a2 = [1,3,2,4], [1,5,2,3,5,3,7,9,5,8,6,3,3]\n\
    a1.sort_by{|a| a}.concat( (a2.sort_by{|a| a}) )\n</code>\n<|/ a tags=ruby,arrays,sorting,ruby-on-rails\
    \ |>\n<| c |>\nThis answer is missing its educational explanation.\n<|/ c |>\n\
    <| c |>\nThis is how it works: a1.sort_by{|a| a} is equal to [1,3,2,4] but a1.sort_by{|a|\
    \ a} returns a1 sorted ascending. a2.sort_by{|a| a} is equal to [1,5,2,3,5,3,7,9,5,8,6,3,3]\
    \ but a2.sort_by{|a| a} returns a2 sorted ascending. a1.sort_by{|a| a}.concat(\
    \ (a2.sort_by{|a| a}) ) is equal to [1,3,2,4,1,5,2,3,5,3,7,9,5,8,6,3,3] which\
    \ is then sorted. Is this explanation not clear enough? I would appreciate if\
    \ someone could give a clearer explanation.\n<|/ c |>\n<| c |>\nTo clarify, my\
    \ previous explanation is wrong. a1.sort_by{|a| a} returns a copy of the array,\
    \ which is sorted in ascending order. a2.sort_by{|a| a} returns a copy of the\
    \ array, which is sorted in ascending order. The difference is that a1.sort_by{|a|\
    \ a}.concat( (a2.sort_by{|a| a}) ) returns a copy of this array, but this array\
    \ is now sorted ascending. In other words, the array is sorted ascending from\
    \ both the original arrays. Does that clarify things?\n<|/ c |>\n<| a dscore=2\
    \ |>\nIf you have Ruby 2.4 or above, you can use Enumerable#each_concat to combine\
    \ the two arrays without resorting to using sort, like so (assuming each array\
    \ is of equal length):\n<code>\narr1 = [0,1,2,4,5,6,7,8,9,12,11,13,14]", "  return\
    \ l1 & l2 | l1 & l2 | l2 & l1 | l2 & l1\nend", "  u1, u2 = [], []\n  l1.each do\
    \ |val|\n    u1 << val if l2.include?(val)\n  end\n  u2\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\nI have written a module which works for me:\n<code>\n\
    module CommonElements\n  def common_elements(first, second)\n    first.reduce(second)\
    \ { |result, el| result & el }\n  end\nend\n</code>\nAnd it is available as Enumerable#common_elements.\n\
    <|/ a tags=ruby,set,arrays |>\n<| a dscore=0 |>\nUse Enumerable#reduce:\n<code>\n\
    a = [5, 3, 2, 8] # => [5, 3, 2, 8]\nb = [3, 2] # => [3, 2]", "  l1.zip(l2).detect\
    \ { |a,b| a == b }\nend", "  return l1 + l2 - common((l1 - l2).to_a, (l2 - l1).to_a)\n\
    end", "  l1, l2 = l1.sort, l2.sort # Ensure sort order of l1 and l2\n  l1.zip(l2).collect\
    \ do |t1, t2|\n    t1 <=> t2\n  end.uniq\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nThis solution is extremely slow.\n<|/ c |>\n<| c |>\nWhy? How long\
    \ would you expect the array to be?\n<|/ c |>\n<| c |>\nThis is actually O(N**2)\
    \ in the worst case (when arrays are sorted and their sizes differ). Even when\
    \ they're not sorted, it could still be O(N*logN) where N is the maximum size\
    \ of one of the arrays (if they are the same, it's O(N))\n<|/ c |>\n<| c |>\n\
    It's interesting to note that the `sort` method takes up ~12% of the total runtime\
    \ for the OP's code (including all times that the OP said he wanted to keep as\
    \ fast as possible, i.e. the difference between O(n) and O(n log(n))\n<|/ c |>\n\
    <| a dscore=5 tags=ruby,arrays |>\nThis is similar to other solutions, but more\
    \ readable:\n<code>", "  common_elements = []\n  i = -1\n  while (i in l1) do\n\
    \    if l1.index(i) in l2\n      common_elements.push(l1.index(i))\n    end\n\
    \  end\n  i = -1\n  while (i in l2) do\n    if l2.index(i) in l1\n      common_elements.push(l2.index(i))\n\
    \    end\n  end\n  common_elements\nend", "  l1.each do |x|\n    l2.each do |y|\n\
    \      return x if x == y\n    end\n  end\nend\n</code>\n<|/ a tags=ruby |>\n\
    <| c |>\nYou do not need to compare the elements in each array. Simply return\
    \ true if all the elements in the two arrays are the same. Or, if you prefer:\
    \ `l1.all? { |x| l2.include? x }`\n<|/ c |>\n<| c |>\nIt does not work: ```common([1,3],\
    \ [1,2,3])", "  common = []\n  i1, i2 = 0, 0\n  while i1 < l1.length and i2 <\
    \ l2.length\n    if l1[i1] == l2[i2]\n      common << l1[i1]\n      i1 += 1\n\
    \      i2 += 1\n    elsif l2[i2] < l1[i1]\n      i1 += 1\n    else\n      i2 +=\
    \ 1\n    end\n  end\n  return common\nend", "  common = Set.new\n  l1.each do\
    \ |i|\n    l2.each do |j|\n      common << i unless i == j\n    end\n  end\n \
    \ common.to_a\nend\n</code>\n<|/ a dscore=2 |>\n<| a |>\nYou can do this in O(m\
    \ log(n)) time by first sorting the list and then comparing adjacent elements.\n\
    <code>", "  l1.zip(l2).flatten.sort & l1.sort\nend", "  l1.zip(l2).collect {|a,\
    \ b| a&b}\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis is a great solution.\
    \ However there is some issue with it. There are some scenarios where it breaks.\
    \ I will update my question to include the scenarios.\n<|/ c |>\n<| c |>\nI added\
    \ a new solution.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,arrays |>\nTry this:\n\
    <code>", "  return l1.inject(:&).to_a.sort.uniq.map(&:first).uniq.concat(\n  \
    \  l2.inject(:&).to_a.sort.uniq.map(&:first).uniq\n  )\nend\n</code>\n<|/ a dscore=2\
    \ tags=arrays,ruby,hashmap |>\n<| c |>\nAh, interesting approach - I like that\
    \ (but I have the feeling that the performance of the `common` method is worse\
    \ than the one I posted below)\n<|/ c |>\n<| a tags=arrays,ruby,hashmap |>\n<code>",
  "  l1.shift if l1.empty?\n  l2.shift if l2.empty?\n  l1.zip(l2).select { |a, b|\
    \ a.first == b }\nend", "  if l1 == nil or l2 == nil\n    return nil\n  else\n\
    \    length = @length(l1) + @length(l2)\n    if length == 0\n      return nil\n\
    \    else\n      common = []\n      i = 0\n      while i < length\n        if\
    \ l1[i] == l2[i]\n          common.push l1[i]\n          i += 1\n        else\n\
    \          break\n        end\n      end\n      return common\n    end\n  end\n\
    end", "  l1.zip(l2).find do |a|\n    a.all? { |e| l.index(e) }\n  end\nend", " \
    \ l1.sort!\n  l2.sort!\n  u = []\n  l1.each do |x|\n    if l2.include?(x)\n  \
    \    u << x\n      l2.delete(x)\n    end\n  end\n  l2.each{|x| u << x if l1.include?(x)}\n\
    \  u\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis works fine for small lists,\
    \ but for larger ones, it gets extremely slow as you're doing a linear search\
    \ for every element. Sorting would help but then you have to sort the entire array\
    \ twice just to find the common elements, which can be done in O(n).\n<|/ c |>\n\
    <| c |>\nThis code also returns duplicates in the array. [1,2,5] & [1,2,1] will\
    \ return [1,2].\n<|/ c |>\n<| c |>\n- No. It does not return duplicates. I added\
    \ a test case to the question that shows it does. It does return duplicates though.\n\
    <|/ c |>\n<| c |>\n- You're right. I didn't test it for duplicates.\n<|/ c |>\n\
    <| a |>\n<code>", "  l1.each do |item1|\n    l2.each do |item2|\n      return\
    \ item1 if item1 == item2\n    end\n  end\nend", '  return [item1 for item1 in
    l1 for item2 in l2 if item1 == item2]', "    l1.zip(l2).each do |a,b|\n      \
    \  return a if b == a\n    end\n    return nil\nend", "  c1 = Hash.new(0)\n  c2\
    \ = Hash.new(0)\n  l1.each do |x|\n    c1.add(x)\n  end\n  l2.each do |x|\n  \
    \  c2.add(x)\n  end\n  c1.keys.sort.zip(l2.keys).each do |key, value|\n    if\
    \ c1.get(key) != c2.get(key)\n      return key\n    end\n  end\nend", "  c = l1\n\
    \  c.uniq!\n  c & l2\nend", "  l1.uniq(&:first) & l2.uniq(&:first)\nend", "  l1.each\
    \ { |e| l2.each { |f| return e if e == f } }\nend", "  uniq = Set.new\n  l1.each\
    \ do |el|\n    uniq.add(el) if l2.include?(el)\n  end\n  uniq\nend", "  l1.sort!\n\
    \  l2.sort!\n  j = 0\n  n1 = l1.length\n  n2 = l2.length\n  common = []\n  while\
    \ j < n1 && j < n2\n    if l1[j] == l2[j]\n      j += 1\n    else\n      common\
    \ = [l1[j]] + common\n      j += 1\n    end\n  end\n  common[common.length...]\
    \ = [] if j == n1 && j == n2\n  common\nend", '  return [x for x,y in zip(l1,l2)
    if y in l1]', "  l1 -= l2\n  l2 = l1\n  common = Set.new\n  l1.each { |i| common\
    \ << i }\n  l2.each { |i| common << i }\n  common.sort { |i1, i2| i1.to_s <=>\
    \ i2.to_s }\n  common\nend", "  return l1 & l2 if l1.length >= l2.length then\
    \ l1 & l2\n  # Remove duplicate elements\n  l1 & l1.delete_if { |x| l2.include?(x)\
    \ }\nend", "  n = l1[0]\n  x = l1[n]\n  i = 2\n  while i <= l2.length and x >=\
    \ l2[i]\n    i += 1\n  return i\nend", "  l1 = sort(l1)\n  l2 = sort(l2)\n  return\
    \ filter(l -> l1.include?(l) or l2.include?(l), l1 + l2)\nend", "  l1 = [*l1]\n\
    \  l2 = [*l2]\n  l1.sort.each {|x| l2.delete(x if l2.include?(x))}\n  l2.sort.each\
    \ {|x| l1.delete(x if l1.include?(x))}\n  l1\nend", "    l1_count = {}\n    l2_count\
    \ = {}", "  r = []\n  v1.each do |e|\n    v2.each do |f2|\n      r += [e] if e\
    \ == f2\n    end\n  end\n  r\nend", "  common_elements = []\n  l1.each do |i|\n\
    \    l2.each do |j|\n      break if i == j\n      common_elements << i if i ==\
    \ j\n    end\n  end\n  common_elements\nend", "  common_elements = []\n  common_size\
    \ = 0\n  common_i = 0\n  common_j = 0\n  while common_i < l1.length && common_j\
    \ < l2.length\n    if l1[common_i] == l2[common_j]\n      common_elements << l1[common_i]\n\
    \      common_i += 1\n      common_j += 1\n      common_size += 1\n    elsif l1[common_i]\
    \ < l2[common_j]\n      common_i += 1\n    elsif l1[common_i] > l2[common_j]\n\
    \      common_j += 1\n    else\n      common_i += 1\n      common_j += 1\n   \
    \ end\n  end\n  common_elements.concat(l1[common_i .. -1]) if common_i < l1.length\n\
    \  common_elements.concat(l2[common_j .. -1]) if common_j < l2.length\n  common_elements.sort!\n\
    \  return common_elements\nend", "    common = []\n    while l1 and= l1.pop\n\
    \        while l2 and= l2.pop\n            common << yield\n        end\n    end\n\
    end", "  r = []\n  l1.each do |e1|\n    l2.each do |e2|\n      r = [e1] + r if\
    \ e1 == e2\n    end\n  end\n  r\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby\
    \ dscore=0 |>\nThis might not be the best way, but should work:\n<code>", "  l1.sort!\n\
    \  l2.sort!\n  ret = []\n  while l1.length > 0 || l2.length > 0\n    break if\
    \ l1.length < l2.length\n    if l1.length < 1\n      ret << l2[0]\n      l2.shift\n\
    \    elsif l2.length < 1\n      ret << l1[0]\n      l1.shift\n    elsif l1[0]\
    \ == l2[0]\n      l1.shift\n      l2.shift\n    else\n      ret << l1[0]\n   \
    \   l1.shift\n      l2.shift\n    end\n  end\n  ret\nend", "  return l1.select\
    \ { |e| l2.include? e }.sort\nend", "  l1.each do |elem1|\n    l2.each do |elem2|\n\
    \      if elem1 == elem2\n        return true\n      end\n    end\n  end\n  return\
    \ false\nend\n</cell>\n<text>\nThe common function works identically to Array#uniq.\
    \ As shown in the example, it removes duplicate elements and returns them as a\
    \ new array. Here's how you might use it.", "    l = l1 + l2\n    index = Array.new\n\
    \    l = l - l2\n    l = l + l1\n    i = 0\n    len = l.length\n    while i <\
    \ len\n        if l[i] == l2[i]\n            index.push(i)\n        end\n    \
    \    i += 1\n    end\n    return index\nend", "  c1, n1 = l1.size, l1.length\n\
    \  c2, n2 = l2.size, l2.length\n  set1 = common_set(c1, n1)\n  set2 = common_set(c2,\
    \ n2)\n  c = set1.intersection(set2)\n  c = c.sort.to_a unless c.empty?\n  c\n\
    end", "  n1 = l1.length\n  n2 = l2.length\n  ret = []\n  \n  i = 0\n  while i\
    \ < n1 && i < n2\n    if l1[i] == l2[i]\n      i += 1\n    else\n      ret <<\
    \ l1[i]\n      i += 1\n    end\n  end\n  \n  while i < n1\n    ret << l1[i]\n\
    \    i += 1\n  end\n  \n  while i < n2\n    ret << l2[i]\n    i += 1\n  end\n\
    \  \n  return ret\nend", "  return uniq(common_sort(l1), common_sort(l2))\nend",
  "  a = l1.sort\n  b = l2.sort\n  return a[-1] == b[-1] ? a : [a[-1], b[-1]]\nend",
  "  l1 = l1.sort\n  l2 = l2.sort\n  (l1 + l2).uniq.sort\nend", "  l1 = l1.sort {|a,b|\
    \ a <=> b}\n  l2 = l2.sort {|a,b| a <=> b}\n  l1.first( (l1.size - l2.size).to_f\
    \ / 2.0 + 1 )\nend\n</code>\n<|/ a dscore=3 |>\n<| a tags=algorithm,ruby,arrays,ruby-on-rails\
    \ dscore=3 |>\nHere is a solution using sort_by with Array#min. Notice that because\
    \ of the way the array is sorted, it is O(n) instead of O(nlogn), but I think\
    \ it should be faster, because it is using the same sorting algorithm that Ruby\
    \ uses for Array#sort (O(nlogn))\n<code>", "  l1.sort.sort.zip(l2.sort.sort).flatten.uniq\n\
    end", "  if l1 == [] or l2 == []\n    []\n  else\n    l1 + l2\n  end\nend", " \
    \ return [item for item in l1 if item in l2]\nend", "  return l1[common_indexes(l1)]\
    \ & l2[common_indexes(l2)]\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
