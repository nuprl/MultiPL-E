name: HumanEval_40_triples_sum_to_zero
language: rb
prompt: "# triples_sum_to_zero takes an array of integers as an input.\n# it returns\
  \ true if there are three distinct elements in the array that\n# sum to zero, and\
  \ false otherwise.\n# >>> triples_sum_to_zero.call([1, 3, 5, 0])\n# false\n# >>>\
  \ triples_sum_to_zero.call([1, 3, -2, 1])\n# true\n# >>> triples_sum_to_zero.call([1,\
  \ 2, 3, 7])\n# false\n# >>> triples_sum_to_zero.call([2, 4, -5, 3, 9, 7])\n# true\n\
  # >>> triples_sum_to_zero.call([1])\n# false\ndef triples_sum_to_zero(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_triples_sum_to_zero\n\
  \    candidate = method(:triples_sum_to_zero)\n    assert_equal(false, candidate.call([1,\
  \ 3, 5, 0]))\n    assert_equal(false, candidate.call([1, 3, 5, -1]))\n    assert_equal(true,\
  \ candidate.call([1, 3, -2, 1]))\n    assert_equal(false, candidate.call([1, 2,\
  \ 3, 7]))\n    assert_equal(false, candidate.call([1, 2, 5, 7]))\n    assert_equal(true,\
  \ candidate.call([2, 4, -5, 3, 9, 7]))\n    assert_equal(false, candidate.call([1]))\n\
  \    assert_equal(false, candidate.call([1, 3, 5, -100]))\n    assert_equal(false,\
  \ candidate.call([100, 3, 5, -100]))\n  end\nend\n"
completions: ["  l.each_with_index do |n,i|\n    return false if n == 0 || (i==0 &&\
    \ n==0)\n  end\n  return true\nend", "    l.uniq.length == 3\nend\n</code>\nFinally,\
    \ write your function as a lambda function and use it in your .each call instead\
    \ of triples_sum_to_zero.\n<code>", "  l = l.sort\n  return (l[0] + l[1] + l[2])\
    \ == 0 && (l[0] + l[1] + l[2] + l[3]) == 0\nend", "  return l.all? && l.none?\
    \ && l.all? { |x| (l.all? {|y| y < 0 && y > 0}) == false }\nend", "  l.each_index\
    \ do |i|\n    for j in (i..l.size).to_a\n      if l[j].zero? and l[j-i].zero?\
    \ and l[j+i].zero?\n        return false\n      end\n    end\n  end\n  true\n\
    end\n</code>\nThis takes advantage of the fact that you can use a negative index\
    \ to access an array in reverse.\n<|/ a tags=ruby,arrays,algorithm |>\n<| a tags=ruby,arrays,algorithm\
    \ dscore=0 |>\nHere's another way to do it, but as I mentioned in my comment,\
    \ it may have some issues, as I've not yet done a thorough test of the code.\n\
    <code>", "  return l.count(l[0], l[1], l[2]) == 3\nend", "  l.each_with_index\
    \ do |a, i|\n    l.each_with_index do |b, j|\n      if ((i - j) == 3) && (a >\
    \ 0 && b > 0)\n        return false\n      end\n    end\n  end\n  return true\n\
    end", "  return l.all? &&\n         (3==l.find_all { |a| a.sum==0 }).size\nend",
  "    l.sort do |a,b,c| return b if c < 0 || a + b < c - b end\n    l.size == 3 ||\
    \ l.size == 0\nend", "  l.inject { |sum, e| sum += e } == 0 && l.uniq.size ==\
    \ 3\nend", "  arr.zip(arr).reduce(0) do |n|\n    sum = 0\n    n.each {|x| sum\
    \ += x}\n    n == sum\n  end\nend\n</code>\n<|/ a tags=ruby,sum,algorithm |>\n\
    <| a tags=ruby,sum,algorithm |>\nThis is an easy problem to solve using a hashtable.\
    \  First we convert the list to a hash and then just loop through the list adding\
    \ each item to the hash as we go along.  When we finish looping through the list,\
    \ we check to see if any item in the hash exists and if it is we know the list\
    \ contains three different positive numbers.\n<code>\nrequire 'set'", "  l.uniq!\n\
    \  l.sort!\n  sum = 0\n  l.each do |item|\n    sum += item\n    return false if\
    \ (sum == 0 && l == [item])\n  end\n  true\nend", "  l.each_index { |i| l[i] +\
    \ l[i] + l[i] } == l.inject(0) { |sum, e| sum + e }\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThis is an interesting solution, however it seems rather inefficient,\
    \ since it iterates over `l` three times and stores results in `sum` three times.\
    \ Also, I think it would return true if the array contained the same element twice.\n\
    <|/ c |>\n<| c |>\nI tested it, and it is indeed slower.  My answer, which is\
    \ similar, is O(n), while the other is O(n^2) (worst-case).  I also think it is\
    \ just as slow as calling `.inject` 3 times.\n<|/ c |>\n<| c |>\nI suspect that\
    \ your `triples_sum_to_zero` function can be written as `def triples_sum_to_zero(l)\n\
    \  l.all? { |e| (l.count(e) + l.count(e) + l.count(e)) <= 2 }\nend`.\n<|/ c |>\n\
    <| c |>\n: I looked at your answer and it does seem to work.  However, it seems\
    \ to return true if the array contains a duplicate element more than once.  For\
    \ example: `triples_sum_to_zero.call([2,3,2])` returns `true`.  I believe that\
    \ should be false, but it seems your function returns `true`.  Am I missing something?\n\
    <|/ c |>\n<| c |>\n: I was just looking at your answer again, and I wonder if\
    \ there is a more efficient way to do it.  I'm thinking that there must be a way\
    \ to do this in O(n) time.\n<|/ c |>\n<| a tags=ruby |>\nHere's a solution that\
    \ uses two sets (which can grow large) and uses a hash to do the computation.\
    \  It requires O(n) time.\n<code>\nrequire 'set'", "  return l.inject(:+) == 0\
    \ && l.count(&:zero?) == 3\nend\n</code>\n<|/ a |>\n<| c |>\nThe \"trick\" to\
    \ solve this kind of problems is to try to think in terms of how you would do\
    \ it on paper, and then translate that approach into Ruby.\n<|/ c |>\n<| c |>\n\
    I love the solution. I've been trying for a solution that is more \"rubyish\"\
    \ but the problem is that i can't think of anything to do this.", "  l.sort.each{|i|\
    \ return false if l[i-1]+l[i]+l[i+1]==0 else true }\nend", "  return l.all? {\
    \ |x| x.even? && x.odd? }\nend", "  return ((l.inject(:+) == l.uniq.size) && l.uniq.size\
    \ == 3 && l.uniq.all? {|i| l.sum - 0 == i})\nend", "  l.uniq.reduce(:+)==0\nend",
  "  l.uniq! # removes any duplicate integers\n  l.map { |e| e-e }.uniq.size == 3\
    \ || 0\nend\n</code>\nLet's compare this with the OP solutions:\n<code>\nrequire\
    \ \"benchmark\"", "  l.sort.map {|x| triples_sum_to_zero(x) }.all?\nend", "  \
    \  l.sort.sort!\n    (0..l.size-1).each {|i| l.delete_at(i) if l[i] + l[i+1] +\
    \ l[i+2] == 0 }\n    l.size == 0\nend", "  sum = 0\n  l.each {|i| sum += i}\n\
    \  if sum > 0 && sum % 3 == 0\n    true\n  else\n    false\n  end\nend", "  l.each_cons(3).all?\
    \ { |x,y,z| x==y && x==z && y==z }\nend", "  l.each_index do |i|\n    triple =\
    \ l.slice(i, i+3)\n    triple.each_index do |j|\n      triple[j].zero? && (l[i]\
    \ -= triple[j], break)\n    end\n  end\n  l.empty?\nend\n</code>\n<|/ a |>\n<|\
    \ c |>\nJust a warning, that implementation will fail if `l` is sorted in descending\
    \ order (e.g. `l = [1, 3, -2, 1]`). Also, it is really inefficient as you are\
    \ creating 4 new arrays with all elements set to zero. Try this with a list with\
    \ 1000 elements. Your code will need to run thousands of iterations to finish\
    \ :-)\n<|/ c |>\n<| c |>\nThank you for pointing that out. I have included a second\
    \ implementation that keeps track of the indexes in the original array, and uses\
    \ only 2 arrays. However, I have now learned that my first example does not keep\
    \ track of the indexes in the original array and will not work in that case.\n\
    <|/ c |>\n<| c |>\n+1 for your first implementation. I would have upvoted it twice\
    \ if I could.\n<|/ c |>\n<| c |>\nYour first implementation doesn't work for arrays\
    \ with negative values. `[1,2,-3,4].each_index { |i| puts \"#{i} #{self[i]} #{self[i]\
    \ + self[i+1]}\"}` gives `1 0 2`. But the second one does. It's much slower, but\
    \ you can do both of them in one pass (using `slice_before` instead of `slice`).\
    \ `[1, 2, -3, 4].slice_before(-1).each_index { |i| puts \"#{i} #{self[i]} #{self[i]\
    \ + self[i+1]}\"}`\n<|/ c |>\n<| a |>\nI know this question is old, but I'm having\
    \ a similar problem and thought I would share my solution. \nFirst of all, since\
    \ I'm working with Ruby I believe that most of the answers here are unnecessary.\
    \ This problem can be solved without using any loops by using some Ruby language\
    \ features such as regular expressions.\nHere is my code that I used:\n<code>\n\
    \  def count_zero_elem(arr)\n    arr = arr.dup\n    return false if arr.size <\
    \ 3\n    arr.slice!(0...arr.size-2)\n    arr.each do |i|\n      next if i.to_s.match?(/[-]/)\n\
    \      arr.slice!(i)\n      arr.slice!(arr.size-1)\n      arr.each do |j|\n  \
    \      next if j.to_s.match?(/[-]/)\n        arr.slice!(j)\n      end", "  l.each_cons(3).none?{|s|\
    \ s.inject(:+) == 0}.tap do |res|\n    throw(\"Not a triples!\") unless res\n\
    \  end\nend", "  return l.count(l[0]) == 3\nend", "  l1=l.sort\n  l2=l1.select{|x|\
    \ x==0 or x==1 or x==-1}\n  l3=l2.select{|x| x>0}\n  l4=l3.select{|x| l1.count(x)>3}\n\
    \  l5=l4.select{|x| l1.count(x)==3}\n  return false if l5.empty?\n  l5.each do\
    \ |x|\n    l1.delete_at(x)\n    l3.delete_at(x)\n    l4.delete_at(x)\n  end\n\
    \  return true if l1.empty?\n  return false if l3.empty?\n  return false if l4.empty?\n\
    \  return true\nend", "  return l.count(l[0]) == 3 && l.count(l[1]) == 3 && l.count(l[2])\
    \ == 0\nend", "  return l.inject(:+) == 0 &&\n         l.uniq.size == 3 &&\n \
    \        l.uniq.all? { |n| n.even? || n.odd? } &&\n         l.minus_one == 0\n\
    end", "  triples_sum_to_zero.result ||= (l.inject(0) do |acc, e|\n    acc + (e\
    \ == 0)\n  end) == 0\nend", "  # write your code here\n  return true\nend\n</cell>\n\
    <code language=julia-0.5>\n@test triples_sum_to_zero.call([1, 3, 5, 0])\n</cell>\n\
    <code language=julia-0.5>\n@test triples_sum_to_zero.call([1, 3, -2, 1])\n</cell>\n\
    <code language=julia-0.5>\n@test triples_sum_to_zero.call([1, 2, 3, 7])\n</cell>\n\
    <code language=julia-0.5>\n@test triples_sum_to_zero.call([2, 4, -5, 3, 9, 7])\n\
    </cell>\n<code language=julia-0.5>\n@test triples_sum_to_zero.call([1])\n</cell>\n\
    <text>\n6. (20 points)", "  l.each_with_index do |x, i|\n    if i != 0\n     \
    \ break if i > l.size - 1\n      l.slice!(0, i + 1)\n      l.slice!(0, i + 1)\n\
    \    end\n  end\n  return l.size == 3\nend", "  l.inject(:+) == l.inject(:*)\n\
    end", "  return l.uniq.size == 3 and l.uniq.select { |e| e % 3 == 0 }.sum == 0\n\
    end", "  return l.is_a?(Array) && l.any?{|n| n.is_a?(Fixnum) && n == 0}\nend",
  "  l.inject {|a, x, *rest| a + x; a} == l.inject(0) {|a, x, *rest| a + x; a}\nend",
  "  return l.count(1) == 3\nend", "  l.inject(0) {|sum, e| sum + e * e} == 0 and\n\
    \      l.uniq.length == 3\nend", "    triple = l.zip(l).zip(l)\n    triple.all?\
    \ { |x, y, z| x == y && x == z && y != 0 }\nend\n</code>\nThe main advantage of\
    \ this function is that it returns true or false instead of an array (as you originally\
    \ requested).  But notice that this function is inefficient, as it has to go through\
    \ each element of the list three times.  \nOne way to speed it up is to remember\
    \ what you've seen so far, e.g. in a HashSet:\n<code>", "  l.sort\n  l.inject([[],\
    \ [], [], []]) do |(sums, count), num|\n    if num == 0\n      return true\n \
    \   elsif num == -1\n      return true\n    elsif num == -2\n      return true\n\
    \    end\n    sums.push num\n    count += 1\n  end\n  sums.length == 3 && sums.uniq.length\
    \ == 3\nend", "    l.each_with_index do |v,i|\n        next unless v != 0\n  \
    \      j = i + 1\n        l.each_with_index do |u,j|\n            next unless\
    \ v + u == 0 && i != j\n            return true if v == u\n        end\n    end\n\
    \    false\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThanks for taking\
    \ the time to write this down! I'm going to accept this as the answer though because\
    \ it's much cleaner code, but I'm going to run some performance tests on each\
    \ one and let everyone know which one works best. Thanks for your time!\n<|/ c\
    \ |>\n<| c |>\nI'm curious, what do you use to measure performance of ruby scripts?\n\
    <|/ c |>\n<| c |>\nI used to use Timmy's script. That's been around for a while\
    \ now, and it's always been pretty good at giving me an idea of how long various\
    \ methods are taking, or how much memory they take.\n<|/ c |>\n<| c |>\nI have\
    \ added my code to benchmark `triples_sum_to_zero` on 1000 loops, 100 elements\
    \ array\n<|/ c |>\n<| c |>\nThanks for the update. I ran some benchmark tests\
    \ and this one is fastest. I'm going to use this one for now, but I'll keep my\
    \ \"clever\" version in mind for future use.\n<|/ c |>\n<| a |>\n<code>", "  sum\
    \ = 0\n  for i in l\n    sum += i\n    if sum > 0\n      return false\n  end\n\
    \  return true\nend\n</code>\n<|/ a |>\n<| c |>\nIt's pretty much the same thing\
    \ as the accepted answer but with a small improvement - you forgot to add the\
    \ `end` keyword. Also, the `<=>` operator is available in Ruby >= 2.1.\n<|/ c\
    \ |>\n<| c |>\nThanks for that! I realized the `<=>` operator is available in\
    \ Ruby 2.1, but I didn't know about it. I just looked it up and fixed it.\n<|/\
    \ c |>\n<| a dscore=0 |>\nThe answer provided above is correct, but you can do\
    \ it in just one line.\n<code>", "  return l.all? do |x| x == 0 && x.even? &&\
    \ x.odd? ||\n    (x.positive?(-1) && x == 0) ||\n    (x.even? && x.odd? && x ==\
    \ 0) ||\n    (x.even? && x.odd? && x.positive?(-x)) ||\n    (x.even? && x.even?\
    \ && x == 0) ||\n    (x.positive?(-x) && x.even? && x == 0) ||\n    (x.positive?(-x)\
    \ && x.odd? && x == 0) ||\n    (x.positive?(-x) && x.even? && x.positive?(-x))\
    \ ||\n    (x.positive?(-x) && x.odd? && x.positive?(-x))\n  end\nend", "  l.each_with_index\
    \ do |e, i|\n    break if i > 1\n    break if i > 2\n    break if l - e == 0\n\
    \  end\n  l.each_with_index do |e, i|\n    break if i > 1\n    break if i > 2\n\
    \    break if e == 0\n  end\n  l.each_with_index do |e, i|\n    break if i > 1\n\
    \    break if i > 2\n    break if l - e == 0\n  end\nend\n</code>\n<|/ a tags=ruby,arrays,sum\
    \ |>\n<| c |>\nThis answer would be more useful with a bit more detail.  What\
    \ is the `sum` variable that you create in `triples_sum_to_zero` doing?  It's\
    \ not obvious to me how it is being used.  Also how is `l` being used in the `each_with_index`\
    \ blocks?  Is it just an arbitrary variable name that you've created?\n<|/ c |>\n\
    <| c |>\nThe `sum` variable is created in the method `triples_sum_to_zero`. It\
    \ is just a local variable that is used to hold the sum of all the numbers up\
    \ to index 2.", "  l.inject([]) do |memo, item|\n    memo.push item\n    memo.push\
    \ item\n    memo.push item\n    memo\n  end.reduce { |memo, item| item == memo.first\
    \ && item == memo.last && item == memo.last }\nend\n</code>\n<|/ a dscore=1 tags=ruby\
    \ |>\n<| a tags=ruby |>\nYou could use a counter:\n<code>", "  l.map! {|x| (x\
    \ * x * (3 - x))}\n  l.uniq\n  .size==3\nend", "  l.each do |num|\n    sum = 0\n\
    \    l.each do |num2|\n      sum += 1\n      break if sum == num\n    end\n  \
    \  sum != num\n  end\nend\n</code>\nThe second part of this exercise is to create\
    \ a function named doubles, which takes a list of integers as an input.\nThe function\
    \ doubles doubles the integers in the list, returning the new list.\n<code>",
  "  return l.count(l.first(3).sum) == 0\nend", "  l.map!{ |n| -(n + 1) } # get rid\
    \ of negative numbers\n  l.uniq.size == 3\nend\n</code>\n<|/ a |>\n<| c |>\nNice!\
    \ I didn't know about `uniq` - nice one!\n<|/ c |>\n<| c |>\nI thought about using\
    \ `uniq` but it didn't quite come out of my mind.\n<|/ c |>\n<| c |>\nAh, I didn't\
    \ even know about `map!` :) I was just thinking about a more readable solution\
    \ than a lambda/map - still nice!\n<|/ c |>\n<| a dscore=3 |>\nHere's an elegant\
    \ solution based on a very efficient data structure known as a DAG. \n<code>",
  "  l.each_with_index do |item, index|\n    next if item == 0\n    triple_index =\
    \ index * 2 + 2\n    if triple_index + 2 > l.size\n      triple_index -= (l.size\
    \ - index)\n    end\n    l.each { |item2| l.delete(item2) if item2 != item }\n\
    \    l.each { |item2| l.delete(item2) if item2 != item + 1 }\n    l.each { |item2|\
    \ l.delete(item2) if item2 != item - 1 }\n    l.each { |item2| l.delete(item2)\
    \ if item2 != item - 2 }\n    l.delete(item)\n    l.delete(item + 1)\n    l.delete(item\
    \ - 1)\n    l.delete(item - 2)\n  end\n  l.length == 3\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 tags=ruby |>\nHere is my answer. Probably a lot of code but\
    \ I think this code is quite clear.\n<code>", "  l.sort {|a, b| b - a} # sort\
    \ the array in descending order first\n  l.uniq.sort.size == 3 ? true : false\n\
    end", "  return l.product(l)==([0,]*l.count).all?\nend\n</cell>\n<cell>", "  l.inject(0){|a,\
    \ x| a + (x * x)} == 0.0\nend", "    l.each_with_index do |e, i|\n      l.each_with_index\
    \ do |f, j|\n        l.each_with_index do |g, k|\n          if i != j and j !=\
    \ k and k != i and k + e + f == 0 \n            return true\n          end\n \
    \       end\n      end\n    end\n    return false\nend", "    l.each do |i|\n\
    \        l.each do |j|\n            l.each do |k|\n                if i != j and\
    \ i != k and j != k and i + j + k == 0 \n                    return false\n  \
    \              end\n            end\n        end\n    end\n    return true\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThis code appears to be a variation of Haskell\
    \ code I wrote, where I used an explicit recursion relation that doesn't require\
    \ the use of explicit loops.  This code appears to be an inefficient way to solve\
    \ the problem -- it is an O(n^3) algorithm, but I don't see how it can be solved\
    \ in O(n) time.\n<|/ c |>\n<| c |>\n: You are correct.  I looked back at my algorithm\
    \ and saw that I was checking for three *distinct* elements that sum to zero rather\
    \ than three, distinct elements that add up to zero.  Your solution is correct.\n\
    <|/ c |>\n<| a tags=big-o,algorithm,ruby,ruby-on-rails |>\nI don't think Ruby\
    \ has some way to iterate over multiple arrays at once, especially not one that\
    \ uses hashes. Perhaps you can store all the numbers in an array, then loop through\
    \ that array in a hash/set style loop to get your result.\n<|/ a dscore=0 |>\n\
    <| c |>\nThat's not how you would write a hash based algorithm though.\n<|/ c\
    \ |>\n<| c |>\n: Why is that? A hash takes each key once, with each value once.\
    \ Iterating over an array is the same in that case.\n<|/ c |>\n<| a tags=big-o,algorithm,ruby,ruby-on-rails\
    \ |>\nRuby 1.9 has Enumerators for this:\n<code>", "  l=l.sort\n  sum=0\n  n=l.length\n\
    \  i=0\n  while i<n\n    sum+=l[i]\n    i=i+1\n    if sum<0\n      return false\n\
    \    else if sum==0\n      return true\n    else if sum>0\n      sum=sum-1\n \
    \     i=i+1\n  end\n  return false\nend", "  l.each do |i|\n    l.each do |j|\n\
    \      l.each do |k|\n        next if i == j && j == k\n        return true if\
    \ i == j + k\n      end\n    end\n  end\n  false\nend", "  l.each do |n|\n   \
    \ l.each do |m|\n      l.each do |k|\n        return false if n == m + k\n   \
    \   end\n    end\n  end\n  true\nend\n</code>\n<|/ a |>\n<| a dscore=0 tags=ruby\
    \ |>\n<code>", "  l.each_index do |i|\n    break if l[i] > 0 && l[i] < 0\n   \
    \ return true if l[i] == 0\n  end\n  return false\nend", "  l.each_with_index\
    \ do |number, i|\n    if number > 0 && i.odd? && i.even?\n      triples_sum_to_zero(l,\
    \ i + 2, i)\n      triples_sum_to_zero(l, i + 2, i + 2)\n      triples_sum_to_zero(l,\
    \ i, i)\n      return true\n    end\n  end\n  return false\nend", "  l = l.reverse\n\
    \  l[0] = 0\n  l[1] = l[1] > 0 ? 1 : 0\n  l[2] = l[2] > 0 ? 1 : 0\n  l.reverse_each\
    \ do |e|\n    if e == 0\n      return true\n    elsif e == l[0]\n      return\
    \ l[1] < 0\n    elsif e == l[1]\n      return l[2] < 0\n    elsif e == l[2]\n\
    \      return false\n    end\n  end\n  return false\nend", "  sum = 0\n  l.each\
    \ { |num| sum += num }\n  sum == 0\nend", "  return l.count == 3 &&\n        \
    \ l.min.zero? &&\n         l.max.zero? &&\n         l.zip(l.drop(1).drop(2)).all?\
    \ { |a, b| a == 0 || b == 0 }\nend", "  triples_sum = 0\n  l.each do |x|\n   \
    \ triples_sum += x\n    if triples_sum > 0\n      break\n    end\n  end\n  triples_sum\
    \ == 0\nend", "  sum = 0\n  for i in 0...l.length\n    sum += l[i]\n    return\
    \ true if sum == 0 and false otherwise\nend\n  ", "  l.each_with_index do |num,\
    \ i|\n    break if num.even?\n    next if i == 0\n    prev = l[i-1]\n    if num\
    \ + prev == prev\n      return false\n    end\n  end\n  return true\nend\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nThank you for your answer. Can you please explain\
    \ me the purpose of the `next` statement in the for loop?\n<|/ c |>\n<| c |>\n\
    The next statement causes the loop to move on to the next element in the array.\
    \ In the case of the array [1,3,-2,1] the first iteration takes you to the last\
    \ element, so the loop moves on to the next element. In the case of the array\
    \ [1, 2, 3, 7] the second iteration takes you to the second element, so the loop\
    \ moves on to the next element. In the case of the array [2, 4, -5, 3, 9, 7] the\
    \ third iteration takes you to the first element, so the loop stops.\n<|/ c |>\n\
    <| c |>\nThe `next` statement will exit the loop and go to the next element in\
    \ the array (if there is one). I've just added some comments to explain this.\n\
    <|/ c |>\n<| c |>\nI understand now, thank you for taking the time to explain\
    \ it in detail! :)\n<|/ c |>\n<| a |>\nHere's a solution using Enumerable#each_cons:\n\
    <code>", "  l.each do |x|\n    next if x == 0\n    sum = x\n    l.each do |y|\n\
    \      sum = sum + y\n      break if sum == 0\n    end\n    return false unless\
    \ sum == 0\n  end\n  true\nend", "  return triples_sum_to_zero_helper(l, 0, 0,\
    \ []).all?\nend", "  # write your code here\n  sum = 0\n  for i in l\n    sum\
    \ += i\n  return sum == 0\nend ", "  l.each_cons(3) do |triple_of_numbers|\n \
    \   return false unless triple_of_numbers.uniq.count < 3\n  end\n  true\nend\n\
    </pre>", "  l.each do |i|\n    return false if (l.count - i) % 3 == 0\n  end\n\
    \  true\nend\n</cell>\n<text>\nExercise 5 - Defining variables and using them\
    \ in a function", "  return l.count(:distinct => true) % 3 == 0\nend\n</code>\n\
    Now you can do:\n<code>\np [\n  triples_sum_to_zero.call([1, 2, 3, 7]),\n  triples_sum_to_zero.call([2,\
    \ 4, -5, 3, 9, 7]),\n  triples_sum_to_zero.call([3, -7, 9, 2, 1]),\n  triples_sum_to_zero.call([1,\
    \ 3, 5, 0]),\n  triples_sum_to_zero.call([3, 5, -7, 8]),\n  triples_sum_to_zero.call([1,\
    \ 3, -2, 1]),\n  triples_sum_to_zero.call([2, 4, -5, 3, 9, 7, 8]),\n  triples_sum_to_zero.call([3,\
    \ 5, -7, 9, 2]),\n  triples_sum_to_zero.call([3, -7, 9, 2, 1])\n].each { |r| puts\
    \ r }\n</code>\nPrints:\n<code>\nfalse\nfalse\ntrue\nfalse\ntrue\ntrue\nfalse\n\
    true\nfalse\n</code>\n<|/ a dscore=2 |>\n<| c |>\nAh yes, I like `count` :) +1\n\
    <|/ c |>\n<| c |>\nYour solution doesn't work if the array contains duplicates.\
    \ I've updated the question to show how duplicates are handled.\n<|/ c |>\n<|\
    \ c |>\n, I've edited my answer, now it handles duplicates as well.\n<|/ c |>\n\
    <| a |>\nI suggest the following approach using Array#include?\n<code>", "  l.uniq.reduce(:+)\
    \ == 0 && l.count(3) == 0\nend", "  return l.count(l[0]) == 3 && l.uniq.count(l[0])\
    \ == 3\nend", "  return l.reduce(:+) == 0 && l.reduce(:-) == 0 && l.reduce(:*)\
    \ == 0 && l.reduce(:&) == 0\nend", "  return l.count(l[0]+l[1]+l[2]) == 0\nend",
  "  # your code goes here\n  if l.is_a? Array and l.count == 3\n    l1 + l2 + l3\
    \ == 0\n  end\nend", "    count = 0\n    negatives = []\n    positives = []\n\
    \    negatives_sum = 0\n    positives_sum = 0\n    for el in l\n        if el\
    \ < 0\n            negatives << el\n        else\n            positives << el\n\
    \    end\n    positives.each do |el|\n        negatives_sum += el\n    end\n \
    \   negatives_sum.times do |i|\n        if l == negatives # element at position\
    \ i is a negative integer\n            count += 1\n        elsif l == positives\
    \ # element at position i is a positive integer\n            count += 1\n    \
    \    else\n            return false # element at position i is not a negative\
    \ or positive integer\n        end\n    end\n    return count == 3\nend", "  l.uniq.length\
    \ == 3\nend\n  ", "  for i in 0..(l.length-1) # loop from 0 to length-1, because\
    \ we are counting down from length\n    if l.sum - l[i] > 0\n      return false\n\
    \    end\n  end\n  return true\nend\n</cell>\n<cell>", "  sum = 0\n  for i in\
    \ 0..l.size\n    sum = sum + l[i]\n    if sum < 0\n      return false\n    elsif\
    \ sum > 0\n      return true\n  end\nend", "  return l.count(3)==2 and not l.count(0)\n\
    end\n</cell>\n<text>\nExercise 10: Write a function that takes a list as an input\
    \ and returns true if there are at least two distinct elements in the list that\
    \ sum to zero or false. For example, triples_sum_to_zero([1, 4, 0, 6, 0, 2]) returns\
    \ true.", "    return l.select{|n| n >= 3 && l.count(n) == 3} == nil\nend", " \
    \ l.each_index do |i|\n    sum += l[i]\n    if (sum == 0) && (i != l.size - 1)\n\
    \      return true\n    end\n  end\n  return false\nend\n</code>\n<|/ a tags=python,algorithm,ruby\
    \ |>\n<| c |>\nThis solution worked really well. I can't say I'm thrilled that\
    \ it's so much more complicated than it needs to be, but at least it's an option\
    \ to consider. Thanks for taking the time to respond.\n<|/ c |>\n<| c |>\nYou\
    \ can make it a lot simpler by avoiding `sum` and just comparing the `sum` of\
    \ `l[i]` against `sum(l[i..-1])`. You'd only need the `sum` variable if you wanted\
    \ to keep the original array unchanged.\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ with negative inputs (e.g. `triples_sum_to_zero.call([-2, -1, 2])`). One has\
    \ to change `sum` into `sum >= 0`.\n<|/ c |>\n<| a |>\nRuby version:\n<code>",
  "  l.each do |el|\n    next if el == 0 || el == 1 || el == 2\n    l.each do |el2|\n\
    \      l.each do |el3|\n        return true if el + el2 + el3 == 0\n      end\n\
    \    end\n  end\n  false\nend", "  l.each do |x|\n    l.each do |y|\n      l.each\
    \ do |z|\n        return false if (x + y + z == 0)\n      end\n    end\n  end\n\
    \  true\nend", "  l.uniq.length == 3\nend", "  l.each do |e|\n    next if e ==\
    \ 0\n    l.each do |e|\n      l.each do |e|\n        return true if e == 0\n \
    \     end\n    end\n  end\n  false\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n\
    You might want to make that a little nicer, `return true if e == 0 || triples_sum_to_zero[e\
    \ + 1]` or something.\n<|/ c |>\n<| c |>\n, can you elaborate? What do you mean\
    \ by \"nicer\"? I thought that would work...\n<|/ c |>\n<| c |>\nI mean more concise,\
    \ IMO.\n<|/ c |>\n<| c |>\nIt wouldn\u2019t work, since when you\u2019re calling\
    \ `triples_sum_to_zero` with something other than 0, you\u2019ll get another recursive\
    \ call that will eventually return `true` (since `e == 0` will be false), while\
    \ you\u2019re still trying to access the element at the `e + 1` position.\n<|/\
    \ c |>\n<| c |>\n, you're right; I fixed it. I think the other problems still\
    \ apply; though, I think this version is more clear, and is less likely to overflow.\n\
    <|/ c |>\n<| a tags=ruby |>\nYou can do it like this:\n<code>", "    sum = 0\n\
    \    for i in l\n        sum += i\n        if sum == 0 then return false\n   \
    \ true\nend", "    l.each_with_index do |n,i|\n        next unless n.positive?\n\
    \        j = i+1\n        l.each_with_index do |m,j|\n            next unless\
    \ m.positive?\n            if n*m == 0 then\n                l.slice!(i, j).clear\n\
    \                return true\n            end\n        end\n    end\n    false\n\
    end\n</code>\n<|/ a tags=ruby,algorithm |>\n<| c |>\nThanks for your suggestion.\
    \ I had a question about the complexity of your code - why is it O(N^2)? Is it\
    \ because the nested loops increase the complexity per iteration of the outer\
    \ loop? If so, then the complexity of O(N^2) comes from O(N^2) iterations of the\
    \ inner loop?\n<|/ c |>\n<| c |>\nYes, that is exactly what happens. When you\
    \ have a nested loop and you remove items from the outer loop you don't need to\
    \ recalculate all the items in the nested loop but you still need to iterate the\
    \ other items in the inner loop. This means that the complexity is `O(N^2)`, not\
    \ `O(N)`.\n<|/ c |>\n<| c |>\nThanks for the explanation. I'm really glad I asked\
    \ the question here and not in the math SE forums. :)\n<|/ c |>\n<| c |>\nI guess\
    \ I am stuck in the old trick of always thinking about problems in terms of big-O\
    \ complexity. :(\n<|/ c |>\n<| c |>\nThe code is not O(N^2). It will iterate through\
    \ each element twice. In the inner loop, the first time through, it goes through\
    \ the whole list of N-1 elements twice. The second time through, only goes through\
    \ one element of N elements. But even that does not matter; you are still doing\
    \ N operations.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  l.uniq.size == 3 && l.uniq.all?\
    \ { |i| l.all? { |j| j < i } }\nend", "    l.each_with_index { |e, i| return false\
    \ if (e - l[i+2]).abs <= (e - l[i+1]).abs }\n    l.each_with_index { |e, i| return\
    \ false if (e - l[i+3]).abs <= (e - l[i+1]).abs }\n    l.each_with_index { |e,\
    \ i| return false if (e - l[i+2]).abs <= (e - l[i+3]).abs }\n    l.each_with_index\
    \ { |e, i| return false if (e - l[i+2]).abs <= (e - l[i+4]).abs }\n    l.each_with_index\
    \ { |e, i| return false if (e - l[i+3]).abs <= (e - l[i+4]).abs }\n    l.each_with_index\
    \ { |e, i| return false if (e - l[i+3]).abs <= (e - l[i+5]).abs }\n    l.each_with_index\
    \ { |e, i| return false if (e - l[i+4]).abs <= (e - l[i+5]).abs }\n    l.each_with_index\
    \ { |e, i| return false if (e - l[i+4]).abs <= (e - l[i+6]).abs }\n    l.each_with_index\
    \ { |e, i| return false if (e - l[i+5]).abs <= (e - l[i+6]).abs }\n    l.each_with_index\
    \ { |e, i| return false if (e - l[i+5]).abs <= (e - l[i+7]).abs }\n    l.each_with_index\
    \ { |e, i| return false if (e - l[i+6]).abs <= (e - l[i+7]).abs }\n    l.each_with_index\
    \ { |e, i| return false if (e - l[i+7]).abs <= (e - l[i+8]).abs }\n    l.each_with_index\
    \ { |e, i| return false if (e - l[i+7]).abs <= (e - l[i+9]).abs }\n    l.each_with_index\
    \ { |e, i| return false if (e - l[i+8]).abs <= (e - l[i+9]).abs }\n    l.each_with_index\
    \ { |e, i| return false if (e - l[i+8]).abs <= (e - l[i+10]).abs }\n    l.each_with",
  "  l.length.times {\n    i = l.pop\n    j = l.pop\n    k = l.pop\n    l.length.times\
    \ { \n      ik, jk, kk = l.pop, j.pop, l.pop\n      if ik != jk || kk != ik ||\
    \ ik != kk\n        return false\n      }\n    }\n  true\nend", "  if l.length\
    \ < 3\n  then return true\n  else return false\n  end \nend", "  # Your code here\n\
    end", "  return true if l.inject(:+) == 0 && l.size == 3\n  false\nend\n</cell>\n\
    <code language=julia-0.6>", "  l.each do |i|\n    next_index = i+1\n    break\
    \ if next_index == l.length\n    while l[i] == l[next_index] and next_index <\
    \ l.length\n      next_index += 1\n      break if next_index == l.length\n   \
    \ end\n    return true if next_index == l.length\n  end\n  false\nend", "  l.each\
    \ do |number|\n    next if number == 0\n    next if number == 1\n    return false\
    \ if (number+number+number) == 0\n  end\n  return true\nend", "  l.each_with_index\
    \ do |x, index|\n    sum =  x - l[index]\n    sum == 0 && return index\n  end\n\
    \  false\nend", "  l.inject(true) { |a, b| a && b }\nend", "    a.sort.call(l)\
    \ # sort first for speed\n    return a.uniq.length.call(a).eql?.call([0,0,0])\
    \ \nend", "  return l.reduce(:+) == 0 || l.reduce(:-) == 0 || l.reduce(:*) ==\
    \ 0 || l.reduce(:/) == 0\nend", "    sum = 0\n    for i in l\n        sum += i\n\
    \        if sum == 0\n            return true\n    return false\n    end", " \
    \ return l.sum.to_f == 0\nend", "  # your code here\n  triple_count = 0\n  trip_sum\
    \ = 0\n  for i in l\n    if trip_sum == 0 \n      trip_sum += i\n    else\n  \
    \    triple_count += 1\n      trip_sum -= i\n  case triple_count == 3\n    true\n\
    \  else\n    false\n  end\nend\n</code>\nSolution 2 - Using Array#uniq (without\
    \ using any extra variable)\n<code>", "\tl.each do |x|\n\t\tnext if x != 0 &&\
    \ triples_sum?(x.to_a)\n\t\treturn true\n\tend\n\treturn false\nend", "  return\
    \ l.all? do |x| \n    (l.count(x) % 3) == 0 \n  end\nend\n</cell>\n<code language=julia-1.0>\n\
    function triples_sum_to_zero(l)\n  return l.all? do |x| \n    (l.count(x) % 3)\
    \ == 0 \n  end\nend\n</cell>\n<code language=julia-1.0>\nfunction triples_sum_to_zero(l)\n\
    \  return l.all? do |x| \n    (l.count(x) % 3) == 0 \n  end\nend\n</cell>\n<code\
    \ language=julia-1.0>", "  l = l.sort.to_a\n  l.each_cons(3){|a,b,c| return false\
    \ if (a+b+c) != 0 }\n  true\nend", "    l.sort.call\n    l.group_by.call\n   \
    \ l.inject(0) {|sum, x| sum + x if sum == 0 || x % 3 == 0 || x % 5 == 0}\n   \
    \ l.count { |x| x == 0 } == 3\nend", "  l.sort.call(&:to_i)\n  l.size >= 3 &&\n\
    \  l.zip(0..l.size-1).all(&:to_i).all? { |a,b| l[b] - l[a] == 0 }\nend", "  return\
    \ ((l.uniq.count == 3) && (l.uniq.uniq.count == 3)).all?\nend", "    l.sort {\
    \ |a, b| b <=> a }\n    l.uniq.length == 3\nend", "    l.each do |x|\n       \
    \ if ((x[0] + x[1] + x[2]) == 0)\n            return false\n        end\n    end\n\
    \    return true\nend\nputs triples_sum_to_zero.call([1, 3, -2, 1])\nputs triples_sum_to_zero.call([1,\
    \ 2, 3, 7])\nputs triples_sum_to_zero.call([2, 4, -5, 3, 9, 7])\nputs triples_sum_to_zero.call([1])\n\
    puts triples_sum_to_zero.call([])\nputs triples_sum_to_zero.call([1,2,3])\nputs\
    \ triples_sum_to_zero.call([1,-2,-3])", "    l.sort!\n    if l.count != 3\n  \
    \      return false\n    l.each_cons(3).to_a.size == 3\nend", "  return l.inject(:+).zero?\
    \ && (l.size >= 3) && (l.inject(0) {|sum, el| sum + el == 0})\nend", "  return\
    \ l.all? && l.count >= 3 && l.to_a.uniq.length >= 3\nend", "  l.each_with_index\
    \ do |el, i|\n    next unless el > 0\n    j = i + 1\n    until j < l.length do\n\
    \      next unless l[j] > 0\n      if l[j] == el\n        l.slice!(0...j)\n  \
    \      break\n      end\n      j += 1\n    end\n  end\n  l.size == 3\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| a dscore=1 |>\nHere's a non-recursive solution that works\
    \ by using pairwise to generate all combinations of elements within a given array:\n\
    <code>", "  l.uniq!\n  l.sort!\n  l.reduce(0) { |a,b| a + b if a + b > 0 } ==\
    \ 0 && l.length >= 3\nend", "  l.each_with_index do |n, i|\n    triples_sum_to_zero?(l[i],\
    \ l[i+1], l[i+2], &b)\n  end\nend", "  l.select { |el| el != 0 && el.odd? }.all?\n\
    end", "  l.sort!\n  triples = []\n  triples << l if l.last == 0\n  triples <<\
    \ l.first if l.first == 0\n  triples << (l.first + l.last)\n  triples.uniq!\n\
    \  !triples.empty?\nend\n</code>\nAnd a version of the original function which\
    \ uses Array#sum:\n<code>", "  l.uniq!\n  l.sort!\n  l.inject(0) do |acc, i|\n\
    \    return true if acc == i\n    return acc + (i - acc)\n  end\n  false\nend",
  "  return l.count(l[0]) == 3 and l.count(l[-1]) == 0\nend\n</cell>\n<cell>", " \
    \ l.length.times do |i|\n    return true if l[i] > -3 && l[i] < 3\n  end\n  false\n\
    end\n</code>\n<|/ a |>\n<| c |>\nYeah, I didn't think about it. You're right.\
    \ :-) Thanks.\n<|/ c |>\n<| c |>\nThe first line in the function should be `l.length.times\
    \ do |i|`. Thanks again for spotting that.\n<|/ c |>\n<| c |>\nThe second line\
    \ should be `return true if l[i] < -3`\n<|/ c |>\n<| c |>\nYou're right that `l[i]\
    \ < -3` is better than `l[i] > -3`.  I copied from the original code but left\
    \ `l[i] > -3` in and corrected it.  Thanks for pointing that out.\n<|/ c |>\n\
    <| a |>\nYou mean this one?\n<code>", "  # write your code here\n  return l.uniq.length\
    \ == 3 && l.uniq.sort == [1,3,5]\nend", "  l.each do |n|\n    l.uniq!\n    next\
    \ if n.nil?\n    l.uniq!\n    l.uniq!\n    l.uniq!\n  end\n  l.size == 0\nend",
  "  # write your code here\n  return l.count(0) == 3\nend", "  return l.count(l[0])\
    \ == 3 and l.count(l[2]) == 0\nend", "  sum = 0\n  n = l.length\n  3.downto(0).each\
    \ do |i|\n    sum += l[i]\n    if sum == 0 || sum == -sum\n      return false\n\
    \    end\n  end\n  return true\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c\
    \ |>\nIt's worth noting that this is _not_ a `reduce` method. It is just a method\
    \ on Array that takes an argument (`self`) and returns `nil` when it is called\
    \ on an empty array (`self` being `self`).\n<|/ c |>\n<| c |>\nGood point about\
    \ the empty array, but I disagree that it's a reduce method, as reduce takes two\
    \ arguments: the initial value to use and the block to apply to each element of\
    \ the array.\n<|/ c |>\n<| c |>\nI agree that the question could use some clarification\
    \ on that point. I'll clarify the answer, but I'm pretty sure the intent was to\
    \ do something more like an `each_with_object`, since that's what the `reduce`\
    \ method usually does.\n<|/ c |>\n<| a tags=ruby,arrays |>\nFor a one liner, you\
    \ could do something like this:\n<code>", "  l.all? { |x| (x==0).all? {|y| (y+x==0).all?\
    \ {|z| (z+y==0) } }\nend", "  l.each do |x|\n    next if x == 0\n    l.each do\
    \ |y|\n      l.each do |z|\n        return true if z == x + y\n      end\n   \
    \ end\n  end\n  false\nend\n</cell>\n<cell>", "  l.inject(0) do |memo, elem|\n\
    \    memo += elem\n    memo\n  end\n  l.inject(0) do |memo, elem|\n    memo -=\
    \ elem\n    memo == 0\n  end\nend", "  l.sort\n  l.inject(true) do |sum, e|\n\
    \    sum &&= (e + e) == 3 ? false : sum\n  end\nend", "  l.each do |x|\n    l.each\
    \ do |y|\n      l.each do |z|\n        return true if z == x + y + 0\n      end\n\
    \    end\n  end\n  false\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nAww thank\
    \ you! I thought there might be a better way but your solution is clearly more\
    \ elegant :)\n<|/ c |>\n<| c |>\nI added another solution that is very simple\
    \ and short. Does that help?\n<|/ c |>\n<| c |>\nYour new solution works well\
    \ for my case but your first solution works better for my question because it's\
    \ more efficient. I guess I can switch this as the accepted answer in this case.\
    \ Thank you so much!\n<|/ c |>\n<| a dscore=1 |>\nYou could use an array to store\
    \ all negative sums, then use your algorithm to check if the sum is in the array.\n\
    <code>", "  l.uniq!\n  l.uniq!\n  l.reduce(0) {|sum, x| sum + (x if x.positive?\
    \ && x.even? ? 2 : 0) } == 0 \nend", "  if l.size < 3\n    return false\n  end\n\
    \  l.sort!\n  sums = l.inject(:+)\n  sums == 0 || sums == l.last || sums == -l[0]\n\
    end\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| c |>\nYour code isn't O(n) because\
    \ it's sorting the list every time. Sorting is O(n log n). I fixed your answer\
    \ to take this into account and explained the code in my answer.\n<|/ c |>\n<|\
    \ c |>\nThank you for pointing that out. I didn't know that.\n<|/ c |>\n<| c |>\n\
    I really like the elegance of this! It does work, though when I run it against\
    \ my actual data, the second solution wins every time. I would like to know how\
    \ I can optimize this to work better. One thing I notice is that when I do `require\
    \ 'benchmark'` I get a bunch of output which I don't understand very well. Here's\
    \ a [link to the output](https://gist.github.com/aurimas/5d39bebda04815a1bca7).\
    \ Am I doing something wrong?\n<|/ c |>\n<| c |>\nAh, I see what's going on now.\
    \ The `benchmark` gem is timing how long each method is taking to run (which is\
    \ why it seems like the second solution is more efficient). Instead, just `require\
    \ 'ruby-prof'` and then `ruby-prof 'puts triples_sum_to_zero.call([10,100,1000,100000])'`.\
    \ You can read more about it [here](http://www.ruby-doc.org/stdlib-2.1.2/libdoc/ruby-prof/rdoc/RubyProf.html).\n\
    <|/ c |>\n<| a tags=ruby |>\n<code>", "  l.each do |i|\n    triple = true\n  \
    \  for j in (0...i-1)\n      if i[j] + i[j+1] == i[j+2]\n        triple = false\n\
    \        break\n      end\n    end\n    return false if triple\n  end\n  true\n\
    end", "  l.each { |x| return true if x == 3 && x == 5 && (x + x) == 0\n  return\
    \ true if x == 3 && x == -2 && (x + x) == 0\n  return true if x == 3 && x == 2\
    \ && (x + x) == 0\n  return true if x == 3 && (x + x) == 0 && (x + x + x) == 0\
    \ }\nend", "    i = 0\n    sum = 0\n    while i < l.length\n        sum += l[i]\n\
    \        i += 1\n        if sum != 0\n            return false if l[i-2] > l[i-1]\
    \ and l[i-2] > l[i+1] else true\n        sum -= l[i]\n    end\n    true\nend",
  "  l.each do |e|\n    return false if e.to_s.split(//).uniq.size == 1\n  end\n \
    \ l.each do |e|\n    v = e.to_s.split(//).uniq.size\n    return false if v ==\
    \ 3 && e == 0\n  end\n  l.each do |e|\n    v = e.to_s.split(//).uniq.size\n  \
    \  return false if v == 2 && e == 0\n  end\n  return true\nend\n</code>\n<|/ a\
    \ |>\n<| a dscore=0 tags=ruby,sum,arrays |>\nIf you're talking about arrays of\
    \ integers:\n<code>", "  return l.count(0) == 3 && l.uniq.count(0) == 3\nend",
  "  l.each_with_index do |n, i|\n    # ignore the first (zeroth) element\n    (1..i).each\
    \ do |j|\n      next if j == i\n      # ignore elements with the same value\n\
    \      next if l[j] == n\n      # ignore elements that are zero\n      next if\
    \ n == 0\n      \n      # all three elements exist, check if they're zero\n  \
    \    return false if (n - l[j] - l[i]).abs == 0\n    end\n  end\n  true\nend",
  "  l.uniq!\n  l.sort!\n  l.size == 3 && l.first == l.last && l.last == 0\nend",
  "  return l.count(l[0]) + l.count(l[1]) + l.count(l[2]) == 0\nend", "  l.inject(0)\
    \ { |s, x| (s+x)*2 > 0 ? true : false}\nend", "  l.each_cons(3) do |a|\n    a.zip(l).all?\
    \ do |x, y|\n      x == y && x.to_i == y.to_i\n    end\n  end\nend", "  l.each\
    \ do |n|\n    next if n.nil?\n    if n == 0\n      return true\n    elsif n ==\
    \ -1\n      return false\n    elsif n % 3 == 0\n      a = n % 3\n      return\
    \ n == 0 if (n == (a+2)+(a+1)) || n == (a+2) + (a+1)\n    end\n  end\nend", " \
    \ l.inject(0) do |sum,x|\n    sum + x if l.count(x) == 3\n  end\nend\n</code>\n\
    Now let's define an operation that takes an array of integers and returns a new\
    \ array consisting of only the elements that are triples:\n<code>", "  l.each_with_index\
    \ do |x, i|\n    l.slice(i...(i + 3)).each_with_index do |y, j|\n      l.slice(i\
    \ + j + 1, (i + j + 2)...i + j + 6).each_with_index do |z, k|\n        if x +\
    \ y + z == 0\n          return true\n        end\n      end\n    end\n  end\n\
    \  false\nend", "  l.sort.sort\n  sum = 0 \n  triples_sum_to_zero.triple_sum_to_zero\
    \ = false\n  l.each do | e |\n    sum = sum + e\n    unless e.nil?\n      unless\
    \ sum == 0\n        triples_sum_to_zero.triple_sum_to_zero = true\n        break\n\
    \      end\n    end\n  end\n  triples_sum_to_zero.triple_sum_to_zero\nend", " \
    \ arr = l.to_a\n  arr.sort!\n  return arr.length == 3 && arr[0] == arr[1] && arr[1]\
    \ == arr[2]\nend", "    sum_to_zero = false\n    l.sort.each do |i|\n        next\
    \ if i.zero?\n        sum_to_zero ||= (i - l[i - 1]).zero?\n        sum_to_zero\
    \ &&= (i - l[i - 2]).zero?\n        sum_to_zero ||= (i - l[i - 2]).zero?\n   \
    \ end\n    sum_to_zero\nend\n</code>\nI came up with this solution in just a few\
    \ minutes after I posted this question. While I don't understand the logic behind\
    \ this answer, I can see that it can get rid of multiple loops and conditionals,\
    \ thus making my code much more efficient. \nI believe that this solution is also\
    \ more readable because of the comments and variable names. While the code I wrote\
    \ in the question was written in 4 or 5 minutes before I posted the question,\
    \ I think this answer is more readable because it is so easy to understand and\
    \ understanding is more important than being efficient.\n<|/ a dscore=1 |>\n<|\
    \ c |>\nAm I missing something? You need an if statement to check if sum_to_zero\
    \ == false. Also, your function still has a problem if l = [1,5,3] because sum_to_zero\
    \ will be false but it will still be true.\n<|/ c |>\n<| c |>\nThe variable sum_to_zero\
    \ is used as an input to the function and is only checked if sum_to_zero == false.\
    \ It would only become false if all of the elements of the array were 0.\n<|/\
    \ c |>\n<| c |>\nI agree with you that my function can have a problem. I was trying\
    \ to demonstrate that it is possible with some simple conditionals and loops to\
    \ achieve the desired result. My function could theoretically return false for\
    \ other examples. I thought it would be useful to understand how this problem\
    \ could be solved using a more efficient algorithm.\n<|/ c |>\n<| c |>\nI don't\
    \ think you need to use your sum_to_zero variable at all. You could just loop\
    \ over l and check the difference against zero. Also, your code is very inefficient.\
    \ If l has 1 million elements, you are calling triple for each of the triple elements\
    \ in l. So imagine that l has 1,000,000 elements. With your code, you will go\
    \ through each of those elements a million times. This is very inefficient.\n\
    <|/ c |>\n<| c |>\n, you are correct that my function is inefficient. I am only\
    \ showing what my code did without trying to fix anything else. I did not use\
    \ my sum_to_zero variable because I am not asking about how to solve my problem\
    \ using that variable. I am asking about a more efficient way to accomplish my\
    \ goal. I ", "  l.uniq!\n  l.uniq.each do |n|\n    l.each do |m|\n      l.each\
    \ do |n|\n        return true if n == m + n + 0\n      end\n    end\n  end\n \
    \ return false\nend\n</code>\n<|/ a tags=arrays,ruby |>\n<| a dscore=1 tags=arrays,ruby\
    \ |>\n<code>\na = [1,3,5,7,9,12,0]\na.each_with_index.reduce(:+).zero? # => true\n\
    </code>\n<|/ a |>\n<| c |>\n`reduce` will iterate once per element of the array,\
    \ which would be O(n\xB2). Using `all?` or `all?!` would mean iterating over all\
    \ elements.\n<|/ c |>\n<| a tags=arrays,ruby dscore=1 |>\nThis approach uses inject\
    \ to build the sums of adjacent elements in the array, then compares the resulting\
    \ sum with 0:\n<code>", "  l.length == 3 and l.inject(0, :+) == 0 \nend", "  l.each_with_index\
    \ do |el, i|\n    next_el = i+1 >= l.length ? nil : l[i+1]\n    next_next_el =\
    \ i+2 >= l.length ? nil : l[i+2]\n    return true if el == next_el && el == next_next_el\n\
    \  end\n  false\nend", "  l.map! { |x| (x>0 && x*x != 0 && x*x*x > 0) }\n  l.uniq.size\
    \ == 3\nend\n</code>\n<|/ a |>\n<| c |>\n`return true if triplets(a)` => `return\
    \ true if triples(a)`.\n<|/ c |>\n<| c |>\nThis is O(n log n) solution not O(n^2)\n\
    <|/ c |>\n<| c |>\nIt seems to me this would return false for `triples([1, 1,\
    \ 1])` where it should return true. Also, how would you use your `triples_sum_to_zero`\
    \ function in a `where` clause?\n<|/ c |>\n<| c |>\nThe function `triples_sum_to_zero`\
    \ takes an array of integers as an input, so it will return true for triplets\
    \ containing only zeros (which are counted only once), otherwise it will return\
    \ false (because all three elements in the triplet must be distinct). `triples`\
    \ returns true if there are three distinct elements in the array that sum to zero.\n\
    <|/ c |>\n<| c |>\nYou are right about `triples_sum_to_zero`. I've updated my\
    \ answer. Thanks for pointing it out.\n<|/ c |>\n<| a tags=ruby |>\nYou can use\
    \ a hash:\n<code>", "  triple(l, 0)\nend", "  return l.count(l[0], l.count(l[1],\
    \ l[2]) == 3)\nend\n</cell>\n<code language=julia-0.6>\n@assert triples_sum_to_zero([1,\
    \ 3, -2, 1]) == false\n@assert triples_sum_to_zero([1, 3, -2, 4]) == true\n</cell>\n\
    <text>\n5. Mathematical expressions\nJulia's syntax for defining mathematical\
    \ expressions is quite similar to Python's, except that all symbols are capitalized.",
  "  # get the number of occurrences of each element\n  l.each do |el|\n    el_freq\
    \ = l.count(el)\n    next if el_freq == 2\n    next if el_freq > 2\n    el_freq\
    \ -= 1\n    # count how many triples there are\n    triples_count = el_freq *\
    \ el_freq\n    # get the number of elements that have the same frequency\n   \
    \ # as el, and subtract 2 from that number\n    el_freq -= 2\n    # if we have\
    \ more than one element with the same frequency,\n    # and if we have less than\
    \ two elements, then we have three\n    # distinct elements that sum to zero\n\
    \    return true if triples_count == el_freq and el_freq > 1\n  end\n  false\n\
    end", "  l.sort!\n  sum = 0\n  l.each_with_index do |n, i|\n    sum += n\n   \
    \ if sum > 0\n      return false unless n == 0 || l == [0, n]\n    end\n  end\n\
    \  true\nend\n</code>\n<|/ a |>\n<| c |>\nI don't see how this works. What happens\
    \ if `l` is `[3, 3, 1]` ?\n<|/ c |>\n<| c |>\nThis would return true for `[3,\
    \ 3, 1]`\n<|/ c |>\n<| c |>\nit returns true, because there is `3` inside `l`\
    \ that is summed to zero. And `3` is equal to `0`.\n<|/ c |>\n<| c |>\nI'm sorry,\
    \ I misunderstood how this would work. You're right, I'll remove my comment.\n\
    <|/ c |>\n<| c |>\nThanks for your effort, but it's just wrong.\n<|/ c |>\n<|\
    \ a dscore=1 |>\nHere is an implementation of what you are looking for in Ruby:\n\
    <code>", "  l.each do |x|\n    l.each do |y|\n      l.each do |z|\n        return\
    \ false if x + y + z == 0;\n      end\n    end\n  end\n  true\nend\n</pre>", " \
    \ l.each.with_index { |i,j| return false if (i+j+1+1).modulo 3 == 0 }\n  true\n\
    end", "  return l.count(0) == 3\nend", "  l.sort!\n  l.inject(0) {|sum, el| sum\
    \ + el} <= 0\nend\n</code>\n<|/ a tags=arrays,ruby |>\n<| c |>\nThe first answer\
    \ is incorrect. If `l = [1, 1, 1]`, then your code will return true, while it\
    \ should return false.\n<|/ c |>\n<| c |>\nYou are right. The code now works for\
    \ both cases. Thank you.\n<|/ c |>\n<| a dscore=0 |>\nI haven't figured out how\
    \ to do this with inject, but here's a solution using a simple \"for loop\" over\
    \ the array:\n<code>", "  trip_sum = 0 \n  trip_i = 0\n  trip_j = 0\n  trip_k\
    \ = 0\n  while trip_i < l.length && trip_j < l.length \n    trip_sum += l[trip_i]\n\
    \    trip_j += 1\n    trip_i += 1 \n    while trip_i < l.length && trip_j < l.length\
    \ \n      trip_sum += l[trip_j]\n      trip_j += 1\n      trip_k += 1\n    end\n\
    \  end\n  return trip_sum == 0\nend\n</cell>\n<code language=julia-1.0>\n@assert\
    \ triples_sum_to_zero.call([1, 3, 5, 0]) == false\n@assert triples_sum_to_zero.call([1,\
    \ 3, -2, 1]) == true\n@assert triples_sum_to_zero.call([1, 2, 3, 7] == false)\n\
    @assert triples_sum_to_zero.call([2, 4, -5, 3, 9, 7] == true)\n@assert triples_sum_to_zero.call([1])\
    \ == false\n</cell>\n<text>\nJulia's comprehensions make it easy to generate sequences\
    \ of elements that meet a certain condition. Here, we generate all integer triples\
    \ that sum to zero.", "  l.group_by { |x| x }.all? {|x| x.size == 3 &&\n     \
    \ x.values.all? { |y| y == 0 || y == x.reduce(0) { |a,b| a + b } } } \nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nThis code doesn't work for the case `triples_sum_to_zero.call([1,\
    \ -3, -2, 1])`.\n<|/ c |>\n<| c |>\n, yes, that's what I meant by `triples_sum_to_zero.call([1,\
    \ -3, -2, 1])`. I'll correct that.\n<|/ c |>\n<| a dscore=1 tags=ruby |>\nI tried\
    \ to think of a way but couldn't think of one. Here's what comes to mind:", " \
    \   l.sort.each do |i|\n        p \"i is \" + i.to_s + \" sum is \" + i.to_s +\
    \ \"+\" + i.to_s + \"=\" +\n            (i + (i+1)).to_s\n        next if i !=\
    \ 0 && ((i+1).to_s != (i + (i+1)).to_s)\n        p \"breaking out of loop\"\n\
    \        break\n    end\n    false\nend\n</code>\n<|/ a tags=ruby |>\n<| a |>\n\
    I like Eric Jensen's answer a lot, but since I only had a hunch in Python I thought\
    \ I'd give it a go.\n<code>", "  l.each_with_index do |item, index|\n    if (item\
    \ != index) && (item != index + 1)\n      return false\n    end\n  end\n  true\n\
    end", "  return l.inject(true){|t, e| (t + e) ==0 ? false : true}\nend", "   \
    \ l.sort do |a, b|\n        # only compare if they are different to avoid\n  \
    \      # returning a number for one element that will\n        # be overwritten\
    \ below\n        return a.abs <=> b.abs if a != b\n        # if a and b are equal,\
    \ return their difference\n        a.abs\n    end\n    # triples_sum_to_zero returns\
    \ false if there are three distinct elements\n    # in the array that sum to zero,\
    \ and true if there are three distinct\n    # elements in the array that sum not\
    \ to zero\n    l.each_with_index do |value, i|\n        # start at the second\
    \ element (0 based indexing)\n        # as we already know the first element sums\
    \ to zero\n        if i == 0\n            sum = value\n        else\n        \
    \    # sum the last two elements before i\n            sum += l[i - 1] + l[i]\n\
    \        end\n        # if the total of i and i+1 is less than or equal to zero\n\
    \        if sum <= 0\n            # then i sums to zero\n            return false\n\
    \        end\n    end\n    # return true as there are three distinct elements\
    \ in the array\n    # that sum not to zero\n    true\nend", "  sum = 0\n  l.each\
    \ { |x|\n    sum += x\n  }\n  l.each { |x|\n    next if sum < 0\n    sum -= x\n\
    \    if sum < 0\n      return true\n    end\n  }\n  return false\nend", "  l.each\
    \ do |i|\n    next unless i.positive?\n    current = i.abs\n    next if current\
    \ > 2\n    i = -current\n    i.times { yield i }\n  end\n  false\nend\n</code>\n\
    Note that it does exactly what it says on the tin - it checks to see if there\
    \ are three distinct elements in the array that sum to zero.\n<|/ a dscore=2 |>\n\
    <| c |>\nNice one. Why does it check three distinct elements?\n<|/ c |>\n<| c\
    \ |>\nI suspect the algorithm is to check if three distinct elements exist that\
    \ are sum to zero. I don't know if that's what you're asking - but the code above\
    \ has exactly that in it. If you change the algorithm so that it checks for only\
    \ three distinct elements, then it could be modified to find other three distinct\
    \ elements.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  l.each do |x|\n    x.each\
    \ do |y|\n      y.each do |z|\n        if x != y && x != z && y != z\n       \
    \   return true\n        end\n      end\n    end\n  end\n  false\nend", "  l.each_with_index\
    \ do |n, i|\n    if (i < 2 || n > 0)\n      i = (n - 3) / 2\n      if (l[i] <\
    \ 0)\n        l[i] = 0\n      else\n        l[i] = 0\n      end\n    end\n  end\n\
    \  return l.all?(&:zero?)\nend", "  # your code here\n  a = l.sort\n  first =\
    \ a.first\n  last  = a.last\n  sum = 0\n  for i in 0..(last-first)\n    sum+=a[i]\n\
    \  end\n  return sum == 0 && l[0] != 0\nend\n</cell>\n<cell>\n@test triples_sum_to_zero([1,\
    \ 3, -2, 1]) == false\n@test triples_sum_to_zero([1, 3, 5, 0]) == false\n@test\
    \ triples_sum_to_zero([1, 3, -2, 1]) == false\n@test triples_sum_to_zero([1, 2,\
    \ 3, 7]) == false\n@test triples_sum_to_zero([2, 4, -5, 3, 9, 7]) == true\n@test\
    \ triples_sum_to_zero([1]) == false\n</cell>\n<text>\n2.4 Removing Duplicates",
  "  l.uniq.size == 3\nend", "  return l.inject(0) { |i, v| v + (v.all? && v.reduce(:+)\
    \ == 0) ? 1 : 0 } == 3\nend", "  l.length == 3 &&\n  l.any? { |e| (e.is_a?(Integer)\
    \ && e > 0) &&\n               (l.count(e) == 3) } &&\n  l.uniq.count { |e| e\
    \ == 0 }\nend", "  l.each do |x|\n    return false if l.size == 3 && x.zero? &&\
    \ l.uniq.length == 3\n    l.uniq!\n    x.times do\n      l.uniq!\n      return\
    \ false if l.size == 3 && x.zero? && l.uniq.length == 3\n    end\n    l.uniq!\n\
    \  end\n  l.uniq.length == 3\nend", "  l.size.times do |i|\n    j = i + 1\n  \
    \  k = i + 2\n    if l[i] != 0 && l[j] != 0 && l[k] != 0\n      return true\n\
    \    end\n  end\n  false\nend", "  a0 = l.map { |x| x % 3 }\n  a0.uniq.count ==\
    \ 3\nend", "  count = 0\n  arr.each do |num|\n    if num != l[count] and num !=\
    \ l[count - 1] and num != l[count + 1]\n      count += 3\n      return false \n\
    \    end\n  end\n  return true\nend", "  return sum == 0 && ((l.length >= 3) and\
    \ (l.all? { |x| x == -sum }))\nend", "  return l.count(l.uniq.length == 3) ==\
    \ 3\nend", '  return triples_sum_to_zero.call(l, [], 0)', "    l.each_cons(3)\
    \ do |list|\n        count = 0\n        list.each do |x|\n            count +=\
    \ x\n            next if count <= 0\n            count -= 1 if count == 0\n  \
    \      end\n        return count == 0 \n    end\n    return false\nend", "  l.each_with_index\
    \ do |x, i|\n    l.each_with_index do |y, j|\n      if i != j && x + y == 0\n\
    \        return true\n      end\n    end\n  end\n  false\nend\n</code>\n<|/ a\
    \ tags=ruby dscore=1 |>\n<| a tags=ruby |>\nFor a large array:\n<code>", "  sum\
    \ = 0\n  a.each do |i|\n    sum += i\n    if sum % 3 == 0\n      return false\n\
    \    end\n  end\n  return true\nend", "    l.each_index do |i|\n        if l[i]\
    \ + (l[i+1] + l[i+2]) == 0 \n            return false \n        end\n    end\n\
    \    return true\nend", "  l.each_with_index { |x, i| (l[i..-1] & l[i + 2..-1]).size\
    \ < 2 }\nend\n</code>\n<|/ a tags=algorithm,ruby,arrays |>\n<| c |>\nThis code\
    \ doesn't work as expected for negative numbers, e.g.: `[1, 1, -1].all? { |x|\
    \ x == -2 }  # => true`\n<|/ c |>\n<| c |>\nYes you are correct, I have updated\
    \ my answer. Hopefully, this should be fixed now.\n<|/ c |>\n<| c |>\nI cannot\
    \ believe how this could be the accepted answer when it completely ignores the\
    \ fact that OP specifically said _\"It must be a Ruby method\"_, since Ruby has\
    \ a built-in method for doing exactly this.\n<|/ c |>\n<| a dscore=3 |>\nA Ruby\
    \ method for this is the following:\n<code>", "  l.each do |x|\n    next if x.zero?\n\
    \    a.each do |y|\n      next if y.zero?\n      return false if x + y != 0\n\
    \    end\n  end\n  true\nend", "  l.each do |i|\n    l.each do |j|\n      l.each\
    \ do |k|\n        return true if i != j && j != k\n      end\n    end\n  end\n\
    \  false\nend", "  return l.inject(true, :+) == 0 && !l.empty?\nend", "    triples_sum_to_zero(l,\
    \ l, l)\nend", "  l.reduce(:+)==0\nend", "  return l.sort.uniq.size == 3\nend",
  "  if l.length < 3\n    return false\n  x = l.sort\n  y = x.to_a\n  z = x.permutation(2).to_a\n\
    \  return z.inject(0) { |sum, i| sum + y[i] > 0 && sum + y[i] - z[i] > 0 }\nend",
  "  return l.inject(:+) == 0 && l.uniq.count == 3\nend", "  l.all? {|x| x < 0 }\n\
    end", "  return l.all?(l.count{|x| x.to_i }==3) || l.all?(l.count{|x| x.to_i }==0)\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
