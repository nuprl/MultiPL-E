name: HumanEval_153_Strongest_Extension
language: rb
prompt: "# You will be given the name of a class (a string) and an array of extensions.\n\
  # The extensions are to be used to load additional classes to the class. The\n#\
  \ strength of the extension is as follows: Let CAP be the number of the uppercase\n\
  # letters in the extension's name, and let SM be the number of lowercase letters\
  \ \n# in the extension's name, the strength is given by the fraction CAP - SM. \n\
  # You should find the strongest extension and return a string in this \n# format:\
  \ ClassName.StrongestExtensionName.\n# If there are two or more extensions with\
  \ the same strength, you should\n# choose the one that comes first in the array.\n\
  # For example, if you are given \"Slices\" as the class and an array of the\n# extensions:\
  \ ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n# return 'Slices.SErviNGSliCes'\
  \ since 'SErviNGSliCes' is the strongest extension \n# (its strength is -1).\n#\
  \ Example:\n# >>> Strongest_Extension.call(\"my_class\", [\"AA\", \"Be\", \"CC\"\
  ])\n# \"my_class.AA\"\ndef Strongest_Extension(class_name, extensions)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_Strongest_Extension\n\
  \    candidate = method(:Strongest_Extension)\n    assert_equal(\"Watashi.eIGHt8OKe\"\
  , candidate.call(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]))\n    assert_equal(\"\
  Boku123.YEs.WeCaNe\", candidate.call(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\"\
  , \"32145tggg\"]))\n    assert_equal(\"__YESIMHERE.NuLl__\", candidate.call(\"__YESIMHERE\"\
  , [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]))\n\
  \    assert_equal(\"K.TAR\", candidate.call(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
  , \"cosSo\"]))\n    assert_equal(\"__HAHA.123\", candidate.call(\"__HAHA\", [\"\
  Tab\", \"123\", \"781345\", \"-_-\"]))\n    assert_equal(\"YameRore.okIWILL123\"\
  , candidate.call(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
  , \"-_-\"]))\n    assert_equal(\"finNNalLLly.WoW\", candidate.call(\"finNNalLLly\"\
  , [\"Die\", \"NowW\", \"Wow\", \"WoW\"]))\n    assert_equal(\"_.Bb\", candidate.call(\"\
  _\", [\"Bb\", \"91245\"]))\n    assert_equal(\"Sp.671235\", candidate.call(\"Sp\"\
  , [\"671235\", \"Bb\"]))\n  end\nend\n"
completions: ["  # Write your code here.\n  extension_strength = Array.new\n  extensions.each\
    \ do |extension|\n    extension_strength << extension.index(class_name.upcase)\
    \ - extension.index(class_name.downcase)\n  end\n  \n  strongest_extension = extension_strength.max\
    \ { |x, y| x <=> y }\n  return class_name + \".\" + strongest_extension\nend",
  "  # Initialize your data structure here.\n  \n  strongest_extension = ''\n  \n\
    \  extension_strength = extension_strength_calculator(extensions)\n  \n  strongest_extension\
    \ = class_name + strongest_extension_calculator(extensions, extension_strength)\n\
    \  \n  return strongest_extension\nend", "  extensions.sort_by { |x| -x.count(CAP)\
    \ }\nend", "  extensions_count = extensions.length\n  \n  extensions_map = {}\n\
    \  extensions_count.times { |i|\n    extensions_map[\"#{class_name}.#{extensions[i]}\"\
    .to_sym] = -1\n  }\n  \n  extensions_count.times do |i|\n    extensions_map[\"\
    #{class_name}.#{extensions[i]}\".to_sym] = i\n  end", "  case extensions.size\
    \ \n  when 0\n  then \"\"\n  when 1\n  then extensions.first\n  else\n    strength\
    \ = extension_strength(extensions.last) - extension_strength(extensions.first)\n\
    \    if strength == 0\n    then extensions.last\n    else extensions.find { |e|\
    \ extension_strength(e) == strength }.last\n    end\n  end\nend\n</code>\nAnd\
    \ here's the test cases:\n<code>", "\tStrongest_Strength = 0\n\t\n\tfor i in 0..(extensions.length\
    \ - 1)\n\t    if extensions[i].length < Strongest_Strength\n\t        Strongest_Strength\
    \ = extensions[i].length\n\t    end\n\tend\n\t\n\tputs class_name\n\tputs Strongest_Strength.to_s\n\
    \t\n\tstrongest = nil\n\tfor i in 0..(extensions.length - 1)\n\t    if extensions[i].length\
    \ > Strongest_Strength\n\t        strongest = extensions[i]\n\t    end\n\tend\n\
    \t\n\treturn strongest.to_s\nend", "  extensions = extensions.map { |e| e.gsub(/[A-Z]/)\
    \ }\n  extensions.sort.last.upcase\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2\
    \ |>\nThis is actually a very good question and I like your solutions. I wanted\
    \ to point out that you can also use an extension method (if you don't mind a\
    \ slight bit of overhead in each class using it). Here's a solution that uses\
    \ this method, but I agree with you on the \"not worth the extra effort\" part.\
    \ \n<code>", "  extensions_arr = extensions.sort\n  extensions_arr.last.last\n\
    end\n</cell>\n<code language=julia-0.6>", "    \n    if extensions.all? { |e|\
    \ e.split('').size > 1 }\n        extensions = extensions.sort_by { |e| e.split('').size\
    \ }\n        extensions.shift if extensions.first.split('').size != 0\n    end\n\
    \    return class_name.to_s + extensions[extensions.size - 1]\nend\n</cell>\n\
    <cell>", "  return class_name + (extensions[0..(extensions.size - 1).grep(/(?<=\\\
    d)[A-Z]/) - \n                                extensions[0..(extensions.size -\
    \ 1).grep(/(?<=\\d)[a-z]/)].sum]) \nend\n</code>\nSolution 3\n<code>", "  extensions.sort!\n\
    \  strongest_extension = nil\n  extensions.each do |extension|\n    extension_len\
    \ = extension.length\n    if extension_len == 0\n      next\n    elsif extension_len\
    \ == 1\n      break unless strongest_extension\n      strongest_extension = extension\n\
    \    else\n      if strongest_extension.split(\".\").length < extension_len\n\
    \        strongest_extension = extension\n      end\n    end\n  end\n  return\
    \ class_name.constantize.const_get(strongest_extension.split(\".\").first).constantize\n\
    end\n</code>\n<|/ a tags=ruby,constants dscore=2 |>\n<| c |>\nI wouldn't recommend\
    \ using these examples in real code; they're more of a proof of concept. `Class#const_get`\
    \ was introduced way back in 1.9, while `Class#constants` was introduced in 1.8.7.\
    \ Neither have had much attention in recent years.\n<|/ c |>\n<| a tags=ruby,constants\
    \ |>\n<code>", "\t\n\tnew_str = \"\"\n\t\n\tfor i in range(0, len(extensions))\
    \ \n\t\t\n\t\t# check if the current extension is the strongest one\n\t\tcurrent_extension\
    \ = extensions[i]\n\t\tif new_str.length > 0\n\t\t\n\t\t\tif CAP(current_extension,\
    \ CAP(new_str)) < SM(current_extension, SM(new_str))\n\t\t\t\tnew_str = current_extension\n\
    \t\t\t\t\n\t\t\telse \n\t\t\t\t# if CAP is higher than SM, the current extension\
    \ is \n\t\t\t\t# higher than the strongest one, so it must be replaced\n\t\t\t\
    \tnew_str = current_extension\n\t\t\t\t\n\t\t\t\tbreak\n\t\t\t\n\t\telse \n\t\t\
    \t\n\t\t\tif CAP(current_extension, CAP(new_str)) < SM(current_extension, SM(new_str))\n\
    \t\t\t\tnew_str = current_extension\n\t\t\t\t\n\t\t\telse \n\t\t\t\tnew_str =\
    \ current_extension\n\t\t\t\tbreak\n\t\t\t\n\treturn new_str\n    ", "    # @param\
    \ class_name:  The name of the class.\n    # @param extensions:  An array of extensions.\n\
    \    # @return:  The strongest extension of the given class.\n    # @postcondition:\
    \  The given class name has the same number of uppercase\n    #              \
    \ letters as the extensions array has number of lowercase letters.\n    # @postcondition:\
    \  The given class name has the same number of lowercase letters\n    #      \
    \         as the extensions array has number of uppercase letters.\n    # @postcondition:\
    \  The given class name has the same number of uppercase\n    #              \
    \ letters as the extensions array has number of uppercase letters.\n    # @postcondition:\
    \  If there are two or more extensions with the same strength, \n    #       \
    \        you should choose the one that comes first in the array.\n    \n    if\
    \ extensions.size < 2\n        raise NoExtensionsException.new(class_name)\n \
    \   \n    extensions.uniq.sort! { |x,y| x.to_i == y.to_i }\n    \n    strength_min\
    \ = 0\n    strength_max = 0\n    \n    extensions.each do |ext|\n        strength_min\
    \ = strength_min if ext.to_i.to_s <= strength_max\n        strength_max = ext.to_i\n\
    \    end\n    \n    extensions.select { |ext| ext.to_i.to_s <= strength_min }\n\
    end", "  extensions_set = Set.new\n  extensions.each { |e| extensions_set << e.downcase\
    \ }\n  \n  extensions_set.each do |extension|\n    index = extension_position(class_name,\
    \ extension)\n    return class_name + \".\" + extensions[(index+1)..-1].join(\"\
    .\") if strength(index) >= 0\n  end\n  \n  raise \"Could not find strongest extension!\"\
    \nend", "    \n    extension_strongest = []", "  strength = extensions.length\n\
    \  extensions.each { |e| strength += (e.to_s[0]..e.to_s[e.to_s.length-1]).count\
    \ }\n  strength / extensions.length\nend", "  strongest_extension = nil\n  strength_of_extension\
    \ = 0\n  \n  extensions.each do |extension|\n    strength_of_extension = extension.upcase.count\
    \ - extension.downcase.count\n    strongest_extension = class_name + extension\
    \ if strength_of_extension > strength_of_extension\n  end\n  return strongest_extension\n\
    end\n</cell>\n<text>\nNow you can use the Strongest_Extension function in a single\
    \ line of code!", "  extensions_with_strength = {}\n  extensions_with_strength[extensions[0]]\
    \ = -1\n  \n  # Fill out each extension and its strength\n  ext_strength = extensions_with_strength[extensions[0]]\n\
    \  for ext_name in extensions[1..-1] do\n    if ext_strength < extensions_with_strength[ext_name]\
    \ then\n      extensions_with_strength[ext_name] = ext_strength\n    end\n  end\n\
    \  \n  # Choose the strongest extension from the hash with the minimum strength\n\
    \  extension = nil\n  \n  for ext_name, strength in pairs(extensions_with_strength)\
    \ do\n    ext_class = class_name .. \".\" .. ext_name\n    if strength < extension_with_strength[ext_name]\
    \ then\n      extension = ext_class\n      break\n    end\n  end\n  \n  if extension\
    \ == nil then\n    # no extension with smallest strength\n    return nil\n  end\n\
    \  \n  return extension\nend", "  strength = -1 # default strength to -1\n  extension_count\
    \ = extensions.size\n  # if there are more than one extensions with the same strongest,\
    \ choose \n  # the one that comes first in the array.\n  (0...extension_count).each\
    \ do |i|\n    \n    # get the name of the extension\n    extension_name = extensions[i]\n\
    \    \n    # get the number of upper case letters in the extension's name\n  \
    \  capitals = extension_name.length\n    \n    # get the number of lower case\
    \ letters in the extension's name\n    lowercases = extension_name.count(\"a\"\
    )\n    \n    # find the fraction CAP - SM\n    fraction = capitals - lowercases\n\
    \    \n    # if the fraction is > 0 and the strongest strength hasn't been found\
    \ yet,\n    # store the new strongest\n    if fraction >0 && strength == -1\n\
    \      strength = fraction\n    end\n  end\n  \n  # return the string with the\
    \ extension with the highest strength\n  return class_name + \".\" + extensions[strength]\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks a lot. Your answer is awesome\
    \ but i would like to add that i didnt understand why you used this (0...extension_count).\
    \ You used (0...extension_count).each do |i| and i still dont really get it. The\
    \ explanation would be greatly appreciated if you could explain.\n<|/ c |>\n<|\
    \ c |>\nIt just loops through the `(0...extension_count)` range. More info [here](http://ruby-doc.org/core-2.2.3/Range.html)\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>", "  # TODO: Write your code here.\n  return\
    \ className\nend\n</pre>\n<p><strong>Test your solution</strong></p>\n<p><u>Start\
    \ with your function and see if it works.</u></p>\n<pre>\nruby &lt;&lt; '\nrequire\
    \ \"test_helper\"\nrequire \"strongest_extension\"", "  # Write your code here.\n\
    \  extension_length = extensions.length\n  classed = extensions[0..extension_length-1].inject({},\
    \ :merge).keys\n  classes = classed.map{|a| class_name.split(\".\").last.downcase.pluralize.underscore}.uniq\n\
    \  classes.sort.reverse.inject(class_name.split(\".\").last.downcase.pluralize.underscore,\
    \ :+).to_s\nend", "  extension_set = extension_array_to_set(extensions)\n  extension_hash\
    \ = hash_array_to_hash(extension_set)\n  extension_hash.sort!", "  extensions_count\
    \ = extensions.count\n  \n  # initialize an empty array\n  extension_strength\
    \ = []\n  \n  # loop through the array and calculate the strength based on \n\
    \  # the number of upper case letters and lower case letters\n  \n  # count the\
    \ number of upper case letters\n  uppercase_count = 0\n  for e in extensions\n\
    \    uppercase_count += e.count(\"A\") - e.count(\"a\")\n  end", "  extension_strongest\
    \ = extensions[0]\n  extension_strength = extensions[0].split('')\n  extensions.each\
    \ do |extension|\n    extension_strength = extension.split('')\n    extension_strength.each\
    \ do |char|\n      if char.upcase == extension_strongest.upcase\n        extension_strength.delete_at(extension_strength.index(char))\n\
    \        break\n      end\n    end\n    extension_strongest = extension_strength.join\n\
    \  end\n  return class_name.constantize.const_get(extension_strongest)\nend\n\
    </code>\n<|/ a tags=ruby,constants,arrays,class dscore=1 |>\n<| c |>\nThanks so\
    \ much for the help with this - I really appreciate it! I am new to ruby, so my\
    \ code was messy. I'll try your suggestions and report back. Thanks again!\n<|/\
    \ c |>\n<| c |>\nI edited my original question and added what I have so far (still\
    \ need help). Thanks so much for the help with the original code and the suggestions\
    \ so far!\n<|/ c |>\n<| c |>\nI just added the method which returns the strongest\
    \ extension. Hope this helps. :)\n<|/ c |>\n<| c |>\nThanks for the help! I've\
    \ been trying to implement your code into my code and it doesn't work very well\
    \ yet. I'm still having a bit of trouble with it though. I've made some changes\
    \ and added comments above, can you take a look? Thanks!\n<|/ c |>\n<| c |>\n\
    Okay, let me try it. In your last edit you have a different method which returns\
    \ an array of the extension names. You should get the index of the strongest extension\
    \ and return that array item. Let me know if that works.\n<|/ c |>\n<| a |>\n\
    Here's a fairly simple solution. There are probably better ways to solve your\
    \ problem.\n<code>", "\textensions.sort!\n\textensions.reverse!\n\tstrength =\
    \ nil\n\t\n\tindex = 0\n\twhile index<extensions.length do\n\t\tletters = extensions[index].length\n\
    \t\tletters_upper = 0\n\t\tletters_lower = 0\n\t\t\n\t\tfor i in 1...letters do\n\
    \t\t\tif letters_upper < i \n\t\t\t\tletters_upper += letters[i].upcase!\n\t\t\
    \telse\n\t\t\t\tletters_lower += letters[i].downcase!\n\t\t\tend\n\t\tend\n\t\t\
    \n\t\tif letters_upper == letters_lower \n\t\t\tstrength = nil\n\t\telse\n\t\t\
    \tstrength = letters_upper-letters_lower\n\t\tend\n\t\t\n\t\tbreak if strength\
    \ == (-1*letters_upper-letters_lower)\n\t\t\n\t\tindex += 1\n\tend\n\t\n\tif strength\
    \ == nil \n\t\textensions.reverse!\n\t\textensions.sort!\n\t\tstrength = nil\n\
    \t\t\n\t\tindex = 0\n\t\twhile index<extensions.length do\n\t\t\tletters = extensions[index].length\n\
    \t\t\tletters_upper = 0\n\t\t\tletters_lower = 0\n\t\t\t\n\t\t\tfor i in 1...letters\
    \ do\n\t\t\t\tif letters_upper < i \n\t\t\t\t\tletters_upper += letters[i].upcase!\n\
    \t\t\t\telse\n\t\t\t\t\tletters_lower += letters[i].downcase!\n\t\t\t\tend\n\t\
    \t\tend\n\t\t\t\n\t\t\tif letters_upper == letters_lower \n\t\t\t\tstrength =\
    \ nil\n\t\t\telse\n\t\t\t\tstrength = letters_upper-letters_lower\n\t\t\tend\n\
    \t\t\t\n\t\t\tbreak if strength == (-1*letters_upper-letters_lower)\n\t\t\t\n\t\
    \t\tindex += 1\n\t\tend\n\t\t\n\t\tif strength == nil \n\t\t\textensions.reverse!\n\
    \t\t\textensions.sort!\n\t\t\tstrength = nil\n\t\t\t\n\t\t\tindex = 0\n\t\t\t\
    while index<extensions.length do\n\t\t\t\tletters = extensions[index].length\n\
    \t\t\t\tletters_upper = 0\n\t\t\t\tletters_lower = 0\n\t\t\t\t\n\t\t\t\tfor i\
    \ in 1...letters do\n\t\t\t\t\tif letters_upper < i \n\t\t\t\t\t\tletters_upper\
    \ += letters[i].upcase!\n\t\t\t\t\telse\n\t\t\t\t\t\tletters_lower += letters[i].downcase!\n\
    \t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tif letters_upper == letters_lower\
    \ \n\t\t\t\t\tstrength = nil\n\t\t\t\telse\n\t\t\t\t\tstrength = letters_upper-letters_lower\n\
    \t\t\t\tend\n\t\t\t\t\n\t\t\t\tbreak if strength == (-1*letters_upper-letters_lower)\n\
    \t\t\t\t\n\t\t\t\tindex += 1\n\t\t\tend\n\t\t\t\n\t\t\tif strength == nil \n\t\
    \t\t\textensions.reverse!\n\t\t\t\textensions.sort!\n\t\t\t\t", "  name_split\
    \ = class_name.split('.') # split string into name and extensions\n  extension_split\
    \ = name_split[-1].split(//) # split extensions from name\n  \n  # get the number\
    \ of uppercase\n  cap = extension_split.map(&:size).min\n  \n  # get the number\
    \ of lowercase\n  sm = extension_split.map(&:size).max\n  \n  # find the strongest\
    \ extension\n  strongest = extension_split.sort.last\n  \n  class_name << strongest\
    \ # add strongest extension to class_name\n  \n  extension_split.each { |e| e.capitalize!\
    \ } # capitalize all extensions of class_name\n  \n  class_name << extension_split.map\
    \ { |e| e.capitalize }.join # capitalize all extensions of class_name\n  \n  class_name\
    \ << extension_split.map { |e| e - strongest }.min # append strongest extension\n\
    end", "    \n    # Write your code here.\n    \n    extensions_hash = {}\n   \
    \ extensions_name_hash = {}\n    extensions_strength_hash = {}\n    \n    extensions_names\
    \ = extensions[0].split('.')\n    \n    for extension in extensions:\n       \
    \ extension_name, extension_ext = extension.split('.')\n        \n        extensions_strength_hash[extension_name]\
    \ = extensions_strength_hash.get(extension_name, -1) + int(extension_ext)\n  \
    \  \n    for extension in extensions:\n        extension_name, extension_ext =\
    \ extension.split('.')\n        \n        if extension_strength = extensions_strength_hash[extension_name]\n\
    \        \n        if extension_strength > -1 and extension_name != \"Slices\"\
    :\n            \n            extensions_name_hash[extension_name] = extensions_name_hash.get(extension_name,\
    \ -1) + 1\n            \n            if extensions_name_hash[extension_name] ==\
    \ 1:\n                extensions_name_hash[extension_name] = extension_strength",
  "  extension_count = extensions.length\n  strongest_extension_count = -1\n  class_extension_count\
    \ = 0\n  \n  extensions.each do |extension|\n    extension_count += 1\n    extension_count\
    \ += extension.count(\"CA\")\n    class_extension_count += 1\n  end", "    extension_array\
    \ = extensions.map{|e| e.upcase}.sort.map{|e| e.downcase}\n    extension_array.each\
    \ do |e|\n        strength = class_name.count(e) - class_name.count(e.upcase)\n\
    \        puts \"#{class_name}.#{e}\"\n    end\nend", "  \n  extensions_sorted\
    \ = extensions.sort.reverse\n  \n  # The most likely extension should be the first\
    \ one in the array\n  strongest_extension = extensions_sorted.first\n  \n  # Iterate\
    \ over the rest of the array and compare strength values\n  extensions_sorted.each\
    \ do |extension|\n    \n    # Get the number of uppercase letters in extension\n\
    \    uppercase_letters = extension.chars.map(&:upcase).count\n    \n    # Get\
    \ the number of lowercase letters in extension\n    lowercase_letters = extension.chars.map(&:downcase).count\n\
    \    \n    # Calculate strength using the fraction CAP - SM\n    strongest_extension.strength\
    \ = uppercase_letters - lowercase_letters\n    \n    # Keep the most likely extension\
    \ until there are two or more equal extensions\n    break if strongest_extension.strength\
    \ == 0\n    \n  end\n  \n  strongest_extension.name = class_name\n  \n  return\
    \ strongest_extension\n  \nend", "  extensions.sort.each { |ext| return class_name\
    \ + ext if ext.match(/[A-Z]+$/) }\n  extensions.sort.each { |ext| return class_name\
    \ + ext.upcase if ext.match(/[a-z]+$/) }\n  extensions.sort.each { |ext| return\
    \ class_name + ext if ext.match(/[A-Z]+$/).nil? }\n  extensions.sort.each { |ext|\
    \ return class_name + ext.upcase if ext.match(/[a-z]+$/).nil? }\n  extensions.sort.each\
    \ { |ext| return class_name + ext if ext.match(/[A-Z]+$/).nil? && ext.match(/[a-z]+$/)\
    \ }\n  extensions.sort.each { |ext| return class_name + ext.upcase if ext.match(/[a-z]+$/).nil?\
    \ && ext.match(/[A-Z]+$/) }\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby |>\n\
    <code>", "    extension_strength = {}\n    extension_strength_array = []\n   \
    \ extension_strength_array.push(class_name)\n    extension_strength_array.push(extensions)\n\
    \    extension_strength_array.each_with_index do |pair, index|\n        extension_strength[pair[0]]\
    \ = pair[1]\n    end\n    extension_strength_array.sort.each_with_index do |pair,\
    \ index|\n        extension_strength_array[index] = [pair[0], pair[1], -1]\n \
    \   end\n    extension_strength_array.each do |pair|\n        extension_strength_array.each\
    \ do |other_pair|\n            if pair[1] == other_pair[1]\n                extension_strength[pair[0]][2]\
    \ = 0\n            end\n        end\n    end\n    extension_strength_array.each\
    \ do |pair|\n        extension_strength[pair[0]][2] = 1 if pair[1] != 0\n    end\n\
    \    extension_strength_array.sort.each_with_index do |pair, index|\n        extension_strength_array[index]\
    \ = [pair[0], pair[1], pair[2]]\n    end\n    extension_strength_array[-1][0]\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThe code was intended to be uncommented, but\
    \ it seems that it is not.\n<|/ c |>\n<| c |>\nThis answer would be more useful\
    \ if you explained how it works.\n<|/ c |>\n<| c |>\nAs the comment says, this\
    \ code does two things:\nFirst, for each character in the class name, it counts\
    \ the number of occurrences of each character's uppercase (Capital A), lowercase\
    \ (small a) and the numbers in between (0-9). This gives you a hash with the characters\
    \ as keys and the frequencies of the characters as values. \nThen, it sorts the\
    \ hash by the frequency, and for every pair of characters with the same frequency,\
    \ the one that comes first in the array is chosen arbitrarily. To make it work,\
    \ you need to convert all the characters to lowercase.\n<|/ c |>\n<| a dscore=1\
    \ |>\nI have written the following script using Ruby 1.9 and it is working as\
    \ expected\n<code>", "  strength = extensions.length\n  extension = extensions[0]\n\
    \  extensions.delete_at(extensions.index(extension))\n  if extensions.length >\
    \ strength\n    extension = extensions.sort_by{ |e| -e.length }[0]\n  else\n \
    \   extension = extension\n  end\n  return class_name + \".\" + extension\nend",
  "    \n    num_capitals = class_name.count(' ')\n    num_lowers = class_name.count('a')\n\
    \    if num_capitals == 0 and num_lowers == 0\n        return \"#{class_name}\"\
    \n    \n    strongest_extension = extensions[0]\n    strength_of_extension = 1\n\
    \    \n    # Loop through the array\n    for i in 1..extensions.length\n     \
    \   \n        # Split the name into two parts: the first part is the extension\
    \ name and the second\n        # part is the class name that is going to be extended.\n\
    \        name_of_extension, class_name_of_extension = extensions[i].split('.')\
    \ \n        \n        # Look at the second part of the name\n        strength_of_extension\
    \ = strength_of_extension * class_name_of_extension.count(name_of_extension.upcase)\n\
    \        \n        # Get the current extension\n        extension = class_name_of_extension.downcase\n\
    \        \n        # If the current extension has already been added to the class,\
    \ ignore it\n        if extension.include?(name_of_extension.downcase)\n     \
    \       next\n        end\n        \n        # Add the current extension to the\
    \ class\n        class_name_of_extension += \".#{name_of_extension.upcase}\"\n\
    \        \n        # Make the new name of the class\n        class_name_of_extension.upcase!\n\
    \        \n        # Make the new name of the extension\n        name_of_extension.upcase!\n\
    \        \n        # Make the new name the new class\n        class_name = class_name_of_extension\n\
    \        \n        # If the extension's name has already been added to the class,\
    \ ignore it\n        if extension.include?(name_of_extension)\n            next\n\
    \        end\n        \n        # Add the extension to the class\n        class_name\
    \ += \".#{name_of_extension}\"\n        \n        # Make the new name of the class\n\
    \        class_name.upcase!\n        \n        # Make the new name the new extension\n\
    \        name_of_extension.upcase!\n        \n        # Make the new name the\
    \ new class\n        class_name = class_name\n    end\n    \n    if strongest_extension\
    \ == '' and extensions.length > 0\n        extension = extensions[extensions.length\
    \ - 1]\n        strongest_extension = extension.upcase\n    end\n    \n    return\
    \ class_name.gsub(\"\\n\", ' ').gsub('.', ' ').gsub(\" \", '').gsub(/[']/, '')\n\
    end\n</cell>\n<code language=julia-0.5>", "  extensions = extensions.sort\n  \n\
    \  # initialize a variable to hold the strongest extension name\n  strongest_extension_name\
    \ = \"\"\n  \n  # initialize a variable to hold the strongest extension strength\n\
    \  strongest_extension_strength = -1\n  \n  # initialize a variable to hold the\
    \ strongest extension count\n  strongest_extension_count = 0\n  \n  # loop over\
    \ all the extensions in the array\n  extension_counter = 0\n  while extension_counter\
    \ < extensions.length\n    # increment the extension counter\n    extension_counter\
    \ = extension_counter + 1\n    # check if the extension strength is larger than\
    \ the current strongest extension strength\n    if extensions[extension_counter].to_s[0,1].upcase\
    \ > strongest_extension_strength\n      # update the strongest extension strength\n\
    \      strongest_extension_strength = extensions[extension_counter].to_s[0,1].upcase\n\
    \      # update the strongest extension name\n      strongest_extension_name =\
    \ extensions[extension_counter].to_s\n      # increment the strongest extension\
    \ count\n      strongest_extension_count = strongest_extension_count + 1\n   \
    \ # check if the extension strength is equal to the current strongest extension\
    \ strength\n    elsif extensions[extension_counter].to_s[0,1].upcase == strongest_extension_strength\n\
    \      # check if the extension name is the current strongest extension name\n\
    \      if extensions[extension_counter].to_s == strongest_extension_name\n   \
    \     # increment the strongest extension count\n        strongest_extension_count\
    \ = strongest_extension_count + 1\n      end\n    # check if the extension name\
    \ is the current strongest extension name\n    elsif extensions[extension_counter].to_s\
    \ != strongest_extension_name\n      # update the strongest extension name\n \
    \     strongest_extension_name = extensions[extension_counter].to_s\n      # increment\
    \ the strongest extension count\n      strongest_extension_count = strongest_extension_count\
    \ + 1\n    end\n  end\n  \n  # return the strongest extension name\n  return strongest_extension_name\n\
    end", "  strongest = {}\n  extensions.each do |extension|\n    arr = extension.split('')\n\
    \    strongest[extension] = -1\n    arr.each do |elem|\n      strongest[extension]\
    \ = 0 if elem.upcase == elem\n    end\n  end\n  strongest.max_by {|k, v| v}[1]\n\
    end", "    extensions = extensions.sort{|a, b| b.size - a.size}.reverse\n    strength\
    \ = extensions.length\n    count = 0\n    extensions.each do |e|\n        count\
    \ = count + (e.include?(class_name) ? 0 : 1)\n    end\n    count/strength\nend\n\
    </code>\n<|/ a dscore=0 tags=ruby |>\n<| c |>\nThis is nice but has problems in\
    \ Ruby; `String#include?` takes one parameter and will never return `nil`. This\
    \ will raise an exception if the argument passed to `String#include?` isn't a\
    \ string. Changing the `include?` call to `include?(e)` will fix the problem.\
    \ Also, if you don't need to support versions of Ruby prior to 1.9.2, you can\
    \ simply use `to_sym` instead of `to_i` to coerce a symbol to a string.\n<|/ c\
    \ |>\n<| c |>\nI agree that it's nice to have this in one place, but I think it's\
    \ too clever. Also, I had not considered the version limitations, thanks for pointing\
    \ that out. I have updated the code to reflect these changes.\n<|/ c |>\n<| c\
    \ |>\nI didn't downvote you, but I believe it's because you shouldn't be calling\
    \ `to_i` in the first place. `to_i` takes `Fixnum` and turns it into a `Fixnum`,\
    \ but you only want to treat it as a string if it's a symbol that's being called\
    \ as `to_i`. I think what would have been more appropriate, if you would have\
    \ mentioned that version limitation, would be to use `to_sym` instead of `to_i`.\
    \ `to_i` would return `0` if the string was `\"0\"`.\n<|/ c |>\n<| c |>\nThank\
    \ you for the suggestions and improvements, I've updated my code to reflect the\
    \ recommendations.\n<|/ c |>\n<| a |>\n<code>", "  extension_strength = {}\n \
    \ extensions.each { |ext|\n    index = ext.index(ext.upcase)\n    extension_strength[ext]\
    \ = (index == 0 ? -index : index)\n  }\n  sorted_keys = extension_strength.keys.sort_by\
    \ { |ext| -extension_strength[ext] }\n  sorted_keys.each { |ext|\n    index =\
    \ ext.index(ext.downcase)\n    extension_strength[ext] = -1\n  }\n  extension_strength.each\
    \ { |ext, strength|\n    index = ext.index(ext.downcase)\n    if index != 0\n\
    \      extension_strength[ext] = (index - 1) * strength\n    end\n  }\n  sorted_keys.find\
    \ { |ext| extension_strength[ext] == -1 }\nend\n</code>\n<|/ a dscore=3 |>\n<|\
    \ c |>\nI like the elegance of your solution.  It does not use regular expressions\
    \ so it's more efficient than my solution.  I added your solution to my answer\
    \ too.\n<|/ c |>\n<| a dscore=2 |>\nHere is my solution:\n<code>", "    \n   \
    \ extension_strengths = []\n    \n    for extension in extensions\n        extension_strength\
    \ = extension.count('Z') - extension.count('A')\n        extension_strengths.append(extension_strength)\n\
    \        \n    sorted_strengths = extension_strengths.sort\n    \n    strength\
    \ = sorted_strengths[0]\n    \n    sorted_extensions = extension_strengths.sort\n\
    \    \n    extension_name = sorted_extensions[0]\n    \n    return f\"{class_name.title()}.{extension_name.title()}\"\
    \n</code>\n<|/ a tags=string,ruby,string |>\n<| c |>\nThis solution would return\
    \ `Slice.AA`, which is clearly wrong.\n<|/ c |>\n<| c |>\nI agree.  I didn't see\
    \ that from the question, but it makes perfect sense with the desired output.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "  strongest = extensions[0]\n  extensions.each\
    \ do |ext|\n    if ext.split('').map { |e| e.capitalize }.uniq.size == ext.split('').map\
    \ { |e| e.capitalize }.uniq.size\n      if ext.split('').map { |e| e.downcase\
    \ }.uniq.size < ext.split('').map { |e| e.downcase }.uniq.size\n        strongest\
    \ = ext\n      end\n    end\n  end\n  return class_name.to_s + '.' + strongest\n\
    end\n</code>\nHere we call Strongest_Extension on our array (of class names plus\
    \ their extensions) and concatenate the class name with the strongest extension\
    \ we found.\n<code>", "  extensions = extensions.sort\n  i = 0\n  while i < extensions.length\n\
    \    next_letter = class_name.slice(i, i+1)\n    letter = extensions[i]\n    if\
    \ letter == next_letter\n      i += 1\n    else\n      strength = (letter.length\
    \ - next_letter.length) / letter.length\n      break if strength == 0\n      i\
    \ += 1 if strength > 0\n    end \n  end \n  \n  name = class_name + (\".#{extensions[0]}\"\
    ) \n  i = 1 \n  while i < extensions.length\n    name += \".#{extensions[i]}\"\
    \n    i += 1\n  end \n  name\nend \n</cell>\n<cell>", "  extension_count = extension_counts(extensions)\n\
    \  return extension_counts.sort.reverse.sort.first", "  extensions.max_by { |x|\
    \ x[0].to_s.split('').reverse.count - x[0].to_s.split('').count }\nend", "  return\
    \ nil if extensions.empty?\n  extensions_array = extensions.map{|e| e.capitalize}\n\
    \  sorted_extensions_array = extensions_array.sort{|e1, e2| e1.downcase <=> e2.downcase}\n\
    \  index_of_extension = sorted_extensions_array.index { |e| e.index(class_name.downcase)\
    \  }\n  index_of_extension = -1 if index_of_extension < 0\n  extensions_array.delete_at(index_of_extension)\n\
    \  extensions_array.delete_at(0)\n  sorted_extensions_array.join.capitalize\n\
    end\n</code>\n<|/ q tags=arrays,ruby,class dscore=0 |>\n<| a tags=arrays,ruby,class\
    \ |>\nTry this:\n<code>", "\tstrongest_extension = nil\n\t\n\textensions.each\
    \ { |ext|\n\t\tcase ext.capitalize.to_s\n\t\t\twhen \"A\"..\"Z\", \"Aa\"..\"Za\"\
    , \"B\"..\"Z\", \"Ba\"..\"Za\", \"C\"..\"Z\", \"Ca\"..\"Za\"\n\t\t\t\tstrongest_extension\
    \ = ext\n\t\t\t\tbreak\n\t\t\twhen \"a\"..\"z\", \"aa\"..\"za\", \"b\"..\"z\"\
    , \"ba\"..\"za\", \"c\"..\"z\", \"ca\"..\"za\"\n\t\t\t\tstrongest_extension =\
    \ ext\n\t\t\t\tbreak\n\t\t\twhen \"0\"..\"9\"\n\t\t\t\tstrongest_extension = ext\n\
    \t\t\t\tbreak\n\t\t\twhen \"a\"..\"z\", \"aa\"..\"za\", \"b\"..\"z\", \"ba\"..\"\
    za\", \"c\"..\"z\", \"ca\"..\"za\"\n\t\t\t\tstrongest_extension = ext\n\t\t\t\t\
    break\n\t\t\telse\n\t\t\t\tputs \"There was an error in Strongest_Extension: Strongest\
    \ extensions may not begin with letters (#{ext} is not a valid extension name).\"\
    \n\t\tend\n\t}\n\t\n\treturn class_name.to_s + \".\" + strongest_extension\nend",
  "  new_extension = extensions[0..(extensions.count(\".\"))-1].join(\"\")\n  return\
    \ class_name + \".\" + new_extension\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    You should probably explain your answer before posting it as an answer. Your answer\
    \ will likely be deleted later by someone who doesn't know how it works.\n<|/\
    \ c |>\n<| c |>\nI appreciate your comment but I'm looking for an explanation\
    \ on how this code works not just a solution for me.\n<|/ c |>\n<| a tags=ruby\
    \ |>\n<code>", "  sorted_extensions = extensions_sort(extensions)\n  extensions.each\
    \ do |extension|\n    if sorted_extensions.include?(extension)\n      class_name.send(:const_set,\
    \ extension.downcase, -1)\n    end\n  end\n  strongest_extension = extensions.first\n\
    \  extensions.each do |extension|\n    if sorted_extensions.include?(extension)\n\
    \      strongest_extension = extension if extension.downcase.to_i >= strongest_extension.downcase.to_i\n\
    \    end\n  end\n  strongest_extension\nend", "  extension_strengths = {}\n  extensions.each\
    \ do |extension|\n    next if extension =~ /\\./ || extension =~ /[^A-Z]/\n  \
    \  extension_strengths[extension] = extension.upcase - extension.downcase\n  end",
  "  extension_strengths = Hash.new(-1)\n  extensions.each do |ext|\n    extension_strengths[ext]\
    \ = class_name.count(ext.upcase) - class_name.count(ext.downcase)\n  end\n  extension_strengths.sort_by\
    \ {|k, v| -v}.first\nend\n</cell>\n<cell>\n%load '../test/testcases/solution.py'\n\
    </cell>\n<cell>", "    max_length = 1\n    \n    for i in range(len(extensions)):\n\
    \        max_length = max(max_length, extensions[i].count(class_name[i]))\n  \
    \  return class_name + extensions[max_length].lower()\n</cell>\n<cell>", "  name_of_class\
    \ = class_name.downcase\n  name_of_class = name_of_class.gsub(/\\s+/, '.')\n \
    \ name_of_class.split('.').inject(class_name, :+)\nend", "    # Initialize empty\
    \ list of classes and strengths \n    classes_strengths = []\n    # Initialize\
    \ number of uppercase letters in class name \n    uppercases = class_name.count(\"\
    A\")\n    # Initialize number of lowercase letters in class name \n    lowercases\
    \ = class_name.count(\"a\")\n    # Iterate through the list of extensions, counting\
    \ uppercase and lowercase \n    # letters\n    for extension in extensions\n \
    \       uppercases += extension.count(\"A\")\n        lowercases += extension.count(\"\
    a\")\n    # Iterate through the list of extensions, accumulating the strength\n\
    \    strength = 0\n    for extension in extensions\n        strength += extension.count(\"\
    A\") - extension.count(\"a\")\n        strength += extension.count(\"a\") - extension.count(\"\
    A\")\n    classes_strengths += [class_name, uppercases, lowercases, strength]\n\
    \    classes_strengths.sort\n    most_strength = classes_strengths[-1][3]\n  \
    \  most_extension = extensions[classes_strengths[-1][2]]\n    return most_extension\n\
    </code>\n<|/ a tags=ruby |>\n<| a dscore=0 |>\n<code>", "  strongest_extension\
    \ = nil\n  extension_strength = nil\n  extensions.each do |ext|\n    ext_strength\
    \ = ext.split.split('').sort.reduce(0) do |sum, letter|\n      sum += letter.isupper\n\
    \    end\n    if strongest_extension.nil? || ext_strength > strongest_extension.strength\n\
    \      strongest_extension = ext\n      extension_strength = ext_strength\n  \
    \  end\n  end\n  \"#{class_name}.#{strongest_extension}\"\nend", "    extensions_array\
    \ = extensions.sort\n    extensions_array.each do |ext|\n        ext = ext.downcase\n\
    \        strength = extensions_array.count(ext)\n        if strength == 1\n  \
    \          return class_name\n        elsif strength > 1\n            strength\
    \ = strength - 1\n            return class_name + ext.to_s.slice(0,strength.to_i)\n\
    \        end\n    end\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nThis\
    \ can be solved using Regular Expressions.\n<code>", "  extensions = extensions.sort\
    \ { |a,b| b.length - a.length }\n  extension = extensions[0]\n  class_name = class_name.gsub(/[A-Z]/,\
    \ '').gsub(/[a-z]/, '').gsub(/[0-9]/, '')\n  return class_name + \".\" + extension\n\
    end", "  extensions_count = extensions.size\n  return class_name.gsub(/[A-Z]/)\
    \ { |m| m >= (extensions_count - 1 ? 0 : extensions[extensions_count - 1][m.upcase].size)\
    \ }.downcase.gsub(/[^A-Z]/, \"_\").gsub(/[-_]/, \"_\")\nend\n</code>\n<|/ a |>\n\
    <| a |>\nIf you want more elegant and simple solution then this answer might work\
    \ for you:\n<code>", "  strength = extension_strength(class_name, extensions)\n\
    \  extension = extensions[strength]\n  class_name = class_name.split('.')[0]\n\
    \  class_names = []\n  while extension != class_name\n    class_names.push(extension)\n\
    \    extension = extensions[extension_strength(class_name + '.' + extension, extensions)]\n\
    \  end\n  class_names.join('.')\nend", "  s = extensions.length\n  c = 0\n  extension\
    \ = nil\n  while c < s\n    extension = extensions[c]\n    c += 1\n    if StrongestExtension(class_name,\
    \ extension) == class_name + extension\n      return class_name + extension\n\
    \    else \n      if class_name == StrongestExtension(class_name, extension).downcase\n\
    \        return StrongestExtension(class_name, extension)\n      end\n    end\n\
    \  end\nend", "  extensions_length = extensions.length\n  \n  if extensions_length\
    \ == 0\n    puts \"No extensions to #{class_name}\"\n    return\n  end\n  \n \
    \ extensions_length.times do |i|\n    \n    extension = extensions[i]\n    \n\
    \    if extension.empty?\n      puts \"No extensions to #{class_name}\"\n    \
    \  return\n    end\n    \n    extension_strength = extension.downcase.to_s.size\
    \ - (extension.downcase.to_s.rindex(\"_\") + 1).to_i\n    \n    if extension_strength\
    \ == 0\n      puts \"No extensions to #{class_name}\"\n      return\n    end\n\
    \    \n    if extension_strength > 0\n      extension_strength += 1\n    end\n\
    \    \n    extension_strength = extension_strength.abs\n    \n    if extension_strength\
    \ == 1\n      extension_strength -= 1\n    end\n    \n    puts \"#{class_name}#{extension.downcase}.#{extension_strength}\"\
    \n  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,rubygems,ruby-on-rails-4,ruby-on-rails-3\
    \ |>\n<| c |>\n`class Foo; def bar; \"bar\" end end Strongest_Extension.call(\"\
    foo\", [:bar, :baz])` would return `\"foo.bar\"`.\n<|/ c |>\n<| c |>\nOops sorry,\
    \ I'll fix it\n<|/ c |>\n<| c |>\nJust to nitpick: `Strongest_Extension` returns\
    \ a string, not an array. Also, `foo_bar_baz` is really a class-name and not an\
    \ extension.\n<|/ c |>\n<| a dscore=0 |>\nThis is a slight extension on Joseph's\
    \ answer, this way you can take in any object and not just strings.\n<code>",
  "  \n  extensions.each do |extension|\n    extension = extension.downcase\n    strength\
    \ = class_name.split('.').map(&:capitalize).count { |e| e.eql?(extension) }\n\
    \    if strength != 0\n      name = class_name.split(\".\").\n        map { |e|\
    \ e.split(\"(?=[A-Z])\").first}.\n        join(\"\")\n      \"#{name.capitalize}.#{extension}\"\
    \n    end\n  end\nend", '    sorted_extensions = extensions.sort!.reverse!', " \
    \ extension_strength = extension_strength_calculator(extensions)\n  highest_strength_extension\
    \ = extension_strength.max_by { |k, v| v }\n  return(\"#{class_name}.#{highest_strength_extension}\"\
    )\nend\n</code>\n<|/ a tags=ruby,string dscore=1 |>\n<| c |>\nYou don't need `return`\
    \ when doing `map`, just return the block.\n<|/ c |>\n<| c |>\nHe is asking for\
    \ the strongest extension, hence the need for the return statement.\n<|/ c |>\n\
    <| c |>\nI think you're misreading his question. He wants to find the strongest\
    \ extension from a given array of extensions (not just one).\n<|/ c |>\n<| c |>\n\
    My apologies, I read it that way. I read it as he has a class name and a array\
    \ of extensions and wants to find the strongest extension from the array. He stated\
    \ that he wanted \"the strongest extension\" from his list of extensions, so I\
    \ thought he meant strongest alphabetically. He also stated that he wanted \"\
    the strongest extension\" so I thought he meant strongest extension.\n<|/ c |>\n\
    <| c |>\nI suspect he does want `strongest extension`. :-)\n<|/ c |>\n<| a tags=ruby,string\
    \ |>\nHere's my take on it. I think it's fairly straightforward.\n<code>", " \
    \ strongest = {}\n  strongest[extensions[0]] = -1\n  for i in (1..extensions.length)\n\
    \    if strongest[extensions[i]] < strongest[extensions[i-1]]\n      strongest[extensions[i]]\
    \ = extensions[i-1]\n    end\n  end\n  return class_name + \".\" + extensions[strongest[extensions[extensions.lenght]]]\n\
    end", "    return class_name.split('_').map { |e| e.gsub(/[A-Z]/, \"\").length\
    \ }.max -\n           extensions.map { |e| e.gsub(/[a-z]/, \"\").length }.min\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,string |>\n<code>", "  extension_classes\
    \ = []\n  extension_strengths = []\n  \n  # Go through all the extensions\n  for\
    \ extension in extensions do\n    \n    # Get the extension name and its letters\
    \ count\n    name = extension[0..CAP]\n    letters = extension[CAP..SM]\n    \n\
    \    # Go through all extensions with that name and count\n    Enum.each(classes,\
    \ function (enum, class_name)\n      if name == Enum.first(enum.name) then\n \
    \       extension_classes[#extension_classes+1] = class_name\n        extension_strengths[#extension_strengths+1]\
    \ = Enum.last(enum.strength)\n      end\n    end)\n  end\n  \n  # Return the class\
    \ name with the strongest extension\n  class_names[#class_names+1] = class_name\n\
    \  \n  # Find the strongest extension and return the extension letters count\n\
    \  strongest_extension_index = #extension_strengths\n  for i = #extension_strengths,\
    \ 1, -1 do\n    if extension_strengths[i] ~= extension_strengths[i-1] then\n \
    \     strongest_extension_index = i\n    end\n  end\n  return extension_classes[strongest_extension_index]\n\
    end\n</cell>\n<cell>", "  extensions.each do |extension|\n    strength = extension.upcase.count\
    \ - extension.downcase.count\n    puts class_name + \".\" + extension if strength\
    \ > 0\n  end\nend", "  extension_strengths = {}\n  \n  extensions.each do |extension|\n\
    \    extension_strengths[extension] = extension.upcase.length - extension.downcase.length\n\
    \  end\n  \n  extension_strengths.sort_by{|k,v| v}.last\nend", "  # Initialize\
    \ a String variable which will hold our extension.\n  extension = \"\"\n  # Iterate\
    \ over our extensions and find the strongest one.\n  extensions.each { |e|\n \
    \   if (e.include?(class_name) && (e != class_name))\n      extension = e\n  \
    \  end\n  }\n  return extension\nend\n</code>\nThe next step is to test your code.\n\
    <code>", "  extensions.sort!\n  best_strength = extensions[0].length\n  extensions.reverse!\n\
    \  extensions.each do |ext|\n    length = ext.length\n    ext.downcase!\n    if\
    \ length < best_strength \n      best_strength = length\n    end\n  end\n  return\
    \ class_name + best_strength.to_s + extensions.join('.')\nend", "  strength =\
    \ extensions.length\n  for i in 0...extensions.length\n    if extensions[i].downcase\
    \ == class_name[0].upcase\n      strength = i - 1\n      break\n    end\n  end\n\
    \  extensions[strength]\nend", "  return Array.max(extensions).map { |e| class_name.split(\"\
    .\").map { |c| e.to_s.split(c).size }.max }.max\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis looks great! However, your implementation seems to be giving\
    \ me strange results. Here's an example:\nInput: \"my_class\", [\"AB\", \"AA\"\
    , \"CC\"]\nOutput: \"my_class.CC\"\nHowever, if I input \"my_class\", [\"AB\"\
    , \"AA\", \"CC\", \"DD\", \"BB\"]\nthen I get \"my_class.AB\"\n<|/ c |>\n<| c\
    \ |>\nIt sounds like your input array contains only a mix of lower and uppercase\
    \ letters whereas your expected output should be the longest extension that contains\
    \ only lowercase letters, i.e. \"my_class.AA\"? If that's the case then my code\
    \ should work. I'd be happy to help you debug why it's doing something else if\
    \ you could provide an example that doesn't work.\n<|/ c |>\n<| c |>\nThe input\
    \ array contains both lowercase and uppercase letters. The expected output should\
    \ be my_class.AA, where AA is the longest extension that contains only lowercase\
    \ letters. I updated my question with an example.\n<|/ c |>\n<| c |>\nAh, I misunderstood\
    \ the problem. I thought you only wanted to find the longest extension which contained\
    \ lowercase letters but not necessarily the longest extension that contained all\
    \ letters. I have updated my answer with the code to find the longest extension\
    \ which contains only lowercase letters.\n<|/ c |>\n<| c |>\nThe solution is pretty\
    \ much what you have, but with two minor tweaks: 1) The array \"extensions\" is\
    \ returned with each extension split into its own element in the array. This makes\
    \ it easier to find the maximum extension strength later on; 2) The maximum extension\
    \ strength is now calculated by finding the maximum element in the array. Thanks!\n\
    <|/ c |>\n<| a |>\nThe answer of is good but it's easy to understand if you're\
    \ a beginner. Here is my solution:\n<code>", "  # Write your code here\n  min_ext=0\n\
    \  min_ext_name=\"\"\n  for e in extensions:\n    ext_name=e.rsplit(\".\",1)[1]\n\
    \    ext_name=ext_name[0].capitalize+ext_name[1:]\n    ext=e.capitalize+e[1:]\n\
    \    ext = ext.lower() \n    if ext in extensions:\n      ext_count=extensions.count(ext)\n\
    \      if ext_count<min_ext:\n        min_ext=ext_count\n        min_ext_name=ext_name\n\
    \  return class_name +\".\"+min_ext_name", "  max_strength = -1\n  max_extension\
    \ = \"\"\n  min_extension = \"\"\n  \n  extensions_hash = {}\n  \n  classes.each\
    \ do |name|\n    extensions_hash[name] = extensions.collect{|e| e.to_s}.uniq.sort\n\
    \  end\n  \n  extensions_hash.each do |name, extensions|\n    extensions.each\
    \ do |extension|\n      strength = extension.scan(/[A-Z]/).length - extension.scan(/[a-z]/).length\n\
    \      if strength > max_strength\n        max_strength = strength\n        max_extension\
    \ = extension\n      elsif strength == max_strength\n        if extensions.index(extension)\
    \ > extensions.index(min_extension)\n          min_extension = extension\n   \
    \     end\n      end\n    end\n  end\n  return \"#{class_name.capitalize}#{max_extension}\"\
    \nend", "  extensions.sort!\n  strength = extensions.length * 1.0 / extensions.length\n\
    \  extensions.each { |e| break if e.include?(class_name.upcase) }\n  extensions.each\
    \ { |e| break if e.include?(class_name.downcase) }\n  return class_name + extensions[extensions.index(extensions.last)\
    \ - 1] if extensions.count > 1\n  class_name.gsub(class_name.upcase, \"_#{class_name.upcase}\"\
    )\nend", "    extensions.sort.each_with_index do |extension, index|\n        return\
    \ class_name if extension.downcase == extensions[index]\n    end\nend\n</code>\n\
    <|/ a tags=ruby,string |>\n<| c |>\nThis was my first thought too, but if you\
    \ have `Slices` and `Slice` then your code will return `Slices` because it compares\
    \ the `Slice` string with the capital letters in `Slices` first.  Also, `extensions.sort.each_with_index.find\
    \ { |e| e.downcase == extensions[index] }` would work just as well.\n<|/ c |>\n\
    <| c |>\nYou're right! I didn't test it properly.  I updated my solution. Thank\
    \ you for pointing that out.\n<|/ c |>\n<| c |>\nThank you! This is very helpful.\n\
    <|/ c |>\n<| c |>\nBy the way, this doesn't work if the extension is \"Slices.SErviNGSliCes.\"\
    \  The correct result should be \"Slices.SErviNGSliCes\", because that is the\
    \ strongest extension.\n<|/ c |>\n<| c |>\nI did this the hard way:", "  n = length(extensions)\n\
    \  s = 0.0\n  for i in 0..(n-1)\n    s += ord(extensions[i])-ord(class_name)\n\
    \  end\n  return class_name + extensions[s]\nend", "  \n  result = []\n  \n  #\
    \ Loop through each extension\n  for extension in extensions\n    \n    # Split\
    \ the extension\n    extension_letters = extension.split", "  max_strength = -1\n\
    \  best_extension = \"\"\n  extensions.each do |e|\n    e.gsub(/[A-Z]/, '').to_i.to_s\
    \ - (e.gsub(/[a-z]/, '').to_i.to_s)\n    if e.gsub(/[A-Z]/, '').to_i.to_s < max_strength\n\
    \      max_strength = e.gsub(/[A-Z]/, '').to_i.to_s\n      best_extension = e\n\
    \    end\n  end\n  best_extension.concat(\".\").concat(class_name)\nend", "  extensions.sort.reverse.first\n\
    end", "  \n    \n  return class_name.gsub(/(?<=[A-Z])/, '_').gsub(/(?=[A-Z])/,\
    \ '_').downcase\n  \nend", "  extensions.sort.reverse.each do |ext|\n    next\
    \ unless ext.include?(class_name.downcase)\n    strength = ext.size - class_name.downcase.size\
    \ - ext.downcase.size\n    return class_name + \".\" + ext if strength > 0\n \
    \ end\n  raise \"No valid extension found\"\nend\n</code>\n<|/ a |>\n<| c |>\n\
    Hi Sascha, thanks for your answer, but I can't quite follow what you are saying.\
    \ Could you explain what you are saying in more detail? I appreciate your help\
    \ and will check back in once I have time to go through this and understand your\
    \ code. Thanks.\n<|/ c |>\n<| c |>\nHi Sascha, thanks for your answer, but I can't\
    \ quite follow what you are saying. Could you explain what you are saying in more\
    \ detail? I appreciate your help and will check back in once I have time to go\
    \ through this and understand your code. Thanks.\n<|/ c |>\n<| c |>\nHi Sascha,\
    \ I appreciate your answer, but I can't quite follow what you are saying. Could\
    \ you explain what you are saying in more detail? I appreciate your help and will\
    \ check back in once I have time to go through this and understand your code.\
    \ Thanks.\n<|/ c |>\n<| c |>\nPlease explain your comments and how your solution\
    \ works.\n<|/ c |>\n<| a |>\n<code>", "\textensions = extensions.sort\n\textension_count\
    \ = extensions.length\n\tstrength = nil\n\t\n\tfirst_extension = extensions.first.upcase\n\
    \tsecond_extension = extensions.second.downcase\n\t\n\tstrength = first_extension.length\
    \ + second_extension.length\n\t\n\tif extension_count == 1 || strength == first_extension.length\n\
    \t\treturn \"#{class_name}.#{first_extension}\"\n\tend\n\t\n\tstrongest_extensions\
    \ = extensions.select { |s| s.upcase == first_extension }\n\t\n\tif strongest_extensions.empty?\n\
    \t\treturn \"#{class_name}.#{first_extension}\"\n\tend\n\t\n\tmin_strength = first_extension.length\n\
    \t\n\tstrongest_extensions.each do |strongest_extension|\n\t\tstrength = strength\
    \ + strongest_extension.length\n\t\tif strength < min_strength\n\t\t\tmin_strength\
    \ = strength\n\t\tend\n\tend\n\t\n\tif min_strength == first_extension.length\n\
    \t\treturn \"#{class_name}.#{first_extension}\"\n\tend\n\t\n\treturn \"#{class_name}.#{first_extension}#{strongest_extensions.last}\"\
    \nend\n</cell>\n<cell>", "  extensions = extensions.sort { |a, b| b.length.to_f\
    \ <=> a.length.to_f }\n  strongest = extensions[0]\n  extensions.each do |extension|\n\
    \    if extension.index(strongest) != 0\n      strongest = extension\n    end\n\
    \  end\n  class_name.to_s + \".\" + strongest.downcase\nend\n</code>\nEDIT: I've\
    \ modified the code so that it returns the name of the strongest extension if\
    \ there are multiple with the same strength.\n<|/ a dscore=1 tags=ruby |>\n<|\
    \ c |>\nWhy do I get \"undefined method `index' for [\"AA\", \"Be\", \"CC\"]:Array\"\
    \ when I run this example?\n<|/ c |>\n<| c |>\nThe code was only meant to be run\
    \ in a Rails console. It had a typo, it should have been `extension.index(strongest)`.\
    \ I've corrected the code and added a link to my Github repo.\n<|/ c |>\n<| c\
    \ |>\nWhat if I add `'a','b','c'` as a class name? The code doesn't work if the\
    \ class names are `'A','B','C'`.\n<|/ c |>\n<| c |>\nThat shouldn't be a problem\
    \ as long as you always put them in quotes. It works fine for me when I run my\
    \ code in a Rails console.\n<|/ c |>\n<| c |>\nIt should be possible to fix the\
    \ code so that it works for any character class name with a single uppercase letter,\
    \ by just replacing the `extension.index(strongest)` call with `extension.index(strongest.upcase)`.\
    \ I'll look into this when I get a chance.\n<|/ c |>\n<| a tags=ruby |>\n<code>",
  "  # Your code here\n  result = ''\n  \n  # Your code here\n  \n  return result",
  "    sorted_extensions = extensions.sort_by { |e| e.to_s.size }\n    return sorted_extensions.detect\
    \ { |e| e.to_s.size == sorted_extensions.last.to_s.size }.to_s\nend", "  strongest_extensions\
    \ = []\n  class_name = class_name.to_s.upcase\n  classes.each do |class_name,\
    \ extensions|\n    extensions_array = extensions.to_a.flatten.map(&:to_s).sort\n\
    \    extensions_array.each do |ext|\n      strongest_extensions.push class_name\
    \ + \"_\" + ext.upcase.gsub(/\\d/, \"\")\n    end\n  end\n  strongest_extensions.uniq.sort!.first\n\
    \  strongest_extensions.reverse.each do |extension|\n    strongest_extension =\
    \ class_name + extension.downcase.gsub(/\\d/, \"\")\n    break strongest_extension\
    \ if strongest_extensions.include?(strongest_extension)\n  end\n  strongest_extensions.first\n\
    end", "  extensions.inject([]) do |exts, extension|\n    exts << extension.to_s.gsub(/[A-Z]/,\
    \ ' ').gsub(/[a-z]/, ' ').capitalize\n  end\n  extensions.sort_by { |s| s.length\
    \ }.first\nend\n</code>\nThen you simply call your extensions with some code like\
    \ this:\n<code>", "  strongest = extensions[0].downcase\n  extensions.each{|x|\
    \ strongest = x if x.include?(strongest)}\n  strongest.sub(/[A-Z]/, '')\nend\n\
    </code>\n<|/ a tags=ruby,string,ruby-on-rails,replace dscore=1 |>\n<| c |>\nI\
    \ think this does solve the problem of returning the extension with the least\
    \ amount of capital letters, but it doesn't solve the problem of returning all\
    \ extensions with the same amount of capital letters.  E.g. \"ABC\".gsub(/[A-Z]/,\
    \ '') returns \"abc\", not \"ABC\".\n<|/ c |>\n<| c |>\nThanks much. Yes, I actually\
    \ wanted to write \"ABC\".gsub(/[A-Z]/, ''). My bad! Edited my post.\n<|/ c |>\n\
    <| c |>\nThis still doesn't solve the problem of returning all extensions with\
    \ the same amount of capital letters.  E.g. \"ABC\".gsub(/[A-Z]/, '') returns\
    \ \"abc\", not \"ABC\".\n<|/ c |>\n<| a tags=ruby,string,ruby-on-rails,replace\
    \ |>\nHere are a few options. I put them in one array so I could give them a sensible\
    \ name.\n<code>", "    array_of_classes = []\n    array_of_strengths = []\n  \
    \  \n    # TODO\n    for extension in extensions\n        array_of_classes.append(class_name)\n\
    \        array_of_strengths.append(extension)\n        \n    array_of_classes.each_with_index\
    \ do |class_name, i|\n        array_of_classes[i] = array_of_classes[i].to_s.downcase\n\
    \        array_of_strengths[i] = array_of_strengths[i].to_s.downcase\n    end\n\
    \    \n    strength_array = array_of_strengths.sort\n    \n    strongest_extension\
    \ = \"\"\n    \n    strength_array.each_with_index do |extension_strength, index|\n\
    \        \n        if array_of_classes[index] == array_of_classes[index]\n   \
    \         # Do not compare the same classes with the same strength\n         \
    \   next\n        end\n        \n        if extension_strength == -1\n       \
    \     # Do not compare any extensions with strength -1\n            next\n   \
    \     end\n        \n        if extension_strength < array_of_strengths[index]\n\
    \            # This is the strongest extension\n            strongest_extension\
    \ = array_of_classes[index]\n        end\n        \n        if strongest_extension\
    \ == \"\"\n            # This is the first extension with strength -1\n      \
    \      strongest_extension = array_of_classes[index]\n        end\n    end\n \
    \   \n    return strongest_extension\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    This returns \"my_class.AA\" instead of the expected \"my_class.aa\". Same problem\
    \ as my previous attempt.\n<|/ c |>\n<| c |>\nAh, my bad. Yes, I forgot about\
    \ that last part, where it says \"or if two or more extensions have the same strength\"\
    . I'll fix it in a minute.\n<|/ c |>\n<| c |>\nHmmm, I guess this is still not\
    \ right. Let's try with [\"AA\", \"Be\", \"CC\"]. What happens is that in array\
    \ [\"AA\", \"Be\", \"CC\"] Becomes the strongest extension and \"AA\" becomes\
    \ the strongest extension as well, but \"CC\" doesn't become any more the strongest\
    \ extension. Maybe the problem is to compare the strength only and not the capital\
    \ letters.\n<|/ c |>\n<| c |>\nOops, didn't pay attention to that last part :D\
    \ Will fix it.\n<|/ c |>\n<| c |>\nI updated the answer, please take a look.\n\
    <|/ c |>\n<| a tags=ruby,arrays,string |>\nHere's a one-liner:\n<code>\n\"my_class\"\
    .downcase.split(\"_\").sort_by { |s| s.length }.reverse.join('').", "  extensions_sorted\
    \ = extensions.sort\n  first_extension = extensions_sorted.first\n  first_extension_strength\
    \ = (first_extension.downcase.length.to_f - first_extension.upcase.length.to_f)\
    \ / first_extension.downcase.length.to_f\n  strength_sum = extensions_sorted.reduce(lambda\
    \ a,b: a + (b.downcase.length.to_f - b.upcase.length.to_f) / b.downcase.length.to_f)\n\
    \  return class_name + first_extension.downcase + first_extension.upcase * strength_sum\n\
    end\n</code>\n<|/ a tags=ruby,arrays,algorithm,string |>\n<| a dscore=2 |>\nFor\
    \ a more general approach (not just for the example you provided, but you can\
    \ modify it easily) one approach is to count the letters and then create the extension\
    \ based on it.\n<code>", "  extensions.sort.find { |e| class_name.index(e.upcase)\
    \ - class_name.index(e.downcase) > 0 }\nend", "  return class_name.downcase +\
    \ extensions.sort_by { |e| e.count(0) }.first[0]\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,model-view-controller\
    \ |>\n<| c |>\nIt would be good if you'd include an explanation of how and why\
    \ this works.\n<|/ c |>\n<| c |>\nThis code worked well for me. Thanks a lot\n\
    <|/ c |>\n<| c |>\nThis works well for me, but I'm wondering if this is the best\
    \ way to go about it. It seems very cumbersome and inefficient to me. Perhaps\
    \ there is a better way to do this. I looked at the source code for ActiveSupport::Inflector\
    \ and I couldn't figure out any better way to do this without writing a new Inflector.\
    \ I'm open to other solutions though.\n<|/ c |>\n<| a dscore=4 |>\nA combination\
    \ of both answers above with my own:\n<code>", "  strongest = nil\n  extensions.each\
    \ do |extension|\n    strength = class_name.split(' ').inject(0) do |count, letter|\n\
    \      (count + (letter[0].ord >= letter[1].ord) ? 1 : 0)\n    end\n    strongest\
    \ = \"#{class_name}.#{extension}\" if strength > 0\n  end\n  strongest.nil? ?\
    \ \"Error\" : strongest\nend\n</cell>\n<text>\nProblem 3\nUsing the methods you\
    \ have implemented, implement the function Strongest_Extensions below to find\
    \ the strongest extensions for any two classes. You may assume that each class\
    \ has at most two extensions.", "  str_extension = nil\n  \n  extensions.each_with_index\
    \ do |ext, index|\n    str = ext.size\n    cap_num = str.upcase.count(\"A\") -\
    \ str.downcase.count(\"A\")\n    sm_num = str.downcase.count(\"a\") - str.upcase.count(\"\
    a\")\n    \n    if cap_num > 0\n      str_extension = class_name+\".\"+extensions[index]\
    \ if cap_num == sm_num\n    end\n  end\n  \n  return str_extension if str_extension\n\
    end\n</cell>\n<code language=julia-0.4>", "    return class_name.to_s.downcase.to_s.split('').sort.map(&:capitalize).join\n\
    end", "  strongest_extension = nil\n  extensions.each do |extension|\n    strength\
    \ = case(extension)\n    strength.nil? ? (strongest_extension = extension) : \n\
    \    (strength.size > strongest_extension.size ? strongest_extension = strength\
    \ : nil)\n  end\n  puts class_name\n  puts strongest_extension\nend", "  strongest_extension\
    \ = nil\n  extensions.each do |extension|\n    next if extension.empty?\n    strength\
    \ = extension.chars.map(&:upcase).count - extension.chars.map(&:downcase).count\n\
    \    strongest_extension = extension if strength > 0\n  end\n  return strongest_extension.nil?\
    \ ? nil : class_name + \"_\" + strongest_extension\nend\n</code>\n<|/ q dscore=1\
    \ |>\n<| c |>\nWhat does `Strongest_Extension` do?  Your description of it is\
    \ vague.  It doesn't look like it works?  Or doesn't work the way you expected?\n\
    <|/ c |>\n<| c |>\nI think you should add some comments and explanation in your\
    \ code, especially the purpose of the function. So that others can understand\
    \ it well and help you\n<|/ c |>\n<| c |>\nI have added the description of Strongest_Extension\
    \ above. Thanks\n<|/ c |>\n<| c |>\nIt doesn't work at all, it just gives the\
    \ wrong answer.\n<|/ c |>\n<| a |>\nHere is a possible solution:\n<code>", " \
    \   \n    # Write your code here\n    \n    if extensions.size < 2 then\n    \
    \    puts \"The array size should be greater than 1 for Strongest_Extension!\"\
    \n        return \"\"\n    end\n    \n    extension_count = {}\n    \n    extensions.each\
    \ do |extension|\n        if extension_count.has_key? extension[0].upcase \n \
    \           extension_count[extension[0].upcase] += 1\n        else\n        \
    \    extension_count[extension[0].upcase] = 1\n        end\n    end\n    \n  \
    \  max_extension = nil\n    max_extension_count = 0\n    \n    extensions.each\
    \ do |extension|\n        if extension_count.has_key? extension[0].upcase\n  \
    \          if extension_count[extension[0].upcase] > max_extension_count \n  \
    \              max_extension = extension\n                max_extension_count\
    \ = extension_count[extension[0].upcase]\n            end\n        end\n    end\n\
    \    \n    return class_name+\".\"+max_extension[0].downcase\nend\n</cell>\n<text>\n\
    Test Your Solution", "  strongest_extension = nil\n  sorted_extensions = extensions.sort\n\
    \  \n  number_of_chars = class_name.size\n  number_of_chars.times do |i|\n   \
    \ strongest_extension = sorted_extensions[i]\n    break if strongest_extension.size\
    \ <= number_of_chars\n  end\n  \n  return strongest_extension\nend", "  # Your\
    \ code here\n  return class_name+StrongestExtensionName(extensions)\nend", " \
    \ max_strength = -1\n  current_class = class_name\n  extensions.each do |extension|\n\
    \    if extension.include?(current_class)\n      current_class = extension\n \
    \     break\n    elsif max_strength == -1\n      max_strength = current_class.rindex(extension).to_i\
    \ \n    end\n  end\n  return \"#{class_name}.#{extensions[max_strength]}\"\nend",
  "  strongest_extension = nil\n  extensions.each do |extension|\n    number = extension.count(uppercase_letter)\n\
    \    next_number = extension.count(lowercase_letter)\n    strength = number/next_number\n\
    \    if strength > strongest_extension\n      strongest_extension = extension\n\
    \    end\n  end\n  return class_name + strongest_extension\nend\n</code>\nTo use\
    \ it, you just need to pass in the class name as a string, your array of extensions\
    \ as an array (which should be of strings), and it returns the class name with\
    \ its strongest extension appended to it.\nThe last part that you may need is\
    \ for you to implement this for any other number of classes and extensions as\
    \ well, so the code would look something like this:\n<code>", "  highest_strength\
    \ = -1\n  highest_extension = ''\n  \n  extensions.each do |extension|\n    strength\
    \ = class_name.split(extension).join.size\n    if strength > highest_strength\
    \ then\n      highest_strength = strength\n      highest_extension = extension\n\
    \    end\n  end\n  \n  return \"#{class_name}#{highest_extension}\"\nend", " \
    \ a = extensions.sort { |x,y| x.count <=> y.count }\n  s = a[0].count\n  if s.zero?\n\
    \    return class_name\n  else\n    return \"#{class_name}.#{a.shift}\"\n  end\n\
    end", "  result = nil\n  classes.each do |klass|\n    if klass.name == class_name\n\
    \      extensions.each do |ext|\n        if klass.name.include?(ext)\n       \
    \   result = klass.name \n          break\n        end\n      end\n    end\n \
    \ end\n  result\nend", "  a = extensions[0]\n  b = extensions[1]\n  c = extensions[2]\n\
    \  d = extensions[3]\n  e = extensions[4]\n  f = extensions[5]\n  g = extensions[6]\n\
    \  h = extensions[7]\n  i = extensions[8]\n  j = extensions[9]\n  k = extensions[10]\n\
    \  l = extensions[11]\n  m = extensions[12]\n  n = extensions[13]\n  o = extensions[14]\n\
    \  p = extensions[15]\n  q = extensions[16]\n  r = extensions[17]\n  s = extensions[18]\n\
    \  t = extensions[19]\n  u = extensions[20]\n  v = extensions[21]\n  w = extensions[22]\n\
    \  x = extensions[23]\n  y = extensions[24]\n  z = extensions[25]\n  A = extensions[26]\n\
    \  B = extensions[27]\n  C = extensions[28]\n  D = extensions[29]\n  E = extensions[30]\n\
    \  F = extensions[31]\n  G = extensions[32]\n  H = extensions[33]\n  I = extensions[34]\n\
    \  J = extensions[35]\n  K = extensions[36]\n  L = extensions[37]\n  M = extensions[38]\n\
    \  N = extensions[39]\n  O = extensions[40]\n  P = extensions[41]\n  Q = extensions[42]\n\
    \  R = extensions[43]\n  S = extensions[44]\n  T = extensions[45]\n  U = extensions[46]\n\
    \  V = extensions[47]\n  W = extensions[48]\n  X = extensions[49]\n  Y = extensions[50]\n\
    \  Z = extensions[51]\n  AA = extensions[52]\n  AB = extensions[53]\n  AC = extensions[54]\n\
    \  AD = extensions[55]\n  AE = extensions[56]\n  AF = extensions[57]\n  AG = extensions[58]\n\
    \  AH = extensions[59]\n  AI = extensions[60]\n  AJ = extensions[61]\n  AK = extensions[62]\n\
    \  AL = extensions[63]\n  AM = extensions[64]\n  AN = extensions[65]\n  AO = extensions[66]\n\
    \  AP = extensions[67]\n  AQ = extensions[68]\n  AR = extensions[69]\n  AS = extensions[70]\n\
    \  AT", "  extensions.sort!\n  strengths = []\n  current_index = 0\n  while current_index\
    \ < extensions.length\n    if current_index == 0\n      strength = extensions[0]\n\
    \      strengths << strength\n    else\n      current_extension = extensions[current_index-1]\n\
    \      next_extension = extensions[current_index]\n      current_extension_index\
    \ = current_extension.index(next_extension)\n      strength = current_extension_index\
    \ + next_extension.length.to_f\n      strengths << strength\n    end\n    current_index\
    \ += 1\n  end\n  strengths.sort.last.to_s + \"#{class_name.downcase}\".to_s\n\
    end\n</code>\n<|/ a tags=ruby dscore=1 |>\n<| a tags=ruby dscore=0 |>\n<code>",
  "    extensions_sorted = extensions.sort\n    extensions_sorted = extensions_sorted.reverse\n\
    \    \n    extensions_sorted.each do |extension|\n        begin\n            if\
    \ extension.include?(class_name.capitalize)\n                return class_name+\"\
    .\"+extension\n            end\n        rescue\n            puts \"The extension\
    \ #{extension} cannot be found for #{class_name}!\"\n        end\n    end\nend",
  "  extensions.sort_by{|s| s.split(//).map {|s| s.upcase.count('S') - s.downcase.count('S')}}.last\n\
    end\n</code>\nThe code above takes the input class_name, and an array of strings.\
    \ Each string in the array is the name of an extension, and each string must have\
    \ the form \"EXTENSION_NAME\". The code splits each string on whitespace, and\
    \ maps each part to the count of upper and lower case letters. Then it sorts the\
    \ extensions by strength, and returns \"ClassName.StrongestExtensionName\".\n\
    <|/ a tags=algorithm,language-agnostic |>\n<| c |>\nHow are you counting the number\
    \ of uppercase and lowercase letters in a string?\n<|/ c |>\n<| c |>\nThis counts\
    \ the number of uppercase letters in a string: http://stackoverflow.com/questions/406230/how-do-i-count-the-number-of-occurrences-of-a-character-in-a-string-using-php\n\
    <|/ c |>\n<| c |>\nThe problem is how to determine the strength of extension by\
    \ counting upcase and downcase letters.\n<|/ c |>\n<| c |>\nI've updated the question\
    \ to clarify a bit.\n<|/ c |>\n<| c |>\nI've updated the question again. I think\
    \ I have now understood your question better.\n<|/ c |>\n<| a tags=algorithm,language-agnostic\
    \ |>\nI don't have a solution in mind, but perhaps a starting point:\nFirst, get\
    \ the number of lowercase letters and the number of uppercase letters in the string.\n\
    Then subtract the number of lowercase letters from the number of uppercase letters,\
    \ giving you the string length\n<|/ a dscore=1 |>\n<| c |>\nIf I am not mistaken\
    \ this assumes that the letters are in alphabetical order.\n<|/ c |>\n<| c |>\n\
    : Yes -- but it does assume that your strings are in alphabetical order.  I mean,\
    \ I suppose you could have \"a\" and \"c\" as two examples and it wouldn't work.\n\
    <|/ c |>\n<| a tags=algorithm,language-agnostic |>\nI think the idea of counting\
    \ how many uppercase and lowercase letters you have will work. You can easily\
    \ convert lowercase to uppercase and vice-versa by using the ASCII table. So,\
    \ in order to get a total you can just add all the ASCII values of the letters\
    \ in the string.\nFor example, for the string \"ABCDEF\" you can add up their\
    \ ASCII values which is 65+66+67+68+69+70+71+72+73+74+75+76+", "    # Find all\
    \ capital letters starting from the end\n    upper_caps = []\n    for c in class_name:\n\
    \        if c.isupper():\n            upper_caps.append(c)\n    upper_cap_count\
    \ = len(upper_caps)\n    # Find all lowercase letters starting from the end\n\
    \    lower_caps = []\n    for c in class_name:\n        if c.islower():\n    \
    \        lower_caps.append(c)\n    lower_cap_count = len(lower_caps)\n    # Calculate\
    \ the relative position of the last uppercase letter\n    upper_cap_count_pos\
    \ = upper_caps.rindex(upper_caps[-1]) + 1\n    # Calculate the relative position\
    \ of the last lowercase letter\n    lower_cap_count_pos = lower_caps.rindex(lower_caps[-1])\
    \ + 1\n    # Find the relative strength of the extension by dividing capital letters\
    \ \n    # and lowercase letters\n    if upper_cap_count < lower_cap_count:\n \
    \       strength = upper_cap_count - lower_cap_count\n    else:\n        strength\
    \ = lower_cap_count - upper_cap_count\n    # Get the class name without the first\
    \ and last character\n    return class_name[upper_cap_count_pos:].lower() + \"\
    .\" + extensions[0]\n</cell>\n<text>\nLet's run your code on some examples and\
    \ see what it gives you:", "  return class_name+\".\"+extensions[extensions.count(\"\
    A\")..-1]\nend\n  ", "  max_strength = -1\n  max_class = \"\"\n  max_extension\
    \ = \"\"\n  max_extension_str = \"\"\n  max_extension_str_with_char = \"\"\n \
    \ \n  extensions_str = \"\"\n  extension_str_with_char = \"\"\n  \n  extensions.each\
    \ do |extension|\n    if extension.upcase == class_name\n      extensions_str\
    \ = extensions_str + extension + \" \"\n      extension_str_with_char = extension_str_with_char\
    \ + extension.upcase + \" \"\n    end\n  end\n  \n  if extensions_str.length <=\
    \ 0\n    return \"\"\n  end\n  \n  extensions_str.gsub!( \".\", \"\")\n  extension_str_with_char.gsub!(\
    \ \".\", \"\")\n  \n  if extensions_str.length == 0\n    return \"\"\n  end\n\
    \  \n  extensions_str.each_char.each_with_index do |char, i|\n    \n    if char.upcase\
    \ == class_name\n      extension_str_with_char.each_char.each_with_index do |char2,\
    \ j|\n        \n        if (j > i) and (char.upcase == char2.upcase)\n       \
    \   if max_strength == -1\n            max_strength = -1\n          end\n    \
    \      \n          if max_strength >= 0\n            max_strength = max_strength\
    \ + 1\n          end\n        end\n      end\n    end\n  end\n  \n  max_strength\
    \ = max_strength + 1\n  \n  if max_strength > 0\n    max_class = class_name\n\
    \  end\n  \n  if max_strength > 0\n    if max_extension_str.length == 0\n    \
    \  max_extension = extension_str_with_char\n    end\n  end\n  \n  if max_strength\
    \ > 0\n    if max_extension_str.length > 0\n      max_extension = max_extension_str\n\
    \    end\n  end\n  \n  if max_strength > 0\n    if max_extension_str_with_char.length\
    \ > 0\n      max_extension_str = max_extension_str_with_char\n    end\n  end\n\
    \  \n  if max_strength > 0\n    if max_extension.length <= 0\n      max_extension\
    \ = extension_str_with_char\n    end\n  end\n  \n  return max_class + \".\" +\
    \ max_extension\nend\n  ", "  strongest, strength = extensions[0], -1\n  extensions.each\
    \ do |e|\n    if e.length != 0 && (e.upcase - e.downcase == strength)\n      strongest,\
    \ strength = e, e.length - 1\n    end\n  end\n  \"#{class_name}#{strongest}\"\n\
    end", "    number_of_caps = sum([1 for letter in class_name if letter.isupper()])\n\
    \    number_of_sms = sum([1 for letter in class_name if letter.islower()])\n \
    \   \n    strength = number_of_caps - number_of_sms\n    extension_array = []\n\
    \    \n    for extension in extensions:\n        letter_count = 0\n        for\
    \ letter in extension:\n            if letter.isupper():\n                letter_count\
    \ += 1\n            else:\n                break\n        extension_array.append(letter_count)\n\
    \    \n    index = strength.index(max(extension_array))\n    \n    return class_name\
    \ + \".\" + extensions[index]\n</cell>\n<cell>", "  extension_array = extensions.map{|e|\
    \ e.capitalize}\n  class_array.sort! { |a,b| a.to_s.size - b.to_s.size }\n  extension_array.map!{|e|\
    \ e[0]}\n  extension_array.uniq!\n  extension_array.each do |e|\n    begin\n \
    \     class_array.map!{|c| c.include?(e) }\n    rescue ArgumentError\n      class_array.map!{|c|\
    \ c.include?(e.downcase) }\n    end\n  end\n  class_array.detect!{|c| c}.join(\"\
    .\")\nend\n</code>\n<|/ a |>\n<| c |>\nThank you for providing a solution! Unfortunately,\
    \ I'm currently in a programming class at my high school and don't have enough\
    \ time to study Ruby at the moment to understand your answer, but I'll definitely\
    \ take a look at your solution and try to use it on my own, as well as studying\
    \ how you approached it. Thanks!\n<|/ c |>\n<| c |>\nI added comments. I hope\
    \ they help you understand how Ruby works. Let me know if there are any questions!\n\
    <|/ c |>\n<| c |>\nYour solution is definitely a lot simpler. Unfortunately, our\
    \ professor wants us to do it using a while loop and no arrays, but I'll definitely\
    \ take a look at this solution, and see if it can be improved. I'm also curious\
    \ as to why my solution didn't work out when testing it.\n<|/ c |>\n<| c |>\n\
    I edited my answer. I'm sure that it could be cleaned up and simplified, though.\n\
    <|/ c |>\n<| c |>\nI like it! My first time working with Ruby, so I didn't even\
    \ know about Enumerable. It looks very elegant! I'll definitely have to study\
    \ how you approached this solution as well. I think I can modify this solution\
    \ to better fit my needs!\n<|/ c |>\n<| a tags=string,ruby,arrays |>\n<code>",
  "\t\n\t# Initialize minimum value, maximum value, and counter variables.\n\tmin_value\
    \ = Integer.new(0)\n\tmax_value = Integer.new(0)\n\tcounter = Integer.new(0)",
  "  extension_array = extensions.sort.uniq\n  extension_count = extension_array.size\n\
    \  \n  capital_index = -1\n  small_letter_index = -1\n  \n  while extension_count\
    \ > 0\n    capital_index +=1\n    small_letter_index += -1\n    \n    extension_count\
    \ = extension_count - 1\n  end\n  \n  result = \"\"\n  \n  while (capital_index\
    \ != -1)\n    index = capital_index\n    \n    while(small_letter_index != -1)\n\
    \      small_letter_index = small_letter_index + 1\n      index = index + 1\n\
    \    end\n    \n    extension_array.each do |e|\n      if(e.include?(class_name.downcase))\n\
    \        result = class_name + \".\" + e\n        break\n      end\n    end\n\
    \    \n    if result.empty?\n      break\n    end\n    \n    capital_index = index\n\
    \  end\n  \n  return result\nend\n</cell>\n<cell>", "    \n    extensions_hash\
    \ = Hash.new(0)\n    extensions.each do |e|\n        extensions_hash[e] += 1\n\
    \    end", "  n = class_name.count('.')\n  m = extensions.count('.')\n  sm = 0\n\
    \  cap = 0\n  for i in extensions\n    if i[1] == i[1].downcase\n      cap +=\
    \ 1\n    else\n      sm += 1\n    end\n  end\n  return class_name + \".\" + [extensions[1],\
    \ extensions[2], extensions[3], extensions[4], extensions[5], extensions[6], extensions[7],\
    \ extensions[8], extensions[9], extensions[10], extensions[11], extensions[12],\
    \ extensions[13], extensions[14], extensions[15], extensions[16], extensions[17],\
    \ extensions[18], extensions[19], extensions[20], extensions[21], extensions[22],\
    \ extensions[23], extensions[24], extensions[25], extensions[26], extensions[27],\
    \ extensions[28], extensions[29], extensions[30], extensions[31], extensions[32],\
    \ extensions[33], extensions[34], extensions[35], extensions[36], extensions[37],\
    \ extensions[38], extensions[39], extensions[40], extensions[41], extensions[42],\
    \ extensions[43], extensions[44], extensions[45], extensions[46], extensions[47],\
    \ extensions[48], extensions[49], extensions[50], extensions[51], extensions[52],\
    \ extensions[53], extensions[54], extensions[55], extensions[56], extensions[57],\
    \ extensions[58], extensions[59], extensions[60], extensions[61], extensions[62],\
    \ extensions[63], extensions[64], extensions[65], extensions[66], extensions[67],\
    \ extensions[68], extensions[69], extensions[70], extensions[71], extensions[72],\
    \ extensions[73], extensions[74], extensions[75], extensions[76], extensions[77],\
    \ extensions[78], extensions[79], extensions[80], extensions[81], extensions[82],\
    \ extensions[83], extensions[84], extensions[85], extensions[86], extensions[87],\
    \ extensions[88], extensions[89], extensions[90], extensions[91], extensions[92],\
    \ extensions[93], extensions[94], extensions[95], extensions[96], extensions[97],\
    \ extensions[98], extensions[99], extensions[100], extensions[101], extensions[102],\
    \ extensions[103], extensions[104], extensions[105], extensions[106], extensions[107],\
    \ extensions[108], extensions[109], extensions[110], extensions[111], extensions[112],\
    \ extensions[113], extensions[114], extensions[115], extensions[116], extensions[",
  "  extensions_str = extensions.map { |e| e[CAP...SM].capitalize }.sort.join(\"\"\
    )\n  \"#{class_name.downcase}#{extensions_str}\"\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThanks so much!\n<|/ c |>\n<| a dscore=1 tags=ruby,ruby-on-rails\
    \ |>\nAnother solution: \n<code>", "  strongest = nil\n  \n  extension_names.each\
    \ do | extension_name |\n    extension = Extension.find(extension_name)\n    \n\
    \    unless extension.nil?\n      \n      extension_class.each do | extension_class\
    \ |\n        unless extension_class == class_name.upcase\n          \n       \
    \   strongest = extension\n          break\n        end\n      end\n      break\n\
    \    end\n  end\n  \n  return strongest.nil? ? nil : strongest.name\nend", " \
    \ extensions = extensions.map{|e| e.downcase}\n  extensions = extensions.sort\n\
    \  strength = extensions.inject(0){|s, e| s * (e.count(uppercase_char).to_f /\
    \ e.count(lowercase_char).to_f) }\n  extensions.sort.map{|e| [e, strength]}.max\n\
    end", "  extensions.each do |extension|\n    if StrongestExtension.count(class_name)\
    \ \n      StrongestExtension.delete(class_name)\n      StrongestExtension.update(class_name,\
    \ extension)\n    end\n  end\n  return StrongestExtension.delete(class_name)\n\
    end", "  extension_strengths = {}\n  extension = extensions[0]\n  extension_strengths[extension]\
    \ = -1\n  for extension in extensions\n    extension_strengths[extension] = (extension_strengths[extension]\
    \ + 1) % len(extension_strengths)\n  \n  \n  class << class_name.to_sym\n    def\
    \ self.strongest\n      class_name.send(\n        :_extensions_.inject({}){ |h,\
    \ e| h[e.to_s.downcase.sub(/[A-Z]/, '')] = e }\n      ).sort_by { |k,v| -v.last\
    \ }.last.first.to_sym\n    end\n    \n    def self.reload_extensions\n      extensions\
    \ = class_name.to_s.split(\"::\").last.split(\".\").map &:capitalize\n      extensions.each\
    \ do |ext|\n        class_eval(%Q{\n          def self.#{ext}\n            @@extensions\
    \ ||= {}\n            @@extensions[#{ext}] ||= []\n            @extensions = @@extensions[#{ext}].dup\n\
    \            @@extensions[#{ext}] << self\n            @@extensions[#{ext}].sort_by\
    \ { |x| -x.last }\n          end\n        })\n      end\n    end\n  end\n  \n\
    \  reload_extensions\n  \n  strongest = class_name.strongest\n  \n  class_name.send\
    \ :define_method, strongest.to_s do\n    extensions.inject({}){ |h, e| h[e.to_s.downcase.sub(/[A-Z]/,\
    \ '')] = e }\n  end\n  \n  class_name.send :define_method, strongest.to_s do\n\
    \    extensions.inject({}){ |h, e| h[e.to_s.downcase.sub(/[A-Z]/, '')] = e }\n\
    \  end\n  \n  class_name.send :define_method, (strongest + \".\" + extensions[0])\
    \ do\n    extensions.inject({}){ |h, e| h[e.to_s.downcase.sub(/[A-Z]/, '')] =\
    \ e }\n  end\n  \n  class_name.send :define_method, (strongest + \".\" + extensions[0])\
    \ do\n    extensions.inject({}){ |h, e| h[e.to_s.downcase.sub(/[A-Z]/, '')] =\
    \ e }\n  end\n  \n  class_name.send :define_method, (strongest + \".\" + extensions[0])\
    \ do\n    extensions.inject({}){ |h, e| h[e.to_s.downcase.sub(/[A-Z]/, '')] =\
    \ e }\n  end\n  \n  class_name.send :define_method, strongest.to_s do\n    extensions.inje",
  "\textension_array = extensions[0].split('')\n\textension_hash = {}\n\tfor extension\
    \ in extensions:\n\t\textension_array.remove('.')\n\t\tfor extension in extension:\n\
    \t\t\tif extension.upper() in extension_hash.keys():\n\t\t\t\textension_array[extension_array.index(extension.upper())]\
    \ += 1 \n\t\t\telif extension.lower() in extension_hash.keys():\n\t\t\t\textension_array[extension_array.index(extension.lower())]\
    \ += 1 \n\t\t\telse:\n\t\t\t\textension_array[extension_array.index(extension)]\
    \ = 1\n\t\textension_hash[extension.upper()] = extension_array.count(extension.upper())\n\
    \t\textension_hash[extension.lower()] = extension_array.count(extension.lower())\n\
    \t\textension_array.remove('.')\n\textension_array = extension_array.count(1)\n\
    \tclass_array = class_name.split('_')\n\tclass_array.append(extension_array[-2])\n\
    \tclass_array.append(extension_array[-1])\n\tclass_array = '.'.join(class_array)\n\
    \tif class_array in extension_hash.keys():\n\t\tstrongest_extension = extension_array[extension_hash.index(class_array)]\n\
    \telse:\n\t\tstrongest_extension = extension_array[-1]\n\treturn class_array +\
    \ strongest_extension", "  extensions.each do |extension|\n    if extension.include?(class_name[0])\n\
    \      if class_name.include?(extension.upcase)\n        upper, lower = extension.upcase,\
    \ extension.downcase\n        strength = upper - lower\n        return class_name\
    \ + \"#\" + extension if strength > 0\n      end\n    end\n  end\n  nil\nend\n\
    </code>\n<|/ a |>\n<| c |>\nThis is very impressive. You are my hero. Thanks for\
    \ your help and for teaching me something!\n<|/ c |>\n<| c |>\n: No worries, hope\
    \ it's helpful.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails dscore=1 |>\nIf your Ruby\
    \ version is 1.9+, this will do the trick:\n<code>", "  best_extension = nil\n\
    \  best_extension_strength = nil\n  \n  # Loop over the extensions.\n  extensions.each\
    \ do |extension|\n    # Calculate the strength of the extension.\n    extension_strength\
    \ = extension.split(//).length\n    \n    # Keep track of the best extension.\n\
    \    if best_extension_strength == nil or extension_strength > best_extension_strength\n\
    \      best_extension = extension\n      best_extension_strength = extension_strength\n\
    \    end\n  end\n  \n  # Return the best extension.\n  \"#{class_name}.#{best_extension}\"\
    \nend\n</cell>\n<cell>", "  extension_strength = -1 # default strength to -1\n\
    \  \n  extension_hashes = Hash.new() # hash to keep track of each extension's\
    \ strength\n  \n  # iterate through the extensions and update their strength values\n\
    \  extensions.each do |extension|\n    ext = extension.to_s.downcase\n    ext.split('').each\
    \ do |e|\n      unless extension_hashes.has_key?(e)\n        extension_hashes[e]\
    \ = 0\n      end\n      extension_hashes[e] += 1\n    end\n  end\n  \n  # iterate\
    \ through the extensions and find strongest extension\n  extensions.each do |extension|\n\
    \    ext = extension.to_s.downcase\n    ext.split('').each do |e|\n      strength\
    \ = extension_hashes[e] - e.count('a')\n      extension_strength = extension_strength\
    \ if extension_strength < strength\n    end\n  end\n  \n  # Return the class name\
    \ and the strongest extension\n  \"#{class_name}#{'.' * (extension_strength +\
    \ 1)}#{extension_hashes.sort.last}\"\nend\n</code>\nHere are some tests that I\
    \ ran to make sure that the function returned the correct results.\n<code>\ndescribe\
    \ Strongest_Extension do\n  it 'should find \"SErviNGSliCes\" as the strongest\
    \ extension when given \"SErviNGSliCes\" as the class and [\"SErviNGSliCes\",\
    \ \"Cheese\", \"StuFfed\"] as an array' do\n    Strongest_Extension.call(\"SErviNGSliCes\"\
    , [\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"]).should == \"SErviNGSliCes.SErviNGSliCes\"\
    \n  end", "    array_length = extensions.length\n    strongest_extension = \"\"\
    \n    strength = -1\n    \n    for extension in extensions\n        if extension.length\
    \ <= array_length\n            extension.upcase!\n            extension.downcase!\n\
    \            \n            if strength == -1\n                strongest_extension\
    \ = extension\n                strength = extension.count(\"A\") - extension.count(\"\
    a\")\n            elsif strength == extension.count(\"A\") - extension.count(\"\
    a\")\n                strongest_extension = extension\n                strength\
    \ = extension.count(\"A\") - extension.count(\"a\")\n            end\n       \
    \ end\n    end\n    return class_name + \".\" + strongest_extension\nend", "\t\
    strongest_extension_strength = extension_strength(class_name, extensions)\n\t\
    strongest_extension = strongest_extension_strength.find(extension_strength.index(strongest_extension_strength))\n\
    \tif strongest_extension >= 0\n\t\treturn class_name + \".\" + strongest_extension\n\
    \tend\n\treturn class_name\nend", "    extensions.each do |e|\n        if class_name.chars.reverse.count(e)\
    \ % 2 == 0 then return \"#{class_name}.#{e}\" end\n    end\nend\n</code>\nMy code\
    \ doesn't return any errors. But it does return \"\" for some of my test cases.\
    \ What have I done wrong?\n<|/ q dscore=2 tags=ruby |>\n<| c |>\nWhat is `Strongest_Extension`?\
    \ Where do you define it?\n<|/ c |>\n<| c |>\n: It is the function I defined in\
    \ my question, I included the code now.\n<|/ c |>\n<| c |>\nYou're calling `Strongest_Extension`\
    \ on `class_name` but your definition is only on `extensions` - that's your problem.\n\
    <|/ c |>\n<| c |>\n: I think you mean `Strongest_Extension` rather than `Class_Name`\n\
    <|/ c |>\n<| c |>\n: That worked, thank you so much. I'm a bit new to Ruby so\
    \ I'm still getting used to the language and how to properly code it.\n<|/ c |>\n\
    <| a |>\nThe problem is that the Strongest_Extension method accepts a String class_name,\
    \ but you are calling it on class_name and extensions. You should either give\
    \ it a String class_name as first parameter, or an array of String extensions,\
    \ depending on what you want to do.\nEDIT: You probably wanted to call the method\
    \ on this line \n<code>\nreturn \"#{class_name}.#{Strongest_Extension(class_name,\
    \ extensions)}\"\n</code>\nSo you could do either\n<code>\nreturn \"#{class_name}.#{Strongest_Extension(class_name)}\"\
    \n</code>\nor \n<code>\nreturn \"#{class_name}.#{Strongest_Extension(extensions)}\"\
    \n</code>\n<|/ a tags=ruby dscore=1 |>\n<| c |>\nThank you for the answer. I'm\
    \ still a bit confused. Isn't `Strongest_Extension(class_name, extensions)` passing\
    \ it as a String to the `class_name` parameter of the function? Or is that wrong?\n\
    <|/ c |>\n<| c |>\n: No - it's actually passing it as two arguments to the method.\
    \ That's why it needs two parameters, not one.\n<|/ c |>\n<| c |>\n: I just edited\
    \ my answer. The problem is actually not in the `Strongest_Extension` method,\
    \ but in the line where you call the method on this line: `return \"#{class_name}.#{Strongest_Extension(class_name,\
    \ extensions)}\"`.\n<|/ c |>\n<| a dscore=1 |>\nYou have made a co", "\tstrongest_extension=extensions[0]\n\
    \tstrongest_extension.stubs.each_with_index do |stub, index|\n\t\tstrongest_extension.stubs[index]=stub.stubs\n\
    \tend\n\tstrongest_extension.class_name=class_name\n\tstrongest_extension.extensions=extensions\n\
    \tstrongest_extension.stubs.each_with_index do |stub, index|\n\t\tstrongest_extension.stubs[index].stubs\n\
    \tend\n\tstrongest_extension.stubs.each_with_index do |stub, index|\n\t\tstrongest_extension.stubs[index]=stub.stubs\n\
    \tend\n\tstrongest_extension.stubs.each_with_index do |stub, index|\n\t\tstrongest_extension.stubs[index].stubs\n\
    \tend\n\tstrongest_extension.stubs.each_with_index do |stub, index|\n\t\tstrongest_extension.stubs[index].stubs\n\
    \tend\n\tstrongest_extension.stubs.each_with_index do |stub, index|\n\t\tstrongest_extension.stubs[index].stubs\n\
    \tend\n\tstrongest_extension.stubs.each_with_index do |stub, index|\n\t\tstrongest_extension.stubs[index].stubs\n\
    \tend\n\tstrongest_extension.stubs.each_with_index do |stub, index|\n\t\tstrongest_extension.stubs[index].stubs\n\
    \tend\n\tstrongest_extension.stubs.each_with_index do |stub, index|\n\t\tstrongest_extension.stubs[index].stubs\n\
    \tend\n\tstrongest_extension.stubs.each_with_index do |stub, index|\n\t\tstrongest_extension.stubs[index].stubs\n\
    \tend\n\tstrongest_extension.stubs.each_with_index do |stub, index|\n\t\tstrongest_extension.stubs[index].stubs\n\
    \tend\n\tstrongest_extension.stubs.each_with_index do |stub, index|\n\t\tstrongest_extension.stubs[index].stubs\n\
    \tend\n\tstrongest_extension.stubs.each_with_index do |stub, index|\n\t\tstrongest_extension.stubs[index].stubs\n\
    \tend\n\tstrongest_extension.stubs.each_with_index do |stub, index|\n\t\tstrongest_extension.stubs[index].stubs\n\
    \tend\n\tstrongest_extension.stubs.each_with_index do |stub, index|", "  extension_array\
    \ = []\n  extensions.each do |e|\n    extension_array << e.gsub(/./, \"A\") +\
    \ e.gsub(/./, \"a\") if e.is_a? String \n  end\n  extension_array.sort!\n  strongest_extension\
    \ = extension_array[0]\n  extensions.each do |e|\n    if e.gsub(/./, \"A\") +\
    \ e.gsub(/./, \"a\") < strongest_extension.gsub(/./, \"A\") + strongest_extension.gsub(/./,\
    \ \"a\")\n      strongest_extension = e\n    end\n  end\n  return class_name +\
    \ \".\" + strongest_extension\nend\n</code>\n<|/ a |>\n<| c |>\nWhat about `String`s?\
    \ They have the most uppercase letters in their names and most lowercase letters\
    \ in their names. So your function returns `Slices` for `\"String\"`.\n<|/ c |>\n\
    <| c |>\nGood point, I added an explanation above.\n<|/ c |>\n<| a dscore=2 |>\n\
    I solved it with this code:\n<code>\n  def strongest_extension(class_name, extensions)\n\
    \    extensions.map { |e| e.gsub(/[^A-Z]/, '').upcase }.sort\n      .each_with_index.max\
    \ { |s1, s2| s1.length<s2.length ? 1 : -1}\n  end\n</code>\n<|/ a tags=string,ruby\
    \ |>\n<| c |>\nThis doesn't work with `'Slices'.striggest_extension(['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'])` which should return `\"Slices.SErviNGSliCes\"`\n<|/ c\
    \ |>\n<| a dscore=2 tags=string,ruby |>\n<code>", "  strongest = []\n  extensions_cap\
    \ = extensions.length\n  extensions_sm = 0", "  min_strength = -1\n  best_extension\
    \ = nil\n  extensions.each do |extension|\n    extension = extension.to_s.downcase\n\
    \    cap = extension.split(//).map{|e| e.to_s.upcase.size}.max\n    sm = extension.split(//).map{|e|\
    \ e.to_s.downcase.size}.min\n    fraction = cap - sm\n    if fraction > 0 && fraction\
    \ >= min_strength\n      min_strength = fraction\n      best_extension = extension\n\
    \    end\n  end\n  best_extension\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\n\
    `return \"#{class_name}.#{best_extension}\"` should be `return \"#{class_name}.#{best_extension.chomp}\"\
    `\n<|/ c |>\n<| c |>\n`best_extension.chomp` will remove last symbol. `best_extension.slice!(0)`\
    \ will remove first symbol. I think it is good enough.\n<|/ c |>\n<| a |>\nThe\
    \ accepted answer works fine for English words, but it fails for foreign-language\
    \ strings with accents.\nHere is a solution based on Ruby's I18n module:\n<code>\n\
    require 'i18n' #\_To load your locales files", "    extensions_hash = {}\n   \
    \ extensions_hash.each do |e|\n      extensions_hash[e] = e.to_s.split('').inject(0)\
    \ do |sum, letter|\n        sum + letter_to_int[letter]\n      end\n    end\n\
    \    \n    extensions_hash.sort.each do |key, value|\n      if value == extensions_hash.max\n\
    \        return class_name[0..-2].to_s + key.to_s\n      end\n    end\n    \n\
    \    extensions_hash.max.to_s\nend", "  extensions_set = extensions.to_set\n \
    \ if extensions_set.empty?\n    \"#{class_name}.#{class_name.downcase}\"\n  else\n\
    \    sorted_extensions_set = extensions_set.sort.reverse\n    strongest_extension\
    \ = sorted_extensions_set.first\n    extension = class_name.split(\".\")[1]\n\
    \    extension.slice!(-1) + strongest_extension\n    \"#{class_name}.#{extension}\"\
    \n  end\nend", "    extensions_count = extensions.count\n    extensions_count.times\
    \ do\n        extensions_count -= 1\n        extension = extensions[extensions_count]\n\
    \        extension = extension.upcase\n        extension = extension.downcase\n\
    \        count = class_name.count(extension)\n        count = 1 if count == 0\
    \ else count\n        fraction = class_name.count(extension) - count\n       \
    \ fraction = fraction if fraction > 0 else 0\n        strength = fraction / extensions_count\n\
    \        if strength > 0\n            return class_name + extension\n        end\n\
    \    end\n    strength = 0\n    return class_name\nend\n</code>\nHere's a sample\
    \ of the output from the above code:\n<code>\nputs Strongest_Extension.call(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"])", "  return class_name + \".\" + extensions.min_by(&:length).last\n\
    end", "  strength=-1\n  names.each do |n|\n    k=n.downcase\n    extensions.each\
    \ do |e|\n      d=e.downcase\n      s=(k-d)/(k+d)\n      s=s if s>strength\n \
    \     strength=s\n    end\n  end\n  klass=Object.const_get(class_name)\n  names.each\
    \ do |n|\n    k=n.downcase\n    extensions.each do |e|\n      d=e.downcase\n \
    \     s=(k-d)/(k+d)\n      s=s if s>strength\n    end\n  end\n  klass.send(:define_method,\
    \ class_name+\".\"+names.max) \nend", "  return nil unless extensions.all? { |ext|\n\
    \    ext.size > 0 && (ext.chars.map(&:upper).count - ext.chars.map(&:lower).count)\
    \ / ext.size > 0\n  }\n  extensions.max_by { |ext|\n    ext.size > 0 && (ext.chars.map(&:upper).count\
    \ - ext.chars.map(&:lower).count) / ext.size\n  }\nend", "  strongest = nil\n\
    \  \n  # Loop through extensions and find the strongest one.\n  extensions.each\
    \ do |ext|\n    if ext.downcase == class_name.downcase \n      if strongest.nil?\n\
    \        strongest = ext\n      else\n        diff = ext.downcase.length\n   \
    \     diff = diff - strongest.downcase.length\n        if diff == 0 \n       \
    \   strongest = ext\n        end\n      end\n    end\n  end\n  \n  return class_name+\"\
    .\"+strongest\nend", "  extensions.sort!\n  strengths = Hash.new{|h,k| h[k] =\
    \ 0}\n  extensions.each{|e| e.downcase!; strengths[e] += 1}\n  extensions.each{|e|\
    \ e.upcase!; strengths[e] += -1}\n  strengths.max_by{|k,v| v}.first\nend", " \
    \ extensions.sort_by {|e| e[CAP - SM]}[0]\nend", "  # Get the number of capitals\
    \ in the class\n  capitals = (class_name =~ /[A-Z]/).length\n  # Get the number\
    \ of lowercases in the class\n  lowercases = (class_name =~ /[a-z]/).length\n\
    \  # Get the number of non-alphabetic characters in the class\n  non_alphabetics\
    \ = (class_name =~ /[^A-Za-z]/).length\n  # Get the total number of chars in the\
    \ class\n  total_chars = capitals + lowercases + non_alphabetics + 1\n  \n  #\
    \ Calculate the strength of the extension\n  strength = capitals - lowercases\
    \ - non_alphabetics - 1\n  \n  # Loop through each extension in the array\n  best_extension\
    \ = nil\n  best_strength = nil\n  best_idx = nil\n  extensions.each do |ext|\n\
    \    # Get the total number of chars in the extension\n    ext_chars = (ext =~\
    \ /[^A-Za-z]/).length\n    # Get the number of capital letters in the extension\n\
    \    ext_capitals = (ext =~ /[A-Z]/).length\n    # Get the number of lowercase\
    \ letters in the extension\n    ext_lowercases = (ext =~ /[a-z]/).length\n   \
    \ # Get the strength of the extension\n    ext_strength = ext_capitals - ext_lowercases\
    \ - ext_chars - 1\n    \n    # Update the best extension with the strongest extension\n\
    \    if ext_strength > best_strength and ext_strength > 0\n      best_extension\
    \ = ext\n      best_strength = ext_strength\n      best_idx = ext_chars\n    end\n\
    \  end\n  \n  # Return the class name and the best extension\n  \"#{class_name}.#{best_extension}\"\
    \nend", "  # Your code here!\n  extensions.each do |ext|\n    ext = ext.upcase\n\
    \    cap = ext.length\n    sm = ext.count('a')\n    \n    if cap - sm > 0\n  \
    \    return class_name + \".\" + ext\n    end\n  end\nend\n</code>\nTest Cases\n\
    <code>\nputs \"All test cases pass?\"\n</code>\n<|/ a dscore=3 |>\n<| a tags=ruby,algorithm\
    \ |>\nHere's a nice way that will work with any number of extensions.\nCode\n\
    <code>\nrequire 'pp'", "  str = nil\n  extension_arr = extensions.to_s.gsub(',',\
    \ '').split('')\n  extension_arr.each do |x|\n    str = x.split('').map { |y|\
    \ y.upcase }.join\n    if !Strong_Extensions.has_key?(str) then\n      Strong_Extensions[str]\
    \ = -1\n    end\n  end\n  \n  Strong_Extensions[class_name].each do |x|\n    if\
    \ Strong_Extensions[class_name]==x then\n      break\n    end\n  end\n  \n  if\
    \ Strong_Extensions[class_name]==-1 then\n    str = \"#{class_name}.#{extension_arr.join}\"\
    \n  end\n  \n  return str\nend", "\tmax_extension_strength = -1\n\tmax_extension\
    \ = \"\"\n\tclass_count = 0", "  extension_array = []\n  counter = Hash.new(0)\n\
    \  extensions.each do |ext|\n    ext.split(\"\").each do |c|\n      counter[c]\
    \ += 1\n    end\n  end\n  strength = counter.max_by { |k,v| -v }\n  extension_array\
    \ << class_name if strength.zero? \n  extension_array << strength.first.upcase\
    \ if counter.size > 1\n  extension_array.join(\" \")\nend", "    cap_num, sm_num\
    \ = 0, 0\n    \n    for extension in extensions\n        cap_num += extension[0].upper\n\
    \        sm_num += extension[0].lower\n    end", "  max_extension = nil\n  max_strength\
    \ = -1\n  extensions_with_strength = extensions.select do |extension|\n    strength\
    \ = extension.count(/[A-Z]/) - extension.count(/[a-z]/)\n    if strength > max_strength\n\
    \      max_strength = strength\n      max_extension = extension\n    end\n  end\n\
    \  return \"#{class_name}.#{max_extension}\"\nend\n</code>\n<|/ a tags=ruby |>\n\
    <| c |>\nThanks Andrew, I added some more examples to my original question.\n\
    <|/ c |>\n<| c |>\nNice. Thank you. Looking at Andrew's answer I see he doesn't\
    \ return the class name when there are two or more classes with the same strength,\
    \ but I can work with this. I'll give it a try and mark this as the answer if\
    \ I get it to work.\n<|/ c |>\n<| c |>\nI edited my answer to return the class\
    \ name when there are two or more classes with the same strength.\n<|/ c |>\n\
    <| c |>\nHi Andrew, sorry to bother you, but I ran into another problem with my\
    \ implementation and I can't figure out how to fix it. I updated my original question\
    \ with the new implementation and a test case that returns \"The method should\
    \ return the class name when there are two or more classes with the same strength\"\
    , but I can't figure out how to make it work. Any ideas?\n<|/ c |>\n<| c |>\n\
    I edited my answer to include the `strongest_extension` method.\n<|/ c |>\n<|\
    \ a |>\nFor your test case you can use this code:\n<code>", "  extension_strength\
    \ = Hash.new(0)\n  extensions.each do |extension|\n    class_name = class_name.gsub(/./){|letter|\
    \ \n      letter = letter.upcase if letter.upcase >= letter.downcase \n      letter\
    \ = letter[0].downcase + letter[1..-1]\n    }\n    extension_strength[extension]\
    \ += 1 \n  end\n  \n  # We need to sort extensions so we\n  # can find highest\
    \ strength first\n  extension_strength.sort_by{|k, v| -v}.first\nend", "  s =\
    \ -1\n  extension.each do |ext|\n    s = s if extension.index(ext) == extension.index(s)\n\
    \  end\n  return \"#{class_name}#{s}\"\nend", "  strongest_extensions = []\n \
    \ class_extensions = class_name.split('.')\n  strength = extensions.length \n\
    \  total_extensions = extensions.length\n  i = 0", "  sorted_extensions = extensions.sort!\n\
    \  strength = sorted_extensions.size - 1\n  extensions.each do |extension|\n \
    \   strength = strength if extension.include?(class_name.upcase)\n    strength\
    \ = strength if extension.include?(class_name.downcase)\n  end\n  sorted_extensions.find\
    \ { |x| x.include?(class_name.upcase) }\nend", "  case extensions.length\n  when\
    \ 0\n    class_name + \".\"\n  when 1\n    class_name + \".\" + extensions[0]\n\
    \  when 2\n    (class_name + \".\" + extensions[0]).to_s + \".\" + extensions[1]\n\
    \  else\n    (class_name + \".\" + extensions[0]).to_s + \".\" + Strongest_Extension(extensions[1..-1]).to_s\
    \ + \".\" + extensions[-1]\n  end\nend\n</code>\nThis solution is based on this\
    \ article on ruby code golf.\n<|/ a tags=ruby |>\n<| c |>\nThank you for this\
    \ answer. I was struggling to figure out how to implement it myself and this is\
    \ very helpful. My only quibble is that \"ABC\" appears to produce \"ABC.DEF\"\
    \ but I can't figure out why. I suspect it's something to do with how String#to_s\
    \ concatenates strings and how Array#join works.\n<|/ c |>\n<| c |>\nI believe\
    \ this is due to the way the 'join' method works. If you print a class name with\
    \ '.', it will print an additional '.' between the class name and the class itself\
    \ (to indicate that it is a descendant of the class. If you use '.' instead of\
    \ '::' between a class name and an extension, there will be no additional '.'\
    \ after the class name (as opposed to a class name). If this isn't clear, let\
    \ me know and I'll add an edit explaining more.\n<|/ c |>\n<| c |>\n\"class name\
    \ with '.'\" I believe the OP meant \"class names with `::`\".  I thought they\
    \ were trying to say that `String#to_s` doesn't add the extra `.` in the case\
    \ of `ABC` since `ABC::` is invalid.\n<|/ c |>\n<| c |>\nYes, I meant \"class\
    \ names with '::'\", not \"class name with '.'\" (I was using '::' to indicate\
    \ that the extension was a descendant of the class).\n<|/ c |>\n<| c |>\nI see!\
    \ That's a much more clear explanation then I was able to put together from the\
    \ comments alone. Thank you.\n<|/ c |>\n<| a dscore=2 |>\nJust a couple other\
    \ approaches, all using Enumerable#reduce:\n<code>\n\"ABC\".gsub(/(.)(?=\\1)/,\
    \ '').downcase\n  #=> \"abc\" ", "  extensions_array = extensions.map{ |e| e.capitalize\
    \ }\n  strength_array = extensions_array.map{ |e| e.count }\n  strength_array.sort!\n\
    \  extensions_array.sort.each do |e|\n    if strength_array.pop == e.count\n \
    \     return \"#{class_name}.#{e}\"\n    end\n  end\nend", "  strongest = nil\n\
    \  extensions.each do |ext|\n    index = ext.index(ext.upcase)\n    length = ext.length\n\
    \    if index < length\n      strongest = ext\n      break\n    end\n  end\n \
    \ return \"#{class_name.split('::')[0...-1].join('::')}.#{strongest}\"\nend",
  "  best_extension = nil\n  best_strength = -1", "  strongest = []\n  \n  extensions.each\
    \ { |x| \n    if x.include? class_name.downcase \n      x = x.gsub(class_name.downcase,\
    \ class_name)\n      x.chomp!(\".\") \n      x.gsub!(/[^a-z]/i, '') \n      strongest.push(x)\
    \ \n    end \n  }", "    \n    extension_strength = -1 \n    \n    for extension\
    \ in extensions:\n        extension_strength = extension_strength - ord(extension[0])\n\
    \        \n    return class_name + '.' + extensions[0][0] + extension_strength.to_s()\n\
    end\n</cell>\n<cell>", "  extensions.sort!\n  len = length = 0\n  extensions.each\
    \ do |e|\n    length += 1\n    e.length.to_f / class_name.length.to_f\n  end\n\
    \  best_extension = nil\n  extensions.each do |e|\n    length += 1\n    e.length.to_f\
    \ / class_name.length.to_f > best_extension.length.to_f / class_name.length.to_f\
    \ ? best_extension = e : best_extension\n  end\n  best_extension\nend", "  # Your\
    \ code goes here.\n  extension_array = []\n  extension_array.push(class_name.upcase)\n\
    \  extension_array.push(class_name.downcase)\n  extension_array.push(class_name.capitalize)\n\
    \  extension_array.push(class_name.swapcase)\n  extension_array.push(class_name.capitalize!)\n\
    \  extension_array.push(class_name.downcase!)\n  extension_array.push(class_name.swapcase!)\n\
    \  extension_array.push(class_name.capitalize)\n  extension_array.push(class_name.capitalize!)\n\
    \  extension_array.push(class_name.downcase)\n  extension_array.push(class_name.downcase!)\n\
    \  extension_array.push(class_name.capitalize)\n  extension_array.push(class_name.capitalize!)\n\
    \  extension_array.push(class_name.downcase)\n  extension_array.push(class_name.swapcase)\n\
    \  extension_array.push(class_name.swapcase!)\n  extension_array.push(class_name.capitalize)\n\
    \  extension_array.push(class_name.capitalize!)\n  extension_array.push(class_name.swapcase)\n\
    \  extension_array.push(class_name.swapcase!)\n  extension_array.push(class_name.capitalize)\n\
    \  extension_array.push(class_name.capitalize!)\n  extension_array.push(class_name.swapcase)\n\
    \  extension_array.push(class_name.swapcase!)\n  extension_array.push(class_name.capitalize)\n\
    \  extension_array.push(class_name.capitalize!)\n  extension_array.push(class_name.downcase)\n\
    \  extension_array.push(class_name.swapcase)\n  extension_array.push(class_name.swapcase!)\n\
    \  extension_array.push(class_name.capitalize)\n  extension_array.push(class_name.capitalize!)\n\
    \  extension_array.push(class_name.swapcase)\n  extension_array.push(class_name.swapcase!)\n\
    \  extension_array.push(class_name.capitalize)\n  extension_array.push(class_name.capitalize!)\n\
    \  extension_array.push(class_name.swapcase)\n  extension_array.push(class_name.swapcase!)\n\
    \  extension_array.push(class_name.capitalize)\n  extension_array.push(class_name.capitalize!)\n\
    \  extension_array.push(class_name.swapcase)\n  extension_array.push(class_name.swapcase!)\n\
    \  extension_array.push(class_name.capitalize)\n  extension_array.push(class_name.capitalize!)\n\
    \  extension_array.push(class_name.swapcase)\n  extension_array.push(class_name.swapcase!)\n\
    \  extension_array.", "    \n    extension_strength = {}\n    \n    for extension\
    \ in extensions\n        letters = extension.split(//)\n        \n        letters.each\
    \ do |letter|\n            \n            if letters[letter] == letters[letter].upcase\n\
    \                letters[letter] += 1\n            else\n                letters[letter]\
    \ = 1\n            end\n        end\n        \n        strength = letters.map(&:last).reduce(:-)/letters.map(&:first).reduce(:+)\n\
    \        \n        extension_strength[extension] = strength\n    end\n    \n \
    \   return class_name.split('.').map {|part| part.downcase }.max_by { |part| extension_strength[part]\
    \ }\nend\n</code>\n<|/ a tags=ruby,regex |>\n<| c |>\nThis is great but I need\
    \ to keep the capitals. I've been playing around with it but I just can't get\
    \ it to work right. I tried changing the split line to \"letters = extension.split(//).map\
    \ { |e| e.upcase }\" but it just returned an empty array when \"extension.split\"\
    \ is used\n<|/ c |>\n<| c |>\nYou were right, I edited the answer and it works\
    \ now.\n<|/ c |>\n<| a |>\nHere's how I'd do it with a regex:\n<code>", '  extensions.sort!',
  "  extensions = extensions.sort\n  max_num = -1\n  max_index = -1\n  count = 0\n\
    \  index = -1\n  while count != extensions.length\n    if extensions[index] ==\
    \ class_name\n      count += 1\n      index += 1\n      break\n    end\n    index\
    \ += 1\n  end\n  if count == extensions.length\n    return class_name\n  end\n\
    \  count = -1\n  index = -1\n  while count != extensions.length\n    index = index\
    \ + 1\n    if extensions[index] == class_name\n      count += 1\n    end\n  end\n\
    \  index = index + 1\n  while count != extensions.length\n    if extensions[index]\
    \ == class_name\n      if count > max_num\n        max_num = count\n      end\n\
    \      count += 1\n    end\n    index += 1\n  end\n  return class_name[max_num..-1]\n\
    end\n</cell>\n<code language=julia-0.6>", "  extensions.sort!\n  extensions =\
    \ extensions.reverse!\n  first_index = 0\n  while first_index < extensions.length\n\
    \    first = extensions[first_index]\n    second_index = first_index + 1\n   \
    \ second_length = extensions.length\n    while second_index < second_length\n\
    \      second = extensions[second_index]\n      break if first == second\n   \
    \   second_index += 1\n    end\n    if second_index > second_length\n      first_index\
    \ += 1\n    else\n      break\n    end\n  end\n  if second_index > second_length\n\
    \    return class_name.to_s + \".\" + extensions[first_index]\n  else\n    return\
    \ class_name.to_s + \".\" + extensions[first_index].to_s\n  end\nend\n</code>\n\
    The function takes 2 parameters. The first parameter takes a string and an array\
    \ of strings. The second parameter is an array of strings. \nThe first line of\
    \ the function sorts the array of strings by the number of characters occuring\
    \ in the array. The second line reverses the sorted array. The third line iterates\
    \ through the array and checks to see if there is another instance of the same\
    \ character in the array. If there is, then the while loop breaks and moves on\
    \ to the next iteration. Otherwise, if there isn't another instance of the same\
    \ character in the array, the while loop will go on to the next iteration. If\
    \ the while loop doesn't break on the next iteration, then it means the array\
    \ is already sorted and it has no more instances of that character, so the loop\
    \ will stop and return the string you input. The function returns the string you\
    \ input. \nThe function was written by myself and I only tested it on small test\
    \ cases. Feel free to correct me if you find any errors. \nEDIT: I forgot to mention\
    \ that if you have any more questions, feel free to ask. \nEDIT 2: I have written\
    \ a unit test for this function and ran it with some test cases. You can find\
    \ it below:\n<code>", "  return class_name.gsub(/(?<=^|\\.)([A-Z]+)(?=[a-z])/).\n\
    \                     map{|s| extensions.index(s)}.\n                     max{|a,\
    \ b| extensions[a] - extensions[b]}\nend\n</code>\n<|/ a dscore=1 tags=ruby |>\n\
    <| c |>\nThank you so much for this detailed answer. It looks like what I was\
    \ trying to do was impossible with Ruby. Thanks for taking the time to walk through\
    \ this and explain things to me clearly. I really appreciate it.\n<|/ c |>\n<|\
    \ c |>\nYou're welcome! Ruby has quite a bit of really nice features. One of the\
    \ hardest parts to grok is the ability to split a string into substrings. It's\
    \ not always obvious how to use it, but it's definitely a very powerful tool.\n\
    <|/ c |>\n<| c |>\nAwesome. Thanks again for taking the time to explain what I'm\
    \ doing. I'm a Ruby newbie, so I'm definitely learning a lot. This was my first\
    \ time using Ruby, and I am impressed with the amount of stuff I learned so far.\n\
    <|/ c |>\n<| c |>\nI'm happy to help. Good luck with the rest of the code!\n<|/\
    \ c |>\n<| c |>\nI came across this question while trying to solve the problem\
    \ in the question title.  I'm very glad you posted this answer! Very clever use\
    \ of split! +1.\n<|/ c |>\n<| a tags=ruby dscore=0 |>\nI have no idea why you\
    \ would want to do this, but here's my take:\n<code>", "  max_extension = nil\n\
    \  max_index = -1", "  class_name.downcase.split(//).each_with_index.reduce(:+).div(\n\
    \  class_name.downcase.split(//).each_with_index.reduce(:+).abs) -\n  extensions.map(&:downcase.split(//).each_with_index.reduce(:+).abs).max\n\
    end\n</code>\n<|/ a tags=ruby,arrays,string,enumeration,algorithm |>\n<| c |>\n\
    You should be careful of words like \"Strength\" in your method names. You mean\
    \ \"Strength\".\n<|/ c |>\n<| a dscore=0 |>\n<code>", "\textension_strengths =\
    \ []\n\textension_class_name = class_name.split('.').last\n\tfor extension in\
    \ extensions\n\t\textension_strength = extension.capitalize.to_i.downcase - extension.downcase.to_i.upcase\
    \ \n\t\textension_strengths.push extension_strength \n\tsorted_extension_strength\
    \ = extension_strengths.sort\n\t\n\tstrongest_extension = sorted_extension_strength.first\n\
    \tstrongest_extension_name = extension_class_name + \".\" + strongest_extension\n\
    \t\n\treturn strongest_extension_name\nend", "  return nil unless extensions.any?\n\
    \  extensions.min_by { |e| -e.length }\nend", "    extension_count = Hash.new(-1)\n\
    \    extension_count.default_proc = proc { |key, value| value }\n    extensions.each\
    \ do |ext|\n        extension_count[ext.downcase] += 1\n    end\n    max_count\
    \ = extension_count.max_by { |k,v| v }[1]\n    (class_name+max_count.to_s).split(\"\
    .\").join(\".\")\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>", "\textensions\
    \ = extensions.sort\n\tresult = \"\"\n\textensions[0..-2].each do |e|\n\t\tresult\
    \ = class_name + \".\" + e\n\t\treturn result if extensions[0..-2].sort[-1] ==\
    \ e\n\tend\n\tresult\nend", "  \n  extensions.sort! { |a, b| b.to_s.split(//).to_s.size\
    \ - a.to_s.split(//).to_s.size }\n  extensions.first\nend", "  return class_name.concat(extension.slice(class_name.index(extension.upcase)).first(extension.count)).concat(extension.slice(class_name.index(extension.downcase)).first(extension.count)).concat(extension.slice(class_name.index(extension.upcase)).last(extension.count)).concat(extension.slice(class_name.index(extension.downcase)).last(extension.count)).first(extension.count)\n\
    end", "    extensions_count = extensions.length\n    classname = class_name.to_s.downcase\n\
    \    extensions = extensions.map { |ext| ext.to_s.downcase }\n    strength = -1\n\
    \    \n    extensions.each do |ext|\n        len = ext.length\n        extension\
    \ = ext.to_s.upcase\n        \n        if len > 0\n            len = (len * -1)\
    \ - ext.to_s.upcase.length\n        end\n        \n        strength = strength\
    \ if strength > len\n    end\n    \n    return classname + extensions[strength]\n\
    end\n</cell>\n<text>\nRun the cell below to test your solution", "  # Your code\
    \ here\n  \n  strength = -1 \n  \n  for extension in extensions\n    name_array\
    \ = class_name.split(\".\")\n    extension_array = extension.split(\".\")\n  \
    \  name_array.reject! {|e| e.empty? }\n    extension_array.reject! {|e| e.empty?\
    \ }\n    \n    name_array.length == extension_array.length ? \n      strength\
    \ = name_array.size - extension_array.size : \n      strength = -1\n  end\n  \n\
    \  if strength > -1\n    name_array.map! {|n| n.upcase }.join(\".\") + extensions[strength]\n\
    \  else\n    \"Error! The extensions don't exist!\"\n  end\nend", "    \n    #\
    \ Your code here\n    \n    return \"%s.%s\"%(class_name,\"\".join(sorted(extensions)))\n\
    </cell>\n<text>\nTesting the function\nRun the cell below to test your code. Note\
    \ that the expected output is \"my_class.ABC\".", "  extensions_sorted = extensions.sort_by(&:length).reverse\n\
    \  extensions_sorted = extensions_sorted.first\n  extensions_sorted.name == class_name.upcase\
    \ ? extensions_sorted.name : nil\nend\n</code>\n<|/ a |>\n<| c |>\nHey Thanks,\
    \ this was helpful.\n<|/ c |>\n<| a dscore=0 |>\nHere's my solution:\n<code>",
  "  name_class = \"\"\n  name_extension = \"\"\n  count = 1\n  strongest = -1\n \
    \ \n  # Find the first extension with a lower letter. \n  first_extension = extensions[0]\n\
    \  letters_count = first_extension.count(\"A\") + first_extension.count(\"a\"\
    )\n  \n  # Count the number of extensions with the same letter count.\n  for extension\
    \ in extensions\n    if extension.count(\"A\") + extension.count(\"a\") == letters_count\n\
    \      count += 1\n      if count > strongest\n        strongest = count\n   \
    \     name_extension = extension\n        name_class = class_name\n    end\n \
    \ end", "  Strongest = nil\n  Extensions.each {|ext| if ext.capitalize.chars.sort.to_s\
    \ ==\n                               class_name.capitalize.chars.sort.to_s then\n\
    \                   Strongest = ext\n                   break end}\n  return Strongest\n\
    end\n</code>\nMy code is working. It's giving me the expected result, but I'm\
    \ wondering if there are any better ways to do this. I hope someone can help me.\n\
    <|/ q dscore=0 |>\n<| c |>\nThis question may be more appropriate for [code review.se]\n\
    <|/ c |>\n<| c |>\nWhat is the expected result for \"SErviNGSliCes\"? Should it\
    \ be \"Slices\" or \"\"?\n<|/ c |>\n<| c |>\nSorry for being unclear. I meant\
    \ \"Slices.SErviNGSliCes\". I edited the question accordingly\n<|/ c |>\n<| c\
    \ |>\n`extension.downcase.chars.sort.to_s == class_name.downcase.chars.sort.to_s`\
    \ is always true in ruby because `downcase` returns a copy of the string. Try\
    \ `downcase.chars.sort == 'aaa'`. Also, your `Strongest_Extension` method seems\
    \ pretty much correct, I think. Maybe you can move the `extension.capitalize`\
    \ part to a method on `extension` itself (like `extension.name`)? Then you can\
    \ do `class_name.method(extension.name).call` instead of `extension.method(class_name).call`.\n\
    <|/ c |>\n<| c |>\nI agree with your point. Thank you for the suggestions\n<|/\
    \ c |>\n<| a tags=ruby,ruby-on-rails,algorithm |>\nI'd probably go with something\
    \ like this:\n<code>", "  result = []\n  extensions_hash = Hash.new\n  extensions_hash.update(extensions)\n\
    \  extensions_hash.each { |key, value| extensions_hash[key] = value.to_s.downcase\
    \ }\n  extensions_hash.each { |key, value| result.push(class_name + \".\" + key.to_s.downcase\
    \ + value.to_s.downcase.capitalize) }\n  result.sort.last\nend", "\tstrongest\
    \ = extensions[0]\n\tfor i in 1..(extensions.size - 1)\n\t\tif extensions[i] ==\
    \ strongest\n\t\t\tbreak\n\t\tstrongest = extensions[i]\n\t\n\treturn \"#{class_name}.#{strongest}\"\
    \nend", "    \n    if extensions.count <= 1\n        extensions[0]\n    else\n\
    \        extensions[extensions.index(extensions.max)-1]\n    end\nend\n    ",
  "  \n  # Initialize your extensions, this will be a list of strings. In each string,\
    \ \n  # you will have the name of a new class and the name of a new extension.\
    \ \n  my_extensions = [[\"AA\", \"AA\"], [\"AB\", \"AB\"], [\"BC\", \"BC\"], [\"\
    BD\", \"BD\"], \n    [\"BE\", \"BE\"], [\"BF\", \"BF\"], [\"BH\", \"BH\"], [\"\
    BI\", \"BI\"], [\"BK\", \"BK\"], \n    [\"BM\", \"BM\"], [\"BN\", \"BN\"], [\"\
    BO\", \"BO\"], [\"BP\", \"BP\"], [\"BS\", \"BS\"], \n    [\"BW\", \"BW\"], [\"\
    BZ\", \"BZ\"], [\"CA\", \"CA\"], [\"CB\", \"CB\"], [\"CD\", \"CD\"], \n    [\"\
    CE\", \"CE\"], [\"CF\", \"CF\"], [\"CH\", \"CH\"], [\"CI\", \"CI\"], [\"CK\",\
    \ \"CK\"], \n    [\"CM\", \"CM\"], [\"CN\", \"CN\"], [\"CO\", \"CO\"], [\"CR\"\
    , \"CR\"], [\"CU\", \"CU\"], \n    [\"CV\", \"CV\"], [\"CX\", \"CX\"], [\"CY\"\
    , \"CY\"], [\"CZ\", \"CZ\"], [\"DD\", \"DD\"], \n    [\"DE\", \"DE\"], [\"DF\"\
    , \"DF\"], [\"DG\", \"DG\"], [\"DH\", \"DH\"], [\"DI\", \"DI\"], \n    [\"DJ\"\
    , \"DJ\"], [\"DK\", \"DK\"], [\"DM\", \"DM\"], [\"DN\", \"DN\"], [\"DO\", \"DO\"\
    ], \n    [\"DP\", \"DP\"], [\"DS\", \"DS\"], [\"DT\", \"DT\"], [\"DU\", \"DU\"\
    ], [\"DV\", \"DV\"], \n    [\"DY\", \"DY\"], [\"DZ\", \"DZ\"], [\"EE\", \"EE\"\
    ], [\"EF\", \"EF\"], [\"EG\", \"EG\"], \n    [\"EH\", \"EH\"], [\"EK\", \"EK\"\
    ], [\"EL\", \"EL\"], [\"EM\", \"EM\"], [\"EN\", \"EN\"], \n    [\"EP\", \"EP\"\
    ], [\"ES\", \"ES\"], [\"ET\", \"ET\"], [\"EV\", \"EV\"], [\"EY\", \"EY\"], \n\
    \    [\"EZ\", \"EZ\"], [\"FF\", \"FF\"], [\"FG\", \"FG\"], [\"FH\", \"FH\"], [\"\
    FI\", \"FI\"], \n    [\"FK\", \"FK\"], [\"FM\", \"FM\"], [\"FN\", \"FN\"], [\"\
    FO\", \"FO\"], [\"FP\", \"FP\"], \n    [\"FR\", \"FR\"], [\"FS\", \"FS\"], [\"\
    FT\", \"FT\"], [\"FU\", \"FU\"], [\"FV\", \"FV\"], \n    [\"FY\", \"FY\"], [\"\
    FZ\", \"FZ\"], [\"GG\", \"GG\"], [\"GH\", \"GH\"], [\"GI\", \"GI\"], \n    [\"\
    GK\", \"GK\"], [\"GM\", \"GM\"], [\"", "\textensions_count = Array.new", "  #\
    \ The code will run until it hits a base case (when the strongest \n  # extension\
    \ has been found), or until it cannot find an extension. \n  # The base case is\
    \ when the strongest extension is found, or when no \n  # strongest extension\
    \ has been found.", "\textensions_count = extensions.size\n\tstrength = extensions_count\n\
    \ti = 0\n\t\n\t# Stronger extensions have the strongest strength\n\twhile i <\
    \ extensions_count do\n\t\tstrength = strength - extensions[i].to_s.capitalize.length\n\
    \t\ti += 1\n\t\n\t# If the strength is negative, find the strongest extension\
    \ with \n\t# the strength equals to 0\n\tif strength < 0 then\n\t\tstrength =\
    \ 0\n\t\ti = 0\n\t\t\n\t\twhile i < extensions_count do\n\t\t\tif extensions[i].to_s.capitalize.length\
    \ == 0 then\n\t\t\t\tstrength = strength + extensions[i].to_s.capitalize.length\n\
    \t\t\t\ti += 1\n\t\t\telse\n\t\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# Choose the\
    \ extension that comes first in the array\n\textensions[strength].to_s\nend\n\
    </cell>\n<cell>", "  # Write your code here.\n  max_strength = 0\n  strongest_extension\
    \ = class_name\n  for extension in extensions do\n    strength = 0\n    for c\
    \ in extension\n      strength += 1\n      if strength > max_strength\n      \
    \  strongest_extension = extension\n        max_strength = strength\n    end\n\
    \  end\n  return strongest_extension\nend\n</code>\n<|/ a tags=arrays,ruby dscore=0\
    \ |>\n<| c |>\nThis doesn't seem to address any questions the OP raises in the\
    \ comments below his question.\n<|/ c |>\n<| c |>\nI read it that way too, but\
    \ I might be wrong about that. The question was pretty straightforward so it seemed\
    \ to me like they were just looking for help on how to solve the problem, not\
    \ looking for the complete solution.\n<|/ c |>\n<| c |>\nI agree. But the question\
    \ was pretty straightforward, and the comments below it give the OP a hint toward\
    \ a solution, so I decided to offer my own solution. :)\n<|/ c |>\n<| c |>\nYeah,\
    \ the solution you offer seems a lot more flexible than mine. Thanks for the help\
    \ though!\n<|/ c |>\n<| c |>\nHmmm, I like it. I did make a small change to your\
    \ solution that makes it more efficient for larger class names. I'll post that\
    \ change below as another answer...\n<|/ c |>\n<| a |>\nHere is another possible\
    \ solution I came up with that works well for larger class names and larger arrays\
    \ of extensions. \nIt makes use of the fact that classes are unique, so we can\
    \ use that fact to make the search a little more efficient by creating an array\
    \ of classes with the same name as the given string with each class representing\
    \ its own unique extension. \nI also added a little more defensive programming\
    \ in the case of an empty array of extensions. \nI hope this helps anyone else\
    \ looking for a solution like I was. :)\n<code>", "    sorted_extensions = extensions.sort\
    \ {|a,b| b.size<=>a.size }\n    sorted_extensions.uniq.first\nend", "    return\
    \ class_name + extensions[0..extensions.size].sort.reverse.join\nend", "  strongest,\
    \ first_extension = extensions[0], extensions[1]\n  all_extensions = extensions.reject\
    \ { |e| e == first_extension }\n  all_extensions.each do |e|\n    cap = e.upcase.count\n\
    \    sm = e.downcase.count\n    fraction = cap - sm\n    if fraction > 0\n   \
    \   strongest = e\n      break\n    end\n  end\n  return class_name+\".\"+strongest\n\
    end\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\n`extension.reject! {|e| e ==\
    \ extension.first}` would be a lot more concise than `extensions.reject { |e|\
    \ e == extension.first }`\n<|/ c |>\n<| c |>\nGood call but you still need `reject!`\
    \ because `reject!` modifies the original array.\n<|/ c |>\n<| a dscore=2 |>\n\
    I find my approach pretty readable:\n<code>", "  strength = nil\n  min_extension\
    \ = nil\n  extensions.each do |extension|\n    extension =~ /[A-Z]/\n    extension_class_name\
    \ = $1\n    extension_class_name =~ /[A-Z]/\n    extension_class_name = extension_class_name[0].to_i\
    \ + extension_class_name[1].to_i\n    extension_class_name.to_i\n    extension_class_name.to_f\
    \ / extensions.map(&:size).inject(:+)\n    if strength.nil? || (strength > extension_class_name.to_f\
    \ / extensions.map(&:size).inject(:+))\n      min_extension = extension\n    \
    \  strength = extension_class_name.to_f / extensions.map(&:size).inject(:+)\n\
    \    end\n  end\n  min_extension\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=1\
    \ |>\n<code>", "  strongest = extensions[0]\n  for i in 1..extensions.length\n\
    \    e = extensions[i]\n    if e[0] <=> strongest[0] <= 0\n      strongest = e\n\
    \    end\n  end\n  \"#{class_name}#{strongest}\"\nend", "  return nil\nend", " \
    \ extensions.each do |ext|\n    if ext[0].upcase == ext[0].downcase # if the first\
    \ letter of the extension matches the first letter of the extension then this\
    \ is a correct extension\n      return class_name + ext\n    end\n  end\n  raise\
    \ ArgumentError, \"Strongest extension for the given class name and extensions\
    \ does not contain any extensions with matching first letters.\"\nend", "  result\
    \ = nil\n  extensions = extensions.sort\n  extensions.each { |x| \n    strength\
    \ = x.casecmp(class_name).to_f\n    if strength > 0\n      if strength == -1\n\
    \        result = x\n      else\n        if result == nil\n          result =\
    \ x\n        else\n          if result.casecmp(x) > 0\n            result = x\n\
    \          end\n        end\n      end\n    end\n  }\n  return result\nend\n</code>\n\
    <|/ a tags=ruby dscore=2 |>\n<| c |>\nHe wants to find all extensions of a given\
    \ class. Your solution does not do that.\n<|/ c |>\n<| c |>\n, thank you for pointing\
    \ that out. I missed that part. I've added it to my solution. Your code seems\
    \ to do the job\n<|/ c |>\n<| c |>\nI'm getting an error with your code: NameError:\
    \ undefined local variable or method `my_class' for main:Object (NameError)\n\
    <|/ c |>\n<| c |>\nIt works fine for me when run with the supplied code. Perhaps\
    \ it is because I'm using Ruby 1.9.2. What version are you using?\n<|/ c |>\n\
    <| c |>\nYes, I am using Ruby 1.9.2. I had to change your code to work with the\
    \ version I had to work with. Thank you so much!\n<|/ c |>\n<| a tags=ruby |>\n\
    <code>", "  best_extension = nil\n  best_strength = -1\n  extensions.each do |extension|\n\
    \    extension_strength = extension.downcase.count(class_name.downcase) / class_name.length\n\
    \    if extension_strength > best_strength\n      best_extension = extension\n\
    \      best_strength = extension_strength\n    end\n  end\n  return \"#{class_name}.#{best_extension}\"\
    \nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nThanks for the response.\
    \ I understand this but I don't know how to actually get it to work. I think I'm\
    \ missing some key code pieces.\n<|/ c |>\n<| c |>\nI edited my answer so you\
    \ can try it out for yourself. I hope it helps.\n<|/ c |>\n<| c |>\nOkay, I added\
    \ your code to my application and tested it. And I get an error: \"TypeError:\
    \ class name must be a String\". It seems to not be reading the extension array\
    \ as a string. I'm thinking maybe a quick change to the extension array could\
    \ resolve this. I'll keep looking at it.\n<|/ c |>\n<| c |>\nI edited the code\
    \ slightly so it can work with arrays. Try it now.\n<|/ c |>\n<| c |>\nWow, thank\
    \ you so much!! This is exactly what I was looking for. I guess I just need to\
    \ read up on the method you're using, but thank you so much for the help. Really\
    \ appreciate it!\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  strength = extensions[0].to_s.size\
    \ - extensions[1].to_s.size \n  p \"Strength is: #{strength}\"\n  p \"Extensions\
    \ are: #{extensions.inspect}\"\n  extensions.sort{|a,b| a.to_s.size <=> b.to_s.size}.first\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
