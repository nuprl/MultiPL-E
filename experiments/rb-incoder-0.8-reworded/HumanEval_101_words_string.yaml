name: HumanEval_101_words_string
language: rb
prompt: "# You will be given a string of words separated by commas or spaces. Your\
  \ task is\n# to split the string into words and return an array of the words.\n\
  # For example:\n# >>> words_string.call(\"Hi, my name is John\")\n# [\"Hi\", \"\
  my\", \"name\", \"is\", \"John\"]\n# >>> words_string.call(\"One, two, three, four,\
  \ five, six\")\n# [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\ndef\
  \ words_string(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_words_string\n\
  \    candidate = method(:words_string)\n    assert_equal([\"Hi\", \"my\", \"name\"\
  , \"is\", \"John\"], candidate.call(\"Hi, my name is John\"))\n    assert_equal([\"\
  One\", \"two\", \"three\", \"four\", \"five\", \"six\"], candidate.call(\"One, two,\
  \ three, four, five, six\"))\n    assert_equal([\"Hi\", \"my\", \"name\"], candidate.call(\"\
  Hi, my name\"))\n    assert_equal([\"One\", \"two\", \"three\", \"four\", \"five\"\
  , \"six\"], candidate.call(\"One,, two, three, four, five, six,\"))\n    assert_equal([],\
  \ candidate.call(\"\"))\n    assert_equal([\"ahmed\", \"gamal\"], candidate.call(\"\
  ahmed     , gamal\"))\n  end\nend\n"
completions: ["  # Split up the string by spaces.\n  words = s.split(' ')\n  # Convert\
    \ the words into lowercase.\n  words = words.map{ |word| word.downcase }\n  #\
    \ Add the word \"the\" to the list.\n  words << 'the'\n  # Return the words.\n\
    \  words\nend", "  return s.split(/,|\\s/).reject(&:empty?)\nend\n</code>\nNow\
    \ the test case:\n<code>", "  words = s.split(/,| /)\n  words.map!(&:capitalize)\n\
    end", "  words = s.split(/[\\s,]+/).map(&:downcase).reject(&:empty?)\n  words.compact\n\
    end", "  s = s.downcase\n  s = s.gsub(/\\s+/, \" \")\n  s = s.split\nend\n</code>\n\
    Now we have the task of getting the program to ask the user for input and then\
    \ output the word count of those inputs. We can do that by iterating over the\
    \ string and printing it out as we go:\n<code>\nputs <<END\nEnter the text:\n\
    END", "  s = s.split(',')\n  s.map!{|word| word.tr(',', ' ')}\n  s.map!{|word|\
    \ word.scan(/\\w+/)}\n  s.map!{|word| word.delete_if(/[^a-z]/)}\n  s.map!{|word|\
    \ word.delete_if(/\\s+/)}\n  s.map!{|word| word.delete_if(/\\s+/)}\n  s.map!{|word|\
    \ word.delete_if(/\\s/)}\n  s.map!{|word| word.delete_if(/\\s/)}\n  s.map!{|word|\
    \ word.delete_if(' ')}\n  s.map!{|word| word.delete_if(' ')}\n  s.map!{|word|\
    \ word.downcase}\n  s.map!{|word| word.split(//)}\nend\n</code>\nIt will break\
    \ up the string into words and then remove any non-letter characters and spaces.\n\
    Lastly, it will convert the string to all lower case before splitting it into\
    \ individual words.\n<|/ a tags=ruby,regex |>\n<| c |>\nJust a warning: This code\
    \ will remove some punctuation, such as `!` which means `don't` will also end\
    \ up being removed.\n<|/ c |>\n<| a |>\n<code>", "  s = s.strip.split(/,|\\s/)\n\
    \  return s.map(&:to_s)\nend", "  puts \"Parsing string \\\"#{s}\\\" into array\
    \ of words:\"\n  puts s\n  puts\n  puts s\n  puts s\n  puts s\n  puts s\n  puts\
    \ s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts\
    \ s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts\
    \ s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts\
    \ s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts\
    \ s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts\
    \ s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts\
    \ s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts\
    \ s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts\
    \ s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts\
    \ s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts\
    \ s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts\
    \ s\n  puts s\n  puts s\n  puts s\n  puts s\n  puts ", "  word_array = s.split(/,|\\\
    s/)\n  return word_array\nend\n</code>\n<|/ a tags=ruby,arrays dscore=1 |>\n<|\
    \ a tags=ruby,arrays dscore=1 |>\nHere's another solution:\n<code>", "    words\
    \ = []\n    w = \"\"\n    for i in s\n        if i.is_alpha?\n            w +=\
    \ i\n        else\n            if words.length == 0\n                words.push(w)\n\
    \                w = i\n            else\n                words.push(w)\n    \
    \            w = i\n        end\n    end\n    words.push(w)\n    return words\n\
    end", "  words.split(s)\nend", "  s.split(\", \")\nend", "    return s.split(',')\n\
    \    # your code here\n    return s.split(' ')\nend", "    # Your code here\n\
    \    words = []\n    words = s.split(\",\").map(&:to_s).map(&:strip)\n    words\
    \ = words.select do |w|\n      !(w.empty?)\n    end\n    words\nend", "  s.gsub(/,\\\
    s*/).split(', ')\nend", "    puts \"Your code goes here\"\nend", "  return s.split(\"\
    \ \")\nend", "  words = s.split(\",\")\n  words.each do |word|\n    word.strip!\n\
    \  end\n  return words\nend", "  s.split\n  s.split(\", \")\n  s.split(\" \").split(\"\
    ,\")\n  s.split(\", \").split(\" \")\n  s.split(\" \").split(\",\").split(\" \"\
    )\nend", "\twords = s.split(/,|\\s/)\n\twords.each {|w| puts w}\nend", "  words\
    \ = s.split(/,|\\s/).map(&:downcase)\n  words.sort.each { |word| word.gsub!(/[^a-zA-Z\
    \ ]/, '') }\n  words\nend\n</code>\n<|/ a tags=ruby,arrays,string |>\n<| a tags=ruby,arrays,string\
    \ |>\nMy solution to this problem would be to use regular expressions:\n<code>",
  "  s.split(/,| /)\nend", "  s.split(',')\nend", "  return s.split\nend", "  split_words\
    \ = s.split\n  words.call(split_words())\nend", "    # Initialize your data structure\
    \ here.\n    data = []\n    words = s.split(/,|\\s/)\n    return words\nend",
  "  s.split(/,|\\s/)\nend", "  # BEGIN CODING\n  result = s.split\n  # END CODING\n\
    \  return result\nend", "  s = s.strip\n  s.split # split on any whitespace character\
    \ or comma character\nend", "  words = s.downcase.split.join.split(\",\").split\n\
    end", "  s.gsub!(',', ', ')\n  s.gsub!(' ', '').split\nend", "  return s.split(\"\
    \ \")\nend\n</cell>\n<code language=julia-1.5>\nwords_string(words_string.call(\"\
    Hi, my name is John\"))\n</cell>\n<text>\nNow you will want to clean your input\
    \ data. As you can see there are many ways to do this. The most common and preferred\
    \ method is to use a regular expression. Regular expressions are a very powerful\
    \ way to search and extract information from strings, and Julia already has some\
    \ great tools for working with regular expressions.", "    words = s.split(/,/)\n\
    \    words.shift if words.first().empty?\n    return words\nend", "  s.scan(/\\\
    w+/)\nend", "  arr = s.split(', ')\n  arr.map!{|a| a.split(' ').map(&:strip)}.flatten\n\
    end", "  s = s.split(',')\n  s.map { |x| x.split.join }\nend", "  return s.split(\"\
    ,\")\nend", "  s = s.split(',')\n  return s.map(&:strip)\nend", "    words = s.split(/,|,\
    \ /)\n    return words\nend\n</code>\nYou can now take your words_string function\
    \ and put it into your word_counters function (which returns nothing). This will\
    \ let you get the expected output when you call the word_counters function on\
    \ any string. You can use this like so:\n<code>\nputs word_counters(\"Hi, my name\
    \ is John\")\n</code>\nOutput:\n<code>\nHi my name is John\n</code>\nTry it online!\n\
    <|/ a |>\n<| a dscore=1 |>\n<code>", "  s.split(/,|\\s/).map{|w| w.strip!}\nend",
  "  s.split(\",\").map { |s| s.strip }\nend", "    words = s.split(/,|\\s+/)\n  \
    \  return words\nend", "    s.split(\",\")\n    s.split(\" \")\n    return s\n\
    end", "  s = s.to_s.split(' ')\n  s.map! do |word| word.strip unless word.empty?\
    \ end\n  s\nend", "    word_array = s.split\nend", "  words = []\n  s.split(',').each\
    \ do |word|\n    word.strip!\n    words << word unless word.empty?\n  end\n  return\
    \ words\nend", "  return s.split(',')\nend", "    # Split s into words\n    words\
    \ = s.split(/,|\\s+/)", "    s = s.split(', ')\n    i = 0\n    while i < s.length\n\
    \        s[i] = s[i] + '\\n'\n        i = i + 1\n    return s\nend", "    arr\
    \ = s.split(\" \")\n    return arr\nend\n</code>\n<|/ a tags=ruby,split |>\n<|\
    \ c |>\nYou should use spaces, not commas for that example.\n<|/ c |>\n<| c |>\n\
    Thanks for the advice, I've made some adjustments accordingly.\n<|/ c |>\n<| a\
    \ tags=ruby,split |>\nI love regular expressions! \n<code>", "  s.split(/[^ ,]+/)\n\
    end", "  words = s.split(', ')\n  words.map! { |word| word.strip }\n  words.compact!\n\
    \  words\nend", "  s.split(',')\nend", "  words = s.split(/,|\\s+/)\n  words.shift\n\
    \  return words\nend", "  s.split(/,| /)\nend", "    words = s.split(' ') # Split\
    \ on space\n    return words\nend", "    words = []\n    word = \"\"\n    s.split(\"\
    , \").each { |word| word << word.strip }\n    return words\nend\n</cell>\n<cell>\n\
    words_string(\"Hi, my name is John\")\n</cell>\n<cell>\nwords_string(\"One, two,\
    \ three, four, five, six\")\n</cell>\n<cell>", "  s = s.split(/[,\\s]/)\n  s.shift\
    \ if s[0] == \"\"\n  s\nend", "  a = s.split(',')\n  b = a[0]\n  a.shift() \n\
    \  c = a.join(', ')\n  d = b.split(' ')\n  c.shift() \n  d = c.join(', ')\n  e\
    \ = d.split(' ').join(',')\n  return e\nend", "  return s.scan(/\\w+/)\nend",
  "  return s.split(/,|\\s/).map { |x| x.strip }\nend", "  return s.split(/,|\\s/)\n\
    end", "  s.split(', ')\nend\n</code></pre>\n<p>\nA <code>call</code> method on\
    \ a class creates a new instance of the class\nand then calls the method on each\
    \ of the new instance variables. The\nfirst argument is the name of the method\
    \ being called. The second\nargument is the argument list to be passed to the\
    \ method.\n</p>\n<p>\nA method can be defined only within the scope of a class.\
    \ A class method\nis a method that is defined with the <code>def</code> keyword.\
    \ A class variable\nis a variable that is defined with the <code>@</code> symbol.\
    \ For a class\nmethod, the name of the method is <code>call</code>. For example,\
    \ a class method\ncalled <code>greet</code> for a class <code>Person</code> can\
    \ be defined as follows:\n</p>\n<pre class=\"ruby\"><span class=\"ruby-keyword\"\
    >class</span> <span class=\"ruby-constant\">Person</span>\n  <span class=\"ruby-keyword\"\
    >def</span> <span class=\"ruby-identifier\">greet</span>\n    <span class=\"ruby-identifier\"\
    >puts</span> <span class=\"ruby-node\">&quot;Hello, my name is #{@name}&quot;</span>\n\
    \  <span class=\"ruby-keyword\">end</span>\n<span class=\"ruby-keyword\">end</span>\n\
    </pre>\n<p>\nIn the above example, <code>self</code> is the name of the instance\
    \ variable which\nholds the instance of the class. <code>self</code> is also used\
    \ to refer to the\ncurrent object being operated upon.\n</p>\n<p>\nClass methods\
    \ can take arguments. Arguments go after a colon and are separated\nfrom each\
    \ other by commas. For example:\n</p>\n<pre class=\"ruby\"><span class=\"ruby-keyword\"\
    >class</span> <span class=\"ruby-constant\">Person</span>\n  <span class=\"ruby-keyword\"\
    >def</span> <span class=\"ruby-identifier\">greet</span>(<span class=\"ruby-identifier\"\
    >name</span>)\n    <span class=\"ruby-identifier\">puts</span> <span class=\"\
    ruby-node\">&quot;Hello, my name is #{name}&quot;</span>\n  <span class=\"ruby-keyword\"\
    >end</span>\n<span class=\"ruby-keyword\">end</span>\n</pre>\n<p>\nIn order for\
    \ a method to be executed, it must be called from within the context\nof the class\
    \ being defined. For example:\n</p>\n<pre class=\"ruby\"><span class=\"ruby-keyword\"\
    >class</span> <span class=\"ruby-constant\">Person</span>\n  <span class=\"ruby-keyword\"\
    >def</span> <span class=\"ruby-identifier\">greet</span>\n    <span class=\"ruby-identifier\"\
    >puts</span> <span class=\"ruby-node\">&quot;Hello, my name is #{@name}&quot;</span>\n\
    \  <span class=\"ruby-keyword\">end</span>\n<span class=\"ruby-keyword\">end</span>\n\
    <span class=\"ruby-constant\">Person</span>.<span class=\"ruby-identifier\">new</span>.<span\
    \ class=\"ruby-identifier\">greet</span>\n<span class=\"ruby-comment\"># Hello,\
    \ my name is John</span>\n<span class=\"ruby-keyword\">class</span> <span class=\"\
    ruby-constant\">Person</span>\n  <span class=\"ruby-keyword\">def</span> <span\
    \ class=\"ruby-identifier\">greet</span>(<span class=\"ruby-identifier\">name</span>)",
  "  # BEGIN Solution\n  words = s.split(', ')\n  words.delete_if do |word|\n    word.empty?\n\
    \  end\n  words\n  # END Solution\nend", "  return s.split.join(\" \").split\n\
    end\n</code>\n(I recommend a text editor that supports Ruby syntax highlighting,\
    \ because Ruby is often easier to read than Ruby.)\nHere's how you would call\
    \ the function above with a string:\n<code>\nwords_string(\"Hi, my name is John\"\
    )\n</code>\nAnd here's how you would call the function with a file:\n<code>\n\
    File.open(\"words.txt\") do |f|\n  f.each_line { |l| puts words_string(l) }\n\
    end\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nThat's awesome.  I knew it was\
    \ a noob question.  Thanks so much for the help!  I'm still a little confused\
    \ about why the original code doesn't work (the method isn't even being called).\
    \  I'm probably just doing something wrong.\n<|/ c |>\n<| c |>\nI added a more\
    \ detailed example for you.\n<|/ c |>\n<| c |>\nThat helps a lot, thank you. \
    \ It's still throwing an error though... I don't think it's finding the method\
    \ or it's not being called.  Is there some additional syntax I need to write for\
    \ the method call to use the variables?\n<|/ c |>\n<| c |>\nI think you're missing\
    \ the `end` keyword. Add `end` before the `end` where I added the comment `# You\
    \ will need to return an array of words.`\n<|/ c |>\n<| c |>\nAh, okay.  So the\
    \ code you edited in fixed the issue I was having, but I noticed that when I put\
    \ in \"One, two, three, four, five, six\" as an argument, it would return \"One\"\
    \ \"two\" \"three\" \"four\" \"five\" \"six\".  Does this mean it isn't actually\
    \ splitting the string into words based on commas?  Thanks!\n<|/ c |>\n<| a |>\n\
    <code>", "  # Extract the words from the string using 'split' method\n  s.split(',\
    \ ')\nend\n</pre>\n<h3 id=\"call-the-words-string-method\">Call the words_string\
    \ method</h3>\n<pre># You will be given a String that contains the string you\
    \ want", "  splitted = s.split(', ')\n  splitted.map!{|s| s.strip}\n  splitted\n\
    end", "    words = s.split(\",\")\n    return words", "  s = \"\"\n  s.split(\"\
    ,\").map{|word| word.strip!}\nend\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| a\
    \ dscore=0 tags=ruby |>\n<code>", "  words = s.split(\",\")\n  words.sort!\n \
    \ return words\nend", "    s = s.downcase\n    s.gsub!(/,\\s|(\\w+\\s?)+/,\"\"\
    )\n    s.gsub!(/\\s+/, \", \")\n    s.gsub!(/^\\\"/, '\"')\n    s.gsub!(/\\\"\
    ,$/, \"\")\n    s.gsub!(/\\\",\\s/, \"|\")\n    s.gsub!(/^\\|/,\"\")\n    s.gsub!(/\\\
    |$/, \"\")\n    s.gsub!(/\\\"\\|$/, '')\n    words = s.split(\",\")\n    words.map!{|word|\
    \ word.strip}\n    words.compact!\n    words.uniq!\n    words.map!{|word| word.strip}\n\
    \    words.map!{|word| word.downcase}\n    words.map!{|word| word.split(\" \"\
    ).map{|w| w.capitalize}}\n    words.map!{|word| word.split(\"|\").map{|w| w.capitalize}}\n\
    \    words.map!{|word| word.split(\", \").map{|w| w.capitalize}}\n    words.map!{|word|\
    \ word.split(\", \").map{|w| w.capitalize}}\n    words.map!{|word| word.split(\"\
    |\").map{|w| w.capitalize}}\n    words.map!{|word| word.split(\", \").map{|w|\
    \ w.capitalize}}\n    words.map!{|word| word.split(\", \").map{|w| w.capitalize}}\n\
    \    words.map!{|word| word.split(\", \") }\n    words.map!{|word| word.split(\"\
    , \").map{|w| w.capitalize}}\n    words.map!{|word| word.split(\", \").map{|w|\
    \ w.capitalize}}\n    words.map!{|word| word.split(\", \").map{|w| w.capitalize}}\n\
    \    words.map!{|word| word.split(\", \") }\n    words.map!{|word| word.split(\"\
    , \") }\n    words.map!{|word| word.split(\", \").map{|w| w.capitalize}}\n   \
    \ words.map!{|word| word.split(\", \").map{|w| w.capitalize}}\n    words.map!{|word|\
    \ word.split(\", \").map{|w| w.capitalize}}\n    words.map!{|word| word.split(\"\
    , \").map{|w| w.capitalize}}\n    words.map!{|word| word.split(\", \").map{|w|\
    \ w.capitalize}}\n    words.map!{|word| word.", "  s.split(', ').map {|word| word.strip}\n\
    end", "  s = s.split(', ')\n  result = s.collect{|word| word.to_s}\n  return result\n\
    end", "  s = s.call\n  s.each {|x| puts \"[#{x}]\" if x}\nend", "  s.split(',\
    \ ')\nend", "  # +++your code here+++\n  # TODO: Split string into words using\
    \ the split() method\n  # and return an array\n  words = s.split(',')\n  words.each\
    \ do |w|\n    w = w.split\n  end\nend\n</pre>", "  s.split(/,|\\s/).map { |w|\
    \ w.strip }\nend", "  words = s.split(/,|\\s/)\n  words.delete_if { |x| x == \"\
    \" }\n  return words\nend\n</code>\nThe second part is really simple and doesn't\
    \ require any additional gems:\n<code>", "  words = s.split(/,|\\s/)\n  words.map!(&:downcase)\n\
    \  words.map!(&:capitalize)\n  words.compact!\n  return words\nend", "    # Split\
    \ the string into words\n    words = s.split(\",\")\n    # Make an empty array\n\
    \    words = []\n    # for each word\n    words.each do |word|\n        # Append\
    \ each word to the empty array\n        words.push(word.strip)\n    end\n    #\
    \ Return the array\n    return words\nend", "    splitted = s.split(\",\")\n \
    \   words_array = []\n    words_array.push(*splitted)\n    words_array.push(*splitted)\n\
    \    return words_array\nend", "  return s.split(',').reduce([]){|memo, elem|\
    \ memo << elem.to_s.singularize}\nend", "  s.split(\", \")\nend", "  string.split(s.to_s)\n\
    end", "  s = s.split(',')\n  s.collect! {|x| x.gsub(/[^\\w\\s\\-]+/, \"\")}\n\
    \  s.collect! {|x| x.scan(/\\w+/)}\nend", "  # Your code here!\nend", "  words\
    \ = s.split(/,|\\s/)\n  words.map!{ |x| x.lstrip.gsub(/\\W/,'')}\n  words.compact!\n\
    \  return words\nend", "    words = s.split(\" \")\n    return words\nend", " \
    \ s = s.chomp\n  s.split.each do |word| yield word\n  end \nend", "    words =\
    \ s.split(\", \")\n    words[0...-1]\nend\n</code>\nAnd that's it!\n<|/ a dscore=2\
    \ |>\n<| a dscore=2 tags=ruby,ruby-on-rails |>\n<code>", "  # Split into a list.\n\
    \  words = s.split(', ')\n  # Convert to a list.\n  words = words.map { |x| x.strip\
    \ }\n  # Return it.\n  words\nend", "    words = s.split(', ')\n    words.shift\n\
    \    words\nend\n</code>\nThe above is a function which you can call by passing\
    \ in a string and it should return the words. If you run it like so words_string.call(\"\
    Hi, my name is John\") it will return:\n<code>\n[\"Hi\", \"my\", \"name\", \"\
    is\", \"John\"]\n</code>\nNow that we know that the function is working, we can\
    \ get to the second part of the puzzle. The next part of the puzzle is to define\
    \ a function that will take a word and return whether or not that word is a palindrome.\
    \ For example \"I\" is a palindrome but \"a\" isn't.\n<code>", "  s.split.map\
    \ &:strip\nend", "  return s.split(/\\W+/)\nend\n</cell>\n<text>\nQuestion 3\n\
    Write a function that will take a string and a separator as an argument and return\
    \ the string with all the instances of the separator removed.", "  s.split(/,|\\\
    s/)\nend\n</pre>\n<p>Finally, your task is to write a function that takes two\
    \ arguments, and returns True if both arguments\nare numbers, and False otherwise.\
    \ Your function definition looks like this:\n<pre class=\"ruby\">", "  return\
    \ s.split(/,|\\s/)\nend", "    # Split the string into words.\n    split_s = s.split(\"\
    ,\")\n    \n    words = []\n    \n    # Iterate through each word and split it\
    \ into characters.\n    for word in split_s:\n        chars = word.split(\" \"\
    )\n        \n        # Iterate through each character and append it to the words\
    \ array.\n        for char in chars:\n            words.append(char)\n    \n \
    \   return words\n    \n</cell>\n<cell>", "    s = s.upcase\n    s.split(',').map!\
    \ { |word| word.strip }\n    s.split(' ').map! { |word| word.strip }\n    s.split(',').map!\
    \ { |word| word.strip }\n    return s\nend", "  s = s.split(\",\")\n  s = s[1..-1]\n\
    \  s.map!{|x| x.strip.downcase}\n  return s\nend", "    words = s.split(/,|\\\
    s|/)\n    return words\nend", "    words = s.split(',')\n    return words\nend",
  "  words = s.split(\",\")\n  words.pop(words.count)\n  return words\nend", "  s.split(/,|\\\
    s/)\nend", "  # your code goes here\n  words = s.split.to_a\nend\n</code>\nThe\
    \ .split method splits a string into an array of strings, using the given delimiter.\
    \ The return value is a new array containing the elements of the original array\
    \ that were separated with the delimiter.\n<code>\n a = \"One, two, three, four,\
    \ five, six\"\n a.split # => [\"One\", \"two\", \"three\", \"four\", \"five\"\
    , \"six\"]\n</code>\nThe .split method also has an optional parameter that can\
    \ limit the number of elements in the returned array. Using the optional parameter,\
    \ you can limit the number of splits (elements) returned:\n<code>\n a = \"One,\
    \ two, three, four, five, six\"\n a.split(', ', 3) # => [\"One\", \"two\", \"\
    three\"]\n</code>\nWe can use this parameter to return the words in our string:\n\
    <code>\n words_string.call(\"Hi, my name is John\")\n # => [\"Hi\", \"my\", \"\
    name\", \"is\", \"John\"]", "  \n  # Convert to an array and split by commas and\
    \ spaces.\n  a = s.split(/,|\\s/)\n  \n  # Add each element of split array to\
    \ the return array.\n  words.each { |x| words.push x if a.include?(x) }\nend",
  "  words = s.gsub(/[^a-zA-Z ]+/, ' ').split(' ')\n  return words\nend", "    words\
    \ = s.split(\",\")\n    return words\n    \n</cell>\n<cell>", "  words = s.scan(/\\\
    w+/)\n  words.empty? ? [] : words.map(&:capitalize)\nend", "  s.gsub(/[, ]+/,\
    \ \" \").split(\" \").map{|s| s.strip}\nend", "  s = s.split(',')\n  s.map! do\
    \ |word|\n    word.strip\n  end\n  s.uniq.sort!\n  s\nend", "  return s.split(\"\
    \ \")\nend", "  return s.split(\", \")\nend", "  s.scan(/\\w+/).map{|i| i}\nend",
  "    # Your code here\n    words = s.split(/\\s*,\\s*|\\s*,\\s*/)\n    return words\n\
    end\n</cell>\n<text>\nGreat! Now that you have a function ready to use, it will\
    \ be easy to test! Try it on the next cell to make sure you have the right answer.",
  "  s = s.call(\"Hi,  my,  name,  is,  John\")\n  result = []\n  s.split(//).each\
    \ do |word|\n    result << word\n  end\n  result\nend\n</cell>\n<cell>", "  words\
    \ = s.split(/,|\\s/)\nend", "  s.split(/,|\\s/)\nend", "  words = s.split(/[,\\\
    s]+?/)\n  return words\nend", "  # +++your code here+++\n  s.split(/,| /)\nend",
  "  s.split(',')\nend", "  result = s.split(\" \")\n  result = result.map {|e| e.strip}\n\
    \  result.reject {|e| e.empty?}\nend", "    split_s = s.split(', ')\n    splits\
    \ = []\n    \n    for s in split_s\n      splits.push s.split\n    end\n    \n\
    \    return splits\nend", "  s = \"\" if s.nil? || s == \"\" else s\n  return\
    \ s.split(/,| /)\nend", "\ts.split.to_a\nend", "  s = s.to_s\n  a = s.split(',\
    \ ')\n  a.map!{|x| x.strip}\n  a\nend\n</code>\nIn order to see what it actually\
    \ returns, you can add p at the end (it's just for debugging purposes):\n<code>",
  "  # Split the string into words using the String.split() method.\n  words = s.split(\"\
    \ \")", "  words = s.split(\",\")\n  words.map! { |x| x.strip }\n  words\nend",
  "  s = s.split(/[\\s,]+/)\n  s.map { |word| word.split }\nend", "    # Convert string\
    \ to lower case\n    s = s.downcase", "\ts.split(/,| /)\nend", "    words = s.split(/,|\\\
    s/)\n    return words\nend", "\twords = s.split(\", \")\n\twords.map! do |x|\n\
    \t\tx = x.gsub(/\\s+/, \"\")\n\t\tx = x.gsub(/, /, \"\\n\")\n\t\tx = x.gsub(/\\\
    [/, \"\")\n\t\tx = x.gsub(/\\]/, \"\")\n\t\tx = x.gsub(/\\(/, \"\")\n\t\tx = x.gsub(/\\\
    )/, \"\")\n\t\tx = x.gsub(/\\,/, \" \")\n\t\tx\n\tend\n\twords = words.map!{ |x|\
    \ x.split(\" \") }\n\twords\nend", "  s = s.to_s.downcase.split(/[\\s,]+/)\n \
    \ s.map!{|word| word.strip }\n  s.reject!{|word| word.empty? }\n  s\nend", " \
    \ # Split string into a list of words\n  words = s.split\n  # Convert to an array\n\
    \  return words\nend\n</cell>\n<text>\nNow use the following cells to find what\
    \ you need by creating new functions in the code cells above to return the results\
    \ of each function.", "  return s.split ','\nend", "  words = s.split(\",\")\n\
    \  words.map { |word| word.strip }\nend", "  s = s.split(/,|\\s/)\n  s.each do\
    \ |word|\n    words[word] ||= []\n    words[word].push(word)\n  end\n  s.clear\n\
    end", "    # Write your solution here\n    words = s.split(',')\n    return words\n\
    end\n</code>\nI should also note that your test cases are not actually working\
    \ correctly. For example, the words_string method will always return the string\
    \ \"John, my name is John\". That is because you are using the same variable name\
    \ words to return the words array and to store the returned words in the words\
    \ variable. I would suggest to rename the variable in the words_string method\
    \ and to rename the variable in the main method in order to avoid this confusion.\n\
    <|/ a |>\n<| c |>\nThe test cases are actually working, though I agree with the\
    \ `words` vs. `words` confusion.\n<|/ c |>\n<| c |>\nYou are correct that they\
    \ are working. The only issue is that the return values are different. My point\
    \ is that you shouldn't be calling the method `words` anywhere other than in the\
    \ main method.\n<|/ c |>\n<| c |>\nThe test cases are working because `words_string`\
    \ is supposed to be returning a list of words. That's what the return value means,\
    \ isn't it? I should probably make that clearer in my answer I suppose.\n<|/ c\
    \ |>\n<| a tags=ruby |>\nThis should work\n<code>", "  s.split(/,|\\.|\\s/).each\
    \ { |word| words << word.strip }\n  words\nend", "  # Split `s` on commas, or\
    \ on spaces.\n  s.split(/,|\\s/)\nend", "    words = s.split(/,|\\s/)\n    return\
    \ words\nend", "  s.scan(/\\w+/).map {|s| s.tr('A-Z', 'a-z')}\nend\n</code>\n\
    <|/ a dscore=2 tags=ruby,arrays,ruby-on-rails,string |>\n<| c |>\nI'm sorry, this\
    \ was a typo. I've fixed it.\n<|/ c |>\n<| c |>\nOh sorry, it's my first time\
    \ posting here. I've fixed the typo.\n<|/ c |>\n<| c |>\nAwesome, thanks! And\
    \ thanks for the edits, they make it a lot clearer.\n<|/ c |>\n<| c |>\nOh, that\
    \ explains it! Yeah, I figured it would be something like that.\n<|/ c |>\n<|\
    \ c |>\nI've been trying to figure out why this doesn't work for me, though I\
    \ am not sure why your version is different than mine. My version returns the\
    \ same thing, but your returns something different. Does anyone know why that\
    \ would be?\n<|/ c |>\n<| a |>\nIn your case scan is most suitable, as others\
    \ pointed out in comments. Here is an example for you:\n<code>", "    words_array\
    \ = []\n    word_array = s.split(\" \").map { |s| s.downcase }\n    words_array.concat(word_array)\n\
    \    words_array.uniq\nend", "  # Write your code here\nend", "  result = s.split('\
    \ ')\n  result.delete_if { |word| word.match(/^[\\-]/) }\n  result\nend", "  s\
    \ = s.downcase\n  s.scan(/\\w+/).map { |w| w.capitalize }.uniq\nend", "  split_s\
    \ = s.split(/,|, /)\n  split_s\nend", "    words = s.split.to_a\n    words.to_a\n\
    end\n</code>\nFor each of the three exercises below, create a function by copy/pasting\
    \ the function definition given above. As part of the exercise write some unit\
    \ tests, where you call the function and make sure it gives the correct results.\n\
    <code>", "  return s.split(/[\\s,]+/).select {|x| x}\nend", "    s = s.chomp.downcase\n\
    \    s = s.chomp.split\n    return s\nend", "  s.split(/,|\\s/)\nend", "  s =\
    \ s.split(', ') if s.count(',')\n  s.join(',')\nend", "  s.split(/, ?/).map(&:strip)\n\
    end\n</code>\nSo to test that function...\n<code>\nwords_string.call(\"Hi, my\
    \ name is John\") # => [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\nwords_string.call(\"\
    One, two, three, four, five, six\") # => [\"One\", \"two\", \"three\", \"four\"\
    , \"five\", \"six\"]\nwords_string.call(\"One, two, three four, five, six\") #\
    \ => [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\nwords_string.call(\"\
    One, two, three, four, five, six, seven\") # => [\"One\", \"two\", \"three\",\
    \ \"four\", \"five\", \"six\", \"seven\"]\n</code>\n<|/ a dscore=5 |>\n<| c |>\n\
    If you're going to test `strip` specifically, you might as well use `split` with\
    \ `', '`, since the only exceptions you're going to want to catch are those where\
    \ there are multiple consecutive spaces (which are usually a bad idea).\n<|/ c\
    \ |>\n<| a dscore=4 |>\nThe answer provided by Jonathan is quite good. But I would\
    \ like to add few things that might help others.\nThe question says that you are\
    \ not able to use any method from String class (split, join, gsub, etc.). Then\
    \ why are you not able to use any of those methods?\nIf you use Ruby 1.9.3 or\
    \ above, everything is going to be fine.\nIf you use Ruby 1.8.7, you should use\
    \ String#split.\nHere are some ways you can use #split method:\n<code>", "  words\
    \ = s.split(',')\n  return words\nend", "  s.split(/,|\\s|\\s+/)\nend", "  s.split(',\
    \ ')\nend\n</code>\nAnd then we wrap it up in the new method:\n<code>\nputs words_string.call(\"\
    Hi, my name is John\")", "  s = s.split(/,|\\s/)\n  s.map!(&:downcase)\n  s\n\
    end", "  return s.split(\",\")\nend", "  s = s.split(\",\")\n  s.map do |s|\n\
    \    s.strip.split(/\\s\\s+/)\n  end\nend\n</code>\nFor what it's worth, here\
    \ are some tests to make sure you get the right results:\n<code>\ndescribe \"\
    splitting a string into words\" do\n  it \"should work with a space separator\"\
    \ do\n    expect(words_string(\"Hi, my name is John\").length).to eq(3)\n  end",
  "    s.split(/,|\\s/)\nend", "  s.split(/,|\\s/)\nend", "  s.split\nend", "  string_rev\
    \ = s.reverse\n  words = string_rev.split\n  strings.each do |string|\n    puts\
    \ \"string: #{string}\"\n    puts \"words: #{words.call(string)}\"\n  end\nend",
  "    # Return an array of words in s\n    # split method splits string into array\
    \ of words, separated by one or more whitespace\n    return s.split(/,\\s?/)\n\
    end", "  s = s.split \" \"\n  s.collect do |i|\n    i = i.split(\"-\")\n    i.collect\
    \ do |j|\n      j = j.strip \n      if j != \"\"\n        j.downcase!\n      end\n\
    \    end\n  end\nend", "  result = s.split(/,| /).map(&:strip)\n  result\nend",
  "  words = s.split(\",\")\n  words.shift\n  words.each { |word| word.strip! }\n\
    \  return words\nend", "\twords = s.split(',')\n\treturn words\nend", "  # Write\
    \ your code here\n  return s.split(\", \")\nend", "  s.split(\",\").map { |x|\
    \ x.strip }\nend\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| c |>\n`String#split`\
    \ expects a regular expression (`/pattern/`), not a plain string. Using `String#split`\
    \ with a plain string is the same as using `String#split` with a regular expression:\
    \ `s.split(/,/)` is the same as `s.split(//)`.\n<|/ c |>\n<| c |>\nOops, didn't\
    \ see that.  Good catch.  Edited.\n<|/ c |>\n<| c |>\nYou still need to use `String#split`\
    \ with a regular expression like `\"Hello, my name is John\".split(/\\s+/)` to\
    \ get a array of all your words. `String#split` will split at any whitespace.\n\
    <|/ c |>\n<| c |>\nNo, no need for `split`.  Use `split` with a regular expression,\
    \ as I suggested in the first comment on the question.\n<|/ c |>\n<| c |>\nUsing\
    \ a regular expression will split words not only at whitespaces.\n<|/ c |>\n<|\
    \ a dscore=0 |>\nString#split\n<code>", "  s = s.split(', ')\n  s.map! do |word|\n\
    \    word.strip\n  end\n  s\nend", "  # Split string into words.\n  words = []\n\
    \  word = \"\"\n  for i in 0..s.length\n    if s[i] == ','\n      if word != \"\
    \"\n        words << word\n      word = \"\"\n    else\n      word << s[i]\n \
    \   end\n  end\n  if word != \"\"\n    words << word\n  end\n  return words\n\
    end", "\ts.split(',') + s.split(' ').map(&:strip)\nend", "\twords = []\n\tarray\
    \ = s.split(', ')\n\tarray.each do |i|\n\t\twords << i.strip.downcase\n\tend\n\
    \treturn words\nend", "  return s.split(/,|\\.|\\s/).map(&:strip)\nend", "  s.scan(/\\\
    w+/).map(&:to_s)\nend", "  s.split\nend", "  return s.split if s.respond_to? :split\
    \ else nil\nend", "    # BEGIN Question 5\n    # END Question 5\nend", "    words\
    \ = s.split(/,|\\s/)\n    words.each do |word|\n      word = word.strip\n    end\n\
    \    return words\nend", "  # Write your code here.\nend", "  s.gsub!(/[,[\\]\\\
    s]+/, \"\").split(\", \")\nend", "  s.split(', ')\nend", "  # Split your string\
    \ into words using the split method available on Strings.\n  words = s.split(',\
    \ ')\n  \n  # Remove extra spaces and return an array of words.\n  words.each\
    \ { |w| w = w.strip }\n  return words\nend\n</code>\nNext we create our first\
    \ test case:\n<code>", "  arr = s.split(\",\")\n  arr.reverse!", "    puts \"\
    You entered: #{s}\" if s.nil?\n    # BEGIN SOLUTION\n    w = s.split(\", \")\n\
    \    puts \"You entered: #{w}\" if w.size > 0\n    # END SOLUTION\nend", "  words\
    \ = s.split(\" \")\n  words.each{|x| x.gsub!(/[^a-zA-Z0-9]/, \"\") if x}\n  words\n\
    end", "  s.split(/,|, /)\nend", "  return s.split(/,|\\s/)\nend\n</cell>\n<code\
    \ language=julia-1.5>", "  word_list = s.split(', ')\n  return word_list\nend",
  "  s = s.split\n  s.call(\" \") # Replace ' ' with '','\nend", "    # BEGIN CODING\
    \ HERE\n    words = s.split(\" \")\n    return words\n    # END CODING HERE",
  "\twords = s.split # Split into words\n\twords.map! # Convert words into Strings\n\
    \treturn words\nend", "  s = s.split(\",\")\n  words.each { |i| s.delete(i) }\n\
    \  s.each { |i| words.push(i.strip) }\nend", "  # Split string into array of words.\n\
    \  words = s.split(', ') #\n  words.each { |word| puts word } # Print each word\
    \ on new line.\n  puts \"\" # Print blank line after word.\nend", "  s = s.split(//)\
    \ \n  words.reduce(s) \nend", "  # Split string into words separated by commas.\n\
    \  words = s.split(', ')\n  # Return words as array.\n  words_array = []\n  #\
    \ For each word in the string.\n  words.each do |word|\n    # Add word to array\
    \ of words.\n    words_array << word\n  end\n  # Return array of words as string.\n\
    \  return words_array\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,arrays,string\
    \ dscore=0 |>\nUse ruby's built in split method. Assuming you get one word per\
    \ line, split on white spaces and use map to put all the words into an array.\
    \ \n<code>", "  a = s.split(\", \")\n  a.each {|word| puts word}\n  return\nend",
  "  words = s.split(/,/)\n  words.each_with_index do |word, index|\n    words[index]\
    \ = word.strip\n  end\n  return words\nend", "  s = s.split(/,|\\s|,/)\n  s.map\
    \ { |x| x.strip }\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
