name: HumanEval_35_max_element
language: rb
prompt: "# Return maximum element in the array.\n# >>> max_element.call([1, 2, 3])\n\
  # 3\n# >>> max_element.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n# 123\ndef\
  \ max_element(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_max_element\n\
  \    candidate = method(:max_element)\n    assert_equal(3, candidate.call([1, 2,\
  \ 3]))\n    assert_equal(124, candidate.call([5, 3, -5, 2, -3, 3, 9, 0, 124, 1,\
  \ -10]))\n  end\nend\n"
completions: ["  l.max\nend", "  return l.max_by { |x| x }\nend", "    l.sort!\n \
    \   l.inject(:>)\nend\n</code>\n<|/ a |>\n<| c |>\nYou probably want `max_element.call(...)`.\n\
    <|/ c |>\n<| c |>\n: It works in ruby 1.9.3 (Ubuntu 10.10 32-bit)\n<|/ c |>\n\
    <| c |>\nThanks.  I fixed it so it uses `sort` instead of `sort!` so there's no\
    \ chance of surprises.\n<|/ c |>\n<| c |>\n: Thanks for pointing that out.  I\
    \ was wondering why it didn't work.  I thought `sort` was actually a destructive\
    \ method (like `sort!`) so I thought it wasn't `sort!`'s fault.  I realized now\
    \ that I was wrong.\n<|/ c |>\n<| c |>\nThis should be the accepted answer now.\
    \ Very efficient and elegant. Also great for Ruby on Rails 3.1, which doesn't\
    \ support the inject method.\n<|/ c |>\n<| a dscore=4 |>\nHere's another option:\n\
    <code>", "  l.max\nend", "  l.max_by { |e| e }\nend", "  return l.find { |n| n.call\
    \ > -1.0/0 }\nend", "  return l.max_by{|e| e}\nend", "  return l.max_by { |x|\
    \ x }\nend", "    l.max_by{ |e| -e}\nend", "  return l.max_by(&:last)\nend", " \
    \ return l.inject(0, :<=>).last\nend\n</cell>\n<text>\nReturning values\nA value\
    \ returned from a function can be returned from a block of code by explicitly\
    \ returning it. You can return the last element of the array in this case:", " \
    \ l.max { |a, b| (a <=> b) }\nend", "  l.inject(0, &:<=>).max\nend", "  l.max\n\
    end", '  max_value = nil', "  max_element_idx = -1\n  max_element = nil", "  l.max_by\
    \ { |e| e }\nend\n</pre>", "  l.max_by(&:itself)\nend", "  return l[l.max_by{|a,\
    \ b| a}]\nend", "  l.sort.last or return nil\nend", "  if l.empty?\n    l.push\
    \ :nil\n  end\n  max = l[0]\n  l.shift unless l.empty?\n  l.each do |el|\n   \
    \ max = el if el > max && el != :nil\n  end\n  max\nend", "  return l[l.index(l.max)]\n\
    end", "  l.sort.last if l && l.size > 0\nend", "  return l.max { |x, y| y if x\
    \ > y } if l.is_a?(Array)\n  l.max\nend", "  return l.reduce(:<=>)\nend", "  l.inject(0)\
    \ { |a, b| b > a ? b : a }\nend", "  l.max\nend\nmax_element.register(:array)\n\
    max_element.register(:matrix)\nmax_element.register(:hash)\nmax_element.register(:string)\n\
    max_element.register(:symbol)", "  return l.max\nend", "  l.sort!\n  l[-1]\nend",
  "  return l[l.index(-x.call(x))]\nend\n</cell>\n<code language=julia-0.5>", "  l.sort.call(l)\n\
    \  l.shift.call(l)\n  l.first.call\nend", "  if l.length == 0 then nil\n  else\
    \ reduce(min, l) || max_element.call(l[1..-1]) || max_element.call(l)\n  end\n\
    end", "  l.sort.call([0]).pop\nend", "  return l.max_by { |x| x.to_i }\nend\n\
    </pre>", "  l.compact.max\nend", "  # Get the size of the array.\n  size = l.size\n\
    \  # Initialize an iterator; this will be used to iterate over\n  # each element\
    \ in the array.\n  iterator = l.begin", "  l.sort!\n  l.first\nend", "  l.max_by\
    \ {|x| x }\nend", "  l = l.dup\n  l.sort!\n  l.max\nend", "  return l.max\nend",
  "  l.inject(0, &:>)\nend", "  # Define a local scope to calculate max value.\n \
    \ l.inject(0) { |m, e| m > e ? m : e }\nend", "    l.sort.call\n    return l.last\n\
    end", "  return l.max { |a, b| b <=> a }\nend", "  l.sort { |a, b| b > a }[-1]\n\
    end", "  l.max_by { |x| x }\nend", "  l.each do |i|\n    return i if i > l.last\n\
    \  end\n  nil\nend\nputs max_element.call([1, 2, 3])", "  l.sort\n  l.first\n\
    end", "  l.each_with_index { |e, i| return e if i == l.size - 1 }\nend", "  return\
    \ l.max\nend", "  l.sort\n  l[-1]\nend", "  return l.max_by { |e| e } ? l.max_by\
    \ { |e| e } : 0\nend", "  l.max_by { |x| x }\nend", "  l.sort!\n  l.last\nend\n\
    </code>\n<|/ a tags=ruby,sorting |>\n<| a tags=ruby,sorting dscore=1 |>\nHere's\
    \ a one-liner:\n<code>", "  l.each do |e|\n    return e if e >= l.max_by { |v|\
    \ v }\n  end\nend", "  l.inject(0) do |max,el|\n    return max if max < el\n \
    \   el\n  end\nend", "  return l.max\nend", "  l.max\nend", "  l.sort\n  l.last\n\
    end", "  return l.max_by{|e| e}\nend", "  l.compact.max\nend", "  l.inject(&:max)\
    \ rescue nil\nend", "  return l.max_by { |e| e.call }\nend", "  max_element_index\
    \ = nil\n  l.each_with_index do |e, i|\n    if i > max_element_index\n      max_element_index\
    \ = i\n    end\n  end\n  l[max_element_index]\nend", "  l.sort.max { |a, b| b\
    \ < a ? 1 : 0 }\nend\n</code>\n<|/ a |>\n<| a dscore=0 tags=ruby |>\nIf your input\
    \ is an array then Array#max_by does the job and you do not need a helper method:\n\
    <code>\n[3, 5, -5, 2, -3, 3, 9, 0, 123, 1, -10].max_by{ |x| x }\n  #=> -10\n</code>\n\
    This works because a negative number will always be less than a positive number,\
    \ hence the block is called with x = -10, and it returns the maximum value -10.\
    \ In the case of [3, 5, -5, 2, -3, 3, 9, 0, 123, 1, -10] the block is called with\
    \ x = 10 (the value of the last element) and it returns -10, as -10 evaluates\
    \ as true in Ruby.\nThis works because the comparison operator returns the value\
    \ of its left argument, <=> for the array [3, 5, -5, 2, -3, 3, 9, 0, 123, 1, -10].\
    \ The block is passed the arguments to the block, yielding one value for each\
    \ element of the array and hence the block #=> -10. However, the block is called\
    \ with no arguments and the value returned by the block is irrelevant.\nTo understand\
    \ why the block is needed in the first place, consider the following block:\n\
    <code>\n{|x| x }\n</code>\nHere the block returns its argument, x, but is passed\
    \ no arguments. That is, the block is invoked with no arguments and its block\
    \ variable is set to the default value nil. Because nil is falsey, the block returns\
    \ the value of its argument, x, which is nil.\nLet's look at a more complicated\
    \ example. Suppose that we define the following methods:\n<code>", "  l.inject(0)\
    \ { |sum, e| sum.max(e) }\nend", "  max_value = l.first\n  l.delete_if{|x| x >\
    \ max_value}\n  l.max_by{|x, y| y <=> x}\nend", "  l.max_by { |e| e }\nend", " \
    \ l.max_by { |v| v }\nend", "  l.max_by { |x| x } && return\n  raise \"no maximum\
    \ element in #{l.inspect}\"\nend", "  # Remove all nils.\n  l.compact.each { |x|\
    \ x.is_a?(Numeric) ? x.abs : x }\n  # Sort.\n  l.sort.reverse\n  # Find the maximum.\n\
    \  l.detect { |x| x.is_a?(Numeric) ? x.abs == x }\nend", "  l.each_index { |i|\
    \ return l[i] if l[i] > l[i-1] }\n  nil\nend", "  l.max_by { |e| e }\nend", " \
    \ l.sort.last\nend", "  if l == nil then\n    return nil\n  end\n  local max_value\
    \ = l[1]\n  local l = l[2]\n  for k in l\n    do\n      if max_value < k then\n\
    \        max_value = k\n      end\n    end\n  return max_value\nend", "  return\
    \ l.max_by(&:to_i) if l.respond_to?(:max_by)\n  l.max\nend", "  l.each_index do\
    \ |i|\n    if l[i] > l[i + 1] then\n      l[i], l[i + 1] = l[i + 1], l[i]\n  \
    \  end\n  end\n  l\nend", "  if l.empty?\n    raise ArgumentError, \"list should\
    \ not be empty\"\n  end\n  l.shift\n  max_element = l[0]\n  l.shift\n  while l\
    \ != nil\n    max_element = l[0] > max_element ? l[0] : max_element\n    l.shift\n\
    \  end\n  return max_element\nend", "  return l.max_by { |x| x }\nend", "  return\
    \ l.max\nend", "  return l.max\nend", "  l.each do |elem|\n    return elem if\
    \ elem == l.max\n  end\n  nil\nend", "  l.sort.last\nend", "  l.max_by{ |x| x\
    \ }\nend", "  l.max_by { |e| e }\nend", "  return l.max\nend", "  l = l(:call,\
    \ :sort)\n  l.length == 1 ? l : l[0]\nend", "  l.max_by { |i| i }\nend", "  if\
    \ l.size == 0\n    throw(:_)\n  end\n  \n  max_so_far = l[0]\n  max_ele = l[0]\n\
    \  \n  for v in l\n    if v > max_so_far\n      max_so_far = v\n    end\n    if\
    \ v > max_ele\n      max_ele = v\n    end\n  end\n  \n  max_ele\nend", "  return\
    \ l.max\nend", "  l.sort_by!{ |x| -x }\n  l.first\nend", "  return l.max { |x,\
    \ y| y <=> x }\nend", "  # Return maximum element in the array.\n  # >>> max_element.call([1,\
    \ 2, 3])\n  # 3\n  # >>> max_element.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    \  # 123\n  l.each_index do |i|\n    if l[i] > l[i + 1]\n      l[i], l[i + 1]\
    \ = l[i + 1], l[i]\n    end\n  end\n  return l\nend", "  return l.max_by { |i|\
    \ i }\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nYou don't need to convert the\
    \ values to Integer (`max_value`). You also don't need to convert the values to\
    \ Float (`max_value`).\n<|/ c |>\n<| a dscore=4 |>\nHere is one in O(n)\n<code>\n\
    arr = [1, 2, 3, 4]\narr.min_by { |x| arr.reduce(0) { |sum,i| sum + i } } = arr.min\n\
    </code>\n<|/ a tags=ruby |>\n<| a tags=ruby |>\nHere is another option that is\
    \ O(1):\n<code>\narr = [1, 2, 3, 4]\narr.max.reduce(:+)", "  l.max\nend", "  return\
    \ l[0]  if l.size > 0 &&\n              l.all? { |n| n > l[0] } && l[0]\n  l.max\n\
    end", "    l.sort { |a, b| b - a}[0]\nend", "  l.sort\n  l.last\nend", "  l.sort\n\
    \  l.pop\n  l[-1]\nend", "  if l == nil\n    nil\n  else\n    max = l[0]\n   \
    \ for i in 1 .. (l.size - 1)\n      if max < l[i]\n        max = l[i]\n      end\n\
    \    end\n    max\n  end\nend", "  l.max_by { |x| x }\nend\n</code>\nOr just define\
    \ your own method:\n<code>", "  l.inject(0, :<)\nend", "    l.max_by{ |x| x }\n\
    end", "  l.sort\n  l.last\nend", "  max_value = l[0]\n  max_index = 0\n  l.each\
    \ do |e|\n    if e > max_value\n      max_value, max_index = e, 0\n    end\n \
    \ end\n  max_value\nend\n</cell>\n<text>\nWe only need to test for the first element\
    \ to find the maximum.", "    l.sort!\n    l.last\nend", "  l.find { |i| i > l.max\
    \ }\nend", "  l.sort.reverse!\n  l.max\nend\n</code>\n<|/ a dscore=1 tags=ruby,arrays\
    \ |>\n<| a tags=ruby,arrays |>\nI realize this is an old post and perhaps already\
    \ answered, but for posterity I wanted to add some Ruby 1.9 code to the accepted\
    \ answer:\n<code>\n def max_element a\n   a.min_by{ |e| -e.to_f }\n end\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=ruby,arrays |>\nHere's another way of doing it:\n\
    <code>", "  l.sort.max\nend", "  l.sort.last || return nil\nend", "  l.map { |x|\
    \ x.max_by { |y| y } }\nend", "  l.inject(0, :<=>).max_by { |a, b| b }\nend",
  "  max_so_far = nil\n  l.each do |i|\n    if (i > max_so_far)\n      max_so_far\
    \ = i\n    end\n  end\n  max_so_far\nend\n</code>\n<|/ a |>\n<| c |>\nOh, that\
    \ is interesting. Thank you for sharing. It seems like a good idea to keep these\
    \ as pure ruby, instead of making it into a gem. Why would that be beneficial?\
    \ And also, why would you suggest that it is 'more efficient' to call a method\
    \ on the returned value rather than just calling the method itself?\n<|/ c |>\n\
    <| c |>\nYes, in that case you can just return the method and use it as you were\
    \ going to call it. I just thought it would be nice to have a way to reuse the\
    \ method (maybe it is more elegant to write it in one line instead of creating\
    \ a method and then returning it from a different method). Maybe you could add\
    \ that to the answer. Thank you for the feedback.\n<|/ c |>\n<| c |>\nYes, that's\
    \ a great idea. You could also make a `max_element` method that just passes a\
    \ block to `each` so you could use `max_element(l){ |x| x.call(x) }` or something\
    \ like that. I think that's what you were getting at about not making it a gem\
    \ though - it just seems useful if you wanted to do that yourself.\n<|/ c |>\n\
    <| a tags=ruby,methods,arrays |>\nThis might be the most succinct and readable\
    \ way to get the max (if you have Ruby >= 2.0):\n<code>", "  l.sort.max\nend",
  "  return l.max { |x, y| y <=> x }\nend", "  l.map { |x| x.max }\nend", "  l.sort.call\n\
    \  l.last if l and l.length > 0\nend", "    l.sort!\n    l.last\nend", "  return\
    \ l.max\nend", "  l.each_with_index.max_by { |e, i| e }[1]\nend", "  return l.max_by{\
    \ |x| x.to_i }\nend", "  l.max_by { |x| x }\nend", "  l.compact.max\nend", " \
    \ l.max\nend", "  l = l.to_a if l.kind_of?(Array) then l else [l.to_a]\n  l.sort\
    \ { |a, b| b[0] <=> a[0] }\n  l[0]\nend", "  # Your code here\nend", "  l.sort!\n\
    \  l.max\nend", "  l = l.call(0)\n  l.each do |e|\n    return e if e > l[-1]\n\
    \  end\nend", "    l.sort!\n    l[0]\nend", "  l.sort.call\n  l.last\nend\n</code>\n\
    <|/ a |>\n<| c |>\nAwesome ! It took me a while to understand that ruby is just\
    \ calling `each` on `#sort` but yeah it's simple and elegant!\n<|/ c |>\n<| c\
    \ |>\nGreat answer - but please don't call it `max_element`, because that is also\
    \ the name of the built-in function.\n<|/ c |>\n<| c |>\nAnd don't call it `max`\
    \ because `max` is also the name of the built-in function.\n<|/ c |>\n<| a tags=ruby\
    \ dscore=5 |>\nYou could also use\n<code>\n[a,b,c,d].sort\n</code>\n<|/ a |>\n\
    <| c |>\nThis one has less overhead than the other answers.\n<|/ c |>\n<| c |>\n\
    And not overhead at all!\n<|/ c |>\n<| a tags=ruby |>\n<code>\na=[1,2,3]\na.sort\
    \ {|x,y| y <=> x } # => [1, 2, 3]\n</code>\nor \n<code>\na=[1,2,3]\na.sort {|x,y|\
    \ y <=> x} = # => [1, 2, 3]\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI see no reason\
    \ to prefer your second example over `a.sort!`\n<|/ c |>\n<| c |>\nI prefer the\
    \ first example because it's shorter, more concise, and reads better.\n<|/ c |>\n\
    <| c |>\nThis one should be the accepted answer since it works with both Ruby\
    \ versions.\n<|/ c |>\n<| a |>\n<code>\n[1,2,3].max # => 3\n</code>\nor\n<code>\n\
    [1,2,3].max  # => 3\n</code>\n<|/ a tags=ruby dscore=5 |>\n<| c |>\nThanks. I\
    \ added this to my `~/.irbrc` file so that I don't have to type that out each\
    \ time.\n<|/ c |>\n<| a |>\n<code>\n[1,2,3].sort\n</code>\nwill sort by the first\
    \ item, and then by all the subsequent ones.\n<|/ a tags=ruby dscore=5 |>\n<|\
    \ c |>\n+1 for `[1,2,3].sort`. This was a great solution for me as I was sorting\
    \ a list of dates that needed to be ordered chronologically.\n<|/ c |>\n<| a |>\n\
    <code>\na=[1,2,3]\na.sor", "  l.sort!\n  l.last\nend", "  if l.reduce(:<, 0) ==\
    \ 0 then\n    l[0]\n  else\n    l[l.size - 1]\n  end\nend", "  return l.reduce(max)\n\
    end", "  l.sort { |x, y| x <=> y }\n  l[0]\nend", "  l.map! { |x| x.to_i }\n \
    \ l.max\nend", "  l.max_by {|e| e} || l[l.size - 1]\nend", "  return l.max_by\
    \ { |e| e }\nend", "  l.find {|n| n == -n.to_i || n == n.to_i }\nend", "\tl.max\
    \ {|a, b| a <=> b }\nend", "  l.max\nend", "  return max_element.call(l, 0)\n\
    end", "  return nil if l.nil?\n  return l[0] if l[0] > l.last\n  l.last\nend",
  "  l.compact.max\nend", "  l.sort { |a, b| b<=>a }\n  l.last\nend\n</code>\n<|/\
    \ a dscore=0 tags=ruby |>\n<| a |>\n<code>", "  l.sort.reverse\n  l.first\nend",
  "  l.max_by { |e| -e}\nend", "  l.find {|e| e > 0 }.max\nend\n</code>\n<|/ a |>\n\
    <| c |>\nIf you don't have a `max` method, consider using `Enumerable#max_by`.\n\
    <|/ c |>\n<| c |>\nIf you don't have a `max` method then `Enumerable#max_by` would\
    \ be just as good (and faster) than your solution. `Enumerable#max_by` is like\
    \ `Enumerable#max_by{|a,b| b<=>a}` except it returns a `nil` when the list is\
    \ empty. With an added benefit of being more robust than your solution (for example,\
    \ `max_element(nil)` will raise an error).\n<|/ c |>\n<| c |>\n`Enumerable#max_by`\
    \ requires two elements and returns a `nil` if the list is empty. Your solution\
    \ requires one element and returns a `nil` if the list is empty. `max_element(nil)`\
    \ raises an error because `nil.to_i` raises an `ArgumentError`.\n<|/ c |>\n<|\
    \ a tags=ruby,algorithm |>\nThis solution does not use Enumerable#max or Enumerable#max_by\
    \ but rather relies on the fact that Ruby has first-class functions (methods).\n\
    <code>", "  # Initialize an array.\n  a = Array.new(l)\n  # Sort array.\n  a.sort!\n\
    \  # Return element on its place.\n  a[l-1]\nend", "  l.map!{|x| x.to_i} if l\n\
    \  return l.max\nend", "  l.sort!\n  l.last\nend", "  if l.empty?\n    nil\n \
    \ else\n    l.max\n  end\nend", "  l.inject(0) {|max, e| max < e ? max : e}\n\
    end", "  l.sort { |a, b| a <=> b }\n  l.max\nend", "  l.max\nend", "  l.max_by\
    \ { |e| e }\nend", "  l = l.sort { |a, b| a <=> b }\n  l.last\nend", "  l.find\
    \ { |e| e == l.max }\nend", "  l = l.to_a\n  if l.empty?\n    nil\n  else\n  \
    \  lmax = l.max\n    case lmax\n    when Numeric\n      lmax\n    when Complex\n\
    \      lmax.real\n    when String\n      lmax.to_i\n    end\n  end\nend", "  l.max\n\
    end", "  l.sort.last\nend", "  return l.max_by { |n| n.call }\nend", "  l.sort\
    \ { |a, b| b <=> a }\n  l.last\nend", "  l.inject(0) { |i, e| i > e ? i : e }\n\
    end", "  l.inject(0) do |m, e|\n    m > e ? m : e\n  end\nend", "  max_value =\
    \  l[0]\n  max_index = 0\n  l.each_index do |i|\n    if l[i] > max_value then\n\
    \      max_value = l[i]\n      max_index = i\n    end\n  end\n  max_value\nend",
  "  l.max\nend", "  l.sort!\n  l.last\nend", "  return l.max_by{|v| v}\nend", " \
    \ l.max_by { |e| -e.abs }\nend\n</code>\n<|/ a |>\n<| a dscore=5 tags=ruby-1.9,ruby,arrays,max\
    \ |>\nThe most efficient way to do this is with Enumerable#max_by as suggested\
    \ by Jonathan W. Tinsley, but if you don't have a version of Ruby that supports\
    \ max_by yet, here's how you can do it with Enumerable#max:\n<code>", "  l.max_by\n\
    end", "  l.inject(:+).max\nend", "  l = l.to_a\n  l.sort!\n  l.inject { |m,a|\
    \ m == a ? a : m }\nend\n</code>\nTo find the minimum element, the following code\
    \ can be used:\n<code>", "  max_value = nil\n  max_key = nil\n  l.each do |i|\n\
    \    if i.is_a?(Numeric)\n      if !max_value.nil? || max_value < i\n        max_value\
    \ = i\n        max_key = i.to_s\n      end\n    else\n      if !max_value.nil?\
    \ || max_key < i.to_s\n        max_value = i\n        max_key = i.to_s\n     \
    \ end\n    end\n  end\n  max_value.to_s\nend", "  if l.empty?\n    nil\n  else\n\
    \    l.max_by { |e| e }\n  end\nend", "  l.inject(0, :>)\nend", "  l.max_by {\
    \ |x| x }\nend", "  l.max\nend", "  l.map!(&:to_f).max\nend", "  l.to_enum(:max_by).call\n\
    end", '  return l.max', "  return l.reduce(&:>)\nend", "\tl.each do |i|\n\t\t\
    break if i.to_i > max\n\t\tmax = i.to_i\n\tend\n\tmax\nend", "  # @assert array\
    \ l == array l\n  \n  l.sort!\n  \n  if l.size < 2\n    return l[0]\n  \n  max_val\
    \ = l[0]\n  \n  for i in 1..l.size\n    if l[i] > max_val\n      max_val = l[i]\n\
    \    end\n  end\n  \n  return max_val\nend", "  l.inject { |sum, el| sum < el\
    \ ? sum : el }\nend", "  l.max\nend\n</cell>\n<code language=julia-1.4>\n@code_native(max_element)\n\
    </cell>\n<text>\nReturns the maximum element in the array.", "  l.sort.find {\
    \ |e| e > l.max }\nend", "  l.max\nend", "  l.max\nend", "  l.each{|x| return\
    \ x if x > l.max}\nend", "  return l.max\nend", "  l.max\nend", "  l.sort!\n \
    \ l[-1]\nend", "  l.sort!\n  l.first\nend", "  l.sort!\n  l.last\nend", "  l.inject(0,\
    \ :max)\nend", "  l.sort.last\nend", "  l.inject(0, :<=>) do |max, el|\n    return\
    \ max if el > max\n    max\n  end\nend", "  return l.max\nend", "  return l.max\n\
    end", "  max_value = nil\n  max_element = nil\n  l.each do |item|\n    if item\
    \ > max_value\n      max_value = item\n      max_element = item\n    end\n  end\n\
    \  max_element\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
