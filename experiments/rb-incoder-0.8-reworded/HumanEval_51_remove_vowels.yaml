name: HumanEval_51_remove_vowels
language: rb
prompt: "# remove_vowels is a function that takes string and returns string without\
  \ vowels.\n# >>> remove_vowels.call(\"\")\n# \"\"\n# >>> remove_vowels.call(\"abcdef\"\
  )\n# \"bcdf\"\n# >>> remove_vowels.call(\"aaaaa\")\n# \"\"\n# >>> remove_vowels.call(\"\
  aaBAA\")\n# \"B\"\n# >>> remove_vowels.call(\"zbcd\")\n# \"zbcd\"\ndef remove_vowels(text)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_remove_vowels\n\
  \    candidate = method(:remove_vowels)\n    assert_equal(\"\", candidate.call(\"\
  \"))\n    assert_equal(\"bcdf\nghjklm\", candidate.call(\"abcdef\nghijklm\"))\n\
  \    assert_equal(\"fdcb\", candidate.call(\"fedcba\"))\n    assert_equal(\"\",\
  \ candidate.call(\"eeeee\"))\n    assert_equal(\"cB\", candidate.call(\"acBAA\"\
  ))\n    assert_equal(\"cB\", candidate.call(\"EcBOO\"))\n    assert_equal(\"ybcd\"\
  , candidate.call(\"ybcd\"))\n  end\nend\n"
completions: ["  text.downcase!\n  text.gsub(/[aeiou]/, '')\n  text.strip!\nend",
  "  text.downcase! # Make sure text is downcased, or else \"a\" won't be found when\
    \ doing text.find \"a\"\n  text.gsub! /[aeiouy]+/, '' # remove all vowels from\
    \ text\n  text\nend", "  text.chars.reject { |c| c == \"a\" || c == \"e\" || c\
    \ == \"i\" || c == \"o\" || c == \"u\" }\nend\n</cell>\n<text>\nString#match?\
    \ tests if a string matches a regular expression. If so, the first capturing group\
    \ is returned:", "  text.downcase!\n  text = text.tr(\"aeiouyAEIOUY\", \"y\")\n\
    \  text.downcase!\n  text\nend", "  # Split text into list of strings where each\
    \ string is a word in the text.\n  words = text.split(\" \")", "  text.gsub(/[aeiou]/i,\
    \ '')\nend", "  text.gsub(/[aeiou]/, '').strip\nend\n</cell>\n<cell>", "  remove_vowels_text\
    \ = text.gsub(/[aeiouAEIOU]/, '')\n  remove_vowels_text.downcase!\n  remove_vowels_text\n\
    end", "    text = text.upcase\n    text = text.downcase\n    text.scan(/[aeiou]/.freeze).each\
    \ do |e|\n      text.gsub!(e, \"\") #replace vowels with empty string.\n    end\n\
    \    text.scan(/[^aeiou]/.freeze).each do |e|\n      text.gsub!(e, \"\") #replace\
    \ non vowels with empty string.\n    end\n    text.gsub!(/[^aeiouAEIOU]/.freeze,\
    \ \"\") #remove everything that is not vowel and a consonant.\n    text\nend",
  "  text.each_char.with_index.inject(\"\") {|s, (c,i)| c == 'a' ? s.delete(i) : s\
    \ + c}\nend\n</code>\n<|/ a |>\n<| c |>\nYou don't need to use `each_char.with_index`\
    \ and can use `delete_if` instead: `text.delete_if{ |c| c == \"a\" || c == \"\
    e\" || c == \"i\" || c == \"o\" || c == \"u\" }`. Also, the OP seems to be interested\
    \ in deleting all the vowels and then capitalizing letters, so `text.gsub(/[aeiou]/,\
    \ '')` will work just as well. Also, the last argument to `delete` is the starting\
    \ position, so it should be `text.delete(i, '')`.\n<|/ c |>\n<| c |>\nThanks Pavan.\
    \ I didn't realise that gsub could replace a range of characters with a string.\
    \ I guess I should have been more clear about what I was trying to do.\n<|/ c\
    \ |>\n<| a dscore=0 |>\n<code>", "  text.gsub(/[aeiou]/, '')\nend\n</code>\n<|/\
    \ a tags=ruby |>\n<| c |>\nI like that this uses the method `gsub` of the String\
    \ class rather than the gsub! method which modifies the original string.\n<|/\
    \ c |>\n<| a dscore=4 tags=ruby |>\nUsing 'gsub' method as mentioned by Anthony\
    \ Grimm, I have devised this approach as :\n<code>", "  text.downcase!\n  text.gsub!(\"\
    a\", \"z\")\n  text.gsub!(\"e\", \"y\")\n  text.gsub!(\"i\", \"j\")\n  text.gsub!(\"\
    o\", \"c\")\n  text.gsub!(\"u\", \"t\")\n  text.gsub!(\"A\", \"Z\")\n  text.gsub!(\"\
    E\", \"Y\")\n  text.gsub!(\"I\", \"J\")\n  text.gsub!(\"O\", \"C\")\n  text.gsub!(\"\
    U\", \"T\")\n  text\nend", "  text.downcase!\n  text.gsub!(/[aeiou]/, '')\n  text\n\
    end", "  text.tr!(*VOWELS)\nend\n</cell>\n<code language=julia-1.2>", "    text.downcase!\n\
    \    text.gsub!(/[aeiouAEIOU]/i, '')\n    text.gsub!(/[AEIOUaeiou]/i, '')\n  \
    \  text.strip!\nend", "    # Your code here!\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a dscore=0 tags=ruby,regex,ruby-on-rails |>\n<code>", "  text.gsub(/[aeiou]/,\
    \ '')\nend\n</code>\n<|/ a tags=ruby-on-rails,ruby dscore=1 |>\n<| c |>\nI tried\
    \ this and was still getting an error: \"undefined method `gsub' for nil:NilClass\"\
    \n<|/ c |>\n<| c |>\nOops, I meant to call your `remove_vowels` method. Fixed\
    \ now\n<|/ c |>\n<| c |>\nI'm still getting the same error after adding the `remove_vowels`\
    \ function and calling it like `remove_vowels.call` instead of `remove_vowels`.\n\
    <|/ c |>\n<| a dscore=0 tags=ruby-on-rails,ruby |>\nYour regex is wrong. /[^aeiou]/\
    \ will match one single character that is not one of the characters aeiou. But\
    \ you're trying to match multiple characters, in other words you're trying to\
    \ match multiple characters except the character i. You need to use the multi\
    \ character match [^aeiou]{2,} which matches any character except one of the characters\
    \ aeiou or e. \n<code>", "  text.gsub(/[aeiou]/,\"\").reverse.split(\"\").join\n\
    end", "  return text.gsub(/[aeiou]/i, '').strip\nend\n</code>\nNow that we have\
    \ the remove_vowels function, we can use a regular expression to find the first\
    \ instance of a vowel in a given string:\n<code>", "  return text.gsub(/[aeiou]/,'')\n\
    end", "  text.downcase!\n  text.gsub(/[aeiou]/,\"\").gsub(/[aeiouy]/,\"y\")\n\
    end", "    text.gsub(/[aeiou]/i, '')\nend", "    text.gsub(/[aeiou]/, '')  # Removes\
    \ vowels in string\nend", "  text.tr! \"aeiouAEIOU\", \"AEIOU\"\nend\n</cell>\n\
    <text>\nExercise 8: Write a function that takes a string and returns string with\
    \ consecutive characters reversed. E.g. \"abcccbb\" becomes \"cbbbacc\".\nHint:\
    \ Use reverse! or reverse!.", "  text.gsub!(/[aeiou]/, '')\nend", "  text.downcase!\n\
    \  text.gsub!(/[aeiouAEIOU]/,\"\") #gsub takes regex, replacement string\n  text.gsub!(/[^aeiouAEIOU]/,\"\
    \") #gsub takes regex, replacement string\n  text\nend\n</code>\n<|/ a dscore=3\
    \ tags=ruby |>\n<| a dscore=2 |>\n<code>", "    text.upcase!\n    text.downcase!\n\
    \    text.gsub!(/[aeiou]/, '')\n    text.gsub!(/[aeiouAEIOU]/, '')\n    text.tr!('aeiouAEIOU',\
    \ 'AEIOU')\nend\n</cell>\n<code language=julia-1.0>", "  # Implement remove_vowels\
    \ here\nend", "    text.gsub!(/[aeiouy]/, '')\nend", "  text.downcase!\n  text.gsub!(/[aeiouy]/,\
    \ \"\")\nend", "  text = text.downcase\n  text.gsub!(/[aeiou]/, '')\nend\n</cell>\n\
    <text>\n6.2 Pig Latin\nPig Latin is a relatively popular word game where players\
    \ try to arrange letters in a word with equal or close proximity in a way that\
    \ minimizes the number of characters they must delete.", "  if text.length ==\
    \ 0 || text.length == 1\n    text\n  else\n    text.chars.grep(/[aeiou]/).join\n\
    \  end\nend", "  # Write your code here\n  text.gsub!(/[aeiou]/, '')\n  return\
    \ text\nend\n</cell>\n<code language=julia-1.5>", "  text.gsub!(/[aeiouAEIOU]/,\"\
    \")\n  return text\nend", "    vowels = %w(a e i o u)\n    text.gsub(/[aeiou]/,\
    \ '', :ignore)\nend\n</code>\n<|/ a |>\n<| c |>\nHow would I call that function\
    \ without using an argument? Or even better: how would I pass the argument in\
    \ as you did in your example? ", "  vowels = %w(a e i o u)\n  new_text = \"\"\n\
    \  text.each_char.with_index do |char, i|\n    if vowels.include?(char)\n    \
    \  new_text << char\n    else\n      new_text << char.upcase\n    end\n  end\n\
    \  new_text\nend", "  text.downcase!\n  text.gsub!(/[aeiouy]/, '') if text.length\
    \ == 0\n  text\nend", "  text.gsub(/[aeiou]/i, '')\nend\n</cell>\n<cell>", " \
    \ text.gsub(/(\\A)[aeiouy]+(\\z)/,'')\nend", "  return text.tr(\"aeiouAEIOU\"\
    , \"\")\nend", "  text = text\n    .gsub(/(.)(?!\\1|\\2)/, '\\1')\n    .gsub(/([aeiou])\\\
    1/, '')\n    .gsub(/([^aeiou])\\1$/, '')\n  return text\nend", "  text.tr!('aeiou',\
    \ '')\nend", "  vowels = ['a', 'e', 'i', 'o', 'u']\n  return text.gsub(/[#{vowels.join}]/,\
    \ '').strip\nend\n</cell>\n<cell>", "  text = text.chars.to_a\n  text.delete_if\
    \ { |x| ['y', 'a', 'e', 'i', 'o', 'u'].include?(x) }\n  text.join(\"\")\nend",
  "  return text.gsub(/[aeiou]/, '')\nend\n</code>\n<|/ a tags=ruby,string |>\n<|\
    \ a dscore=2 |>\nYou can use partition:\n<code>\n[\" aaaa \", \"aaa \", \" aaa\"\
    ].partition { |s| s != '' }\n=> [[\"aaaa \", \"\"], [\"aaa \", \"aaa\"], [\"aaa\"\
    , \"\"]]\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nInteresting use of partition!\n\
    <|/ c |>\n<| c |>\nIt is not very efficient. The other solutions are more efficient.\
    \ Try it with 1000 elements and you will see why.\n<|/ c |>\n<| a dscore=2 |>\n\
    <code>\n\"aaa bbb ccc ddd\".scan(/\\w+/).reject{|s| s.empty?}\n=> [\"aaa\", \"\
    bbb\", \"ccc\", \"ddd\"]\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nThis is\
    \ one of the rare cases where `String#scan` is preferable to `String#split`.\n\
    <|/ c |>\n<| c |>\nThanks for posting this. I found this solution very helpful.\
    \ :)\n<|/ c |>\n<| a |>\nUse Array#map with a regular expression:\n<code>", " \
    \ text.downcase!\n  text.gsub(/[aeiouy]{2}/, '')\n  text\nend", "  text.gsub(/[aeiou]/,\
    \ '')\nend", "  text.scan(/[aeiou]/) do |vowel|\n    text = text.sub(vowel, \"\
    \")\n  end\n  text\nend\n</code>\nUsing Ruby\n<code>", "    vowels = \"aeiouAEIOU\"\
    \n    translated = text.downcase\n    translated.gsub!(/[#{vowels}]/, '')\n  \
    \  translated\nend\n</code>\n<|/ a tags=ruby,regex |>\n<| c |>\nThis only removes\
    \ one vowel. `remove_vowels(\"asdf\")` still returns `asdf`\n<|/ c |>\n<| c |>\n\
    Yes, it removes only one vowel (the first one found). But that's not what the\
    \ OP asked. The OP asked for the first appearance of any vowel, so...\n<|/ c |>\n\
    <| c |>\nYour code is wrong for two reasons: 1) You don't remove any vowels, you\
    \ remove only the first, and 2) You have to remove the final character, since\
    \ that's what `downcase` does.\n<|/ c |>\n<| c |>\nHaha thanks for pointing that\
    \ out! I forgot about that one!\n<|/ c |>\n<| a tags=ruby,regex dscore=1 |>\n\
    <code>", "  vowels = \"aeiou\"\n  text.downcase!\n  text.gsub(/[#{vowels}]+/,\
    \ '') \nend", "  text.gsub(/[aeiouy]/i, '')\nend\n</code>\nAnd then I use the\
    \ remove_vowels method on the body of every function I write, like so:\n<code>",
  "    text.gsub(/[aeiouAEIOU]/,\"\")\nend", "    text.gsub!(/[aeiouAEIOU]/, '')\n\
    end", "    text = text.downcase\n    text.gsub!(/[aeiou]/, '') #remove any vowels\
    \ \n    text.gsub!(/[aeiouy]/, 'y') #replace vowels with y\n    text.gsub!(/[aeiou]/,\
    \ '') #remove any vowels \n    text.gsub!(/[aeiouy]/, 'y') #replace vowels with\
    \ y\n    text.gsub!(/[aeiou]/, '') #remove any vowels\n    text.gsub!(/[aeiouy]/,\
    \ 'y') #replace vowels with y\n    text.gsub!(/[aeiou]/, '') #remove any vowels\n\
    \    text.gsub!(/[aeiouy]/, 'y') #replace vowels with y\n    text.gsub!(/[aeiou]/,\
    \ '') #remove any vowels\n    text.gsub!(/[aeiouy]/, 'y') #replace vowels with\
    \ y\n    text.gsub!(/[aeiou]/, '') #remove any vowels\n    text.gsub!(/[aeiouy]/,\
    \ 'y') #replace vowels with y\n    text.gsub!(/[aeiou]/, '') #remove any vowels\n\
    \    text.gsub!(/[aeiouy]/, 'y') #replace vowels with y\n    text.gsub!(/[aeiou]/,\
    \ '') #remove any vowels\n    text.gsub!(/[aeiouy]/, 'y') #replace vowels with\
    \ y\n    text.gsub!(/[aeiou]/, '') #remove any vowels\n    text.gsub!(/[aeiouy]/,\
    \ 'y') #replace vowels with y\n    text.gsub!(/[aeiou]/, '') #remove any vowels\n\
    \    text.gsub!(/[aeiouy]/, 'y') #replace vowels with y\n    text.gsub!(/[aeiou]/,\
    \ '') #remove any vowels\n    text.gsub!(/[aeiouy]/, 'y') #replace vowels with\
    \ y\n    text.gsub!(/[aeiou]/, '') #remove any vowels\n    text.gsub!(/[aeiouy]/,\
    \ 'y') #replace vowels with y\n    text.gsub!(/[aeiou]/, '') #remove any vowels\n\
    \    text.gsub!(/[aeiouy]/, 'y') #replace vowels with y\n    text.gsub!(/[aeiou]/,\
    \ '') #", "  text.scan(/[aeiou]/).map {|char| char.downcase }.join(\"\")\nend",
  "  text.gsub(/[aeiou]/, \"\").strip\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\n\
    Here is a solution using recursion.\n<code>", "  text.gsub(/[aeiouy]/, '')\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\nThank you for the answer. Could you explain\
    \ me the regex you wrote here? I'm a beginner in ruby, so I never saw that way\
    \ of writing regex. Thank you so much!\n<|/ c |>\n<| c |>\nI added some explanation.\
    \ Feel free to ask if you don't understand something :)\n<|/ c |>\n<| a tags=ruby\
    \ |>\n<code>\nputs \"Input string : aaBaa\"\nputs \"Output string : B\"\n</code>\n\
    To replace vowels other than yes and no:\n<code>\nputs \"Input string : aaBaa\"\
    \nputs \"Output string : B\"\nputs \"yes or no? yes or no?\"\nputs \"yes or no?\
    \ yes or no?\"", "  text.gsub!(/[aeiou]/, '')\n  text.gsub!(/[aeiouy]/, '')\n\
    end", "  text.chars.reject { |char| Vowels.include?(char)}.join\nend", "  text.gsub(/[aeiou]/,\
    \ '') if text != '' # remove vowels if any\nend", "    text.gsub(/[aeiouAEIOU]/,\"\
    \")\nend", "  text.gsub(/[aeiou]/i, '')\nend", "  text.gsub(/[aeiou]/, '')\nend",
  "  vowels = %w(a e i o u)\n  text.downcase!\n  text.gsub(/[#{vowels.join}]/, '')\n\
    end\n</code>\nAnd of course, there are a few more simple things you can do in\
    \ Ruby using string methods. For instance, this is how I would do it in Ruby:\n\
    <code>", "  text.each_char.with_object(\"\") do |char, str|\n    case char\n \
    \   when 'a'\n      str += 'a'\n    when 'e'\n      str += 'e'\n    when 'i'\n\
    \      str += 'i'\n    when 'o'\n      str += 'o'\n    when 'u'\n      str +=\
    \ 'u'\n    when 'y'\n      str += 'y'\n    else\n      str += char\n    end\n\
    \  end\nend\n</code>\nNow remove_vowels removes vowels from given string:\n<code>\n\
    remove_vowels(\"abcdefg\")\n=> \"bcdefg\"\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby\
    \ |>\n<code>", "  text.gsub(/[aeiou]/, '') \nend\n</code>\nAnd now you can call\
    \ remove_vowels on the string before using it.  \n<code>", "  text.downcase!\n\
    \  text.gsub!(/[aeiou]/, \"\")\nend", "  # Replace all vowels with empty strings.\n\
    \  text.gsub!(/[AEIOUaeiou]/, '')\nend", "  text.gsub(/[aeiou]/, '')\nend", " \
    \ return text.gsub(/[aeiou]/, '')\nend", "  text.gsub(/[aeiou]/, '')\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails,regex |>\n<| c |>\nI ran your code and it returned\
    \ `undefined method 'gsub' for #<String:0x00000002c5bb50>`\n<|/ c |>\n<| c |>\n\
    My bad, forgot that strings are immutable. Edited my answer, see above.\n<|/ c\
    \ |>\n<| c |>\nThe original `def remove_vowels(text)` works in IRB. I just ran\
    \ it through the console and it ran correctly. I am running ruby 1.8.7\n<|/ c\
    \ |>\n<| c |>\n`remove_vowels(\"AaaBcCddd\")` returns `abcd` as expected. `remove_vowels(\"\
    aaaaa\")` returns `aa`. `remove_vowels(\"AaaBcCddd\")` returns `abcd` as expected.\
    \ `remove_vowels(\"aaaaa\")` returns `aa`. `remove_vowels(\"AaaBcCddd\")` returns\
    \ `abcd` as expected. `remove_vowels(\"aaaaa\")` returns `aa`. `remove_vowels(\"\
    AaaBcCddd\")` returns `abcd` as expected.\n<|/ c |>\n<| c |>\n: What version of\
    \ ruby are you using? I suspect you're using ruby 1.9.2+ and I've just fixed a\
    \ typo in my answer that has since been fixed.\n<|/ c |>\n<| a dscore=0 |>\nTry\
    \ this one.\n<code>\ntext = text[0].chr.downcase + text[1].chr.downcase + text[2].chr.downcase\
    \ + text[3].chr.downcase + text[4].chr.downcase + text[5].chr.downcase + text[6].chr.downcase\
    \ + text[7].chr.downcase + text[8]\n</code>\n<|/ a tags=ruby,ruby-on-rails,regex\
    \ |>\n<| c |>\nThis assumes the string has at least one letter. Being able to\
    \ remove vowels is a pretty basic requirement. :)\n<|/ c |>\n<| c |>\nTrue. I\
    \ just wanted to show the simplest approach. :)\n<|/ c |>\n<| c |>\nThis does\
    \ not work at all. Also `text[7]` and `text[8]` are not defined as strings but\
    \ characters. Also this will make `text` longer than 8 characters.\n<|/ c |>\n\
    <| c |>\nYes, I realized that. Thanks.\n<|/ c |>\n<| a dscore", "  text.gsub!(/[aeiouyAEIOUY]{1}[aeiouyAEIOUY]{1}[aeiouyAEIOUY]{1}[aeiouyAEIOUY]{1}/i,\
    \ '')\n  text.gsub!(/[aeiouyAEIOUY]{1}[aeiouyAEIOUY]{1}[aeiouyAEIOUY]{1}/i, '')\n\
    \  text.gsub!(/[aeiouyAEIOUY]{1}/i, '')\nend", "  return text.gsub(/[aeiou]/i,\
    \ '')\nend", "  if text.length <= 0\n    return text\n  else\n    text.gsub!(/[aeiouy]/,\
    \ '')\n  end\n  return text\nend", "  remove_vowels_helper(text, \"\", \"\", 0)\n\
    end", "    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    return text.downcase.gsub(/[#{vowels.join}]/,\
    \ \"\")\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nYou don't need to use that\
    \ complicated regex. Just do `text.downcase.gsub(/[aeiou]/, '')`.\n<|/ c |>\n\
    <| c |>\nThat works, but I wanted to learn about the ruby hash syntax for doing\
    \ it. It was helpful to me.\n<|/ c |>\n<| c |>\nNo problem. I just added an update\
    \ to the answer. Basically, the hash syntax works like this `my_hash[:some_key]`,\
    \ it means to get the value of a `some_key` key in the hash and assign it to a\
    \ local variable named `some_key`.\n<|/ c |>\n<| a tags=ruby |>\nThis answer has\
    \ already been accepted, but I thought it would be better to show how to do this\
    \ using map (as opposed to gsub):\n<code>", "  text.gsub(/[aeiou]+/,'')\nend",
  "  text.gsub(/[aeiou]*/, '')\nend\n</cell>\n<code language=julia-1.6>", "  # @codes_start\n\
    \  text.downcase!\n  text.gsub!(/[aeiouy][^aeiouy]*/, \"\")\n  text.gsub!(/[aeiouy][aeiouy]*/,\
    \ \"\")\n  text.gsub!(/[aeiouy][AEIOUY]*/, \"\")\n  text.gsub!(/[AEIOUY][aeiouy]*/,\
    \ \"\")\n  text.gsub!(/[AEIOUY][AEIOUY]*/, \"\")\n  text.gsub!(/[AEIOUY][AEIOUY]*/,\
    \ \"\")\n  text.gsub!(/[aeiouy]/, \"\")\n  text.gsub!(/[AEIOUY]/, \"\")\n  text.gsub!(/[aeiouy]/,\
    \ \"\")\n  text.gsub!(/[AEIOUY]/, \"\")\n  text.gsub!(/[aeiouy]/, \"\")\n  text.gsub!(/[AEIOUY]/,\
    \ \"\")\n  text.gsub!(/[aeiouy]/, \"\")\n  text.gsub!(/[AEIOUY]/, \"\")\n  text.gsub!(/[aeiouy]/,\
    \ \"\")\n  text.gsub!(/[AEIOUY]/, \"\")\n  text.gsub!(/[aeiouy]/, \"\")\n  text.gsub!(/[AEIOUY]/,\
    \ \"\")\n  text.gsub!(/[aeiouy]/, \"\")\n  text.gsub!(/[AEIOUY]/, \"\")\n  text.gsub!(/[aeiouy]/,\
    \ \"\")\n  text.gsub!(/[AEIOUY]/, \"\")\n  text.gsub!(/[aeiouy]/, \"\")\n  text.gsub!(/[AEIOUY]/,\
    \ \"\")\n  text.gsub!(/[aeiouy]/, \"\")\n  text.gsub!(/[AEIOUY]/, \"\")\n  text.gsub!(/[aeiouy]/,\
    \ \"\")\n  text.gsub!(/[AEIOUY]/, \"\")\n  text.gsub!(/[aeiouy]/, \"\")\n  text.gsub!(/[AEIOUY]/,\
    \ \"\")\n  text.gsub!(/[aeiouy]/, \"\")\n  text.gsub!(/[AEIOUY]/, \"\")\n  text.gsub!(/[aeiouy]/,\
    \ \"\")\n  text.gsub!(/[AEIOUY", "  text.gsub(/[aeiouAEIOU]+/, '').rstrip\nend",
  "  new_text = \"\"\n  text.each_char do |letter|\n    unless vowels.include?(letter)\n\
    \      new_text += letter\n    end\n  end\n  return new_text\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nI feel like this is probably the right solution, but I'm having\
    \ trouble with implementing it properly. I'm getting the following error when\
    \ I try to run the code: \"undefined method `vowels'\" I'm not sure how to fix\
    \ that.\n<|/ c |>\n<| c |>\nI added more details about the vowels method in the\
    \ answer itself. Hope this helps.\n<|/ c |>\n<| a tags=ruby,string |>\n<code>",
  "  text.gsub(/[aeiou]*/, '')\nend", "  vowels = %w(a e i o u)\n  text.downcase.gsub(/[#{vowels.join}]/,\
    \ '')\nend", "  text.gsub(/[aeiou]/, \"\")\nend", "    text.gsub(/[aeiou]/i, '')\n\
    end\n</cell>\n<text>\nWhat if we wanted to remove all the vowels from the string?\
    \ Using a regular expression? Yes, we can. Nothing else is needed.", "  text.downcase!\
    \ \n  text.gsub(/[aeiou]/i, '')\nend\n</code>\n<|/ a |>\n<| c |>\nThat was my\
    \ first try! It didn't work, even though it looked like it should. I can't see\
    \ why.\n<|/ c |>\n<| c |>\nIt looks like my problem was that I was using a string,\
    \ not a method call. Thanks, everyone who helped!\n<|/ c |>\n<| a |>\nYour code\
    \ looks correct to me but I believe you want the following:\n<code>", "  if text.size\
    \ > 0 then\n    vowels = \"aeiouAEIOU\"\n    begin = 0\n    end = nil\n    found\
    \ = false\n    while end < text.size\n      if text[begin] == vowels[begin] then\n\
    \        found = true\n      else\n        begin = begin + 1\n        if begin\
    \ < text.size - 1 then\n        end\n      end\n    end\n    if found then\n \
    \     text = text[0..begin-1]\n      text = text.reverse\n    end\n  end\n  return\
    \ text\nend", "  text.downcase! \n  text.delete!(vowels.upcase)\n  text.gsub!(\"\
    [aeiouyAEIOUY]\", \"\") \n  text\nend\n</code>\n<|/ a dscore=2 tags=ruby,regex\
    \ |>\n<| c |>\nThis doesn't work. `text.downcase!` converts the string to lower\
    \ case so `'A'` becomes `'a'`. `delete!` removes the whole string if it matches\
    \ an item in the regex. It does not delete characters based on the regex, it deletes\
    \ entire strings that match. e.g. `text.delete!('a')` removes the entire `'A'`\
    \ string from the string. It does not delete `'a'` from the string.\n<|/ c |>\n\
    <| c |>\n`text.downcase!` converts the string to lower case so `'A'` becomes `'a'`.\n\
    `delete!` removes the whole string if it matches an item in the regex. It does\
    \ not delete characters based on the regex, it deletes entire strings that match.\
    \ e.g. `text.delete!('a')` removes the entire `'A'` string from the string. It\
    \ does not delete `'a'` from the string\n<|/ c |>\n<| c |>\n`text.downcase!` converts\
    \ the string to lower case so `'A'` becomes `'a'`.  `delete!` removes the whole\
    \ string if it matches an item in the regex. It does not delete characters based\
    \ on the regex, it deletes entire strings that match. e.g. `text.delete!('a')`\
    \ removes the entire `'A'` string from the string. It does not delete `'a'` from\
    \ the string.\n<|/ c |>\n<| c |>\n`downcase` returns a new string with the characters\
    \ in lower case. `delete!` removes the item from the original string. `downcase!`\
    \ returns the original string but with all the characters in lower case. `delete!`\
    \ returns the original string but with all the characters in lower case. `gsub!`\
    \ replaces all the characters in the original string that match a regex (`[aeiouyAEIOUY]`)\
    \ with an empty string. `delete!` returns the original string but with all the\
    \ characters in lower case. `gsub!` replaces all the characters in the original\
    \ string that match a regex (`[aeiouyAEIOUY]`) with an empty string. `delete!`\
    \ returns the original string but with all the characters in lower case.\n<|/\
    \ c |>\n<| c |>\nI appreciate all of the help here, but please be sure to re-read\
    \ my comment. It isn't the answer, it ", "  if text.nil? or text == \"\"\n   \
    \ return text\n  end\n  text = text.downcase\n  a = [\"a\", \"e\", \"i\", \"o\"\
    , \"u\"]\n  b = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\"\
    , \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\"\
    , \"z\"]\n  t = text.upcase\n  for i in 0...(text.length)\n    if a[i] in t or\
    \ b[i] in t\n      t.delete(i)\n    end\n  end\n  text\nend\n</code>\n<|/ q tags=ruby\
    \ dscore=0 |>\n<| c |>\nWelcome to SO! Please read \"[ask]\" and \"[mcve]\".\n\
    <|/ c |>\n<| c |>\nI don't understand your code. Could you explain more precisely\
    \ what you're trying to achieve?\n<|/ c |>\n<| c |>\nI suggest you take the [CodeReview.SE](http://codereview.stackexchange.com)\
    \ site and ask for help with your code.\n<|/ c |>\n<| c |>\nI am trying to strip\
    \ away all the vowels in a string and return the result of the string.\n<|/ c\
    \ |>\n<| c |>\nThis code is working fine in Ruby 2.0.0.\n<|/ c |>\n<| a |>\nThe\
    \ reason your code doesn't work in Ruby 2 is that .delete(i) doesn't return what\
    \ it deleted but rather nil.\nYou could write it this way:\n<code>", "  return\
    \ text.gsub(/[aeiou]/i, '')\nend\n</cell>\n<cell>", "  text.scan(/[aeiou]/).map{|x|\
    \ x}.join\nend\n</cell>\n<text>\n2.2 - Generate substrings\nNow that you have\
    \ a function that generates all substrings of a given string, let's use it to\
    \ generate all possibilities for the target words. Using a function with parameters,\
    \ you can generate the substrings easily.", "  string.gsub(/[aeiou]/, \"\", text)\n\
    end", "  return text.downcase.gsub(/[aeiou]/i, '')\nend", "  text.gsub!(/[aeiouy]/i,\
    \ '')\n  text.gsub!(/[AEIOUY]/i, '')\n  text.gsub!(/[aeiou]/i, '')\n  text.gsub!(/[AEIOU]/i,\
    \ '')\nend", "  text.gsub(/[aeiou]/, '')\nend", "  text.gsub!(/[aeiou]/, '')\n\
    end", "  text.gsub!(/[aeiouyAEIOUY]+/, '')\nend", "  result = \"\"\n  text.each_char\
    \ do |char|\n    result << char.downcase unless vowels.include? char\n  end\n\
    \  result\nend", "  string.gsub(vowels, \"\", text)\nend", "    string.gsub(/[aeiouAEIOU]+/,\
    \ \"\").reverse.concat(\"\").concat(string.gsub(/[AEIOU]+/, \"\")).reverse\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=ruby dscore=1 |>\n<code>", "  # your code\
    \ goes here\n  # use regular expressions to remove vowels\n  text.gsub!(/[aeiouAEIOU]/,\
    \ '')\n  text.gsub!(/[AEIOUaeiou]/, '')\n  text.gsub!(/[aeiou]/, '')\n  text.gsub!(/[AEIOU]/,\
    \ '')\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for your answer. I tried\
    \ using the above methods, but I got this error after typing the code 'remove_vowels'\
    \ (Method must be called on a Fixnum)\n<|/ c |>\n<| c |>\nYou need to type `remove_vowels`,\
    \ not `remove_vowels(something)`. You are calling the method `remove_vowels` on\
    \ the number `2`, which is not what the method expects. You also don't need to\
    \ use that `if` statement. Just type `text` since `text` will already be the string\
    \ without vowels.\n<|/ c |>\n<| c |>\nThanks. I got rid of the error but now I\
    \ am getting this error.", "  text.gsub(/[aeiou]/i, '')\nend", "  vowels = %w[a\
    \ e i o u]\n  text.downcase!\n  text.gsub(/[#{vowels}]+/, '').downcase\nend",
  "  text.downcase!\n  text.gsub!(/[aeiouy]/i, '')\n  text\nend\n</code>\nAnd that's\
    \ how you use it:\n<code>\nputs remove_vowels.call(\"Hello, World!\")\n</code>\n\
    <|/ a dscore=5 tags=string,ruby |>\n<| c |>\nThis is the best answer!\n<|/ c |>\n\
    <| c |>\nJust to add to this, the string will be empty if there are less than\
    \ three vowels in the string, not zero. Which isn't a problem, as long as it's\
    \ documented.\n<|/ c |>\n<| c |>\nI added the missing `!` on the end of `text.downcase`,\
    \ so that it works in all cases (upper/lower/mixed case).\n<|/ c |>\n<| c |>\n\
    I think it is more efficient to do this in one regex: `/[aeiouy]/i`\n<|/ c |>\n\
    <| c |>\nThe accepted answer doesn't work. Try `remove_vowels.call(\"abcdef\"\
    )` and the result is \"abcdf\".\n<|/ c |>\n<| a tags=string,ruby |>\nIf you want\
    \ to remove all vowels in your string you could do something like this (without\
    \ using regexps):\n<code>\n\"Hello, World!\".gsub(/[aeiou]/, \"\")\n</code>\n\
    Or you could do this:\n<code>\n\"Hello, World!\".gsub(/[aeiouy]/, '')\n</code>\n\
    I guess this is why people invented regexps, because they are pretty efficient\
    \ and fast!\n<|/ a dscore=5 |>\n<| c |>\nYes, but gsub and gsub!, as well as the\
    \ other gsub methods use regexps.\n<|/ c |>\n<| c |>\n`gsub` only returns modified\
    \ string if given block is given, which is not the case here. So it should be\
    \ `gsub(/[aeiou]/, \"\")` instead.\n<|/ c |>\n<| a tags=string,ruby |>\n<code>",
  "  remove_vowels_hash = Hash.new\n  text.each_char do |char|\n    remove_vowels_hash[char]\
    \ = char.upcase if char.upcase =~ /[AEIOUY]/\n  end\n  text.downcase!\n  text.split(\"\
    \").reject { |char| remove_vowels_hash[char] }.join\nend", "  text.gsub! /[aeiou]/,\
    \ \"\"\nend", "    # Return text without vowels\n    text.downcase!\n    text\
    \ = text.gsub(/[aeiouy]/, '')\n    return text\nend\n</cell>\n<cell>", "  text.scan(/[aeiou]+/).map\
    \ { |vowel| vowel.downcase }.join(\"\")\nend\n</code>\n<|/ a |>\n<| a |>\nYou\
    \ can use the gsub method from String:\n<code>\ntext.gsub(/[aeiou]/, \"\")\n</code>\n\
    This takes each letter in the string (text) and removes it if it's an 'e', 'i',\
    \ 'o', or 'u'.\n<|/ a dscore=3 tags=string,ruby |>\n<| c |>\nTo be honest, I didn't\
    \ downvote you. :) I appreciate your answer though.\n<|/ c |>\n<| c |>\nNo problem.\
    \ Sometimes people just like doing things in one line. I think I did a good job\
    \ of explaining why `gsub` is preferred over `gsub!`\n<|/ c |>\n<| c |>\nThank\
    \ you for the explanation.\n<|/ c |>\n<| a tags=string,ruby |>\nYou can use the\
    \ gsub! method on strings to replace all occurrences of a pattern:\n<code>\n\"\
    this is a string\".gsub!(/\\w/, '')\n=> \"ths is a strin\"\n</code>\nThe pattern\
    \ /\\w/, matches any word character (\\w means any letter, number or underscore).\
    \ gsub! will replace all occurrences with the empty string, effectively removing\
    \ them from the string.\n<|/ a dscore=3 |>\n<| c |>\n+1 for `gsub!` over `gsub`,\
    \ which is a more general-purpose method that can take an arbitrary number of\
    \ arguments.\n<|/ c |>\n<| a tags=string,ruby |>\nThe accepted answer's gsub method\
    \ would fail for strings with multiple vowels such as \"aeee\" because the gsub\
    \ method will replace all vowels in the string with a single empty string.  Here's\
    \ a solution that does not require a regular expression.\n<code>", "    vowels\
    \ = 'aeiouAEIOU'\n    return text.gsub(vowels, '')\nend\n</code>\n<|/ a tags=ruby\
    \ dscore=2 |>\n<| c |>\nThanks for your explanation.\n<|/ c |>\n<| a |>\nRuby\
    \ provides many ways to do this task in single line", "  vowels = \"aeiouAEIOU\"\
    \n  text.gsub(vowels, '')\nend", "  text.gsub(/[aeiou]/, \"\").downcase\nend\n\
    </cell>\n<cell>", "  text.downcase!\n  text.gsub(/[aeiou]/i, '') # \"\"\n  text.gsub!(/[^aeiou]/,\
    \ '')\n  text.gsub!(/[aeiou]/, '')\nend\n</cell>\n<cell>", "  text.gsub(/(.)(\\\
    1{2,})/, '\\2')\nend", "  # Solution\n  vowels = %w[a e i o u]\n  text.scan(/[aeiouy]+/).map\
    \ { |s| s[/[aeiouy]+/].delete('y') if s.include?('y') && vowels.include?(s[0])\
    \ }.join\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\nHere is my solution in Ruby:\n\
    <code>", "  text.gsub(/[aeiou]/, '')\nend", "  # Convert text to lower case and\
    \ remove any duplicate characters\n  text.downcase!\n  text.squeeze!\n  text.gsub(/[aeiouyAEIOUY]/i,\
    \ '')\nend", "  if text.count(\"a\") == text.count(\"A\")\n    text.delete(\"\
    a\")\n    text.delete(\"A\")\n  else\n    text\n  end\nend\n</code>\n<|/ a dscore=2\
    \ tags=ruby,ruby-on-rails,regex |>\n<| c |>\nI don't think you should need to\
    \ do `text.delete(\"a\")` and `text.delete(\"A\")`. You don't care if the input\
    \ string is made up of `a` and `A` characters, right?\n<|/ c |>\n<| c |>\nNot\
    \ necessarily, it could be `!text.include? \"a\"` and `!text.include? \"A\"`\n\
    <|/ c |>\n<| c |>\nIn that case you can just do `!text.include?(\"a\")` and `!text.include?(\"\
    A\")`.\n<|/ c |>\n<| c |>\nThat was a typo. Fixed. Thanks.\n<|/ c |>\n<| c |>\n\
    But that doesn't change the fact that `\"a\"` should be `\"A\"` rather than `\"\
    Aa\"`.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,regex |>\nThis would do it:\n<code>",
  "  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  text.downcase!\n  text.gsub(/[aeiou]/i,\
    \ \"\")\n  text.downcase!\n  return text\nend", "  return text.gsub(/[aeiouy]+/,\
    \ '').strip\nend", "  text = text.downcase.scan(/[aeiou]/)\n  text.each do |letter|\n\
    \    text.delete(letter)\n  end\n  return text\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a dscore=0 |>\nThe answer is based on a recursive solution. Using ruby 2.6.5\n\
    <code>", "  text.gsub!(/[aeiouyAEIOUY]/, '')\n  return text\nend", "  return text.gsub(/[aeiou]/,\
    \ '')\nend\n</cell>\n<cell>", "  text.gsub(/[aeiou]/, '')\nend", "    text.gsub(/[aeiou]/i,\
    \ '')\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>", "  text.downcase!\n\
    \  text = text.gsub(/[aeiouy]/, '')\n  text.sub!(/[^a-zA-Z0-9]+/, '')\nend", " \
    \   text.each_char.with_object(\"\") do |char, output|\n        next output unless\
    \ vowels.include?(char)\n        output << char\n    end\nend", "    vowels =\
    \ ('a', 'e', 'i', 'o', 'u')\n    return \"\".join([x for x in text if x not in\
    \ vowels])", "  # Your code here\n  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"\
    ]\n  filtered_text = \"\"\n  \n  if text.include? a\n    filtered_text = filtered_text\
    \ + a \n  elsif text.include? e\n    filtered_text = filtered_text + e\n  elsif\
    \ text.include? i\n    filtered_text = filtered_text + i\n  elsif text.include?\
    \ o\n    filtered_text = filtered_text + o\n  elsif text.include? u\n    filtered_text\
    \ = filtered_text + u\n  else\n    filtered_text = filtered_text + text\n  end\n\
    \  return filtered_text\nend", "  return text.gsub(/[aeiou]/i, '')\nend\n</cell>\n\
    <code language=julia-1.3>", "  remove_vowels_hash = Hash.new\n  text.upcase.split(\"\
    \").each do |char|\n    if char.match(/[aeiou]/)\n      remove_vowels_hash[char]\
    \ = true\n    end\n  end\n  text.downcase.split(\"\").map do |char|\n    if remove_vowels_hash.has_key?(char)\n\
    \      char\n    else\n      char.chr\n    end\n  end.join(\"\")\nend\n</code>\n\
    <|/ a tags=ruby dscore=1 |>\n<| c |>\nThe OP specifically asked for the \"shortest\"\
    \ solution, not necessarily the shortest in terms of lines of code. You've posted\
    \ a solution that uses the same approach, however. You could also have just said\
    \ \"use `gsub(/[aeiou]\\z/, '')`\". I don't think that's what the OP meant.\n\
    <|/ c |>\n<| c |>\n: yes you are correct. As I said, the OP specifically asked\
    \ for the shortest code. By the way, I updated my answer to point out a shorter\
    \ code but still using hash, but also using sub. I would prefer to use sub because\
    \ it is more natural to me. I know my code is \"longer\" than yours. I just think\
    \ it looks more readable to me. But it seems I am not allowed to use sub :)\n\
    <|/ c |>\n<| c |>\nYeah, I realized that after I posted. :) Your solution is definitely\
    \ more compact, but your explanation was very clear. +1. :)\n<|/ c |>\n<| a dscore=0\
    \ |>\nA more compact solution:\n<code>", "  text.gsub!(/[aeiou]/,'')\nend\n</code>\n\
    Then your remove_vowels method can be called without having to redefine it each\
    \ time:\n<code>", "  text = 'aeiouAEIOU'.gsub(/[aeiou]/, '')\n  text = 'AEIOUaeiou'.gsub(/[aeiou]/,\
    \ '')\n  return text\nend", "  text = text.downcase.gsub(/[aeiouy]/, '')\n  return\
    \ text unless text.nil?\nend\n</code>\n<|/ a |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\n<code>", "    text = text.downcase\n    text.gsub!(/[aeiou]/, '')\n    return\
    \ text\nend", "  new_text = \"\"\n  text.each_char do |c|\n    if c != c.downcase\n\
    \      new_text << c\n    end\n  end\n  return new_text\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\n\"Ruby has many cool tools, you can do everything with them!\"\
    \ \u2013 The Ruby Way is to not program yourself but use libraries that already\
    \ exist. For example, `String#delete` would seem to be ideal for this task, since\
    \ it also removes characters that match a regex. Also, consider that `String#scan`\
    \ could be a viable alternative to `String#each_char`.\n<|/ c |>\n<| c |>\nI never\
    \ said that one should use libraries to do this task. `String#delete` could be\
    \ a good solution if this task is not very complicated. `String#scan` can be an\
    \ alternative to `each_char` if this task is more complicated.\n<|/ c |>\n<| c\
    \ |>\nThanks everyone for all the input! I definitely appreciate it.\n<|/ c |>\n\
    <| a dscore=1 tags=ruby,string |>\n<code>", "  if text.length == 0\n    return\
    \ \"\"\n  end\n  text.downcase!\n  text.gsub!(/[aeiouAEIOU]+/, \"\")\n  text.gsub!(/[^aeiou]+/,\
    \ \"\")\nend", "  text.gsub(/[aeiou]/,'').gsub(/[AEIOU]/,'')\nend", "  text.downcase.scan(/[aeiou]/).each\
    \ do |vowel|\n    text.gsub!(vowel, \"\") if text =~ /#{vowel}/\n  end\n  return\
    \ text\nend\n</code>\n<|/ a dscore=0 tags=ruby,string |>\n<| c |>\nNote that `scan`\
    \ returns the matched substrings *as an array*, so you really want `text&.downcase&.scan(/[aeiou]/).map\
    \ { |vowel| text.gsub!(vowel, '') }`\n<|/ c |>\n<| c |>\nI agree with you, I used\
    \ scan in the first place because I thought that would be a cleaner way of removing\
    \ the vowels. I guess it really doesn't make any difference.\n<|/ c |>\n<| a dscore=0\
    \ |>\nRuby's gsub! is probably not the best way here: ", "  text.gsub(/[aeiou]/,\
    \ '')\nend", "  return text.gsub(/[aeiou]/,'')\nend\n</cell>\n<cell>", "    text.gsub!(/[aeiouAEIOU]/,\"\
    \")\n    return text\nend\n</cell>\n<cell>", "  text.gsub!(/[aeiouyAEIOUY]/, '')\n\
    \  text.gsub!(/[AEIOUYaeiouy]/, '')\n  return text\nend\n</code>\n<|/ a dscore=0\
    \ tags=ruby,regex |>\n<| c |>\nI don't think this works, e.g. `remove_vowels(\"\
    aaBAA\")` gives me `\"b\"\"`. Maybe you need to `gsub!` each of the vowels individually\
    \ instead.\n<|/ c |>\n<| a tags=ruby,regex |>\nIf you want a regex that matches\
    \ any word that has at least one non-vowel character and one vowel, use\n<code>\n\
    /\\b(?=[^aeiou]\\W*aeiou)\\w*\\b/\n</code>\nIf you want a regex that matches any\
    \ word that has at least one non-vowel character and no vowels, use\n<code>\n\
    /\\b(?=[^aeiou]\\W*[^aeiou])\\w*\\b/\n</code>\nIf your word is going to be something\
    \ other than a word like \"aaBAA\", you'll need to change the \\b anchors so that\
    \ it doesn't match things like \"aa\" and \"BAA\", and you'll need to change the\
    \ \\w to \\W (as \\w matches non-word characters).\n<|/ a dscore=0 |>\n<| a tags=ruby,regex\
    \ |>\nYou can use the following regex:\n<code>\n/^(?=.*[aeiouy])(?=.*[aeiouy]).*$/i\n\
    </code>\nAnd replace it with: empty string.\n<|/ a dscore=0 |>\n<| c |>\nThis\
    \ doesn't work. For example, `aaBAA` gives `\"\"`.\n<|/ c |>\n<| c |>\nOops, my\
    \ bad.\n<|/ c |>\n<| c |>\nNow it will give `\"\"` for *all* strings of length\
    \ greater than 1.\n<|/ c |>\n<| c |>\nI think this does work (I used the 'i' flag\
    \ and added `#{ }` around it so it could go in a regex), but this regex is needlessly\
    \ complex and complicates the answer. You'd be better off just using a negative\
    \ lookahead to do the same thing.\n<|/ c |>\n<| c |>\nYou're right, I was too\
    \ lazy to do negative lookaheads. Updated the answer.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>", "  return text.downcase.scan(/[aeiou]/).join\nend", "  return text.gsub(/[aeiou]/,'').downcase\n\
    end", "  # Remove all vowels from a text string.\n  text.gsub(/[aeiou]/i, \"\"\
    )\nend", "  text.gsub!(/[aeiou]/, '')\nend\n</code>\n<|/ a tags=ruby,function,string\
    \ |>\n<| c |>\nI think you should also add `text.gsub!(/[^A-Za-z]` to the second\
    \ gsub method.\n<|/ c |>\n<| a tags=ruby,function,string |>\nYou can use the following\
    \ Ruby code:\n<code>", "  text.downcase!\n  text.gsub!(/[aeiou]/, '')\n  text.strip!\n\
    end\n</code>\n<|/ a dscore=3 |>\n<| c |>\n`puts` should be `puts` or `print`.\
    \ Not sure why the `!` has been used in some places.\n<|/ c |>\n<| c |>\nThe `!`\
    \ is not used in places, it is used in methods that are designed to modify the\
    \ string. For example, downcase and gsub are designed to modify the string. `!`\
    \ is used in places such as `replace` and `slice` to modify the string without\
    \ modifying its reference, such as `text = 'a'; text = 'b'; text == 'a'` returns\
    \ `true`. You can read more about it here: https://gist.github.com/jamesrhues/7155467\n\
    <|/ c |>\n<| a dscore=3 |>\nA lot of this has been covered in other answers, but\
    \ here are a few more to add to your knowledge.\nStrings have a lot of different\
    \ operations that you can perform.\nThe Ruby String class has a lot of them. You\
    \ can find them here:", "  text.gsub!(/[aeiouy]+/, \"\")\nend", "    text.downcase!\n\
    \    text.gsub!(/[aeiouAEIOU]+/, \"\")\n    return text\nend", "  # remove vowels\
    \ from each character in text\n  text.each_char{|c| text.delete(c) if !vowels[c]}\n\
    \  text\nend\n</cell>\n<cell>", "  text.gsub(/[aeiou]/, '')\nend\n</cell>\n<text>\n\
    The function remove_vowels is called with each input string in the array text.",
  "  text.gsub(/[aeiouAEIOU]/,\"\")\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby\
    \ |>\n<code>", "  remove_vowels_re = Regexp.new(\"[aeiouyAEIOUY]\", \"gi\")\n\
    \  text.gsub(remove_vowels_re)\nend\n</code>\n<|/ a tags=ruby,regex |>\n<| c |>\n\
    Thanks. I added the vowel checking function. I also added the tests for `remove_vowels`\
    \ and some other things.\n<|/ c |>\n<| c |>\nI did some tests and my function\
    \ is a bit faster.\n<|/ c |>\n<| c |>\nAh, thanks. I added the test `remove_vowels_test\
    \ \"aaaaaa\"` and it passes. Should you update the answer?\n<|/ c |>\n<| c |>\n\
    Just a small addition: this would remove all vowels (not only those defined in\
    \ the `Regexp` constructor). Therefore, `remove_vowels(\"bbbbb\")` would return\
    \ `'bb'`, instead of `'bbb'`. You will have to do `text.gsub(remove_vowels_re,\
    \ '')` instead of `text.gsub(remove_vowels_re)`.\n<|/ c |>\n<| a tags=ruby,regex\
    \ |>\nHere is a quick benchmark, using Benchmark gem:\n<code>\nrequire 'benchmark'",
  "  # return string.gsub(/[aeiou]/i, '')\n  text.gsub(/[aeiou]/i, '')\nend\n</code>\n\
    And this is what it looks like on the console:\n<code>\n> remove_vowels\nfunction\
    \ (text)\n  # return string.gsub(/[aeiou]/i, '')\n  text.gsub(/[aeiou]/i, '')\n\
    end", "  text.gsub(/[aeiouyAEIOUY]/, '')\nend\n</code>\n<|/ a dscore=4 |>\n<|\
    \ a dscore=3 |>\n<code>\nrequire 'set'", "  text.downcase!\n  text.gsub!(/[aeiouAEIOU]/,\
    \ '')\n  text.gsub!(/[AEIOUaeiou]/, '')\n  text\nend", "    text = text.upcase\n\
    \    vowels = \"AEIOU\"\n    vowel_text = text.scan(/[AEIOU]/).flatten\n    result\
    \ = text.gsub(vowel_text, \"\")\n    return result\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=ruby,regex |>\nHere is an approach that makes use of regular expressions\
    \ to do all sorts of cool things.  I'm sure it could be made more efficient, but\
    \ I think the clarity and readability is worth it.\n<code>", "  text.gsub(/[aeiou]/,\
    \ \"\") \nend\n</cell>\n<cell>\nremove_vowels.call(\"\")\nremove_vowels.call(\"\
    abcdef\")\nremove_vowels.call(\"aaaaa\")\nremove_vowels.call(\"aaBAA\")\nremove_vowels.call(\"\
    zbcd\")\n</cell>\n<cell>", "  text.gsub(/[aeiouAEIOU]/,\"\").downcase\nend\n</cell>\n\
    <cell>", "  text.gsub(/[aeiou]/, '')\nend", "  return text.gsub(/[aeiou]/i, '')\n\
    end", "  text.gsub(/[aeiouy]./, '')\nend\n</cell>\n<cell>", "  text.downcase!\n\
    \  text.gsub!(/[aeiou]/i, '')\n  text.strip\nend\n</code>\n<code>", "  text.gsub(/[aeiou]/,\
    \ '')\nend\n</code>\nWe run it on our test data by doing:\n<code>\nremove_vowels(\"\
    aaaaaaBAA\")", "  text.gsub(/[aeiou]/, '')\nend", "  return text.gsub(/[aeiou]/,\
    \ '')\nend\n</code>\n<|/ a |>\n<| a dscore=2 tags=ruby,regex |>\n<code>", "  text.gsub(/[aeiou]/,\
    \ '')\nend", "  return text.gsub(/[aeiou]+/, '')\nend", "  text = text.to_s\n\
    \  text = text.downcase\n  text.gsub!(/[aeiou]/,\"\")\n  return text\nend\n</code>\n\
    The last thing is putting it all together with a helper function:\n<code>", " \
    \ text = text.dup\n  text.gsub(/[aeiou]/, '')\nend", "  text.gsub(/[aeiou]/i,\
    \ '')\nend", "  text.downcase!\n  text.gsub(/[aeiouy]+/, \"\")\nend\n</code>\n\
    The gsub(/[aeiouy]+/, \"\") function replaces any number of vowels in each string\
    \ with an empty string.\n<code>\nremove_vowels.call(\"aaaaa\")", "  text.gsub(/[aeiou]/,\
    \ \"\")\nend", "  text.downcase.scan(/[aeiou]/).each do |letter|\n    text = text.gsub(letter,\
    \ \"\")\n  end\n  text\nend", "    text.gsub(/[aeiou]/, '')\nend", "    text =\
    \ text.downcase\n    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    text.gsub!(/[#{vowels.join}]/,\
    \ \"\")\n    text\nend", "  text.gsub(/[aeiou]/, '')\nend", "  text.tr!(\"aeiouy\"\
    , \"\")\n  text\nend", "  text.gsub!(/[aeiou]/, '')\n  return text\nend\n</cell>\n\
    <text>\nExercise 3: Write a function that takes two strings as arguments and returns\
    \ the length of their longest common subsequences. Your function should only take\
    \ two arguments. Use dynamic programming to implement the function.", "  text.downcase!\n\
    \  text.gsub!(/[aeiou]/, '')\n  text.gsub!(/[AEIOU]/, '')\n  text.gsub!(/[AEIOUaeiouy]/,\
    \ '')\n  text.gsub!(/[aeiouy]/, '')\n  text.gsub!(/[AEIOUYaeiouy]/, '')\n  text.gsub!(/[AEIOUaeiouy]/,\
    \ '')\n  text.gsub!(/[AEIOUaeiouy]/, '')\n  text.gsub!(/[AEIOUaeiouy]/, '')\n\
    \  text.gsub!(/[AEIOUaeiouy]/, '')\n  text.gsub!(/[AEIOUaeiouy]/, '')\n  text.gsub!(/[AEIOUaeiouy]/,\
    \ '')\n  text.gsub!(/[AEIOUaeiouy]/, '')\n  text.gsub!(/[AEIOUaeiouy]/, '')\n\
    \  text.gsub!(/[AEIOUaeiouy]/, '')\n  text.gsub!(/[AEIOUaeiouy]/, '')\n  text.gsub!(/[AEIOUaeiouy]/,\
    \ '')\n  text.gsub!(/[AEIOUaeiouy]/, '')\n  text.gsub!(/[AEIOUaeiouy]/, '')\n\
    \  text.gsub!(/[AEIOUaeiouy]/, '')\n  text.gsub!(/[AEIOUaeiouy]/, '')\n  text.gsub!(/[AEIOUaeiouy]/,\
    \ '')\n  text.gsub!(/[AEIOUaeiouy]/, '')\n  text.gsub!(/[AEIOUaeiouy]/, '')\n\
    \  text.gsub!(/[AEIOUaeiouy]/, '')\n  text.gsub!(/[AEIOUaeiouy]/, '')\n  text.gsub!(/[AEIOUaeiouy]/,\
    \ '')\n  text.gsub!(/[AEIOUaeiouy]/, '')\n  text.gsub!(/[AEIOUaeiouy]/, '')\n\
    \  text.gsub!(/[AEIOUaeiouy]/, '')\n  text.gsub!(/[AEIOUaeiouy]/, '')\n  text.gsub!(/[AEIOUaeiouy]/,\
    \ '')\n  text.gsub!(/[AEIOUaeiouy]/, '')\n  text.gsub", "  text.gsub!(/[aeiouy]{3}/,\
    \ '')\n  text.gsub!(/[AEIOUY]{3}/, '')\n  text.gsub!(/[AEIOUY]{4}/, '')\n  text.gsub!(/[AEIOUY]{5}/,\
    \ '')\n  text.gsub!(/[AEIOUY]{6}/, '')\n  text.gsub!(/[AEIOUY]{7}/, '')\n  text.gsub!(/[AEIOUY]{8}/,\
    \ '')\n  text.gsub!(/[AEIOUY]{9}/, '')\n  text.gsub!(/[AEIOUY]{10}/, '')\n  text.gsub!(/[AEIOUY]{11}/,\
    \ '')\n  text.gsub!(/[AEIOUY]{12}/, '')\n  text.gsub!(/[AEIOUY]{13}/, '')\n  text.gsub!(/[AEIOUY]{14}/,\
    \ '')\n  text.gsub!(/[AEIOUY]{15}/, '')\n  text.gsub!(/[AEIOUY]{16}/, '')\n  text.gsub!(/[AEIOUY]{17}/,\
    \ '')\n  text.gsub!(/[AEIOUY]{18}/, '')\n  text.gsub!(/[AEIOUY]{19}/, '')\n  text.gsub!(/[AEIOUY]{20}/,\
    \ '')\n  text.gsub!(/[AEIOUY]{21}/, '')\n  text.gsub!(/[AEIOUY]{22}/, '')\n  text.gsub!(/[AEIOUY]{23}/,\
    \ '')\n  text.gsub!(/[AEIOUY]{24}/, '')\n  text.gsub!(/[AEIOUY]{25}/, '')\n  text.gsub!(/[AEIOUY]{26}/,\
    \ '')\n  text.gsub!(/[AEIOUY]{27}/, '')\n  text.gsub!(/[AEIOUY]{28}/, '')\n  text.gsub!(/[AEIOUY]{29}/,\
    \ '')\n  text.gsub!(/[AEIOUY]{30}/, '')\n  text.gsub!(/[AEIOUY]{31}/, '')\n  text.gsub!(/[AEIOUY]{32}/,\
    \ '')\n  text.gsub!(/[AEIOUY]{33}/, '')\n  text.gsub!(/[AEIOUY]{34}/, '')\n  text.gsub!(/[AEIOUY]{35}/,\
    \ '')\n  text.", "  text.gsub(/[aeiou]+/, '')\nend\n</cell>\n<text>\n6.2 Reverse\
    \ string\nWrite a function that reverses text (including spaces).", "  text.scan(/[aeiou]/i).map\
    \ {|x| x}.join(\"\")\nend", "  text.gsub(/[aeiou]/, '')\nend", "  return text.gsub(/[aeiou]/,'')\n\
    end", "  text.gsub!(/[aeiouAEIOU]/,\"\") \n  return text\nend", "  text.downcase!\n\
    \  text.gsub(/[aeiou]/, '')\n  text.gsub(/[^aeiou]/, '')\n  text\nend", "  text.chars.reject\
    \ { |char| char.ascii_only? || char.upcase == 'A' || char.upcase == 'O' || char.upcase\
    \ == 'U' || char.upcase == 'a' || char.upcase == 'o' || char.upcase == 'u' }.join\n\
    end\n</code>\nTest:\n<code>\n> remove_vowels.call(\"\")\n\"\"\n> remove_vowels.call(\"\
    abcdef\")\n\"bcdf\"\n> remove_vowels.call(\"aaaaa\")\n\"\"\n> remove_vowels.call(\"\
    aaBAA\")\n\"B\"\n> remove_vowels.call(\"zbcd\")\n\"zbcd\"\n</code>\n<|/ a tags=ruby,string,functional-programming\
    \ |>\n<| a tags=ruby,string,functional-programming |>\n<code>", "  return text.gsub(/[aeiou]/i,\
    \ '')\nend", "  text.gsub(/[aeiou]/.to_s, '')\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a dscore=0 |>\nThis would work:\n<code>", "    text = text.downcase\n    text\
    \ = text.gsub(/[aeiouyAEIOUY]/,\"\")\n    text = text.gsub(/[bcdfghjklmnpqrstvwxyz]/,\"\
    \")\n    text = text.gsub(/[AEIOUYBCDFGHJKLMNPQRSTVWXYZ]/,\"\")\n    text = text.gsub(/[aeiouAEIOUY]/,\"\
    \")\n    text = text.gsub(/[bcdfghjklmnpqrstvwxyz]/,\"\")\n    text = text.gsub(/[AEIOUYBCDFGHJKLMNPQRSTVWXYZ]/,\"\
    \")\n    text = text.gsub(/[^a-zA-Z]/,\"\")\n    text = text.gsub(/\\W/,\"_\"\
    )\n    return text\nend\n</cell>\n<cell>", "  text.scan(/[aeiou]/).flatten.compact.join\n\
    end", "  text = text.dup\n  text.gsub!(/[aeiouy]/, \"\")\n  text.force_encoding(text.encoding)\n\
    \  text\nend", "    text.gsub!(/[aeiouAEIOU]/, '')\nend", "  # Write your function\
    \ here.\n  vowels = \"aeiouAEIOU\"\n  letters = \"\"\n  while text != \"\"\n \
    \   letters = text\n    for letter in letters\n      if letter not in vowels\n\
    \        text = text.replace(letter,\"\")\n  return text\n</code>\nExercise:\n\
    <code>", "  # your code here\n  new_string = \"\"\n  if text != \"\"\n    new_string\
    \ = text.split(\"\").map{|c| c.match?(/[aeiou]/) ? \"\" : c}.join\n  end\n  return\
    \ new_string\nend\n</code>\n<|/ a |>\n<| a |>\n<code>", "  text.tr!(\"aeiouAEIOU\"\
    , \"\")\nend\n</code>\nThis removes vowels from the string and returns the string.\
    \ Now that you have removed the vowels, you can apply the .downcase method to\
    \ the result and capitalize the first letter:\n<code>", "  text.gsub(/[aeiou]/,\
    \ '')\nend", "    str.gsub(/[aeiou]+/, '', text)\nend\n</cell>\n<cell>", "   \
    \ text_array = text.split(\"\")\n    text_array_without_vowels = []"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
