name: HumanEval_64_vowels_count
language: rb
prompt: "# Write a function vowels_count which takes a string representing\n# a word\
  \ as input and returns the number of vowels in the string.\n# Vowels in this case\
  \ are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n# vowel, but only when it is\
  \ at the end of the given word.\n# Example:\n# >>> vowels_count.call(\"abcde\")\n\
  # 2\n# >>> vowels_count.call(\"ACEDY\")\n# 3\ndef vowels_count(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_vowels_count\n\
  \    candidate = method(:vowels_count)\n    assert_equal(2, candidate.call(\"abcde\"\
  ))\n    assert_equal(3, candidate.call(\"Alone\"))\n    assert_equal(2, candidate.call(\"\
  key\"))\n    assert_equal(1, candidate.call(\"bye\"))\n    assert_equal(2, candidate.call(\"\
  keY\"))\n    assert_equal(1, candidate.call(\"bYe\"))\n    assert_equal(3, candidate.call(\"\
  ACEDY\"))\n  end\nend\n"
completions: ["  s.length != s.length.call\n  s.split.map { |c| c[0].call if c.size\
    \ == 2 }.count\nend", "  s.downcase!\n  count = 0\n  s.split(//).each do |i|\n\
    \    count += 1 if i.downcase == \"a\"\n    count += 1 if i.downcase == \"e\"\n\
    \    count += 1 if i.downcase == \"i\"\n    count += 1 if i.downcase == \"o\"\n\
    \    count += 1 if i.downcase == \"u\"\n  end\n  return count\nend", "  s.scan(/[aeiou]/)\n\
    \  return s.count('a') + s.count('e') + s.count('i') + s.count('o') + s.count('u')\n\
    end\n</cell>\n<code language=julia-0.5>\nfunction vowels_count(s)\n  s.scan(/[aeiou]/)\n\
    \  return s.count('a') + s.count('e') + s.count('i') + s.count('o') + s.count('u')\n\
    end\n</cell>\n<code language=julia-0.5>\nvowels_count(s)\n</cell>\n<code language=julia-0.5>",
  "    s.downcase!\n    s.gsub(/[^aeiou]/, \"\")\n    s.chars.each.with_index do |c,\
    \ i|\n        if c == 'a'\n            vowels_count.call[s.slice!(i..i-1)]\n \
    \       end\n    end\n    vowels_count.call[s]\nend\n</cell>\n<code language=julia-1.6>",
  "  if s.length == 0\n    count=0\n  else\n    count=s.length.to_s.length\n    count.times\
    \ do\n      if s.at(count).upcase == \"A\" or s.at(count).upcase == \"E\" or s.at(count).upcase\
    \ == \"I\" or s.at(count).upcase == \"O\" or s.at(count).upcase == \"U\"\n   \
    \     count+=1\n      end\n    end\n  end\n  return count\nend", "\ts.downcase!\n\
    \ts.gsub(/[aeiouy]+/, \"\")\n\ts.count(\"a\")\n\ts.count(\"e\")\n\ts.count(\"\
    i\")\n\ts.count(\"o\")\n\ts.count(\"u\")\nend\n</cell>\n<cell>", "  return s.count(\"\
    a\") +  s.count(\"e\") +  s.count(\"i\") +  s.count(\"o\") +  s.count(\"u\")\n\
    \    ", "  s.chars.each do |c|\n    next unless c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u'\n    if c == 'y' && (s.size - 1).zero?\n      break\n\
    \    end\n  end\n  s.chars.count('a'..'u').to_i\nend\n</cell>\n<cell>\nvowels_count.call(\"\
    abcde\")\n</cell>\n<cell>\nvowels_count.call(\"ACEDY\")\n</cell>\n<cell>", " \
    \ vowels = %w(a e i o u)\n  result = s.count(\"a\") + s.count(\"e\") + s.count(\"\
    i\") + s.count(\"o\") + s.count(\"u\")\n  result -= s.count(\"y\") - s.count(\"\
    Y\")\n  result -= s.count(\"Y\") - s.count(\"y\")\n  result -= s.count(\"Y\")\n\
    \  result -= s.count(\"y\")\n  result -= s.count(\"Y\")\n  result -= s.count(\"\
    y\")\n  result -= s.count(\"y\")\n  result -= s.count(\"Y\")\n  result -= s.count(\"\
    y\")\n  result -= s.count(\"Y\")\n  result -= s.count(\"y\")\n  result -= s.count(\"\
    Y\")\n  result -= s.count(\"y\")\n  result -= s.count(\"Y\")\n  result -= s.count(\"\
    y\")\n  result -= s.count(\"Y\")\n  result -= s.count(\"y\")\n  result -= s.count(\"\
    Y\")\n  result -= s.count(\"y\")\n  result -= s.count(\"Y\")\n  result -= s.count(\"\
    y\")\n  result -= s.count(\"Y\")\n  result -= s.count(\"y\")\n  result -= s.count(\"\
    Y\")\n  result -= s.count(\"y\")\n  result -= s.count(\"Y\")\n  result -= s.count(\"\
    y\")\n  result -= s.count(\"Y\")\n  result -= s.count(\"y\")\n  result -= s.count(\"\
    Y\")\n  result -= s.count(\"y\")\n  result -= s.count(\"Y\")\n  result -= s.count(\"\
    y\")\n  result -= s.count(\"Y\")\n  result -= s.count(\"y\")\n  result -= s.count(\"\
    Y\")\n  result -= s.count(\"y\")\n  result -= s.count(\"Y\")\n  result -= s.count(\"\
    y\")\n  result -= s.count(\"Y\")\n  result -= s.count(\"y\")\n  result -= s.count(\"\
    Y\")\n  result -= s.count(\"y\")\n  result -= s.count(\"Y\")\n  result -= s.count(\"\
    y\")\n  result -= s.count(\"Y\")\n  result -= s.count(\"y\")\n  result -= s.count(\"\
    Y\")\n  result -= s.count(\"y\")\n  result -= s.count(\"Y\")\n  result -= s.count(\"\
    y\")\n  result -= s.count(\"Y\")\n  result -= s.count(\"y\")\n  result -= s.count(\"\
    Y\")", "    count = 0\n    s.split(\"\").each do |letter|\n        count += (letter\
    \ == \"a\" || letter == \"e\" || letter == \"i\" || letter == \"o\" || letter\
    \ == \"u\") ? 1 : 0\n    end\n    count\nend\n</code>\nI tested both these functions\
    \ and they both output the correct results.\n<|/ a dscore=0 |>\n<| c |>\nHey thank\
    \ you for the answer. I was actually asked to do this without using any loops.\
    \ And also without using if statements since it seemed a bit complicated for my\
    \ beginner level.\n<|/ c |>\n<| c |>\nI edited my original answer to include two\
    \ solutions (without using loops and without using if statements) that are both\
    \ very simple and very fast.\n<|/ c |>\n<| c |>\nHey thanks for all the help!\
    \ I actually did it using 2 loops. I just didn't include it in my question. But\
    \ I appreciate the help! Thanks again!\n<|/ c |>\n<| c |>\nNo problem. I added\
    \ my solution as well. I tested it out and it works great.\n<|/ c |>\n<| c |>\n\
    You're right, I should've clarified that I used 2 loops. I was just not sure if\
    \ that was the right solution to my problem. Thanks for the help though, appreciate\
    \ it!\n<|/ c |>\n<| a dscore=0 |>\n<code>", "    vowels = ('a', 'e', 'i', 'o',\
    \ 'u')\n    count = 0\n    for i in s:\n        if i in vowels:\n            count\
    \ += 1\n    return count\n    ", "  s.split('').each do |char|\n    char.match(/[aeiouAEIOU]$/)\
    \ ? vowel_count = vowel_count + 1 : nil\n  end\n  vowel_count\nend", "  vowels\
    \ = ('a', 'e', 'i', 'o', 'u')\n  count = 0\n  i = 0\n  while i < s.length\n  \
    \  count += 1\n    if s[i] == vowels[i]\n      i += 1\n    end\n  end\n  count\n\
    end\n</cell>\n<cell>\nvowels_count(\"abcde\")\n</cell>\n<cell>\nvowels_count(\"\
    ACEDY\")\n</cell>\n<cell>", "  count = 0\n  s.each_char do |c|\n    if c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n      count = count + 1\n \
    \   end\n  end\n  count\nend\n</pre>\n</div>\n<p>Now write a function word_count\
    \ which counts the number of words\nin a given string.</p>\n<pre>", "  s = s.downcase.gsub(/[aeiouy]+/,\
    \ '')\n  s.count('a')\nend", "  s.chars.select { |c| c == \"a\" || c == \"e\"\
    \ || c == \"i\" || c == \"o\" || c == \"u\" }.length\nend\n</code>\nNow your main\
    \ function can be re-written as follows\n<code>", "  if s.length < 1 then\n  \
    \  return 0\n  else\n    count = 0\n    vowels = %w{a e i o u}\n    len = s.length\n\
    \    i = 0\n    while  i < len do\n      if not s[i] in vowels then\n        count\
    \ = count + 1\n      end\n      i = i + 1\n    end\n    return count\n  end\n\
    end\n</cell>\n<text>\nSolution\nYou can now run the code in the cell below.",
  "  s.split(//).count(/[aeiou]/)\nend", "  vowels = %w(aa ae ai oo ou uu ee ei ii\
    \ yy yy y u e i o u)\n  s.scan(/./) do |c|\n    vowels.include?(c) ? c += \" \"\
    \ : c\n  end\nend", "  s.chars.grep(/[aeiou]/).count\nend", "  vowels = %w(a e\
    \ i o u)\n  s.chars.map { |c| vowels.include?(c) }\n    .inject(:+)\nend", " \
    \ return s.scan(/[aeiou]/)[1].length\nend", "  vowels = %w(a e i o u)\n  s.chars.select\
    \ { |char| vowels.include?(char)}.size\nend", "  s.downcase! #\n  s.reverse!\n\
    \  i = 0\n  while i < s.length\n    if s[i] == 'a' || s[i] == 'e' || s[i] == 'i'\
    \ || s[i] == 'o' || s[i] == 'u'\n      i += 1\n    else\n      break\n  end\n\
    \  return i\nend", "  s.scan(/[aeiouy]/)\n  s.count(\"a\")\nend", "  count = 0\n\
    \  s.each_byte { |c| count += 1 if c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u' }\n  count\nend", "  s.scan(/[aeiou]/).size\nend", "  s = s.split(\"\
    \")\n  vowel_count = s.length\n  vowel_count = (vowel_count-1) % vowel_count\n\
    \  vowel_count = (vowel_count+1)%(vowel_count)\n  vowel_count = (vowel_count+1)\
    \ % vowel_count\n  vowel_count = (vowel_count+1) % vowel_count\n  return vowel_count\n\
    \  # Write a function to replace vowels in a string with another letter.\n  #\
    \ Example\n  # >>> replace_vowels.call(\"abcde\", \"a\", \"x\")\n  # \"xbdxy\"\
    \n  # >>> replace_vowels.call(\"ABCDE\", \"A\", \"B\")\n  # \"BCBD\"\n  # >>>\
    \ replace_vowels.call(\"aBcDe\", \"a\", \"B\")\n  # \"bBdC\"\n  # >>> replace_vowels.call(\"\
    aBcDe\", \"a\", \"X\")\n  # \"XcXe\"\n  # >>> replace_vowels.call(\"a b c d e\
    \ f\", \"a\", \"X\")\n  # \"X b c d e f\"\n  # >>> replace_vowels.call(\"a b c\
    \ d e f\", \"a\", \"Y\")\n  # \"YbY c d e f\"\n  # >>> replace_vowels.call(\"\
    a b c d e f\", \"a\", \"z\")\n  # \"azb c d e f\"\n  # >>> replace_vowels.call(\"\
    a b c d e f\", \"a\", \"Z\")\n  # \"a b c d e f\"\n  # >>> replace_vowels.call(\"\
    a b c d e f\", \"a\", \"z\")\n  # \"a b c d e f\"\n  # >>> replace_vowels.call(\"\
    a b c d e f\", \"a\", \"Z\")\n  # \"a b c d e f\"\n  # >>> replace_vowels.call(\"\
    a b c d e f\", \"b\", \"z\")\n  # \"a z c d e f\"\n  # >>> replace_vowels.call(\"\
    a b c d e f\", \"b\", \"Z\")\n  # \"a Z c d e f\"\n  # >>> replace_vowels.call(\"\
    a b c d e f\", \"C\", \"a\")\n  # \"a b c d e f\"\n  # >>> replace_vowels.call(\"\
    a b c d e f\", \"c\", \"a\")\n  # \"a b c d e f\"\n  # >>> replace_vowels.call(\"\
    a b c d e f\", \"c\", \"y\")\n  # \"a b c d e f\"\n  # >>> replace_vowels.call(\"\
    a b c d e f\", \"C\", \"A\")\n  # \"a b c d e f\"\n  # >>> replace_vowels.call(\"\
    a b c d e f\", \"C\", \"y\")\n  # \"a b ", "  s.scan(/[aeiou]/)\n  s.count(\"\
    a\")\nend", "  vowels = %w[a e i o u]\n  s.each_char.with_object(0) do |char,\
    \ count|\n    vowels.include?(char) ? count += 1\n  end\nend", "  a = s.count(\"\
    a\")\n  e = s.count(\"e\")\n  i = s.count(\"i\")\n  o = s.count(\"o\")\n  u =\
    \ s.count(\"u\")\n  \n  y = s.count(\"y\")\n  \n  return a+e+i+o+u+y\n</cell>\n\
    <cell>", "  s.each_char do |c|\n    if c == \"a\" || c == \"e\" || c == \"i\"\
    \ || c == \"o\" || c == \"u\"\n      i += 1\n    elsif c == \"y\"\n      y +=\
    \ 1\n    end\n  end\n  i\nend\n</code>\n<|/ a |>\n<| c |>\nOoo good job! I had\
    \ this problem before, just couldn't figure out what was causing it. It was just\
    \ a case of the logic being off! Thanks.\n<|/ c |>\n<| c |>\nThanks for all the\
    \ help guys. I was having problems understanding how to implement counting variables\
    \ and how to get them out of the functions. I appreciate it.\n<|/ c |>\n<| a dscore=1\
    \ |>\nHere is a solution that uses two for loops to loop through the two strings\
    \ and count the vowels and return them as a hash:\n<code>", "  count = 0\n  s.each\
    \ do |c|\n    count += 1 if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u'\n  end\n  count\nend", "    vowels = (\"a\", \"e\", \"i\", \"o\", \"\
    u\")\n    count = 0\n    for letter in s\n        if letter in vowels\n      \
    \      count += 1\n        end\n    end\n    return count\nend", "  count = 0\n\
    \  s.each_char do |c|\n    case c\n    when \"a\" then count += 1\n    when \"\
    e\" then count += 1\n    when \"i\" then count += 1\n    when \"o\" then count\
    \ += 1\n    when \"u\" then count += 1\n    when \"y\" then count += 1 if c !=\
    \ \"y\" && c.upcase != \"Y\"\n    end\n  end\n  return count\nend", "  s.split(//).select\
    \ do |c|\n    %w(a e i o u).include?(c) || c == 'y'\n  end.count\nend\n</code>\n\
    <|/ a tags=ruby,hash,arrays,counter,string dscore=0 |>\n<| c |>\nThanks for your\
    \ comments. I'm new to Ruby so I hope I understand your comments correctly.\n\
    <|/ c |>\n<| a tags=ruby,hash,arrays,counter,string |>\n<code>", '  return s.scan(/[aeiouy]/).length',
  "  s.scan(/[aeiou]/).count\nend", "  vowels = (\"a\", \"e\", \"i\", \"o\", \"u\"\
    )\n  s = s.downcase\n  s.scan(/[aeiouy]*/) do |vowel|\n    if vowel.last == \"\
    y\"\n      s.delete! vowel\n    end\n  end\n  s.length\nend", "  s.downcase!\n\
    \  vowels = \"aeiou\"\n  count = 0\n  s.each_char do |c|\n    count = count +\
    \ 1 if vowels.include?(c)\n  end\n  count\nend\n</cell>\n<code language=julia-1.5>",
  "  vowels = %w[a e i o u]\n  s.split(//).map(&vowels).inject(0) { |sum, v| sum +\
    \ v.size }\nend", "  s.scan(/[aeiouy]*/)\n  s.count\nend", "  s.upcase!\n  s.downcase!\n\
    \  s.scan(/[aeiouy]/)\n  s.count(\"y\") == 0\nend", "  return s.scan(/[aeiouy]+/).count\n\
    end", "    s.each_char.each_with_index do |char, i|\n        char = char.to_s\n\
    \        break false if char.match(/[aeiouy]$/)\n        break true if char.match(/[aeiou]/)\n\
    \    end\n    s.each_char.count { |char| char.match(/[aeiou]/) }\nend", "    #\
    \ Write your solution here.\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    vowel_count\
    \ = 0\n    for letter in s\n        if letter in vowels\n            vowel_count\
    \ += 1\n    return vowel_count\n    ", "    s.each_char.with_index do |char, index|\n\
    \        vowels = if index == 0\n            \"a\" + \"e\" + \"i\" + \"o\" + \"\
    u\"\n        else\n            \"y\" + \"a\" + \"e\" + \"i\" + \"o\" + \"u\"\n\
    \        end\n        next if char == vowels.last\n        if char == vowels.first\n\
    \            count += 1\n        end\n    end\n    return count\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nIf I am not wrong, this is similar to what I have\
    \ tried. This code should work well for the OP.\n<|/ c |>\n<| a |>\nI solved it...\n\
    The code was actually working but the problem was with my input.\nI used \"abcde\"\
    \ as input and the output was always 0.\nBut the problem is that I was using \"\
    aabcde\", which was the wrong input.\n<|/ a dscore=0 tags=ruby,ruby-on-rails |>\n\
    <| a |>\nThis is a common misconception with Ruby that it's not a purely functional\
    \ language - it is, however, a functional language with functional style. Though\
    \ your question seems really interesting, it isn't about how to solve this problem\
    \ in a Ruby manner, but about how Ruby works internally.\nThis problem is solved\
    \ using Ruby's memoization. Essentially, you wrap a method around your method\
    \ that you want to memoize and store the return value. Here's an example that\
    \ counts the number of vowels in a string with memoization:\n<code>", "  count\
    \ = 0\n  s.each_char do |c|\n    if c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u'\n      count += 1\n    end\n  end\n  return count\nend", "  return\
    \ s.scan(/[aeiou]y/)\nend\n</cell>\n<text>\nvowels_count is now a Ruby method\
    \ and can be called using Python's square brackets.", "  count=0\n  for i in s\n\
    \    if i.downcase==\"a\"||i.downcase==\"e\"||i.downcase==\"i\"||i.downcase==\"\
    o\"||i.downcase==\"u\"\n      count+=1\n    end\n  end\n  count\nend", "  s.downcase!\n\
    \  s.gsub(/[aeiouy]+/, '')\n  s.count('a')\nend", "  s.scan(/[aeiouy]/)\n  s.count(\"\
    a\")\nend", "  s = s.gsub(/[aeiouAEIOU]/, '')\n  return s.count(\"a\")\nend",
  "  s.upcase!\n  s.downcase!\n  s.gsub!(/[^aeiouAEIOU]+/, '')\n  s.gsub(/[aeiouy]/,\
    \ '').length\nend", "  vowel_count = 0\n  \n  s.split(\"\").each do |letter|\n\
    \    letter.ord != 32 &&\n      letter == \"a\" ||\n      letter == \"e\" ||\n\
    \      letter == \"i\" ||\n      letter == \"o\" ||\n      letter == \"u\" ||\n\
    \      letter == \"y\"\n      vowel_count += 1\n  end\n  \n  vowel_count\nend",
  "  s.gsub!(/[aeiou]/i, '').count('a'..'u')\nend\n</code>\n<|/ a |>\n<| a |>\nI took\
    \ advise in comments and turned it into a Ruby gem:\n<code>", "  count = 0\n \
    \ s.each_char do |c|\n    count += 1 if c == 'a' || c == 'e' || c == 'i' || c\
    \ == 'o' || c == 'u'\n  end\n  return count\nend", "  vowels=0\n  s.each_byte\
    \ do |ch|\n    ch=ch.downcase\n    if ch==\"a\"\n      vowels+=1\n    elsif ch==\"\
    e\"\n      vowels+=1\n    elsif ch==\"i\"\n      vowels+=1\n    elsif ch==\"o\"\
    \n      vowels+=1\n    elsif ch==\"u\"\n      vowels+=1\n    elsif ch==\"y\"\n\
    \      if s.index(\"y\")==s.size-1\n        vowels+=1\n      end\n    end\n  end\n\
    \  return vowels\nend", "  s = s.downcase\n  vowels_count = 0\n  s.gsub!(/[AEIOUY]/)\
    \ { |v| vowels_count += 1 }\n  return vowels_count\nend\n</code>\nRuby\n<code>",
  "  return s.scan(/[aeiouy]+/).length\nend", "  if s.include?(\"y\")\n    count =\
    \ s.scan(/[aeiouy]y+/)[0].count\n  else\n    count = s.scan(/[aeiouy]/).count\n\
    \  end\nend", "    vowel_count = 0\n    s.upcase unless vowel_count.nil?\n   \
    \ s.downcase unless vowel_count.nil?\n    s.gsub(/[AEIOUY]/) { vowel_count +=\
    \ 1 }\n    vowel_count\n  end\nend", "  count = 0\n  s.each_char do |c|\n    count\
    \ += 1 if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n  end\n  return\
    \ count\nend", "  return s.scan(/[aeiou]+y/).inject(0) do |acc, char|\n    acc\
    \ + 1 if char == \"y\"\n    acc\n  end\nend", "  s = s.upcase.tr('aeiouy', 'AEIOUY')\n\
    \  s.count('aeiouy').to_i\nend\n</pre>\n<p>\nYou can now call our function <tt>vowels_count</tt>\
    \ like this:\n</p>\n<pre class=\"ruby\">\n<span class=\"ruby-identifier\">vowels_count</span>\
    \ <span class=\"ruby-identifier\">string</span>\n</pre>\n<p>\nAs we can see, <tt>vowels_count</tt>\
    \ is a function which returns the number\nof vowels in the given string. We can\
    \ now use it as you might use any other\nRuby method:\n</p>\n<pre class=\"ruby\"\
    ><span class=\"ruby-identifier\">string</span>.<span class=\"ruby-identifier\"\
    >downcase</span>.<span class=\"ruby-identifier\">scan</span>(<span class=\"ruby-regexp\"\
    >/./</span>).<span class=\"ruby-identifier\">map</span>(&amp;<span class=\"ruby-value\"\
    >:vowels_count</span>).<span class=\"ruby-identifier\">reduce</span> <span class=\"\
    ruby-operator\">|</span><span class=\"ruby-identifier\">a</span>,<span class=\"\
    ruby-identifier\">b</span><span class=\"ruby-operator\">|</span> <span class=\"\
    ruby-identifier\">a</span> <span class=\"ruby-operator\">+</span> <span class=\"\
    ruby-identifier\">b</span> <span class=\"ruby-operator\">+</span> <span class=\"\
    ruby-value\">1</span>\n</pre>\n<p>\nHere we first call <tt>downcase</tt> on our\
    \ string. This converts every\ncharacter into lower case letters. Then we scan\
    \ the resulting array for\nany character (we used <tt>/./</tt> as a shorthand\
    \ for <tt>/./</tt>\nand <tt>/../</tt>). This will return an array of every character\n\
    in the string which is not white space. Then we map the result\nusing <tt>:vowels_count</tt>\
    \ as the key function. The value is actually\nnot very interesting since we only\
    \ want to know how many vowels we have,\nso the value is ignored. We then call\
    \ <tt>reduce</tt> on the result and\nreturn the total of all values which is <tt>a</tt>\
    \ plus <tt>b</tt> plus 1.\n</p>\n<p>\nNow our code becomes even more elegant than\
    \ before.\n</p>\n<p>\n<tt>String#scan</tt> and <tt>String#downcase</tt> are methods\
    \ available on\nany String object. <tt>String#scan</tt> takes a regular expression\
    \ as an\nargument and returns a <tt>Enumerator</tt> of all the matches. <tt>String#downcase</tt>\n\
    takes a string and converts all letters to lower case. Since <tt>scan</tt> returns\
    \ an\nenumerator and <tt>reduce</tt> expects an array, we pass <tt>:vowels_count</tt>\
    \ to\n<tt>reduce</tt>, which calls <tt>vowels_count</tt> on every object in the\
    \ enumerator.\n</p>\n<p>\nYou might wonder why we call <tt>scan", "  s.split(\"\
    \").each_with_object(Hash.new(0)) { |v, h| h[v] += 1 }.\n    values.max\nend",
  "  vowels = \"aeiouy\"\n  vowels_count = 0", "  s.scan(/[aeiou]/)\n  s.count('a')+s.count('e')+s.count('i')+s.count('o')+s.count('u')\n\
    end", "  s.chars.uniq.count(\"aeiouy\")\nend\n</cell>\n<code language=julia-1.5>",
  "  s.scan(/[aeiouy]+/)\n  s.count(\"a\")\nend", "  vowel_count = 0\n  for i in 0..s.length-1\n\
    \    if s[i] == \"a\" || s[i] == \"e\" || s[i] == \"i\" || s[i] == \"o\" || s[i]\
    \ == \"u\"\n      vowel_count += 1\n    end\n  end\n  return vowel_count\nend",
  "    count = 0\n    s.each_byte do |c|\n        if c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u' then\n            count = count + 1\n        end\n\
    \    end\n    count\nend\nputs vowels_count(\"The quick brown fox jumped over\
    \ the lazy dog\") # =>  5\nputs vowels_count(\"The quick brown fox jumped over\
    \ the lazy dog\") # =>  5\nputs vowels_count(\"abracadabra\") # =>  4\nputs vowels_count(\"\
    abracadabra\") # =>  4\nputs vowels_count(\"abracadabra\") # =>  4\nputs vowels_count(\"\
    abracadabra\") # =>  4\nputs vowels_count(\"abracadabra\") # =>  4\nputs vowels_count(\"\
    abracadabra\") # =>  4\nputs vowels_count(\"abracadabra\") # =>  4\nputs vowels_count(\"\
    abracadabra\") # =>  4\nputs vowels_count(\"abracadabra\") # =>  4\nputs vowels_count(\"\
    abracadabra\") # =>  4\nputs vowels_count(\"abracadabra\") # =>  4\nputs vowels_count(\"\
    abracadabra\") # =>  4\nputs vowels_count(\"abracadabra\") # =>  4\nputs vowels_count(\"\
    abracadabra\") # =>  4\nputs vowels_count(\"abracadabra\") # =>  4\nputs vowels_count(\"\
    abracadabra\") # =>  4\nputs vowels_count(\"abracadabra\") # =>  4\nputs vowels_count(\"\
    abracadabra\") # =>  4\nputs vowels_count(\"abracadabra\") # =>  4\nputs vowels_count(\"\
    abracadabra\") # =>  4\nputs vowels_count(\"abracadabra\") # =>  4\nputs vowels_count(\"\
    abracadabra\") # =>  4\nputs vowels_count(\"abracadabra\") # =>  4\nputs vowels_count(\"\
    abracadabra\") # =>  4\nputs vowels_count(\"abracadabra\") # =>  4\nputs vowels_count(\"\
    abracadabra\") # =>  4\nputs vowels_count", "    vowels = \"aeiouAEIOU\"\n   \
    \ words = s.split(\"\")\n    count = 0\n    \n    # Count all non-vowels except\
    \ vowels at the end of the string\n    for word in words\n        if vowels.include?(word[-1])\n\
    \            count += 1\n        end\n    end\n    \n    return count\nend", " \
    \ vowels = (\"a\", \"e\", \"i\", \"o\", \"u\", \"y\")\n  count = 0\n  s.each do\
    \ |v|\n    if vowels.include? v\n      count += 1\n    end\n  end\n  count\nend",
  "  count = 0\n  s.each do |e|\n    if e == \"a\" || e == \"e\" || e == \"i\" ||\
    \ e == \"o\" || e == \"u\" \n      count += 1\n    end\n  end\n  return count\n\
    end\n</code>\n<|/ a |>\n<| a dscore=1 |>\nRuby is known as a scripting language,\
    \ which means it can only do one thing at a time. Thus, you need to do your checks\
    \ and counting before you print out the word. \nTo do this, you need to move the\
    \ logic for counting and checking to a method which you can call before you print.\n\
    I suggest splitting the method into multiple methods. \n<code>", "    count =\
    \ 0\n    s.split('').each do |x|\n        count += 1 if x == 'a' || x == 'e' ||\
    \ x == 'i' || x == 'o' || x == 'u' || x == 'y'\n    end\n    count\nend", "  s.gsub(/[AEIOUYaeiouy]*/i).size\n\
    end", "  count = 0\n  s.each_byte {|c| count += 1 if c == 'a' || c == 'e' || c\
    \ == 'i' || c == 'o' || c == 'u' }\n  count\nend", '  return s.count("a") +s.count("e")
    +s.count("i") +s.count("o") +s.count("u")', "  s.chars.inject(0) do |acc, c|\n\
    \    if c == 'a'\n      acc + 1 if s.endwith? 'a'\n    elsif c == 'e'\n      acc\
    \ + 1 if s.endwith? 'e'\n    elsif c == 'i'\n      acc + 1 if s.endwith? 'i'\n\
    \    elsif c == 'o'\n      acc + 1 if s.endwith? 'o'\n    elsif c == 'u'\n   \
    \   acc + 1 if s.endwith? 'u'\n    end\n  end\nend\n</code>\nThe inject method\
    \ here takes a block, which is executed for each element of the array, and returns\
    \ the value of the block. The block itself takes two arguments: the accumulator\
    \ value and the current element. So we simply check to see if each character is\
    \ a vowel, and add 1 to the accumulator if so. Finally, we return the accumulator\
    \ value.\nThis can be reduced down a little bit by removing the if statements,\
    \ and using a Hash to keep track of which vowels are at the end of the word, and\
    \ the number of vowels that appear:\n<code>", "    s.downcase!\n    s.chars.each\
    \ {|v| return 0 if v != \"a\" && v != \"e\" && v != \"i\" && v != \"o\" && v !=\
    \ \"u\"}\n    s.chars.count(\"aeiou\")\nend", "  return s.count.count('aeiou')\n\
    end", "  count=0\n  vowels=['a','e','i','o','u','y']\n  for i in vowels\n    count\
    \ += s.count(i)\n  return count\nend", "  vowel_count = 0\n  for ch in s\n   \
    \ case (ch)\n    when \"a\" then vowel_count += 1\n    when \"e\" then vowel_count\
    \ += 1\n    when \"i\" then vowel_count += 1\n    when \"o\" then vowel_count\
    \ += 1\n    when \"u\" then vowel_count += 1\n    when \"y\" then vowel_count\
    \ += 1\n    else nil\n    end\n  end\n  vowel_count\nend\n</code>\n<|/ a tags=ruby,count,arrays,string\
    \ |>\n<| c |>\nYou should use `vowel_count = 0` instead of `vowel_count = 0; vowel_count\
    \ += 1 unless vowel_count > 0`\n<|/ c |>\n<| c |>\n: I thought about that too,\
    \ but I think `vowel_count += 1 unless vowel_count > 0` reads better than `vowel_count\
    \ += 1; vowel_count > 0 unless vowel_count > 0` -- although it reads even worse\
    \ since it duplicates `vowel_count` but `vowel_count > 0`.\n<|/ c |>\n<| c |>\n\
    Yes, that makes a lot more sense in those cases. In this case, I can't think of\
    \ a better way to do the same thing without creating a `vowel_count` variable.\
    \ Though I'd probably go with `vowel_count = vowel_count.to_i + 1`.\n<|/ c |>\n\
    <| c |>\n: I agree.  `vowel_count += vowel_count.to_i + 1` reads much better,\
    \ and is a lot more understandable (to me at least).\n<|/ c |>\n<| a tags=ruby,count,arrays,string\
    \ |>\nYou can do:\n<code>", "  s.scan(/[aeiou](?![aeiouy])/)\n  s.count('a')\n\
    end", "\tvowel_count = 0\n\tfor i in 0..(s.length - 1)\n\t\tif (s.slice(i,i +\
    \ 1).to_s.upcase == \"AEIOU\")\n\t\t\tvowel_count += 1\n\t\tend\n\tend\n\treturn\
    \ vowel_count\nend", "  s.chars.count{|c| c == 'a' || c == 'e' || c == 'i' ||\
    \ c == 'o' || c == 'u'}.to_s\nend", "  # Initialize count_vowels to 0.\n  count_vowels\
    \ = 0", "  s.chars.each_with_index.inject(0) do |count,(i,v)|\n    count = count\
    \ + 1 if v == 'a' || v == 'e' || v == 'i' || v == 'o' || v == 'u'\n  end\nend",
  "  count = 0\n  s.each_byte do |c|\n    count += 1 if c == \"a\" || c == \"e\" ||\
    \ c == \"i\" || c == \"o\" || c == \"u\"\n  end\n  count\nend", "  return s.scan(/[aeiou]/).count\n\
    end\n</cell>\n<code language=julia-1.0>", "  vowels = [:a, :e, :i, :o, :u]\n \
    \ vowels_count = s.scan(/[aeiouy]+/).count\n  s.upcase! if vowels_count > 0\n\
    \  vowels_count\nend\n</code>\n<|/ a dscore=4 tags=ruby |>\n<| a dscore=3 tags=ruby\
    \ |>\nYou could also use the count method, which returns the number of times a\
    \ certain element is found in a collection.\n<code>", "  s.downcase!\n  s.upcase!\n\
    \  s.scan(/[aeiouy]$/)\n  s.count\nend", '  return s.count "aeiou"', "  s = s.downcase\n\
    \  vowel_count = 0\n  s.scan(/[aeiouy]/) do |vowel|\n    if vowel ~= /[aeiou]/\n\
    \      vowel_count += 1\n    end\n  end\n  vowel_count\nend", "  s.split(\"\"\
    ).inject(0) {|c,v| c+1 if v in ['a', 'e', 'i', 'o', 'u']}\nend\n</code>\n<|/ a\
    \ dscore=0 |>\n<| c |>\nYes, I thought about that. Unfortunately, I can't use\
    \ anything else than `count`, `inject`, `map`, etc. Any suggestions?\n<|/ c |>\n\
    <| c |>\nOkay, I added a solution which uses `inject`. I think the complexity\
    \ is still O(n), though.\n<|/ c |>\n<| c |>\nNice solution! Thanks a lot. Now\
    \ I just need to figure out how to write this in such a way that it is \"not rubyish\"\
    \ ;)\n<|/ c |>\n<| c |>\nI actually don't know ruby, and I find it to be the more\
    \ \"ruby-ish\" solution, as opposed to functional programming. It's basically\
    \ a one-liner, so it shouldn't be too bad. I think it uses `inject` more or less\
    \ like the `reduce` function in most languages. In Ruby, you can use `inject`,\
    \ but it's more usual to use `reduce` because it's more familiar to Ruby programmers.\
    \ Anyway, if it helped, please upvote and accept!\n<|/ c |>\n<| c |>\nOkay, I'm\
    \ going to accept this answer as it's actually the most rubyish, and it's the\
    \ only one that uses only a method from the standard library, but I'm gonna have\
    \ to accept the other one as it's more detailed.\n<|/ c |>\n<| a tags=ruby,string\
    \ |>\n<code>", "  s = s.downcase\n  s.scan(/[aeiouy]|[AEIOUY]/)\n  s.count('y')\n\
    end", "  s = s.downcase\n  count = 0\n  vowels = ('a', 'e', 'i', 'o', 'u')\n \
    \ s.gsub!(/[aeiou]/,\"\")\n  if s.match(/[aeiouy]$/)\n    count += 1\n  end\n\
    \  s.gsub!(/[^aeiouy]/,\"\")\n  s.gsub!(/[aeiouy]/,\"\")\n  s.gsub!(/[^aeiou]/,\"\
    y\")\n  s.gsub!(/[aeiou]/,\"y\")\n  s.gsub!(/[^aeiou]/,\"y\")\n  s.gsub!(/[aeiou]/,\"\
    y\")\n  s.gsub!(/[aeiou]/,\"y\")\n  s.gsub!(/[aeiou]/,\"y\")\n  s.gsub!(/[aeiou]/,\"\
    y\")\n  s.gsub!(/[aeiou]/,\"y\")\n  s.gsub!(/[aeiou]/,\"y\")\n  s.gsub!(/[aeiou]/,\"\
    y\")\n  s.gsub!(/[aeiou]/,\"y\")\n  s.gsub!(/[aeiou]/,\"y\")\n  s.gsub!(/[aeiou]/,\"\
    y\")\n  s.gsub!(/[aeiou]/,\"y\")\n  s.gsub!(/[aeiou]/,\"y\")\n  s.gsub!(/[aeiou]/,\"\
    y\")\n  s.gsub!(/[aeiou]/,\"y\")\n  s.gsub!(/[aeiou]/,\"y\")\n  s.gsub!(/[aeiou]/,\"\
    y\")\n  s.gsub!(/[aeiou]/,\"y\")\n  s.gsub!(/[aeiou]/,\"y\")\n  s.gsub!(/[aeiou]/,\"\
    y\")\n  s.gsub!(/[aeiou]/,\"y\")\n  s.gsub!(/[aeiou]/,\"y\")\n  s.gsub!(/[aeiou]/,\"\
    y\")\n  s.gsub!(/[aeiou]/,\"y\")\n  s.gsub!(/[aeiou]/,\"y\")\n  s.gsub!(/[aeiou]/,\"\
    y\")\n  s.gsub!(/[aeiou]/,\"y\")\n  s.gsub!(/[aeiou]/,\"y\")\n  s.gsub!(/[aeiou]/,\"\
    y\")\n  s.gsub!(/[aeiou]/,\"y\")\n  s.gsub!(/[aeiou]/,\"y\")\n  s.gsub!(/[aeiou",
  "\ts = s.downcase\n\ts.scan(/[aeiouy]+/)\n\ts.count(\"y\")\nend", "  return s.downcase.count(\"\
    aeiouy\") if s.downcase !~ /[aeiouy]*[^aeiouy]+[aeiouy]+/ else s.count(\"aeiouy\"\
    )\nend", "    count = 0\n    words = s.split # Split the string into words\n \
    \   \n    words.each do |word| # Iterate over each word\n      next if word ==\
    \ \"\" # Skip empty words\n      \n      word.each do |char| # Iterate over each\
    \ character in the word\n        case char # Check if the character is an 'a'\n\
    \        when 'a' then count += 1 # If a is an 'a' then increment the count\n\
    \        when 'e' then count += 1\n        when 'i' then count += 1\n        when\
    \ 'o' then count += 1\n        when 'u' then count += 1\n        when 'y' then\
    \ count += 1 # If 'y' then increment the count\n        end\n      end\n    end\n\
    \    return count\nend", "  vowels = \"AEIOU\"\n  s.split(\"\").map do |char|\n\
    \    vowels.include?(char)\n  end.inject(:+)\nend\n</code>\n<|/ a tags=ruby |>\n\
    <| c |>\nThanks for the answer.\n<|/ c |>\n<| c |>\nYou might want to add a `case`\
    \ statement in there, just in case there is a word that contains more than one\
    \ vowel.\n<|/ c |>\n<| c |>\nYeah, that would be a good addition. Updated the\
    \ answer.\n<|/ c |>\n<| a |>\nTry this:\n<code>", "  count = 0\n  s.each do |c|\n\
    \    if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n      count\
    \ += 1\n    end\n  end\n  return count\nend", "  s.scan(/[aeiou]$/).size\nend",
  "  s.each_byte{|b| vowels.include?(b) ? vowels.delete(b) }\nend\n</cell>\n<code\
    \ language=julia-1.5>", "  s.scan(/[aeiou]/)\n  s.count(\"a\") + s.count(\"e\"\
    ) + s.count(\"i\") + s.count(\"o\") + s.count(\"u\")\nend", "  s = s.downcase\n\
    \  s.split('').select { |c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u' }.size\nend", "    s.gsub(/[aeiou]/){ |v| v == 'y' ? 2 : 1 }\nend", " \
    \   count = 0\n    s.each_char do |c|\n        next if (c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u')\n        if (c == 'y')\n            count\
    \ += 1\n        end\n    end\n    return count\nend", "  s.split(//).each do |x|\n\
    \    x.upcase! if x =~ /^[aeiou]$/\n  end\n  s.count(//)\nend\nputs vowels_count.call(\"\
    ACEDY\")\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThank you! I thought about using\
    \ .count, but I did not know how to implement it correctly. Your example helped\
    \ a lot, thank you.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  s.split(//).map {|s|\
    \ s.upcase }.count(\"AO\")\nend", "  count = 0\n  s.chars.each do |letter|\n \
    \   if letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter\
    \ == 'u'\n      count += 1\n    end\n  end\n  count\nend\n</code>\nAnd that's\
    \ all. Try it out.\n<|/ a dscore=4 |>\n<| c |>\nWhy do you use \"puts s.chars.inspect\"\
    \ instead of \"puts s.inspect\"? Is there any difference?\n<|/ c |>\n<| c |>\n\
    I used `puts` there just to make sure the result is displayed in the console.\
    \ I don't know what IDE you are using, so I just left it there.\n<|/ c |>\n<|\
    \ c |>\nIt would be better to return `count` than to print the output of `inspect`.\
    \  `inspect` returns a string representation of an object, but you are not printing\
    \ it to the console or storing it in any variable, so it seems unnecessary to\
    \ assign it to a variable and then print it afterwards.\n<|/ c |>\n<| c |>\n,\
    \ I agree, that would be better. I have corrected it right now.\n<|/ c |>\n<|\
    \ a |>\nA Ruby way to do it:\n<code>", "  s.chars.each_with_index.reduce(0) {\
    \ |acc, char, idx|\n    (idx == s.length - 1) ? acc : acc + case char\n      when\
    \ 'a' then 0\n      when 'e' then 1\n      when 'i' then 2\n      when 'o' then\
    \ 3\n      when 'u' then 4\n      else -1\n    end\n  }\nend\n</code>\n<|/ a tags=ruby,string,loops\
    \ |>\n<| c |>\nThank you sir. I will try this. I was trying to do the same thing\
    \ in one line and I couldn't think of any way to do the \"if\" statement. Thanks\
    \ again sir.\n<|/ c |>\n<| c |>\nYou are welcome.  I thought you wanted a one-liner\
    \ :)  Glad it worked out!\n<|/ c |>\n<| c |>\nThis code would be better if it\
    \ used `each_char` rather than `chars`.\n<|/ c |>\n<| c |>\nThanks.  I'll make\
    \ those changes and clean it up a bit more.\n<|/ c |>\n<| a |>\n<code>\na = \"\
    Hello World\"\nvowels = ['a','e','i','o','u']\na.gsub(/#{vowels.join('|')}/).scan(/\\\
    w+/).count\n</code>\n<|/ a tags=ruby,string,loops dscore=1 |>\n<| c |>\nI like\
    \ this solution, because it doesn't require a regex per letter, instead it uses\
    \ `Array.join` which builds the regex out of the vowels. Nice job!\n<|/ c |>\n\
    <| c |>\nThanks, I like that solution. I wish I could choose more than one answer\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>\na = \"Hello World\"\na.downcase.scan(/[aeiou]/).count\n\
    </code>\n<|/ a tags=ruby,string,loops |>\n<| c |>\nThanks for answering. I like\
    \ this solution because it doesn't require a regex per letter, instead it uses\
    \ Array.join, which is very cool.\n<|/ c |>\n<| c |>\n: This doesn't use `join`.\
    \ That's why it's better than this answer.\n<|/ c |>\n<| c |>\nAh I see it now.\
    \ Thanks. I like this answer because I don't have to create a regex per letter.\n\
    <|/ c |>\n<| c |>\n: This does require a regex per letter. `/[aeiou]/` builds\
    \ the regex out of the vowels. This is what `join` do", "  vowels = %w( a e i\
    \ o u y )\n  s.count('a'..'z').to_i + s.scan(vowels).inject(0) {|sum, v| sum +\
    \ 1 if v[-1] == 'y' }\nend", "    vowel_count=0\n    vowels = [\"a\",\"e\",\"\
    i\",\"o\",\"u\",\"y\"]\n    for c in s\n        if vowels.include?(c)\n      \
    \      vowel_count+=1\n        end\n    end\n    vowel_count\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nThis answer uses `include?` which is a Ruby method that has been\
    \ deprecated since 1.9.3. Use `vowels.include?(c)` instead.\n<|/ c |>\n<| a |>\n\
    <code>", "  # Initialize the counter with zero\n  count = 0", "  s.scan(/[aeiou]/)\n\
    \  s.scan(/[aeiouy]/)\n  s.count('y')\nend\n</code>\nOutput:\n<code>\nRunning\
    \ each test case...\ntest_vowels_count_returns_2(\"abcde\") => 2\ntest_vowels_count_returns_2(\"\
    ACEDY\") => 3\ntest_vowels_count_returns_2(\"a\") => 1\ntest_vowels_count_returns_2(\"\
    b\") => 1\ntest_vowels_count_returns_2(\"ab\") => 2\ntest_vowels_count_returns_2(\"\
    abc\") => 2\ntest_vowels_count_returns_2(\"abbb\") => 3\ntest_vowels_count_returns_2(\"\
    abbbc\") => 3\ntest_vowels_count_returns_2(\"aA\") => 1\nFinished tests in 0.2233s\n\
    </code>\n<|/ a tags=ruby,regex dscore=2 |>\n<| c |>\nWhile this code may answer\
    \ the question, providing additional context regarding how and/or why it solves\
    \ the problem would improve the answer's long-term value.\n<|/ c |>\n<| a dscore=2\
    \ tags=ruby,regex |>\nYour original solution works fine if you change it to:\n\
    <code>", "    count = 0\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    vowel_pos\
    \ = s.each_char.with_index.select {|a,b| vowels.include?(a) }\n    vowel_pos.each\
    \ do |a, i|\n        if i == (vowel_pos.length - 1)\n            count = count\
    \ + 1\n        end\n    end\n    return count\nend", "  count = 0\n  vowels =\
    \ \"aeiouAEIOU\"\n  s.scan(/[^aeiou]/)\n  s.gsub(/[^aeiouy]/, '')\n  s.scan(vowels)\n\
    \  s.scan(/[aeiouAEIOU]/)\n  s.scan(/[aeiouy]/)\n  s.each_char do |c|\n    count+=1\
    \ if vowels.include?(c)\n  end\n  count\nend\n</code>\n<|/ a dscore=1 tags=ruby,regex,arrays\
    \ |>\n<| a tags=ruby,regex,arrays |>\n<code>", "  s.chars.each_with_index.inject(0)\
    \ { |c, (v, i)| c + (1 if v == \"a\" || v == \"e\" || v == \"i\" || v == \"o\"\
    \ || v == \"u\" || (v == \"y\" && i+1<s.size) }) \nend", "  count = 0\n  s.each_char\
    \ { |c| c != 'y' ? count += 1 }\n  count\nend", "  s.downcase!\n  vowels = %w(aa\
    \ ee ii oo uu)\n  s.split(//).count{|w| vowels.include? w}\nend", "  s.split(//)\n\
    end", "  s.chars.each do |c|\n    c = c.downcase\n    c.gsub!(/[^aeiou]/, '')\
    \ # remove all non-vowels\n    c.gsub!(/y/, '') if c[-1] == \"Y\" # replace all\
    \ 'y's at the end with ''\n    c.chars.each do |cc|\n      cc.each { |ccc| ccc.upcase\
    \ }\n    end\n  end\n  return s.count('aeiou')\nend", "    count = 0\n    s.each\
    \ do |i|\n        count += 1 if i.match(/[aeiou]/)\n    end\n    return count\n\
    end\n</cell>\n<code language=julia-0.5>\nfunction vowels_count(s)\n    count =\
    \ 0\n    s.each do |i|\n        count += 1 if i.match(/[aeiou]/)\n    end\n  \
    \  return count\nend\n</cell>\n<code language=julia-0.5>", "  s.split('').inject(0)\
    \ do |sum, char| \n    if char == 'a' || char == 'e' || char == 'i' || char ==\
    \ 'o' || char == 'u'\n      sum += 1\n    end\n    sum\n  end\nend", "  s.downcase!\n\
    \  s.gsub(/[aeiou]/, '')\n  s.scan(/[aeiouy]/)\n  s.count\nend", "  s.scan(/[aeiou]/)\n\
    \  s.count(s)\nend\n</cell>\n<cell>", "  s.split('').count {|c| c == 'a' || c\
    \ == 'e' || c == 'i' || c == 'o' || c == 'u'}\nend", "    vowels = ['a', 'e',\
    \ 'i', 'o', 'u']\n    count = s.count(\"a\")\n    count += s.count(\"e\")\n  \
    \  count += s.count(\"i\")\n    count += s.count(\"o\")\n    count += s.count(\"\
    u\")\n    return count if vowels.include?(s.last) \n                  else count\
    \ + vowels.count(\"y\")\nend", "  s.each_char do |c|\n    if c == 'a' || c ==\
    \ 'e' || c == 'i' || c == 'o' || c == 'u' then\n      puts c\n    end\n  end\n\
    \  count\nend", "  count = s.count(\"aeiouyAEIOUY\")\n  s.each_byte {|c| if c\
    \ == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' then count = count +\
    \ 1; end}\n  return count\nend", "    # Your code here!\n    return s.count(\"\
    a\")+s.count(\"e\")+s.count(\"i\")+s.count(\"o\")+s.count(\"u\")", "  count =\
    \ 0\n  for i in 0...s.length\n    if s[i] == 'a' || s[i] == 'e' || s[i] == 'i'\
    \ || s[i] == 'o' || s[i] == 'u'\n      count += 1\n    end\n  end\n  return count\n\
    end", "  count = 0\n  s.each do |i|\n    case i\n    when 'a', 'e', 'i', 'o',\
    \ 'u'\n      count += 1\n    end\n  end\n  count\nend", "    vowels_count_letters\
    \ = Array.new\n    vowels_count_letters[:] = []\n    s.each_char do |c|\n    \
    \    if c == \"a\" || c == \"e\" || c == \"i\" || c == \"o\" || c == \"u\"\n \
    \           vowels_count_letters << c\n        end\n    end\n    vowels_count_letters.uniq.length\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThank you for this! I am going to try\
    \ this out now.\n<|/ c |>\n<| c |>\nOk so I made this and I ran it on irb but\
    \ it doesn't seem to want to run. It says \"Invalid argument: abcde\"\n<|/ c |>\n\
    <| c |>\nYou probably ran it under Ruby 1.8.7, which is very old and obsolete.\
    \ You will have to upgrade to a modern Ruby version or use an alternative method.\
    \ `each_char` is part of the standard library since Ruby 1.8.7, so no reason to\
    \ not use it.\n<|/ c |>\n<| c |>\nOk I see. I did have 1.8.7 but I just had to\
    \ upgrade to 1.9.3. Once I did that it worked perfectly. Thank you very much for\
    \ the help!\n<|/ c |>\n<| c |>\nNo problem, I hope I helped!\n<|/ c |>\n<| a tags=ruby,count,string\
    \ dscore=0 |>\n<code>", "  count = 0\n  s.each do |letter|\n    if letter == \"\
    a\" || letter == \"e\" || letter == \"i\" || letter == \"o\" || letter == \"u\"\
    \n      count += 1\n    end\n  end\n  count\nend", "    vowels = \"aeiouy\"\n\
    \    vowel_count = 0\n    for c in s\n        if c in vowels\n            vowel_count\
    \ += 1\n    return vowel_count\nprint(vowels_count.call(\"abcde\"))\nprint(vowels_count.call(\"\
    ACEDY\"))\n</cell>\n<text>\nExercise 4:\nWrite a function to reverse a string\
    \ (that is, it takes a string as input and returns a string with the characters\
    \ in reverse order). The string passed in does not need to be an entire sentence.\n\
    Example:\n>>> reverse(\"Python\")\n\"nohTyP\"\n>>> reverse(\"The quick brown fox\
    \ jumps over the lazy dog\")\n\"ehT quick brown fox jumps ovE the lAZY dog\"\n\
    >>> reverse(\"The quick brown fox jumps over the lazy dog\")\n\"ehT quick brown\
    \ fox jumps ovE the lAZY dog\"\nIf you don't like recursion, try using a loop\
    \ (for, while, etc.).", "  s = s.upcase\n  s.gsub(/[^aeiouy]/, \"\").length\n\
    end\n</code>\nThis solution assumes you have not learned about regular expressions,\
    \ or the Regexp#upcase method. Also, it assumes that \"y\" does not occur in the\
    \ string. If it does occur, it is changed to \"Y\", otherwise it is left untouched.\
    \ \nThe method gsub is used to replace all characters in the string that are not\
    \ vowels with nothing, and then take the length of the result. \nIf you're interested\
    \ in the details of the gsub method and Regexp objects, take a look at http://www.ruby-doc.org/core-2.2.0/Regexp.html.\n\
    <|/ a dscore=0 |>\n<| a |>\n<code>", "  vowels = /[aeiouy]/ \n  s.scan(vowels)\
    \ do |vowel|\n    vowels[vowel].to_i\n  end\nend", "  vowels = 'a','e','i','o','u'\n\
    \  s.each_char do |ch|\n    if vowels.include?(ch)\n      vcount = vcount + 1\n\
    \    end\n  end\n  vcount\nend", "  s.count(\"a\")\n  s.count(\"e\")\n  s.count(\"\
    i\")\n  s.count(\"o\")\n  s.count(\"u\")\n  s.count(\"Y\")\nend", "  s.split(\"\
    \").count(\"aeiou\")\nend", "  s.count('a')+s.count('e')+s.count('i')+s.count('o')+s.count('u')\n\
    end", "  vowels_count = 0\n  s.upcase!\n  s.gsub(/[^aeiouAEIOU]/i) { vowels_count\
    \ += 1 }\n  vowels_count\nend", "  s.chars.each do |c|\n    c != 'a' && c != 'e'\
    \ && c != 'i' && c != 'o' && c != 'u' && c != 'y'\n  end\n  s.chars.size\nend",
  "  s.downcase!\n  return s.scan(/[aeiou]/).inject(0) { |c,v| c + (v.end_with?('y')\
    \ ? 1 : 0)}\nend\n</code>\nNow we can run a test case:\n<code>\nputs vowels_count(\"\
    abcde\")    # => 2\nputs vowels_count(\"ACEDY\")    # => 3\nputs vowels_count(\"\
    aday\")     # => 2\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| a tags=ruby |>\n\
    If you're trying to figure out how to count the letters in each word (as opposed\
    \ to just counting them all together for all the words in the string) then you\
    \ can do the following:\n<code>", "  s = s.downcase\n  s.count(\"a\")\n  s.count(\"\
    e\")\n  s.count(\"i\")\n  s.count(\"o\")\n  s.count(\"u\")\n  s.count(\"y\")\n\
    end\n</cell>\n<code language=julia-1.0>", "  s.downcase!\n  s.count(\"aeiou\"\
    )\nend", "  s.each_char.with_object(Hash.new(0)) { |c, h| h[c] += 1  if c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u'  }.values.reduce(:+)\nend",
  "  vowels = %w[a e i o u]\n  s.split.each do |word|\n    word = word.downcase\n\
    \    return 0 if word.empty?\n    word.chars.each do |char|\n      return 0 if\
    \ vowels.include?(char)\n    end\n  end\n  0\nend", "  return s.split('').select{|letter|letter=='a'\
    \ || letter=='e' || letter=='i' || letter=='o' || letter=='u'}.count\nend", " \
    \ letters = s[1..-1]\n  letters.each do |l|\n    case l\n    when \"a\",\"e\"\
    ,\"i\",\"o\",\"u\"\n      return 1\n    when \"y\"\n      return 2\n    end\n\
    \  end\n  0\nend\np vowels_count(\"abcde\")\np vowels_count(\"ACEDY\")\nputs\n\
    puts", "  s.scan(/[aeiou]/).size\nend\n</cell>\n<text>\nWe can use this same function\
    \ we wrote to create a hash with the word count of the letters in the word 'elephant'\
    \ as the key.", "  vowels = 'aeiouAEIOU'\n  vowel_count = 0\n  s.each do |char|\n\
    \    if vowels.include?(char)\n      vowel_count += 1\n    end\n  end\n  vowel_count\n\
    end", "  count = 0\n  s.each_index do |i|\n    if s[i] == \"a\"\n      count +=\
    \ 1\n    elsif s[i] == \"e\"\n      count += 1\n    elsif s[i] == \"i\"\n    \
    \  count += 1\n    elsif s[i] == \"o\"\n      count += 1\n    elsif s[i] == \"\
    u\"\n      count += 1\n    end\n  end\n  return count\nend", "  s = s.downcase\n\
    \  count = 0\n  s.gsub!(/[aeiouy]+/, '')\n  s.gsub!(/[^aeiouy]+/, '')\n  s.each_char\
    \ {|c|\n    if c == 'a'\n      count += 1\n    elsif c == 'e'\n      count +=\
    \ 1\n    elsif c == 'i'\n      count += 1\n    elsif c == 'o'\n      count +=\
    \ 1\n    elsif c == 'u'\n      count += 1\n    elsif c == 'y'\n      count +=\
    \ 1\n    end\n  }\n  count\nend", "  s.each_byte do |b|\n    v = b\n    if v ==\
    \ a.ord and v == e.ord and v == i.ord and v == o.ord and v == u.ord\n      count\
    \ += 1\n    end\n  end\n  return count\nend", "    vowels = ['a','e','i','o','u']\n\
    \    vowels_count = 0\n    vowels_count = s.count('a') + (s.count('e') + s.count('i')\
    \ + s.count('o') + s.count('u'))\n    if s[-1] in vowels\n        vowels_count+=1\n\
    \    return vowels_count", "  s.downcase!\n  s.gsub!(/[aeiouy]/, '')\n  s.count('a')\
    \ + s.count('e') + s.count('i') + s.count('o') + s.count('u')\nend", "  vowels\
    \ = \"aeiouy\"\n  vowel_count = 0\n  for v in vowels\n    if v == s[s.length-1]\n\
    \      vowel_count += 1\n    end\n  end\n  return vowel_count\nend\n</code>\n\
    And now that you know how to use a loop to count the number of vowels, you can\
    \ take it further, using map and grep.\n<code>", "  vowels = %w(a e i o u)\n \
    \ s.downcase!\n  s.scan(/[aeiou]$/) do |match|\n    vowels.include?(match[-1].ord\
    \ % 0x20) ? 1 : 0\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nIt seems to me that\
    \ `vowels.include?(match[-1].ord % 0x20) ? 1 : 0` should be `vowels.include?(match[-1].ord\
    \ % 0x20) ? match[-1].ord % 0x20 : 0` so that you can get the correct vowel count\
    \ on `\"aAcA\"`. However, this also works fine for `\"aAcAy\"` (which gives `1`)\n\
    <|/ c |>\n<| c |>\nThanks for the feedback; I've updated my answer based on your\
    \ feedback.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  vowels = (\"a\", \"e\", \"\
    i\", \"o\", \"u\")\n  count = 0\n  s.split(\"\").each do |letter|\n    if vowels.include?(letter)\n\
    \      count += 1\n    end\n  end\n  count\nend", "  vowels_count = 0\n  s.upcase!\n\
    \  s.chars.each do |ch|\n    if ch == \"a\" || ch == \"e\" || ch == \"i\" || ch\
    \ == \"o\" || ch == \"u\"\n      vowels_count += 1\n    end\n  end\n  return vowels_count\n\
    end", "  count = 0\n  for i in [s[0]] + s.chars\n    if i.upcase == 'A' || i.upcase\
    \ == 'E' || i.upcase == 'I' || i.upcase == 'O' || i.upcase == 'U'\n      count\
    \ += 1\n  end\n  count\nend", "    s.count(\"aeiou\") # Count the vowels in the\
    \ string\nend\n</cell>\n<cell>", "    vowels = %w[a e i o u]\n    vowels.each\
    \ do |vowel|\n        if s.include?(vowel)\n            count = s.count(vowel)\n\
    \            if s.include?(\"y\")\n                count += 2\n            end\n\
    \            return count\n        end\n    end\n    return 0\nend", "  s.split('').inject(0)\
    \ do |sum, v|\n    sum + 1 if v == 'a' || v == 'e' || v == 'i' || v == 'o' ||\
    \ v == 'u'\n  end\nend", "  count = 0\n  s.downcase!\n  s.gsub!(/[aeiou]y$/, '')\n\
    \  s.gsub!(/a$/, '')\n  s.gsub!(/y$/, '')\n  s.gsub!(/[aeiou]$/, '')\n  s.gsub!(/[^aeiou]$/,\
    \ '')\n  s.each_char do |c|\n    next if c == 'a' || c == 'e' || c == 'i' || c\
    \ == 'o' || c == 'u'\n    count += 1\n  end\n  return count\nend\n</code>\n<|/\
    \ a tags=ruby,regex |>\n<| c |>\nThank you,.  I thought there might have been\
    \ a way to do it without having to remove all the vowels but that seemed like\
    \ it would be too much work.  It was much easier to do this that way.\n<|/ c |>\n\
    <| c |>\nThis won't work for the input `\"abyc\"`, which has 3 vowels. Also, it\
    \ is possible to do without regex `\"abyc\".gsub!(/[aeiou]$/, \"\").count('aeiou')`.\n\
    <|/ c |>\n<| a |>\nThis regex works fine for me.\n<code>\nstr = \"abycy\"", " \
    \ s = s.downcase\n  s.scan(/[aeiou]/)\n  s.count(\"y\") if s.count(\"y\") == 1\
    \ end\nend", "  s.scan(/[aeiou]/i)\n  s.count('a')\n  s.count('e')\n  s.count('i')\n\
    \  s.count('o')\n  s.count('u')\nend\n</cell>\n<code language=julia-1.0>\n@test\
    \ vowels_count(\"abcde\") == 2\n@test vowels_count(\"ACEDY\") == 3\n</cell>\n\
    <text>\nIn the following challenge, please complete the function by adding your\
    \ code.", "  count = 0\n  for i in s\n    if i == \"a\"\n      count = count +\
    \ 1\n    elsif i == \"e\"\n      count = count + 1\n    elsif i == \"i\"\n   \
    \   count = count + 1\n    elsif i == \"o\"\n      count = count + 1\n    elsif\
    \ i == \"u\"\n      count = count + 1\n    end\n  end\n  count\nend", "\ts = s.to_s\n\
    \ts.chars.each do |c|\n\t\tif c == \"a\" || c == \"e\" || c == \"i\" || c == \"\
    o\" || c == \"u\"\n\t\t\ts << c\n\t\tend\n\tend\n\ts.chars.size\nend\n</cell>\n\
    <cell>", "  s.length.times.reduce do |c, i|\n    (c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u') ? c : c+1\n  end\nend\n</code>\nI guess you already\
    \ know how to use reduce, but here is another way to do the same thing without\
    \ using reduce:\n<code>", "  s.downcase!\n  s.scan(/[aeiouy]/)\n  s.count(\"y\"\
    )\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nHow do you write this in Ruby 1.9?\n\
    <|/ c |>\n<| c |>\n`s.downcase!` needs to be `s.downcase!`\n<|/ c |>\n<| c |>\n\
    Thanks for the correction, I have updated the answer.\n<|/ c |>\n<| a tags=ruby\
    \ dscore=0 |>\nHere's a one liner\n<code>\n\"abcde\".scan(/[aeiouy]/).count(\"\
    y\")\n=> 2\n</code>\n<|/ a |>\n<| a |>\n<code>\n'abcde'.scan(/[aeiouy]y/).size\n\
    </code>\n<|/ a tags=ruby dscore=0 |>\n<| c |>\nI like the idea! However it raises\
    \ an error for `\"abc\".scan(/[aeiouy]y/).size` which is `0`. Why is that?\n<|/\
    \ c |>\n<| c |>\nIt does not raise an error, it returns nil. I think that `[aeiouy]y`\
    \ matches `\"y\"` but does not match `\"\"`\n<|/ c |>\n<| c |>\nYes, but it does\
    \ not match the empty string. Try `'abc'.scan(/[aeiouy]y/).size`.\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>\ns = \"abcde\"\nv = s.scan(/[aeiouy]y/)\np v.count \"\
    y\" \n</code>\n<|/ a tags=ruby |>\n<| c |>\nHow would you add `count` after the\
    \ expression?\n<|/ c |>\n<| c |>\nYou could just do `v.count(\"y\")`\n<|/ c |>\n\
    <| a tags=ruby |>\n<code>\nword = 'abcde'\nword.upcase.split(//).reject(&:empty?).count('y')\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nCan you explain how this answers the question?\n\
    <|/ c |>\n<| c |>\nYes I can, upcase converts everything into uppercases and then\
    \ splits the words into an array. reject removes all empty values and then counts\
    \ the number of y\n<|/ c |>\n<| c |>\nBut `word.upcase.split(//).reject(&:empty?)`\
    \ results in `", "  vowels = %w(aa ae ai ao au)\n  s.downcase!\n  s.tr!('aeiou',\
    \ 'y')\n  s.split.inject(0) do |cnt, v|\n    vowels.include?(v) ? cnt + 1 : cnt\n\
    \  end\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby |>\n<code>", "  s = s.downcase\n\
    \  s.scan(/[aeiou]/)\n  s.count('aeiou')\nend", "\tvowels = \"aeiouy\"\n\tcount\
    \ = 0\n\tfor i in s\n\t\tif vowels.index(i) then count+=1\n\tputs count\nend",
  "  count = 0\n  s.each_char { |c| c =~ /[aeiou]/i ? count++ : nil }\n  count\nend",
  "  s.downcase!\n  s.chars.each do |c|\n    c != 'a' && c != 'e' && c != 'i' && c\
    \ != 'o' && c != 'u' && c!='y'\n  end\n  s.count('a') + s.count('e') + s.count('i')\
    \ + s.count('o') + s.count('u') + s.count('y')\nend\n</cell>\n<cell>", "\ts.downcase!\n\
    \ts.each_char {|char| return true if 'a'.eql?(char) or 'e'.eql?(char) or 'i'.eql?(char)\
    \ or 'o'.eql?(char) or 'u'.eql?(char) }\n\ts.count(\"aeiou\")\nend", "\ts.scan(/[aeiouy]+/)\n\
    \ts.count('a')\nend\n</cell>\n<cell>", "  s.downcase!\n  s.scan(/[aeiou]$/).inject(0)\
    \ {|sum, v| sum + 1 if v == 'a' or v == 'e' or v == 'i' or v == 'o' or v == 'u'\
    \ }\nend\n</code>\nI guess it's quite unreadable but I tried to make it as simple\
    \ as possible.\n<|/ a dscore=0 |>\n<| c |>\nThis does not work for me with Ruby\
    \ 2.3.4 and Rails 5.2.4.  It gives me a blank page.\n<|/ c |>\n<| c |>\nWhich\
    \ version of ruby and rails are you using?\n<|/ c |>\n<| c |>\nAh, I fixed it\
    \ by changing this part:", "  s.split('').select { |char|\n      char.match(/^[aeiouy]+$/)\n\
    \  }.count\nend", "  s.scan(/[aeiouy]+/).count\nend", "  count=0\n  vowels = \"\
    aeiouAEIOU\"\n  s.split(\"\").each do |char|\n    count += 1 if vowels.include?(char)\n\
    \  end\n  count\nend", "  vowels = %w[a e i o u]\n  s.chars.inject(0) do |count,\
    \ char|\n    char == 'y' ? count + 1 : count.succ\n  end\nend\n</pre>\n</div>\n\
    </div>\n</div>\n</div>\n<div class=\"cell border-box-sizing text_cell rendered\"\
    ><div class=\"prompt input_prompt\">\n</div><div class=\"inner_cell\">\n<div class=\"\
    text_cell_render border-box-sizing rendered_html\">\n<p>But there's a better way\
    \ to do this: using a method in the String class!</p>\n<p>The <code>String#count</code>\
    \ method is a more general-purpose way of doing this.</p>\n<p>Here's how it works:</p>\n\
    <ul>\n<li><code>String#count</code> is essentially just an alias for <code>Enumerable#count</code>.</li>\n\
    <li><code>Enumerable#count</code> has a special case that returns 0 for empty\
    \ strings, and\nreturns the length of the collection for non-empty strings.</li>\n\
    <li><code>String#count</code> will return the number of occurrences of what it's\n\
    given as an argument, in the string. It counts non-nil strings as well,\njust\
    \ like <code>Array#count</code>, except it counts nil strings also as a\nnon-nil\
    \ string.</li>\n</ul>\n<p>The <code>String#count</code> method has this behavior:</p>\n\
    <ul>\n<li><code>\"abcd\".count('d') == 3</code></li>\n<li><code>\"abcd\".count('x')\
    \ == 0</code></li>\n<li><code>\"abcd\".count('a') == 4</code></li>\n<li><code>\"\
    abcd\".count('d') == 3</code></li>\n<li><code>\"\".count('x') == 0</code></li>\n\
    </ul>\n<p>So if <code>s</code> is a <code>String</code> object, <code>s.count('x')</code>\
    \ will return <code>nil</code>.</p>\n<p>Here's the <code>String#count</code> method\
    \ from the <a href=\"http://www.ruby-doc.org/core-2.1.2/String.html\">Ruby docs</a>\
    \ with the extra case we discuss above:</p>", "  return s.count(\"aeiouyAEIOUY\"\
    )\nend\n</cell>\n<code language=julia-1.5>", "  s = s.downcase\n  s.scan(/[aeiouy]+/)\n\
    \  s.count(\"y\")\nend", "  s.split(\"\").inject(0) {|sum, letter| sum += letter\
    \ == 'a' ? 1 : letter == 'e' ? 1 : letter == 'i' ? 1 : letter == 'o' ? 1 : letter\
    \ == 'u' ? 1 : 0 }\nend\n</code>\nThis may seem long and repetitive, but it is\
    \ much more readable than the code above, and it is much more compact than any\
    \ solution which involved looping through the whole string.\n<|/ a dscore=2 tags=ruby,string,ruby-on-rails\
    \ |>\n<| a dscore=1 tags=ruby,string,ruby-on-rails |>\n<code>", "  # TODO: implement\
    \ vowels_count\n  return 0\nend", "  s.split.count 'a','e','i','o','u','y','y'\n\
    end\n</cell>\n<text>\nThe .split method of a string returns a new array containing\
    \ all the words in the string.\nSo the above code says \"count the occurrences\
    \ of the letters 'a','e','i','o','u' and 'y' in each word and return the result\"\
    .\nWe could have used the code s.split.count 'a','e','i','o','u','y' instead of\
    \ what I have above but that is just more compact.", "  s = s.to_s\n  vowel_count\
    \ = 0\n  vowel_count += 1 if s.index(\"a\") == 0\n  vowel_count += 1 if s.index(\"\
    e\") == 0\n  vowel_count += 1 if s.index(\"i\") == 0\n  vowel_count += 1 if s.index(\"\
    o\") == 0\n  vowel_count += 1 if s.index(\"u\") == 0\n  vowel_count += 1 if s.index(\"\
    y\") == 0\n  vowel_count += 1 if s.index(\"Y\") == 0\n  vowel_count\nend", " \
    \ if s.downcase.count(\"aeiou\") == s.size\n    vowels_count(s.upcase)\n  else\n\
    \    s.size\n  end\nend\n</code>\n<|/ q tags=ruby dscore=0 |>\n<| c |>\nYour code\
    \ does not return any value. Also, it is very difficult to read code without proper\
    \ indentation. Could you please update your question?\n<|/ c |>\n<| c |>\nMy first\
    \ question is whether you really need to write the code yourself or if it can\
    \ be done in some other way that makes it easier for you to learn. Secondly, do\
    \ you know what `return` does? Thirdly, does your code run at all? Have you tried\
    \ running it? If not, why not?\n<|/ c |>\n<| c |>\nI have added the full program.\
    \ I need help with writing the method that returns the number of vowels.\n<|/\
    \ c |>\n<| c |>\nI have added the full program. I need help with writing the method\
    \ that returns the number of vowels.\n<|/ c |>\n<| a |>\nIt looks like you're\
    \ trying to use recursion, but you've got your returns in the wrong place:\n<code>",
  "    count = 0\n    for character in s\n        if character == \"a\"\n        \
    \    count += 1\n        if character == \"e\"\n            count += 1\n     \
    \   if character == \"i\"\n            count += 1\n        if character == \"\
    o\"\n            count += 1\n        if character == \"u\"\n            count\
    \ += 1\n        if character == \"y\"\n            count += 1 unless s[end - 1]\
    \ == \"a\"\n    end\n    count\nend", "  s.scan(/[aeiouyAEIOUY]/)\nend\n</cell>\n\
    <text>\nExercise: Write a function, count_chars, which takes a string and a character\
    \ as input and returns the number of times the character appears in the string.",
  "  s.gsub!(\"[aeiouy]\", \"\") \n  s.count(\"a\")+s.count(\"e\")+s.count(\"i\")+s.count(\"\
    o\")+s.count(\"u\")\nend", "  count = 0\n  s.downcase!\n  s.chars.each do |c|\n\
    \    case c\n    when 'a', 'e', 'i', 'o', 'u'\n      count += 1\n    end\n  end\n\
    \  count\nend\n</code>\nThis can be turned into a more Ruby-esque version using\
    \ methods:\n<code>", "    vowels = \"aeiouy\"\n    count = 0\n    letters = s.split('')\n\
    \    for i in letters\n        if vowels.include?(i)\n            count += 1\n\
    \    return count\n    ", "  # Write your code here.\n  vowels = [\"a\", \"e\"\
    , \"i\", \"o\", \"u\"]\n  vowel_count = 0\n  s.to_s.split(\"\").each do |word|\n\
    \    word.each do |letter|\n      vowels.include?(letter) ? vowel_count += 1 :\
    \ next\n    end\n  end\n  return vowel_count\nend\n</code>\n<|/ a tags=string,ruby,methods,counter\
    \ |>\n<| a dscore=0 |>\nUsing each_char:\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
