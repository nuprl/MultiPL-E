name: HumanEval_44_change_base
language: rb
prompt: "# Change numerical base of input number x to base.\n# return string representation\
  \ after the conversion.\n# base numbers are less than 10.\n# >>> change_base.call(8,\
  \ 3)\n# \"22\"\n# >>> change_base.call(8, 2)\n# \"1000\"\n# >>> change_base.call(7,\
  \ 2)\n# \"111\"\ndef change_base(x, base)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_change_base\n\
  \    candidate = method(:change_base)\n    assert_equal(\"22\", candidate.call(8,\
  \ 3))\n    assert_equal(\"100\", candidate.call(9, 3))\n    assert_equal(\"11101010\"\
  , candidate.call(234, 2))\n    assert_equal(\"10000\", candidate.call(16, 2))\n\
  \    assert_equal(\"1000\", candidate.call(8, 2))\n    assert_equal(\"111\", candidate.call(7,\
  \ 2))\n    assert_equal(\"2\", candidate.call(2, 3))\n    assert_equal(\"3\", candidate.call(3,\
  \ 4))\n    assert_equal(\"4\", candidate.call(4, 5))\n    assert_equal(\"5\", candidate.call(5,\
  \ 6))\n    assert_equal(\"6\", candidate.call(6, 7))\n    assert_equal(\"7\", candidate.call(7,\
  \ 8))\n  end\nend\n"
completions: ["  # Base must not be less than 10.\n  unless base >= 2\n    fail 'Base\
    \ must be less than 10.'\n  end", "  if base <= 0 or base >= 10\n    raise ArgumentError\
    \ \"invalid base\"\n  return x.to_s.reverse.gsub(\"(#{base})\".to_sym, base.to_s)\
    \ rescue x\nend", "  x = x.to_s(base)\n  raise \"base#{base} is greater than the\
    \ maximum base\" if base > 62\n  raise \"base#{base} is less than the minimum\
    \ base\" if base < 2\n  return x unless x.kind_of?(String)\n  z = x.gsub(/[\\\
    d]/) { |s| s.to_i * base + $&.ord + s.ord }\n  raise \"no leading zero on #{z}\"\
    \ if z.to_s.empty?\n  z\nend", "  if base < 0 or base > 8\n    error(\"base must\
    \ be between 0 and 8\")\n  end\n  \n  result = \"\"\n  \n  i = 0\n  \n  while\
    \ i < length(x)\n    \n    if x[i] > 9\n      \n      if base > 10\n        error(\"\
    base must be less than 10\")\n      end\n      \n      x_copy = copy(x)\n    \
    \  x_copy[i] = x_copy[i] - 10\n      x_copy[i] = x_copy[i] * base\n      \n  \
    \    x = x_copy\n      \n      i = 0\n      \n      while i < length(x)\n    \
    \    \n        if x[i] > 9\n          \n          if base > 10\n            error(\"\
    base must be less than 10\")\n          end\n          \n          x_copy = copy(x)\n\
    \          x_copy[i] = x_copy[i] + 10\n          x_copy[i] = x_copy[i] * base\n\
    \          \n          x = x_copy\n          \n          i = 0\n          \n \
    \       end\n        \n        result << (x[i])\n        i += 1\n      end\n \
    \     \n    else\n      result << (x[i])\n      i += 1\n    end\n  end\n  \n \
    \ return result\nend", "    number = x.to_s\n    number.to_i\n    number.reverse!\n\
    \    number.reverse!\n    number.each_char.with_index.with_object([]) do |char,\
    \ i|\n        char.ord + i * base\n    end.join\nend", "  x.to_s % base == 0 ?\
    \ x.to_s : x.to_s(base)\nend", "  if x <= base\n    \"0\"\n  else\n    x.to_s(base)\n\
    \  end\nend\nend\n</code>\n<|/ q dscore=3 |>\n<| c |>\nWhat's a base? Could you\
    \ explain what you're trying to do here? If you're looking for an arbitrary base\
    \ converter with different bases, why are you using strings?\n<|/ c |>\n<| c |>\n\
    A base is something you use when representing a number as a string. I want to\
    \ convert from decimal to binary. I don't know another way to represent numbers\
    \ in binary...\n<|/ c |>\n<| c |>\nIf you can't use strings, you can represent\
    \ it as a binary number using [bit operators](http://en.wikipedia.org/wiki/Bitwise_operation),\
    \ but that's not really what you're asking about...\n<|/ c |>\n<| c |>\nThe binary\
    \ number would be represented by a string. But how would I represent it in decimal?\n\
    <|/ c |>\n<| c |>\nA decimal number isn't represented by a string; a decimal number\
    \ has a particular base. Binary isn't a string (it's number), but you can represent\
    \ it by using a base other than 10.\n<|/ c |>\n<| a dscore=2 |>\nAs I understand\
    \ it, you're trying to do the following:\n<code>", "  # Convert x to an array\
    \ of digits in base\n  # If x is a float, convert it to an array of digit string\
    \ \n  x = x.to_s.split(\"\")\n  x_digits = x.collect{|i| i.to_i}\n  x_length =\
    \ x_digits.size - 1\n  x_remainder = 0\n  x_integer = x_digits.collect{|i| x_remainder\
    \ * base + i}\n  x_integer\nend", "  return to_s * (x / base) + to_s[(-x + 1)\
    \ % base]\nend", "  s = \"\"\n  while x > 0\n    x, r = divmod(x, base)\n    s\
    \ = base_conversion(r).to_s + s\n  end\n  s\nend", "  return x.to_s(base)\nend",
  "  return x.to_s(base).reverse\nend\n</code>\n<|/ a tags=ruby,biginteger,number-formatting\
    \ |>\n<| a dscore=1 |>\n<code>", "  return x.to_s(base)\nend", "  x.to_s.split(//).map\
    \ { |x| x.to_i * base + x.to_i }.join\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    Thanks for sharing this, but as stated in my original post, I prefer not to use\
    \ string manipulation methods for simple mathematical operations. I am interested\
    \ in learning why that is.\n<|/ c |>\n<| a dscore=2 tags=ruby |>\nTo answer your\
    \ direct question:\n<code>\n'9'.to_i #=> 9\n'9'.to_i + '1' #=> 10\n</code>\nAs\
    \ you can see to_i converts a string to an integer.\n<code>\n'9'.to_s #=> \"9\"\
    \n'9'.to_s + '1' #=> \"10\"\n</code>\nAs you can see to_s converts a string to\
    \ an string, so you can actually concatenate two strings.\n<code>\n'9'.to_s.to_i\
    \ #=> 9\n'9'.to_s.to_s #=> \"9\"\n'9'.to_s.to_i + 1 #=> 10\n</code>\nAs you can\
    \ see to_i converts a string to an integer and to_s converts a string to an string.\
    \ to_i is the same as to_i.to_i, and to_s is the same as to_s.to_s.\nI hope this\
    \ answer makes sense.\n<|/ a |>\n<| c |>\nThanks for sharing. I understand string-to-string\
    \ conversion, but I wonder why the strings get converted to integers in your example\
    \ code. Is `'9'.to_s.to_i #=> 9` the correct way to convert?\n<|/ c |>\n<| a dscore=0\
    \ |>\nI wanted to add one more possible answer here, since my answer was already\
    \ a bit long.\nIf you wanted to implement a mathematical function like that, I\
    \ suggest using Kernel#Math.\nHere is an example (I didn't test it):\n<code>",
  "    digits = x.to_s.reverse.split(//).map(&:to_i).map { |d| d / base }\n    digits.reverse.map\
    \ { |d| d * base }.join.to_s\nend\n</code>\n<|/ a tags=algorithm,ruby,string |>\n\
    <| c |>\nIt would be interesting to see benchmarks of this method.\n<|/ c |>\n\
    <| c |>\n: What is your opinion on this? I've added a benchmark results for `change_base()`\n\
    <|/ c |>\n<| c |>\nThanks for the benchmarks, I see a significant difference.\
    \ I'll have to think a bit more about how your code is working.\n<|/ c |>\n<|\
    \ c |>\nI see a significant difference. I'll have to think a bit more about how\
    \ your code is working.\n<|/ c |>\n<| c |>\nThis implementation is very slow for\
    \ large numbers. How could we speed this up?\n<|/ c |>\n<| a |>\nHere is my version\
    \ with no temporary array:\n<code>", "  base = 10**base\n  digits = []\n  while\
    \ x > 0\n    digit = x % base\n    digits.push(digit)\n    x = x / base\n  end\n\
    \  digits.reverse\n  digits.join(\"0\")\nend\n</code>\n<|/ a tags=ruby,math,bigint\
    \ |>\n<| c |>\nIt's worth mentioning that the code in this answer relies on Ruby's\
    \ BigInt class being able to represent numbers with arbitrary precision.\n<|/\
    \ c |>\n<| c |>\nYou would need to change the `x = x / base` to `x = x.quo(base)`\
    \ to use the floating point division operator.\n<|/ c |>\n<| c |>\nIt works in\
    \ Ruby 2.2 but it doesn't work under Ruby 2.2.2. It outputs different answers\
    \ for `change_base(4651784345, 10).to_i` and `change_base(4651784345, 16).to_i`.\
    \ The output should be the same.\n<|/ c |>\n<| a dscore=3 |>\nI came up with this\
    \ solution:\n<code>", "  x.to_s(base).to_i\nend", "    x, base = [Integer(x)],\
    \ [base]\n    digits = x.digits(base)\n    digits[0..(digits.length - 1)] = [digits[digits.length\
    \ - 1]*base]\n    digits = digits.join(\"\")\n    x = x.to_integer(base, digits)\n\
    \    if digits == x\n        digits = digits\n    else\n        digits = digits\
    \ * base\n    x = x.to_integer(base, digits)\n    return \"%d\" % x\nend\n</cell>\n\
    <code language=julia-1.0>\nchange_base.call(8, 3)\n</cell>\n<code language=julia-1.0>\n\
    change_base.call(8, 2)\n</cell>\n<code language=julia-1.0>\nchange_base.call(7,\
    \ 2)\n</cell>\n<code language=julia-1.0>\nchange_base.call(7, 3)\n</cell>\n<text>\n\
    Change base of number using its digits and its digits", "  return x.to_s(base)\n\
    end", "    if base > 10\n       raise ArgumentError, 'base is greater than 10.'\n\
    \    digits = x.to_s(base).split(//)\n    tens, base = ['0'], base\n    if digits.length\
    \ == 1\n       digits[0..0] = ['0']\n       tens       = ['0']\n    end\n    digits.each\
    \ {|digit|\n       base = 10 * base + digit.to_i\n    }\n    tens.join(//)\nend",
  "  base = base_to_integer(base)\n  if x < base\n    digits = x.to_s.split(\"\")\n\
    \    digits[base] = digits[base].to_i(base)\n    x = Integer.new(digits.join(\"\
    \"))\n  else\n    x = x.to_i(base)\n  end\n  x = x.to_s\n  if x.length < (base\
    \ * 2)\n    x = ((base * 2) - x.length).to_s + x\n  end\n  return x\nend", " \
    \ base = 10\n  x = x.to_i\n  if x != 0\n    x = x.divmod(base)\n    x.map(&:to_i)\n\
    \  else\n    return \"0\"\n  end\n  x.reverse.join.to_s + base.to_s\nend\n</code>\n\
    <|/ a tags=string,ruby,binary,math |>\n<| a |>\nHere's a method that returns binary\
    \ equivalents of any integer in base X:\n<code>", "  if x.is_a?(Numeric) and base.is_a?(Integer)\n\
    \    x.to_s(base)\n  else\n    raise(TypeError, \"expected #{x.class}, #{base.class}\
    \ as arguments\")\n  end\nend", "    if base > 10\n        base -= 10\n      \
    \  return x.to_s(base)\n    end\n    return x.to_s(base)\nend", "  base_into_char\
    \ = string.split('', '0123456789ABCDEF')\n  base_into_int = []\n  for i in base_into_char\n\
    \    if i.to_i == base\n      base_into_int_char = string.split('', i)\n     \
    \ base_into_int_int = []\n      for i in base_into_int_char\n        base_into_int_int.push(i.to_i)\n\
    \      base_into_int_int.reverse!\n      base_into_int_int.each do |x|\n     \
    \   base_into_int.push(x.to_s)\n      end\n    end\n  end\n  base_into_int[x]\
    \ = x.to_s(base)\n  return base_into_int[x]\nend\n</code>\nThis code will convert\
    \ any number into the next higher number with base greater than or equal to the\
    \ input base. For example, if base is 10 and input is 27, it will output 51, where\
    \ 51 is the next highest number with base 10.\nHere is a ruby program I wrote\
    \ to test it:\n<code>", "    return x.to_s ** (1 / base) # use .to_s to convert\
    \ to string\nend", "    str = x.to_s\n    return x.to_s.reverse.split(\"\").reverse.inject(\"\
    \"){ |s| s.to_i(base).to_s(base) }\nend", "  if x <= base\n    x.to_s <= base.to_s\n\
    \  else\n    x.to_s.chars.map{|x| x.to_i(base).to_s}/.map{|x| x.to_i(base).to_s}.join\n\
    \  end\nend", "  x = x.to_s.split(//).map(&:to_i)\n  base = base.to_s.split(//).map(&:to_i)\n\
    \  return x.zip(base).map{|n,b| n.to_s(b)}.join(//)\nend", "  x.to_s.split(//).map.with_index{\
    \ |n| n.to_i ** base }.inject(:*)\nend\n</code>\n<|/ a |>\n<| c |>\nThis does\
    \ not work when base is greater than 36. Example: `change_base.call(8, 36)\n\"\
    8\"`\n<|/ c |>\n<| c |>\n, oops, fixed.\n<|/ c |>\n<| c |>\nYou do not need to\
    \ convert the numbers to string. Nor do you need to split them before mapping\
    \ them with to_i. Try `x.to_s.map.with_index{|n| n ** base}`\n<|/ c |>\n<| a tags=ruby,base,math\
    \ |>\nI see no reason to convert to string. Instead, do the arithmetic on integers:\n\
    <code>", "  if x < 10\n    \"#{x}\"\n  else\n    x.to_s(base)\n  end\nend", " \
    \ base = base.to_i\n  power = x.to_i\n  string = \"\"\n  while power != 0\n  \
    \  string = case power % base of \"0\",\"1\": string.concat(digit(power % base))\
    \ end\n    power = power / base\n  end\n  string.reverse\nend\n</code>\n<|/ a\
    \ tags=ruby |>\n<| c |>\nThe string manipulation is wrong, the function does not\
    \ return \"111\" for \"change_base.call(7, 2)\".\n<|/ c |>\n<| c |>\nI've now\
    \ added a version that gives the correct answer for \"change_base.call(7, 2)\"\
    .  Thanks James for catching that.  I tested my code against the Ruby version\
    \ as well and noticed a problem.  I now think my code gives correct results.\n\
    <|/ c |>\n<| a dscore=2 |>\nHere's another solution, using to_s.reverse:\n<code>",
  "  x.to_s(base).to_i\nend", "  if base == 10\n    return x\n  if x.to_i > base or\
    \ x.to_i < 1\n    raise ArgumentError(\"Base must be between 0 and 10.\")\n  result\
    \ = ''\n  while x.to_i > 0\n    result, x = divmod_int(x)\n    break if base ==\
    \ 10\n    result += (base ** x.to_i)\n  result.reverse!\n  return result\nend",
  "  # convert x to string if x is number\n  x = x.to_s if x.is_a? Numeric\n  # convert\
    \ base to string if base is number\n  base = base.to_s if base.is_a? Numeric\n\
    \  # convert x to base as string\n  strx = x.to_s\n  # convert to base as string\n\
    \  strbase = base.to_s\n  # loop through each digit\n  strx.each_char {|char|\
    \ strbase = strbase.gsub(base, char) }\n  # return converted string\n  strx\n\
    end\n</code>\n<|/ a dscore=0 tags=ruby,bignum,ruby-on-rails |>\n<| c |>\nThis\
    \ solution is very inefficient and very hard to read for someone who doesn't know\
    \ ruby very well. The whole function can be written as `x.to_s.reverse.gsub(base,\
    \ &:reverse).reverse`.\n<|/ c |>\n<| c |>\nYes, but what was wrong with the original\
    \ solution was the use of gsub, where it is just an overkill in the first place.\
    \ Now I think your solution will work, but I will try my best to understand what\
    \ happens. Do you know how gsub works exactly? I thought that it just finds the\
    \ first match and replaces it with the string you provide in second parameter\
    \ (:base). So it is an overkill for just finding the first instance of a specific\
    \ character in a string?\n<|/ c |>\n<| c |>\nSorry I didn't read your solution\
    \ thoroughly enough, gsub is definitely overkill in this particular case. Replacing\
    \ with each char is very inefficient, especially as base is big. The original\
    \ code would have just had `strx.each_char.reduce(base) { |a, c| a.gsub(base,\
    \ c) }`\n<|/ c |>\n<| c |>\nThank you for your answer, but please take a look\
    \ at my solution. I find it very clean and readable. :)\n<|/ c |>\n<| a dscore=0\
    \ |>\nAs I stated in my answer to this question, I recently came up with a solution\
    \ for converting a decimal to a base that preserves all the digits after a decimal\
    \ point for very large bases (in my case, base 4 up to base 1023). The solution\
    \ also preserves the leading zeroes for base 10. If base is zero, nothing is done.\n\
    Here is my solution:\n<code>", "  if x <> 0\n    digit = x % base\n    x = x /\
    \ base\n    return \"#{digit}#{x}\" if (digit != 0) * base\n  end\n  return \"\
    0\"\nend", "  return \"#{x.to_s(base)}0\"\nend", "  base = Integer(base)\n  x\
    \ = Integer(x)\n  return x.to_s(base) if x.is_a?(Integer)", "  if x >= base\n\
    \    return \"#{x} is not a valid integer representation\"\n  else\n    digits\
    \ = x.to_s.chars.reverse\n    digits = digits.map { |c| (c-'0').to_i(base) }.reverse\n\
    \    digits.reverse!.join.to_s\n  end\nend", "  str = x.to_s\n  x = str.split(//).map{|s|\
    \ s.to_i}\n  if x.size == 0\n    x << 0\n  elsif x.size <= base\n    x << base\n\
    \  else\n    raise ArgumentError.new(\"too many bases\")\n  end\n  x.reverse!\n\
    \  str = x.join.to_s\n  str *= base\n  x.reverse!\n  str = x.join.to_s\n  str\n\
    end", "  return x.to_s.reverse.gsub(/^0*/) do\n    str = self =~ /^(-?\\d+)/ ?\
    \ $1 : \"0\"\n    \"#{str}#{'0' * (base - str.length)}\"\n  end\nend\n</code>\n\
    The above assumes you want a string with leading zeros added. You may need to\
    \ add leading zeros to your input number or just use your base for the conversion.\
    \ \nYou can then write the following method for any number base. Call this by\
    \ passing the number to process and your base of conversion.\n<code>", "  return\
    \ x.to_s.reverse.to_i(base) unless x.nil? || x.zero?\n  x.to_s.reverse.to_i(base).to_s(base)\n\
    end", "  return x.to_s(base)\nend", "  res = []\n  base = (10**base).to_i\n  x.to_i.times\
    \ do\n    res << (x % base).to_s\n    x /= base\n  end\n  res.reverse\nend", " \
    \ return x.to_s(base) if x.to_s(base).length > 0\n  return \"0\"\nend", "  if\
    \ base < 10\n    puts \"Base must be less than 10\"\n    return\n  else\n    if\
    \ base == 10\n      puts \"Base cannot be 10\"\n      return\n    else\n     \
    \ result = x.to_s(base)\n    end\n  end\n  puts result\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThanks for the answer. But i am unable to execute this code in\
    \ my irb it throws me an error saying unexpected end. I did some modifications\
    \ and now it says method call missing 1 required argument:base. any idea how to\
    \ fix this? I am really new to ruby and ruby on rails.\n<|/ c |>\n<| c |>\nThat\
    \ is because you used puts instead of return on the last line.\n<|/ c |>\n<| c\
    \ |>\nI used return but now it says method call missing 1 required argument:base.\
    \ any idea how to fix this?\n<|/ c |>\n<| c |>\nYes - that is a method missing\
    \ error. That is the only error I see when running this code - what did you change?\n\
    <|/ c |>\n<| c |>\nI changed 'puts result' into 'return result' on line 15 and\
    \ 14. And now it says method call missing 1 required argument:base\n<|/ c |>\n\
    <| a |>\n<code>", "  if x < 10 then\n    if base < 2 then\n      \"0\"\n    else\n\
    \      \"0\"..base\n    end\n  else\n    x.to_s.reverse.chars.reverse.join(\"\"\
    ).reverse\n  end\nend\n</code>\n<|/ a tags=math,ruby dscore=0 |>\n<| c |>\nThat\
    \ is a lot of code. Could you explain to me how you came up with that? I ran it\
    \ through rubular and it seems to just do the trick\n<|/ c |>\n<| c |>\n`String#reverse`\
    \ returns a new string object; it doesn't reverse the string in-place.\n<|/ c\
    \ |>\n<| c |>\nThanks, that was a typo.\n<|/ c |>\n<| a dscore=0 tags=math,ruby\
    \ |>\nHere is a method I came up with for reversing a number:\n<code>", "  return\
    \ x.to_s(base)\nend", "  if x > base\n    x % base\n  else\n    x - (x // base)\
    \ * base\n  end\nend", "  return x.to_s(base)\nend", "  if base==0\n    puts \"\
    Invalid base. Cannot change to 0.\"\n  elsif base<2\n    puts \"Base must be a\
    \ positive integer (2 or larger)\"\n  elsif (x<0)\n    puts \"Cannot convert negative\
    \ numbers\"\n  elsif base>36\n    puts \"Invalid base. Base must be <= 36\"\n\
    \  else\n    digit_string = x.to_s(base)\n    puts \"The new number is: \"+digit_string\n\
    \  end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI tested it with this code:\
    \ puts change_base.call(92, 2) but it says invalid base. base must be between\
    \ 2 and 36.\n<|/ c |>\n<| c |>\nI tested it again, and it works fine. See the\
    \ output: `The new number is: 100`. Are you sure you put it in the right place?\n\
    <|/ c |>\n<| c |>\nOk, I see, thank you for the help. I put it in one file and\
    \ then run it with ruby filename. Is there another way I could put it in a separate\
    \ file? I've never made a separate file for a ruby program before.\n<|/ c |>\n\
    <| c |>\nOh, I see. That's a different question. I suggest you try doing `ruby\
    \ -e \"puts change_base.call(92, 2)\"` (which means \"run the following Ruby program\
    \ as if you typed it in at the console\")\n<|/ c |>\n<| c |>\nOh, I see. That's\
    \ a different question. I suggest you try doing `ruby -e \"puts change_base.call(92,\
    \ 2)\"` (which means \"run the following Ruby program as if you typed it in at\
    \ the console\")\n<|/ c |>\n<| a tags=ruby dscore=0 |>\nIf you just want to change\
    \ the base of numbers in your program, you can do this with a single call:\n<code>\n\
    puts change_base.call(92, 2)\n</code>\nThis doesn't actually change the base of\
    \ the number, so you can't print the number with the original base.  You can print\
    \ the number with the new base with something like this:\n<code>\nputs change_base.call(92,\
    \ 2).to_i(36)\n</code>\nThis takes the number and converts it to a base of 36.\
    \  Then it converts it back to a number.\n<|/ a |>\n<| a dscore=0 tags=ruby |>\n\
    I wrote a gem to solve this problem. https://github.com/jzfang/ruby-number-base\n\
    <code>\nrequire 'ruby-number-base'\nnumber = \"123456789\"\nnumber_in_base_2 = ",
  "  base = [nil, 1, 2, 3, 4, 5, 6, 7, 8, 9].to_set * base\n  if base[base.length\
    \ - 1] < 10\n    base.last = 0\n  end\n  digits = x.to_s\n  new_digits = \"\"\n\
    \  while digits.length > 0\n    digit, digits = digits[digits.length - 1], digits[0..-2]\n\
    \    new_digits = new_digits + digit.to_s + base[digit]\n  end\n  return new_digits\n\
    end", "  \n  # TODO: This code can be written in a more pythonic way.\n  # Hint:\
    \ use 'divmod' to convert the integer to a number with\n  # a base smaller than\
    \ the given base, then use % to extract its\n  # digits.\n  # \n  # Example (from\
    \ C):\n  # >>> change_base.call(1234, 2)\n  # \"1000\"\n  # >>> change_base.call(1235,\
    \ 2)\n  # \"1001\"\n  \n  # Base must be larger than 0.\n  if base < 0\n    raise\
    \ \"Wrong base number\"\n  \n  digits = x.to_s.split(\"\")\n  digits.reverse!\
    \ # reverse string from right to left.\n  \n  # TODO: Write a more pythonic way\
    \ of extracting the digits.\n  # This could be done by using slicing and a range.\n\
    \  \n  # Change base of last digit.\n  digits[-1] = digits[-1].chars.\n    \n\
    \  # Change base of first digit and the remaining digits.\n  digits[0..-2].each\
    \ do |digit|\n    if digit == digits[-2]\n      # Reset the last digit to 0.\n\
    \      digits[-1] = digit\n    else\n      digits[-2] = digit.\n    end\n  end\n\
    \  \n  return digits.join\nend\n</code>\nNow that we have all that, we can just\
    \ do some simple calculations. We don't have to worry about the base conversions,\
    \ since it only makes one change. \n<code>", "  # Base can only be between 1 and\
    \ 36\n  return sprintf(\"%0#{base}x\", x)\nend", "  return x.to_s(base).to_i(2)\n\
    end", "  if x < 10\n    digits = Array.new(x * base, \"0\")\n  else\n    digits\
    \ = Array.new((x - 10) * base, \"0\")\n    digits.reverse!\n  end \n  return digits.join\
    \ \nend \n</code>\n<|/ a dscore=3 tags=ruby |>\n<| c |>\nThis is very nice, but\
    \ how would I apply this to my question?\n<|/ c |>\n<| c |>\nI used `printf` to\
    \ format it, and added it to the answer. Also, you can add it yourself: `puts\
    \ change_base(number, base).gsub!(/(\\d)(?=(\\d{3})+(?!\\d))/, '\\1\\n') #=> \"\
    123456789\"`. But it would be better to do it with pure Ruby code.\n<|/ c |>\n\
    <| c |>\nI added a pure Ruby method :)\n<|/ c |>\n<| c |>\nThanks for adding the\
    \ other pure ruby solution :)\n<|/ c |>\n<| a |>\n<code>", "\tbase = \"0123456789ABCDEF\"\
    \n\tbase_index = -1\n\ty = x.to_i\n\tresult = ''\n\twhile y\n\t\tx = x / (base\
    \ ** base_index)\n\t\ty = x.to_i\n\t\tbase_index -= 1\n\t\tresult += base[(x %\
    \ base).to_s]\n\tend\n\treturn result\nend", "\tnum = Integer(x)\n\tif num < 10\n\
    \t\tnum.to_s(base)\n\telse\n\t\tnum.to_s(base).reverse\n\tend\nend", "    return\
    \ x.to_s.reverse.gsub(/(\\d)#{base}(?!\\d)/) { $1.to_i ** base }\nend", "  if\
    \ x != 0\n    x.to_s.length / base.to_s.length\n  else\n    \"0\"\n  end\nend",
  "  res = []\n  if x.is_a? Numeric\n    res = x.to_s(base)\n  else\n    res = x.to_s\n\
    \  end\n  if res.length < base\n    res *= base\n  elsif res.length > base\n \
    \   tmp = change_base(res.gsub(/([a-z]+)/, \"\"), base)\n    return tmp.to_s\n\
    \  else\n    return res\n  end\nend", "  if x % base == 0 then\n    return x.to_s\
    \ % base\n  else\n    temp = x.to_s(base)\n    ans = temp.scan(/^\\d+\\z/)\n \
    \   ans[0] = ans[0].to_i * base\n    return ans.join\n  end\nend", "  xx = x.to_s\n\
    \  if base <= 0\n    return (\"(\" + xx + \")\")\n  elsif base >= 10\n    return\
    \ (\"(\" + xx + \")\")\n  else\n    xx = base.to_s\n    xx = xx.gsub(/(\\d{1})(\\\
    d{3})/, '\\1\\2')\n    xx = xx.gsub(/(\\d{2})(\\d{3})/, '\\1\\2 ')\n    xx = xx.gsub(/(\\\
    d{2})(\\d{2})/, '\\1\\2')\n    xx = xx.gsub(/(\\d{2})(\\d{1})/, '\\1 ')\n    xx\
    \ = xx.gsub(/(\\d{1})(\\d{2})/, '\\1 ')\n    xx = xx.gsub(/(\\d{1})(\\d{1})/,\
    \ '\\1 ')\n    xx = xx.gsub(/(?<!\\d)(\\d{2})(?!\\d)/, '#')\n    xx = xx.gsub(/(?<!\\\
    d)(\\d{3})(?!\\d)/, '#')\n    xx = xx.gsub(/(?<!\\d)(\\d{4})(?!\\d)/, '#')\n \
    \   xx = xx.gsub(/(?<!\\d)(\\d{6})(?!\\d)/, '#')\n    xx = xx.gsub(/(?<!\\d)(\\\
    d{9})(?!\\d)/, '#')\n    xx = xx.gsub(/(?<!\\d)(\\d{6})(?!\\d)/, '0')\n    xx\
    \ = xx.gsub(/(?<!\\d)(\\d{9})(?!\\d)/, '0')\n    xx = xx.gsub(/(?<!\\d)(\\d{3})(?!\\\
    d)/, '00')\n    xx = xx.gsub(/(?<!\\d)(\\d{4})(?!\\d)/, '000')\n    xx = xx.gsub(/(?<!\\\
    d)(\\d{6})(?!\\d)/, '00000')\n    xx = xx.gsub(/(?<!\\d)(\\d{9})(?!\\d)/, '00000000')\n\
    \    xx = xx.gsub(/(?<!\\d)(\\d{4})(?!\\d)/, '000000000')\n    xx = xx.gsub(/(?<!\\\
    d)(\\d{6})(?!\\d)/, '0000000000')\n    xx = xx.gsub(/(?<!\\d)(\\d{9})(?!\\d)/,\
    \ '00000000000')\n    xx = xx.gsub(/(?<!\\d)(\\d{6})(?!\\d)/, '000000000000')\n\
    \    xx = xx.gsub(/(?<!\\d)(\\d{", "  r = \"\"\n  while x > 0\n    r = r + (x\
    \ / base).to_s.to_i + x\n    x = x % base\n  end\n  r\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThanks, this is working great!\n<|/ c |>\n<| a |>\n<code>", " \
    \ while x > base\n    x -= base\n  x * base\nend", "  if base < 10\n    return\
    \ \"#{x}\"\n  else\n    digits = x.to_s.reverse.to_i(base)\n    return digits.to_s.reverse.slice(1..-1)\n\
    \  end\nend", "  x_str = x.to_s.to_s\n  base = 10**base.to_i\n  x_str.to_i.to_s.length\
    \ <= base ? x_str.to_i.to_s * base : x_str\nend\n</cell>\n<cell>", "  if x ==\
    \ 0\n    number\n  else\n    number = x.to_s\n    number.gsub!(/\\d*$/, \"\")\n\
    \    number = \"0\" * base + number\n    number.reverse!\n    number\n  end\n\
    end\n</code>\n<|/ a tags=numbers,ruby dscore=2 |>\n<| a |>\nHere's one way, using\
    \ the standard String#rindex method:\n<code>", "  x\nend", "  # Split string on\
    \ digits and convert to an array.\n  digits = x.to_s.chars.to_a\n  # Change array\
    \ base to base.\n  digits.map! { |n| n % base }\n  # Concatenate the new string\
    \ back into a string.\n  digits.join\nend", "  if x >= base then return (x mod\
    \ base) else (x div base) + base\n  return x\nend\n</cell>\n<code language=julia-0.6>",
  "    if base < 1 or base > 10\n        return \"Invalid base\"\n    # check base\
    \ of base\n    if base == 10\n        return \"0\"", "  if base < 10 then \n \
    \   return nil\n  end\n  if base == 10 then\n    return x \n  end\n  \n  if x\
    \ == 0 then\n    return 0\n  end", "    digits = [\"\", \"One\", \"Two\", \"Three\"\
    , \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    if base<2\
    \ or base>10:\n        return \"Invalid base!\"\n    if x<0 or x>1:\n        return\
    \ \"Invalid input!\"\n    digits_string = x.to_s.reverse.gsub(/([a-z])/){|m| digits[m.ord\
    \ - 97] }.reverse\n    return \"#{digits_string.to_i(base)}\".to_s\nend\n</code>\n\
    <|/ a |>\n<| a |>\nHere is a ruby implementation\n<code>", "  base_convert = Array.new(2)\n\
    \  base_convert[0] = base\n  base_convert[1] = 10\n  base_convert.map!\n  x =\
    \ x.to_s.to_i\n  x = x.to_i * base_convert[1]\n  base_convert[0].times! { x /=\
    \ base_convert[1] }\n  base_convert[1].times! { x += x }\n  base_convert.each_index\
    \ do |i| \n    x = x.to_i * base_convert[i]\n  end\n  return x.to_s\nend", " \
    \ if x >= base\n    x.to_s.length\n    \n    return x.to_s.reverse.split(//).\n\
    \                 map.with_index {|a,b|\n                   case b\n         \
    \            when 0 then a.to_s << 0\n                     when 1 then a.to_s\
    \ << base\n                     else raise \"Invalid base\"\n                \
    \   end\n                 }.join\n  else\n    raise \"Base must be less than or\
    \ equal to 10\"\n  end\nend", "  return x.to_s(base) if x.is_a?(Numeric) else\
    \ '#{}'.format(\"#{x.to_s(base)}\".to_i(base).to_s(base))\nend\n</code>\n<|/ a\
    \ dscore=0 tags=ruby |>\n<| c |>\nThanks for the solution. But it is failing when\
    \ x is negative and base is even.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  base\
    \ = base.to_i\n  x.to_s.reverse.each_char{|c| c == '0' ? x = x.to_i + base : x\
    \ += base}\n  x\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThank you for sharing\
    \ your solution.\n<|/ c |>\n<| a tags=ruby |>\nHere's another approach using Ruby's\
    \ built-in methods for working with numbers.\n<code>", "  return x.to_s(base)\n\
    end", "  if x <  10 then\n    return x.to_s(base)\n  else\n    # Add x to (base-1)\
    \ to get base.\n    # Adding two numbers is the same as multiplying them by 10.\n\
    \    # >>> change_base.call(8, 2) == change_base.call(8 + 10, 2)\n    # True\n\
    \    # >>> change_base.call(10, 2) == change_base.call(10 + 10, 2)\n    # True\n\
    \    # >>> change_base.call(12, 2) == change_base.call(12 + 10, 2)\n    # True\n\
    \    # >>> change_base.call(8, 2) == change_base.call(8 + 10, 2)\n    # True\n\
    \    # >>> change_base.call(7, 2) == change_base.call(7 + 10, 2)\n    # True\n\
    \    return x.to_s(base) + change_base.call((x - x.to_s(base)), base - 1).to_s(base)\n\
    \  end\nend", "  return x.to_s b (base * x)\nend\n</cell>\n<code language=julia-1.3>\n\
    @assert change_base(2, 3) == \"1000\"\n@assert change_base(3, 3) == \"100\"\n\
    @assert change_base(2, 5) == \"20\"\n@assert change_base(2, 2) == \"2\"\n</cell>\n\
    <text>\nExercise 1: Sum a list\nWrite a function, sum_nums, that calculates the\
    \ sum of the elements of a given list nums. The function should return the sum\
    \ of the elements and a boolean flag indicating whether there are any non-zero\
    \ elements in the list.", "  digits = \"0123456789abcdefghijklmnopqrstuvwxyz\"\
    \n  x = x.to_s\n  base = base.to_i\n  result = ''\n  while x != 0\n    if x %\
    \ base == 0\n      result = digits[x%base] + result\n      x = x/base\n    else\n\
    \      result = digits[base] + result\n      x = x/base\n  end\n  if result.empty?\n\
    \    result = \"0\"\n  end\n  result\nend\n</code>\n<|/ a tags=ruby |>\n<| a |>\n\
    The Ruby way to do this would be to use the to_s method on your number, then use\
    \ the gsub method to strip out the non-digits:\n<code>", "  return x.to_s + \"\
    \ #\" + base.to_s + \" #\" + x.to_s % base\nend", "  return x.to_s(base) if x.is_a?\
    \ Integer\n  x.to_s(base).gsub(/./) do |n|\n    base, num = n.divmod(base)\n \
    \   next if num == 0\n    num.to_s(base)\n  end.join\nend\n</code>\n(To get rid\
    \ of leading zeros, strip the leading zero from the string, convert string to\
    \ number then back to string.)\nThis approach is better than using to_i() because\
    \ it's faster, and also works for negative numbers.  (The above code will give\
    \ unexpected results for 0.)\n<|/ a dscore=3 |>\n<| c |>\nThanks for providing\
    \ both ways of doing this.  I like how you handle negatives.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ dscore=2 |>\n<code>", "  # convert x to integer if necessary\n  if x.kind_of?(Integer)\n\
    \    x = x.to_s\n  end\n  # if base < 2 then return x, otherwise convert to integer\n\
    \  if base.kind_of?(Integer)\n    base = (base < 2) ? 2 : base\n  end\n  # check\
    \ base is valid\n  if base > 9\n    raise ArgumentError, \"base must be between\
    \ 2 and 9\"\n  end\n  # do base conversion\n  i = 0\n  while i <= (base.to_s.length\
    \ - 2)\n    digit = Integer(x.to_s[0..i] + x.to_s[(i+1)..-1]).to_s\n    x = (digit.to_i\
    \ * base).to_s + (digit.to_i % base)\n    i += 1\n  end\n  x\nend\n</pre>", " \
    \ res = []\n  while x >= base do\n    res.unshift(x % base)\n    x = x / base\n\
    \  end\n  res[-1] = x\n  res.each_index {|i| res[i] = \"0\" + res[i] if res[i]\
    \ < 10}\n  res.join '')\nend", "  base_to_power = base.to_s.to_i\n  result = x.to_s.reverse.gsub(/.(?=\\\
    D*$)/, '').gsub(/(?<=\\D*(?<=\\d)\\d)/, base).gsub(/^0+/, '').gsub(/0+$/, '')\n\
    \  result = result.reverse.gsub(/^0+/, '').gsub(/0+$/, '')\n  result = result.reverse.gsub(/.(?=\\\
    D*$)/, '').gsub(/(?<=\\D*(?<=\\d)\\d)/, base_to_power)\n  return result\nend",
  "  if base == 0\n    return x\n  r = \"\"\n  while x != 0\n    r = (x % base) +\
    \ r\n    x /= base\n  end\n  r\nend", "  # Only change if base is less than base\
    \ number of x\n  if base<x\n    return x.to_s.reverse\n  # Otherwise, loop through\
    \ powers of 2\n  else\n    while base<=x\n      # Add one to base\n      base=base+1\n\
    \      # Round result to base number\n      x=x.to_f.to_s(base).reverse\n    end\n\
    \    return x.to_s\n  end\nend", "  return x.to_s.to_i(base).to_s.to_i(base)\n\
    end\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\n`1.to_s(3) => \"100\"\
    ` which is not what we want. `1.to_s(3) => \"1000\"` which is better.\n<|/ c |>\n\
    <| c |>\nAhh yeah, I see how that doesn't make sense. I'll update.\n<|/ c |>\n\
    <| c |>\nThis is actually a really clever solution. Thanks for sharing.\n<|/ c\
    \ |>\n<| a |>\nI've decided to write this in pure Ruby using the String#succ method\
    \ as proposed by. This code works as is and is not dependent on any external libraries.\
    \ You can just copy this into your lib/change_base.rb file:\n<code>", "    # base\
    \ numbers are less than 10.\n    if x <10\n        return x.to_s(base)\n    res=\"\
    \"\n    num = x\n    i = 0\n    \n    while num>0 and num<base\n        \n   \
    \     res = num.to_s(base) + res\n        num = num.to_i()\n    \n    return res\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\nI think there is a problem in `change_base`\
    \ function\n<|/ c |>\n<| c |>\nHis question was about Ruby code, not Python :)\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "  case x\n  when 0\n    return \"0\"\n \
    \ when 1\n    return \"1\"\n  when 2\n    return \"10\"\n  when 3\n    return\
    \ \"11\"\n  when 4\n    return \"100\"\n  when 5\n    return \"101\"\n  when 6\n\
    \    return \"110\"\n  when 7\n    return \"111\"\n  when 8\n    return \"1000\"\
    \n  when 9\n    return \"1001\"\n  when 10\n    return \"1010\"\n  when 11\n \
    \   return \"1011\"\n  else\n    case\n    when x.to_s.length <= base\n      result\
    \ = x.to_s\n    else\n      result = change_base(x.to_i, base).to_s + (x.to_s.to_s.length\
    \ - base).times.to_a.join + change_base(x.to_i, base).to_s\n    end\n  end\n \
    \ return result\nend\n</code>\n<|/ a dscore=1 |>\n<| a |>\nThis works:\n<code>",
  "    return x.to_s(base)\nend\n</cell>\n<text>\n3.3. Converting from other base\
    \ to base 10", "  base_array = [(\"Z\", 36), (\"E\", 11), (\"P\", 7), (\"T\",\
    \ 10), (\"G\", 16),\n  (\"M\", 2), (\"K\", 10), (\"B\", 2), (\"P\", 9), (\"T\"\
    , 5), (\"G\", 2),\n  (\"M\", 8)]\n  result = x.to_s.to_i\n  result = base_array[result][1]\
    \ + base_array[base][1]*result\n  result = result.to_s\n  result = result.split(\"\
    \").reverse.join\n  if result.length <= 3\n    if result.length == 1\n      result\
    \ = \"0\" + result\n    else # result.length > 1\n      result = \"0\" + result\n\
    \  else # result.length >= 3\n    result = result[0...1] + \"0\" + result[2..3]\n\
    \  result\nend", "    base = base.to_i\n    return x.to_s(base)\nend", "  return\
    \ x.to_s.reverse.to_i(base).to_s\nend", "  if base==1\n    return x.to_s\n  x\
    \ = x.to_i\n  digits = x.digits.to_a\n  while base > 10 do\n    digits[base] =\
    \ digits[base-1].to_i\n    base -= 1\n  end\n  digits.last(base).to_s\nend", " \
    \ base = BigDecimal(base) if base.is_a?(String) else base\n  x = BigDecimal(x)\n\
    \  base_power = x.to_s.to_s.length\n  powers_count = BigDecimal(2).pow(base_power).to_s.length\n\
    \  digits_count = x.to_s.length.to_s.length\n  base = BigDecimal(base).to_i",
  "  return x * base if x.is_a? Fixnum && base.is_a? Fixnum else x.to_s\nend", " \
    \ base = base.to_i\n  result = ''\n  while x >= base\n    digit = x%base\n   \
    \ result += \"#{digit}\"\n    x = x/base\n  end\n  if x > 1\n    result += \"\
    #{x}\"\n  end\n  result\nend", "  puts (\"Number #{x} is #{x.to_s(base)}\")\n\
    end\nchange_base.call(-12, 3)\nchange_base.call(-33, 10)", "  new_base = 10\n\
    \  new_digits = \"\"\n  xs = \"0123456789ABCDEF\"\n  xl = x.length\n  base = xs[base]\n\
    \  while x > 0\n    if xl == 1\n      new_digits << x\n      break\n    digit\
    \ = (x % new_base)\n    new_digits << xs[digit]\n    x /= new_base\n    new_base\
    \ = new_base * 10\n  end\n  return new_digits.reverse\nend", "  # Your code here\n\
    \  result = \"\"\n  if base <= 0 or x % base != 0\n    result = x.to_s\n  else\n\
    \    quotient = x / base\n    remainder = x % base\n    result = \"\"\n    while\
    \ remainder\n      result = base + remainder.to_s + result\n      remainder =\
    \ quotient % base\n      quotient = quotient / base\n    end\n  end\n  result\n\
    end", "    base = base.to_s\n    if base == \"10\"\n        return x.to_s\n  \
    \  temp = x.to_s.split(\"\").map { |i| i.to_i }\n    temp.reverse\n    temp[base]\
    \ = Integer(temp[base])\n    return temp.join.to_s\nend", "  base.downto(1).map\
    \ { |b| x / b.to_f }\nend", "\tcase base\n\twhen 2\n\t\tx.to_s + \" hundred\"\n\
    \twhen 3\n\t\tx.to_s + \" thousand\"\n\twhen 4\n\t\tx.to_s + \" million\"\n\t\
    when 5\n\t\tx.to_s + \" billion\"\n\twhen 6\n\t\tx.to_s + \" trillion\"\n\twhen\
    \ 7\n\t\tx.to_s + \" quadrillion\"\n\telse\n\t\tx.to_s + \" unknown\"\n\tend\n\
    end", "  if base < 10 then \n    base = 10\n  else \n    base = base\n  end\n\
    \  digit_array = []\n  while x > 0 do\n    digit_array.push(x % base)\n    x =\
    \ x /= base\n  end\n  return digit_array.reverse.join.to_s \nend\n</cell>\n<code\
    \ language=julia-1.5>\nchange_base.call(6, 4)\n</cell>\n<code language=julia-1.5>",
  "  return x.to_s.split(\"\").map.with_index{|n, i| n * (base**i) }.join\nend\n</code>\n\
    <|/ a |>\n<| c |>\nI agree that you should always use regexes, but this does not\
    \ really answer the question that was asked. Besides, this is a perfect example\
    \ of why you should never use regexes if you can avoid it.\n<|/ c |>\n<| c |>\n\
    , I agree that using regexes for this is not the best way to solve the problem.\
    \ Yet, my answer is a good one because it is simple, short, and doesn't use regexes.\n\
    <|/ c |>\n<| c |>\nI agree that you should only use regexes when you *need* to\
    \ use them. Regular expressions are very useful in programming, and I agree that\
    \ using them in general is perfectly fine. Yet, your answer doesn't actually answer\
    \ the question. It merely shows you how you might write it using regexes, and\
    \ doesn't actually give a solution to the problem of converting a number from\
    \ base 10 to base 36. Also, why are regexes bad?\n<|/ c |>\n<| c |>\n, I've revised\
    \ my answer to provide an actual solution to converting the base 10 number to\
    \ base 36. Yet, I agree that using regexes for this is very bad.\n<|/ c |>\n<|\
    \ c |>\n: I agree that regexes are a poor way to solve this problem, but in this\
    \ case they are *definitely* the simplest, most readable and least ugly way to\
    \ solve the problem. The \"regex\" is not the only way of solving this problem,\
    \ but I think it is one that should be used only when it is appropriate and necessary.\n\
    <|/ c |>\n<| a tags=ruby dscore=3 |>\n<code>", "    digits = Array.new\n    digits.length\
    \ = (base ** x.length).to_i\n    (0...digits.length).each do |i|\n        digits[i]\
    \ = x.to_s.chars.to_a[i.to_s]\n    end\n    digits.join\nend", "  base = base.to_i\n\
    \  x    = x.to_i\n  if (base > 10)\n    raise \"base number is too large\"\n \
    \ return x.to_s.reverse.chars.reverse.\n          map { |i| i.to_i(base) } * base\n\
    end\n</code>\nThe code above is similar to my original answer, but it doesn't\
    \ use recursion and I used the more general conversion method instead of using\
    \ Integer#to_i. It also uses the most basic methods on String, and is probably\
    \ still slow.\n<code>", "  digits = x.to_s.chars\n  digits.reverse!\n  digits.map!\
    \ { |d| d.to_i(base) }\n  digits.join\nend\n</code>\n<|/ a dscore=4 |>\n<| a |>\n\
    <code>", "  return x.to_s.reverse.gsub(/\\d+/) { |m| m.to_i * base ** $&.size\
    \ }\nend", "  base = base.to_i\n  x.to_i.times { |i| (base - i).to_s << x }\n\
    \  \nend", "  str = \"\"\n  num = [\"\", \"000\", \"00\", \"011\", \"010\", \"\
    012\", \"013\", \"014\", \"015\", \"016\", \"017\", \"018\", \"019\", \"010\"\
    , \"011\", \"012\", \"013\", \"014\", \"015\", \"016\", \"017\", \"018\", \"019\"\
    , \"010\", \"011\", \"012\", \"013\", \"014\", \"015\", \"016\", \"017\", \"018\"\
    , \"019\", \"010\", \"011\", \"012\", \"013\", \"014\", \"015\", \"016\", \"017\"\
    , \"018\", \"019\", \"010\", \"011\", \"012\", \"013\", \"014\", \"015\", \"016\"\
    , \"017\", \"018\", \"019\", \"010\", \"011\", \"012\", \"013\", \"014\", \"015\"\
    , \"016\", \"017\", \"018\", \"019\"]\n  i = 0\n  while x > 0\n    digit = x %\
    \ base\n    str = num[digit] + str\n    x = x / base\n    i = i + 1\n  end\n \
    \ str\nend\n</code>\n<|/ a tags=function,ruby,math |>\n<| c |>\nThanks so much\
    \ for your help. I'm sorry I did not specify this in my original post, but I am\
    \ looking for a function that accepts 2 numbers and a number, and returns a new\
    \ number with the base changed to whatever number you entered. For example, change_base.call(8,2)\
    \ should return \"1000\"\n<|/ c |>\n<| c |>\nThis should be pretty trivial to\
    \ implement on your own.  Let me know if you need help with that.\n<|/ c |>\n\
    <| c |>\n, added my version\n<|/ c |>\n<| a tags=function,ruby,math |>\nHere's\
    \ a recursive solution:\n<code>", "  if x >  10 * base or x < 0:\n    return x\n\
    \  a = Array.new\n  i = 0\n  while x > base\n    a << base\n    i += 1\n    x\
    \ /= base\n  a << x\n  return a.join('')\nend", "  x = x.to_i\n  base = base.to_i\n\
    \  return \"#{base} * #{x} / #{base} = 10\" + x.to_s.reverse.to_s\nend", "  return\
    \ x.to_s << (base-1).to_s \nend", "  if x.is_a?(Fixnum)\n    return x.to_s.split(\"\
    \").reverse.collect{ |e| e * base }.join.to_s\n  else\n    x.to_s.split(\"\").collect\
    \ do |e|\n      e / base\n    end.reverse.inject(:+).to_s\n  end\nend", "  if\
    \ base == 0\n    return x\n  if x > base \n    temp = x\n    while temp >= base\n\
    \      temp, x = x / base, x\n    return x\n  temp = x\n  while temp < base\n\
    \    temp, x = x * base, x\n  return x\nend\n</code>\n<|/ a dscore=2 |>\n<| c\
    \ |>\nI thought of doing it this way, but I have some concerns. For example, how\
    \ does it handle the case where the base is larger than the number you want to\
    \ convert? For example, if you wanted to convert from base 3 to base 10...\n<|/\
    \ c |>\n<| c |>\n: You might want to check for that edge case first. I will edit\
    \ my answer.\n<|/ c |>\n<| c |>\nThank you for your help. Your code is very clean\
    \ and I appreciate you taking the time to explain everything.\n<|/ c |>\n<| a\
    \ dscore=2 |>\nHere is my answer:\n<code>", "  base = base.to_i\n  x = x.to_i\n\
    \  return x.to_s(base)\nend\n</cell>\n<code language=julia-0.5>\nchange_base(1)\n\
    </cell>\n<code language=julia-0.5>\nchange_base(2)\n</cell>\n<code language=julia-0.5>\n\
    change_base(3)\n</cell>\n<code language=julia-0.5>\nchange_base(-1)\n</cell>\n\
    <code language=julia-0.5>\nchange_base(-1)\n</cell>\n<code language=julia-0.5>\n\
    change_base(1)\n</cell>\n<code language=julia-0.5>\nchange_base(2)\n</cell>\n\
    <code language=julia-0.5>\nchange_base(3)\n</cell>\n<code language=julia-0.5>\n\
    change_base(-1)\n</cell>\n<code language=julia-0.5>\nchange_base(2)\n</cell>\n\
    <code language=julia-0.5>\nchange_base(3)\n</cell>\n<code language=julia-0.5>\n\
    change_base(-3)\n</cell>\n<code language=julia-0.5>\nchange_base(-1)\n</cell>\n\
    <code language=julia-0.5>\nchange_base(-2)\n</cell>\n<code language=julia-0.5>\n\
    change_base(-3)\n</cell>\n<code language=julia-0.5>\nchange_base(0)\n</cell>\n\
    <code language=julia-0.5>\nchange_base(-0)\n</cell>\n<code language=julia-0.5>\n\
    change_base(7)\n</cell>\n<code language=julia-0.5>\nchange_base(-7)\n</cell>\n\
    <code language=julia-0.5>\nchange_base(11)\n</cell>\n<code language=julia-0.5>\n\
    change_base(-11)\n</cell>\n<code language=julia-0.5>\nchange_base(10)\n</cell>\n\
    <code language=julia-0.5>\nchange_base(-10)\n</cell>\n<code language=julia-0.5>\n\
    change_base(15)\n</cell>\n<code language=julia-0.5>\nchange_base(-15)\n</cell>\n\
    <code language=julia-0.5>\nchange_base(17)\n</cell>\n<code language=julia-0.5>\n\
    change_base(-17)\n</cell>\n<code language=julia-0.5>\nchange_base(10)\n</cell>\n\
    <code language=julia-0.5>\nchange_base(-10)\n</cell>\n<code language=julia-0.5>\n\
    change_base(15)\n</cell>\n<code language=julia-0.5>\nchange_base(-15)\n</cell>\n\
    <code language=julia-0.5>\nchange_base(17)\n</cell>\n<code language=julia-0.5>\n\
    change_base(-17)\n</cell>\n<code language=julia-0.5>\nchange_base(-2)\n</cell>",
  "  while x > base\n    x = x / base\n  end\n  x\nend", "  str = x.to_s\n  num =\
    \ (\"\"+x).to_i\n  str.gsub!(/[0-9]/, \"\")\n  str.gsub!(/[0-9]/) { |n| num.to_s(base).rjust(base,\
    \ \"0\") }\n  str\nend", "  if x == 0\n    puts \"0\"\n  elsif base < 10\n   \
    \ puts \"#{base * x}\"\n  else\n    puts \"#{base ** x}\"\n  end\nend", "  s =\
    \ \"\"\n  while x > 0\n    digit = x % base\n    x = x / base\n    s = digit.to_s\
    \ + s\n  end\n  s\nend", "  base_digits = base.to_s\n  x = x.to_s\n  result =\
    \ \"\"\n  i = 0\n  while i < x.length\n    digit = x[i]\n    position = base_digits.index(digit)\n\
    \    digit_value = Integer(digit).to_s\n    digit_value *= base\n    if digit_value\
    \ >= 10_000\n      digit_value = digit_value.to_s\n      digit_value += 1\n  \
    \  digits[position] = digit_value\n    i += 1\n  end\n  i = 0\n  while i < x.length\n\
    \    digit = x[i]\n    result += digits[base_to_position[digit]]\n    i += 1\n\
    \  end\n  result\nend", "  x = x.to_i\n  base = base.to_i\n  a = x.abs % base\n\
    \  x = x.to_i\n  digits = []\n  while x > base\n    digits.push(x % base)\n  \
    \  x = x / base\n  end\n  if x != 0\n    digits.push(x)\n  end\n  return digits.reverse.join.to_s\n\
    end\n</code>\n<|/ a dscore=2 tags=ruby,numbers,base,math |>\n<| c |>\nIf i run\
    \ your code it gives the wrong result. Change_base.call(12, 2) => change_base.call(12,\
    \ 10) => change_base.call(12, 16) => \"17\" which is not correct. Should it be\
    \ \"120\"?\n<|/ c |>\n<| c |>\nSorry, I did a little testing too quick. Now it\
    \ should work. Hope you find it useful!\n<|/ c |>\n<| c |>\nI think I finally\
    \ understood what the question was asking. Check out my updated answer.\n<|/ c\
    \ |>\n<| c |>\nThanks man. Your solution is awesome too :D\n<|/ c |>\n<| c |>\n\
    Yes i know that i don't need to write my own base10 converter. I just needed to\
    \ get it to work first before i would write my own base2 converter. So thank you\
    \ for the code i was trying to make work in Ruby :D And yes your solution works\
    \ perfectly.\n<|/ c |>\n<| a tags=ruby,numbers,base,math |>\n<code>", "  if base\
    \ < 10\n    return x.to_s\n  \n  result = ''\n  \n  # Change each digit from base\
    \ to base using recursion.\n  for i in 0...x.to_s.length\n    new_digit = (x.to_s[(x.to_s.length\
    \ - i) - 1].to_i + \n                 x.to_s[(x.to_s.length - i) - 2].to_i * \n\
    \                 base.to_i) / base.to_i\n    result = x.to_s[(x.to_s.length -\
    \ i) - 1].chr + \n             change_base(new_digit, base).chr + \n         \
    \    result\n  end\n  \n  return result\nend", "  return x.to_s.reverse.gsub(/^1/,\
    \ \"0\" * base).reverse\nend\n</code>\n<|/ a dscore=5 tags=ruby,string,regex |>\n\
    <| c |>\nNice. Just a small improvement for the last line `to_s.reverse.gsub(/^1/,\
    \ \"0\" * base).reverse`\n<|/ c |>\n<| c |>\nI didn't downvote, but I think this\
    \ answer is more of a \"clever\" version than a good one.\n<|/ c |>\n<| c |>\n\
    It is, I believe, more clever because it doesn't use regular expressions at all.\
    \ Regular expressions are overkill for this task. This solution also requires\
    \ Ruby 1.9+ (because of `String#reverse`).\n<|/ c |>\n<| c |>\nWhy does this work?\
    \ What does `gsub(/^1/, \"0\" * base).reverse` actually do?\n<|/ c |>\n<| c |>\n\
    : `\"1\"` becomes `\"01\"`, then `gsub` reverses it so the `\"1\"` becomes `\"\
    10\"`, then `reverse` reverses the `\"10\"` back to `\"1\"`.\n<|/ c |>\n<| a dscore=4\
    \ tags=ruby,string,regex |>\nI know this is a late answer, but I just had to do\
    \ this myself and found the answers on this question really hard to come by. \n\
    My solution was\n<code>", "  x = x.to_s.to_i\n  base = base.to_s.to_i\n  return\
    \ x.to_s(base)\nend", "    digit = x.to_s.chars.to_i\n    if (digit < base)\n\
    \        digit = digit + base\n        x.to_s = (digit.to_s).chars.to_s\n    else\n\
    \        x.to_s = (digit.to_s).chars.to_s + (base.to_s).chars.to_s\n    end\n\
    end\n</code>\n<|/ a tags=ruby,integer,base,ruby-on-rails |>\n<| a dscore=1 |>\n\
    <code>", "  if base == 0 then return x end\n  \n  y = tostring(x / base)\n  \n\
    \  while y >= base\n    x, y = div(y, base)\n    y = tostring(x + base)\n  end\n\
    \  \n  return x + y\nend", "  x = x.to_i\n  base = base.to_i\n  return x.to_s(base)\
    \ if base < 10 && x != 0 else x.to_s(base)\nend", "  x = x.to_s # convert number\
    \ to string\n  x = x.to_i # convert number to integer\n  return x.to_s(base)\n\
    end\n</code>\n<|/ a |>\n<| a dscore=4 tags=string,ruby,integer |>\n<code>", " \
    \ x.divmod(base) # returns pair with quotient and remainder\n  x.to_s + str((x.to_i\
    \ / base).to_s)\nend", "  return x if base < 2 ? \"0\" : ((x % base) + base).to_s\n\
    end\n</code>\n<|/ a tags=ruby,base,numbers dscore=3 |>\n<| a dscore=2 tags=ruby,base,numbers\
    \ |>\nThe fastest method I could find is to use the built in binary number base\
    \ conversion by using the bit operators. So if you have a number you want to convert\
    \ to base 10 (base 2) you just need to check each bit of the number one at a time\
    \ (the operator is &):\n<code>", "  base_to_power = {\n    1 => \"10\",\n    2\
    \ => \"100\",\n    3 => \"1000\",\n    4 => \"10000\",\n    5 => \"100000\",\n\
    \    6 => \"1000000\",\n    7 => \"10000000\",\n    8 => \"100000000\",\n    9\
    \ => \"1000000000\",\n    10 => \"10000000000\",\n    11 => \"100000000000\",\n\
    \    12 => \"1000000000000\",\n    13 => \"10000000000000\",\n    14 => \"100000000000000\"\
    ,\n    15 => \"1000000000000000\",\n    16 => \"10000000000000000\",\n    17 =>\
    \ \"100000000000000000\",\n    18 => \"1000000000000000000\",\n  }\n  return base_to_power[base]\
    \ + ((x.to_s).reverse.to_s).reverse.gsub(/(\\d)(?=(#{base})(?!\\d))/, \"\\\\1\"\
    .to_sym)\nend", "  base = 10\n  result = ''\n  if x.to_s.to_i < 10\n    result\
    \ = x.to_s.to_i\n  else\n    if x < base\n      x = x.to_s.to_i\n      x = x.to_s.to_i\
    \ * base\n      result = x.to_s\n    else \n      while x > 0\n        digit =\
    \ x % base\n        x += base\n        result << (digit + base)\n      end\n \
    \   end\n  end\n  result\nend", "  return x.to_s(base) if x.is_a? Fixnum and base.is_a?\
    \ Fixnum else x.to_s(base)\nend", "\tresult = \"\"\n\tdigits = \"0123456789ABCDEF\"\
    \n\twhile x > 0\n\t\tdigit, x = divmod(x, base)\n\t\tresult = digits[digit] +\
    \ result\n\tend\n\treturn result\nend", "  if x > 0\n    (10 ** base).to_i * x.to_i\
    \ * x\n  elsif x < 0\n    (10 ** (-base)).to_i * x.to_i * x\n  else\n    x.to_s\n\
    \  end\nend", "  return x.to_s(base)\nend\n</code>\nNow we have the basics down:\n\
    <code>", "  if base == 10\n    x.to_s\n  else\n    # base 10\n    digits = x.to_s.split(//)\n\
    \    digits.reverse.each_with_index { |digit, i|\n      digits[i] = digit.to_i(base)\
    \ }\n    x = digits.join\n  end\nend", "    if x < base\n        x.to_s\n    else\n\
    \        x.to_s + (x.to_s.to_i(base).to_s)\n    end\nend", "  if x < 10\n    return\
    \ x.to_s + \"0\" * base\n  else\n    digits = x.to_s.chars.to_a\n    remainder\
    \ = 10\n    result = \"\"\n    digits.each do |digit|\n      remainder = remainder.times(base)\n\
    \      if remainder < 10\n        result << (digit + remainder)\n      else\n\
    \        result << (digit + (10 - remainder))\n      end\n    end\n    result\n\
    \  end\nend", '  x.to_s.reverse.chars.reverse.chars.reverse.chars.reverse.upcase
    + x.to_s.reverse.chars.reverse.chars.reverse.chars.reverse.upcase + x.to_s.reverse.chars.reverse.chars.reverse.chars.reverse.upcase
    + x.to_s.reverse.chars.reverse.chars.reverse.chars.reverse.upcase + x.to_s.reverse.chars.reverse.chars.reverse.chars.reverse.upcase
    + x.to_s.reverse.chars.reverse.chars.reverse.chars.reverse.upcase + x.to_s.reverse.chars.reverse.chars.reverse.chars.reverse.upcase
    + x.to_s.reverse.chars.reverse.chars.reverse.chars.reverse.upcase + x.to_s.reverse.chars.reverse.chars.reverse.chars.reverse.upcase
    + x.to_s.reverse.chars.reverse.chars.reverse.chars.reverse.upcase + x.to_s.reverse.chars.reverse.chars.reverse.chars.reverse.upcase
    + x.to_s.reverse.chars.reverse.chars.reverse.chars.reverse.upcase + x.to_s.reverse.chars.reverse.chars.reverse.chars.reverse.upcase
    + x.to_s.reverse.chars.reverse.chars.reverse.chars.reverse.upcase + x.to_s.reverse.chars.reverse.chars.reverse.chars.reverse.upcase
    + x.to_s.reverse.chars.reverse.chars.reverse.chars.reverse.upcase + x.to_s.reverse.chars.reverse.chars.reverse.chars.reverse.upcase
    + x.to_s.reverse.chars.reverse.chars.reverse.chars.reverse.upcase + x.to_s.reverse.chars.reverse.chars.reverse.chars.reverse.upcase
    + x.to_s.reverse.chars.reverse.chars.reverse.chars.reverse.upcase + x.to_s.reverse.chars.reverse.chars.reverse.chars.reverse.upcase
    + x.to_s.reverse.chars.reverse.chars.reverse.chars.reverse.upcase + x.to_s.reverse.chars.reverse.chars.reverse.chars.reverse.upcase
    + x.to_s.reverse.chars.reverse.chars.reverse.chars.reverse.upcase + x.to_s.reverse.chars.reverse.chars.reverse.chars.reverse.upcase
    + x.to_s.reverse.chars.reverse.chars.', "  return x.to_s % base\nend\n</cell>\n\
    <text>\nThe next cell will test your change_base function on a few examples:",
  "  if x<10\n    x.to_s(base)\n  else\n    x.to_s(base).rjust(10, \"0\")\n  end\n\
    end", "  base_to_decimal = digits_to_base(x, base).to_s\n  base_to_decimal.slice!(0,\
    \ 1) if base_to_decimal.size == 1\n  x = x.to_i\n  return x.to_s.gsub(\"0\", base_to_decimal)\n\
    end\n</code>\n<|/ a tags=ruby,algorithm,string |>\n<| a tags=ruby,algorithm,string\
    \ |>\n<code>", "  if x.is_a? Bignum\n    base = Bignum(base)\n  else\n    base\
    \ = Bignum(base)\n  end\n  r = x.to_s.reverse\n  result = ''\n  while r != ''\n\
    \    i, v = r.divmod(base)\n    result += i.to_s\n    r = v.reverse\n  end\n \
    \ return result\nend", "  str = x.to_s\n  new_str = \"\"\n  i = 0\n  while i <\
    \ str.length\n    num = str[i]\n    if str[i] == \"0\" || str[i] == \"1\"\n  \
    \    digit = str[i - 1]\n      num = num.to_i * Math.pow(base, digit.to_i).to_f\n\
    \    end\n    new_str += num.to_s\n    i += 1\n  end\n  return new_str\nend",
  "  # Convert base to string\n  baseStr = baseToString(base)\n  # Convert number\
    \ to a string\n  xStr = str(x)\n  # Return the string\n  return baseStr + xStr[1..-2]\n\
    end", "  digits = to_base(x, base)\n  digits.reverse!\n  return digits.reverse.join.to_s\n\
    end", "  return x.to_s % base\nend\n</cell>\n<cell>", "  r = \"\"\n  while x >\
    \ 0\n    if x % base = 0\n      x = x / base\n      r += base.to_s\n    else \n\
    \      x /= base\n      r += x.to_s\n    end\n  end\n  r\nend", "  if x < base\n\
    \    return 0\n  else\n    digits = Array.new(x * base)\n    digits.each { |x|\
    \ x.to_s(base) }\n    digits.reverse.each { |x| x.to_i(base) }\n    digits.join(\"\
    \")\n  end\nend", "  str = \"\"\n  for i in x.to_s.split(\"\")\n    str = str.chr\
    \ + (i.to_i(base) rescue i.to_s)\n  str\nend", "  x.to_s.reverse! if x.odd?\n\
    \  x.to_s.split(\"\").reverse!\n  x.to_s.reverse! if x.odd?\n  x.to_s.split(\"\
    \").reverse!\n  x.to_s.reverse! if x.odd?\n  x.to_s.split(\"\").reverse!\n  x.to_s.reverse!\
    \ if x.odd?\n  x.to_s.split(\"\").reverse!\n  x.to_s.reverse! if x.odd?\n  x.to_s.split(\"\
    \").reverse!\n  x.to_s.reverse! if x.odd?\n  x.to_s.split(\"\").reverse!\n  x.to_s.reverse!\
    \ if x.odd?\n  x.to_s.split(\"\").reverse!\n  x.to_s.reverse! if x.odd?\n  x.to_s.split(\"\
    \").reverse!\n  x.to_s.reverse! if x.odd?\n  x.to_s.split(\"\").reverse!\n  x.to_s.reverse!\
    \ if x.odd?\n  x.to_s.split(\"\").reverse!\n  x.to_s.reverse! if x.odd?\n  x.to_s.split(\"\
    \").reverse!\n  x.to_s.reverse! if x.odd?\n  x.to_s.split(\"\").reverse!\n  x.to_s.reverse!\
    \ if x.odd?\n  x.to_s.split(\"\").reverse!\n  x.to_s.reverse! if x.odd?\n  x.to_s.split(\"\
    \").reverse!\n  x.to_s.reverse! if x.odd?\n  x.to_s.split(\"\").reverse!\n  x.to_s.reverse!\
    \ if x.odd?\n  x.to_s.split(\"\").reverse!\n  x.to_s.reverse! if x.odd?\n  x.to_s.split(\"\
    \").reverse!\n  x.to_s.reverse! if x.odd?\n  x.to_s.split(\"\").reverse!\n  x.to_s.reverse!\
    \ if x.odd?\n  x.to_s.split(\"\").reverse!\n  x.to_s.reverse! if x.odd?\n  x.to_s.split(\"\
    \").reverse!\n  x.to_s.reverse! if x.odd?\n  x.to_s.split(\"\").reverse!\n  x.to_s.reverse!\
    \ if x.odd?\n  x.to_s.split(\"\").reverse!\n  x.to_s.reverse! if x.odd?\n  x.to_s.split(\"\
    \").reverse!\n  x.to_s.reverse! if x.odd?\n  x.to_s.split(\"\").reverse!\n  x.to_s.reverse!\
    \ if x.", "  while x > base\n    x = x/base\n  end\n  result = (x * base).to_s\n\
    \  \n  if result < 10\n    result = \"0\" + result\n  end\n  \n  return result\n\
    end", "  x = x.to_s\n  if base < 10\n    return x if x =~ /^[0-9]+$/ || x =~ /^[0123456789]$/\n\
    \    return x.to_s.chars.reverse.inject(\"\") do |s, b|\n      s << (10**(base-b)).to_s\
    \ << b\n    end.reverse\n  else\n    10.to_s.chars.reverse.inject(\"\") do |s,\
    \ b|\n      s << base**(b-10)*x if b > 10\n      s << b\n    end\n  end\nend",
  "  if base == 0\n    return x\n  digits = []\n  while x >= base\n    digits, x =\
    \ divmod x, base\n  end\n  digits.reverse\n  digits.push(digits.pop)\n  digits.reverse\n\
    \  return digits.join\nend", "\tif base > 9\n\t\traise ArgumentError, \"The argument\
    \ 'base' is out of range.\"\n\telsif base < 0\n\t\traise ArgumentError, \"The\
    \ argument 'base' is out of range.\"\n\tend\n\t\n\t# Convert to string.\n\tstrX\
    \ = to_string(x)\n\t# Convert to string with base.\n\tstrX = num2base(strX, base)\n\
    \t# Return string after conversion.\n\treturn strX\nend", "\tdigits = x.to_s\n\
    \tdigits.reverse!\n\tdigits.reverse!\n\twhile digits.length > 0\n\t\tx = x / base\n\
    \t\tdigits.delete!\n\tend\n\treturn x + digits.reverse\nend", "    base = base.to_i\n\
    \    x = x.to_i\n    if base<10\n        puts \"Base #{base} is not supported\
    \ for negative numbers.\"\n        return nil\n    elsif base == 0\n        puts\
    \ \"Base #{base} is not supported for 0.\"\n        return nil\n    end\n    if\
    \ x<0\n        if x>0\n            puts \"The given number #{x} is negative.\"\
    \ \n        else\n            puts \"The given number #{x} is positive.\"\n  \
    \      end\n        return nil\n    end\n    x = (x/base).floor\n    if x<base\n\
    \        puts \"The given number #{x} is smaller than the desired base.\"\n  \
    \      return nil\n    end\n    return x.to_s\nend", "  if x == 0\n    '0'\n \
    \ else\n    temp = x.to_s\n    length = temp.length\n    digits = []\n    count\
    \ = 1\n    if base < 2\n      for i = temp.downto(0)\n        digits.push(i)\n\
    \        while digits.length >= base\n          digits.pop(0)\n        end\n \
    \     end\n    else\n      for i = temp.downto(0)\n        digits.push(base.to_s.chars.zip(i).reduce(:+).to_s)\n\
    \        while digits.length >= base\n          digits.pop(0)\n        end\n \
    \     end\n    end\n    digits.reverse.insert(0, count.to_s)\n  end\nend", " \
    \ if x < 10 \n    digits = x.to_s(base)\n  else\n    digits = x.to_s(base)\n \
    \   digits = digits[0..digits.length-1]\n  end\n  return digits\nend", "    digits\
    \ = x.to_s.reverse.gsub(/(?<=\\d)(?=[a-z])/, '').to_i \n    base = base.to_i\n\
    \    \n    return x.to_s.reverse.gsub(/(?<=\\d)(?=[a-z])/) do\n      digit = digits*base\
    \ + $1.to_i\n      digit = (10 - digit).divmod(base).to_a\n      digit = digit.join(\"\
    \").reverse\n      digit.chop!\n      digit\n    end\nend", "  # Initialize result\
    \ string.\n  result = ''\n  # Process numbers less than base.\n  if x < base\n\
    \    # Convert from base to decimal, store in result.\n    result = dec2dec(x,\
    \ base)\n  # Process numbers greater than base.\n  else\n    # Divide by base\
    \ into result and remainder.\n    result = dec2dec(dec2dec(x, base), base)\n \
    \   result *= base\n  # Return result.\n  return result\n  # end\nend", "  return\
    \ x.to_s(base)\nend", "  if x < 10\n    x.to_s(base)\n  else\n    x.div(base).to_s(base)\n\
    \  end\nend", "  if base < 10\n    raise(ArgumentError, \"Base must be less than\
    \ 10.\")\n  x_str = x.to_s\n  x.to_s = ''\n  result = ''\n  for i in (x_str.length.to_i)..-1\n\
    \    if i.to_i < base\n      result = result + \"0\"\n    else\n      result =\
    \ result + (x_str[i].to_s.to_i)\n    end\n  end\n  x = x.to_i\n  x.to_s = x_str\n\
    \  result\nend", "  return x.to_s(base).reverse.to_i(base)\nend", "  x = [x] if\
    \ x.is_a?(Array) else x.to_a\n  base = base.to_i if base.is_a?(Fixnum)\n  res\
    \ = []\n  x.each do |x|\n    res << x.to_s(base)\n  end\n  res.join\nend", " \
    \ x.to_s % base\nend", "  str = x.to_s\n  base = base.to_i\n  str.split(\"\").each_with_index\
    \ do |n, i|\n    str = str.chars.map{|x| x.to_i}.inject(n){|n,i| (n*base+i)%base}.to_s\n\
    \  end\n  str\nend", "  if x.to_s.length == base\n    # no need to change base\n\
    \  else\n    str = x.to_s\n    digits = str.to_char.split(//).reverse\n    digits.reverse!\n\
    \    basedigits = base.to_char.split(//).reverse\n    basedigits.reverse!\n  \
    \  basedigits = basedigits - digits.length\n    basedigits = (basedigits + digits.length).modulo(basedigits.length)\n\
    \    digits[0..basedigits.length].zip(basedigits).each do |left, right|\n    \
    \  digits[left.to_i] = (left + right).modulo(basedigits.length)\n    end\n   \
    \ digits.join\n  end\nend", "  base = 10**base\n  x.to_s.split(\"\").reverse.inject(base)\
    \ { |m, s| m * s.to_f + m }\nend\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| a tags=ruby\
    \ |>\nI like Chris's answer, but just to add a bit to the spirit of it, I thought\
    \ I'd give a couple of other options.\nOne, probably the most simple and possibly\
    \ fastest, but probably not necessarily easy to read, would be to just add spaces\
    \ before and after each character using String#gsub.\n<code>\n\"12\".gsub(/[0-9]/)\
    \ { |x| x.to_s + \" \" }", "  if x == 0\n    return \"\"\n  bases = [\"\", \"\
    K\", \"M\", \"B\", \"T\"]\n  base_index = 0\n  while x < base\n    x /= base\n\
    \    base_index += 1\n  end\n  return \"#{x}#{bases[base_index]}\"\nend", "  result\
    \ = 0\n  for i in x\n    result *= base\n    result += i\n  result\nend\n</code>\n\
    <|/ a |>\n<| a dscore=0 |>\nI wanted to add one more way that might come in handy\
    \ if you are in need of doing division.\nFor example you want to divide numbers\
    \ between 1 and 1000 by 1000. \nHere are some simple ways you can do this.\n<code>\n\
    for i in 1..1000\n   puts i / 1000\nend\n</code>\nOr if you have a variable already\
    \ that stores the number, you simply use the variable.\n<code>\nnumber = 1\nfor\
    \ i in 1..1000\n    puts number / 1000\nend\n</code>\nIf you wanted to change\
    \ the base to other bases, you could do that as well.\n<code>\nnumber = 10\nfor\
    \ i in 1..1000\n    puts number.to_s(2) \nend\n</code>\n<|/ a tags=ruby,math,integer\
    \ |>\n<| a tags=ruby,math,integer dscore=0 |>\nI believe my answer is somewhat\
    \ more concise and probably faster than other proposed solutions.\n<code>", " \
    \   puts \"#{base_convert(x, base)}\"\nend\n</code>\nAnd here is the result I\
    \ got:\n<code>\n$ irb\nirb(main):001:0> puts \"#{base_convert(8, 3)}\"\n22\n=>\
    \ nil\nirb(main):002:0> puts \"#{base_convert(8, 2)}\"\n1000\n=> nil\nirb(main):003:0>\
    \ puts \"#{base_convert(7, 2)}\"\n111\n=> nil\n</code>\n<|/ a dscore=2 |>\n<|\
    \ a dscore=1 |>\n<code>", "  result = \"\"\n  n = x.to_i\n  while n > 0\n    digit\
    \ = n % base\n    result = digit.to_s + result\n    n = n / base\n  result =~\
    \ /^0(.*)/\n  result = $1.to_s\n  result\nend\n</cell>\n<code language=julia-0.6>\n\
    x = 8\ny = 4\n</cell>\n<code language=julia-0.6>\nchange_base(x, y)\n</cell>\n\
    <text>\nIn addition to converting from one base, in Julia it is also possible\
    \ to convert from two bases at once:", "  if base == 10 then\n    return toStr(x)\n\
    \  else\n    base = tonumber(base)\n    \n    if x ~= 0 then\n      x = tonumber(x)\n\
    \      local digits = math.floor(math.log(x) / math.log(base))\n      local digit\
    \ = digits\n      \n      local base = tonumber(string.format(\"%1.\" .. digits\
    \ .. \"d\", math.pow(base, digits)))\n      \n      if x >= 1 then\n        digit\
    \ = digits - 1\n      else\n        digit = digits\n      end\n      \n      return\
    \ toStr(math.round(x / math.pow(base, digit)))\n    else\n      return toStr(1)\n\
    \    end\n  end\nend", "  to_s = x.to_s\n  bases = [1, 10, 100]\n  bases.each\
    \ do |base|\n    if (to_s.to_i / base) == x.to_i\n      return x.to_s % (base\
    \ * base).to_s\n    end\n  end\n  nil\nend", "  result = \"\"\n  remainder = x\
    \ % base\n  while remainder != 0\n    digit = remainder % 10\n    result = to_s(digit,\
    \ base) + result\n    remainder = remainder // 10\n  end\n  result = to_s(digit,\
    \ base) + result\n  result = to_s(remainder, base) + result\n  return result\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| a dscore=1 tags=ruby |>\n<code>", "    x.to_s.reverse!\n\
    \    (x.to_s.reverse.split(\"\").map { |i| i.to_i(base) }.join ).reverse!\n  \
    \  x.to_s.reverse\nend\n</code>\nThe only requirement is that base numbers are\
    \ less than 10.\n<|/ a |>\n<| c |>\nThanks Martin. The problem is I already have\
    \ the code as you see in my original post. I just need to find the right way to\
    \ write the algorithm to find the answer without using any built in functions.\
    \ I did my research and I see there are only a few people that can help me on\
    \ this. Maybe my question is not well written so I change my original post a little\
    \ bit. Thank you again.\n<|/ c |>\n<| c |>\n, The `change_base` function is just\
    \ an example of how you could approach the problem.  To answer your question of\
    \ \"how to find the answer without using any built-in functions\", you just need\
    \ to understand how to write recursive functions.  Look at the function's `next`\
    \ function call, which does the next recursion.  So you can just do the same thing\
    \ recursively, except that you don't have to return the result of the `change_base`\
    \ function.  Instead, call the `next` function as you recurse until you're done.\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>", "  if x != 0\n    digits = []\n    while\
    \ x > 0\n      digit = x % base\n      x /= base\n      digits << digit\n    digits.reverse!\n\
    \    digits = digits.join \"\"\n    digits << 0\n  end\n  digits\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>", "  x.to_s.reverse.each_char.with_index(1).inject(\"\
    \") do |s, (n, i)|\n    i2 = base.to_i * base\n    digit = x.to_n % i2 # % operator\
    \ is the remainder of a / b\n    n += digit\n    s += i2 - digit.to_i * base\n\
    \  end.reverse\nend", "  x.to_s.reverse!\n  x.to_s = x.to_s.split(//).map(&:to_i).map\
    \ { |i| base_to_index(i, base) }.join.to_s\nend\n</code>\n<|/ a dscore=0 tags=ruby-on-rails,ruby,math\
    \ |>\n<| a tags=ruby-on-rails,ruby,math |>\nThis one handles large numbers in\
    \ a safe way (without overflowing arrays):\n<code>\nmodule BigNum\n  BASE_10 =\
    \ [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,23",
  "  x.to_s.reverse.split(//).reverse.map {|i| i.to_i(base)}.join\nend\n</pre>\n\t\
    \t\t\t<pre class=\"ruby\">", "  if base < 2 or base > 10\n    raise \"Invalid\
    \ base!\"\n  result = x.to_s\n  while result.length <  base\n    result += \"\
    0\"\n  while result.length > base\n    result = result.slice(0, -1)\n  \n  result\
    \ = result.slice(base..-1).reverse\n  result = result.join.to_i(base)\n  \n  return\
    \ result\nend", "  num = \"\"\n  while x >= base\n    num = num * base + x\n \
    \   x = x - (x / base)\n  end\n  num = num * base + x\n  return num\nend\nputs\
    \ change_base.call(8, 2)", "  x = x.to_s\n  if x.is_a? Integer\n    base = base.to_s\n\
    \    digits = \"0123456789\"\n    if base == \"10\"\n      digits.reverse + \"\
    abcdefghijklmnopqrstuvwxyz\"\n    else\n      digits = digits * base\n    end\n\
    \    digits = digits.gsub(/^\\+/, \"\")\n    digits.reverse!\n    result = []\n\
    \    digits.each { |i| result[i] = x % base }\n    x = x.to_i\n    result.each\
    \ { |i| x = x / base + i }\n    result.join(\"\")\n  else\n    raise ArgumentError,\
    \ \"#{x} is not a number\"\n  end\nend", "  if base < 0 or base > 10\n    return\
    \ \"Bad base\"\n  if x > 0 and x < base\n    return x.to_s\n  ans = \"\"\n  while\
    \ (x > 0)\n    digit = x % base\n    ans = digit.to_s + ans\n    x = x / base\n\
    \  return ans\nend", "    digits = []\n    digit = x.to_s(base)\n    if digit\
    \ =~ /^-?\\d+$/\n        digits.push digit\n    else\n        digits.push digit[-base..-1]\n\
    \    end\n    return digits[0...-1].join\nend\n</cell>\n<cell>", "  if base <=\
    \ 10\n    x.to_s.reverse\n    base\n  elsif base > 10\n    change_base(x, base.to_i)\n\
    \  elsif base < 0\n    change_base(x, (10.to_i + base.to_i).to_i)\n  else\n  \
    \  x\n  end\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\nI did a function that converts\
    \ number to given base (including negative numbers)\n<code>", "    digits = (\"\
    0\" .. base).to_a\n    digits[base] = x.to_s.chars.join.to_i\n    digits.map!{|x|\
    \ x.to_i}\n    digits.join\nend", "  base = base.to_i\n  x = x.to_i\n  case base\
    \ < 10\n  when 0\n    return x.to_s + '0'\n  when 1\n    return '1' + x.to_s\n\
    \  when 2\n    if x < 100\n      return '2' + x.to_s\n    elsif x < 1000\n   \
    \   return '3' + x.to_s\n    elsif x < 10000\n      return '4' + x.to_s\n    elsif\
    \ x < 100000\n      return '5' + x.to_s\n    elsif x < 1000000\n      return '6'\
    \ + x.to_s\n    elsif x < 10000000\n      return '7' + x.to_s\n    elsif x < 100000000\n\
    \      return '8' + x.to_s\n    elsif x < 1000000000\n      return '9' + x.to_s\n\
    \    elsif x < 10000000000\n      return 'A' + x.to_s\n    elsif x < 100000000000\n\
    \      return 'B' + x.to_s\n    elsif x < 1000000000000\n      return 'C' + x.to_s\n\
    \    elsif x < 10000000000000\n      return 'D' + x.to_s\n    elsif x < 100000000000000\n\
    \      return 'E' + x.to_s\n    elsif x < 1000000000000000\n      return 'F' +\
    \ x.to_s\n    else\n      return 'F' + x.to_s\n    end\n  else\n    if x < 1000\n\
    \      return '0' + x.to_s\n    elsif x < 10000\n      return 'A' + x.to_s\n \
    \   elsif x < 100000\n      return 'B' + x.to_s\n    elsif x < 1000000\n     \
    \ return 'C' + x.to_s\n    elsif x < 10000000\n      return 'D' + x.to_s\n   \
    \ elsif x < 100000000\n      return 'E' + x.to_s\n    elsif x < 1000000000\n \
    \     return 'F' + x.to_s\n    elsif x < 10000000000\n      return 'G' + x.to_s\n\
    \    elsif x < 100000000000\n      return 'H' + x.to_s\n    elsif x < 1000000000000\n\
    \      return 'I' + x.to_s\n    elsif x < 10000000000000\n      return 'J' + x.to_s\n\
    \    elsif x < 100000000000000\n      return 'K' + x.to_s\n    elsif x < 1000000000000000\n\
    \      return 'L' + x.to_s\n    else\n      return 'L' + x.to_s\n    end\n  end\n\
    end", "  base_digits = base_to_digits(base)\n  x = x.to_s\n  digits = x.split(\"\
    \")\n  return digits.map{|d| base_digits[d].to_s << 1}.join\nend", "  if x < 10\n\
    \    puts \"#{x * base}\"\n  else\n    puts \"#{((x - 10) / base) * (base ** 2)}#{\"\
    0\" * (base - 1)}\"\n  end\nend\n</code>\n<|/ a dscore=2 tags=ruby,string |>\n\
    <| c |>\nThanks for the response, but that example is not quite what I am looking\
    \ for.\n<|/ c |>\n<| c |>\n, I don't understand. Are you saying you want a more\
    \ generalized way to do base conversion, such as `base_convert(number, base, digit)`?\n\
    <|/ c |>\n<| c |>\nI am looking to see if there is a way to convert any given\
    \ number into a base of another given number\n<|/ c |>\n<| c |>\n, that's not\
    \ possible, because base conversion is undecidable.\n<|/ c |>\n<| c |>\nIt sounds\
    \ like a bad plan, is there a better way?\n<|/ c |>\n<| a tags=ruby,string |>\n\
    The question is \"can you do this?\"\nThe answer is yes, you can do it, and it's\
    \ a lot easier than the other answers, since in some languages converting a decimal\
    \ to any base is as simple as dividing the decimal by the base. Ruby's core libraries\
    \ use BigDecimal's divide_by method to do the division:\n<code>\nBigDecimal.new(DecimalString.to_f,\
    \ base).to_s\n</code>\nWhere DecimalString is whatever base you want to convert\
    \ to.\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nI wrote a gem that can help you do\
    \ this.\nhttps://github.com/jennygardner/to_base\n<code>\nrequire 'to_base'",
  "    base, base_to_x_table = base\n    if base_to_x_table == nil\n        base_to_x_table\
    \ = {}\n    end\n    x_string = \"\"\n    while x > 1\n        x_string = x.to_s\
    \ + x_string\n        x = (x / base).to_i\n    end\n    x = x_string.to_i\n  \
    \  x_to_base_table = base_to_x_table[base]\n    x_to_base_table[x_string] = x\n\
    end\nchange_base.call(nil, 3)\nchange_base.call(nil, 2)\nchange_base.call(8, 2)\n\
    change_base.call(7, 2)\nchange_base.call(8, 1)\nchange_base.call(3, 1)\nchange_base.call(1,\
    \ 1)\nchange_base.call(10, 1)\nchange_base.call(10, 2)\nchange_base.call(1, 2)\n\
    change_base.call(1, 3)\nchange_base.call(1, 4)\nchange_base.call(92, 1)\nchange_base.call(91,\
    \ 1)\nchange_base.call(91, 2)\nchange_base.call(90, 2)\nchange_base.call(89, 1)\n\
    change_base.call(89, 2)\nchange_base.call(87, 2)\nchange_base.call(87, 1)\nchange_base.call(83,\
    \ 1)\nchange_base.call(83, 2)\nchange_base.call(82, 1)\nchange_base.call(82, 2)\n\
    change_base.call(81, 2)\nchange_base.call(81, 1)\nchange_base.call(79, 1)\nchange_base.call(79,\
    \ 2)\nchange_base.call(78, 1)\nchange_base.call(78, 2)\nchange_base.call(77, 1)\n\
    change_base.call(77, 2)\nchange_base.call(76, 1)\nchange_base.call(76, 2)\nchange_base.call(75,\
    \ 1)\nchange_base.call(75, 2)\nchange_base.call(73, 2)\nchange_base.call(73, 1)\n\
    change_base.call(73, 2)\nchange_base.call(72, 1)\nchange_base.call(72, 2)\nchange_base.call(71,\
    \ 1)\nchange_base.call(71, 2)\nchange_base.call(70, 2)\nchange_base.call(69, 1)\n\
    change_base.call(69, 2)\nchange_base.call(68, 1)\nchange_base.call(68, 2)\nchange_base.call(67,\
    \ 1)\nchange_base.call(67, 2)\nchange_base.call(66, 1)\nchange_base.call(66, 2)\n\
    change_base.call(65, 1)\nchange_base.call(65, 2)\nchange_base.call(63, 2)\nchange_base.call(63,\
    \ 1)\nchange_base.call(63, 2)\nchange_base.call(62, 1)\nchange_base.call(62, 2)\n\
    change_base.call(61, 2)\nchange_base.call(61, 1)\nchange_base.call(60, 2)\nchange_base.call(59,\
    \ 1)\nchange_base.call(59, 2)\nchange_base.call(58, 1)\nchange_base.call(58, 2)\n\
    change_base.call(57, 1)\nchange_", "  if base == 0\n    \"0\"\n  elsif base <\
    \ 10\n    x.to_s.gsub(/\\d+/) { |m| m.to_i }\n  elsif base == 10\n    x.to_s.gsub(/\\\
    d+/) { |m| m.to_s.rjust(2, \"0\") }\n  else\n    x.to_s.gsub(/\\d+/) { |m| m.to_s.rjust(base,\
    \ \"0\") }\n  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
