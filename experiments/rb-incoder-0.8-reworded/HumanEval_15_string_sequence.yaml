name: HumanEval_15_string_sequence
language: rb
prompt: "# Return a string containing space-delimited numbers starting from 0 upto\
  \ n inclusive.\n# >>> string_sequence.call(0)\n# \"0\"\n# >>> string_sequence.call(5)\n\
  # \"0 1 2 3 4 5\"\ndef string_sequence(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_string_sequence\n\
  \    candidate = method(:string_sequence)\n    assert_equal(\"0\", candidate.call(0))\n\
  \    assert_equal(\"0 1 2 3\", candidate.call(3))\n    assert_equal(\"0 1 2 3 4\
  \ 5 6 7 8 9 10\", candidate.call(10))\n  end\nend\n"
completions: ["  s = \"\"\n  loop do\n    s << yield(n)\n    n += 1\n  end\n  s\n\
    end", "  return \"\".to_s.tap{ |s| s << n.to_s }\nend", "  \"%(n)d\" % {'n': n}\n\
    end", "  # TODO: Use a helper function string_range(n) defined above.\n  if n.is_a?\
    \ Fixnum\n    \"0\"\n  else\n    n.to_s.split(\" \").map { |x| x.to_i }.join\n\
    \  end\nend", "  str = \"\"\n  for i in 0...n\n    str = str + (i.to_s + \" \"\
    )\n  str\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails-3,ruby-on-rails |>\n<| c\
    \ |>\nAh yes, I suppose I could also do that but then I'd have to use `join`,\
    \ which I would do anyway. I'll update the question\n<|/ c |>\n<| c |>\nYou could\
    \ use `map`, e.g. `(1..n).map { |i| \"#{i}. \" }.join(\" \")`\n<|/ c |>\n<| c\
    \ |>\nThat was my first thought but I like your solution better :)\n<|/ c |>\n\
    <| c |>\nNice, I like that. My mind was blown away by this one.\n<|/ c |>\n<|\
    \ a tags=ruby,ruby-on-rails-3,ruby-on-rails |>\nThe best solution I've found so\
    \ far (but it's not as elegant as it could be) is:\n<code>", "  (0...n).map {\
    \ |n| sprintf(\"%0*d\", 2, n) }.join(' ')\nend", "  numbers = \"\"\n  while n\
    \ > 0\n    numbers << n.to_s\n    n -= 1\n  numbers.strip!\nend\n</code>\nThis\
    \ code does exactly what you described you wanted to do.  When you call string_sequence.call(5),\
    \ it returns \"0 1 2 3 4 5\", which you then can use in your code like \"#{string_sequence.call(5)}\"\
    .  It can be easily modified to accept more parameters (for example, if you wanted\
    \ to call string_sequence.call(n, first_number, last_number) it would return \"\
    #{first_number.to_s} #{string_sequence(n - first_number)} #{last_number.to_s}\"\
    ).  However, you really don't need it - you can just call string_sequence.call(5).\
    \  If you really want to do what you did in the beginning, just change your last\
    \ line to return numbers.\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nThanks for\
    \ the response! I've edited my question to include my controller's code. I'm using\
    \ a before_action filter to set the instance variable with the string sequence,\
    \ and using that string in the view. I've tried your suggestion of making a helper\
    \ for my string sequence, but I'm getting `undefined method 'call' for #<Class:0x00000005acf3d8>`\
    \ when I try to view the index page in my browser. Any ideas why?\n<|/ c |>\n\
    <| c |>\nYeah, I got that far too. I changed `class StringSequence` to `class\
    \ StringSequence` and `def stringsequence(n)` to `def stringsequence(n, first,\
    \ last)` in my helper, and changed `@string_sequence = StringSequence.call(n)`\
    \ to `@string_sequence = StringSequence.call(n, first, last)` in my controller.\
    \ Now I'm getting `undefined method 'call' for #<StringSequence:0x00000005acf3d8>`.\
    \ I updated my question with my updated code!\n<|/ c |>\n<| c |>\nSorry, I didn't\
    \ notice that your `StringSequence` class was actually a subclass of `String`\
    \ - try making that change to `class StringSequence`.  Also, I'd recommend making\
    \ it a module, not a class - it seems more appropriate (since you only need it\
    \ in a single place)\n<|/ c |>\n<| c |>\nI just changed the `class StringSequence`\
    \ to `class StringSequence` and `def stringsequence(n)` to `def stringsequence(n,\
    \ first, last)` in my helper, and changed `@string_sequence = StringSequence.call(n)`\
    \ to `@string_sequence = StringSequence.call(n, first, last)` in my controller.\
    \ Now I'm getting `undefined method 'call' for #<StringSequence:0x00000005acf",
  "  s = \"0\"\n  while n > 0\n    s = s << \" #{n}\"\n    n = n - 1\n  end\n  s\n\
    end", "  n.times { yield \"#\" }\n  yield \" \"\nend\n</code>\n<|/ a |>\n<| c\
    \ |>\nThis is the method I used in the end. Though I used a similar approach but\
    \ I used it in a more 'rails-way' by making a helper method for the numbers. I\
    \ appreciate your answer, though as you said it was not very Rubyish but this\
    \ seemed like it was the most efficient method. I don't know what I was thinking\
    \ back then.\n<|/ c |>\n<| a |>\nFor Ruby 1.9.x this may help you, it's working\
    \ and tested in Rails 3.2.\n<code>", "  \n  # Create an empty string which will\
    \ be used to store the sequence of numbers created.\n  string = \"\"\n  \n  #\
    \ Loop through the numbers starting from 0 upto n inclusive.\n  for i in 0...n\n\
    \    \n    # Append the number to a string starting from the beginning of the\
    \ string. \n    # This string is stored in string.\n    string << i\n  \n    #\
    \ Return that string.\n    return string\nend", "  i = 0\n  res = []\n  while\
    \ i < n\n    res << yield(i)\n    i += 1\n  end\n  res.join\nend", "  result =\
    \ []\n  (0..n).each do |i|\n    result << i.to_s\n  end\n  result.join(\" \")\n\
    end", "  # Initialize a string to contain the sequence of numbers.\n  string =\
    \ \"\"\n  # Iterate over the numbers from 0 to n.\n  for i in 0..(n-1)\n    #\
    \ Add a space between numbers and the space.\n    string = string + \" \" + i.to_s\n\
    \  end\n  # Return string.\n  string\nend", "  seq = \"\"\n  while n > 0\n   \
    \ seq << \" #{ n % 10 }\"\n    n /= 10\n  end\n  seq\nend", "  result = []\n \
    \ for i in 0...n\n    result.concat(@(i).to_s)\n  end\n  result.join(\" \")\n\
    end\n</pre>", "  n.to_s.split('').collect { |i| i.to_s }.join(' ')\nend", "  string\
    \ = \"\"\n  while n > 0\n    string = \"#{n} #{string} \"\n    n = n - 1\n  end\n\
    \  string\nend", "  str = \"\"\n  for i in 1..n\n    str = str + \" \" + call(i)\n\
    \  end\n  str\nend\n</code>\n<|/ a tags=ruby,function |>\n<| c |>\n+1: Very nice\
    \ approach! I like that you don't need to define the function yourself. But why\
    \ `@n` isn't declared as global? Is it a bug?\n<|/ c |>\n<| c |>\nThe scope of\
    \ local variables is not limited to a method unless you explicitly declare them\
    \ as global. That is why you have to declare the variable `@n` as global inside\
    \ the method. If you do not do that, the variable `@n` is defined in the block\
    \ scope of the method and thus is not accessible outside.\n<|/ c |>\n<| c |>\n\
    Thanks. I didn't know that. I've added it to my answer.\n<|/ c |>\n<| c |>\nVery\
    \ nice! I'm new to Ruby so I didn't know about this! Thanks a lot.\n<|/ c |>\n\
    <| c |>\nThank you.  I wasn't aware that local variables were not limited to the\
    \ method body as they were in other languages.\n<|/ c |>\n<| a dscore=0 |>\nThis\
    \ works, though it's pretty ugly:\n<code>", "  result = \"\"\n  for i in 0...n\n\
    \    result << \"#{i}\"\n  end\n  result\nend", "  n.times do |i|\n    yield(i)\n\
    \  end\nend", "  sequence = \"\"\n  1.upto(n-1) do |x|\n    sequence += x.to_s\n\
    \  end\n  sequence\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\nI came up with the\
    \ following solution using recursion. Hope it helps.\n<code>", "  a = [0 for _<:(n-1)]\n\
    \  a[-1] = n.to_s\n  a\nend", "  numbers = 0..(n-1).to_a\n  numbers_string = numbers.map{|n|\
    \ n.to_s}.join(\" \")\n  numbers_string\nend\n</code>\n<|/ a dscore=1 |>\n<| c\
    \ |>\nThanks again. I've edited my question - I realise this is a really basic\
    \ question, but I'm a beginner learning Ruby, and am struggling a bit!\n<|/ c\
    \ |>\n<| a tags=ruby,ruby-on-rails dscore=1 |>\nI love this kind of problems that\
    \ you try to solve with ruby on rails.\nI suggest you to try with this:\n<code>",
  "  \"#{0..n}\"\nend", "  return n.to_s.split(\" \").collect(&:to_i)\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThanks for your answer. I have a quick question: Why does your\
    \ solution require a module to be required in the beginning and why doesn't the\
    \ code I posted require any additional modules to be required in the beginning\
    \ (except for the definition of `string_sequence`)?\n<|/ c |>\n<| c |>\n`collect`\
    \ and `inject` are methods in the `Enumerable` module and `Enumerable` is a module\
    \ that is included in every Ruby program. This is the same as `require \"Enumerable\"\
    ` at the start of your program, which is what `Enumerable` contains. You can read\
    \ up on Ruby modules at [ruby-doc.org](http://ruby-doc.org/core-2.1.2/Module.html)\n\
    <|/ c |>\n<| c |>\nThanks for your explanations. Do you know why in my solution\
    \ I couldn't use just `n.to_s.split().collect()` instead of `n.to_s.split(\" \"\
    ).collect` ?\n<|/ c |>\n<| c |>\n`split` returns a single string that is a representation\
    \ of an array of strings. By passing that to the collect method, you are calling\
    \ `collect` on the return of split, which returns a string array. `collect` doesn't\
    \ exist on the string array though.\n<|/ c |>\n<| c |>\nAh ok I understand. Thanks\
    \ :)\n<|/ c |>\n<| a tags=ruby |>\nYou can write it this way:\n<code>", "  s =\
    \ \"\"\n  until n == 0\n    s = s + \" \" + call(0)\n    n -= 1\n  end\n  s\n\
    end", "  result = ''\n  n.times do |i|\n    result << i\n    result << \" \"\n\
    \  end\n  result[0...-1]\nend\n</code>\nAnd now we get the sequence we want:\n\
    <code>", "  \"#{n}\"\nend", "  numbers = (0...n).to_a\n  numbers.collect! { |n|\
    \ n.to_s.rjust(2, '0') }\n  numbers.join(' ')\nend", "  return n.to_s.split('')\n\
    end", "  # Define a function named \"string_sequence\" that returns a string containing\
    \ space-delimited numbers\n  # starting from 0 upto n inclusive.\n  \n  # Return\
    \ a string containing space-delimited numbers starting from 0 upto n inclusive.\n\
    \  # >>> string_sequence.call(0)\n  # \"0\"\n  # >>> string_sequence.call(5)\n\
    \  # \"0 1 2 3 4 5\"\n  return n.to_s.split(\" \").map {|i| i.to_i}.to_s.join(\"\
    \ \")\nend", "  result = []\n  (0..Float::INFINITY).each do |i|\n    result <<\
    \ i.to_s\n  end\n  result\nend", "  # Define a sequence of strings containing\
    \ numbers between 0 and n-1.\n  result = ''\n  i = 0\n  # Continue until we reach\
    \ n.\n  while (i < n)\n    # Append a space to the current string, unless n is\
    \ 0.\n    result += (i < 1) ? ' ' : ''\n    # Append the number to this string.\n\
    \    result += i.to_s\n    i += 1\n  # Return the string.\n  return result\nend",
  "  \"Returns a string containing space-delimited numbers starting from 0 upto n\
    \ inclusive.\"\n  (0...n).collect { |i| i.to_s.rjust(n,\" \") }.join\nend", " \
    \ s = \"0\"\n  for i in 1..n\n    s = s + \" \" + s\n  end\n  s\nend", "  return\
    \ \" \".take_while{ |x| x <= n } + \" \".repeat_while{ |x| x <= n } \nend", " \
    \ return n.to_s.split(\" \").collect(&:to_i).join(\" \")\nend", "  return @range_call(:string_sequence,\
    \ n)\nend", "  str = n.to_s.gsub(/([0-9]+)/) {|x| x[/([0-9]+)/].to_i}.join\n \
    \ str.length > 0 ? str : nil\nend\n</code>\nAs you noticed I didn't use the Ruby\
    \ range function, because it's kind of ugly, so here is my own implementation\
    \ of a range function, which I find really useful, and I think it's pretty efficient:\n\
    <code>", "  str = \"\"\n  for i in 0..(n-1)\n    str += i.to_s\n  end\n  str\n\
    end", "  seq = \"\"\n  for i in 0...n\n    seq = seq + \" \" + i\n  end\n  return\
    \ seq\nend", "  \"Return space-delimited numbers starting from 0 upto n inclusive.\"\
    \n  (0..n).to_a.join(\" \")\nend", "  s = \"\"\n  for i in 0..(n)\n    s = s <<\
    \ (i+1) + \" #{i}, \"\n  end\n  return s\nend", "  n.to_s.split(\" \").map { |n|\
    \ n.to_i }.to_s.reverse\nend\n</code>\n<|/ a tags=ruby,sequence |>\n<| a |>\n\
    Here's my take:\n<code>", "  \"#{0..n}\"\nend", "  number_to_string = number_to_string_map[n]\n\
    \  return number_to_string.call(n)\nend", "  result = ''\n  (1..n).each do |i|\n\
    \    result << \" #{i}\"\n  end\n  result\nend", "  return n.to_s\nend", "  result\
    \ = []\n  while n > 0\n    result << n\n    n -= 1\n  end\n  result.join(' ')\n\
    end", "  a = []\n  n = 0\n  until n < 20 do\n    a.push(n == 0 ? \"0\" : n.to_s)\n\
    \    n = n + 1\n  end\n  return a.join(' ')\nend", "  \"#{0..(n-1)}\"\nend\n</code>\n\
    And here's another way to produce such a sequence:\n<code>", "  if n < 1\n   \
    \ n = 1\n  result = ''\n  for i in 0...n\n    result << i\n    result << \" \"\
    \n  end\n  result\nend", "  string_sequence = [0]\n  while string_sequence.last\
    \ < n\n    string_sequence << string_sequence.last += 2\n  end\n  string_sequence.last\n\
    end\n</pre>", "  a = []\n  while n > 0\n    a << (n % 10).to_s + \" \"\n    n\
    \ /= 10\n  end\n  a.reverse\n  a.join(\"\")\nend", "  seq = \"\"\n  loop do\n\
    \    seq = seq + yield(seq)\n  end\nend", "  \n  # Make an accumulator for our\
    \ sequence of numbers.\n  numbers = \"\"\n  \n  # Build our sequence of numbers\
    \ one at a time, adding each one to the accumulator as we go.\n  (1..n).each do\
    \ |number|\n    numbers += number.to_s + \" \"\n  end\n  \n  # Return our accumulator\
    \ which now contains the string of space-delimited numbers from 0 to n inclusive.\n\
    \  numbers\nend\n</cell>\n<text>\nLet's test our string_sequence function", " \
    \ s = \"\"\n  i = 0\n  while i < n do\n    s += \"#{n}-\"\n    i += 1\n  end\n\
    \  s\nend", "  (0..(n)).map {|i| i.to_s}.join(' ')\nend", "  i = 0\n  while i\
    \ <= n\n    i += 1\n    yield i\n  end\nend\n</cell>\n<text>\nNow you can use\
    \ a for loop on an instance of string_sequence to print out its values from 0\
    \ to 5 inclusive.", "  return n.to_s\nend", "  \"#{(0...n).map{|i| i.to_s}.join('\
    \ ')}\"\nend\n</code>\n<code>", "  number_sequence = \" \"\n  number = 0\n  while\
    \ number < n\n    number_sequence = number_sequence + number.to_s + \"\\n\"\n\
    \    number += 1\n  number_sequence\nend", "  return n.times.to_a.join\nend",
  "  \"#{0..(n-1)}\"\nend", "  return ('0 ' + n.to_s.reverse.split(\" \").map{|n|\
    \ n.to_s}.join(\" \"))\nend", "  n = n()\n  i = 0\n  acc = ''\n  while i < (n-1)\n\
    \    acc = acc + ((i % 10).to_s + ' ')\n    i += 1\n  end\n  return acc\nend",
  "  # Print the current value of n to the console using \"puts\" for debugging purposes.\n\
    \  puts \"#{n}\" if n > 0\n  # Create a string containing space-delimited numbers\
    \ starting from 0 up to n inclusive.\n  number_sequence = \"\"\n  n.times do |index|\n\
    \    number_sequence += \" #{index}\"\n  end\n  return number_sequence\nend",
  "  n = n.to_i if n.respond_to? :to_i\n  return \"0\" if n < 0\n  return n.to_s.split(\"\
    \ \").map(&:to_i).sort.map(&:to_s).join(\" \")\nend", "  # Define a procedure,\
    \ string_sequence, to return a string containing numbers starting from 0 upto\n\
    \  # n inclusive.\n  s = \"0\"\n  while n > 0\n    s = s << 1 + n\n    n -= 1\n\
    \  end\n  s\nend", "  result = \"\"\n  for i in 0 .. n\n    result += i.to_s +\
    \ \" \"\n  end\n  result\nend", "  if n < 0\n    error(\"string_sequence expected\
    \ a non-negative integer, but got #{n}\")\n  end", "  result = []\n  (n - 1).downto(0)\
    \ do |x|\n    result << (x + 1).to_s\n  end\n  result.join(' ')\nend", "  # Return\
    \ a string containing space-delimited numbers starting from 0 upto n inclusive.\n\
    \  s = \"\"\n  i = n - 1\n  while i >= 0\n    s = s + \"#{i}\"\n    i = i - 1\n\
    \  end\n  s\nend", "  return join(*[ \"#{0.call(i)}\" for i in xrange(n) ])\n\
    end", "  # Return a string containing space-delimited numbers starting from 0\
    \ upto n inclusive.\n  return \"#{n}\".to_s + \" \"*(n - \"#{n}\".to_s.size)\n\
    end", "  result = ''\n  for i in 0...n\n    result << i.to_s\n    result << '\
    \ '\n  end\n  result\nend", "  return n.to_s.split(\" \").map(&:to_i).inject(:+).to_s.rstrip\n\
    end\nend", "  \"#{0.upto(n).map { |i| i.to_s }}\"\nend", "  # Initialize the string\
    \ to be the empty string.\n  result = ''\n  # While there are numbers remaining\
    \ to be added to the string, add them to the string.\n  while n > 0\n    # Add\
    \ the next number to the string.\n    result = result + to_s(n)\n    # Decrement\
    \ the number by 1.\n    n = n - 1\n  # Return the string containing the number\
    \ sequence.\n  result\nend", "  # Return a string containing space-delimited numbers\
    \ starting from 0 upto n inclusive.\n  # >>> string_sequence.call(0)\n  # \"0\"\
    \n  # >>> string_sequence.call(5)\n  # \"0 1 2 3 4 5\"\n  s = \"\"\n  while n\
    \ > 0\n    s, n = s[0, n-1], n - 1\n  end\n  return s\nend", "  if n <= 0\n  \
    \  return \"0\"\n  s = \"\"\n  i = 0\n  while i <= n\n    s << i << \" \" << (i\
    \ + 1) + \"\\n\"\n    i += 1\n  s\nend", "  \"#{n}\"\nend", "  result = \"\"\n\
    \  i =  0\n  while i < n\n    result = result + \" \" + i.to_s\n    i += 1\n \
    \ end\n  result\nend", "  str_array = Array.new(n - 1)\n  str_array.fill(\"\"\
    )\n  str_array.map! do |i|\n    i.to_s + \" \" + (i.to_s + 1).to_s\n  end\n  str_array.join(\"\
    , \")\nend\n</pre>\n          </div>\n        </div>\n      </div>\n    </div>\n\
    \    <div class=\"col-2\">\n      <div class=\"nav-item has-treeview menu-open\"\
    >\n        <button class=\"nav-link active\">\n          <i class=\"nav-icon fas\
    \ fa-tree\"></i>\n          <p>\n            Data structures\n            \n \
    \           \n          </p>\n        </button>\n        <a class=\"nav-link\"\
    \ href=\"/algorithms/graphs\">\n          <i class=\"far fa-circle nav-icon\"\
    ></i>\n          <p>\n            Graphs\n            \n            \n       \
    \   </p>\n        </a>\n      </div>\n    </div>\n    <div class=\"col-2\">\n\
    \      <div class=\"nav-item has-treeview\">\n        <button class=\"nav-link\"\
    >\n          <i class=\"nav-icon fas fa-chart-pie\"></i>\n          <p>\n    \
    \        Charts\n            \n            <i class=\"fas fa-angle-left right\"\
    ></i>\n          </p>\n        </button>\n        <a class=\"nav-link\" href=\"\
    /charts/chartjs.html\">\n          <i class=\"far fa-circle nav-icon\"></i>\n\
    \          <p>\n            Charts\n            \n            <i class=\"fas fa-angle-left\
    \ right\"></i>\n          </p>\n        </a>\n      </div>\n    </div>\n    <div\
    \ class=\"col-2\">\n      <div class=\"nav-item has-treeview\">\n        <button\
    \ class=\"nav-link\">\n          <i class=\"nav-icon fas fa-tree\"></i>\n    \
    \      <p>\n            UI Elements\n            \n            \n          </p>\n\
    \        </button>\n        <a class=\"nav-link\" href=\"/interfaces/colors.html\"\
    >\n          <i class=\"far fa-circle nav-icon\"></i>\n          <p>\n       \
    \     Colors\n            \n            \n          </p>\n        </a>\n     \
    \ </div>\n    </div>\n    <div class=\"col-2\">\n      <div class=\"nav-item has-treeview\"\
    >\n        <button class=\"nav-link\">\n          <i class=\"nav-icon fas fa-edit\"\
    ></i>\n          <p>\n            Forms\n            \n            \n        \
    \  </p>\n        </button>\n        <a class=\"nav-link\" href=\"/forms/general.html\"\
    >\n          <i class=\"far fa-circle nav-icon\"></i>\n          <p>\n       \
    \     General Elements\n            \n            \n          </p>\n        </a>\n\
    \      </div>\n    </div>\n    <div class=\"col-2\">\n      <div class=\"nav-item\
    \ has-treeview\">\n        <button class=\"nav-link\">\n          <i class=\"\
    nav-icon fas fa-table\"></i>\n          <p>\n            Tables\n            \n\
    \            \n          </p>\n        </button>\n        <a class=\"nav-link\"\
    \ href=\"/tables/bootstrap.html\">\n          <i class=\"far fa-circle nav-icon\"\
    ></i>\n          <p>\n            Bootstrap\n            \n            \n    \
    \      </p>\n        </a>\n      </div>\n    </div>\n    <div class=\"col-2\"\
    >\n      <div class=\"nav-item has-treeview\">\n        <button class=\"", " \
    \ a = (0...n).to_a.join(' ')\n  a = a.gsub(/^0/, '').gsub(/[^ 0-9]+/, ' ').gsub(/\
    \ +$/, '')\nend", "  number_sequence = (0..n).to_a\n  number_sequence.collect!\
    \ do |i|\n    i.to_s.rjust(2, '0')\n  end\n  number_sequence.join\nend", "  result\
    \ = ''\n  i = 0\n  while i < n do\n    result = result + ' ' + i\n    i += 1\n\
    \  end\n  result\nend", "  result = \"\"\n  (1..n).each { |i| result << i }\n\
    \  result\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>", "  number_list =\
    \ Array.new(n+1)\n  number_list.each do |i|\n    number_list[i] = i+1\n  end\n\
    \  number_list.to_s\nend", "  seq = \"\"\n  while n > 0\n    seq << n\n    n -=\
    \ 1\n  end\n  seq\nend", "  s = \"\"\n  while n > 0 do\n    s, n = s, n.succ\n\
    \  end\n  s\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby |>\nA simple way\
    \ to implement this is:\n<code>", "  number_string = n.to_s\n  number_string.gsub!(/\\\
    D/, ' ')\n  number_string.split(' ').map { |x| x.to_i }.join(' ')\nend", "  return\
    \ \"#{0...n}\"\nend", "  numbers = (0...n).to_a\n  numbers.map { |i| i.to_s }.join(\"\
    \ \")\nend", "  result = \"0\"\n  for i in 0...n\n    result = result + \" \"\
    \ + i.to_s\n  end\n  result\nend", "  number_str = \" \" * n\n  number_str.slice!(0)\n\
    \  number_str.slice!(0...n)\n  number_str\nend", "  return n.to_s * (n - 1)\n\
    end", "  result = ''\n  for i in (0..n-1)\n    result = result + (i).to_s + \"\
    \ \"\n  result\nend", "  result = ''\n  (0...n).each do |i|\n    result << i\n\
    \    result += \" \"\n  end\n  result\nend", "  result = \"0\"\n  i = 1\n  while\
    \ i <= n\n    result += (i .to_s ).to_s + \" \"\n    i += 1\n  result \nend",
  "  s = \"\"\n  for i in 0...n\n    s = s << i\n  s\nend\n</code></pre>\n<h3 id=\"\
    string-concatenation-s-\">String Concatenation: <code>+</code></h3>\n<pre><code\
    \ class=\"rust rust-example-rendered\">fn string_concat_s(x: String, y: String)\
    \ -> String {\n    x + y\n}\n</code></pre>\n<p>String concatenation is a pretty\
    \ straight-forward operation. Strings are immutable and each time a new string\
    \ is created it\u2019s copied from the previous one. In Python, strings are also\
    \ mutable so concatenation is a relatively expensive operation. Rust on the other\
    \ hand performs string concatenation very efficiently. The compiler optimizes\
    \ away redundant string concatenations because they can be shared between different\
    \ strings. This means that the following code will compile just fine:</p>\n<pre><code\
    \ class=\"rust rust-example-rendered\">fn string_concat_s(x: String, y: String)\
    \ -> String {\n    let z: String = x + y;\n    z\n}\n</code></pre>\n<h3 id=\"\
    string-concatenation-and-string-literal-concatenation\">String Concatenation and\
    \ String Literal Concatenation</h3>\n<p>Rust allows the following syntax:</p>\n\
    <pre><code class=\"rust rust-example-rendered\">let x = String::from(\"abc\");\n\
    let y = String::from(\"def\");\nlet z = x.to_string() + y.to_string();\n</code></pre>\n\
    <p>which compiles to:</p>\n<pre><code class=\"rust rust-example-rendered\">let\
    \ x = \"abc\";\nlet y = \"def\";\nlet z = x + y;\n</code></pre>\n<p>String concatenation\
    \ and string literal concatenation are very similar operations, one difference\
    \ being that string concatenation creates a new string and thus involves heap\
    \ allocation. The difference between this and the string concatenation operator\
    \ (+) is that string concatenation will attempt to create a new string every time.\
    \ String concatenation can lead to inefficient or undesirable behaviour since\
    \ each new string will be copied from the previous string and a new object will\
    \ be created every time a new string is created. String literal concatenation\
    \ can avoid this by avoiding the creation of new strings and instead creating\
    \ a constant string on the heap. Rust also allows string concatenation and string\
    \ literal concatenation using the <code>concat</code> method which accepts a string\
    \ literal or a string literal (which is itself a constant string):</p>\n<pre><code\
    \ class=\"rust rust-example-rendered\">let x = \"abc\";\nlet y = \"def\";\nlet\
    \ z = x.concat(y);\nlet zz = String::from(x) + y;\n</code></pre>\n<p>which compiles\
    \ to:</p>\n<pre><code class=\"rust rust-example-rendered\">", "  a = []\n  i =\
    \ 0\n  while i < n\n    a << i.to_s\n    i += 1\n  end\n  a.join(' ')\nend", " \
    \ seq = \"\"\n  while n > 0\n    seq += \" \" + sprintf(\"%0#{length(n).to_s}d\"\
    , n)\n    n -= 1\n  seq\nend", "  \"#{n} + #{n % 10} + #{n % 100} + #{n % 1000}\
    \ + #{n % 10000} + #{n % 100000} + #{n % 1000000}\"\nend", "  return n.to_s.split(\"\
    \ \").inject(\"\", :+).sub!(/^0/, '')\nend", "  numbers = 0..(n)\n  numbers.inject(\"\
    \") do |s, i|\n    s << \"#{numbers[i]}\"\n  end\nend", "  if n < 1 then return\
    \ \"\"\n  strings = \"\"\n  for i in 0..n-1 do\n    strings = strings + \" \"\
    \ .. i\n  end\n  strings = strings + \" \"\n  strings = strings + n\n  return\
    \ strings\nend", "  \"#{n} #{n+1 .. n+n}\"\nend", "  if n<1\n    string_sequence.call(n,\"\
    \ \")\n  else\n    string_sequence.call(1,\",\") << (yield)\n    string_sequence.call(n-1,\"\
    \ \") << (yield)\n  end\nend\nendmodule\n\"\"\")", "  \"#{sequence(:0,n)}\"\n\
    end", "  string_sequence_helper(n, 0, \"\")\nend", "  i = 0\n  s = \"\"\n  while\
    \ i < n\n    s = s + i\n    i = i + 1\n    s\n  end\nend", "  \"#{0..(n-1).to_a}\"\
    \nend", "  return @to_s\nend", "  i = 0\n  result = \"0\"\n  while i < n\n   \
    \ result << \" \"\n    result << i\n    i += 1\n  end\n  return result\nend",
  "  result = \"\"\n  for i in 0..(n-1) do\n    result << (i % 10).to_s + \" \"\n\
    \  end\n  return result\nend", "  result = \"\"\n  for i in 0..n\n    result +=\
    \ i\n    result += \" \"\n  result[0..(n - 1)] + \".\"\nend", "  a = \"0\"\n \
    \ while a < n do\n    a = a + \" \" + (n % 10).to_s\n    n = n / 10\n  end\n \
    \ a\nend", "  number_sequence = '0' + '..' + n\n  number_sequence.gsub!(/..../,\
    \ '*')\n  number_sequence.gsub!(/*/, \"0\")\n  number_sequence\nend", "  result\
    \ = ''\n  i = 0\n  while i <= n\n    result << number_to_string(i)\n    i += 1\n\
    \  end\n  result\nend", "  str = \" \"\n  (0...n).each do |i|\n    str << \"#{i}\"\
    \n  end\n  str\nend\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| a tags=ruby |>\n\
    If you like doing things with strings then String#% (aka String#format) might\
    \ come in handy:\n<code>\nputs \"Hi, my name is %s. My name is %s. My name is\
    \ %s!\"\n</code>\nYou can replace %s with numbers (%i) or even multiple arguments\
    \ (%1$#). Also note that you can always put a variable inside of curly braces\
    \ and it will replace it with its value, for example:\n<code>\nputs \"Hi, my name\
    \ is %{name}. My name is %{name}. My name is %{name}!\"\n</code>\nWhich outputs:\n\
    <code>\nHi, my name is Frank. My name is Frank. My name is Frank!\n</code>\n<|/\
    \ a dscore=0 |>\n<| c |>\nI knew that `%i` was a thing, and I didn't know you\
    \ could use it that way. Unfortunately, it appears to require the use of string\
    \ interpolation. As far as I can tell, that's not really a good use of it.\n<|/\
    \ c |>\n<| c |>\n: That's correct. Though I think `String#format` is better than\
    \ `%` as it provides support for interpolation.\n<|/ c |>\n<| a dscore=0 tags=ruby\
    \ |>\nI suppose the question was for how to do this with arbitrary parameters,\
    \ not just three or 4.\n<code>", "  a = ''\n  for i in 0...n\n    a << i\n   \
    \ puts a\n  end\nend", "  ret = \"\"\n  for i in 0..n-1\n    ret += i.to_s\n \
    \   ret += \" \"\n  end\n  ret + n.to_s\nend", "  result = \"0\"\n  while n >\
    \ 0\n    result = \" #{result} #{n}\"\n    n = n - 1\n  end\n  result\nend", " \
    \ # Initialize string variable (using string concatenation) \n  s = \"\"\n  \n\
    \  # Perform a for loop for n times to populate string variable \n  for i in 1..n\n\
    \    s = s + i\n  end\n  \n  # Return string variable\n  s\nend\n</cell>\n<code\
    \ language=julia-1.6>", "  sequence = \"\"\n  for i in 1..n\n    sequence << i\n\
    \  end\n  sequence\nend", "  \"%s() 0 .. %d inclusive\" % [\n    name,\n    n\n\
    \  ]\nend", "  spaces = ' ' * n\n  strings = Array.new(spaces, 0, 2)\n  strings[1]\
    \ = ' '\n  strings.inject('') do |result, space|\n    result.concat(space + strings[0..n])\n\
    \  end\nend", "  result = ''\n  for i in 0..n-1\n    result << (i+1).to_s + '\
    \ '\n  end\n  result << (n+1).to_s\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    The `join` method was introduced in 1.8.7 so this solution will not work in older\
    \ versions.\n<|/ c |>\n<| c |>\n: Thanks, updated to use array concatenation instead.\n\
    <|/ c |>\n<| c |>\n: Thanks for your answer. While the problem was more theoretical\
    \ and I never actually tried your suggestion, I tried it and it doesn't work for\
    \ me because I'm working with a custom ruby interpreter, so `join` isn't even\
    \ an option.\n<|/ c |>\n<| a dscore=1 tags=ruby,string |>\n<code>\nn = 0\ns =\
    \ \"0\"\nwhile n <= n\n  s << n.to_s\n  n = n + 1\nend\ns << n\nputs s\n</code>\n\
    <|/ a |>\n<| c |>\nSorry, I wasn't clear in my question, I have revised it now.\
    \ The string has to start with a number, not 0.\n<|/ c |>\n<| a dscore=1 |>\n\
    I suspect that your question was more about how to get every permutation of a\
    \ string of digits. This is easily done by using the itertools rubygem:\n<code>\n\
    require 'itertools/permutation'\nstring = '0123456789'\nstring.permutation.each\
    \ { |perm| puts perm }\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nSorry, I\
    \ wasn't clear in my question, I have revised it now. The string has to start\
    \ with a number, not 0.\n<|/ c |>\n<| c |>\nThanks, I realized that after I posted.\n\
    <|/ c |>\n<| a tags=ruby,string |>\nI like these kind of solutions because it\
    \ shows me how to use the tool that I already know well and I like how they make\
    \ me think.\nTo do this I created an Array of all the digits.\n<code>\ndigits\
    \ = Array.new(n+1)\ndigits.each { |i| i << 0 }\n</code>\nThen I took the reverse\
    \ of it. I would start with the digit n and took digits from right to left and\
    \ I did this until I got all the digits in reverse order.\n<code>\nn = 0\nwhile\
    \ n < n\n  digits.reverse.each { |d| puts d[n-1]}\n  n += 1\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<|", "  if n < 0\n    n = 0\n  else\n    n = n-1\n  end\n  n\
    \ = n + 1\n  string = \"\"\n  for i in 0..n\n    string = (string + (\"#\" + to_s(i)))\n\
    \  end\n  string\nend", "  # We only care about even numbers in this exercise.\n\
    \  return \"0 1 2 3 4 5\".split(\" \").map { |n| n.to_s.to_i }.join(\"#\") + \"\
    \ 6\".to_s.to_i\nend\n</code>\n<|/ a |>\n<| c |>\nThank you so much! I'm going\
    \ to try out your solution this evening - it's a very interesting way to do this\
    \ kind of thing with Ruby.\n<|/ c |>\n<| a tags=loops,string,ruby |>\nI took a\
    \ different approach:\n<code>\nputs ('0' .. '5').map{ |i| i.to_s.rjust(2, '0')\
    \ }.join(' ')\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI like this one for its clarity,\
    \ but it's just as slow for me. Thanks for posting it!\n<|/ c |>\n<| c |>\n- you\
    \ might consider `('0' .. '5').each_with_object([]) { |i,a| a.unshift(i.to_s.rjust(2,'0'))\
    \ }`.\n<|/ c |>\n<| a tags=loops,string,ruby |>\n<code>", "  nseq = \"\"\n  while\
    \ n > 0\n    nseq << n unless nseq.include? ' '\n    n = n-1\n  end\n  nseq\n\
    end", "  string_sequence = @string_sequence ||= []\n  string_sequence << (n %\
    \ 10 == 0 ? \"0\" : nil)\n  string_sequence.call(n/10)\nend", "  n.to_s + ' '\
    \ + (1..n).map { |i| i.to_s }\nend", "  numbers = (0...n).to_a.join\n  numbers[0,n-1]\n\
    end", "  return n.to_s(0).reverse\nend", "  result = \"\"\n  for i in 0..n\n \
    \   result += i + \" \"\n  end\n  return result.chop\nend", "  s = \"\"\n  for\
    \ i in 0...n\n    s << i\n  end\n  s\nend\n</cell>\n<cell>", "  if n <= 0\n  \
    \  \"0\"\n  else\n    \"#{string_sequence(n - 1)} #{n}\"\n  end\nend\n</code>\n\
    Now you can do this\n<code>\nputs string_sequence(5)\n</code>\n<|/ a |>\n<| c\
    \ |>\nThis code isn't actually recursive.  Your solution just uses Ruby's `*`\
    \ operator to call itself recursively.\n<|/ c |>\n<| c |>\nNo, its not recursive,\
    \ its a tail recursive solution. Hence it uses `*`, not `#`.\n<|/ c |>\n<| c |>\n\
    , your solution isn't really tail recursive, you're calling a method inside itself\
    \ and returning a string, which isn't the same thing.\n<|/ c |>\n<| c |>\n, you're\
    \ right, it should be `*` instead of `#`, fixed it.\n<|/ c |>\n<| a tags=ruby,loops\
    \ |>\n<code>", "  # Make a string containing space-delimited numbers starting\
    \ from 0 upto n inclusive.\n  # >>> string_sequence.call(0)\n  # \"0\"\n  # >>>\
    \ string_sequence.call(5)\n  # \"0 1 2 3 4 5\"\n  return \"#{n}\".split(\" \"\
    ).map { |i| i.to_i }.join(\", \")\nend", "  return n.to_s.split(\" \").collect\
    \ do |x|\n    x.to_i\n  end.join(\" \")\nend", "  a = []\n  (1..n).each { a <<\
    \ '0' }\n  a.join(' ')\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nHere's\
    \ another Ruby solution, that uses recursion and yields a string, instead of an\
    \ array.\n<code>", "  return \"0 1 2 3 4 5\" if n==0 else\n    \"#{string_sequence.call(n-1)}\
    \ #{n.to_s} #{string_sequence.call(n-1)}\"\nend", "  # Write your code here.\n\
    \  return \"\".*(1..n).map { |i| i.to_s }.join(' ')\nend", "  # Create a string.\n\
    \  s = \"\"\n  # Loop for n times.\n  while n > 0\n    # Append the current number\
    \ to the string.\n    s << n\n    # Decrement the counter.\n    n = n - 1\n  end\n\
    \  # Return the string.\n  s\nend", "  \"<#(:string_sequence/n)>\"\nend", "  s\
    \ = \"\"\n  for i in 0..n\n    s += \"#{n} \"\n  end\n  s\nend", "  n\n  n.to_s.length\n\
    \  n.to_s.split(\" \").map { |x| x.to_i }.map { |x| x.to_s }.join \" \"\nend",
  "  n.to_s.split(\" \").map {|s| s.to_i}.reverse.join\nend", "  puts \"0\"\n  (1..n).each\
    \ do |i|\n    puts \" #{i}\"\n  end\n  puts\nend\n</pre>\n</div>\n</div>\n<div\
    \ class=\"section\" id=\"multiple-method-calls\">\n<h2>Multiple Method Calls<a\
    \ class=\"headerlink\" href=\"#multiple-method-calls\" title=\"Permalink to this\
    \ headline\">\xB6</a></h2>\n<p>If more than one method is defined, Ruby will call\
    \ these methods in the order that they are defined.  Thus it is possible to change\
    \ the output order of the methods by defining the methods in the order that they\
    \ should be called.</p>\n<p>To control the order in which these methods are called,\
    \ define an alias for the method and then call the alias after defining the other\
    \ methods.  To illustrate, consider the example below where we define one method\
    \ and then call the other using an alias.</p>\n<div class=\"highlight-ruby notranslate\"\
    ><div class=\"highlight\"><pre><span></span><span class=\"nb\">define_method</span><span\
    \ class=\"p\">(</span><span class=\"s2\">&quot;first&quot;</span><span class=\"\
    p\">)</span> <span class=\"p\">{</span> <span class=\"nb\">puts</span> <span class=\"\
    s2\">&quot;first&quot;</span> <span class=\"p\">}</span>\n<span class=\"nb\">define_method</span><span\
    \ class=\"p\">(</span><span class=\"s2\">&quot;second&quot;</span><span class=\"\
    p\">)</span> <span class=\"p\">{</span> <span class=\"nb\">puts</span> <span class=\"\
    s2\">&quot;second&quot;</span> <span class=\"p\">}</span>", "  result = []\n \
    \ result.push(0)\n  for i in (2..n)\n    result.push(\"#{i} \")\n  end\n  result.join\n\
    end\n</code>\nHere's an example of using that to create your desired output:\n\
    <code>\np string_sequence(10)", "  \"\"+n\nend\n</code>\n<|/ a dscore=2 tags=ruby\
    \ |>\n<| c |>\nIf you don't want a space at the end of the string, just use `string_sequence(n).chomp`.\n\
    <|/ c |>\n<| a tags=ruby |>\n<code>", "  result = \"\"\n  for i in 0..n do\n \
    \   result += i.to_s + \" \"\n  end\n  result[0..(n - 1)] # to remove extra space\
    \ at end\nend\n</cell>\n<cell>", "  result = \"\"\n  for i in 0..(n)\n    result\
    \ << i\n  result\nend", "  \"#{n}\"\nend", "  return \"0 1 2 3 4 #{n}\"\nend",
  "  n = n.to_i\n  if n == 0\n    \"0\"\n  elsif n > 0\n    string_sequence(n - 1).split(\"\
    \ \").map { |s| s.to_s + \" \" + ((n > 0) ? \"... #{n}\" : \"\") }.join(\" \"\
    )\n  else\n    []\n  end\nend", "  a = []\n  while n > 0\n    a << n\n    n -=\
    \ 1\n  a.join(' ')\nend", "  strings = []\n  string.each {|i| strings << i.to_s(n)\
    \ }\n  strings.join(\" \")\nend", "  number_list = (0..n).map { |x| x.to_s }\n\
    \  number_list.join(\" \")\nend", "    number_list = \"\"\n    while n != 0\n\
    \        number_list += n.to_s\n        n -= 1\n    number_list\nend", "  result\
    \ = []\n  result.append(0)\n  until result.size < n do\n    result.unshift(rand(result.size\
    \ - 1))\n  end\n  result\nend", "  return n.to_s.split(' ').join(' ' + \"#{n}\
    \ \").gsub(/ \\d+$/, '') + \"#{n}\"\nend", '  "#(0 1 2 3 4 5 6 7 8 9 10 11 12
    13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38
    39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64
    65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90
    91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112
    113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132
    133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152
    153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172
    173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192
    193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212
    213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232
    233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252
    253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272
    273 274 275 276 277 278 279 280', "  return \"0\" * (n - 1) + \"1 2 3 4 5\"\n\
    end", "  numbers = (0...n).collect{|n| n.to_s}\n  numbers.join(\" \")\nend", " \
    \ return n.to_s.split(\" \").join(\"0\")+\" \"\nend\n</cell>\n<text>\nExercise\
    \ 2: String-sequence\nWrite a function that returns a string containing space-delimited\
    \ numbers starting from n upto n inclusive.", "\tstring = \"\"\n\tfor i in 0 ..<\
    \ n\n\t\tstring += string[i]\n\tend\n\treturn string\nend", "  number_string =\
    \ \"\"\n  for i in 1...n\n    number_string << number_string.length.call(i)\n\
    \    number_string << \" \"\n  end\n  number_string\nend", "    sequence = StringBuilder.new()\n\
    \    sequence.write n, :string\n    sequence.to_s\nend", "  spaces = \" \" * (n\
    \ - 1)\n  numbers = (0...n).to_a\n  numbers.join(spaces)\nend\n</code>\n<|/ a\
    \ dscore=2 |>\n<| a dscore=2 |>\nI wrote a ruby extension to do it for me in one\
    \ shot:\n<code>", "  result = []\n  i = n\n  while i\n    result.push(i)\n   \
    \ i -= 1\n  end\n  result.reverse\n  result.join(' ')\nend", "  (0...n).map {|i|\
    \ i.to_s}.join(\" \")\nend", "  seq = n.to_s.split(\" \")\n  seq.empty? ? seq.push(0)\
    \ : seq\nend", "  \"#{0..(n-1).to_a}\"\nend", "  number_string = n.to_s(0).split('').map\
    \ { |n| n.to_s(10) }.join(' ')\n  number_string.gsub(' ') do |n|\n    case\n \
    \   when n =~ /([0-9]{3})/\n      \"#{$1.to_i}:\"\n    when n =~ /([0-9]{2})/\n\
    \      \"#{$1.to_i}:\"\n    else\n      n\n    end\n  end\nend\n</code>\n<|/ a\
    \ tags=ruby-on-rails,ruby |>\n<| a tags=ruby-on-rails,ruby |>\nI agree that regular\
    \ expressions are the way to go in this situation, but since I'm already using\
    \ a gem to do this, I figured I should share the solution that I went with that\
    \ solved the issue that I had. I don't know how this will work in the context\
    \ of Rails, but I did it in pure Ruby.\nI decided to try implementing the solution\
    \ offered by in the comments. I implemented his solution and found that his solution\
    \ did not work. Here was my code:\n<code>", "  result = ''\n  while n > 0\n  \
    \  result << (n - 1) << ' '\n    n -= 1\n  end\n  result\nend", "  result = ''\n\
    \  for i in 0..n-1\n    result << \" #{i}\"\n  end\n  result << \" #{i}\"\n  result\n\
    end", "  return n.times.map{ |i| i.to_s.rjust(max_length, \"0\") }.join(' ')\n\
    end", "  result = ''\n  i =1\n  while i <= n\n    result << ' '\n    result <<\
    \ i\n    i += 1\n  result\nend", "  n = [n].pack('U*')\n  result = ''\n  for i\
    \ in 0...n[0]\n    result << \"#{i} \"\n  end\n  result << n[0]\n  result\nend",
  "  return n.to_s.split(\" \").collect{|i| i.to_i }.join(\" \")\nend", "  # Define\
    \ an empty sequence. \n  sequence = \"\"\n  # Return a lambda function to be executed\
    \ in the for loop below.\n  return lambda num: sequence + (num if num == n else\
    \ \" \" + str(num))", "  # If n is negative or positive, return empty string.\
    \ \n  if n.nil?\n    \"\"\n  elsif n < 0\n    \"negative number of strings starting\
    \ from 0 upto #{n}\"\n  elsif n.zero?\n    \"empty string from 0 to #{n}\"\n \
    \ else\n    seq = \"\"\n    while n > 0\n      seq << n\n      n -= 1\n    end\n\
    \    return seq\n  end\nend\n</code>\nThe solution:\n<code>", "  i = n ? n : 1\n\
    \  s = \"0\"\n  while i < 0 do\n    i = i + 1\n    s = s.succ\n  end\n  return\
    \ s\nend", "  a = 0\n  str = \" \"\n  while a < n\n    str << \" #{a}\"\n    a\
    \ = a + 1\n  end\n  str\nend", "  result = \"\"\n  i =  0\n  while i < n\n   \
    \ result = result + (\"#{i}  \" * (n-1-i))\n    i += 1\n  result\nend", "  \"\
    0\"\n  \"0 1 2 3 4 5\"\nend", "  return \"#{n} #{string_sequence(n+1)}\"\nend",
  "  result = \"\"\n  (0..n).each do |i|\n    result = result + \" \" + to_string(i)\n\
    \  end\n  result\nend", "  i = 0\n  output = \"\"\n  while i < n do\n    output\
    \ = output + \" \" + call(i)\n    i += 1\n  end\n  return output\nend", "  return\
    \ n.to_s.split(\" \").join(0).upto(n).to_s\nend", "  result = []\n  loop do\n\
    \    result.push \"#{n}\"\n    n += 1\n    break if n <= 0\n  end\n  result.join('\
    \ ')\nend\n</cell>\n<cell>", "  result = ''\n  result = result + \"0\"\n  n.downto(0).each\
    \ do |i|\n    result = result + \" \" + i.to_s\n  end\n  return result\nend",
  "  n0 = nil\n  a = [0]\n  \n  while n != 0\n    n -= 1\n    a << n0\n    n0 = n\
    \ + a[-1]\n  end\n  \n  a.join(\", \")\nend", "  s = \"\"\n  while n > 0\n   \
    \ s = s.to_s + n.to_s\n    n -= 1\n  end\n  s\nend\n</pre>\n      </td>\n    </tr>\n\
    \    <tr>\n      <td class='doc-right'>\n        <pre class=\"doc-example\">",
  "  # Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n\
    \  # >>> string_sequence.call(0)\n  # \"0\"\n  # >>> string_sequence.call(5)\n\
    \  # \"0 1 2 3 4 5\"\n  return \"#{n}\"\nend", "  \"${#n}\"\nend", "  # Return\
    \ the string \"0 1 2 3 4 5\" starting from 0 to n-1.\n  return \"0 \"*n\nend\n\
    </pre>", "  result = \"\"\n  for i in 0...n\n    result += \" \" + i.to_s\n  end\n\
    \  result\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
