name: HumanEval_80_is_happy
language: rb
prompt: "# You are given a string s.\n# Your task is to check if the string is haprb\
  \ or not.\n# A string is haprb if its length is at least 3 and every 3 consecutive\
  \ letters are distinct\n# For example:\n# >>> is_happy.call(a)\n# false\n# >>> is_happy.call(aa)\n\
  # false\n# >>> is_happy.call(abcd)\n# true\n# >>> is_happy.call(aabb)\n# false\n\
  # >>> is_happy.call(adb)\n# true\n# >>> is_happy.call(xyy)\n# false\ndef is_happy(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_happy\n\
  \    candidate = method(:is_happy)\n    assert_equal(false, candidate.call(\"a\"\
  ))\n    assert_equal(false, candidate.call(\"aa\"))\n    assert_equal(true, candidate.call(\"\
  abcd\"))\n    assert_equal(false, candidate.call(\"aabb\"))\n    assert_equal(true,\
  \ candidate.call(\"adb\"))\n    assert_equal(false, candidate.call(\"xyy\"))\n \
  \   assert_equal(true, candidate.call(\"iopaxpoi\"))\n    assert_equal(false, candidate.call(\"\
  iopaxioi\"))\n  end\nend\n"
completions: ["  s.chars.each_cons(3).all? { |a,b| a != b }\nend\n</code>\n<|/ a tags=ruby,string,regex\
    \ dscore=0 |>\n<| c |>\nI don't think this is a good answer, because I don't believe\
    \ it can be done as a single regex. He said \"using Regexp\" and not \"using Regexp*\"\
    .\n<|/ c |>\n<| c |>\n, can you elaborate why you think this isn't a good answer?\n\
    <|/ c |>\n<| c |>\n, I just read that part in the question, too. It doesn't say\
    \ whether a regexp would be acceptable, or why not.\n<|/ c |>\n<| c |>\nHe said\
    \ \"using Regexp\". Regex is probably the worst tool to use for a single problem.\
    \ The problem requires you to find the same consecutive characters in the string.\
    \ Regex is great for finding patterns in a string. For example, if the input was\
    \ \"abbcccddeeeef\" you might use a regexp like `(..)(..)(..)(..)(..)(..)` to\
    \ find all \"triples\" of \"a\"s. In this case, `$1`, `$2`, `$3`, `$4`, `$5`,\
    \ and `$6` are all \"a\"s, because they all match the same pattern.\n<|/ c |>\n\
    <| c |>\nThat being said, my answer was \"use Regexp\", not \"use Regexp*\". I\
    \ don't think it warrants being down-voted, though it's not a big deal either.\n\
    <|/ c |>\n<| a tags=ruby,string,regex |>\nThis is an alternative that uses less\
    \ memory, and is more readable (at least to me):\n<code>", "\treturn s.length\
    \ >= 3 && Array.new(3, s.chars.to_a).combination(3).none?{|i,j,k| j == k}\nend",
  "    s.length >= 3 and s.chars.each_cons(3).all? { |c| c.uniq.length == 1 }\nend\n\
    </code>\n<|/ a |>\n<| c |>\nThanks, that helps a lot! I didn't realize that each_cons\
    \ works like that.\n<|/ c |>\n<| a |>\nThis is another implementation:\n<code>",
  "  return s.length >= 3 && s.chars.all? { |x| x.to_i != x.to_i }.nil?\nend", " \
    \ \n  # Write your code here\n  \n  s = s.split(\"\")\n  s.each_with_index do\
    \ |item, index|\n    return false if index == 3 || s.include?(item)\n  end\n \
    \ return true\nend", "  # initialize to empty string and check string length\n\
    \  str_arr = []\n  str_arr.push(s)\n  str_length = s.length", "  happy = s.count\
    \ > 3 && s.chars.all? {|c| Hash[c]}\n  return false if happy.nil?\n  return happy\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby |>\n<code>", "    s = s.to_s\n\
    \    lens = s.count\n    (count) = lens\n    (lenght) = lens\n    return lens\
    \ >= 3 && (count - 3) == lenght && all(a.length == count-3 for a in s)\nend",
  "    count = 0\n    for i in s.chars\n        if i == i\n            count += 1\n\
    \        else\n            break\n    return count == 3 and s.chars.uniq.length\
    \ >= 3\nend", "  s.chars.uniq.count == s.length >= 3 && s.length % 3 == 0\nend",
  "  s.length >= 3 && (s.chars.uniq.length % 3 == 0)\nend\n</code>\n<|/ a |>\n<| a\
    \ tags=ruby,string |>\nI would do it this way:\n<code>", "  len = s.length\n \
    \ if len < 3 return false\n  s.chars.each_with_index do |letter, index|\n    if\
    \ index == 0 then return false end\n    if letter.ascii_code == s.chars[index\
    \ - 1].ascii_code then return false end\n  end\n  return true\nend", "    s.length\
    \ >= 3 \n    return s.chars.all?{|c| c.upcase != c }\nend", "  s.split('').all?{|e|\
    \ e =~ /\\w\\w\\w/}.size == 3 && s.split('').uniq.length >= 3\nend", "  s=s(s.downcase).chars\n\
    \  return s.length >= 3 && (s[0]==s[1] && s[1]==s[2] || s[2]==s[1] && s[1]==s[2]\
    \ || s[0]==s[2] && s[1]==s[2])\nend", "  s.length >= 3 && (s.chars.chunk{ |c|\
    \ c.to_i == c }.size == s.size - 3)\nend", "  happy = s.gsub(/./).length >= 3\
    \ and (s.gsub(/./).length - 1) % 3 == 0\n  puts happy if happy\nend\n</code>\n\
    <|/ a |>\n<| a |>\nThis solution is for Ruby 1.9 or later\n<code>", "  if s.length\
    \ < 3 || s.count(s) == 0\n    puts \"false\"\n    return false\n  else\n    puts\
    \ \"true\"\n    return true\n  end\nend", "  s.size >= 3 && s.chars.combination(3).none?\
    \ { |x| x.to_s.chars.uniq.size == 1 }\nend\n</code>\n<|/ a |>\n<| c |>\nIt would\
    \ be better to define is_happy.call using a lambda instead, especially since you\
    \ are only calling it once anyway.\n<|/ c |>\n<| c |>\nI don't think lambda would\
    \ make any difference here, but you're right in general. I'll update the answer.\n\
    <|/ c |>\n<| c |>\nThis looks like the best way for me, since I do not know Ruby,\
    \ but I am having some problems getting it to work. Could you please show how\
    \ I might use this with a string in my code? I'm guessing something like `s =\
    \ String` but I'm not sure how to go about it correctly. Thanks!\n<|/ c |>\n<|\
    \ c |>\nI have edited my answer to show how I would do it. You can find more information\
    \ on String literals [here](http://www.tutorialspoint.com/ruby/ruby_strings.htm).\n\
    <|/ c |>\n<| c |>\nthanks, I appreciate it! I'm just not understanding how to\
    \ get this into my code now. I think I've been working on this too much to wrap\
    \ my head around. Could you please explain how to integrate this into my code?\
    \ The only way I can get it to work is with using `is_happy.call('a')` which returns\
    \ false, but I need it to work when I enter a string into `is_happy()`. Thanks!\n\
    <|/ c |>\n<| a tags=ruby |>\n<code>", "  return s.length >= 3 and (s.chars.uniq.count\
    \ >= 3)\nend", "  s.length >= 3 and s.chars.each.with_index.any? {|c, i| c.to_i\
    \ == i+1}\nend", "  return s.length >= 3 and (s.chars - s.chars.uniq.sort_by(&:chr).map(&:chr).map(&:length).max\
    \ <= 3)\nend\n</code>\n<|/ a tags=string,ruby |>\n<| a tags=string,ruby |>\nYou\
    \ can use Array#repeated_permutation\n<code>", "\treturn is_happy.call( len(s)==3\
    \ and (s[0..2]==s[2..4] and s[2..4]==s[4..6] and s[4..6]==s[6..8] and s[6..8]==s[8..10]\
    \ and s[8..10]==s[10..12] and s[10..12]==s[12..14] ))\nend", "  s = s[0]\n  return\
    \ s == s[0..1] && s == s[1..2] && s == s[2..3] && s == s[0..2] && s == s[0..1]\
    \ && s == s[1..3] && s == s[1..2] && s == s[2..3]\nend\n</code>\n<|/ a tags=ruby\
    \ dscore=3 |>\n<| c |>\n\"Your task is to check if its length is at least 3\"\
    \ is ambiguous. Do you mean to check if the string contains at least 3 characters?\
    \ That would be `s.count >= 3`.\n<|/ c |>\n<| c |>\nYeah. My bad! Thanks for pointing\
    \ that out.\n<|/ c |>\n<| a dscore=2 |>\nRuby 2.2 solution:\n<code>", "  s.gsub!(/[^a-z]/,\
    \ '')\n  s.gsub!(/[^a-z]/i, '')\n  s.gsub!(/[^a-z]/i, '') \n  s.gsub!(/[^a-z]/i,\
    \ '') \n  s.gsub!(/[^a-z]/i, '')\n  s.gsub!(/[^a-z]/i, '')\n  s.gsub!(/[^a-z]/i,\
    \ '') \n  s.gsub!(/[^a-z]/i, '') \n  s.gsub!(/[^a-z]/i, '')\n  s.gsub!(/[^a-z]/i,\
    \ '')\n  s.gsub!(/[^a-z]/i, '') \n  s.gsub!(/[^a-z]/i, '')\n  s.gsub!(/[^a-z]/i,\
    \ '') \n  s.gsub!(/[^a-z]/i, '') \n  s.gsub!(/[^a-z]/i, '') \n  s.gsub!(/[^a-z]/i,\
    \ '')\n  s.gsub!(/[^a-z]/i, '') \n  s.gsub!(/[^a-z]/i, '') \n  s.gsub!(/[^a-z]/i,\
    \ '') \n  s.gsub!(/[^a-z]/i, '') \n  s.gsub!(/[^a-z]/i, '')\n  s.gsub!(/[^a-z]/i,\
    \ '') \n  s.gsub!(/[^a-z]/i, '') \n  s.gsub!(/[^a-z]/i, '')\n  s.gsub!(/[^a-z]/i,\
    \ '') \n  s.gsub!(/[^a-z]/i, '') \n  s.gsub!(/[^a-z]/i, '') \n  s.gsub!(/[^a-z]/i,\
    \ '') \n  s.gsub!(/[^a-z]/i, '') \n  s.gsub!(/[^a-z]/i, '') \n  s.gsub!(/[^a-z]/i,\
    \ '') \n  s.gsub!(/[^a-z]/i, '') \n  s.gsub!(/[^a-z]/i, '') \n  s.gsub!(/[^a-z]/i,\
    \ '') \n  s.gsub!(/[^a-z]/i, '') \n  s.gsub!(/[^a-z]/i, '') \n  s.gsub!(/[^a-z]/i,\
    \ '') \n  s.gsub!(/[^a-z]/i, '') \n  s.gsub!(/[^a-z]/i, '') \n  s.gsub!(/[^a-z]/i,\
    \ '') \n  s.g", "  a = [1, 2, 3]\n  return s.split(\"\").all? { |letter| a.include?(letter)\
    \ } and s.length >= 3\nend\n</code>\n<|/ a |>\n<| c |>\nA more \"Ruby\" approach:\
    \ `[1,2,3].all? { |n| s.split(\"\").all? { |c| n == c } and s.length >= 3 }`\n\
    <|/ c |>\n<| c |>\nVery clever! You could also simplify the conditional to `s.length\
    \ >= 3` and remove the `and`\n<|/ c |>\n<| c |>\nNice idea, but it won't work.\
    \ Try `is_happy.call(\"aaa\")`.\n<|/ c |>\n<| c |>\nI guess the idea is to find\
    \ out if the string is haprb when it's length >=3 and all the letters are different\n\
    <|/ c |>\n<| a tags=ruby,loops |>\nI think this is more elegant, using Enumerable#group_by\n\
    <code>", "    return s.length >= 3 && s.chars.all?{|c| (c+1) == c}.all?{|i| i\
    \ % 3 == 0}\nend\n</code>\n<|/ a |>\n<| c |>\nNice use of `Enumerable#all?` here.\n\
    <|/ c |>\n<| a dscore=3 |>\nOne way to achieve this in Ruby is to convert each\
    \ character to a number and sort them. You could then use Enumerable#each_cons\
    \ to get the consecutive pairs and then check if each pair is unique.\n<code>",
  "\ts_length = s.length\n\ts_chars = s.chars\n\thappy = 0\n\tfor i in range(0, s_length)\
    \ if s_length >= 3 then\n\t\tfor j in range(0, s_length-i) do\n\t\t\tif s_chars[j]\
    \ == s_chars[j+1] and s_chars[j] == s_chars[j+2] then\n\t\t\t\thappy = happy +\
    \ 1\n\t\t\t\tbreak\n\t\tend\n\tend\n\tif happy == s_length then\n\t\treturn true\n\
    \telse\n\t\treturn false\n\tend\nend", "  if s.nil?\n    return false\n  else\n\
    \    \n    #Write your code here\n  end \nend", "  return s.length >= 3 &&\n \
    \ s.chars.with_index.with_object([]).inject(:&).all? { |char,hash| !hash.include?(char)\
    \ }\nend\n</code>\n<|/ a |>\n<| c |>\nNice one with inject :-)\n<|/ c |>\n<| c\
    \ |>\nThat's what I needed! :) Thank you!\n<|/ c |>\n<| a dscore=1 tags=ruby |>\n\
    <code>", "  return s.size > 3 && s.chars().each_cons(3).all? { |a, b| !a.eql?(b)\
    \ }\nend", "  s = s.split('')\n  if(s.length < 3) then\n    return false\n  end",
  "    counts = Hash.new(0)\n    s.chars.each.with_index(1) do |char, index|\n   \
    \     counts[char] += index\n    end\n    counts.values.all?(&:zero?)\nend", " \
    \ s.length >= 3 && s[0..3].each_char.uniq.length == 3\nend", "  s.size >= 3 &&\
    \ s.chars.all?{|c| c != s[0-1]}\nend", "  return s.length >= 3 and s.split('').all?\
    \ do |letter|\n    letter == letter.next\n  end\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| c |>\nWhy `s.split('').all? do |letter|`? Couldn't you simply write `s.chars.all?\
    \ {|c| c == c.next}`? Or, in Ruby 1.9.2+, `s.chars.all?(&:next)`. Also, you missed\
    \ the fact that `s.chars` creates a new array which is unneeded. `s.chars.all?\
    \ { |c| c == c.next }` should be sufficient.\n<|/ c |>\n<| c |>\nAlso, `letter\
    \ == letter.next` isn't a great way to compare characters. `letter == letter.next`\
    \ is essentially the same as `letter == (letter + \"\").next`, which just doesn't\
    \ work. Instead, use `letter == (letter + \"\").next`.\n<|/ c |>\n<| c |>\n: I\
    \ forgot about `next` returning nil.  I agree with you, however, that using `chars`\
    \ rather than `split` is more efficient.\n<|/ c |>\n<| c |>\n`chars` is definitely\
    \ more efficient, thanks for pointing that out! However, the problem with this\
    \ method is that it still isn't efficient. I need to find a way to do the same\
    \ thing without using loops, which is why I thought a solution using `split` would\
    \ be better.\n<|/ c |>\n<| c |>\n: Your original method was clearly wrong. Replacing\
    \ it with that method would be the easiest fix, and if that's not an option, my\
    \ first solution is actually the best option (as far as efficiency is concerned).\n\
    <|/ c |>\n<| a dscore=1 |>\nI thought of a way to do it. It doesn't use String#each\
    \ or #each_index\n<code>", "    count = 0\n    str.split(s).each do |letter|\n\
    \        if letter == \"a\"\n            count += 1\n        else\n          \
    \  count = 0\n        end\n    end\n    count\nend\n</code>\nBut we can refactor\
    \ it to something like this:\n<code>", "  return s.length >= 3 && s.chars.each_cons(3).all?{|a|\
    \ a.uniq.size == 1 }\nend", "    count = 0\n    letters = [\"a\", \"b\", \"c\"\
    , \"d\"]\n    unique_letters = letters.to_a\n    \n    return s.size > 3 and letters.all?\
    \ { |x| s.count(x) } and letters.all? { |x| s.count(x).even? } and letters.all?\
    \ { |x| s.count(x).odd? }\nend", "  strlen = s.length\n  return (strlen > 3) &&\
    \ all( s.chars.combination(3).none? {|c| (c[0] == c[1] && c[1] == c[2])} )\nend\n\
    </code>\n<|/ a dscore=0 tags=ruby,regex |>\n<| c |>\nI'm really new to Ruby, how\
    \ would I implement this into my code?\n<|/ c |>\n<| c |>\n, I would love to give\
    \ you a hint, but I'm really not sure where to start.  You would have to go through\
    \ each of those examples, figure out what they are doing, try to implement them,\
    \ and if you run into any problems, post back here with what you've tried and\
    \ where you are stuck.  There are many Ruby tutorials and books available online\
    \ that explain how to use regular expressions and how to test strings for validity.\n\
    <|/ c |>\n<| c |>\nAlso, be sure to read the documentation for [`String#match`](https://ruby-doc.org/core-2.4.1/String.html#method-i-match)\
    \ carefully, and familiarize yourself with the [Regular Expressions documentation](http://ruby-doc.org/core-2.4.1/Regexp.html).\n\
    <|/ c |>\n<| a tags=ruby,regex |>\nHow about something simple like:\n<code>",
  "    s.length >= 3 and s.chars.map{|c| c.ord}.uniq.size == s.chars.length\nend",
  "  \n  if s.length < 3\n    return false\n  end", "    l = s.length\n    count =\
    \ Array.new(3)\n    count[0] = s.count(\"a\")\n    count[1] = s.count(\"b\")\n\
    \    count[2] = s.count(\"c\")\n    if l<3 or l.modulo(3) != 0 then\n        return\
    \ false\n    \n    for i in 0...2 do\n        if count[i] > 1 then\n         \
    \   return false\n    end\n    \n    return true\nend", "  return s.split('').all?\
    \ {|c| s.count(\"c\") == 3 && s.count(c) == 1}\nend", "  return s.size >= 3 and\
    \ !s.chars.uniq.any? { |c| c.to_sym == :x}\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nThis seems too simple, isn't it? :)\n<|/ c |>\n<| a |>\nHere is a simple\
    \ solution in Ruby\n<code>", "  check_hap_str = false\n  if s.size < 3\n    check_hap_str\
    \ = true\n  elsif s.size >= 3\n    for i in 0...s.size\n      if s[i] == s[i+2]\
    \ == s[i+4]\n        check_hap_str = true\n      end\n    end\n  end\n  return\
    \ check_hap_str\nend", "  return s.length >= 3 && s.chars.combination(3).any?{|a,\
    \ b| a != b}\nend", "  if s.length < 3 then return false\n  for c in s\n    if\
    \ c.charcode == '9'.charcode then return false\n  end\n  return true\nend\n</cell>\n\
    <text>\nChallenge 12\nThe next challenge is checking if a given string is palindrome\
    \ or not.\nThe palindrome is a string which is read the same backward or forward.\n\
    For example, the word \"antarctica\" is palindrome.\n\"racecar\" is a palindrome\
    \ too.\n\"civic\" is another palindrome.\n\"cavs\" is not palindrome.\n\"narcotics\"\
    \ is not a palindrome too.", "  s.to_s.length >= 3 and (s.chars.sort.map{|s| s.chr}.uniq.length\
    \ == 3 )\nend", "  s.length >= 3 && (s.chars.to_a.uniq.length == 3).all? {|x|\
    \ x != s.chars.to_a.uniq}\nend", "    count = 0\n    s.each_char do |c|\n    \
    \    if s.index(c) == 0 and s.index(c-1) == 1 and s.index(c-2) == 2\n        \
    \    count = count + 1\n        else\n            count = 0\n        end\n   \
    \ end\n    return count >= 3\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,string\
    \ |>\n<code>", "    a.size>= 3 && a.chars.distinct.each_slice(3).any? { |slice|\n\
    \        s[0...(slice.length-1)].sort == s[(slice.length-1)...-1].sort \n    }\n\
    end", "  is_happy.called = is_happy.called + 1\n  return s.length >= 3 && s.gsub(/./)\
    \ { |c| c.downcase }.uniq.size >= 3\nend", "  is_happy.result ||= s.chars.any?\
    \ do |char|\n    s.count(char) == 3\n  end\nend", "  return s.nil? or s.length\
    \ >= 3 and s.chars.all? {|c| c.kind_of? String and c.length == 3} and s.chars.combination(3).all?\
    \ {|a, b| a != b} and s.chars.combination(3).all? {|a, b| a == b}\nend\n</code>\n\
    <|/ a dscore=0 tags=ruby,string,boolean |>\n<| a tags=ruby,string,boolean |>\n\
    <code>", "  s.scan(/\\w/).all? { |c| c.size == 3 } && s.scan(/\\w+/).all? { |s|\
    \ s.size == 3 }\nend\n</code>\n<|/ a |>\n<| c |>\nWhile this doesn't answer the\
    \ question exactly, it does demonstrate that the question isn't asking for *a\
    \ pure Ruby solution*, but rather a *solution with no Ruby code* - which would\
    \ allow for other languages than the Ruby language being used.\n<|/ c |>\n<| c\
    \ |>\nYes, it's pure Ruby, it uses `scan` and `all?`\n<|/ c |>\n<| c |>\nYeah,\
    \ I wasn't thinking Ruby was a particularly important detail - just that he could\
    \ solve it without *any Ruby code* - which means it could be used in other languages.\n\
    <|/ c |>\n<| c |>\nI like this solution best - it uses no Ruby code at all, and\
    \ just pure Ruby.\n<|/ c |>\n<| c |>\nI like this, because it's easier to read,\
    \ and it works for strings with more than 3 characters too. I would just change\
    \ `3 <=.length <= 8` to `3 <= s.length <= 8` to allow strings with 8 characters.\n\
    <|/ c |>\n<| a |>\n<code>", "  return s.length >= 3 && !s.scan(/(a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z)/).any?{|s|\
    \ s.include?(s.next) }\nend\n</code>\nThe above method will return true only if\
    \ the string is happy.\n<|/ a dscore=1 |>\n<| a tags=ruby,string |>\n<code>",
  "  s.length >= 3 and s.chars.group_by{|c| c}.all?{|_, v| v.size == v.size}.nil?\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a |>\nUsing Enumerable#each_cons, which accepts\
    \ a block we can achieve the desired result:\n<code>", "  return s.count(s) ==\
    \ s.length and s.count { |x| not x.succ? } > 3 \nend", "  # Your code here\n \
    \ count = 0\n  for i in s.chars\n    if i.to_s.size == 3\n      a = i.to_s.chars\n\
    \      a.each do |x|\n        if a.count(x) == 3\n          count += 1\n     \
    \   else\n          count = 0\n        end\n      end\n      if count == 3\n \
    \       true\n      else\n        false\n      end\n    end\n  end\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nI don't think you understand the question. He wants\
    \ to know if his string has at least 3 distinct letters, not just 3 consecutive\
    \ letters.\n<|/ c |>\n<| c |>\nYes, I do, I forgot that distinction, but now I\
    \ realize.\n<|/ c |>\n<| c |>\nAh, now I see that distinction, sorry for the misunderstanding.\n\
    <|/ c |>\n<| a tags=ruby,ruby-on-rails dscore=0 |>\n<code>", "  s = s[0..-2]\n\
    \  return s.length >= 3 and s.chars.uniq.all? {|i| i <=> i}\nend\n</code>\n<|/\
    \ a dscore=4 tags=ruby,regex |>\n<| a tags=ruby,regex dscore=3 |>\n<code>\n^[a-z]*$\n\
    </code>\nThis regex will match any string with zero or more lowercase letters.\
    \ \nEdit: To match three consecutive letters, use\n<code>\n^[a-z]{3}$\n</code>\n\
    <|/ a |>\n<| c |>\nThis matches `aaa` as well.\n<|/ c |>\n<| c |>\nYes, it does.\
    \ But OP never said it should have to, so I didn't bother with it.\n<|/ c |>\n\
    <| c |>\nYes. I guess it could have been made clearer in the question, but OP\
    \ never made it clearer either.\n<|/ c |>\n<| c |>\nYes, it is. I didn't think\
    \ of that either.\n<|/ c |>\n<| a |>\nOne option is to use negative lookahead:\n\
    <code>\n^(?=(?:a{3})*$)[a-z]*$\n</code>\nDemo\nIn Ruby this can be written as:\n\
    <code>\n/^(?!(?:a{3})*$)[a-z]*$/\n</code>\nAnd it does the same.\n<|/ a tags=ruby,regex\
    \ dscore=2 |>\n<| c |>\nThis matches `aaa` as well.\n<|/ c |>\n<| c |>\nYes, it\
    \ does. But OP never said it should have to, so I didn't bother with it.\n<|/\
    \ c |>\n<| c |>\nYes, it could. But not with a simple alternation, that is.\n\
    <|/ c |>\n<| c |>\nYou're right it matches the `aaa` case, but `(?=(?:a{3})*$)`\
    \ doesn't match that case. [Here is a demo](https://regex101.com/r/7QKlVV/1).\n\
    <|/ c |>\n<| c |>\nYou're right. Now it does. [Demo](https://regex101.com/r/7QKlVV/2)\n\
    <|/ c |>\n<| a tags=ruby,regex |>\nYou can use this regex:\n<code>\n^[a-z]+$\n\
    </code>\nWorking Demo\nIf you want to match 3 consecutive characters you can use\
    \ this:\n<code>\n^[a-z]{3}$\n</code>\nWorking Demo\n<|/ a dscore=1 |>", "    return\
    \ s.length > 3 and s.chars.group_by{|c| c}.size > 3 && s.chars.group_by{|c| c}.all?\
    \ {|k, v| k == v}\nend\n</code>\n<|/ a tags=ruby,string,regex dscore=1 |>\n<|\
    \ a tags=ruby,string,regex |>\nHere's another way of doing it. It involves splitting\
    \ the string on whitespace (using String#split) and checking whether there are\
    \ 3 consecutive characters that are different from the original ones (using Enumerable#each_cons):\n\
    <code>", "  return s.length >= 3 &&\n    s[0...3].uniq.size == 3 &&\n    s[2...5].uniq.size\
    \ == 3\nend\n</cell>\n<code language=julia-1.5>\na = \"abc\"\nb = \"aabb\"\nc\
    \ = \"xyy\"\n</cell>\n<code language=julia-1.5>\nis_happy(a)\n</cell>\n<code language=julia-1.5>\n\
    is_happy(b)\n</cell>\n<code language=julia-1.5>\nis_happy(c)\n</cell>\n<text>\n\
    Write a function which checks if a given string s is palindrome or not.\nA palindrome\
    \ is a string that reads the same backward as forward. For example \"abcba\" and\
    \ a palindrome is \"cba\"", "  s.split('').map(&:to_i).all? { |n| n > 0 && n <\
    \ 26 }\nend", "    s = s.downcase\n    return s.length >= 3 &&\n        s[0, 3]\
    \ == s[1, 3] == s[2, 3]\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nHey thanks\
    \ for the answer!\nThe thing is, I dont know what to put in the place of \"abc\"\
    , as I dont know where it would be located. Also, I have no idea what \"downcase\"\
    \ means.\n<|/ c |>\n<| c |>\nOkay so my professor just gave me this problem and\
    \ he wants us to write this method in Ruby.\nI guess he made this up since he\
    \ didnt teach Ruby so much and im not that knowledgeable either. Do you know a\
    \ way of doing it in Ruby or can you show me how I can do it in Ruby with what\
    \ he gave me?\n<|/ c |>\n<| c |>\nYou can do it in Ruby. It will depend on how\
    \ you're reading your code. I will update my answer to show you how in Ruby.\n\
    <|/ c |>\n<| c |>\nHmm... I think I'm very confused on this. Can you please show\
    \ me how I can do it in Ruby? I've been trying to figure out how to do this for\
    \ about an hour now and I'm just not getting it\n<|/ c |>\n<| c |>\nThank you\
    \ so much for your help! I finally got it to work! :D I appreciate it so much!\n\
    <|/ c |>\n<| a tags=ruby |>\n<code>", "    length = 0\n    chars = []", "  s.count(\"\
    a\") == s.count(\"b\") && s.count(\"a\") == s.count(\"c\")\nend", "  s.split(\"\
    \").uniq.size >= 3 and s.split(\"\").each_index {|i| s[i] = s.split(\"\")[i -\
    \ 3] + s.split(\"\")[i - 2] + s.split(\"\")[i - 1]}\nend\n</code>\n<|/ a tags=ruby\
    \ dscore=2 |>\n<| a dscore=1 tags=ruby |>\nAs you pointed out, a regex is overkill\
    \ for this. Here's a straight Ruby solution that uses regular expressions and\
    \ should work in any Ruby implementation:\n<code>", "    if s.length < 3 or s.length\
    \ >= 6 then\n        return false\n    else\n        return true\n    end \nend\n\
    </code>\n<|/ a tags=lua |>\n<| a dscore=2 |>\nMy solution:\n<code>\n-- returns\
    \ true iff s is a happy happy happy string\n-- \n-- The length of a happy happy\
    \ happy string is at least 3, and every 3\n-- consecutive letter is different.",
  "  return s.length >= 3 and s.chars.group_by.all?(&:distinct?)\nend\n</cell>\n<code\
    \ language=julia-1.0>\n@test is_happy(\"aaabbbcccd\") # should return false\n\
    @test is_happy(\"a\") # should return true\n</cell>\n<text>\nWe have already implemented\
    \ a function that checks if a string is a palindrome:", "  s.each_char.all? do\
    \ |char|\n    char.all? { |e| e!=char.succ}.all? { |e| e != char.succ }.all? {\
    \ |e| e != char.succ==e }\n  end\nend", "  (0...s.length).all? { |i| (i + 1..s.length).all?\
    \ { |j| s[i] == s[j] } }\nend", "  str = s.split(\"\")\n  count = 0\n  for i in\
    \ str\n    count = 0 if count + 1 == str.length\n    count += 1 if i != str[count+1]\n\
    \  end\n  return false if count < 3\n  true\nend", "  s.each_char do |c|\n  (c\
    \ == \"a\" || c == \"e\" || c == \"i\" || c == \"o\" || c == \"u\") && return\
    \ false \n  (c == \"a\" || c == \"e\" || c == \"o\" || c == \"u\") && return false\
    \ \n  (c == \"b\" || c == \"e\" || c == \"i\" || c == \"o\" || c == \"u\") &&\
    \ return false \n  (c == \"b\" || c == \"e\" || c == \"o\" || c == \"u\") && return\
    \ false \n  (c == \"c\" || c == \"e\" || c == \"i\" || c == \"o\" || c == \"u\"\
    ) && return false \n  (c == \"c\" || c == \"e\" || c == \"o\" || c == \"u\") &&\
    \ return false \n  (c == \"d\" || c == \"e\" || c == \"i\" || c == \"o\" || c\
    \ == \"u\") && return false \n  (c == \"d\" || c == \"e\" || c == \"o\" || c ==\
    \ \"u\") && return false \n  (c == \"d\" || c == \"e\" || c == \"o\" || c == \"\
    u\") && return false \n  (c == \"d\" || c == \"e\" || c == \"o\" || c == \"u\"\
    ) && return false \n  (c == \"e\" || c == \"i\" || c == \"o\" || c == \"u\") &&\
    \ return false \n  (c == \"e\" || c == \"o\" || c == \"u\") && return false \n\
    \  (c == \"e\" || c == \"o\" || c == \"u\") && return false \n  (c == \"e\" ||\
    \ c == \"o\" || c == \"u\") && return false \n  (c == \"i\" || c == \"o\" || c\
    \ == \"u\") && return false \n  (c == \"i\" || c == \"o\" || c == \"u\") && return\
    \ false \n  (c == \"i\" || c == \"o\" || c == \"u\") && return false \n  (c ==\
    \ \"i\" || c == \"o\" || c == \"u\") && return false \n  (c == \"o\" || c == \"\
    u\") && return false \n  (c == \"o\" || c == \"u\") && return false \n  (c ==\
    \ \"o\" || c == \"u\") && return false \n  (c == \"o\" || c == \"u\") && return\
    \ false \n  (c == \"u\") && return false \n  (c == \"u\") && return false \n \
    \ (c == \"u\") && return false \n  (c == \"u\") && return false \n  end\n  true\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThat code does not work for the test\
    \ cases `'abc'` and `'abcda'`.  You need to use `each_char` instead of `chars`.\n\
    <|/ c |>\n<| c |>\nGood catch.  I edited my answer to reflect that.\n", "    len\
    \ = s.length\n    \n    true_count = 0\n    happy_count = 0\n    \n    if len\
    \ < 3 then\n        return false\n    end\n    \n    for i in 1..len\n       \
    \ if s[i] == s[i-1] then\n            true_count = true_count+1\n        else\n\
    \            true_count = 0\n        end\n        if true_count == 3 then\n  \
    \          happy_count = happy_count+1\n        end\n    end\n    if happy_count\
    \ != 3 then\n        return false\n    else\n        return true\n    end\nend\n\
    </cell>\n<code language=julia-0.6>", "    return s.length >= 3 && s.chars.each_cons(3).all?\
    \ {|arr| arr.uniq.length == 2}\nend", "    hash = {}\n    for i in s\n       \
    \ if hash[i] && hash[i] != i\n            return false\n        hash[i] = i\n\
    \    return true\nend", "  s.length >= 3 &&\n  s.chars.each_cons(3).map(&:first).uniq.all?\
    \ { |x| x == \"a\" || x == \"e\" || x == \"i\" || x == \"o\" || x == \"u\" }\n\
    end", "\treturn s.length >= 3 && (s.length % 3) == 0\nend", "    length_count\
    \ = 0\n    length_array = [0]\n    # go through each letter in string\n    for\
    \ letter in s\n        if letter != ' '\n            # check if letter not repeated\n\
    \            if length_array[length_count + 1] != letter\n                # if\
    \ not, add it to the array\n                length_array[length_count] = letter\n\
    \                length_count += 1\n            # check if length of array is\
    \ 3\n            if length_count < 3\n                return false\n         \
    \   # check if each letter from 0 to 2 is unique\n            for count in 0...2\n\
    \                if length_array[count] == letter\n                    return\
    \ false\n                # if not unique, return false\n    return true\nend",
  "  return s.length >= 3 and s.chars.distinct.all? {|s| s.empty?}\nend\n</code>\n\
    <|/ a tags=ruby dscore=3 |>\n<| c |>\nI think this is too complicated for such\
    \ a simple task. You don't need `each` here. `each` doesn't do anything useful\
    \ in your solution. It would have been better to use `each_with_index` in this\
    \ case\n<|/ c |>\n<| c |>\nThe OP wants to find out if the string is happy.\n\
    <|/ c |>\n<| c |>\nHe wrote in his question: \"The method should return false\
    \ for strings like aaaa, bbbb, cccc or dddd.\"\n<|/ c |>\n<| c |>\n: I agree.\
    \ I would have used `each_with_index`, but I wasn't sure if he wanted indexes\
    \ or just if an entire string was happy.\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ for **all** strings. If you have a string like `\"aaabbb\"` it returns true.\n\
    <|/ c |>\n<| a tags=ruby |>\n<code>", "  s = s.chars.uniq\n  return s.length >=\
    \ 3 and s.uniq.length >= (s.length / 3)\nend\n</cell>\n<cell>", "    count = 0\n\
    \    i = 0\n    while i < s.length\n        i += 1\n        if s[i] == s[i]\n\
    \            count += 1\n        else\n            count = 0\n        end\n  \
    \      if count >= 3 && s[i - 3] != s[i - 2]\n            return false\n     \
    \   end\n    end\n    return true\nend", "  s.gsub!(/(.)\\1\\1+/, '\\\\1\\1')\n\
    \  s.gsub!(/([a-z])\\1\\1/, '\\\\1\\\\1\\1')\n  s.gsub!(/([a-z])\\1\\1/, '\\\\\
    1\\\\1\\1')\n  s.gsub!(/([a-z])\\1\\1/, '\\\\1\\\\1\\1')\n  s.gsub!(/([a-z])\\\
    1\\1/, '\\\\1\\\\1\\1')\n  s.gsub!(/([a-z])\\1\\1/, '\\\\1\\\\1\\1')\n  s.gsub!(/([a-z])\\\
    1\\1/, '\\\\1\\\\1\\1')\n  s.gsub!(/([a-z])\\1\\1/, '\\\\1\\\\1\\1')\n  s.gsub!(/([a-z])\\\
    1\\1/, '\\\\1\\\\1\\1')\n  s.gsub!(/([a-z])\\1\\1/, '\\\\1\\\\1\\1')\n  s.gsub!(/([a-z])\\\
    1\\1/, '\\\\1\\\\1\\1')\n  s.gsub!(/([a-z])\\1\\1/, '\\\\1\\\\1\\1')\n  s.gsub!(/([a-z])\\\
    1\\1/, '\\\\1\\\\1\\1')\n  s.gsub!(/([a-z])\\1\\1/, '\\\\1\\\\1\\1')\n  s.gsub!(/([a-z])\\\
    1\\1/, '\\\\1\\\\1\\1')\n  s.gsub!(/([a-z])\\1\\1/, '\\\\1\\\\1\\1')\n  s.gsub!(/([a-z])\\\
    1\\1/, '\\\\1\\\\1\\1')\n  s.gsub!(/([a-z])\\1\\1/, '\\\\1\\\\1\\1')\n  s.gsub!(/([a-z])\\\
    1\\1/, '\\\\1\\\\1\\1')\n  s.gsub!(/([a-z])\\1\\1/, '\\\\1\\\\1\\1')\n  s.gsub!(/([a-z])\\\
    1\\1/, '\\\\1\\\\1\\1')\n  s.gsub!(/([a-z])\\1\\1/, '\\\\1\\\\1\\1')\n  s.gsub!(/([a-z])\\\
    1\\1/, '\\\\1\\\\1\\1')\n  s.gsub!(/([a-z])\\1\\1/, '\\\\1\\\\1\\1')\n  s.gsub!(/([a-z])\\\
    1", "  return s.split('').all? { |c| (c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u') && c[1..-1].uniq.size == 3 }\nend\n</code>\nThe first two test\
    \ cases were written by hand and don't reflect your description (for example,\
    \ what if there are no 3 consecutive letters?). However, they should work correctly\
    \ for the cases you're given.\n<|/ a tags=ruby,string dscore=2 |>\n<| c |>\n`abcde`\
    \ should return true for `is_happy.call('abcde')`.\n<|/ c |>\n<| c |>\nAgreed,\
    \ but OP said \"A string is haprb if its length is at least 3 [and there exists\
    \ a 3-letter non-repeating substring].\" That is why I included the substring\
    \ check in my first answer.\n<|/ c |>\n<| c |>\n\"A string is haprb if its length\
    \ is at least 3 [and there exists a 3-letter non-repeating substring].\" This\
    \ seems to require the string to be of length at least 4 and for the letters to\
    \ be in alphabetical order with no repeated letters.\n<|/ c |>\n<| c |>\n, You're\
    \ right that my description wasn't clear. I've updated my answer.\n<|/ c |>\n\
    <| c |>\nThe \"substring\" check isn't even needed here, just use `each_char`\
    \ and compare the results to your string.\n<|/ c |>\n<| a |>\nRuby has the method\
    \ String#succ:\n<code>\nirb(main):001:0> \"abcd\".succ\n=> \"abce\"\nirb(main):002:0>\
    \ \"aabc\".succ\n=> \"abcb\"\nirb(main):003:0> \"abcdef\".succ\n=> \"abcde\"\n\
    </code>\nIf your input string is always longer than 3 characters, you can simply\
    \ check the last character to see if it equals the last character of your string.\n\
    <code>", "    s.each_index { |i| return true if s[i].length < 3 || s[i].gsub!(/./,\
    \ '').uniq.length % 3 != 0 }\n    return true\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\n`gsub!` doesn't mutate `s`, it returns a new string.\n<|/ c |>\n\
    <| c |>\nThat is true, but it is not the problem here. The problem is that `gsub!`\
    \ does not mutate `s`, it returns a new string. `gsub!` mutates `s` because it\
    \ returns `s`.\n<|/ c |>\n<| c |>\nAh, so I see. Thanks. I didn't know about this\
    \ distinction.\n<|/ c |>\n<| a dscore=0 |>\nThis isn't exactly an answer, but\
    \ may help you understand:\n<code>\na = \"hello\"\nb = a.gsub(\"o\",\"X\")\nputs\
    \ b\n</code>\nYou'll find that the string \"hello\" is now \"heXllo\".\nIn your\
    \ case, you can do this:\n<code>", "  s=s.to_s.downcase\n  return s.length >=\
    \ 3 and s.chars.all?{|c| c!=c}\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,string\
    \ |>\n<code>", "  return s.length >= 3 && s[0...-1].uniq.length >= 3\nend", " \
    \   chars=s.length\n    if chars<3 then return false\n    begin\n        i=0;j=chars-2;while\
    \ i<j do\n            if s[i]=s[j] then return false\n            i=i+1;j=j-1\n\
    \        end\n        if s[i]=s[j] then return true\n    end while i\n    return\
    \ false\nend\n</cell>\n<code language=julia-1.6>", "  s.split(\"\").uniq.size\
    \ == s.split(\"\").size && s.split(\"\").uniq.all? {|c| s.count(c) == 3}\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\nHi thank you for the answer, but can you\
    \ please give me a hint on how I might implement this into my code?\n<|/ c |>\n\
    <| c |>\nIt's already implemented as an anonymous method, so you just call it\
    \ as `is_happy(str)`\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  return s.length\
    \ >=3 && s.chars.uniq.group_by(&:itself).all? { |k| k.count >= 3 }\nend", "  \
    \  s = s[0..-2]\n    return s.length >= 3 and (s[0..2].zip(s[1..-1]).inject(:+)\
    \ == s.length)\nend", "    str.split(s) #splits string into array of characters\
    \ (chars)\n    s.length #length of the string\n    each_cons(3).include? #checks\
    \ if array has three consecutive same characters\nend", "\ti = 0\n\twhile i <\
    \ s.length\n\t\tj = 0\n\t\twhile j < s.length - i\n\t\t\tif s.slice(i, j) == \
    \ s.slice(j+1, j+3)\n\t\t\t\treturn false\n\t\t\tj = j + 1\n\t\ti = i + 1\n\t\
    return true\nend", "  s.to_s.length >= 3 &&\n  s.to_s[0...3].each_char.uniq.count\
    \ == 3\nend", "    arr=s.chars\n    return (arr.length >= 3) and\n        ((arr.uniq.count(\"\
    a\") < arr.uniq.count(\"b\")) and\n        (arr.uniq.count(\"b\") < arr.uniq.count(\"\
    c\")) and\n        (arr.uniq.count(\"c\") < arr.uniq.count(\"a\")) and\n     \
    \   (arr.uniq.count(\"a\") < arr.uniq.count(\"d\")) and\n        (arr.uniq.count(\"\
    d\") < arr.uniq.count(\"x\")) and\n        (arr.uniq.count(\"x\") < arr.uniq.count(\"\
    y\")))\nend\nend\n</code>\nAnd here is the code for the HappyNumbers2 class:\n\
    <code>", "    i = 0\n    while i < s.length do\n        if s[i] == s[i]\n    \
    \    i+=1\n        if i >= s.length then\n            true\n        else\n   \
    \         false\n        end\n    end\nend\n</cell>\n<code language=julia-0.5>",
  "  if s.length >= 3 then\n    true\n  else\n    false\n  end\nend", "  s.gsub(/./,\"\
    \").length.to_i >= 3 && s.chars.all?{|c| c.to_i != c.to_i}\nend", "  s.length\
    \ >= 3 and s.chars.uniq.size == 3 \nend\n</cell>\n<code language=julia-1.3>\n\
    is_happy(\"\")\n</cell>\n<code language=julia-1.3>\nis_happy(\"a\")\n</cell>\n\
    <code language=julia-1.3>\nis_happy(\"aa\")\n</cell>\n<code language=julia-1.3>\n\
    is_happy(\"abcd\")\n</cell>\n<code language=julia-1.3>\nis_happy(\"aabb\")\n</cell>\n\
    <code language=julia-1.3>\nis_happy(\"adb\")\n</cell>\n<code language=julia-1.3>\n\
    is_happy(\"xyy\")\n</cell>\n<text>\nPart 2", "  hap_counter=1\n  for c in s\n\
    \    if c==s[hap_counter] and hap_counter<s.length-3\n      hap_counter=hap_counter+1\n\
    \    end\n    if hap_counter==3\n      hap_counter=0\n    end\n  end\n  return\
    \ hap_counter==3\nend", "  if s.length<3 then\n   return false\n  end\n  for i\
    \ = 0 to s.length-3\n    if s[i]==s[i+1] and s[i]==s[i+2] and s[i]==s[i+3] then\n\
    \      return false\n    end\n  end\n  return true\nend\n</cell>\n<code language=julia-1.5>\n\
    s = \"\"\"\nSam went to the park with her.\nSam, the park he went to with her.\n\
    Sam, the park she went to with her.\n\"\"\"\n</cell>\n<code language=julia-1.5>\n\
    is_happy.(s)\n</cell>\n<code language=julia-1.5>", "  s.each_char do |ch|\n  \
    \  return false if ch != s.at(s.length - 1) && ch != s.at(s.length - 2)\n    return\
    \ false if s.at(s.length - 1) != s.at(s.length - 2)\n  end\n  return true\nend",
  "  return s.length >= 3 && s.chars.each_cons(3).all?{|a,b,c| a.hash==b.hash && a.hash==c.hash}\n\
    end\n</cell>\n<text>\nTime complexity: O(n)", "  s.split.each do |l|\n    next\
    \ if l.length < 3 || l.uniq.length != 3\n    false\n  end\n  true\nend", "  s\
    \ = s.chars\n  return s.length >= 3 && s.group_by{|x| x}.all?{|key, v| v.uniq.length\
    \ == 1}\nend", "\thappy_chars = (('a','b','c'),('d','e','f'),('g','h','i'),('j','k','l'),('m','n','o'),('p','q','r'),\n\
    \t\t\t\t\t('s','t','u'),('v','w','x'),('y','z','a'))\n\thappy_chars.each do |c|\n\
    \t\tif s.length >= 3 and s.index(c.first..c.last) == nil\n\t\t\treturn false\n\
    \t\telse\n\t\t\treturn true\n\t\tend\n\tend\nend", "    return s.count(\"a\")\
    \ == s.count(\"b\") && s.count(\"a\") == s.count(\"c\")\nend\n</cell>\n<cell>",
  "  s.size == 3 && all?(s[0..2], s[2..-1]).length == 3\nend\n</code>\n<|/ a tags=string,ruby,boolean\
    \ |>\n<| a tags=string,ruby,boolean |>\n<code>", "  s = char_list(s) \n  s.sort!\n\
    \  s.each_with_index do |c,i|\n    break if i%3 == 0 || s[i] == c\n  end\n  s.size\
    \ == 3 and s[0] == s[2] and s[1] == s[3]\nend\n</code>\n<|/ a |>\n<| a dscore=0\
    \ |>\nMy solution is a little different from the ones already posted. \nThe benefit\
    \ of this code is that you can run it on any string without having to put in any\
    \ conditions.\nThe main difference is that my method uses 'each_char' instead\
    \ of 'each'. \n<code>", "  s.to_s.length >= 3 and (s.chars.zip(s.chars[1..-1]).map\
    \ {|a,b| a.eql? b || a.nil? || b.nil? }.inject(:&)).nil?\nend", "  str.length(s)\
    \ > 0\nend", "  return s.length >= 3 and s.gsub(/[^a-z]\\W+/, '').length == 3\n\
    end\n</cell>\n<cell>", "  s = String.new(s)\n  s.length >= 3 && s.each_char.group_by.with_index\
    \ { |x,i| x }.size == s.size/3\nend", "  s.size >= 3 && s.chars.uniq.length >=\
    \ 3\nend", "  return s.length >= 3 && (s.chars.sort.uniq.select {|i| i % 2 ==\
    \ 0}.uniq.length >= 3)\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis solution\
    \ is O(n^2) because you're sorting the string. Not an issue if you're going to\
    \ be calling the function a lot but could be a problem if you're calling the function\
    \ a lot.\n<|/ c |>\n<| c |>\n: I agree with you. The code isn't exactly efficient\
    \ but the algorithm is clear to me. I would like to see a better solution.\n<|/\
    \ c |>\n<| a tags=ruby |>\nA straight forward implementation without using sort\
    \ would be as follows:\n<code>", "    count = {}\n    count = 0\n    letters =\
    \ \"\"\n    flag = 0\n    count = 0\n    lenght = len(s)\n    if lenght < 3 then\
    \ return false end\n    for letter in s\n        if !count[letter]\n         \
    \   count[letter] = 1\n        else\n            count[letter] = count[letter]\
    \ + 1\n        end\n    end\n    for k in count\n        if count[k] > 1\n   \
    \         flag = 1\n        end\n    end\n    if flag == 0\n        return true\n\
    \    else\n        return false\n    end\nend\n</cell>\n<cell>\nprintln(is_happy(s))\n\
    </cell>\n<text>\n4.1 Happy numbers\nNow let's write some Ruby code that checks\
    \ if the given number is happy:", "    s.length >= 3 and s.each_cons(3).all? {|s|\
    \ (s.uniq.length == 1) }\nend", "\tis_happy = s.size>=3 && s.chars.uniq.length\
    \ == 3\nend", "  string=s.split('').join\n  (3..string.length).all? { |i| (string[0..i].uniq.length==3)\
    \ }\nend", "    s=s.to_s\n    return s.length>=3 and s.chars.all? {|c| c==s.to_s[1..-1]}\n\
    end\n</code>\n<|/ a tags=string,ruby dscore=2 |>\n<| a tags=string,ruby dscore=1\
    \ |>\n<code>", "  return s.length>=3 && (s.chars.zip3.all? {|(a,b,c)| a==b==c}\
    \ )\nend\n</cell>\n<code language=julia-0.4>\nis_happy(\"hello\")\n</cell>\n<text>\n\
    The Julia language", "    if s.empty?\n      true\n    elsif s.length < 3\n  \
    \    false\n    elsif s.chars.uniq.length >= 3\n      true\n    else\n      false\n\
    \    end\n  end", "  s = s[0].to_s\n  puts s.split(//).select { |e| e[0] }.uniq.count\
    \ > 2 ? true : false\nend", "  h=s.count(\"a\")\n  a=s.count(\"b\")\n  b=s.count(\"\
    c\")\n  c=s.count(\"d\")\n  d=s.count(\"e\")\n  e=s.count(\"f\")\n  f=s.count(\"\
    g\")\n  g=s.count(\"h\")\n  h=s.count(\"i\")\n  i=s.count(\"j\")\n  j=s.count(\"\
    k\")\n  k=s.count(\"l\")\n  l=s.count(\"m\")\n  m=s.count(\"n\")\n  n=s.count(\"\
    o\")\n  o=s.count(\"p\")\n  p=s.count(\"q\")\n  q=s.count(\"r\")\n  r=s.count(\"\
    s\")\n  s=s.count(\"t\")\n  t=s.count(\"u\")\n  u=s.count(\"v\")\n  v=s.count(\"\
    w\")\n  w=s.count(\"x\")\n  x=s.count(\"y\")\n  y=s.count(\"z\")\n  z=s.count(\"\
    a\")\n  z=s.count(\"b\")\n  z=s.count(\"c\")\n  z=s.count(\"d\")\n  z=s.count(\"\
    e\")\n  z=s.count(\"f\")\n  z=s.count(\"g\")\n  z=s.count(\"h\")\n  z=s.count(\"\
    i\")\n  z=s.count(\"j\")\n  z=s.count(\"k\")\n  z=s.count(\"l\")\n  z=s.count(\"\
    m\")\n  z=s.count(\"n\")\n  z=s.count(\"o\")\n  z=s.count(\"p\")\n  z=s.count(\"\
    q\")\n  z=s.count(\"r\")\n  z=s.count(\"s\")\n  z=s.count(\"t\")\n  z=s.count(\"\
    u\")\n  z=s.count(\"v\")\n  z=s.count(\"w\")\n  z=s.count(\"x\")\n  z=s.count(\"\
    y\")\n  z=s.count(\"z\")\n  z=s.count(\"a\")\n  z=s.count(\"b\")\n  z=s.count(\"\
    c\")\n  z=s.count(\"d\")\n  z=s.count(\"e\")\n  z=s.count(\"f\")\n  z=s.count(\"\
    g\")\n  z=s.count(\"h\")\n  z=s.count(\"i\")\n  z=s.count(\"j\")\n  z=s.count(\"\
    k\")\n  z=s.count(\"l\")\n  z=s.count(\"m\")", "    return s.length >= 3 && s.chars.all?\
    \ {|c| c.odd?}.size % 3 == 0\nend\n</pre>", "  s.length >= 3 &&\n  s.chars.each_cons(3).to_a\
    \ == s.chars.uniq.count\nend", "  a = s.split(\"\")\n  b = a.sort\n  a.length\
    \ >= 3 && b.inject(0) { |i,x| i + 1 } >= 3\nend\n</code>\n<|/ a tags=ruby dscore=2\
    \ |>\n<| c |>\nThis solution doesn't consider that 'aa' is a happy.\n<|/ c |>\n\
    <| c |>\n, you're right, thank you. Edited the answer\n<|/ c |>\n<| a |>\nThis\
    \ is not the most efficient, but it's quite readable:\n<code>", "  s.chars.reduce(&:+)\
    \ == s.chars.length\nend", "    s = s.downcase\n    count = 0\n    s.each { |c|\
    \ break if count >= 3 || s[count] == c }\n    count == 3\nend", "  str=s.to_s\n\
    \  return str.count(\"a\")==3&str.length>=3&str.length%3==0\nend\n</code>\n<|/\
    \ a dscore=0 tags=ruby,string,algorithm |>\n<| c |>\nCan you explain how the algorithm\
    \ works?\n<|/ c |>\n<| c |>\nIt counts the number of a's in a string and if it\
    \ is 3 then the string is happy.\n<|/ c |>\n<| c |>\nI like how you used the string\
    \ method `count` instead of the regex method.\n<|/ c |>\n<| c |>\nBut `count`\
    \ also counts consecutive letters. So `aa` would return 2 instead of 3\n<|/ c\
    \ |>\n<| c |>\nYes. A is counted 2 times. But you said \"a is 3 consecutive letters\"\
    \ so if you want A to be counted as 3, then you need to check if it is 3 consecutive\
    \ letters.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  s.length >= 3 && s.chars.all?\
    \ {|c| c%33!=0 && c%33!=0 && c%33!=0}\nend\n</cell>\n<cell>", "  return s.length\
    \ >= 3 and s.split('').all?{ |c| is_happy.call(c) }\nend", "    if s.length <\
    \ 3 then\n        return false\n    local str = \"\"\n    for i=1,3,1 do\n   \
    \     if str==\"\" then\n            str = s\n        else\n            str =\
    \ str .. s\n        end\n    end\n    for i=2,#str do\n        if str[i]~=str[i-1]\
    \ then\n            return false\n        end\n    end\n    return true\nend\n\
    </cell>\n<cell>", "    s = s.split(\"\")\n    s.sort!\n    s.length >= 3\n   \
    \ loop do\n      return false if s.uniq.length < 3\n      s.uniq.each {|l| break\
    \ true if l != s.uniq.last}\n    end\n    return true\nend", "  s.chars.each_index\
    \ do |i|\n    if i != 0\n      c = s.chars[i]\n      next if c != s.chars[i-1]\n\
    \      next if c != s.chars[i+1]\n      next if c != s.chars[i+2]\n    end\n \
    \   break\n  end\n  return s.chars.length >= 3\nend\n</cell>\n<code language=julia-1.2>\n\
    is_happy.call(\"abc\")\n</cell>\n<code language=julia-1.2>\nis_happy.call(\"abcd\"\
    )\n</cell>\n<code language=julia-1.2>\nis_happy.call(\"aabb\")\n</cell>\n<code\
    \ language=julia-1.2>\nis_happy.call(\"adb\")\n</cell>\n<code language=julia-1.2>\n\
    is_happy.call(\"xyy\")\n</cell>\n<text>\nRemark: this problem might be easier\
    \ if you start from the other end and work your way inwards.", "  s.each_char.all?\
    \ do |char|\n    char.downcase == char\n  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails-4,arrays,hash,string\
    \ |>\n<| a dscore=2 tags=ruby,ruby-on-rails-4,arrays,hash,string |>\nYou could've\
    \ used each_char.all? and String#include? in a single statement and avoid using\
    \ .each.\n<code>", "  s.size >= 3\n  s.chars.permutation(3).all? { |i| s[i].hash\
    \ != s[i].downcase }\nend", "  return s.length >= 3 && s.chars.uniq.size > 3\n\
    end\n</code>\nBut it also fails the test case that you are using that requires\
    \ every 3 letters to be distinct:\n<code>", "  s.empty?\n  || s.length < 3 ||\
    \ s.scan(/^[abc]+$/).length >= 3\nend\n</cell>\n<code language=julia-1.5>", " \
    \ s.chars.map{|c|\n    if c == 'a' || c == 'e' || c == 'i'\n      return false\n\
    \    elsif c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I'\n      return\
    \ true\n    elsif c == 'o' || c == 'u'\n      return false\n    end\n  }.all?{|b|\n\
    \    (b.to_s == 'aa' || b.to_s == 'ee' || b.to_s == 'ii' || b.to_s == 'oo' ||\
    \ b.to_s == 'uu' || b.to_s == 'oo' || b.to_s == 'uu')\n  }\nend\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\n+1 for the cool solution. However, the OP has explicitly\
    \ asked for a solution without using any additional methods.\n<|/ c |>\n<| c |>\n\
    This would not work even if I could find an elegant solution without using any\
    \ additional methods\n<|/ c |>\n<| c |>\nSorry but this does not work on the first\
    \ example. For instance, it returns true when it should return false.\n<|/ c |>\n\
    <| c |>\nYou are absolutely right. It would be better not to have it at all. You\
    \ should check my updated answer and check out my comment on KennyTM's answer.\n\
    <|/ c |>\n<| a dscore=1 |>\nYou can try this too:\n<code>", "  # write your code\
    \ in Ruby\nend", "  # Add your code here\n  return s.size == 3 and check_all_distincts(s[1..-2])\
    \ && check_all_distincts(s[-2..-1])\nend", "  count = 0\n  chars = s.split(\"\"\
    )\n  while count < chars.length do\n    if chars[count] == chars[count-1] then\n\
    \      return false\n    end\n    count = count + 1\n  end\n  return true\nend\n\
    </code>\n<|/ a tags=functional-programming,ruby |>\n<| c |>\nI don't understand,\
    \ how does your solution work? The \"count < chars.length\" will always be true,\
    \ right?\n<|/ c |>\n<| c |>\nyes, because we are counting `chars.length` times.\n\
    <|/ c |>\n<| c |>\nThe `if chars[count] == chars[count-1] then` is redundant and\
    \ counterproductive, since Ruby allows `chars[count] == chars[count-1]` to test\
    \ whether `chars[count]` is equal to `chars[count-1]`.\n<|/ c |>\n<| a dscore=0\
    \ tags=functional-programming,ruby |>\nIf you don't want to use any built-in methods,\
    \ you can use the following approach:\n<code>", "    s.length >= 3 && (s.chars.each.with_index.inject(true)\
    \ { |a,(letter,i)| a == false && letter == a[i-1] } )\nend\n</pre>", "  return\
    \ s.length >= 3 and s.gsub(/./, '').split(//).uniq.size == 3\nend", "    len =\
    \ s.length\n    if len < 3 \n        return false\n    count = 0\n    while count\
    \ < len\n        if s[count] == s[count+2]\n            return false\n       \
    \ count = count + 1\n    return true\nend", "    s = s[0..-2]\n    return s[0..-2]\
    \ == s[0..-2] + s[0..-2] + s[0..-2] + s[0..-2] + s[0..-2]\nend\n</code>\nNow we\
    \ can compare our two implementations and see that ours is significantly faster\
    \ than the others. I ran this test a bunch of times in IRB and here are the results:\n\
    <code>\nirb(main):008:0> require 'benchmark'\n=> true\nirb(main):009:0> a = rand\
    \ * 10\n=> 1425445629\nirb(main):010:0> a.sort\n=> [1425445629, 1425445629, 1425445629,\
    \ 1425445629, 1425445629, 1425445629, 1425445629, 1425445629, 1425445629, 1425445629,\
    \ 1425445629, 1425445629, 1425445629, 1425445629, 1425445629, 1425445629, 1425445629,\
    \ 1425445629, 1425445629, 1425445629, 1425445629, 1425445629, 1425445629, 1425445629,\
    \ 1425445629, 1425445629, 1425445629, 1425445629, 1425445629, 1425445629, 1425445629,\
    \ 1425445629, 1425445629, 1425445629, 1425445629, 1425445629, 1425445629, 1425445629,\
    \ 1425445629, 1425445629, 1425445629, 1425445629, 1425445629, 1425445629, 1425445629,\
    \ 1425445629, 1425445629, 1425445629, 1425445629, 1425445629, 1425445629, 1425445629,\
    \ 1425445629, 1425445629, 1425445629, 1425445629, 1425445629, 1425445629, 1425445629,\
    \ 1425445629, 1425445629, 1425445629, 1425445629, 1425445629, 1425445629, 1425445629,\
    \ 1425445629, 1425445629, 1425445629, 1425445629, 1425445629, 1425445629, 1425445629,\
    \ 1425445629, 1425445629, 1425445629, 142544", "    s.gsub!(/[^a-z]/i, '')\n \
    \   s.each_char{ |c| c.upcase if s.index(c) <3}.all? {|c| c.to_s.size >= 3}.all?\
    \ {|c| s.index(c) <3}\nend\n</code>\n<|/ a tags=string,ruby,arrays dscore=1 |>\n\
    <| a |>\n<code>", "  s.gsub!(/[^a-z]/, '')\n  return s.length >= 3 && s.chars.uniq.length\
    \ >= 3\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\n`s.chars.uniq.length >= 3` is\
    \ better written as `s.length >= 3`.\n<|/ c |>\n<| c |>\nAgreed. `gsub!` does\
    \ something with the results. `length` already returns the length in characters.\
    \ Also `chars` includes the non-alphabetic characters in the result, so `uniq`\
    \ removes them.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,regex,ruby-on-rails-4\
    \ |>\nI see no reason to use regex here, but you can use this as is. Just replace\
    \ the is_happy.call call with is_happy.call on every string. \n<code>", "  s.each_char.with_index.all?\
    \ { |char, i| char != char.succ } && s.length >= 3\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| c |>\nThis is a brilliant answer! I believe `is_happy` could be greatly\
    \ simplified by `s.each_char.with_index.all? { |char, i| char != char.succ } &&\
    \ s.length >= 3`, but this definitely nails the point of it.\n<|/ c |>\n<| c |>\n\
    Thanks for your comment! I just pointed out that `s.each_char.with_index.all?`\
    \ should be replaced by `s.each_char.all?`.\n<|/ c |>\n<| c |>\nThis is perfect!\
    \ I got it working. But, I still don't understand how it works because I can't\
    \ find a way to print out the value of `i`.\n<|/ c |>\n<| c |>\nThis is just a\
    \ shortcut for writing `s.each_char.with_index.all? { |char, i| puts char if char\
    \ != char.succ } && s.length >= 3`. You just need to put the code block inside\
    \ the `all?`\n<|/ c |>\n<| a dscore=2 |>\nThis can be done with a regex, which\
    \ I believe is more readable and maintainable:\n<code>\n/^.{3}[^a-zA-Z]*$/\n</code>\n\
    This regex says to match 3 characters and then match any number of non-letter\
    \ characters up until the end of the string and then the end of the string.\n\
    <code>\nif input =~ /^.{3}[^a-zA-Z]*$/\n  puts \"happy\"\nend\n</code>\nThe Ruby\
    \ code will work for strings of any length.\n<|/ a tags=ruby,string |>\n<| c |>\n\
    This doesn't work for non-ASCII characters. `'\xE1'.gsub(/^.{3}[^a-zA-Z]*$/, 'happy')\n\
    \ => happy\n 'a'.gsub(/^.{3}[^a-zA-Z]*$/, 'happy')\n => happy\n '\xDF'.gsub(/^.{3}[^a-zA-Z]*$/,\
    \ 'happy')\n => happy\n '\xE4'.gsub(/^.{3}[^a-zA-Z]*$/, 'happy')\n => happy\n\
    \ '\xC4'.gsub(/^.{3}[^a-zA-Z]*$/, 'happy')\n => happy\n '\xC4'.gsub(/^.{3}[^a-zA-Z]*$/,\
    \ 'happy')\n => happy`\n<|/ c |>\n<| c |>\nYou're right, this doesn't work for\
    \ non-ASCII characters, however", "  arr = s.to_a\n  arr.empty? && return false\
    \ # empty string => false\n  arr.size == 1 && return true # 1 letter => true\n\
    \  return arr.size >= 3 && arr.each_index.all? { |i| arr[i] != arr[i+1] }\nend",
  "  s.gsub(/[a-z]/) do |c|\n    (c != s.last)\n  end.length >= 3\nend\n</code>\n\
    <|/ a tags=ruby,string |>\n<| a |>\n<code>\nrequire 'set'", "\th=false\n\tif(s.length<3)\n\
    \t\treturn false\n\telse\n\t\tfor i in 1..s.length\n\t\t\th=h||(s[i]!=s[(i-1)%s.length])\n\
    \t\tend\n\tend\n\treturn h\nend", "  return s.length >= 3 and s.chars.all?(&:distinct)\n\
    end", "  return s.length >= 3 and (s.chars.each_cons(3).all? {|c| c.uniq.length\
    \ == 1} | s.chars.each_cons(2).all? {|c| c.uniq.length == 2} | s.chars.each_cons(1).all?\
    \ {|c| c.uniq.length == 3})\nend", "  s = s.to_s\n  return s.length >= 3 and s.chars.each_cons(3).all?\
    \ { |x| x.chars.distinct.count == x.length }\nend\n</cell>\n<cell>\na = 'a' #>\
    \ 'a'\na == 'a' #> false\na == 'b' #> false\na == 'c' #> true\na == 'd' #> false\n\
    </cell>\n<text>\nExercise 3", "  s = s.downcase\n  return s.length >= 3 && s.chars.all?{\
    \ |char| char.ord != char }\nend\n</code>\n<|/ a tags=ruby dscore=1 |>\n<| a dscore=1\
    \ |>\n<code>", "    if s.length < 3 || s.length % 3 != 0\n        return false\n\
    \    chars = {}\n    for character in s\n        chars[character] = chars[character]\
    \ + 1 if character in chars else 1\n    return true\nend", "    s.chars.each_index\
    \ { |i| return false if s.chars[i] == s.chars[i+1] if s.chars[i] == s.chars[i+2]\
    \ if s.chars[i] == s.chars[i+3] }\n    true\nend", "  s.chars.each_slice(3).all?\
    \ { |a,b| a.chars.include?(b) }\nend", "  s.count('a').odd? && s.count(c) - s.count('a')\
    \ == s.count('a') - s.count('a'/3)\nend", "  return s.length >= 3 && s.chars.each_cons(3).all?\
    \ {|i| i.uniq.length == 1}\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\n\
    While this may answer the question, providing additional context regarding how\
    \ and/or why it solves the problem would improve the answer's long-term value.\n\
    <|/ c |>\n<| a dscore=4 |>\n<code>", "  return s.length >= 3 and s.chars.distinct.size\
    \ == 3 \nend\nend\n</code>\n<|/ a |>\n<| c |>\nThis also works in Ruby 1.8.6 (at\
    \ least)\n<|/ c |>\n<| c |>\nI thought that there would be a better solution than\
    \ the one with inject, but this is definitely more elegant. Thanks!\n<|/ c |>\n\
    <| c |>\nI was thinking about it too late, I've changed the code to match the\
    \ requirements. Thank you!\n<|/ c |>\n<| a |>\nYou could just do something like\n\
    <code>\nif s.chars.uniq.size == 3 &&\n   s.chars.uniq.sort == s.chars\n  puts\
    \ 'happy'\nelse\n  puts 'unhappy'\nend\n</code>\n<|/ a tags=ruby dscore=1 |>\n\
    <| c |>\nWhoops, that doesn't work. This code returns true if s is \"ab\" which\
    \ is clearly not happy.\n<|/ c |>\n<| c |>\n- Sorry, I misread the question. \
    \ Fixed.\n<|/ c |>\n<| c |>\nOh wow. I didn't think of that. Thanks!\n<|/ c |>\n\
    <| c |>\nI didn't actually test it before I posted, but it works now. I had to\
    \ edit it a bit to account for having more than two consecutive letters :)\n<|/\
    \ c |>\n<| a tags=ruby dscore=1 |>\n<code>", "  return ((s.length >= 3) and (s.scan(/^\\\
    w\\w\\w/).empty? or s.scan(/\\w\\w\\w/).empty?))\nend", "  s.length >= 3 and ((s.length\
    \ % 3 == 0) and (s.chars.permutation? or s.chars.uniq.size == s.length))\nend",
  "  if s.length < 3 or s.chars.uniq.count != s.length\n    puts false\n  else\n \
    \   puts true\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nWhat is the use of `count`\
    \ in `uniq.count`? Why not simply `uniq.size`?\n<|/ c |>\n<| c |>\nBecause `uniq.size`\
    \ is the same thing as `uniq.count`. From the [docs](http://ruby-doc.org/core-2.2.0/Array.html#method-i-uniq):\
    \  `uniq \u2192 new_ary \u2192 new_ary`:\n`Returns a new array containing all\
    \ unique elements of an\narray. If an element is present more than once in the\
    \ given\narray, that element will be only once in the result array.`\n<|/ c |>\n\
    <| c |>\nThat was a quick copy-paste from my editor. Thanks for noticing that.\
    \ I updated my answer. Thanks!\n<|/ c |>\n<| c |>\nthank you. I was looking at\
    \ something similar and I was trying to figure out how it worked.\n<|/ c |>\n\
    <| c |>\nFor those who are interested in the implementation of `uniq` see this\
    \ [implementation](https://github.com/ruby/ruby/blob/ece00dda5bae69ad54587632ff77ddbdddafd671/array.c#L563).\n\
    <|/ c |>\n<| a tags=ruby,ruby-on-rails,arrays,logic |>\n<code>", "  return s.length\
    \ >= 3 and s.chars.all?{|char| char.count(char.next) == 1 }\nend", "  if s.length\
    \ < 3 then return false\n  local last, curr\n  for i = 1, s.length, 1 do\n   \
    \ last = curr\n    local c = s[i]\n    repeat\n      curr = s[i+1]\n      if last\
    \ == curr then break end\n      last = curr\n    until curr == c\n  end\n  return\
    \ true\nend", "  s.each_char.with_index.inject(true) do |result, ((letter, index),\
    \ count)|\n    (result && index == count) && result.downcase!\n  end\nend\n</cell>\n\
    <cell>\nis_happy('adbc')\n</cell>\n<cell>\nis_happy('bab')\n</cell>\n<cell>\n\
    is_happy('abcabc')\n</cell>\n<cell>\nis_happy('abc')\n</cell>\n<cell>\nis_happy('acb')\n\
    </cell>\n<cell>\nis_happy('aa')\n</cell>\n<cell>\nis_happy('aaa')\n</cell>\n<text>\n\
    Problem 5\nYou will have a list of numbers represented as an array of digits,\
    \ possibly with leading zeroes. The length of the array will be in the range between\
    \ 1 and 100,000. The digits are stored such that the most significant digit is\
    \ at the zeroth index and the least significant digit is at the last index. The\
    \ list of numbers will not contain leading zeroes.", "  puts s.length >= 3\n \
    \ s.each_char.with_index do |e, i|\n    puts i != 0\n    puts e != s[i-1]\n  end\n\
    \  return s.length >= 3\nend", "  s.split(\"\").all? { |l| l.each_cons(3).none?\
    \ { |n| n.size == 2 && n.all? { |x| x == l.pop } }  }\nend", "    i = 0\n    count\
    \ = 0\n    while i < s.length\n        # check if every three letters are not\
    \ the same\n        if s.chars[i] == s.chars[i + 1] && s.chars[i + 1] == s.chars[i\
    \ + 2]\n            return false\n        else\n            # count the number\
    \ of the same letters\n            count += 1\n            i += 3\n    end\n \
    \   count >= 3\nend\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| c |>\nHow does this\
    \ differ from [the accepted answer](https://stackoverflow.com/a/55691517/128421)?\
    \ It has the same bug that [this answer does](https://stackoverflow.com/a/55691605/128421)\
    \ but you also fixed this bug, thus both answers give the same result for your\
    \ sample input.\n<|/ c |>\n<| c |>\nThanks so much. Very clear explanation. Now\
    \ I understand\n<|/ c |>\n<| c |>\nThis answer is great, except I believe it can\
    \ be made significantly more efficient by using a while loop rather than a recursive\
    \ method. As written it requires O(n) stack space and uses O(n) extra memory for\
    \ storing `count`. See my answer for my suggested approach.\n<|/ c |>\n<| a tags=ruby\
    \ |>\nYou can do this in O(1) space by using a Hash object with a counter.\n<code>",
  "  return s.size >= 3 &&\n    not s.chars.any? {|c| c.eql? c }\nend", "  return\
    \ s.size >= 3 && s.chars.permutation.reduce(&:+).to_s.length >= 3\nend\n</cell>\n\
    <cell>", "  str=s.to_s\n  str_len=str.size\n  return (str.size >= 3) and (str.chars.inject(:+)\
    \ == str_len && str.chars.take_while { |x| x != str[str.length-1] })\nend", " \
    \ return s.length >= 3 && s.chars.inject(true,:==).all? {|x,y| x!=y}\nend", " \
    \ s.size.between?(3, s.length) && s.chars.all? { |c| (c & 1) == 0  }\nend", " \
    \ s.length >= 3 &&\n  (s.chars.uniq.length >= 3 || s.chars.uniq.all? {|c| s.chars.uniq.include?(c)})\
    \ \nend", "    s.length >= 3 && s.chars.distinct.each_slice(3).any?{|slice| slice.length\
    \ == 3}\nend\n</code>\n<|/ a |>\n<| c |>\nThe performance of this is really poor.\
    \ On my computer, it is about 2x slower for \"aaaaaaaa\" than for \"abbcabcb\"\
    .\n<|/ c |>\n<| c |>\nThanks for the feedback! I did some benchmarking and updated\
    \ my answer.\n<|/ c |>\n<| a |>\n<code>", "  s.length >= 3 && s[0...-3].uniq.size\
    \ == s.length\nend", "    s = s.chars.reject(&:ascii_only?).join\n    s.length\
    \ >= 3 and s.chars.each.with_index.all? { |c,i| c!=s[i+1], i+1<s.length }\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\nI like this one too, because it doesn't\
    \ require a third party gem or writing any functions, but I wonder why it's getting\
    \ downvoted? Does anyone have any comments?\n<|/ c |>\n<| c |>\nI didn't downvote\
    \ your answer, but I suspect it's because you're using an imperative solution\
    \ that doesn't use any of the Ruby idioms and uses `Array#each` and `Array#all?`\
    \ when an active Ruby solution exists: `s.chars.all? { |c| s.chars.none? { |c2|\
    \ c == c2 || c==c2[1..-1] } }`.\n<|/ c |>\n<| c |>\nI agree, there is something\
    \ wrong with your solution which prevents it from being used as an example. I'd\
    \ like to learn what it is, but I can't think of anything better than yours.\n\
    <|/ c |>\n<| c |>\nYou're correct, it doesn't work correctly. I guess I was stuck\
    \ in a rush and didn't think of using `all?` and `none?`. I've updated my solution\
    \ with your solution and my explanation why it won't work.\n<|/ c |>\n<| c |>\n\
    I really like the use of `chars` and `reject` here. This answer deserves more\
    \ upvotes.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "    s.length >= 3 and s.gsub(/(.)\\\
    1*/,'').length == 3\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThe \"every 3\
    \ consecutive letters are distinct\" rule is very cool! +1\n<|/ c |>\n<| c |>\n\
    What is the `1` for? And why do you have two `s`'s? Also, why are you using `gsub`\
    \ instead of `split`?\n<|/ c |>\n<| c |>\n`gsub` works in case you have `aa.bb.cc`\
    \ or other weird case like `aabb.cc`. In this case we need to keep only unique\
    \ values so we use `gsub`. `split` is more general than `gsub` it allows us to\
    \ take only first letter of each group.\n<|/ c |>\n<| c |>\n`aa.bb.cc` is not\
    \ \"weird\" by any means. What about `aaa.bbb.ccc`?\n<|/ c |>\n<| c |>\nyes it\
    \ is. What do you think of `aa.bbb.ccc` ?\n<|/ c |>\n<| a tags=ruby |>\nHere's\
    \ a solution without regular expressions:\n<code>", "  case s.length >= 3 \n \
    \ when true then true \n  when false then false\n  else return false\n  end\n\
    \  case s.each_index{|i| return false if i.modulo(3) != 0 } \n  when true then\
    \ true \n  when false then false\n  else return false\n  end\nend\n</cell>\n<cell>\n\
    is_happy(\"abcd\")\n</cell>\n<cell>\nis_happy(\"aabb\")\n</cell>\n<cell>\nis_happy(\"\
    adb\")\n</cell>\n<cell>\nis_happy(\"xyy\")\n</cell>\n<text>\nYour task is to verify\
    \ if all characters in a string are digits. Write a function, isdigits_that_is_not_happy.",
  "  if s.length < 3 then return false end\n  last_char = s[s.length-1]\n  for c in\
    \ s[0..length-1]\n    if c <> last_char then return false end\n  end\n  return\
    \ true\nend", "    count = 0\n    for i in s.chars\n        if i == i\n      \
    \      count += 1\n        else\n            count = 0\n        if count > 3\n\
    \            return false\n    return true\nend", "  n = s.length\n  is_happy.rval\
    \ = (n >= 3) && (3**(n-1) === s.length)\nend", "  # Initialize all variables\n\
    \  count = 0\n  last_count = 0\n  last_char = \"\"\n  result = True\n  \n  # Loop\
    \ through each character\n  s.each_byte do |char|\n    \n    # Increment count\
    \ if char is happy\n    if char == \"h\" && last_count != 1\n      count += 1\n\
    \    \n    # Increment count if char is unhappy\n    if char == \"u\" && last_count\
    \ != -1\n      count += 1\n    \n    # Save count for next char\n    last_count\
    \ = count\n    last_char = char\n    \n    # Check if count is at least 3\n  \
    \  if count >= 3 \n      result = False\n    end\n  end\n  \n  return result\n\
    end", "  s = s.split('')\n  s.each do |letter|\n    letter2 = letter\n    letter3\
    \ = ''\n    while letter2 == letter\n      letter3 << letter2\n      letter2 =\
    \ letter + letter\n    end\n    if letter3.length >= 3 and !letter3.split('').all?\
    \ { |c| c.include?(letter) }\n      return false\n    end\n  end\n  return true\n\
    end", "  return s.length >= 3 and all?(s.each_char.with_object(Hash.new(0)).with_index\
    \ { |(c,i),h| h[c] += 1 if i > 0 && h[c] == h[i-1] })\nend", "  (0..length(s)).all?\
    \ {|i| s.chars.uniq(&:first).length >= 3}.all? {|i| s.chars.uniq(&:first).each_cons(3).all?\
    \ {|c| c != s.chars.uniq(&:first).first}}\nend", "  str = s.downcase\n  str.length\
    \ >= 3 and str[0..str.length-2].each_index do |i|\n    prevVal = str[i-1]\n  \
    \  val   = str[i..-1].each_cons(2).inject(:+).to_i\n    (prevVal + val) % 3 ==\
    \ 0\n  end\nend", "  # Your code here\n  happy_count = 0\n  new_string = s\n \
    \ while (new_string != nil)\n    new_string = new_string[0..-2]\n    happy_count\
    \ += 1\n  end\n  return (happy_count == 3)\nend", "  s.gsub!(/[^a-z]/, '')\n \
    \ if s.length < 3\n    return false\n  end\n  result = ''\n  for i in (2..s.length)\n\
    \    result = result + s[i]\n    result << s[(i-1)..i].uniq.size\n  end\n  if\
    \ result == '111' or result == '22' or result == '33' or result == '444' or result\
    \ == '555' or result == '666'\n    return true\n  end\n  return false\nend", "\t\
    a = 0\n\tb = 1\n\twhile a < s.length\n\t\twhile b < s.length\n\t\t\tif s[a] ==\
    \ s[b]\n\t\t\t\ta = a + 1\n\t\t\t\tb = b + 1\n\t\t\telse\n\t\t\t\tb = b + 1\n\t\
    \t\t\tbreak\n\t\telse\n\t\t\ta = a + 1\n\t\t\tbreak\n\t\n\treturn true\nend",
  "  s.scan(/./) { |char| return false if char.upcase == char.downcase }\n  s.length\
    \ >= 3 && s.scan(/./).all? { |char| char.upcase == char.downcase }\nend", "  return\
    \ s.length > 3 && s.chars.all? {|c| c.is_a? String}.all? {|s| s.chars.uniq.length\
    \ == 3}\nend", "  a = s.chars\n  return a.length >= 3 and a.all? { |a| a != a[0..1]\
    \ && a[0..1] != a[0..2] }\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI believe\
    \ you need to make each character a separate array item to compare them as individual\
    \ items. `s.chars.all? { |char| char != char.shift }`.\n<|/ c |>\n<| a |>\n<code>",
  "  (happy = (s.length > 3) == (s.chars.all? { |c| (s.each_index { |i| c[i] }.all?\
    \ { |x| (x != s[i] && x != s[i-1] && x != s[i-2]) } )) )\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nI wouldn't say it is 'faster' since a regex is built and evaluated\
    \ in advance (just like the one in the answer). On the other hand, it is shorter\
    \ and more elegant.\n<|/ c |>\n<| c |>\nI agree. Your answer is more elegant and\
    \ readable. +1\n<|/ c |>\n<| c |>\nYour solution has time complexity of O(N^2),\
    \ while mine has time complexity of O(N).\n<|/ c |>\n<| c |>\n: Not really. Your\
    \ code is not O(N^2). Just because you `collect` the results, the size of the\
    \ results is unrelated to the size of the input. The only reason I suggest it\
    \ is because you have the `all?` function inside of the `map`. `collect` is O(N),\
    \ and `all?` is O(N^2). Since both are inside of `each` they have O(N^2) complexity.\
    \ Even though it would be O(N), it is still O(N^2) since `each` has O(N) complexity.\
    \ `each` does not need to be inside `collect`\n<|/ c |>\n<| c |>\nThe `all?` function\
    \ inside `map` does not make it O(N). `all?` itself is an O(N) operation. And\
    \ each call of `each` inside `each` has O(N^2) complexity. Your code is O(N^3).\
    \ You do `collect` twice and `all?` inside `each` is O(N) too.\n<|/ c |>\n<| a\
    \ dscore=2 |>\n<code>", "  s.count(\"a\") + s.count(\"e\") + s.count(\"i\") +\
    \ s.count(\"o\") + s.count(\"u\") >= 3 && s.count(\"a\") < s.count(\"e\") && s.count(\"\
    a\") < s.count(\"i\") && s.count(\"a\") < s.count(\"o\") && s.count(\"a\") < s.count(\"\
    u\") \nend\n</code>\n<|/ a dscore=0 tags=ruby |>\n<| c |>\nIf you're going to\
    \ use `count` then you probably want to use `include?`, since that is faster than\
    \ `count`. Also, you should probably use `each_char` instead of `chars`, because\
    \ `chars` will create an intermediate array that you might not need later on.\n\
    <|/ c |>\n<| a dscore=0 tags=ruby |>\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
