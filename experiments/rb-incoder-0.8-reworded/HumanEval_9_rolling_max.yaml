name: HumanEval_9_rolling_max
language: rb
prompt: "# From a given array of integers, generate an array of rolling maximum element\
  \ found until given moment\n# in the sequence.\n# >>> rolling_max.call([1, 2, 3,\
  \ 2, 3, 4, 2])\n# [1, 2, 3, 3, 3, 4, 4]\ndef rolling_max(numbers)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rolling_max\n\
  \    candidate = method(:rolling_max)\n    assert_equal([], candidate.call([]))\n\
  \    assert_equal([1, 2, 3, 4], candidate.call([1, 2, 3, 4]))\n    assert_equal([4,\
  \ 4, 4, 4], candidate.call([4, 3, 2, 1]))\n    assert_equal([3, 3, 3, 100, 100],\
  \ candidate.call([3, 2, 3, 100, 3]))\n  end\nend\n"
completions: ["  return numbers[-numbers.length+1-(numbers.first.size-1)..-1]\nend",
  "  numbers.reduce(:<<)\nend", "    rolling_maxes = []\n    rolling_max = 0", " \
    \ rolling_max = Array.new\n  numbers.each_with_index do |element, index|\n   \
    \ rolling_max[index] = element if rolling_max[index].nil? || rolling_max[index]\
    \ > element\n  end\n  return rolling_max\nend", "  numbers.each_with_index.inject([0])\
    \ do |result, value|\n    if value < result.last\n      result.last += 1\n   \
    \ end\n    result\n  end\nend\n</code>\nI guess this implementation is more concise\
    \ than my solution and probably better. But anyway, I have learned something new\
    \ today, and I would recommend you to take a look at the Enumerable module and\
    \ learn how it works.\n<|/ a |>\n<| a |>\nHere is my solution using Enumerable#each_cons:\n\
    <code>", "  array = numbers.to_a\n  return [].tap do |result|\n    result.push(array.shift)\n\
    \    numbers.each do |number|\n      result.push(number) if number > result.last\n\
    \    end\n  end\nend\n</code>\n<|/ a dscore=4 |>\n<| a tags=ruby dscore=3 |>\n\
    I liked this one, but it has a bug, since it takes two arguments instead of one:\n\
    <code>", "    numbers.each_with_index do |n, i|\n        if numbers[i - 1] < n\n\
    \            numbers[i - 1]\n        end\n    end\nend", "  numbers = numbers.to_a\n\
    \  rolling = numbers.dup\n  rolling.compact!\n  rolling.rotate!\n  rolling[0]\
    \ = [numbers[0]]\n  rolling.each do |x|\n    if numbers[0] > x\n      rolling[0][0]\
    \ = numbers[0]\n      rolling.rotate!\n    end\n    rolling.shift!\n  end\n  rolling.flatten!\n\
    \  return rolling\nend", "  numbers.each do |number|\n    if rolling_max.call([number]\
    \ + [numbers[number-1]])\n      return number\n    end\n  end\nend", "  rolling_maxes\
    \ = []\n  rolling_max = 0", "  rolling_max_helper(numbers, 0)\nend", "  numbers.map!\
    \ do |num|\n    max = num\n    count = 0\n    until count == numbers.size - 1\n\
    \      max += numbers[count]\n      count += 1\n    end\n    max\n  end\n  numbers\n\
    end", "  return max_from_array(1, numbers)\nend", "  numbers.each_index.with_object([])\
    \ {|idx, memo| memo << numbers[idx] if numbers[idx] < numbers[idx].last }.max\n\
    end", '  rolling_maxes = Array.new', "  numbers.reduce(&:max)\nend", "    numbers.each_with_index.with_object([])\
    \ do |(n, i),a|\n        if i.odd? || n.zero?\n            a.last(n); a.last(n)\n\
    \        else\n            a.push(n); a.push(n); a.push(n)\n        end\n    end.max_by(&:first).last(3)\n\
    end\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThanks. I thought of that too,\
    \ but it is really not efficient. I was hoping for a solution that uses only core\
    \ library methods and that would be faster than my solution.\n<|/ c |>\n<| c |>\n\
    I added my solution for you based on your comment.\n<|/ c |>\n<| c |>\nThanks.\
    \ I didn't know about `each_with_index`. Very cool!\n<|/ c |>\n<| c |>\nI was\
    \ just thinking about this myself. It does look like a more efficient solution\
    \ than mine. I had to take off the `.first` from the last line of your `rolling_max`\
    \ method so that it didn't give the wrong results. Not sure why that is. Anyway,\
    \ this seems like an excellent answer.\n<|/ c |>\n<| c |>\nHmmm... Actually the\
    \ second one does a lot more. `rolling_max.call([1, 2, 3, 2, 3, 4, 2]) == [3,\
    \ 3, 3, 3, 3, 4, 4]` but `rolling_max.call([1, 2, 3, 2, 3, 4, 2]) == [3, 3, 3,\
    \ 4, 4, 3, 3]`\n<|/ c |>\n<| a |>\nIf you're looking for an answer that uses only\
    \ the core library, I suppose this is the closest you'll get with just arrays.\
    \ \n<code>", "  numbers.inject(0) { |max, element| max > element ? max : element\
    \ }\nend\n</code>\n<|/ a tags=arrays,ruby |>\n<| a dscore=1 tags=arrays,ruby |>\n\
    <code>\na = [1,2,3,4,5,6,7,8,9,10]\na.map do |x| a.reverse.shift x end", "  max_numbers\
    \ = numbers.dup\n  max_numbers.reverse_each do |n|\n    # Find a max index whose\
    \ number is smaller than n\n    idx = max_numbers.find_index { |x| x > n }\n \
    \   if idx\n      max_numbers.delete_at(idx)\n      # If the current index is\
    \ bigger than n, then replace the number\n      # at the index with n\n      if\
    \ max_numbers.last > n\n        max_numbers.delete_at(-1)\n      end\n    else\n\
    \      # If the current index is bigger than n, then append it to the\n      #\
    \ array\n      max_numbers.push(n)\n    end\n  end\n  max_numbers.reverse\nend",
  "  return [numbers[0...].max] + [numbers[0...-1].max] + numbers\nend", "  return\
    \ numbers.max{|a, b| b <= a}.to_a\nend\n</code>\nAnd you can use it like that:\n\
    <code>\nrolling_max.call([1, 2, 3, 2, 3, 4, 2])", "  rolling_max.call(numbers,\
    \ 0, numbers.size)\nend", "  max_size = numbers.max { |n| n }\n  rolling_array\
    \ = []\n  index = 0\n  until index == numbers.size or numbers[index] >= max_size\n\
    \    rolling_array << numbers[index]\n    index += 1\n  end\n  rolling_array.compact\n\
    end\n</code>\n<|/ a |>\n<| c |>\nNice implementation! Note that it generates N+1\
    \ copies of `rolling_max` instead of N+1 copies of `max` (and also N+1 copies\
    \ of `min`), but in real life it's likely that that isn't a big deal. :-)\n<|/\
    \ c |>\n<| c |>\nThanks J\xF6rg! Yes, it's also my fault that i didn't realize\
    \ that the min and max methods generate N+1 copies of themselves. :-)\n<|/ c |>\n\
    <| c |>\nThis implementation is also very efficient as it only uses one extra\
    \ array and a while loop.\n<|/ c |>\n<| c |>\nThis is a nice answer. One improvement\
    \ is that it could have returned a Range instead of a Array. An Array is mutable,\
    \ and that would break this code. Instead, `rolling_max` could return `rolling_max[0...numbers.size]`\
    \ as a Range object. The caller could do something like `rolling_max.to_a`. That\
    \ would allow the user to get the same results, but also get an immutable Array.\
    \ You'd have to do that anyway because `Range#each` returns the original Array\
    \ instead of an Array.\n<|/ c |>\n<| c |>\n`to_a` would create an intermediate\
    \ array, which would not be optimal. `Range#each` would still be an O(N) operation,\
    \ which is why it would be slower than the other solutions. You could write your\
    \ own `each` method on the `Range` class to return an `Array` instead, but that\
    \ would be a lot of work, and also less efficient.\n<|/ c |>\n<| a tags=ruby,arrays,max\
    \ |>\n<code>\nrequire 'benchmark'", "  numbers.reduce(&:+).rolling(4).max\nend\n\
    </code>\n<|/ a |>\n<| c |>\nThanks for the response! I actually implemented the\
    \ rolling max function but was looking for a way to implement it without using\
    \ an external gem. My goal was to solve this problem without using an external\
    \ gem (since I'm learning ruby by writing my own functions). Anyway, thanks for\
    \ the help!\n<|/ c |>\n<| c |>\nThis isn't an answer. Although I appreciate your\
    \ effort to provide a solution, I don't think it's an answer to what the question\
    \ is asking for. That's why I posted it as a comment, instead of posting an answer.\n\
    <|/ c |>\n<| c |>\nThe question was about implementing rolling max function in\
    \ pure ruby.\n<|/ c |>\n<| a tags=ruby |>\nI didn't know you could call methods\
    \ on any object in Ruby! Nice!\n<code>", "    rolling = numbers.shift\n    result\
    \ = numbers[0]\n    numbers.each do |n|\n        rolling > n ? rolling = n : nil\n\
    \        result < n ? result = n : nil\n    end\n    rolling\nend", "  numbers\
    \ = numbers.to_a\n  numbers = [number] unless numbers[0].is_a? Array\n  max =\
    \ numbers.shift\n  numbers.each do |n|\n    max = n if n < max\n  end\n  max\n\
    end", "  rolling_max =\n    if numbers.empty?\n      numbers.first\n    else\n\
    \      numbers.max { |a,b| a >= b ? a : b }\n    end\nend\n</cell>\n<cell>", "\t\
    numbers.each_with_index do |number,i|\n\t\tnumbers[i] = number\n\tend\n\tnumbers.each_with_index\
    \ do |number,i|\n\t\tnumbers[i] = numbers[i-1] + number\n\tend\n\tnumbers.max\n\
    end", "  rolling_max = 0\n  rolling_min = numbers[0]\n  rolling_max_index = 0\n\
    \  rolling_min_index = 0\n  numbers.each do |number|\n    if number > rolling_max\n\
    \      rolling_max = number\n      rolling_max_index = number_index\n    end\n\
    \    if number < rolling_min\n      rolling_min = number\n      rolling_min_index\
    \ = number_index\n    end\n  end\n  return [rolling_max, rolling_min, rolling_max_index,\
    \ rolling_min_index]\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby |>\nHere\
    \ is a simple way to do it:\n<code>", "  return numbers.max { |a, b| a <=> b }\n\
    end", "  numbers.each_with_index { |x, i|\n    if i > 0 && numbers[i-1] > x\n\
    \      numbers[i] = numbers[i-1]\n    end\n  }\nend", '  return [] if numbers.empty?',
  "  return array_reduce(numbers, :max)\nend", "  return numbers.reduce { |x, y| y\
    \ > x ? y : x }\nend", "  result = numbers[0]\n  numbers.each do |number|\n  \
    \  result < number ? result : number = number\n  end\n  result\nend", "  numbers\
    \ = numbers.dup\n  numbers.map {|n| n.to_i}.sort.last(numbers.count).to_a\nend",
  "  numbers.inject(0, :+).to_a.reverse\nend", "  rolling_max_number = 0\n  rolling_max_index\
    \ = 0\n  numbers.each_with_index do |number, index|\n    if number > rolling_max_number\n\
    \      rolling_max_number = number\n      rolling_max_index = index\n    end\n\
    \  end\n  return numbers[rolling_max_index]\nend", "  rolling_maxes = []\n  numbers.each\
    \ do |number|\n    if rolling_maxes.length == 0\n      rolling_maxes << number\n\
    \    else\n      rolling_maxes[rolling_maxes.size - 1] = number\n      break if\
    \ rolling_maxes[rolling_maxes.size - 1] >= number\n    end\n  end\n  rolling_maxes\n\
    end", "    \n    rolling_max = Array.new", "  numbers.reduce(:<<)\nend", "  numbers.each_cons(2).with_object([])\
    \ { |(first, second), result|\n    result << (first > second ? first : second)\n\
    \  }\nend", "  rolling_max = []\n  rolling_max.push(numbers[0])\n  numbers.each\
    \ do |number|\n    rolling_max.push(number) if number > rolling_max[-1]\n  end\n\
    \  rolling_max\nend\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| c |>\nThis was a\
    \ great help. I needed to return the rolling max from a method. I took out a couple\
    \ of lines and it works now. I appreciate the time you took to write this.\n<|/\
    \ c |>\n<| a dscore=1 tags=ruby |>\n<code>", '    rolling_max = numbers.shift',
  "  numbers.shift if numbers.empty?\n  numbers.shift while numbers.first != numbers.last",
  "  numbers.each_cons(2).max_by(&:last).map(&:first)\nend", "  numbers.each_with_index.inject(0)\
    \ do |max,(number,index)|\n    max = number > max ? number : max\n    max\n  end\n\
    end", "  rolling_maxes = numbers.dup\n  rolling_maxes.each do |number|\n    rolling_maxes[number]\
    \ = numbers[number]\n    rolling_maxes[number] = number if number > rolling_maxes[number]\n\
    \  end\n  rolling_maxes\nend", "  numbers = numbers.dup\n  numbers.shift\n  numbers.each\
    \ do |n|\n    numbers.unshift n if numbers[0] > n\n  end\n  numbers\nend\n</code>\n\
    <|/ a dscore=2 tags=algorithm,ruby,arrays,max |>\n<| a tags=algorithm,ruby,arrays,max\
    \ |>\n<code>", "  numbers.size.times { |i| numbers[i] = numbers[i].max if numbers[i].is_a?\
    \ Fixnum }\n  numbers\nend", "  return rolling_max(numbers.reverse)\nend\n</cell>\n\
    <code language=julia-1.0>\nusing Random", "  numbers.each { |n| yield n if yield_rolling_max_until(n).any?\
    \ }\nend", "  rolling_max = numbers.dup\n  rolling_max.each do |number|\n    rolling_max.shift\
    \ while number > rolling_max.first and rolling_max.first != 0\n    rolling_max[0]\
    \ = number\n  end\n  rolling_max\nend", "  numbers = Array.wrap(numbers).map(&:to_i)\n\
    \  numbers[0..-1].each_with_index.inject([numbers.min, numbers.max]) do |(max,\
    \ min), element|\n    min = (element < min) ? element : min\n    max = (element\
    \ > max) ? element : max\n    (element < min) ? min : max\n  end\nend", "  numbers.max\n\
    end\n</code></pre>\n<h2>\n<a id=\"user-content-the-basics\" class=\"anchor\" href=\"\
    #the-basics\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon\
    \ octicon-link\"></span></a>The Basics</h2>\n<p>Once you have a basic understanding\
    \ of JavaScript (you should, of course), you'll want to understand what arrays\
    \ are and how to use them.</p>\n<p>One of the most important concepts in JavaScript\
    \ is the array. JavaScript arrays are like Python lists, and can be multidimensional\
    \ (lists of lists).</p>\n<p>In this section, we'll explain how to create and access\
    \ arrays, and then work with two-dimensional arrays.</p>\n<h2>\n<a id=\"creating-an-array\"\
    \ class=\"anchor\" href=\"#creating-an-array\" aria-hidden=\"true\"><span aria-hidden=\"\
    true\" class=\"octicon octicon-link\"></span></a>Creating an Array</h2>\n<p>There\
    \ are two ways to make an array in JavaScript: Arrays and Objects. We'll describe\
    \ the differences between the two below.</p>\n<h2>\n<a id=\"using-arrays-to-describe-coordinates\"\
    \ class=\"anchor\" href=\"#using-arrays-to-describe-coordinates\" aria-hidden=\"\
    true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>Using\
    \ Arrays to Describe Coordinates</h2>\n<p>One of the most common uses of arrays\
    \ is for describing coordinates. For example, if we wanted to represent a site\
    \ coordinate in pixel coordinates, where x represents the horizontal axis and\
    \ y represents the vertical axis, we might represent this like an array with 2\
    \ elements, where the first element represents the x position (or longitude) and\
    \ the second element represents the y position (or latitude). As we saw in the\
    \ previous section, we can access an element in an array using square bracket\
    \ notation:</p>\n<pre class=\"highlight highlight-source-js\"><code>var xPosition\
    \ = coordinates[0];\nvar yPosition = coordinates[1];\n</code></pre>\n<p>We can\
    \ also use the <code>length</code> property to see how many elements are in the\
    \ array:</p>\n<pre class=\"highlight highlight-source-js\"><code>var xPosition\
    \ = coordinates.length;\nvar yPosition = coordinates.length;\n</code></pre>\n\
    <p>An important thing to note is that arrays in JavaScript are 0 indexed, meaning\
    \ that the first position (or element) in the array is at index 0.</p>\n<p>This\
    \ means that the first position (or element) in the array is at index 0. In our\
    \ previous example, the y position was at index 1, since arrays use zero-based\
    \ indexing.</p>\n<p>In addition to indexing arrays, JavaScript allows us to access\
    \ the individual elements within arrays as though they were properties of objects.\
    \ In other words, we can use <code>arrayName.propertyName</code> to access a specific\
    \ element of an array, where <code>arrayName</code> is the name of the array and\
    \ <code>propertyName</code> is the name of the property within that array.</p>\n\
    <p>Let's ", "  numbers.each { |n| return n if n.max == n }\n  numbers.last\nend",
  "  n = numbers.length - 1\n  rolling_max_numbers = []", "  numbers.each do |number|\n\
    \    yield number\n    break if number == numbers.last\n  end\nend", "  return\
    \ numbers.reduce(:+).downto(numbers.first || 0).map { |x| x }\nend", "  # Find\
    \ max and min numbers\n  min, max = numbers.minmax\n  # Initialize current maximum\
    \ element index\n  max_index = 0\n  # Initialize current maximum element value\n\
    \  max_value = numbers[max_index]\n  # Iterate over all numbers\n  numbers.each_with_index\
    \ do |value, index|\n    # If current max value is the same as current value,\
    \ skip current number\n    if value == max_value\n      next\n    else\n     \
    \ # Increment max element index\n      max_index += 1\n      # Set new max value\n\
    \      max_value = value\n    end\n    # If current element index is bigger than\
    \ max index, break and return max value\n    if index > max_index\n      max_index\
    \ = index\n      max_value = value\n      break\n    end\n  end\n  # Return max\
    \ element value\n  max_value\nend", "  return numbers.inject([]) do |max_num,\
    \ number|\n    max_num << number if number > max_num[-1]\n    max_num\n  end\n\
    end", '  rolling_max_numbers = []', "  numbers.each_cons(3).map { |a| a.reduce(&:max)\
    \ }\nend", "  maxs = Array.new\n  numbers.length.times do |i|\n    maxs[i] = numbers[i]\n\
    \  end if numbers\n  numbers.each do |number|\n    numbers[0...i].each do |max|\n\
    \      maxs[max] = number if number > maxs[max]\n    end\n  end\n  maxs\nend",
  "  rolling_max_numbers = []\n  rolling_max_numbers_count = 0\n  numbers.each do\
    \ |number|\n    if rolling_max_numbers.count <= rolling_max_numbers_count\n  \
    \    rolling_max_numbers << number\n      rolling_max_numbers_count += 1\n   \
    \ else\n      if rolling_max_numbers.last(number).nil? || rolling_max_numbers.last(number)\
    \ > number\n        rolling_max_numbers << number\n        rolling_max_numbers_count\
    \ += 1\n      end\n    end\n  end\n  rolling_max_numbers\nend", "  numbers.reduce(:+)\n\
    end", "  window = 1\n  max = numbers.first\n  numbers = numbers.drop(1)\n  numbers.each\
    \ do |number|\n    window = window + number\n    max = Math.max(max, window)\n\
    \  end\n  max\nend", "  result = numbers.dup.clone\n  rolling_max_count = 0\n\
    \  rolling_max_number = nil\n  numbers.each_index do |i|\n    rolling_max_count\
    \ += numbers[i]\n    rolling_max_number = numbers[i] if rolling_max_count > rolling_max_number\n\
    \    result[i] = rolling_max_number\n  end\n  return result\nend", "  rolling\
    \ = numbers[0..length]\n  numbers.size.times do |index|\n    if numbers[index]\
    \ == rolling\n      rolling += 1\n    else\n      rolling = numbers[index] \n\
    \    end\n  end\n  return rolling\nend\n</code>\n<|/ a |>\n<| a |>\n<code>", " \
    \ numbers.inject([numbers.first]) do |result, el|\n    result << el if el.max\
    \ < result[-1] || result.empty?\n    result << el.max if result.size < numbers.size\
    \ - 1 || el.max != result[-1]\n    result\n  end\nend\n</cell>\n<text>\nAs a bonus,\
    \ we could have used the Enumerable method each_cons to avoid repeating code,\
    \ like we did with the inject method.", "  numbers.each_cons(2) do |n, m|\n  \
    \  if n > m\n      n.next\n    else\n      m\n    end\n  end\nend\n</code>\nAnd\
    \ then we can just call it with:\n<code>\nrolling_max(array).take(4) #=> [1, 2,\
    \ 3, 3, 3, 4]\n</code>\n<|/ a tags=ruby,algorithm,ruby-on-rails |>\n<| a |>\n\
    This is another way:\n<code>", "  numbers.inject([]) do |max, number|\n    max\
    \ + [number] if number > max[-1]\n    max\n  end\nend", "  return [numbers.max]\
    \ * numbers.length\nend", "  min_element = numbers.min\n  numbers.each_with_index\
    \ do |number, i|\n    if number < min_element\n      min_element = number\n  \
    \  end\n    numbers[i] = min_element\n  end\n  numbers\nend", "  numbers.reverse.inject([])\
    \ do |rolling, number|\n    rolling << number unless rolling.last < number\n \
    \   rolling\n  end\nend", "  numbers.map { |n| n == numbers.max ? numbers.max\
    \ : n }\nend", "  numbers.inject(0) do |max, number|\n    max > number ? max :\
    \ number\n  end\nend", "  result = numbers.max\n  result = if numbers.empty? then\
    \ result else numbers.last\n  numbers.shift until numbers.first > result\n  numbers.shift\n\
    \  result\nend", "  results = []\n  numbers.each do |number|\n    results << number\
    \ if number > results.last\n  end\n  results\nend", "    max = numbers.first\n\
    \    rolling = []\n    rolling << max\n    numbers.each do |number|\n        rolling.last.max\
    \ < number ? rolling << number : rolling.last.max = number\n    end\n    rolling\n\
    end", "  numbers.each_cons(2) do |max|\n    max = max[-1]\n    rolling_max.call(max)\
    \ if rolling_max.call(max).length > 1\n  end.compact.flatten\nend", "  numbers.each.with_index.with_object([])\
    \ do |number, index|\n    result = []\n    while index > 0\n      result << numbers[index\
    \ - 1]\n      index -= 1\n    end\n    result << number\n  end\nend", "    rolling_max_window\
    \ = Array.new\n    @rolling_max_window << numbers.shift\n    numbers.each do |number|\n\
    \        if (number > @rolling_max_window.last)\n            @rolling_max_window.last\
    \ += 1\n        else\n            @rolling_max_window << number\n        end\n\
    \    end\n    @rolling_max_window\nend", "  numbers.reverse.each.with_index(1).with_object([])\
    \ { |e, i| i << e }\nend", "  rolling_max.max = []\n  rolling_max.index = -1\n\
    \  rolling_max.max.push(0)\n  rolling_max.max.push(numbers[0])\n  rolling_max.max.push(numbers[0])\n\
    \  rolling_max.max.push(numbers[0])\n  rolling_max.max.push(numbers[0])\n  rolling_max.max.push(numbers[0])",
  "  numbers.inject([numbers].max) { |max, n| max < n ? n : max }\nend", "  maximum\
    \ = numbers[0]\n  numbers.each do |number|\n    if number > maximum\n      maximum\
    \ = number\n    end\n  end\n  maximum\nend\n</code>\nThe code is self-explanatory,\
    \ I hope. Let's see if we can improve it using recursion.\n<code>", "  return\
    \ max_by(numbers, :last)\nend\n</code></pre>\n<h2>Ruby <code>instance_eval</code>\
    \ method</h2>\n<p>The <code>instance_eval</code> method is used to execute a block\
    \ of code that is defined within the current class or instance.</p>\n<pre class=\"\
    prettyprint source lang-rb\"><code># Get all posts with an association to a tag",
  "  max_list = []\n  numbers.each do |num|\n    if num > (max_list.last || 0)\n \
    \     max_list << num\n    end\n  end\n  max_list\nend", "  numbers.reduce do\
    \ |acc, number|\n    number > acc ? number : acc\n  end\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\n`numbers.reduce { |acc, n| n > acc ? n : acc }` can be written\
    \ as `numbers.max`\n<|/ c |>\n<| c |>\nNice, thanks. I didn't realize that existed.\
    \ Updated the answer.\n<|/ c |>\n<| a dscore=2 |>\nThis is one way to do it using\
    \ the Range class.\n<code>\nArray.new(5) {|i| i = rand(1..100) }.reverse + Array.new(5)\
    \ {|i| i = rand(1..100) }.reverse\n</code>\nThe above creates a random array of\
    \ the numbers 1-100 in reverse order. Then add 2 more random numbers to it in\
    \ reverse order.\n<|/ a tags=ruby |>\n<| a tags=ruby dscore=2 |>\nAnother way\
    \ to do it without creating an array and only using Array#sum:\n<code>\nArray.new(5)\
    \ {|i| i = rand(1..100) }.reverse.sum(&:+)\n</code>\n<|/ a |>\n<| a |>\nI made\
    \ some tests and found a solution based on some benchmarks that I found.\n<code>",
  "  numbers.each { |number| rolling_max_array.push(number) if number > rolling_max_array.last\
    \ }\n  rolling_max_array\nend", "  # Find the maximum element\n  max = numbers.shift\n\
    \  # For each element, find its cumulative sum\n  numbers.each { |n| max = [max,\
    \ n + max].max }\n  max\nend", "  numbers.shift while numbers.first && numbers.first\
    \ < 0\n  numbers.shift\n  result = numbers.last\n  numbers.shift\n  numbers.shift\
    \ while numbers.first && numbers.first < 0\n  numbers.shift\n  until numbers.empty?\
    \ do\n    result = result > numbers.first ? result : numbers.first\n    numbers.shift\n\
    \    numbers.shift while numbers.first && numbers.first < 0\n    numbers.shift\n\
    \  end\n  return result\nend", "    numbers.each_with_index.with_object([]) do\
    \ |number, rolling_max|\n        rolling_max << number if (rolling_max.last <\
    \ number && rolling_max.empty?)\n        rolling_max << number\n    end\nend\n\
    </code>\nIf you want a solution that uses only a single array, you can change\
    \ the above code to this:\n<code>", "  return numbers.max{|a, b| a > b ? a : b}\n\
    end\n</code>\nThe method .call allows you to pass an argument to a method as a\
    \ block.\n<|/ a tags=ruby,arrays,algorithm,arrays |>\n<| a tags=ruby,arrays,algorithm,arrays\
    \ |>\nAs an exercise in recursion, the following is a working solution:\n<code>",
  "  numbers.size.times do |i|\n    max = numbers[i]\n    numbers.each_index do |j|\n\
    \      if numbers[j] > max\n        max = numbers[j]\n      end\n    end\n   \
    \ numbers[i] = max\n  end\n  return numbers\nend", "\tnumbers.each_with_index\
    \ do |number,index|\n\t\tnumbers.rotate(index).max << number\n\tend\nend", " \
    \ numbers = numbers.to_a\n  rolling_max = nil", "  numbers.max_by(&:itself)\n\
    end", "  sorted_numbers = numbers.sort\n  rolling_max = sorted_numbers.first",
  "    numbers.reduce(:+)\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,ruby-on-rails\
    \ dscore=0 |>\nI've been using this one:\n<code>", "\tnumbers.each { |x| @array_max\
    \ << x if x < @array_max[-1] } if @array_max.any?\n\t@array_max.max\nend", " \
    \ rolling_max_value = numbers.shift\n  numbers.each do |num|\n    rolling_max_value\
    \ = num if num > rolling_max_value\n  end\n  rolling_max_value\nend", "  return\
    \ array_helper.rolling_max(numbers)\nend", "  numbers, roll_max = numbers.dup,\
    \ []\n  numbers.each do |number|\n    roll_max << number if roll_max.last >= number\
    \ && roll_max.last != number\n  end\n  roll_max\nend", "    numbers.each_with_index.inject(0)\
    \ do |max, (number, i)|\n        max < number ? max : number\n    end\nend", " \
    \ numbers_max = numbers.max\n  numbers.each_with_index { |n, i|\n    numbers.slice!(0,\
    \ i).unshift(n) if numbers.last >= n\n  }\n  numbers.max! { |n| numbers_max if\
    \ numbers_max < n }\n  numbers\nend\n</code>\n<|/ a |>\n<| c |>\nI like this solution!\
    \ The idea of using max was good, but I kept thinking about it more and made a\
    \ mistake with `slice!`. Thank you for the tip about `shift!`!\n<|/ c |>\n<| c\
    \ |>\nThis solution does not seem to be working on edge cases where the maximum\
    \ number has multiple occurrences. E.g. `rolling_max.call([2, 4, 4, 2, 2, 3])`\
    \ returns `[2, 4, 2, 2, 3, 3]`.\n<|/ c |>\n<| c |>\nThat's right. My initial tests\
    \ showed that when you have multiple occurrences the last occurrence takes precedence.\
    \ I'll fix the answer.\n<|/ c |>\n<| a tags=arrays,ruby,algorithm |>\nHere is\
    \ a way without recursion: It generates the maximum of the minimum of an array\
    \ and its tail:\n<code>", "  numbers.inject([]) {|memo, num| memo << num if memo.length\
    \ < numbers.size && num < memo[memo.size-1]; memo << num}\nend", "  numbers.inject(0)\
    \ do |max, el|\n    max.nil? ? el : el > max ? el : max\n  end\nend", "  max_number\
    \ = 0\n  rolling_max_number = nil\n  numbers.each do |number|\n    if number >\
    \ max_number\n      rolling_max_number = max_number\n    end\n    max_number =\
    \ number if number > rolling_max_number\n  end\n  rolling_max_number\nend", " \
    \   numbers = numbers.sort_by { |n| -n }\n    numbers[-1..-1].map { |x| x }.reduce(:<<)\n\
    end", "  return [] if numbers.empty?\n  roll_max = numbers.max_by(&:last).last\n\
    \  numbers[0...-1].map { |n| n.max { |a, b| (a.last > roll_max) && (b.last > roll_max)\
    \ ? (a.last <= b.last) ? a : b : roll_max } }\nend", "  return numbers.inject([nil])\
    \ do |result, (number, acc)|\n    acc == nil ? [number] : acc[0] > number ? [number,\
    \ acc[0]] : [number, acc[0]]\n  end\nend\n</code>\n<|/ a dscore=2 tags=ruby |>\n\
    <| c |>\nI like the use of `inject` here, and it works perfectly. Thank you.\n\
    <|/ c |>\n<| a dscore=2 tags=ruby |>\nThis answer is inspired by MrYoshiji's answer\
    \ (which I upvoted) but with some refactoring to make it more idiomatic.  It also\
    \ avoids having to use .call so you might consider this a little \"hacky\" but\
    \ it's very readable and performant for most cases:\n<code>", "  array.each do\
    \ |number|\n    numbers.shift\n    break number if number > numbers[-1]\n    numbers[-1]\
    \ = number\n  end\nend", "  max_values = [numbers.shift]\n  numbers.each do |number|\n\
    \    max_value = max_values.shift\n    max_value += number\n    max_values <<\
    \ max_value\n  end\n  max_values.shift\nend", "  return rolling_sum(numbers, :max)\n\
    end", "    numbers.reverse.inject([0]) do |rolling_max, number|\n        rolling_max[0]\
    \ = max(rolling_max[0], number)\n        rolling_max\n    end\nend", "  rolling_max.max_index\
    \ = nil\n  rolling_max.max = nil\n  numbers.each_index do |i|\n    if i > 0 and\
    \ numbers[i - 1] > numbers[i]\n      rolling_max.max = numbers[i]\n      rolling_max.max_index\
    \ = i\n    end\n  end\n  return rolling_max.max_index\nend", "  rolling_max_array\
    \ = Array.new\n  numbers.each do |number|\n    rolling_max_array << number\n \
    \   rolling_max_array << number\n  end\n  return rolling_max_array\nend", "  \
    \  numbers.each do |number|\n        numbers.each { |num| yield num if num > number\
    \ }\n    end\nend", "  return numbers.reduce(:<<)\nend", "  rolling_max_calculator\
    \ = ->(numbers, window, min_max) do\n    min_max_indexes = calculate_min_max_indexes(numbers,\
    \ window, min_max)\n    max_length = min_max_indexes[min_max][2]\n    min_max\
    \ = (min_max == :left) ? :right : :left\n    min_max_indexes.map do |min_max_index|\n\
    \      numbers[min_max_index[0]][min_max_index[1] + 1]\n    end.max\n  end\n \
    \ min_max_indexes = calculate_min_max_indexes(numbers, window, :right)\n  min_max_indexes[min_max][2]\n\
    end", "  rolling_max_array.call(numbers)\nend", "  numbers.reduce(:<<) do |rolling,\
    \ number|\n    rolling > number ? rolling : number\n  end\nend", "  numbers.reduce(:+)\n\
    end", "  numbers.each_with_object([]) do |n, array|\n    array << n if n < array.max\n\
    \    array << n if n < array.max && n < array.max-1\n    array << n if n < array.max\
    \ && n < array.max-2\n    array << n if n < array.max && n < array.max-3\n   \
    \ array << n if n < array.max && n < array.max-4\n    array << n if n < array.max\
    \ && n < array.max-5\n    array << n if n < array.max && n < array.max-6\n  end\n\
    end", "  numbers.shift if numbers.length == 0 || numbers.first.is_a?(Numeric)\n\
    \  numbers.reduce(:+)\nend", "  numbers.size.times.collect { |i| numbers.first\
    \ + (numbers.size - i - 1).times.reduce(:+) }\nend", "    numbers.reduce(:<=)\
    \ ? numbers : nil\nend\nmodule_function :rolling_max", "  numbers.inject(0, :+).tap\
    \ do |max|\n    numbers[0..-1].each do |value|\n      max = value if value > max\n\
    \    end\n    max\n  end\nend", "    rolling = []\n    numbers.each { |num|\n\
    \        rolling.append(num)\n        if rolling.length > 3\n            rolling.pop\n\
    \        end\n    }\n    return rolling\nend", "  numbers.inject([numbers], :max)\n\
    end", "  numbers.each_cons(2) do |pairs|\n    rolling_max = pairs.max\n    rolling_max.nil?\
    \ ? pairs : [rolling_max, pairs.min]\n  end\nend", "  max_values = []\n  numbers.each\
    \ do |number|\n    number = number.to_i\n    max = number\n    max_values.each\
    \ do |m|\n      next if m == max\n      if m * number > max\n        max = m *\
    \ number\n      end\n    end\n    max_values << max\n  end\n  max_values\nend",
  "\tnumbers = numbers.to_a\n\trolling_max = []", "  maxes = []\n  numbers.each {\
    \ |e|\n    maxes.push(maxes.last + e) unless maxes.empty? and maxes[-1] < e\n\
    \  }\n  return maxes\nend", "  result = []\n  numbers.each do |number|\n    result\
    \ << number if number > result.last\n    result << number if number > result.last\n\
    \  end\n  return result\nend", "  return numbers.each_cons(2) do |arr|\n    arr[-2..-1].max.with_index\
    \ { |e, i| arr[i] }\n  end\nend", "  numbers.collect{|x|x}.max\nend", "  rolling_max\
    \ = []\n  numbers.each do |num|\n    rolling_max << num if rolling_max.last >=\
    \ num\n  end\n  rolling_max\nend", "  return numbers.max if numbers.size > 0 then\
    \ numbers.max() else nil\nend", "  numbers.each_with_index do |n, i|\n    min\
    \ = nil\n    max = i\n    numbers.each_with_index do |j|\n      if (j > i && j\
    \ > n) || (j < i && j < n)\n        if (j > max)\n          max = j\n        end\n\
    \      end\n    end\n    numbers[i] = max\n  end\n  numbers\nend", "    numbers.inject([numbers.first])\
    \ do |max, number|\n        max.nil? || number > max ? number : max\n    end\n\
    end", "  n = numbers.count\n  if n.zero?\n    n = 1\n  rolling_max_array = [numbers.first]\n\
    \  numbers.each_cons(n) do |number|\n    rolling_max_array << number if number\
    \ > rolling_max_array.last\n  end\n  return rolling_max_array\nend", "  numbers.each_with_index\
    \ do |element, position|\n    if position == 0\n      maximum = element\n    else\n\
    \      if element > maximum\n        maximum = element\n      end\n    end\n \
    \ end\n  maximum\nend", "  return if numbers.empty?\n  numbers = numbers.to_a\n\
    \  return numbers if numbers.size == 1\n  last_numbers = numbers.last(numbers.size/2).reverse\n\
    \  max_numbers = numbers[numbers.size-numbers.size/2-2]\n  max_numbers = max_numbers\
    \ if max_numbers.any?\n  max_numbers = max_numbers.max\n  numbers[numbers.size-2]\
    \ = max_numbers\n  numbers.compact!\n  numbers.reverse!\n  numbers.map!\nend",
  "    numbers.reduce do |max_val, el|\n        if el > max_val\n            max_val\n\
    \        else\n            el\n        end\n    end\nend", "  return rolling_max(numbers,\
    \ 0, numbers.size)\nend", "  window = []\n  max_element = nil\n  numbers.each\
    \ do |number|\n    window << number\n    if number > max_element\n      max_element\
    \ = number\n    end\n  end\n  window\nend", "  numbers.reduce(:<<)\nend", "  return\
    \ numbers & (numbers - 1)\nend", "  return numbers.inject([]) do |max, elem|\n\
    \    max << elem\n    max = max if elem > max[-1]\n    max << max[-1]\n    max\n\
    \  end\nend", "  rolling = Enumerator.new do |y|\n    numbers.each_index do |i|\n\
    \      y << numbers[i]\n      y << numbers[(i + numbers.size - 1) % numbers.size]\n\
    \    end\n  end || []\n  rolling.find do |item|\n    item > numbers.last\n  end\n\
    end", "  return numbers.reduce(:+)\nend", "  numbers.each do |number|\n    numbers.shift\n\
    \    number == numbers.max ? number : number\n  end\nend", "\tmin_number = numbers.min\n\
    \tnumbers.shift\n\trolled = 0\n\twhile numbers.any?\n\t\tif numbers.last > min_number\n\
    \t\t\trolled += 1\n\t\tend\n\t\tnumbers.shift\n\tend\n\trolled\nend", "  numbers.inject([[]])\
    \ do |max, number|\n    if max and number > max[-1]\n      max[-1]\n    else\n\
    \      max[-1] = number\n      max\n    end\n  end\nend\n</cell>\n<cell>", " \
    \ rolling_max_counts = Hash.new(0)\n  numbers.each do |number|\n    rolling_max_counts[number]\
    \ += 1\n  end\n  rolling_max_numbers.concat(rolling_max_counts.keys.sort.reverse)\n\
    \  rolling_max_values.concat(rolling_max_counts.values.sort.reverse)\nend", " \
    \ maximum = numbers[0]\n  numbers.each_index do |i|\n    maximum = maximum if\
    \ numbers[i] > maximum\n  end\n  maximum\nend", "  rolling_max = numbers.dup\n\
    \  rolling_max.shift while rolling_max.last.nil? \n  \n  rolling_max.reverse.each\
    \ do |n|\n    if n\n      rolling_max.shift\n      rolling_max.last << n\n   \
    \   break\n    end\n  end\n  \n  rolling_max\nend", "  # Define a new array with\
    \ the same length as numbers array (without the last element),\n  # with the new\
    \ element filled with \"None\"\n  # The new array is going to store maximum elements\n\
    \  new_numbers = []\n  new_numbers.concat numbers[0..-2]\n  new_numbers.concat\
    \ [0]", "  rolling = numbers.reduce([nil, []]) do |max, current|\n    max.last\
    \ < current ? [max, current] : [max, current.last]\n  end\n  rolling.first\nend",
  "    index = numbers.size - 1\n    max = numbers[0]", "  array = []\n  array.concat\
    \ numbers.drop(1)\n  array.concat numbers.drop(1).map { |number| numbers[numbers.size-1]\
    \ }\nend", "  max_number = 0\n  max_index = 0\n  numbers[max_index] = numbers[0]\n\
    \  numbers.each_with_index do |number, index|\n    if number > max_number\n  \
    \    max_number = number\n      max_index = index\n    end\n  end\n  numbers.rotate!\n\
    \  numbers.max_by { |number| number }\nend\n</cell>\n<code language=julia-1.0>",
  '  rolling_max = numbers.dup', "  # Find the minimum element\n  min = numbers[0]\n\
    \  # Get the indices of all elements smaller than min\n  indices = numbers[numbers.index(min):]\n\
    \  # Find the minimum element\n  min = numbers.min\n  # For each element in the\
    \ indices list\n  indices.each do |index|\n    # Get the element at that index\n\
    \    value = numbers[index]\n    # If the value is the minimum\n    if value ==\
    \ min\n      # Remove the minimum element from the indices list\n      indices.delete(index)\n\
    \    end\n  end\n  # Recusive call for remaining elements after removing element\
    \ at first index\n  numbers.delete(min)\n  numbers.zip(indices).inject(:+)\nend",
  "  max = 0\n  max_element = nil\n  numbers.each do |number|\n    if number > max\
    \ \n      max = number\n      max_element = number\n    end\n  end\n  return max_element\n\
    end", "  numbers.each_cons(2) do |first, second|\n    if second < first then\n\
    \      yield first\n    end\n  end\nend", "  rolling_max = numbers[0..numbers.size\
    \ - 1]\n  numbers.each_index { |i| rolling_max << numbers[i] }\n  rolling_max\n\
    end", "  return numbers.each_cons(2).map { |a, b| b || a }\nend", "  # Convert\
    \ the given number to an array.\n  # >>> rolling_max.call([1, 3, 6, 3, 7, 4, 6])\n\
    \  # [1, 3, 6, 3, 7, 4, 6]\n  numbers = Array(numbers).map(&:to_i)\n  # Define\
    \ a range of numbers for which the rolling max will be calculated.\n  window_size\
    \ = (numbers.length-1) * 4 + 1\n  # Initialize an array to store the result.\n\
    \  result = Array.new(window_size)\n  # Calculate the rolling max for each window\
    \ starting from the first one.\n  numbers.each_index.with_index(1) { |i, index|\
    \ result[index] = rolling_max(numbers[i...i+4]) }\n  # Return the result.\n  result\n\
    end", "  # Return nil if given nil array\n  return nil if numbers.nil? || numbers.empty?\n\
    \  # Initialize rolling max to first element in the given array.\n  rolling_max\
    \ = numbers.shift\n  numbers.each do |number|\n    rolling_max = number if number\
    \ > rolling_max\n  end\n  rolling_max\nend\n</code>\n<|/ a |>\n<| a dscore=3 |>\n\
    As pointed out by others, Ruby does have Array#min_by and Array#max_by methods\
    \ which would help us solve the problem of finding the min and max values of a\
    \ given array.\n<code>\n[7, 9, 2, 5, 8, 4].min_by { |a| a } # => 2\n[7, 9, 2,\
    \ 5, 8, 4].max_by { |a| a } # => 8\n</code>\nAs long as we have the same number\
    \ of elements in each of the arrays, we can do some math magic to find the min\
    \ and max values using Array#min_by and Array#max_by\n<code>\n[7, 9, 2, 5, 8,\
    \ 4].min_by { |a| a } * (-1) ** ([1, 2, 3, 4].count { |a| a == [7, 9, 2, 5, 8,\
    \ 4].min_by { |a| a } })", "  numbers.length.times do |i|\n    numbers[i] = numbers[i].max\n\
    \  end", "  numbers.reverse.inject(0) do |max, number|\n    max.nonzero? && number\
    \ > max[max.length - 1] ? number : max\n  end\nend", "  numbers ? rolling_max_with(numbers.shift,\
    \ numbers, numbers.length) : nil\nend", "  numbers.each_with_object([]) do |number,\
    \ memo|\n    memo << number if number > memo[-1]\n  end\nend", "  numbers.max\n\
    end", "  result = []\n  numbers.each_index do |i|\n    result.push(numbers[i])\n\
    \    if numbers[i] != numbers.last\n      result.push(numbers[i + 1])\n    end\n\
    \  end\n  result\nend", "  return numbers.reduce(:+)\nend", "  numbers = Array.wrap(numbers)\n\
    \  numbers[0, numbers.length - 1].each do |value|\n    index = numbers.length\
    \ - 1\n    while (index > 0) and (numbers[index - 1, numbers.length - 2] < value)\n\
    \      numbers[index, numbers.length - 1] = numbers[index - 1, numbers.length\
    \ - 1]\n      index -= 1\n    end\n  end\n  numbers.to_a\nend", "  numbers.reduce(:<<).tap\
    \ do |max|\n    numbers.find { |n| max < n && n != 0 } ? max : 0\n  end\nend\n\
    </code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| a tags=ruby,ruby-on-rails |>\nI\
    \ have another one to consider.\n<code>", "  numbers.inject([numbers.shift]) do\
    \ |max, element|\n    max > element ? max : element\n  end\nend\n</code>\n<|/\
    \ a tags=arrays,ruby |>\n<| a tags=arrays,ruby |>\nIf you don't mind installing\
    \ ruby-prof, you can simply use RubyProf to accomplish this. It will show you\
    \ the max and min, as well as standard deviation if you want, and give you the\
    \ average and median too!\n<|/ a dscore=2 |>\n<| c |>\nThis should be the top\
    \ answer. It has many nice features, including  very detailed breakdown of execution\
    \ times and memory allocations. Much appreciated for introducing this new gem\
    \ to me!\n<|/ c |>\n<| a tags=arrays,ruby |>\nIf you need to roll your own without\
    \ using ruby-prof, you can do something like this (using ruby 1.9):\n<code>",
  "  rolling = 0\n  numbers.each do |number|\n    rolling = number > rolling ? number\
    \ : rolling\n  end\nend", "  numbers.each_cons(2).map { |a, b| b }.reduce(:+)\
    \ == 0 ? numbers.first : numbers[numbers.each_cons(2).map { |a, b| b }.reduce(:+)]\n\
    end\n</code>\n<|/ a |>\n<| a dscore=2 |>\n<code>", "  numbers.each_with_index.map\
    \ {|x, i| [x, numbers[(i+1).succ]]}.sort_by {|e| -e[1][0]}.first\nend\n</code>\n\
    <|/ a tags=ruby,algorithm |>\n<| c |>\nThanks for this. But it seems slow when\
    \ you have few few elements in an array.\n<|/ c |>\n<| c |>\nIt shouldn't be slow,\
    \ it is just O(n), and it doesn't require the elements be sorted.\n<|/ c |>\n\
    <| c |>\nIt is O(n) because it uses `each_with_index`, which is O(n).\n<|/ c |>\n\
    <| c |>\nI wouldn't say it is O(n), but it's `O(n)` because `each_with_index`\
    \ is O(n). I agree that this solution is more expressive and easier to read, but\
    \ it's still `O(n)`.\n<|/ c |>\n<| a tags=ruby,algorithm |>\nHere's a simple O(n\
    \ log n) solution. Sort by the current max value, then by ascending index, then\
    \ by descending index. Iterate that sequence to find the current max value, and\
    \ you're done. \n<code>", "  numbers.shift if numbers.empty? # Remove the value\
    \ at index 0\n  rolling_max_elements = []\n  rolling_max_element = numbers.shift\n\
    \  numbers.each_with_index do |number, index|\n    rolling_max_elements << rolling_max_element\
    \ if number > rolling_max_element\n    rolling_max_element = number if number\
    \ == rolling_max_element\n  end\n  rolling_max_elements\nend", "  rolling_max_numbers\
    \ = []\n  rolling_max_numbers_index = 0\n  rolling_max_element = nil", "  return\
    \ numbers.reduce(:<<).tap do |result|\n    result.unshift(result[0])\n  end\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| c |>\nWow, that's a great answer. I'm going\
    \ to give it a try. Thanks!\n<|/ c |>\n<| c |>\nHow would I go about doing this\
    \ in Ruby? I understand that `inject` and `reduce` are methods available to all\
    \ objects in Ruby objects, but I don't see a way to implement them in plain Ruby\
    \ code.\n<|/ c |>\n<| c |>\nWhat is `<<` doing in front of `reduce`?\n<|/ c |>\n\
    <| c |>\n`<<` pushes new element\n<|/ c |>\n<| c |>\nIt seems Ruby has a method\
    \ for doing this, but its behavior is different than `inject` and `reduce`.  How\
    \ could I use `<<` in my example above to get the same result?\n<|/ c |>\n<| a\
    \ |>\nI've been working on a library to solve this very problem.\nIt solves many\
    \ of the edge cases of rolling averages, like when all input numbers are negative\
    \ or all numbers are zero.\nThe library is available on rubygems.\n<|/ a tags=arrays,ruby,math\
    \ dscore=4 |>\n<| c |>\nNice library, but I'd like to add that I got this error\
    \ when trying to use it: \"`undefined method << for nil:NilClass`\"\n<|/ c |>\n\
    <| c |>\nSorry, I forgot to add this - I fixed the problem.\n<|/ c |>\n<| c |>\n\
    Looks great. Do you have a link to the documentation?\n<|/ c |>\n<| c |>\n- Unfortunately\
    \ the code is now published as a separate gem on rubygems.org and no longer available\
    \ as a gem. It's very old and out of date. Hopefully it will be updated soon,\
    \ but in the mean time here is a link to github: https://github.com/joelfong/rolling_average\n\
    <|/ c |>\n<| c |>\nAwesome! Can you please add an example of how to use it? What\
    \ are the inputs?\n<|/ c |>\n<| a |>\nI think you can use inject and reduce to\
    \ solve this problem:\n<code>", "    numbers.pop\n    numbers.shift\n    numbers.length\
    \ = numbers.length.to_i\n    numbers.sort!", "  return [numbers.max]\nend", " \
    \ result = numbers.dup\n  numbers.each do |number|\n    rolling_max_until(result,\
    \ number)\n  end\n  result\nend", "  numbers.reduce(:+)\nend", "  numbers = numbers.sort\n\
    \  rolling_max = []\n  rolling_max.push(numbers[0])\n  i = numbers.size - 1\n\
    \  while (i >= 1)\n    if numbers[i] >= rolling_max[-1]\n      rolling_max.push(numbers[i])\n\
    \    end\n    i--\n  end\n  rolling_max.pop\nend", "  numbers[0, numbers.size]\
    \ = 0\n  numbers.each_cons(2) do |number, max_number|\n    numbers[0] = number\n\
    \    numbers[1] = max_number\n    if numbers[0, numbers.size] > numbers[1]\n \
    \     numbers[1, numbers.size] = numbers[0, numbers.size]\n    end\n  end\n  numbers\n\
    end", "  rolling_max.value = numbers.dup\n  rolling_max.index = 0\n  rolling_max.value\
    \ = nil\n  rolling_max.last_max = 0\n  rolling_max.last_max_index = nil\n  rolling_max.each_index\
    \ do |i|\n    rolling_max.value[i] = numbers[i]\n    if i > 0 && rolling_max.value[i\
    \ - 1].to_i > numbers[i].to_i\n      rolling_max.last_max = numbers[i]\n     \
    \ rolling_max.last_max_index = i\n    end\n  end\nend", "  return [numbers[0]]\
    \ if numbers.size == 1\n  rolling_max_size = numbers.size - 1\n  numbers.each\
    \ { |number|\n    if number > numbers[rolling_max_size]\n      rolling_max_size\
    \ -= 1\n    end\n    rolling_max_size += 1 \n  }\n  numbers.map { |number| numbers[rolling_max_size]\
    \ }\nend", "  numbers.each do |number|\n    numbers.shift\n    numbers.shift while\
    \ number > numbers.max\n  end\nend", "\trolling_max_numbers = []\n\tnumbers.each\
    \ do |number|\n\t\trolled = number.times.map { |i| number[(i + 1)..-1].max }.min\n\
    \t\trolling_max_numbers << rolled\n\tend\n\trolling_max_numbers\nend\n</cell>\n\
    <cell>", "  numbers.each_with_index.map do |number, index|\n    number.call if\
    \ index < numbers.size / 2\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nThis seems\
    \ wrong in multiple ways. 1. It iterates over all possible indices every time,\
    \ not just the highest and lowest 2. You don't need `.each`. 3. Your `each_with_index`\
    \ will iterate over all elements, even after an index has already been checked.\
    \ 4. You don't return after finding the first occurrence of a max number, but\
    \ then still iterate through the rest of the array. 5. This only works if you\
    \ know the size of the array ahead of time, and it requires multiple passes through\
    \ the array to find the highest and lowest number in the array.\n<|/ c |>\n<|\
    \ c |>\nHi Brandon, thanks for your comment. I have edited my answer, please see\
    \ if it is clearer now. I think the issue is that I did not explain the function\
    \ well in the first place, since the question was originally about using 'reduce',\
    \ which I don't think was the main goal.\n<|/ c |>\n<| a dscore=2 |>\nHere's a\
    \ solution that doesn't require a loop:\n<code>\nnumbers.reduce([]) do |result,\
    \ number|\n  result << number if number > numbers.max\n  result << number if number\
    \ < numbers.min\n  result\nend\n</code>\nBut it's less readable, and likely to\
    \ be slower than a loop, and I don't think it's very efficient. The loop is simply\
    \ hidden in a single line.\n<|/ a tags=ruby,algorithm,arrays |>\n<| c |>\nThe\
    \ loop isn't hidden. `numbers.reduce([]) { |result,number| ... }` is one line,\
    \ `numbers.reduce([]) { |result, number| ... }` is another. I'd say it's *more*\
    \ readable.\n<|/ c |>\n<| c |>\nYes, I agree that `numbers.reduce([]) { |result,\
    \ number| ... }` is more readable, and that it's slightly more efficient. The\
    \ loop is just hidden.\n<|/ c |>\n<| c |>\nI would say it's more readable in terms\
    \ of code readability, and slightly more efficient (at least on first sight at\
    \ least). The loop is hidden because it's not immediately obvious what it's doing.\n\
    <|/ c |>\n<| a |>\nHere's an even shorter solution:\n<code>\n(numbers.reverse.detect\
    \ { |num| num == numbers.max }).next\n</code>\nBut this is just an alternative.\n\
    <|/ a dscore=2 tags=ruby,algorithm,arrays |>\n<| c |>\nIt's a little more efficient\
    \ to reverse the entire array, and then to just find the first element "]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
