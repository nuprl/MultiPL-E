language: swift
name: HumanEval_59_largest_prime_factor
results:
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 1\n    var i = 2\n    while i * i <= n {\n        if n\
    \ % i == 0 {\n            largest_prime = i\n            n /= i\n        } else\
    \ {\n            i += 1\n        }\n    }\n    if n > 1 {\n        largest_prime\
    \ = n\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime_factor = 1\n    while n % 2 == 0 {\n        largest_prime_factor\
    \ = 2\n        n /= 2\n    }\n    var i = 3\n    while i <= n {\n        if n\
    \ % i == 0 {\n            largest_prime_factor = i\n            n /= i\n     \
    \   } else {\n            i += 2\n        }\n    }\n    return largest_prime_factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime_factor = 2\n    while n % 2 == 0 {\n        n /= 2\n    }\n\
    \    var i = 3\n    while i <= Int(sqrt(Double(n))) {\n        while n % i ==\
    \ 0 {\n            n /= i\n            largest_prime_factor = i\n        }\n \
    \       i += 2\n    }\n    if n > 2 {\n        largest_prime_factor = n\n    }\n\
    \    return largest_prime_factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmph_3cat84.swift:14:20: error: cannot find 'sqrt' in scope\n    while\
    \ i <= Int(sqrt(Double(n))) {\n                   ^~~~\n"
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 1\n    var i = 2\n    while i * i <= n {\n        if n\
    \ % i == 0 {\n            largest_prime = i\n            n /= i\n        } else\
    \ {\n            i += 1\n        }\n    }\n    if n > 1 {\n        largest_prime\
    \ = n\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    return 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: Exception
  stderr: 'tmpopjsynk8/tmpopjsynk8.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9331c6ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9331965b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9331965988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b93319647b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpopjsynk8                        0x000055b5379d71b5 <unavailable> + 4533

    5    libc.so.6                          0x00002b9331e5a460 __libc_start_main +
    245

    6    tmpopjsynk8                        0x000055b5379d6e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while factor * factor <= n {\n        if n % factor ==\
    \ 0 {\n            n /= factor\n        } else {\n            factor += 1\n  \
    \      }\n    }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime_factor\
    \ = 0\n    var n = n\n    var i = 2\n    while i * i <= n {\n        if n % i\
    \ == 0 {\n            largest_prime_factor = i\n            n /= i\n        }\
    \ else {\n            i += 1\n        }\n    }\n    if n > 1 {\n        largest_prime_factor\
    \ = n\n    }\n    return largest_prime_factor\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 1\n    var i = 2\n    while i <= n {\n        if n % i\
    \ == 0 {\n            largest_prime = i\n            n /= i\n        } else {\n\
    \            i += 1\n        }\n    }\n    return largest_prime\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime\
    \ = 1\n    var n = n\n    while n % 2 == 0 {\n        largest_prime = 2\n    \
    \    n /= 2\n    }\n    var factor = 3\n    while n > 1 {\n        while n % factor\
    \ == 0 {\n            largest_prime = factor\n            n /= factor\n      \
    \  }\n        factor += 2\n    }\n    return largest_prime\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest = 0\n    var i = 2\n    while i * i <= n {\n        if n % i ==\
    \ 0 {\n            largest = i\n            n /= i\n        } else {\n       \
    \     i += 1\n        }\n    }\n    if n > 1 {\n        largest = n\n    }\n \
    \   return largest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime_factor = 1\n    var i = 2\n    while i <= n {\n        if\
    \ n % i == 0 {\n            largest_prime_factor = i\n            n /= i\n   \
    \     } else {\n            i += 1\n        }\n    }\n    return largest_prime_factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime_factor = 1\n    var i = 2\n    while i * i <= n {\n     \
    \   if n % i == 0 {\n            largest_prime_factor = i\n            n /= i\n\
    \        } else {\n            i += 1\n        }\n    }\n    if n > 1 {\n    \
    \    largest_prime_factor = n\n    }\n    return largest_prime_factor\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 1\n    var i = 2\n    while i <= n {\n        if n % i\
    \ == 0 {\n            largest_prime = i\n            n /= i\n        } else {\n\
    \            i += 1\n        }\n    }\n    return largest_prime\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 1\n    while n % 2 == 0 {\n        largest_prime = 2\n\
    \        n /= 2\n    }\n    var i = 3\n    while i <= n {\n        if n % i ==\
    \ 0 {\n            largest_prime = i\n            n /= i\n        } else {\n \
    \           i += 2\n        }\n    }\n    return largest_prime\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime_factor = 1\n    var factor = 2\n    while factor * factor\
    \ <= n {\n        if n % factor == 0 {\n            largest_prime_factor = factor\n\
    \            while n % factor == 0 {\n                n /= factor\n          \
    \  }\n        }\n        factor += 1\n    }\n    if n > 1 {\n        largest_prime_factor\
    \ = n\n    }\n    return largest_prime_factor\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 1\n    var i = 2\n    while i * i <= n {\n        if n\
    \ % i == 0 {\n            largest_prime = i\n            n /= i\n        } else\
    \ {\n            i += 1\n        }\n    }\n    return n > largest_prime ? n :\
    \ largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 1\n    var i = 2\n    while i * i <= n {\n        if n\
    \ % i == 0 {\n            largest_prime = i\n            n /= i\n        } else\
    \ {\n            i += 1\n        }\n    }\n    if n > 1 {\n        largest_prime\
    \ = n\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 1\n    while n % 2 == 0 {\n        largest_prime = 2\n\
    \        n /= 2\n    }\n    var i = 3\n    while i <= n {\n        if n % i ==\
    \ 0 {\n            largest_prime = i\n            n /= i\n        } else {\n \
    \           i += 2\n        }\n    }\n    return largest_prime\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while factor <= n {\n        if n % factor == 0 {\n   \
    \         n /= factor\n        } else {\n            factor += 1\n        }\n\
    \    }\n    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 1\n    var i = 2\n    while i * i <= n {\n        if n\
    \ % i == 0 {\n            largest_prime = i\n            n /= i\n        } else\
    \ {\n            i += 1\n        }\n    }\n    if n > 1 {\n        largest_prime\
    \ = n\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime_factor = 0\n    for i in 2...n {\n        while n % i ==\
    \ 0 {\n            largest_prime_factor = i\n            n /= i\n        }\n \
    \   }\n    return largest_prime_factor\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 2\n    while n > 1 {\n        if n % largest_prime == 0\
    \ {\n            n /= largest_prime\n        } else {\n            largest_prime\
    \ += 1\n        }\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 2\n    while n % 2 == 0 {\n        n /= 2\n    }\n    for\
    \ i in stride(from: 3, through: Int(sqrt(Double(n))), by: 2) {\n        while\
    \ n % i == 0 {\n            n /= i\n            largest_prime = i\n        }\n\
    \    }\n    if n > 2 {\n        largest_prime = n\n    }\n    return largest_prime\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp5j21h5pn.swift:13:43: error: cannot find 'sqrt' in scope\n    for\
    \ i in stride(from: 3, through: Int(sqrt(Double(n))), by: 2) {\n             \
    \                             ^~~~\n"
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 2\n    while n > 1 {\n        if n % largest_prime == 0\
    \ {\n            n /= largest_prime\n        } else {\n            largest_prime\
    \ += 1\n        }\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime_factor = 0\n    var i = 2\n    while i * i <= n {\n     \
    \   if n % i == 0 {\n            largest_prime_factor = i\n            n /= i\n\
    \        } else {\n            i += 1\n        }\n    }\n    if n > 1 {\n    \
    \    largest_prime_factor = n\n    }\n    return largest_prime_factor\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime_factor = 1\n    var i = 2\n    while i <= n {\n        if\
    \ n % i == 0 {\n            largest_prime_factor = i\n            n /= i\n   \
    \     } else {\n            i += 1\n        }\n    }\n    return largest_prime_factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime\
    \ = 0\n    var i = 2\n    while i <= n {\n        if n % i == 0 {\n          \
    \  largest_prime = i\n            n /= i\n        } else {\n            i += 1\n\
    \        }\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp4aexu3be.swift:13:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 2\n    while n % 2 == 0 {\n        n /= 2\n    }\n    var\
    \ i = 3\n    while i <= Int(sqrt(Double(n))) {\n        while n % i == 0 {\n \
    \           n /= i\n            largest_prime = i\n        }\n        i += 2\n\
    \    }\n    if n > 2 {\n        largest_prime = n\n    }\n    return largest_prime\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpst23rdn3.swift:14:20: error: cannot find 'sqrt' in scope\n    while\
    \ i <= Int(sqrt(Double(n))) {\n                   ^~~~\n"
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while factor * factor <= n {\n        if n % factor ==\
    \ 0 {\n            n /= factor\n        } else {\n            factor += 1\n  \
    \      }\n    }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest = 0\n    var i = 2\n    while i * i <= n {\n        if n % i ==\
    \ 0 {\n            largest = i\n            n /= i\n        } else {\n       \
    \     i += 1\n        }\n    }\n    return max(largest, n)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 2\n    while n > 1 {\n        if n % largest_prime == 0\
    \ {\n            n /= largest_prime\n        } else {\n            largest_prime\
    \ += 1\n        }\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime_factor\
    \ = 1\n    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n      \
    \      largest_prime_factor = i\n            n /= i\n        } else {\n      \
    \      i += 1\n        }\n    }\n    if n > 1 {\n        largest_prime_factor\
    \ = n\n    }\n    return largest_prime_factor\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmphimoprsf.swift:13:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime_factor = 1\n    while n % 2 == 0 {\n        largest_prime_factor\
    \ = 2\n        n /= 2\n    }\n    var i = 3\n    while i <= Int(sqrt(Double(n)))\
    \ {\n        if n % i == 0 {\n            largest_prime_factor = i\n         \
    \   n /= i\n        } else {\n            i += 2\n        }\n    }\n    if n >\
    \ 2 {\n        largest_prime_factor = n\n    }\n    return largest_prime_factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpgry1adzj.swift:15:20: error: cannot find 'sqrt' in scope\n    while\
    \ i <= Int(sqrt(Double(n))) {\n                   ^~~~\n"
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest = 0\n    while n % 2 == 0 {\n        largest = 2\n        n /=\
    \ 2\n    }\n    var i = 3\n    while i <= n {\n        while n % i == 0 {\n  \
    \          largest = i\n            n /= i\n        }\n        i += 2\n    }\n\
    \    return largest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 1\n    var i = 2\n    while i * i <= n {\n        if n\
    \ % i == 0 {\n            largest_prime = i\n            n /= i\n        } else\
    \ {\n            i += 1\n        }\n    }\n    if n > 1 {\n        largest_prime\
    \ = n\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime\
    \ = 1\n    var n = n\n    var i = 2\n    while i <= n {\n        if n % i == 0\
    \ {\n            largest_prime = i\n            n /= i\n        } else {\n   \
    \         i += 1\n        }\n    }\n    return largest_prime\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 1\n    var i = 2\n    while i * i <= n {\n        if n\
    \ % i == 0 {\n            largest_prime = i\n            n /= i\n        } else\
    \ {\n            i += 1\n        }\n    }\n    if n > 1 {\n        largest_prime\
    \ = n\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime_factor = 1\n    var i = 2\n    while i <= n {\n        if\
    \ n % i == 0 {\n            largest_prime_factor = i\n            n /= i\n   \
    \     } else {\n            i += 1\n        }\n    }\n    return largest_prime_factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime_factor = 0\n    var i = 2\n    while i <= n {\n        if\
    \ n % i == 0 {\n            largest_prime_factor = i\n            n /= i\n   \
    \     } else {\n            i += 1\n        }\n    }\n    return largest_prime_factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while factor * factor <= n {\n        if n % factor ==\
    \ 0 {\n            n /= factor\n        } else {\n            factor += 1\n  \
    \      }\n    }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime_factor = 1\n    var i = 2\n    while i <= n {\n        if\
    \ n % i == 0 {\n            largest_prime_factor = i\n            n /= i\n   \
    \     } else {\n            i += 1\n        }\n    }\n    return largest_prime_factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest = 1\n    while n % 2 == 0 {\n        largest = 2\n        n /=\
    \ 2\n    }\n    var i = 3\n    while i <= Int(sqrt(Double(n))) {\n        if n\
    \ % i == 0 {\n            largest = i\n            n /= i\n        } else {\n\
    \            i += 2\n        }\n    }\n    if n > 2 {\n        largest = n\n \
    \   }\n    return largest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpt12i2pk0.swift:15:20: error: cannot find 'sqrt' in scope\n    while\
    \ i <= Int(sqrt(Double(n))) {\n                   ^~~~\n"
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 0\n    var i = 2\n    while i <= n {\n        if n % i\
    \ == 0 {\n            largest_prime = i\n            n /= i\n        } else {\n\
    \            i += 1\n        }\n    }\n    return largest_prime\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest = 0\n    while n % 2 == 0 {\n        largest = 2\n        n /=\
    \ 2\n    }\n    var i = 3\n    while i <= Int(sqrt(Double(n))) {\n        while\
    \ n % i == 0 {\n            largest = i\n            n /= i\n        }\n     \
    \   i += 2\n    }\n    if n > 2 {\n        largest = n\n    }\n    return largest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmphpft07qp.swift:15:20: error: cannot find 'sqrt' in scope\n    while\
    \ i <= Int(sqrt(Double(n))) {\n                   ^~~~\n"
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 1\n    var i = 2\n    while i * i <= n {\n        if n\
    \ % i == 0 {\n            largest_prime = i\n            n /= i\n        } else\
    \ {\n            i += 1\n        }\n    }\n    if n > 1 {\n        largest_prime\
    \ = n\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i <= n {\n        if n % i == 0 {\n            n /= i\n\
    \        } else {\n            i += 1\n        }\n    }\n    return i\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 1\n    while n % 2 == 0 {\n        largest_prime = 2\n\
    \        n /= 2\n    }\n    var i = 3\n    while i <= Int(sqrt(Double(n))) {\n\
    \        if n % i == 0 {\n            largest_prime = i\n            n /= i\n\
    \        } else {\n            i += 2\n        }\n    }\n    if n > 2 {\n    \
    \    largest_prime = n\n    }\n    return largest_prime\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpku7s98b0.swift:15:20: error: cannot find 'sqrt' in scope\n    while\
    \ i <= Int(sqrt(Double(n))) {\n                   ^~~~\n"
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var factor = 2\n\
    \    var n = n\n    while n > 1 {\n        if n % factor == 0 {\n            n\
    \ /= factor\n        } else {\n            factor += 1\n        }\n    }\n   \
    \ return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 2\n    while n > 1 {\n        if n % largest_prime == 0\
    \ {\n            n /= largest_prime\n        } else {\n            largest_prime\
    \ += 1\n        }\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime\
    \ = 1\n    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n      \
    \      largest_prime = i\n            n /= i\n        } else {\n            i\
    \ += 1\n        }\n    }\n    if n > 1 {\n        largest_prime = n\n    }\n \
    \   return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp3pmijin4.swift:13:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime\
    \ = 1\n    var i = 2\n    while i < n {\n        if n % i == 0 {\n           \
    \ largest_prime = i\n            n /= i\n        } else {\n            i += 1\n\
    \        }\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp0gp9yuaq.swift:13:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime_factor = 1\n    var i = 2\n    while i * i <= n {\n     \
    \   if n % i == 0 {\n            largest_prime_factor = i\n            n /= i\n\
    \        } else {\n            i += 1\n        }\n    }\n    if n > 1 {\n    \
    \    largest_prime_factor = n\n    }\n    return largest_prime_factor\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var prime_factors\
    \ = [Int]()\n    var n = n\n    var i = 2\n    while i <= n {\n        if n %\
    \ i == 0 {\n            prime_factors.append(i)\n            n /= i\n        }\
    \ else {\n            i += 1\n        }\n    }\n    return prime_factors.last!\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest = 0\n    var i = 2\n    while i * i <= n {\n        if n % i ==\
    \ 0 {\n            largest = i\n            n /= i\n        } else {\n       \
    \     i += 1\n        }\n    }\n    if n > 1 {\n        largest = n\n    }\n \
    \   return largest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime\
    \ = 1\n    var n = n\n    while n % 2 == 0 {\n        largest_prime = 2\n    \
    \    n /= 2\n    }\n    var i = 3\n    while i <= n {\n        if n % i == 0 {\n\
    \            largest_prime = i\n            n /= i\n        } else {\n       \
    \     i += 2\n        }\n    }\n    return largest_prime\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 1\n    var i = 2\n    while i * i <= n {\n        if n\
    \ % i == 0 {\n            largest_prime = i\n            n /= i\n        } else\
    \ {\n            i += 1\n        }\n    }\n    if n > 1 {\n        largest_prime\
    \ = n\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime_factor = 0\n    var i = 2\n    while i * i <= n {\n     \
    \   if n % i == 0 {\n            largest_prime_factor = i\n            n /= i\n\
    \        } else {\n            i += 1\n        }\n    }\n    if n > 1 {\n    \
    \    largest_prime_factor = n\n    }\n    return largest_prime_factor\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime\
    \ = 1\n    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n      \
    \      largest_prime = i\n            n /= i\n        } else {\n            i\
    \ += 1\n        }\n    }\n    if n > 1 {\n        largest_prime = n\n    }\n \
    \   return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp3pmijin4.swift:13:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while factor * factor <= n {\n        if n % factor ==\
    \ 0 {\n            n /= factor\n        } else {\n            factor += 1\n  \
    \      }\n    }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime_factor = 1\n    var i = 2\n    while i * i <= n {\n     \
    \   if n % i == 0 {\n            largest_prime_factor = i\n            n /= i\n\
    \        } else {\n            i += 1\n        }\n    }\n    if n > 1 {\n    \
    \    largest_prime_factor = n\n    }\n    return largest_prime_factor\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest = 1\n    var i = 2\n    while i <= n {\n        if n % i == 0 {\n\
    \            largest = i\n            n /= i\n        } else {\n            i\
    \ += 1\n        }\n    }\n    return largest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime\
    \ = 1\n    var n = n\n    var i = 2\n    while i <= n {\n        if n % i == 0\
    \ {\n            largest_prime = i\n            n /= i\n        } else {\n   \
    \         i += 1\n        }\n    }\n    return largest_prime\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_factor = 1\n    var i = 2\n    while i * i <= n {\n        if n\
    \ % i == 0 {\n            largest_factor = i\n            n /= i\n        } else\
    \ {\n            i += 1\n        }\n    }\n    if n > 1 {\n        largest_factor\
    \ = n\n    }\n    return largest_factor\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest = 1\n    var i = 2\n    while i <= n {\n        if n % i == 0 {\n\
    \            largest = i\n            n /= i\n        } else {\n            i\
    \ += 1\n        }\n    }\n    return largest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 0\n    var i = 2\n    while i <= n {\n        if n % i\
    \ == 0 {\n            largest_prime = i\n            n /= i\n        } else {\n\
    \            i += 1\n        }\n    }\n    return largest_prime\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime_factor = 1\n    var i = 2\n    while i * i <= n {\n     \
    \   if n % i == 0 {\n            largest_prime_factor = i\n            n /= i\n\
    \        } else {\n            i += 1\n        }\n    }\n    if n > 1 {\n    \
    \    largest_prime_factor = n\n    }\n    return largest_prime_factor\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime_factor = 0\n    var i = 2\n    while i <= n {\n        if\
    \ n % i == 0 {\n            largest_prime_factor = i\n            n /= i\n   \
    \     } else {\n            i += 1\n        }\n    }\n    return largest_prime_factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 2\n    while n > 1 {\n        if n % largest_prime == 0\
    \ {\n            n /= largest_prime\n        } else {\n            largest_prime\
    \ += 1\n        }\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime_factor = 1\n    var i = 2\n    while i <= n {\n        if\
    \ n % i == 0 {\n            largest_prime_factor = i\n            n /= i\n   \
    \     } else {\n            i += 1\n        }\n    }\n    return largest_prime_factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_factor = 1\n    var i = 2\n    while i <= n {\n        if n % i\
    \ == 0 {\n            largest_factor = i\n            n /= i\n        } else {\n\
    \            i += 1\n        }\n    }\n    return largest_factor\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_factor = 1\n    while n % 2 == 0 {\n        largest_factor = 2\n\
    \        n /= 2\n    }\n    var factor = 3\n    while n > 1 {\n        while n\
    \ % factor == 0 {\n            largest_factor = factor\n            n /= factor\n\
    \        }\n        factor += 2\n    }\n    return largest_factor\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime_factor = 1\n    for i in 2...n {\n        if n % i == 0 {\n\
    \            largest_prime_factor = i\n            n /= i\n        }\n    }\n\
    \    return largest_prime_factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: Exception
  stderr: 'tmpv6n89gfe/tmpv6n89gfe.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b89b7d56c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b89b7a4db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b89b7a4d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b89b7a4c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv6n89gfe                        0x000055a30242d3b0 <unavailable> + 5040

    5    libc.so.6                          0x00002b89b7f42460 __libc_start_main +
    245

    6    tmpv6n89gfe                        0x000055a30242cfe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime\
    \ = 1\n    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n      \
    \      largest_prime = i\n            n /= i\n        } else {\n            i\
    \ += 1\n        }\n    }\n    if n > 1 {\n        largest_prime = n\n    }\n \
    \   return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp3pmijin4.swift:13:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 1\n    var i = 2\n    while i * i <= n {\n        if n\
    \ % i == 0 {\n            largest_prime = i\n            n /= i\n        } else\
    \ {\n            i += 1\n        }\n    }\n    if n > 1 {\n        largest_prime\
    \ = n\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while factor <= n {\n        if n % factor == 0 {\n   \
    \         n /= factor\n        } else {\n            factor += 1\n        }\n\
    \    }\n    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime_factor\
    \ = 1\n    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n      \
    \      largest_prime_factor = i\n            n /= i\n        } else {\n      \
    \      i += 1\n        }\n    }\n    if n > 1 {\n        largest_prime_factor\
    \ = n\n    }\n    return largest_prime_factor\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmphimoprsf.swift:13:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 1\n    var i = 2\n    while i * i <= n {\n        if n\
    \ % i == 0 {\n            largest_prime = i\n            n /= i\n        } else\
    \ {\n            i += 1\n        }\n    }\n    if n > 1 {\n        largest_prime\
    \ = n\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_factor = 1\n    var i = 2\n    while i * i <= n {\n        if n\
    \ % i == 0 {\n            largest_factor = i\n            n /= i\n        } else\
    \ {\n            i += 1\n        }\n    }\n    if n > 1 {\n        largest_factor\
    \ = n\n    }\n    return largest_factor\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n % factor != 0 {\n        factor += 1\n    }\n \
    \   n /= factor\n    if n == 1 {\n        return factor\n    }\n    return largest_prime_factor(n:\
    \ n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(largest_prime_factor(n: 15) ==\
    \ 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
