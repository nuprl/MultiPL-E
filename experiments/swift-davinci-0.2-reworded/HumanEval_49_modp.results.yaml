language: swift
name: HumanEval_49_modp
results:
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n /= 2\n        p = (p * p) % 101\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmph8m_049u/tmph8m_049u.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad9b39d8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad9b36cfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad9b36cf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad9b36ce7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph8m_049u                        0x000055d45488f24d <unavailable> + 4685

    5    libc.so.6                          0x00002ad9b3bc4460 __libc_start_main +
    245

    6    tmph8m_049u                        0x000055d45488eef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        let x = modp(n: n / 2, p: p)\n        return (x\
    \ * x) % p\n    }\n    return (modp(n: n - 1, p: p) * n) % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmptd3w04e6/tmptd3w04e6.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002affba90fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002affba606b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002affba606988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002affba6057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptd3w04e6                        0x0000560da8d942cd <unavailable> + 4813

    5    libc.so.6                          0x00002affbaafb460 __libc_start_main +
    245

    6    tmptd3w04e6                        0x0000560da8d93ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        let x = modp(n: n / 2, p: p)\n        return (x\
    \ * x) % p\n    }\n    return (n % p) * modp(n: n - 1, p: p) % p\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpqoejf4a2/tmpqoejf4a2.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0ace665c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0ace35cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0ace35c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0ace35b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqoejf4a2                        0x000056339f6dd2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b0ace851460 __libc_start_main +
    245

    6    tmpqoejf4a2                        0x000056339f6dcef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n = n / 2\n        p = (p * p) % 101\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp4jdsv5k1/tmp4jdsv5k1.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1785395c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b178508cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b178508c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b178508b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4jdsv5k1                        0x000055e0e1d1e24d <unavailable> + 4685

    5    libc.so.6                          0x00002b1785581460 __libc_start_main +
    245

    6    tmp4jdsv5k1                        0x000055e0e1d1def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002baa90b90c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002baa90887561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002baa90887286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002baa9088713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002baa90886bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpzvd9j90q                        0x000055c8dc609730 <unavailable> + 5936

    6    tmpzvd9j90q                        0x000055c8dc6091e0 <unavailable> + 4576

    7    libc.so.6                          0x00002baa90d7c460 __libc_start_main +
    245

    8    tmpzvd9j90q                        0x000055c8dc608ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n  \
    \      }\n        n /= 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp43iroj9l/tmp43iroj9l.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0de27f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0de24eeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0de24ee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0de24ed7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp43iroj9l                        0x000056174b4c524d <unavailable> + 4685

    5    libc.so.6                          0x00002b0de29e3460 __libc_start_main +
    245

    6    tmp43iroj9l                        0x000056174b4c4ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        let x = modp(n: n / 2, p: p)\n        return (x\
    \ * x) % p\n    }\n    return (modp(n: n - 1, p: p) * n) % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmptd3w04e6/tmptd3w04e6.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002affba90fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002affba606b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002affba606988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002affba6057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptd3w04e6                        0x0000560da8d942cd <unavailable> + 4813

    5    libc.so.6                          0x00002affbaafb460 __libc_start_main +
    245

    6    tmptd3w04e6                        0x0000560da8d93ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        let x = modp(n: n / 2, p: p)\n        return (x\
    \ * x) % p\n    }\n    return (n * modp(n: n - 1, p: p)) % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp7zethb4l/tmp7zethb4l.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1ec3a49c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1ec3740b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1ec3740988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1ec373f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7zethb4l                        0x000055da2f7752cd <unavailable> + 4813

    5    libc.so.6                          0x00002b1ec3c35460 __libc_start_main +
    245

    6    tmp7zethb4l                        0x000055da2f774ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        n = (n * n) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014291
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return n % p\n    }\n    if n % 2 == 0 {\n        let\
    \ x = modp(n: n / 2, p: p)\n        return (x * x) % p\n    }\n    return (n *\
    \ modp(n: n - 1, p: p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpbixd5i9y/tmpbixd5i9y.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1258d8fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1258a86b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1258a86988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1258a857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbixd5i9y                        0x000056076bdf82cd <unavailable> + 4813

    5    libc.so.6                          0x00002b1258f7b460 __libc_start_main +
    245

    6    tmpbixd5i9y                        0x000056076bdf7ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n = n / 2\n        p = (p * p) % 101\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp4jdsv5k1/tmp4jdsv5k1.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1785395c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b178508cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b178508c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b178508b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4jdsv5k1                        0x000055e0e1d1e24d <unavailable> + 4685

    5    libc.so.6                          0x00002b1785581460 __libc_start_main +
    245

    6    tmp4jdsv5k1                        0x000055e0e1d1def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp1ydqyovw/tmp1ydqyovw.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b992a7bcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b992a4b3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b992a4b3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b992a4b27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1ydqyovw                        0x000055a2f1bfa2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b992a9a8460 __libc_start_main +
    245

    6    tmp1ydqyovw                        0x000055a2f1bf9ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n = n / 2\n        p = (p * p) % 101\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpt6_fwv8b/tmpt6_fwv8b.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b04867e8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b04864dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b04864df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b04864de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt6_fwv8b                        0x0000562cf67b724d <unavailable> + 4685

    5    libc.so.6                          0x00002b04869d4460 __libc_start_main +
    245

    6    tmpt6_fwv8b                        0x0000562cf67b6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3d1413c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3d110a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac3d110a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac3d110a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac3d1109bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpgshix713                        0x00005631ae41b730 <unavailable> + 5936

    6    tmpgshix713                        0x00005631ae41b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002ac3d15ff460 __libc_start_main +
    245

    8    tmpgshix713                        0x00005631ae41aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp1ydqyovw/tmp1ydqyovw.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b992a7bcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b992a4b3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b992a4b3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b992a4b27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1ydqyovw                        0x000055a2f1bfa2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b992a9a8460 __libc_start_main +
    245

    6    tmp1ydqyovw                        0x000055a2f1bf9ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n = n / 2\n        p = (p * p) % 101\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp4jdsv5k1/tmp4jdsv5k1.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1785395c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b178508cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b178508c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b178508b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4jdsv5k1                        0x000055e0e1d1e24d <unavailable> + 4685

    5    libc.so.6                          0x00002b1785581460 __libc_start_main +
    245

    6    tmp4jdsv5k1                        0x000055e0e1d1def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var power = n\n  \
    \  var mod = p\n    while power > 0 {\n        if power % 2 == 1 {\n         \
    \   result = (result * n) % p\n        }\n        power = power / 2\n        n\
    \ = (n * n) % p\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpb3ca_8yl.swift:22:9: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n        n = (n * n) % p\n        ^\n"
  stdout: ''
  timestamp: 1660014286
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var base = n % p\n\
    \    var exponent = n\n    while exponent > 0 {\n        if exponent % 2 == 1\
    \ {\n            result = (result * base) % p\n        }\n        exponent >>=\
    \ 1\n        base = (base * base) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp_2i8y7kj/tmp_2i8y7kj.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af5f0f0ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af5f0c05b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af5f0c05988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af5f0c047b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_2i8y7kj                        0x000055c47ef1d24d <unavailable> + 4685

    5    libc.so.6                          0x00002af5f10fa460 __libc_start_main +
    245

    6    tmp_2i8y7kj                        0x000055c47ef1cef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002baa90b90c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002baa90887561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002baa90887286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002baa9088713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002baa90886bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpzvd9j90q                        0x000055c8dc609730 <unavailable> + 5936

    6    tmpzvd9j90q                        0x000055c8dc6091e0 <unavailable> + 4576

    7    libc.so.6                          0x00002baa90d7c460 __libc_start_main +
    245

    8    tmpzvd9j90q                        0x000055c8dc608ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n = n / 2\n        p = (p * p) % 101\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp4jdsv5k1/tmp4jdsv5k1.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1785395c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b178508cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b178508c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b178508b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4jdsv5k1                        0x000055e0e1d1e24d <unavailable> + 4685

    5    libc.so.6                          0x00002b1785581460 __libc_start_main +
    245

    6    tmp4jdsv5k1                        0x000055e0e1d1def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        let x = modp(n: n / 2, p: p)\n        return (x\
    \ * x) % p\n    }\n    return (n * modp(n: n - 1, p: p)) % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp7zethb4l/tmp7zethb4l.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1ec3a49c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1ec3740b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1ec3740988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1ec373f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7zethb4l                        0x000055da2f7752cd <unavailable> + 4813

    5    libc.so.6                          0x00002b1ec3c35460 __libc_start_main +
    245

    6    tmp7zethb4l                        0x000055da2f774ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var res = 1\n    var n = n\n    var p\
    \ = p\n    while n > 0 {\n        if n & 1 == 1 {\n            res = (res * n)\
    \ % p\n        }\n        n = n >> 1\n        p = (p * p) % p\n    }\n    return\
    \ res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b3f1511dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3f14e14561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3f14e14286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3f14e1413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3f14e13bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpqo2vybaw                        0x000055c1787b569d <unavailable> + 5789

    6    tmpqo2vybaw                        0x000055c1787b51e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b3f15309460 __libc_start_main +
    245

    8    tmpqo2vybaw                        0x000055c1787b4ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002baa90b90c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002baa90887561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002baa90887286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002baa9088713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002baa90886bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpzvd9j90q                        0x000055c8dc609730 <unavailable> + 5936

    6    tmpzvd9j90q                        0x000055c8dc6091e0 <unavailable> + 4576

    7    libc.so.6                          0x00002baa90d7c460 __libc_start_main +
    245

    8    tmpzvd9j90q                        0x000055c8dc608ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n = n / 2\n        p = (p * p) % 101\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp4jdsv5k1/tmp4jdsv5k1.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1785395c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b178508cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b178508c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b178508b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4jdsv5k1                        0x000055e0e1d1e24d <unavailable> + 4685

    5    libc.so.6                          0x00002b1785581460 __libc_start_main +
    245

    6    tmp4jdsv5k1                        0x000055e0e1d1def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002baa90b90c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002baa90887561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002baa90887286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002baa9088713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002baa90886bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpzvd9j90q                        0x000055c8dc609730 <unavailable> + 5936

    6    tmpzvd9j90q                        0x000055c8dc6091e0 <unavailable> + 4576

    7    libc.so.6                          0x00002baa90d7c460 __libc_start_main +
    245

    8    tmpzvd9j90q                        0x000055c8dc608ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        n = n % p\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp8nx3ux0u/tmp8nx3ux0u.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b529e363c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b529e05ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b529e05a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b529e0597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8nx3ux0u                        0x000055c9734162cd <unavailable> + 4813

    5    libc.so.6                          0x00002b529e54f460 __libc_start_main +
    245

    6    tmp8nx3ux0u                        0x000055c973415ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return n % p\n    }\n    var result = 1\n    var base\
    \ = n % p\n    var exponent = n\n    while exponent > 0 {\n        if exponent\
    \ % 2 == 1 {\n            result = (result * base) % p\n        }\n        exponent\
    \ = exponent / 2\n        base = (base * base) % p\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpuyz4pl28/tmpuyz4pl28.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba8fbe2cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba8fbb23b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba8fbb23988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba8fbb227b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuyz4pl28                        0x000055b4a98e024d <unavailable> + 4685

    5    libc.so.6                          0x00002ba8fc018460 __libc_start_main +
    245

    6    tmpuyz4pl28                        0x000055b4a98dfef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var base = n % p\n\
    \    var exponent = n\n    while exponent > 0 {\n        if exponent % 2 == 1\
    \ {\n            result = (result * base) % p\n        }\n        exponent >>=\
    \ 1\n        base = (base * base) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp_2i8y7kj/tmp_2i8y7kj.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af5f0f0ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af5f0c05b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af5f0c05988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af5f0c047b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_2i8y7kj                        0x000055c47ef1d24d <unavailable> + 4685

    5    libc.so.6                          0x00002af5f10fa460 __libc_start_main +
    245

    6    tmp_2i8y7kj                        0x000055c47ef1cef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return n % p\n    }\n    if n % 2 == 0 {\n        let\
    \ x = modp(n: n / 2, p: p)\n        return (x * x) % p\n    }\n    return (n *\
    \ modp(n: n - 1, p: p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpbixd5i9y/tmpbixd5i9y.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1258d8fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1258a86b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1258a86988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1258a857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbixd5i9y                        0x000056076bdf82cd <unavailable> + 4813

    5    libc.so.6                          0x00002b1258f7b460 __libc_start_main +
    245

    6    tmpbixd5i9y                        0x000056076bdf7ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var r = 1\n    var b = n\n    while b\
    \ > 0 {\n        if b % 2 == 1 {\n            r = (r * n) % p\n        }\n   \
    \     b /= 2\n        n = (n * n) % p\n    }\n    return r\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpeunycz4b.swift:21:9: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n        n = (n * n) % p\n        ^\n"
  stdout: ''
  timestamp: 1660014286
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3d1413c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3d110a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac3d110a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac3d110a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac3d1109bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpgshix713                        0x00005631ae41b730 <unavailable> + 5936

    6    tmpgshix713                        0x00005631ae41b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002ac3d15ff460 __libc_start_main +
    245

    8    tmpgshix713                        0x00005631ae41aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n  \
    \      }\n        n /= 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp3pln77q9/tmp3pln77q9.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5d947cfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5d944c6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5d944c6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5d944c57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3pln77q9                        0x000055f3b2bb824d <unavailable> + 4685

    5    libc.so.6                          0x00002b5d949bb460 __libc_start_main +
    245

    6    tmp3pln77q9                        0x000055f3b2bb7ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n /= 2\n        p = (p * p) % 101\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmph8m_049u/tmph8m_049u.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad9b39d8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad9b36cfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad9b36cf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad9b36ce7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph8m_049u                        0x000055d45488f24d <unavailable> + 4685

    5    libc.so.6                          0x00002ad9b3bc4460 __libc_start_main +
    245

    6    tmph8m_049u                        0x000055d45488eef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        let x = modp(n: n / 2, p: p)\n        return (x\
    \ * x) % p\n    }\n    return (modp(n: n - 1, p: p) * n) % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmptd3w04e6/tmptd3w04e6.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002affba90fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002affba606b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002affba606988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002affba6057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptd3w04e6                        0x0000560da8d942cd <unavailable> + 4813

    5    libc.so.6                          0x00002affbaafb460 __libc_start_main +
    245

    6    tmptd3w04e6                        0x0000560da8d93ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n & 1 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n >>= 1\n        p = (p * p) % 101\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpv8li9i_2/tmpv8li9i_2.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b57b8ddec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b57b8ad5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b57b8ad5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b57b8ad47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv8li9i_2                        0x0000559a61f4024d <unavailable> + 4685

    5    libc.so.6                          0x00002b57b8fca460 __libc_start_main +
    245

    6    tmpv8li9i_2                        0x0000559a61f3fef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        n = (n * n) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014291
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        let x = modp(n: n / 2, p: p)\n        return (x\
    \ * x) % p\n    }\n    return (modp(n: n - 1, p: p) * n) % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmptd3w04e6/tmptd3w04e6.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002affba90fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002affba606b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002affba606988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002affba6057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptd3w04e6                        0x0000560da8d942cd <unavailable> + 4813

    5    libc.so.6                          0x00002affbaafb460 __libc_start_main +
    245

    6    tmptd3w04e6                        0x0000560da8d93ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    } else\
    \ if n % 2 == 0 {\n        let m = modp(n: n / 2, p: p)\n        return (m * m)\
    \ % p\n    } else {\n        return (n * modp(n: n - 1, p: p)) % p\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpgzsq3fkh/tmpgzsq3fkh.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b749acd4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b749a9cbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b749a9cb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b749a9ca7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgzsq3fkh                        0x000055ae145f62cd <unavailable> + 4813

    5    libc.so.6                          0x00002b749aec0460 __libc_start_main +
    245

    6    tmpgzsq3fkh                        0x000055ae145f5ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    if n < 0\
    \ {\n        n = n % p + p\n    }\n    var result = 1\n    while n > 0 {\n   \
    \     if n % 2 == 1 {\n            result = (result * 2) % p\n        }\n    \
    \    n /= 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpumcuk4ap/tmpumcuk4ap.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af3d6a61c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af3d6758b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af3d6758988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af3d67577b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpumcuk4ap                        0x000055f8ba9fe24d <unavailable> + 4685

    5    libc.so.6                          0x00002af3d6c4d460 __libc_start_main +
    245

    6    tmpumcuk4ap                        0x000055f8ba9fdef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002baa90b90c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002baa90887561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002baa90887286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002baa9088713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002baa90886bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpzvd9j90q                        0x000055c8dc609730 <unavailable> + 5936

    6    tmpzvd9j90q                        0x000055c8dc6091e0 <unavailable> + 4576

    7    libc.so.6                          0x00002baa90d7c460 __libc_start_main +
    245

    8    tmpzvd9j90q                        0x000055c8dc608ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3d1413c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3d110a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac3d110a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac3d110a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac3d1109bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpgshix713                        0x00005631ae41b730 <unavailable> + 5936

    6    tmpgshix713                        0x00005631ae41b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002ac3d15ff460 __libc_start_main +
    245

    8    tmpgshix713                        0x00005631ae41aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var res = 1\n    var n = n\n    var p\
    \ = p\n    while n > 0 {\n        if n & 1 == 1 {\n            res = (res * n)\
    \ % p\n        }\n        n = n >> 1\n        p = (p * p) % p\n    }\n    return\
    \ res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b3f1511dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3f14e14561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3f14e14286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3f14e1413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3f14e13bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpqo2vybaw                        0x000055c1787b569d <unavailable> + 5789

    6    tmpqo2vybaw                        0x000055c1787b51e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b3f15309460 __libc_start_main +
    245

    8    tmpqo2vybaw                        0x000055c1787b4ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        n = (n * n) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014291
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var res = 1\n    var n = n\n    var p\
    \ = p\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n    return\
    \ res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b6847e60c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6847b57561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b6847b57286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b6847b5713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b6847b56bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpo0t_g801                        0x0000563dfef21730 <unavailable> + 5936

    6    tmpo0t_g801                        0x0000563dfef211e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b684804c460 __libc_start_main +
    245

    8    tmpo0t_g801                        0x0000563dfef20ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3d1413c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3d110a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac3d110a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac3d110a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac3d1109bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpgshix713                        0x00005631ae41b730 <unavailable> + 5936

    6    tmpgshix713                        0x00005631ae41b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002ac3d15ff460 __libc_start_main +
    245

    8    tmpgshix713                        0x00005631ae41aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    } else\
    \ if n == 1 {\n        return 2 % p\n    } else {\n        let half = modp(n:\
    \ n / 2, p: p)\n        if n % 2 == 0 {\n            return (half * half) % p\n\
    \        } else {\n            return (2 * half * half) % p\n        }\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3d1413c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3d110a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac3d110a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac3d110a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac3d1109bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpgshix713                        0x00005631ae41b730 <unavailable> + 5936

    6    tmpgshix713                        0x00005631ae41b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002ac3d15ff460 __libc_start_main +
    245

    8    tmpgshix713                        0x00005631ae41aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        n = (n * n) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014291
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002baa90b90c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002baa90887561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002baa90887286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002baa9088713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002baa90886bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpzvd9j90q                        0x000055c8dc609730 <unavailable> + 5936

    6    tmpzvd9j90q                        0x000055c8dc6091e0 <unavailable> + 4576

    7    libc.so.6                          0x00002baa90d7c460 __libc_start_main +
    245

    8    tmpzvd9j90q                        0x000055c8dc608ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002baa90b90c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002baa90887561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002baa90887286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002baa9088713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002baa90886bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpzvd9j90q                        0x000055c8dc609730 <unavailable> + 5936

    6    tmpzvd9j90q                        0x000055c8dc6091e0 <unavailable> + 4576

    7    libc.so.6                          0x00002baa90d7c460 __libc_start_main +
    245

    8    tmpzvd9j90q                        0x000055c8dc608ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return n % p\n    }\n    if n % 2 == 0 {\n        return\
    \ (modp(n: n / 2, p: p) * modp(n: n / 2, p: p)) % p\n    }\n    return (modp(n:\
    \ n - 1, p: p) * modp(n: n, p: p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp1ydqyovw/tmp1ydqyovw.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b992a7bcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b992a4b3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b992a4b3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b992a4b27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1ydqyovw                        0x000055a2f1bfa2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b992a9a8460 __libc_start_main +
    245

    6    tmp1ydqyovw                        0x000055a2f1bf9ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp1ydqyovw/tmp1ydqyovw.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b992a7bcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b992a4b3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b992a4b3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b992a4b27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1ydqyovw                        0x000055a2f1bfa2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b992a9a8460 __libc_start_main +
    245

    6    tmp1ydqyovw                        0x000055a2f1bf9ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n = n / 2\n        p = (p * p) % 101\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpt6_fwv8b/tmpt6_fwv8b.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b04867e8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b04864dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b04864df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b04864de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt6_fwv8b                        0x0000562cf67b724d <unavailable> + 4685

    5    libc.so.6                          0x00002b04869d4460 __libc_start_main +
    245

    6    tmpt6_fwv8b                        0x0000562cf67b6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n & 1 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n = n >> 1\n        p = (p * p) % 101\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpbr5gy7uc/tmpbr5gy7uc.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b891572ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8915421b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8915421988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b89154207b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbr5gy7uc                        0x000055e8ffb1324d <unavailable> + 4685

    5    libc.so.6                          0x00002b8915916460 __libc_start_main +
    245

    6    tmpbr5gy7uc                        0x000055e8ffb12ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002baa90b90c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002baa90887561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002baa90887286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002baa9088713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002baa90886bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpzvd9j90q                        0x000055c8dc609730 <unavailable> + 5936

    6    tmpzvd9j90q                        0x000055c8dc6091e0 <unavailable> + 4576

    7    libc.so.6                          0x00002baa90d7c460 __libc_start_main +
    245

    8    tmpzvd9j90q                        0x000055c8dc608ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3d1413c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3d110a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac3d110a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac3d110a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac3d1109bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpgshix713                        0x00005631ae41b730 <unavailable> + 5936

    6    tmpgshix713                        0x00005631ae41b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002ac3d15ff460 __libc_start_main +
    245

    8    tmpgshix713                        0x00005631ae41aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp1ydqyovw/tmp1ydqyovw.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b992a7bcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b992a4b3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b992a4b3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b992a4b27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1ydqyovw                        0x000055a2f1bfa2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b992a9a8460 __libc_start_main +
    245

    6    tmp1ydqyovw                        0x000055a2f1bf9ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        let y = modp(n: n / 2, p: p)\n        return (y\
    \ * y) % p\n    }\n    return (modp(n: n - 1, p: p) * n) % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpoo3bxk74/tmpoo3bxk74.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7b3dfb7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7b3dcaeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7b3dcae988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7b3dcad7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoo3bxk74                        0x000055f44d17b2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b7b3e1a3460 __libc_start_main +
    245

    6    tmpoo3bxk74                        0x000055f44d17aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3d1413c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3d110a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac3d110a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac3d110a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac3d1109bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpgshix713                        0x00005631ae41b730 <unavailable> + 5936

    6    tmpgshix713                        0x00005631ae41b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002ac3d15ff460 __libc_start_main +
    245

    8    tmpgshix713                        0x00005631ae41aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3d1413c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3d110a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac3d110a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac3d110a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac3d1109bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpgshix713                        0x00005631ae41b730 <unavailable> + 5936

    6    tmpgshix713                        0x00005631ae41b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002ac3d15ff460 __libc_start_main +
    245

    8    tmpgshix713                        0x00005631ae41aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var (n, p) = (n, p)\n    var result =\
    \ 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        p = (p * p) % 101\n        n /= 2\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpk35ijtf9/tmpk35ijtf9.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b604bc2fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b604b926b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b604b926988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b604b9257b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk35ijtf9                        0x000055923cff524d <unavailable> + 4685

    5    libc.so.6                          0x00002b604be1b460 __libc_start_main +
    245

    6    tmpk35ijtf9                        0x000055923cff4ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n  \
    \      }\n        n /= 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp43iroj9l/tmp43iroj9l.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0de27f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0de24eeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0de24ee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0de24ed7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp43iroj9l                        0x000056174b4c524d <unavailable> + 4685

    5    libc.so.6                          0x00002b0de29e3460 __libc_start_main +
    245

    6    tmp43iroj9l                        0x000056174b4c4ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var x = 1\n    var y = n\n    while y\
    \ > 0 {\n        if y % 2 == 1 {\n            x = (x * n) % p\n        }\n   \
    \     y = y / 2\n        n = (n * n) % p\n    }\n    return x\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp5ggcxm5l.swift:21:9: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n        n = (n * n) % p\n        ^\n"
  stdout: ''
  timestamp: 1660014287
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        n = (n * n) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014291
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n /= 2\n        p = (p * p) % 101\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp8wjrj6_f/tmp8wjrj6_f.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac64113fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac640e36b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac640e36988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac640e357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8wjrj6_f                        0x000056245f1ac24d <unavailable> + 4685

    5    libc.so.6                          0x00002ac64132b460 __libc_start_main +
    245

    6    tmp8wjrj6_f                        0x000056245f1abef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n  \
    \      }\n        n /= 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp43iroj9l/tmp43iroj9l.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0de27f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0de24eeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0de24ee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0de24ed7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp43iroj9l                        0x000056174b4c524d <unavailable> + 4685

    5    libc.so.6                          0x00002b0de29e3460 __libc_start_main +
    245

    6    tmp43iroj9l                        0x000056174b4c4ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        n = (n * n) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014291
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n & 1 == 1 {\n            result = (result\
    \ * p) % MODULO\n        }\n        n = n >> 1\n        p = (p * p) % MODULO\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp04x9uvs_.swift:19:37: error: cannot find 'MODULO' in scope\n  \
    \          result = (result * p) % MODULO\n                                  \
    \  ^~~~~~\n/tmp/tmp04x9uvs_.swift:22:23: error: cannot find 'MODULO' in scope\n\
    \        p = (p * p) % MODULO\n                      ^~~~~~\n"
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var res = 1\n    var n = n\n    var p\
    \ = p\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n    return\
    \ res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b6847e60c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6847b57561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b6847b57286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b6847b5713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b6847b56bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpo0t_g801                        0x0000563dfef21730 <unavailable> + 5936

    6    tmpo0t_g801                        0x0000563dfef211e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b684804c460 __libc_start_main +
    245

    8    tmpo0t_g801                        0x0000563dfef20ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * p) % 101\n\
    \        }\n        p = (p * p) % 101\n        n /= 2\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpdyncz1pz.swift:20:9: error: cannot assign to value: 'p' is a 'let'\
    \ constant\n        p = (p * p) % 101\n        ^\n"
  stdout: ''
  timestamp: 1660014287
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n = n / 2\n        p = (p * p) % 101\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpt6_fwv8b/tmpt6_fwv8b.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b04867e8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b04864dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b04864df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b04864de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt6_fwv8b                        0x0000562cf67b724d <unavailable> + 4685

    5    libc.so.6                          0x00002b04869d4460 __libc_start_main +
    245

    6    tmpt6_fwv8b                        0x0000562cf67b6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n = n / 2\n        p = (p * p) % 101\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp4jdsv5k1/tmp4jdsv5k1.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1785395c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b178508cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b178508c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b178508b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4jdsv5k1                        0x000055e0e1d1e24d <unavailable> + 4685

    5    libc.so.6                          0x00002b1785581460 __libc_start_main +
    245

    6    tmp4jdsv5k1                        0x000055e0e1d1def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3d1413c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3d110a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac3d110a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac3d110a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac3d1109bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpgshix713                        0x00005631ae41b730 <unavailable> + 5936

    6    tmpgshix713                        0x00005631ae41b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002ac3d15ff460 __libc_start_main +
    245

    8    tmpgshix713                        0x00005631ae41aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n  \
    \      }\n        n /= 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp43iroj9l/tmp43iroj9l.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0de27f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0de24eeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0de24ee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0de24ed7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp43iroj9l                        0x000056174b4c524d <unavailable> + 4685

    5    libc.so.6                          0x00002b0de29e3460 __libc_start_main +
    245

    6    tmp43iroj9l                        0x000056174b4c4ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n /= 2\n        p = (p * p) % 101\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmph8m_049u/tmph8m_049u.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad9b39d8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad9b36cfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad9b36cf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad9b36ce7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph8m_049u                        0x000055d45488f24d <unavailable> + 4685

    5    libc.so.6                          0x00002ad9b3bc4460 __libc_start_main +
    245

    6    tmph8m_049u                        0x000055d45488eef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3d1413c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3d110a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac3d110a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac3d110a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac3d1109bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpgshix713                        0x00005631ae41b730 <unavailable> + 5936

    6    tmpgshix713                        0x00005631ae41b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002ac3d15ff460 __libc_start_main +
    245

    8    tmpgshix713                        0x00005631ae41aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n = n / 2\n        p = (p * p) % 101\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpt6_fwv8b/tmpt6_fwv8b.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b04867e8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b04864dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b04864df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b04864de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt6_fwv8b                        0x0000562cf67b724d <unavailable> + 4685

    5    libc.so.6                          0x00002b04869d4460 __libc_start_main +
    245

    6    tmpt6_fwv8b                        0x0000562cf67b6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    var r = 1\n    var i = n\n    var b = 2\n    while i > 0 {\n        if i\
    \ % 2 == 1 {\n            r = (r * b) % p\n        }\n        b = (b * b) % p\n\
    \        i = i / 2\n    }\n    return r\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002baa90b90c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002baa90887561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002baa90887286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002baa9088713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002baa90886bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpzvd9j90q                        0x000055c8dc609730 <unavailable> + 5936

    6    tmpzvd9j90q                        0x000055c8dc6091e0 <unavailable> + 4576

    7    libc.so.6                          0x00002baa90d7c460 __libc_start_main +
    245

    8    tmpzvd9j90q                        0x000055c8dc608ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    } else\
    \ if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p: p)\
    \ % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p) %\
    \ p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n /= 2\n        p = (p * p) % 101\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp8wjrj6_f/tmp8wjrj6_f.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac64113fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac640e36b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac640e36988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac640e357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8wjrj6_f                        0x000056245f1ac24d <unavailable> + 4685

    5    libc.so.6                          0x00002ac64132b460 __libc_start_main +
    245

    6    tmp8wjrj6_f                        0x000056245f1abef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        let m = modp(n: n / 2, p: p)\n        return (m\
    \ * m) % p\n    }\n    return (modp(n: n - 1, p: p) * n) % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp01wssv84/tmp01wssv84.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6c091c1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6c08eb8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6c08eb8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6c08eb77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp01wssv84                        0x00005580ed3d92cd <unavailable> + 4813

    5    libc.so.6                          0x00002b6c093ad460 __libc_start_main +
    245

    6    tmp01wssv84                        0x00005580ed3d8ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpe06d295u/tmpe06d295u.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab0fbb88c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab0fb87fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab0fb87f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab0fb87e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe06d295u                        0x00005575f181524d <unavailable> + 4685

    5    libc.so.6                          0x00002ab0fbd74460 __libc_start_main +
    245

    6    tmpe06d295u                        0x00005575f1814ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n & 1 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n >> 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpe4jzi5ce/tmpe4jzi5ce.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8c3363fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8c33336b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8c33336988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8c333357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe4jzi5ce                        0x00005635f429d2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b8c3382b460 __libc_start_main +
    245

    6    tmpe4jzi5ce                        0x00005635f429cef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n = n / 2\n        p = (p * p) % 101\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp4jdsv5k1/tmp4jdsv5k1.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1785395c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b178508cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b178508c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b178508b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4jdsv5k1                        0x000055e0e1d1e24d <unavailable> + 4685

    5    libc.so.6                          0x00002b1785581460 __libc_start_main +
    245

    6    tmp4jdsv5k1                        0x000055e0e1d1def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        n = n % p\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp8nx3ux0u/tmp8nx3ux0u.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b529e363c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b529e05ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b529e05a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b529e0597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8nx3ux0u                        0x000055c9734162cd <unavailable> + 4813

    5    libc.so.6                          0x00002b529e54f460 __libc_start_main +
    245

    6    tmp8nx3ux0u                        0x000055c973415ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    var result = 1\n    var i = 0\n    while i < n {\n        result = (result\
    \ * 2) % p\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        let x = modp(n: n / 2, p: p)\n        return (x\
    \ * x) % p\n    }\n    return (modp(n: n - 1, p: p) * n) % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmptd3w04e6/tmptd3w04e6.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002affba90fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002affba606b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002affba606988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002affba6057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptd3w04e6                        0x0000560da8d942cd <unavailable> + 4813

    5    libc.so.6                          0x00002affbaafb460 __libc_start_main +
    245

    6    tmptd3w04e6                        0x0000560da8d93ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        let x = modp(n: n / 2, p: p)\n        return (x\
    \ * x) % p\n    }\n    return (modp(n: n - 1, p: p) * n) % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmptd3w04e6/tmptd3w04e6.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002affba90fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002affba606b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002affba606988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002affba6057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptd3w04e6                        0x0000560da8d942cd <unavailable> + 4813

    5    libc.so.6                          0x00002affbaafb460 __libc_start_main +
    245

    6    tmptd3w04e6                        0x0000560da8d93ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        n = (n * n) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014291
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * p) % n\n  \
    \      }\n        n = n / 2\n        p = (p * p) % n\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp1hlpbsha.swift:21:9: error: cannot assign to value: 'p' is a 'let'\
    \ constant\n        p = (p * p) % n\n        ^\n"
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        let m = modp(n: n / 2, p: p)\n        return (m\
    \ * m) % p\n    }\n    return (modp(n: n - 1, p: p) * n) % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp01wssv84/tmp01wssv84.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6c091c1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6c08eb8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6c08eb8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6c08eb77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp01wssv84                        0x00005580ed3d92cd <unavailable> + 4813

    5    libc.so.6                          0x00002b6c093ad460 __libc_start_main +
    245

    6    tmp01wssv84                        0x00005580ed3d8ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n = n / 2\n        p = (p * p) % 101\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp4jdsv5k1/tmp4jdsv5k1.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1785395c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b178508cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b178508c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b178508b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4jdsv5k1                        0x000055e0e1d1e24d <unavailable> + 4685

    5    libc.so.6                          0x00002b1785581460 __libc_start_main +
    245

    6    tmp4jdsv5k1                        0x000055e0e1d1def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
