language: swift
name: HumanEval_99_closest_integer
results:
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let difference\
    \ = number - rounded\n    if difference > 0 {\n        return Int(rounded + 1)\n\
    \    } else if difference < 0 {\n        return Int(rounded - 1)\n    } else {\n\
    \        return Int(rounded)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp_ap1wa9_.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    let decimal = num - Double(int)\n\
    \    if decimal >= 0.5 {\n        return int + 1\n    } else {\n        return\
    \ int\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpn5zuqzif/tmpn5zuqzif.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b42db182c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b42dae79b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b42dae79988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b42dae787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn5zuqzif                        0x0000561b266a5512 <unavailable> + 5394

    5    libc.so.6                          0x00002b42db36e460 __libc_start_main +
    245

    6    tmpn5zuqzif                        0x0000561b266a5049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimal = doubleValue - Double(intValue)\n    if decimal >= 0.5 {\n    \
    \    return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmphrztj8i1/tmphrztj8i1.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf8553fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf85236b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaf85236988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaf852357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphrztj8i1                        0x00005640fb238512 <unavailable> + 5394

    5    libc.so.6                          0x00002aaf8572b460 __libc_start_main +
    245

    6    tmphrztj8i1                        0x00005640fb238049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    if\
    \ number - Double(rounded) >= 0.5 {\n        return rounded + 1\n    } else {\n\
    \        return rounded\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.Rcn9Uu/tmpipdq2yua-1.o:tmpipdq2yua-1.o:function $s11tmpipdq2yua15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.Rcn9Uu/tmpipdq2yua-1.o:tmpipdq2yua-1.o:function $s11tmpipdq2yua15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.Rcn9Uu/tmpipdq2yua-1.o:tmpipdq2yua-1.o:function $s11tmpipdq2yua15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.Rcn9Uu/tmpipdq2yua-1.o:tmpipdq2yua-1.o:function $s11tmpipdq2yua15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.Rcn9Uu/tmpipdq2yua-1.o:tmpipdq2yua-1.o:function $s11tmpipdq2yua15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.Rcn9Uu/tmpipdq2yua-1.o:tmpipdq2yua-1.o:function $s11tmpipdq2yua15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.Rcn9Uu/tmpipdq2yua-1.o:tmpipdq2yua-1.o:function $s11tmpipdq2yua15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(number.rounded(.down))\n \
    \   let ceil = Int(number.rounded(.up))\n    let floorDiff = abs(floor - number)\n\
    \    let ceilDiff = abs(ceil - number)\n    return floorDiff < ceilDiff ? floor\
    \ : ceil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp6a667esf.swift:19:31: error: binary operator '-' cannot be applied\
    \ to operands of type 'Int' and 'Double'\n    let floorDiff = abs(floor - number)\n\
    \                        ~~~~~ ^ ~~~~~~\n/tmp/tmp6a667esf.swift:19:31: note: overloads\
    \ for '-' exist with these partially matching parameter lists: (Double, Double),\
    \ (Int, Int)\n    let floorDiff = abs(floor - number)\n                      \
    \        ^\n/tmp/tmp6a667esf.swift:20:29: error: binary operator '-' cannot be\
    \ applied to operands of type 'Int' and 'Double'\n    let ceilDiff = abs(ceil\
    \ - number)\n                       ~~~~ ^ ~~~~~~\n/tmp/tmp6a667esf.swift:20:29:\
    \ note: overloads for '-' exist with these partially matching parameter lists:\
    \ (Double, Double), (Int, Int)\n    let ceilDiff = abs(ceil - number)\n      \
    \                      ^\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    if abs(number - Double(rounded)) < abs(number - Double(floor)) {\n      \
    \  return rounded\n    } else if abs(number - Double(rounded)) < abs(number -\
    \ Double(ceil)) {\n        return rounded\n    } else if abs(number - Double(floor))\
    \ < abs(number - Double(ceil)) {\n        return floor\n    } else {\n       \
    \ return ceil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.pCicPu/tmptbou0hj5-1.o:tmptbou0hj5-1.o:function $s11tmptbou0hj515closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.pCicPu/tmptbou0hj5-1.o:tmptbou0hj5-1.o:function $s11tmptbou0hj515closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.pCicPu/tmptbou0hj5-1.o:tmptbou0hj5-1.o:function $s11tmptbou0hj515closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.pCicPu/tmptbou0hj5-1.o:tmptbou0hj5-1.o:function $s11tmptbou0hj515closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.pCicPu/tmptbou0hj5-1.o:tmptbou0hj5-1.o:function $s11tmptbou0hj515closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.pCicPu/tmptbou0hj5-1.o:tmptbou0hj5-1.o:function $s11tmptbou0hj515closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.pCicPu/tmptbou0hj5-1.o:tmptbou0hj5-1.o:function $s11tmptbou0hj515closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.pCicPu/tmptbou0hj5-1.o:tmptbou0hj5-1.o:function $s11tmptbou0hj515closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.pCicPu/tmptbou0hj5-1.o:tmptbou0hj5-1.o:function $s11tmptbou0hj515closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.pCicPu/tmptbou0hj5-1.o:tmptbou0hj5-1.o:function $s11tmptbou0hj515closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.pCicPu/tmptbou0hj5-1.o:tmptbou0hj5-1.o:function $s11tmptbou0hj515closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.pCicPu/tmptbou0hj5-1.o:tmptbou0hj5-1.o:function $s11tmptbou0hj515closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.pCicPu/tmptbou0hj5-1.o:tmptbou0hj5-1.o:function $s11tmptbou0hj515closest_i'
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    if number - Double(floor) == 0.5 {\n        return floor\n    } else if number\
    \ - Double(ceil) == -0.5 {\n        return ceil\n    } else {\n        return\
    \ rounded\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_i'
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(round(number))\n    let\
    \ floor = Int(floor(number))\n    let ceil = Int(ceil(number))\n    if abs(Double(rounded)\
    \ - number) < abs(Double(floor) - number) {\n        return rounded\n    } else\
    \ {\n        return floor\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpo47go2db.swift:17:23: error: cannot find 'round' in scope\n   \
    \ let rounded = Int(round(number))\n                      ^~~~~\n/tmp/tmpo47go2db.swift:18:21:\
    \ error: use of local variable 'floor' before its declaration\n    let floor =\
    \ Int(floor(number))\n                    ^\n/tmp/tmpo47go2db.swift:18:9: note:\
    \ 'floor' declared here\n    let floor = Int(floor(number))\n        ^\n/tmp/tmpo47go2db.swift:19:20:\
    \ error: use of local variable 'ceil' before its declaration\n    let ceil = Int(ceil(number))\n\
    \                   ^\n/tmp/tmpo47go2db.swift:19:9: note: 'ceil' declared here\n\
    \    let ceil = Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    let decimal = num - Double(int)\n\
    \    if decimal >= 0.5 {\n        return int + 1\n    } else {\n        return\
    \ int\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpn5zuqzif/tmpn5zuqzif.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b42db182c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b42dae79b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b42dae79988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b42dae787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn5zuqzif                        0x0000561b266a5512 <unavailable> + 5394

    5    libc.so.6                          0x00002b42db36e460 __libc_start_main +
    245

    6    tmpn5zuqzif                        0x0000561b266a5049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    let roundedInt = Int(roundedValue)\n    return roundedInt\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpjfe32e7o.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    let intValue = Int(roundedValue)\n    return intValue\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpop1ychme.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let floatValue = Float(value) ?? 0\n    let intValue = Int(floatValue)\n  \
    \  let decimal = floatValue - Float(intValue)\n    if decimal >= 0.5 {\n     \
    \   return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmppo_86oxc/tmppo_86oxc.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab317218c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab316f0fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab316f0f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab316f0e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppo_86oxc                        0x00005624f296b512 <unavailable> + 5394

    5    libc.so.6                          0x00002ab317404460 __libc_start_main +
    245

    6    tmppo_86oxc                        0x00005624f296b049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    if number - Double(floor) == 0.5 {\n        return number > 0 ? ceil : floor\n\
    \    }\n    return rounded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.iFoYPu/tmpj8fef3ij-1.o:tmpj8fef3ij-1.o:function $s11tmpj8fef3ij15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.iFoYPu/tmpj8fef3ij-1.o:tmpj8fef3ij-1.o:function $s11tmpj8fef3ij15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.iFoYPu/tmpj8fef3ij-1.o:tmpj8fef3ij-1.o:function $s11tmpj8fef3ij15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.iFoYPu/tmpj8fef3ij-1.o:tmpj8fef3ij-1.o:function $s11tmpj8fef3ij15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.iFoYPu/tmpj8fef3ij-1.o:tmpj8fef3ij-1.o:function $s11tmpj8fef3ij15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.iFoYPu/tmpj8fef3ij-1.o:tmpj8fef3ij-1.o:function $s11tmpj8fef3ij15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.iFoYPu/tmpj8fef3ij-1.o:tmpj8fef3ij-1.o:function $s11tmpj8fef3ij15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.iFoYPu/tmpj8fef3ij-1.o:tmpj8fef3ij-1.o:function $s11tmpj8fef3ij15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.iFoYPu/tmpj8fef3ij-1.o:tmpj8fef3ij-1.o:function $s11tmpj8fef3ij15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.iFoYPu/tmpj8fef3ij-1.o:tmpj8fef3ij-1.o:function $s11tmpj8fef3ij15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.iFoYPu/tmpj8fef3ij-1.o:tmpj8fef3ij-1.o:function $s11tmpj8fef3ij15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.iFoYPu/tmpj8fef3ij-1.o:tmpj8fef3ij-1.o:function $s11tmpj8fef3ij15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.iFoYPu/tmpj8fef3ij-1.o:tmpj8fef3ij-1.o:function $s11tmpj8fef3ij15closest_i'
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let integer = Int(number)\n    let decimal\
    \ = number - Double(integer)\n    if decimal < 0.5 {\n        return integer\n\
    \    } else {\n        return integer + 1\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpoovdz8zj/tmpoovdz8zj.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b25b182dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b25b1524b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b25b1524988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b25b15237b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoovdz8zj                        0x000055e93337b512 <unavailable> + 5394

    5    libc.so.6                          0x00002b25b1a19460 __libc_start_main +
    245

    6    tmpoovdz8zj                        0x000055e93337b049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let intNumber = Int(number)\n    let decimal\
    \ = number - Double(intNumber)\n    if decimal >= 0.5 {\n        return intNumber\
    \ + 1\n    } else {\n        return intNumber\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp4a1121tu/tmp4a1121tu.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba59e7ccc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba59e4c3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba59e4c3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba59e4c27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4a1121tu                        0x00005634d7553512 <unavailable> + 5394

    5    libc.so.6                          0x00002ba59e9b8460 __libc_start_main +
    245

    6    tmp4a1121tu                        0x00005634d7553049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let ceiled\
    \ = number.rounded(.up)\n    let floored = number.rounded(.down)\n    let diff1\
    \ = abs(number - rounded)\n    let diff2 = abs(number - ceiled)\n    let diff3\
    \ = abs(number - floored)\n    if diff1 < diff2 && diff1 < diff3 {\n        return\
    \ Int(rounded)\n    } else if diff2 < diff1 && diff2 < diff3 {\n        return\
    \ Int(ceiled)\n    } else {\n        return Int(floored)\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.n6p6Pt/tmpg3obz09_-1.o:tmpg3obz09_-1.o:function $s11tmpg3obz09_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.n6p6Pt/tmpg3obz09_-1.o:tmpg3obz09_-1.o:function $s11tmpg3obz09_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.n6p6Pt/tmpg3obz09_-1.o:tmpg3obz09_-1.o:function $s11tmpg3obz09_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.n6p6Pt/tmpg3obz09_-1.o:tmpg3obz09_-1.o:function $s11tmpg3obz09_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.n6p6Pt/tmpg3obz09_-1.o:tmpg3obz09_-1.o:function $s11tmpg3obz09_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.n6p6Pt/tmpg3obz09_-1.o:tmpg3obz09_-1.o:function $s11tmpg3obz09_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.n6p6Pt/tmpg3obz09_-1.o:tmpg3obz09_-1.o:function $s11tmpg3obz09_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.n6p6Pt/tmpg3obz09_-1.o:tmpg3obz09_-1.o:function $s11tmpg3obz09_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.n6p6Pt/tmpg3obz09_-1.o:tmpg3obz09_-1.o:function $s11tmpg3obz09_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.n6p6Pt/tmpg3obz09_-1.o:tmpg3obz09_-1.o:function $s11tmpg3obz09_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.n6p6Pt/tmpg3obz09_-1.o:tmpg3obz09_-1.o:function $s11tmpg3obz09_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.n6p6Pt/tmpg3obz09_-1.o:tmpg3obz09_-1.o:function $s11tmpg3obz09_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.n6p6Pt/tmpg3obz09_-1.o:tmpg3obz09_-1.o:function $s11tmpg3obz09_15closest_i'
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let floor\
    \ = number.rounded(.down)\n    let ceil = number.rounded(.up)\n    if number -\
    \ floor > ceil - number {\n        return Int(ceil)\n    } else {\n        return\
    \ Int(floor)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpi873j6le.swift:17:9: warning: initialization of immutable value\
    \ 'rounded' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let rounded = number.rounded()\n    ~~~~^~~~~~~\n    _\nerror: link\
    \ command failed with exit code 1 (use -v to see invocation)\n/tmp/TemporaryDirectory.0LdwTu/tmpi873j6le-1.o:tmpi873j6le-1.o:function\
    \ $s11tmpi873j6le15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.0LdwTu/tmpi873j6le-1.o:tmpi873j6le-1.o:function\
    \ $s11tmpi873j6le15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.0LdwTu/tmpi873j6le-1.o:tmpi873j6le-1.o:function\
    \ $s11tmpi873j6le15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.0LdwTu/tmpi873j6le-1.o:tmpi873j6le-1.o:function\
    \ $s11tmpi873j6le15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.0LdwTu/tmpi873j6le-1.o:tmpi873j6le-1.o:function\
    \ $s11tmpi873j6le15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.0LdwTu/tmpi873j6le-1.o:tmpi873j6le-1.o:function\
    \ $s11tmpi873j6le15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.0LdwTu/tmpi873j6le-1.o:tmpi873j6le-1.o:function\
    \ $s11tmpi873j6le15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.0LdwTu/tmpi873j6le-1.o:tmpi873j6le-1.o:function\
    \ $s11tmpi873j6le15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.0LdwTu/tmpi873j6le-1.o:tmpi873j6le-1.o:function\
    \ $s11tmpi873j6le15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.0LdwTu/tmpi873j6le-1.o:tmpi873j6le-1.o:function\
    \ $s11tmpi873j6le15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.0LdwTu/tmpi873j6le-1.o:tmpi873j6le-1.o:function\
    \ $s11tmpi873j6le15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.0LdwTu/tmpi873j6le-"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    if rounded\
    \ > number {\n        return Int(rounded) - 1\n    }\n    return Int(rounded)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.7UYkFu/tmpzrwcnna5-1.o:tmpzrwcnna5-1.o:function $s11tmpzrwcnna515closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.7UYkFu/tmpzrwcnna5-1.o:tmpzrwcnna5-1.o:function $s11tmpzrwcnna515closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.7UYkFu/tmpzrwcnna5-1.o:tmpzrwcnna5-1.o:function $s11tmpzrwcnna515closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.7UYkFu/tmpzrwcnna5-1.o:tmpzrwcnna5-1.o:function $s11tmpzrwcnna515closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.7UYkFu/tmpzrwcnna5-1.o:tmpzrwcnna5-1.o:function $s11tmpzrwcnna515closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.7UYkFu/tmpzrwcnna5-1.o:tmpzrwcnna5-1.o:function $s11tmpzrwcnna515closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.7UYkFu/tmpzrwcnna5-1.o:tmpzrwcnna5-1.o:function $s11tmpzrwcnna515closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    if number - Double(floor) < Double(ceil) - number {\n        return floor\n\
    \    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp_rfjpuic.swift:17:9: warning: initialization of immutable value\
    \ 'rounded' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let rounded = Int(number.rounded())\n    ~~~~^~~~~~~\n    _\nerror:\
    \ link command failed with exit code 1 (use -v to see invocation)\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfj"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    let intValue = Int(roundedValue)\n    return intValue\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpop1ychme.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimalValue = doubleValue - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp51_hz_j6/tmp51_hz_j6.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae2a3878c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae2a356fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae2a356f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae2a356e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp51_hz_j6                        0x000056304faa4512 <unavailable> + 5394

    5    libc.so.6                          0x00002ae2a3a64460 __libc_start_main +
    245

    6    tmp51_hz_j6                        0x000056304faa4049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(Double(value)!.rounded(.awayFromZero))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let ceiled\
    \ = ceil(number)\n    let floored = floor(number)\n    if abs(rounded - number)\
    \ < abs(ceiled - number) {\n        return Int(rounded)\n    } else if abs(rounded\
    \ - number) > abs(ceiled - number) {\n        return Int(ceiled)\n    } else {\n\
    \        return Int(floored)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp0omglovh.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n/tmp/tmp0omglovh.swift:18:18:\
    \ error: cannot find 'ceil' in scope\n    let ceiled = ceil(number)\n        \
    \         ^~~~\n/tmp/tmp0omglovh.swift:19:19: error: cannot find 'floor' in scope\n\
    \    let floored = floor(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimal = doubleValue - Double(intValue)\n    if decimal >= 0.5 {\n    \
    \    return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmphrztj8i1/tmphrztj8i1.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf8553fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf85236b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaf85236988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaf852357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphrztj8i1                        0x00005640fb238512 <unavailable> + 5394

    5    libc.so.6                          0x00002aaf8572b460 __libc_start_main +
    245

    6    tmphrztj8i1                        0x00005640fb238049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    let decimal = num - Double(int)\n\
    \    if decimal >= 0.5 {\n        return int + 1\n    } else {\n        return\
    \ int\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpn5zuqzif/tmpn5zuqzif.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b42db182c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b42dae79b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b42dae79988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b42dae787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn5zuqzif                        0x0000561b266a5512 <unavailable> + 5394

    5    libc.so.6                          0x00002b42db36e460 __libc_start_main +
    245

    6    tmpn5zuqzif                        0x0000561b266a5049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(number.rounded(.down))\n \
    \   let ceil = Int(number.rounded(.up))\n    let diff_floor = abs(number - Double(floor))\n\
    \    let diff_ceil = abs(number - Double(ceil))\n    return diff_floor < diff_ceil\
    \ ? floor : ceil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.HFcUKu/tmpley71tfi-1.o:tmpley71tfi-1.o:function $s11tmpley71tfi15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.HFcUKu/tmpley71tfi-1.o:tmpley71tfi-1.o:function $s11tmpley71tfi15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.HFcUKu/tmpley71tfi-1.o:tmpley71tfi-1.o:function $s11tmpley71tfi15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.HFcUKu/tmpley71tfi-1.o:tmpley71tfi-1.o:function $s11tmpley71tfi15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.HFcUKu/tmpley71tfi-1.o:tmpley71tfi-1.o:function $s11tmpley71tfi15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.HFcUKu/tmpley71tfi-1.o:tmpley71tfi-1.o:function $s11tmpley71tfi15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.HFcUKu/tmpley71tfi-1.o:tmpley71tfi-1.o:function $s11tmpley71tfi15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.HFcUKu/tmpley71tfi-1.o:tmpley71tfi-1.o:function $s11tmpley71tfi15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.HFcUKu/tmpley71tfi-1.o:tmpley71tfi-1.o:function $s11tmpley71tfi15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.HFcUKu/tmpley71tfi-1.o:tmpley71tfi-1.o:function $s11tmpley71tfi15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.HFcUKu/tmpley71tfi-1.o:tmpley71tfi-1.o:function $s11tmpley71tfi15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.HFcUKu/tmpley71tfi-1.o:tmpley71tfi-1.o:function $s11tmpley71tfi15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.HFcUKu/tmpley71tfi-1.o:tmpley71tfi-1.o:function $s11tmpley71tfi15closest_i'
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    let floorDiff = abs(number - Double(floor))\n    let ceilDiff = abs(number\
    \ - Double(ceil))\n    if floorDiff == ceilDiff {\n        return number < 0 ?\
    \ floor : ceil\n    }\n    return floorDiff < ceilDiff ? floor : ceil\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpqtvt09ul.swift:17:9: warning: initialization of immutable value\
    \ 'rounded' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let rounded = Int(number.rounded())\n    ~~~~^~~~~~~\n    _\nerror:\
    \ link command failed with exit code 1 (use -v to see invocation)\n/tmp/TemporaryDirectory.gBz4fe/tmpqtvt09ul-1.o:tmpqtvt09ul-1.o:function\
    \ $s11tmpqtvt09ul15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.gBz4fe/tmpqtvt09ul-1.o:tmpqtvt09ul-1.o:function\
    \ $s11tmpqtvt09ul15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.gBz4fe/tmpqtvt09ul-1.o:tmpqtvt09ul-1.o:function\
    \ $s11tmpqtvt09ul15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.gBz4fe/tmpqtvt09ul-1.o:tmpqtvt09ul-1.o:function\
    \ $s11tmpqtvt09ul15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.gBz4fe/tmpqtvt09ul-1.o:tmpqtvt09ul-1.o:function\
    \ $s11tmpqtvt09ul15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.gBz4fe/tmpqtvt09ul-1.o:tmpqtvt09ul-1.o:function\
    \ $s11tmpqtvt09ul15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.gBz4fe/tmpqtvt09ul-1.o:tmpqtvt09ul-1.o:function\
    \ $s11tmpqtvt09ul15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.gBz4fe/tmpqtvt09ul-1.o:tmpqtvt09ul-1.o:function\
    \ $s11tmpqtvt09ul15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.gBz4fe/tmpqtvt09ul-1.o:tmpqtvt09ul-1.o:function\
    \ $s11tmpqtvt09ul15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.gBz4fe/tmpqtvt09ul-1.o:tmpqtvt09ul-1.o:function\
    \ $s11tmpqtvt09ul15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.gBz4fe/tmpqtvt09ul-1.o:tmpqtvt09ul-1.o:function\
    \ $s11tmpqtvt09ul15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.gBz4fe/tmpqtvt"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let floor\
    \ = number.rounded(.down)\n    let ceil = number.rounded(.up)\n    if number -\
    \ floor < ceil - number {\n        return Int(floor)\n    } else {\n        return\
    \ Int(ceil)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpksdwom9o.swift:17:9: warning: initialization of immutable value\
    \ 'rounded' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let rounded = number.rounded()\n    ~~~~^~~~~~~\n    _\nerror: link\
    \ command failed with exit code 1 (use -v to see invocation)\n/tmp/TemporaryDirectory.VTfEUd/tmpksdwom9o-1.o:tmpksdwom9o-1.o:function\
    \ $s11tmpksdwom9o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.VTfEUd/tmpksdwom9o-1.o:tmpksdwom9o-1.o:function\
    \ $s11tmpksdwom9o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.VTfEUd/tmpksdwom9o-1.o:tmpksdwom9o-1.o:function\
    \ $s11tmpksdwom9o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.VTfEUd/tmpksdwom9o-1.o:tmpksdwom9o-1.o:function\
    \ $s11tmpksdwom9o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.VTfEUd/tmpksdwom9o-1.o:tmpksdwom9o-1.o:function\
    \ $s11tmpksdwom9o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.VTfEUd/tmpksdwom9o-1.o:tmpksdwom9o-1.o:function\
    \ $s11tmpksdwom9o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.VTfEUd/tmpksdwom9o-1.o:tmpksdwom9o-1.o:function\
    \ $s11tmpksdwom9o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.VTfEUd/tmpksdwom9o-1.o:tmpksdwom9o-1.o:function\
    \ $s11tmpksdwom9o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.VTfEUd/tmpksdwom9o-1.o:tmpksdwom9o-1.o:function\
    \ $s11tmpksdwom9o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.VTfEUd/tmpksdwom9o-1.o:tmpksdwom9o-1.o:function\
    \ $s11tmpksdwom9o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.VTfEUd/tmpksdwom9o-1.o:tmpksdwom9o-1.o:function\
    \ $s11tmpksdwom9o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.VTfEUd/tmpksdwom9o-"
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimalValue = doubleValue - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp51_hz_j6/tmp51_hz_j6.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae2a3878c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae2a356fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae2a356f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae2a356e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp51_hz_j6                        0x000056304faa4512 <unavailable> + 5394

    5    libc.so.6                          0x00002ae2a3a64460 __libc_start_main +
    245

    6    tmp51_hz_j6                        0x000056304faa4049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimal = doubleValue - Double(intValue)\n    if decimal >= 0.5 {\n    \
    \    return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmphrztj8i1/tmphrztj8i1.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf8553fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf85236b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaf85236988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaf852357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphrztj8i1                        0x00005640fb238512 <unavailable> + 5394

    5    libc.so.6                          0x00002aaf8572b460 __libc_start_main +
    245

    6    tmphrztj8i1                        0x00005640fb238049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let rounded = round(doubleValue)\n  \
    \  return Int(rounded)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpghv4r0el.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(doubleValue)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let integer = Int(number)\n    let decimal\
    \ = number - Double(integer)\n    if decimal >= 0.5 {\n        return integer\
    \ + 1\n    } else {\n        return integer\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpvmf5afa_/tmpvmf5afa_.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b74a8338c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b74a802fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b74a802f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b74a802e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvmf5afa_                        0x000055556e231512 <unavailable> + 5394

    5    libc.so.6                          0x00002b74a8524460 __libc_start_main +
    245

    6    tmpvmf5afa_                        0x000055556e231049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let ceiled\
    \ = number.rounded(.up)\n    let floored = number.rounded(.down)\n    if number\
    \ - rounded == 0 {\n        return Int(rounded)\n    } else if number - rounded\
    \ > 0 {\n        if number - ceiled < ceiled - number {\n            return Int(ceiled)\n\
    \        } else {\n            return Int(floored)\n        }\n    } else {\n\
    \        if number - floored < floored - number {\n            return Int(floored)\n\
    \        } else {\n            return Int(ceiled)\n        }\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.v8uUAd/tmpuhtyuuno-1.o:tmpuhtyuuno-1.o:function $s11tmpuhtyuuno15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.v8uUAd/tmpuhtyuuno-1.o:tmpuhtyuuno-1.o:function $s11tmpuhtyuuno15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.v8uUAd/tmpuhtyuuno-1.o:tmpuhtyuuno-1.o:function $s11tmpuhtyuuno15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.v8uUAd/tmpuhtyuuno-1.o:tmpuhtyuuno-1.o:function $s11tmpuhtyuuno15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.v8uUAd/tmpuhtyuuno-1.o:tmpuhtyuuno-1.o:function $s11tmpuhtyuuno15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.v8uUAd/tmpuhtyuuno-1.o:tmpuhtyuuno-1.o:function $s11tmpuhtyuuno15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.v8uUAd/tmpuhtyuuno-1.o:tmpuhtyuuno-1.o:function $s11tmpuhtyuuno15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.v8uUAd/tmpuhtyuuno-1.o:tmpuhtyuuno-1.o:function $s11tmpuhtyuuno15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.v8uUAd/tmpuhtyuuno-1.o:tmpuhtyuuno-1.o:function $s11tmpuhtyuuno15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.v8uUAd/tmpuhtyuuno-1.o:tmpuhtyuuno-1.o:function $s11tmpuhtyuuno15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.v8uUAd/tmpuhtyuuno-1.o:tmpuhtyuuno-1.o:function $s11tmpuhtyuuno15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.v8uUAd/tmpuhtyuuno-1.o:tmpuhtyuuno-1.o:function $s11tmpuhtyuuno15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.v8uUAd/tmpuhtyuuno-1.o:tmpuhtyuuno-1.o:function $s11tmpuhtyuuno15closest_i'
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < 0.5 {\n        return floor\n\
    \    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpz5m7rozs.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpz5m7rozs.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpz5m7rozs.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpz5m7rozs.swift:18:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    let floorDiff = abs(floor - number)\n    let ceilDiff = abs(ceil - number)\n\
    \    if floorDiff == ceilDiff {\n        return floor > 0 ? floor : ceil\n   \
    \ }\n    return floorDiff < ceilDiff ? floor : ceil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmppyxdyz9s.swift:20:31: error: binary operator '-' cannot be applied\
    \ to operands of type 'Int' and 'Double'\n    let floorDiff = abs(floor - number)\n\
    \                        ~~~~~ ^ ~~~~~~\n/tmp/tmppyxdyz9s.swift:20:31: note: overloads\
    \ for '-' exist with these partially matching parameter lists: (Double, Double),\
    \ (Int, Int)\n    let floorDiff = abs(floor - number)\n                      \
    \        ^\n/tmp/tmppyxdyz9s.swift:21:29: error: binary operator '-' cannot be\
    \ applied to operands of type 'Int' and 'Double'\n    let ceilDiff = abs(ceil\
    \ - number)\n                       ~~~~ ^ ~~~~~~\n/tmp/tmppyxdyz9s.swift:21:29:\
    \ note: overloads for '-' exist with these partially matching parameter lists:\
    \ (Double, Double), (Int, Int)\n    let ceilDiff = abs(ceil - number)\n      \
    \                      ^\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceiling = Int(number.rounded(.up))\n\
    \    if number - Double(floor) == 0.5 {\n        return ceiling\n    } else if\
    \ number - Double(floor) == -0.5 {\n        return floor\n    } else {\n     \
    \   return rounded\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_i'
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let roundedInt\
    \ = Int(rounded)\n    return roundedInt\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmplgrhlscs.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    let decimal = num - Double(int)\n\
    \    if decimal >= 0.5 {\n        return int + 1\n    } else {\n        return\
    \ int\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpn5zuqzif/tmpn5zuqzif.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b42db182c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b42dae79b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b42dae79988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b42dae787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn5zuqzif                        0x0000561b266a5512 <unavailable> + 5394

    5    libc.so.6                          0x00002b42db36e460 __libc_start_main +
    245

    6    tmpn5zuqzif                        0x0000561b266a5049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    if number - Double(floor) == 0.5 {\n        return floor\n    } else if number\
    \ - Double(ceil) == -0.5 {\n        return ceil\n    } else {\n        return\
    \ rounded\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_i'
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    if number - Double(floor) == 0.5 {\n        return floor\n    } else if number\
    \ - Double(ceil) == -0.5 {\n        return ceil\n    } else {\n        return\
    \ rounded\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_i'
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value = Double(value)!\n    let floor = Int(floor(value))\n    let ceil\
    \ = Int(ceil(value))\n    if value - Double(floor) < Double(ceil) - value {\n\
    \        return floor\n    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp7yy15cxl.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(value))\n                    ^\n\
    /tmp/tmp7yy15cxl.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(value))\n\
    \        ^\n/tmp/tmp7yy15cxl.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(value))\n                  \
    \ ^\n/tmp/tmp7yy15cxl.swift:18:9: note: 'ceil' declared here\n    let ceil = Int(ceil(value))\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let integer = Int(number)\n    let decimal\
    \ = number - Double(integer)\n    if decimal < 0.5 {\n        return integer\n\
    \    } else {\n        return integer + 1\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpoovdz8zj/tmpoovdz8zj.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b25b182dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b25b1524b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b25b1524988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b25b15237b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoovdz8zj                        0x000055e93337b512 <unavailable> + 5394

    5    libc.so.6                          0x00002b25b1a19460 __libc_start_main +
    245

    6    tmpoovdz8zj                        0x000055e93337b049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    let decimal = num - Double(int)\n\
    \    if decimal >= 0.5 {\n        return int + 1\n    } else {\n        return\
    \ int\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpn5zuqzif/tmpn5zuqzif.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b42db182c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b42dae79b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b42dae79988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b42dae787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn5zuqzif                        0x0000561b266a5512 <unavailable> + 5394

    5    libc.so.6                          0x00002b42db36e460 __libc_start_main +
    245

    6    tmpn5zuqzif                        0x0000561b266a5049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    let dec = num - Double(int)\n\
    \    if dec >= 0.5 {\n        return int + 1\n    } else {\n        return int\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmp9e7hpgsh/tmp9e7hpgsh.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b496d0a5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b496cd9cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b496cd9c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b496cd9b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9e7hpgsh                        0x000055ccfe3b2512 <unavailable> + 5394

    5    libc.so.6                          0x00002b496d291460 __libc_start_main +
    245

    6    tmp9e7hpgsh                        0x000055ccfe3b2049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceiling = Int(number.rounded(.up))\n\
    \    let floorDiff = abs(number - Double(floor))\n    let ceilingDiff = abs(number\
    \ - Double(ceiling))\n    if floorDiff < ceilingDiff {\n        return floor\n\
    \    } else if floorDiff > ceilingDiff {\n        return ceiling\n    } else {\n\
    \        return rounded\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.hWfLLD/tmp5ajhxofa-1.o:tmp5ajhxofa-1.o:function $s11tmp5ajhxofa15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.hWfLLD/tmp5ajhxofa-1.o:tmp5ajhxofa-1.o:function $s11tmp5ajhxofa15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.hWfLLD/tmp5ajhxofa-1.o:tmp5ajhxofa-1.o:function $s11tmp5ajhxofa15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.hWfLLD/tmp5ajhxofa-1.o:tmp5ajhxofa-1.o:function $s11tmp5ajhxofa15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.hWfLLD/tmp5ajhxofa-1.o:tmp5ajhxofa-1.o:function $s11tmp5ajhxofa15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.hWfLLD/tmp5ajhxofa-1.o:tmp5ajhxofa-1.o:function $s11tmp5ajhxofa15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.hWfLLD/tmp5ajhxofa-1.o:tmp5ajhxofa-1.o:function $s11tmp5ajhxofa15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.hWfLLD/tmp5ajhxofa-1.o:tmp5ajhxofa-1.o:function $s11tmp5ajhxofa15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.hWfLLD/tmp5ajhxofa-1.o:tmp5ajhxofa-1.o:function $s11tmp5ajhxofa15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.hWfLLD/tmp5ajhxofa-1.o:tmp5ajhxofa-1.o:function $s11tmp5ajhxofa15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.hWfLLD/tmp5ajhxofa-1.o:tmp5ajhxofa-1.o:function $s11tmp5ajhxofa15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.hWfLLD/tmp5ajhxofa-1.o:tmp5ajhxofa-1.o:function $s11tmp5ajhxofa15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.hWfLLD/tmp5ajhxofa-1.o:tmp5ajhxofa-1.o:function $s11tmp5ajhxofa15closest_i'
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    let intValue = Int(roundedValue)\n    return intValue\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpop1ychme.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceiling = Int(number.rounded(.up))\n\
    \    if number - Double(floor) == 0.5 {\n        return ceiling\n    } else if\
    \ number - Double(floor) == -0.5 {\n        return floor\n    } else {\n     \
    \   return rounded\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_i'
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    if abs(number - Double(rounded)) == 0.5 {\n        if number > 0 {\n    \
    \        return ceil\n        } else {\n            return floor\n        }\n\
    \    } else {\n        return rounded\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_i'
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceiling = Int(number.rounded(.up))\n\
    \    let floorDiff = abs(number - Double(floor))\n    let ceilingDiff = abs(number\
    \ - Double(ceiling))\n    if floorDiff == ceilingDiff {\n        return rounded\
    \ > 0 ? ceiling : floor\n    }\n    return floorDiff < ceilingDiff ? floor : ceiling\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_i'
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let roundedInt\
    \ = Int(rounded)\n    let decimal = number - rounded\n    if decimal == 0 {\n\
    \        return roundedInt\n    } else if decimal > 0 {\n        return roundedInt\
    \ + 1\n    } else {\n        return roundedInt - 1\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.kJ260N/tmpg1829udu-1.o:tmpg1829udu-1.o:function $s11tmpg1829udu15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.kJ260N/tmpg1829udu-1.o:tmpg1829udu-1.o:function $s11tmpg1829udu15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.kJ260N/tmpg1829udu-1.o:tmpg1829udu-1.o:function $s11tmpg1829udu15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.kJ260N/tmpg1829udu-1.o:tmpg1829udu-1.o:function $s11tmpg1829udu15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.kJ260N/tmpg1829udu-1.o:tmpg1829udu-1.o:function $s11tmpg1829udu15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.kJ260N/tmpg1829udu-1.o:tmpg1829udu-1.o:function $s11tmpg1829udu15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.kJ260N/tmpg1829udu-1.o:tmpg1829udu-1.o:function $s11tmpg1829udu15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    let intValue = Int(roundedValue)\n    return intValue\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpop1ychme.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let diff\
    \ = number - rounded\n    if diff > 0 {\n        return Int(rounded + 1)\n   \
    \ } else if diff < 0 {\n        return Int(rounded - 1)\n    } else {\n      \
    \  return Int(rounded)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp3dpvdacq.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    if number\
    \ - rounded > 0.5 {\n        return Int(rounded + 1)\n    } else if number - rounded\
    \ < -0.5 {\n        return Int(rounded - 1)\n    } else {\n        return Int(rounded)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.UctEzN/tmpt2_q7dan-1.o:tmpt2_q7dan-1.o:function $s11tmpt2_q7dan15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.UctEzN/tmpt2_q7dan-1.o:tmpt2_q7dan-1.o:function $s11tmpt2_q7dan15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.UctEzN/tmpt2_q7dan-1.o:tmpt2_q7dan-1.o:function $s11tmpt2_q7dan15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.UctEzN/tmpt2_q7dan-1.o:tmpt2_q7dan-1.o:function $s11tmpt2_q7dan15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.UctEzN/tmpt2_q7dan-1.o:tmpt2_q7dan-1.o:function $s11tmpt2_q7dan15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.UctEzN/tmpt2_q7dan-1.o:tmpt2_q7dan-1.o:function $s11tmpt2_q7dan15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.UctEzN/tmpt2_q7dan-1.o:tmpt2_q7dan-1.o:function $s11tmpt2_q7dan15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    if number - Double(floor) < Double(ceil) - number {\n        return floor\n\
    \    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp_rfjpuic.swift:17:9: warning: initialization of immutable value\
    \ 'rounded' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let rounded = Int(number.rounded())\n    ~~~~^~~~~~~\n    _\nerror:\
    \ link command failed with exit code 1 (use -v to see invocation)\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfj"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    return Int(rounded)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpth5ptwc1.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < 0.5 {\n        return floor\n\
    \    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpz5m7rozs.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpz5m7rozs.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpz5m7rozs.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpz5m7rozs.swift:18:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let integer = Int(number)\n    let decimal\
    \ = number - Double(integer)\n    if decimal >= 0.5 {\n        return integer\
    \ + 1\n    } else {\n        return integer\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpvmf5afa_/tmpvmf5afa_.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b74a8338c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b74a802fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b74a802f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b74a802e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvmf5afa_                        0x000055556e231512 <unavailable> + 5394

    5    libc.so.6                          0x00002b74a8524460 __libc_start_main +
    245

    6    tmpvmf5afa_                        0x000055556e231049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimal = doubleValue - Double(intValue)\n    if decimal >= 0.5 {\n    \
    \    return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmphrztj8i1/tmphrztj8i1.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf8553fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf85236b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaf85236988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaf852357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphrztj8i1                        0x00005640fb238512 <unavailable> + 5394

    5    libc.so.6                          0x00002aaf8572b460 __libc_start_main +
    245

    6    tmphrztj8i1                        0x00005640fb238049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimalValue = doubleValue - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp51_hz_j6/tmp51_hz_j6.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae2a3878c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae2a356fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae2a356f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae2a356e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp51_hz_j6                        0x000056304faa4512 <unavailable> + 5394

    5    libc.so.6                          0x00002ae2a3a64460 __libc_start_main +
    245

    6    tmp51_hz_j6                        0x000056304faa4049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    return\
    \ rounded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.uRG6yN/tmpbybu7a2b-1.o:tmpbybu7a2b-1.o:function $s11tmpbybu7a2b15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.uRG6yN/tmpbybu7a2b-1.o:tmpbybu7a2b-1.o:function $s11tmpbybu7a2b15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.uRG6yN/tmpbybu7a2b-1.o:tmpbybu7a2b-1.o:function $s11tmpbybu7a2b15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.uRG6yN/tmpbybu7a2b-1.o:tmpbybu7a2b-1.o:function $s11tmpbybu7a2b15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.uRG6yN/tmpbybu7a2b-1.o:tmpbybu7a2b-1.o:function $s11tmpbybu7a2b15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.uRG6yN/tmpbybu7a2b-1.o:tmpbybu7a2b-1.o:function $s11tmpbybu7a2b15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.uRG6yN/tmpbybu7a2b-1.o:tmpbybu7a2b-1.o:function $s11tmpbybu7a2b15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    let decimal = num - Double(int)\n\
    \    if decimal < 0.5 {\n        return int\n    } else {\n        return int\
    \ + 1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmp3wwshpld/tmp3wwshpld.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab6a7b61c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab6a7858b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab6a7858988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab6a78577b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3wwshpld                        0x000055f1c250d512 <unavailable> + 5394

    5    libc.so.6                          0x00002ab6a7d4d460 __libc_start_main +
    245

    6    tmp3wwshpld                        0x000055f1c250d049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let integer\
    \ = Int(rounded)\n    return integer\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpqq1intpe.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    let diff1 = abs(number - Double(floor))\n    let diff2\
    \ = abs(number - Double(ceil))\n    if diff1 == diff2 {\n        return number\
    \ > 0 ? ceil : floor\n    }\n    return diff1 < diff2 ? floor : ceil\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpiavb1jz2.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpiavb1jz2.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpiavb1jz2.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpiavb1jz2.swift:18:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimal = doubleValue - Double(intValue)\n    if decimal >= 0.5 {\n    \
    \    return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmphrztj8i1/tmphrztj8i1.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf8553fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf85236b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaf85236988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaf852357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphrztj8i1                        0x00005640fb238512 <unavailable> + 5394

    5    libc.so.6                          0x00002aaf8572b460 __libc_start_main +
    245

    6    tmphrztj8i1                        0x00005640fb238049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ decimal = number - Double(rounded)\n    if decimal < 0 {\n        return rounded\
    \ - 1\n    } else if decimal > 0 {\n        return rounded + 1\n    } else {\n\
    \        return rounded\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.gS7YoN/tmpgwp65m0l-1.o:tmpgwp65m0l-1.o:function $s11tmpgwp65m0l15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.gS7YoN/tmpgwp65m0l-1.o:tmpgwp65m0l-1.o:function $s11tmpgwp65m0l15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.gS7YoN/tmpgwp65m0l-1.o:tmpgwp65m0l-1.o:function $s11tmpgwp65m0l15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.gS7YoN/tmpgwp65m0l-1.o:tmpgwp65m0l-1.o:function $s11tmpgwp65m0l15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.gS7YoN/tmpgwp65m0l-1.o:tmpgwp65m0l-1.o:function $s11tmpgwp65m0l15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.gS7YoN/tmpgwp65m0l-1.o:tmpgwp65m0l-1.o:function $s11tmpgwp65m0l15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.gS7YoN/tmpgwp65m0l-1.o:tmpgwp65m0l-1.o:function $s11tmpgwp65m0l15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(value) ?? Int(Double(value)!.rounded(.awayFromZero))\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.4f88JM/tmpy8q9rexm-1.o:tmpy8q9rexm-1.o:function $s11tmpy8q9rexm15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.4f88JM/tmpy8q9rexm-1.o:tmpy8q9rexm-1.o:function $s11tmpy8q9rexm15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.4f88JM/tmpy8q9rexm-1.o:tmpy8q9rexm-1.o:function $s11tmpy8q9rexm15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.4f88JM/tmpy8q9rexm-1.o:tmpy8q9rexm-1.o:function $s11tmpy8q9rexm15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.4f88JM/tmpy8q9rexm-1.o:tmpy8q9rexm-1.o:function $s11tmpy8q9rexm15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.4f88JM/tmpy8q9rexm-1.o:tmpy8q9rexm-1.o:function $s11tmpy8q9rexm15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.4f88JM/tmpy8q9rexm-1.o:tmpy8q9rexm-1.o:function $s11tmpy8q9rexm15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let intNumber = Int(number)\n    if number\
    \ - Double(intNumber) < 0.5 {\n        return intNumber\n    } else {\n      \
    \  return intNumber + 1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmp_7q7_hfd/tmp_7q7_hfd.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6b03987c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6b0367eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6b0367e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6b0367d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_7q7_hfd                        0x0000557773965512 <unavailable> + 5394

    5    libc.so.6                          0x00002b6b03b73460 __libc_start_main +
    245

    6    tmp_7q7_hfd                        0x0000557773965049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    return\
    \ Int(rounded)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.0ma5OM/tmpun2am6bj-1.o:tmpun2am6bj-1.o:function $s11tmpun2am6bj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.0ma5OM/tmpun2am6bj-1.o:tmpun2am6bj-1.o:function $s11tmpun2am6bj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.0ma5OM/tmpun2am6bj-1.o:tmpun2am6bj-1.o:function $s11tmpun2am6bj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.0ma5OM/tmpun2am6bj-1.o:tmpun2am6bj-1.o:function $s11tmpun2am6bj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.0ma5OM/tmpun2am6bj-1.o:tmpun2am6bj-1.o:function $s11tmpun2am6bj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.0ma5OM/tmpun2am6bj-1.o:tmpun2am6bj-1.o:function $s11tmpun2am6bj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.0ma5OM/tmpun2am6bj-1.o:tmpun2am6bj-1.o:function $s11tmpun2am6bj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let floor = Int(num.rounded(.down))\n    let\
    \ ceil = Int(num.rounded(.up))\n    let diff1 = abs(num - Double(floor))\n   \
    \ let diff2 = abs(num - Double(ceil))\n    if diff1 < diff2 {\n        return\
    \ floor\n    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.MGwKDM/tmp4vk5nrey-1.o:tmp4vk5nrey-1.o:function $s11tmp4vk5nrey15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.MGwKDM/tmp4vk5nrey-1.o:tmp4vk5nrey-1.o:function $s11tmp4vk5nrey15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.MGwKDM/tmp4vk5nrey-1.o:tmp4vk5nrey-1.o:function $s11tmp4vk5nrey15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.MGwKDM/tmp4vk5nrey-1.o:tmp4vk5nrey-1.o:function $s11tmp4vk5nrey15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.MGwKDM/tmp4vk5nrey-1.o:tmp4vk5nrey-1.o:function $s11tmp4vk5nrey15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.MGwKDM/tmp4vk5nrey-1.o:tmp4vk5nrey-1.o:function $s11tmp4vk5nrey15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.MGwKDM/tmp4vk5nrey-1.o:tmp4vk5nrey-1.o:function $s11tmp4vk5nrey15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.MGwKDM/tmp4vk5nrey-1.o:tmp4vk5nrey-1.o:function $s11tmp4vk5nrey15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.MGwKDM/tmp4vk5nrey-1.o:tmp4vk5nrey-1.o:function $s11tmp4vk5nrey15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.MGwKDM/tmp4vk5nrey-1.o:tmp4vk5nrey-1.o:function $s11tmp4vk5nrey15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.MGwKDM/tmp4vk5nrey-1.o:tmp4vk5nrey-1.o:function $s11tmp4vk5nrey15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.MGwKDM/tmp4vk5nrey-1.o:tmp4vk5nrey-1.o:function $s11tmp4vk5nrey15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.MGwKDM/tmp4vk5nrey-1.o:tmp4vk5nrey-1.o:function $s11tmp4vk5nrey15closest_i'
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimal = doubleValue - Double(intValue)\n    if decimal >= 0.5 {\n    \
    \    return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmphrztj8i1/tmphrztj8i1.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf8553fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf85236b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaf85236988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaf852357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphrztj8i1                        0x00005640fb238512 <unavailable> + 5394

    5    libc.so.6                          0x00002aaf8572b460 __libc_start_main +
    245

    6    tmphrztj8i1                        0x00005640fb238049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value = Double(value)!\n    let floor = Int(floor(value))\n    let ceil\
    \ = Int(ceil(value))\n    if value - Double(floor) > Double(ceil) - value {\n\
    \        return ceil\n    } else {\n        return floor\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp4z0xme00.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(value))\n                    ^\n\
    /tmp/tmp4z0xme00.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(value))\n\
    \        ^\n/tmp/tmp4z0xme00.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(value))\n                  \
    \ ^\n/tmp/tmp4z0xme00.swift:18:9: note: 'ceil' declared here\n    let ceil = Int(ceil(value))\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value = Double(value)!\n    let integer = Int(value)\n    let decimal =\
    \ value - Double(integer)\n    if decimal >= 0.5 {\n        return integer + 1\n\
    \    } else {\n        return integer\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpqt9tybyo/tmpqt9tybyo.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac576beec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac5768e5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac5768e5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac5768e47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqt9tybyo                        0x000055dc6b40b512 <unavailable> + 5394

    5    libc.so.6                          0x00002ac576dda460 __libc_start_main +
    245

    6    tmpqt9tybyo                        0x000055dc6b40b049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let integer\
    \ = Int(rounded)\n    return integer\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.KhlbcM/tmp_qkybqxu-1.o:tmp_qkybqxu-1.o:function $s11tmp_qkybqxu15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.KhlbcM/tmp_qkybqxu-1.o:tmp_qkybqxu-1.o:function $s11tmp_qkybqxu15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.KhlbcM/tmp_qkybqxu-1.o:tmp_qkybqxu-1.o:function $s11tmp_qkybqxu15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.KhlbcM/tmp_qkybqxu-1.o:tmp_qkybqxu-1.o:function $s11tmp_qkybqxu15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.KhlbcM/tmp_qkybqxu-1.o:tmp_qkybqxu-1.o:function $s11tmp_qkybqxu15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.KhlbcM/tmp_qkybqxu-1.o:tmp_qkybqxu-1.o:function $s11tmp_qkybqxu15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.KhlbcM/tmp_qkybqxu-1.o:tmp_qkybqxu-1.o:function $s11tmp_qkybqxu15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let int =\
    \ Int(rounded)\n    return int\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp9mnfnrq9.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(Double(value)!.rounded(.awayFromZero))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(round(number))\n    let\
    \ floor = Int(floor(number))\n    let ceil = Int(ceil(number))\n    if number\
    \ - Double(floor) < 0.5 {\n        return floor\n    } else if number - Double(floor)\
    \ > 0.5 {\n        return ceil\n    } else {\n        return rounded\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpwvjm7epe.swift:17:23: error: cannot find 'round' in scope\n   \
    \ let rounded = Int(round(number))\n                      ^~~~~\n/tmp/tmpwvjm7epe.swift:18:21:\
    \ error: use of local variable 'floor' before its declaration\n    let floor =\
    \ Int(floor(number))\n                    ^\n/tmp/tmpwvjm7epe.swift:18:9: note:\
    \ 'floor' declared here\n    let floor = Int(floor(number))\n        ^\n/tmp/tmpwvjm7epe.swift:19:20:\
    \ error: use of local variable 'ceil' before its declaration\n    let ceil = Int(ceil(number))\n\
    \                   ^\n/tmp/tmpwvjm7epe.swift:19:9: note: 'ceil' declared here\n\
    \    let ceil = Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    return Int(rounded)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpth5ptwc1.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let floatValue = Float(value) ?? 0\n    let intValue = Int(floatValue)\n  \
    \  let decimal = floatValue - Float(intValue)\n    if decimal < 0.5 {\n      \
    \  return intValue\n    } else {\n        return intValue + 1\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpsxqhvwo8/tmpsxqhvwo8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4e8eb85c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4e8e87cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4e8e87c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4e8e87b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsxqhvwo8                        0x0000561500c4a512 <unavailable> + 5394

    5    libc.so.6                          0x00002b4e8ed71460 __libc_start_main +
    245

    6    tmpsxqhvwo8                        0x0000561500c4a049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let int =\
    \ Int(rounded)\n    return int\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp9mnfnrq9.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value = Double(value)!\n    let floor = Int(floor(value))\n    let ceil\
    \ = Int(ceil(value))\n    if value - Double(floor) < Double(ceil) - value {\n\
    \        return floor\n    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp7yy15cxl.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(value))\n                    ^\n\
    /tmp/tmp7yy15cxl.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(value))\n\
    \        ^\n/tmp/tmp7yy15cxl.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(value))\n                  \
    \ ^\n/tmp/tmp7yy15cxl.swift:18:9: note: 'ceil' declared here\n    let ceil = Int(ceil(value))\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    let decimal = num - Double(int)\n\
    \    if decimal >= 0.5 {\n        return int + 1\n    } else {\n        return\
    \ int\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpn5zuqzif/tmpn5zuqzif.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b42db182c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b42dae79b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b42dae79988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b42dae787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn5zuqzif                        0x0000561b266a5512 <unavailable> + 5394

    5    libc.so.6                          0x00002b42db36e460 __libc_start_main +
    245

    6    tmpn5zuqzif                        0x0000561b266a5049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(round(number))\n    return\
    \ rounded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp9xzctuen.swift:17:23: error: cannot find 'round' in scope\n   \
    \ let rounded = Int(round(number))\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimal = doubleValue - Double(intValue)\n    if decimal >= 0.5 {\n    \
    \    return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmphrztj8i1/tmphrztj8i1.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf8553fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf85236b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaf85236988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaf852357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphrztj8i1                        0x00005640fb238512 <unavailable> + 5394

    5    libc.so.6                          0x00002aaf8572b460 __libc_start_main +
    245

    6    tmphrztj8i1                        0x00005640fb238049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let integer\
    \ = Int(rounded)\n    return integer\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpqq1intpe.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value = Double(value)!\n    let floor = Int(floor(value))\n    let ceil\
    \ = Int(ceil(value))\n    let diff_floor = abs(value - Double(floor))\n    let\
    \ diff_ceil = abs(value - Double(ceil))\n    if diff_floor < diff_ceil {\n   \
    \     return floor\n    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxmv2ke1k.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(value))\n                    ^\n\
    /tmp/tmpxmv2ke1k.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(value))\n\
    \        ^\n/tmp/tmpxmv2ke1k.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(value))\n                  \
    \ ^\n/tmp/tmpxmv2ke1k.swift:18:9: note: 'ceil' declared here\n    let ceil = Int(ceil(value))\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(Double(value)!.rounded(.awayFromZero))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceiling = Int(number.rounded(.up))\n\
    \    let floorDiff = abs(floor - number)\n    let ceilingDiff = abs(ceiling -\
    \ number)\n    if floorDiff == ceilingDiff {\n        return rounded < 0 ? floor\
    \ : ceiling\n    }\n    return floorDiff < ceilingDiff ? floor : ceiling\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpbvvgg_el.swift:20:31: error: binary operator '-' cannot be applied\
    \ to operands of type 'Int' and 'Double'\n    let floorDiff = abs(floor - number)\n\
    \                        ~~~~~ ^ ~~~~~~\n/tmp/tmpbvvgg_el.swift:20:31: note: overloads\
    \ for '-' exist with these partially matching parameter lists: (Double, Double),\
    \ (Int, Int)\n    let floorDiff = abs(floor - number)\n                      \
    \        ^\n/tmp/tmpbvvgg_el.swift:21:35: error: binary operator '-' cannot be\
    \ applied to operands of type 'Int' and 'Double'\n    let ceilingDiff = abs(ceiling\
    \ - number)\n                          ~~~~~~~ ^ ~~~~~~\n/tmp/tmpbvvgg_el.swift:21:35:\
    \ note: overloads for '-' exist with these partially matching parameter lists:\
    \ (Double, Double), (Int, Int)\n    let ceilingDiff = abs(ceiling - number)\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    return\
    \ rounded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.uRG6yN/tmpbybu7a2b-1.o:tmpbybu7a2b-1.o:function $s11tmpbybu7a2b15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.uRG6yN/tmpbybu7a2b-1.o:tmpbybu7a2b-1.o:function $s11tmpbybu7a2b15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.uRG6yN/tmpbybu7a2b-1.o:tmpbybu7a2b-1.o:function $s11tmpbybu7a2b15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.uRG6yN/tmpbybu7a2b-1.o:tmpbybu7a2b-1.o:function $s11tmpbybu7a2b15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.uRG6yN/tmpbybu7a2b-1.o:tmpbybu7a2b-1.o:function $s11tmpbybu7a2b15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.uRG6yN/tmpbybu7a2b-1.o:tmpbybu7a2b-1.o:function $s11tmpbybu7a2b15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.uRG6yN/tmpbybu7a2b-1.o:tmpbybu7a2b-1.o:function $s11tmpbybu7a2b15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(value)!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpd8a3g9ft/tmpd8a3g9ft.swift:16: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002b9ae3a62c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9ae3759561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9ae3759286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9ae375913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9ae3758bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpd8a3g9ft                        0x0000559d5b19c75a <unavailable> + 5978

    6    tmpd8a3g9ft                        0x0000559d5b19c3dd <unavailable> + 5085

    7    libc.so.6                          0x00002b9ae3c4e460 __libc_start_main +
    245

    8    tmpd8a3g9ft                        0x0000559d5b19c039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    if number\
    \ - rounded >= 0.5 {\n        return Int(rounded) + 1\n    } else {\n        return\
    \ Int(rounded)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp2suynj0l.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let floatValue = Float(value) ?? 0\n    let intValue = Int(floatValue)\n  \
    \  let decimalValue = floatValue - Float(intValue)\n    if decimalValue < 0.5\
    \ {\n        return intValue\n    } else {\n        return intValue + 1\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpi8a9j7ch/tmpi8a9j7ch.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b58578d7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b58575ceb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b58575ce988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b58575cd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi8a9j7ch                        0x00005570b5e7a512 <unavailable> + 5394

    5    libc.so.6                          0x00002b5857ac3460 __libc_start_main +
    245

    6    tmpi8a9j7ch                        0x00005570b5e7a049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let integer = Int(number)\n    let decimal\
    \ = number - Double(integer)\n    if decimal >= 0.5 {\n        return integer\
    \ + 1\n    } else {\n        return integer\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpvmf5afa_/tmpvmf5afa_.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b74a8338c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b74a802fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b74a802f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b74a802e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvmf5afa_                        0x000055556e231512 <unavailable> + 5394

    5    libc.so.6                          0x00002b74a8524460 __libc_start_main +
    245

    6    tmpvmf5afa_                        0x000055556e231049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    if number - Double(floor) == 0.5 {\n        return floor\n    } else if number\
    \ - Double(ceil) == -0.5 {\n        return ceil\n    } else {\n        return\
    \ rounded\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_i'
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    let diffFloor = abs(number - Double(floor))\n    let\
    \ diffCeil = abs(number - Double(ceil))\n    if diffFloor < diffCeil {\n     \
    \   return floor\n    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmplin0g9bp.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmplin0g9bp.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmplin0g9bp.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmplin0g9bp.swift:18:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceiling = Int(number.rounded(.up))\n\
    \    if number - Double(floor) == 0.5 {\n        return ceiling\n    } else if\
    \ number - Double(floor) == -0.5 {\n        return floor\n    } else {\n     \
    \   return rounded\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.6VwOBx/tmphprw77_r-1.o:tmphprw77_r-1.o:function $s11tmphprw77_r15closest_i'
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    let floorDiff = abs(number - Double(floor))\n    let ceilDiff = abs(number\
    \ - Double(ceil))\n    if floorDiff == ceilDiff {\n        return number > 0 ?\
    \ ceil : floor\n    }\n    return floorDiff < ceilDiff ? floor : ceil\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxfdly6de.swift:17:9: warning: initialization of immutable value\
    \ 'rounded' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let rounded = Int(number.rounded())\n    ~~~~^~~~~~~\n    _\nerror:\
    \ link command failed with exit code 1 (use -v to see invocation)\n/tmp/TemporaryDirectory.AGRkf4/tmpxfdly6de-1.o:tmpxfdly6de-1.o:function\
    \ $s11tmpxfdly6de15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.AGRkf4/tmpxfdly6de-1.o:tmpxfdly6de-1.o:function\
    \ $s11tmpxfdly6de15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.AGRkf4/tmpxfdly6de-1.o:tmpxfdly6de-1.o:function\
    \ $s11tmpxfdly6de15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.AGRkf4/tmpxfdly6de-1.o:tmpxfdly6de-1.o:function\
    \ $s11tmpxfdly6de15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.AGRkf4/tmpxfdly6de-1.o:tmpxfdly6de-1.o:function\
    \ $s11tmpxfdly6de15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.AGRkf4/tmpxfdly6de-1.o:tmpxfdly6de-1.o:function\
    \ $s11tmpxfdly6de15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.AGRkf4/tmpxfdly6de-1.o:tmpxfdly6de-1.o:function\
    \ $s11tmpxfdly6de15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.AGRkf4/tmpxfdly6de-1.o:tmpxfdly6de-1.o:function\
    \ $s11tmpxfdly6de15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.AGRkf4/tmpxfdly6de-1.o:tmpxfdly6de-1.o:function\
    \ $s11tmpxfdly6de15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.AGRkf4/tmpxfdly6de-1.o:tmpxfdly6de-1.o:function\
    \ $s11tmpxfdly6de15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.AGRkf4/tmpxfdly6de-1.o:tmpxfdly6de-1.o:function\
    \ $s11tmpxfdly6de15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.AGRkf4/tmpxfdl"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    let diff = number - Double(rounded)\n    if diff == 0 {\n        return rounded\n\
    \    } else if diff < 0 {\n        return floor\n    } else {\n        return\
    \ ceil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.nIoDf4/tmp5jehhib2-1.o:tmp5jehhib2-1.o:function $s11tmp5jehhib215closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.nIoDf4/tmp5jehhib2-1.o:tmp5jehhib2-1.o:function $s11tmp5jehhib215closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.nIoDf4/tmp5jehhib2-1.o:tmp5jehhib2-1.o:function $s11tmp5jehhib215closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.nIoDf4/tmp5jehhib2-1.o:tmp5jehhib2-1.o:function $s11tmp5jehhib215closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.nIoDf4/tmp5jehhib2-1.o:tmp5jehhib2-1.o:function $s11tmp5jehhib215closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.nIoDf4/tmp5jehhib2-1.o:tmp5jehhib2-1.o:function $s11tmp5jehhib215closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.nIoDf4/tmp5jehhib2-1.o:tmp5jehhib2-1.o:function $s11tmp5jehhib215closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.nIoDf4/tmp5jehhib2-1.o:tmp5jehhib2-1.o:function $s11tmp5jehhib215closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.nIoDf4/tmp5jehhib2-1.o:tmp5jehhib2-1.o:function $s11tmp5jehhib215closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.nIoDf4/tmp5jehhib2-1.o:tmp5jehhib2-1.o:function $s11tmp5jehhib215closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.nIoDf4/tmp5jehhib2-1.o:tmp5jehhib2-1.o:function $s11tmp5jehhib215closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.nIoDf4/tmp5jehhib2-1.o:tmp5jehhib2-1.o:function $s11tmp5jehhib215closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.nIoDf4/tmp5jehhib2-1.o:tmp5jehhib2-1.o:function $s11tmp5jehhib215closest_i'
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    return Int(rounded)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpth5ptwc1.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceiling = Int(number.rounded(.up))\n\
    \    let diff_from_rounded = abs(number - Double(rounded))\n    let diff_from_floor\
    \ = abs(number - Double(floor))\n    let diff_from_ceiling = abs(number - Double(ceiling))\n\
    \    if diff_from_rounded < diff_from_floor && diff_from_rounded < diff_from_ceiling\
    \ {\n        return rounded\n    } else if diff_from_floor < diff_from_ceiling\
    \ {\n        return floor\n    } else {\n        return ceiling\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.aBi6R8/tmpij2a3429-1.o:tmpij2a3429-1.o:function $s11tmpij2a342915closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.aBi6R8/tmpij2a3429-1.o:tmpij2a3429-1.o:function $s11tmpij2a342915closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.aBi6R8/tmpij2a3429-1.o:tmpij2a3429-1.o:function $s11tmpij2a342915closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.aBi6R8/tmpij2a3429-1.o:tmpij2a3429-1.o:function $s11tmpij2a342915closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.aBi6R8/tmpij2a3429-1.o:tmpij2a3429-1.o:function $s11tmpij2a342915closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.aBi6R8/tmpij2a3429-1.o:tmpij2a3429-1.o:function $s11tmpij2a342915closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.aBi6R8/tmpij2a3429-1.o:tmpij2a3429-1.o:function $s11tmpij2a342915closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.aBi6R8/tmpij2a3429-1.o:tmpij2a3429-1.o:function $s11tmpij2a342915closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.aBi6R8/tmpij2a3429-1.o:tmpij2a3429-1.o:function $s11tmpij2a342915closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.aBi6R8/tmpij2a3429-1.o:tmpij2a3429-1.o:function $s11tmpij2a342915closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.aBi6R8/tmpij2a3429-1.o:tmpij2a3429-1.o:function $s11tmpij2a342915closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.aBi6R8/tmpij2a3429-1.o:tmpij2a3429-1.o:function $s11tmpij2a342915closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.aBi6R8/tmpij2a3429-1.o:tmpij2a3429-1.o:function $s11tmpij2a342915closest_i'
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(Double(value)!.rounded(.awayFromZero))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    if number\
    \ - rounded < 0.5 {\n        return Int(rounded)\n    } else {\n        return\
    \ Int(rounded + 1)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpmt4c4o6o.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let integer = Int(number)\n    let decimal\
    \ = number - Double(integer)\n    if decimal >= 0.5 {\n        return integer\
    \ + 1\n    } else {\n        return integer\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpvmf5afa_/tmpvmf5afa_.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b74a8338c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b74a802fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b74a802f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b74a802e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvmf5afa_                        0x000055556e231512 <unavailable> + 5394

    5    libc.so.6                          0x00002b74a8524460 __libc_start_main +
    245

    6    tmpvmf5afa_                        0x000055556e231049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let integerValue = Int(doubleValue)\n\
    \    let decimalValue = doubleValue - Double(integerValue)\n    if decimalValue\
    \ >= 0.5 {\n        return integerValue + 1\n    } else {\n        return integerValue\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmponm97lpg/tmponm97lpg.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4e9b623c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4e9b31ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4e9b31a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4e9b3197b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmponm97lpg                        0x000055efe81b9512 <unavailable> + 5394

    5    libc.so.6                          0x00002b4e9b80f460 __libc_start_main +
    245

    6    tmponm97lpg                        0x000055efe81b9049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let int =\
    \ Int(rounded)\n    return int\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp9mnfnrq9.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimalValue = doubleValue - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp51_hz_j6/tmp51_hz_j6.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae2a3878c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae2a356fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae2a356f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae2a356e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp51_hz_j6                        0x000056304faa4512 <unavailable> + 5394

    5    libc.so.6                          0x00002ae2a3a64460 __libc_start_main +
    245

    6    tmp51_hz_j6                        0x000056304faa4049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ if doubleValue - Double(intValue) >= 0.5 {\n        return intValue + 1\n  \
    \  } else {\n        return intValue\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpa34m89b6/tmpa34m89b6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afbd3bdfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afbd38d6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afbd38d6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afbd38d57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa34m89b6                        0x00005643036d3512 <unavailable> + 5394

    5    libc.so.6                          0x00002afbd3dcb460 __libc_start_main +
    245

    6    tmpa34m89b6                        0x00005643036d3049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimal = doubleValue - Double(intValue)\n    if decimal >= 0.5 {\n    \
    \    return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmphrztj8i1/tmphrztj8i1.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf8553fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf85236b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaf85236988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaf852357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphrztj8i1                        0x00005640fb238512 <unavailable> + 5394

    5    libc.so.6                          0x00002aaf8572b460 __libc_start_main +
    245

    6    tmphrztj8i1                        0x00005640fb238049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    if number\
    \ - rounded >= 0.5 {\n        return Int(rounded) + 1\n    } else {\n        return\
    \ Int(rounded)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.2qeDO8/tmptrmxhwzd-1.o:tmptrmxhwzd-1.o:function $s11tmptrmxhwzd15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.2qeDO8/tmptrmxhwzd-1.o:tmptrmxhwzd-1.o:function $s11tmptrmxhwzd15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.2qeDO8/tmptrmxhwzd-1.o:tmptrmxhwzd-1.o:function $s11tmptrmxhwzd15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.2qeDO8/tmptrmxhwzd-1.o:tmptrmxhwzd-1.o:function $s11tmptrmxhwzd15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.2qeDO8/tmptrmxhwzd-1.o:tmptrmxhwzd-1.o:function $s11tmptrmxhwzd15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.2qeDO8/tmptrmxhwzd-1.o:tmptrmxhwzd-1.o:function $s11tmptrmxhwzd15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.2qeDO8/tmptrmxhwzd-1.o:tmptrmxhwzd-1.o:function $s11tmptrmxhwzd15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let intNumber = Int(number)\n    let decimalNumber\
    \ = number - Double(intNumber)\n    if decimalNumber >= 0.5 {\n        return\
    \ intNumber + 1\n    } else {\n        return intNumber\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp5u566b3d/tmp5u566b3d.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e7d14cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e7ce43b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9e7ce43988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9e7ce427b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5u566b3d                        0x000055efb741d512 <unavailable> + 5394

    5    libc.so.6                          0x00002b9e7d338460 __libc_start_main +
    245

    6    tmp5u566b3d                        0x000055efb741d049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    let decimal = num - Double(int)\n\
    \    if decimal >= 0.5 {\n        return int + 1\n    } else {\n        return\
    \ int\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpn5zuqzif/tmpn5zuqzif.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b42db182c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b42dae79b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b42dae79988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b42dae787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn5zuqzif                        0x0000561b266a5512 <unavailable> + 5394

    5    libc.so.6                          0x00002b42db36e460 __libc_start_main +
    245

    6    tmpn5zuqzif                        0x0000561b266a5049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let integer = Int(number)\n    let decimal\
    \ = number - Double(integer)\n    if decimal >= 0.5 {\n        return integer\
    \ + 1\n    } else {\n        return integer\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpvmf5afa_/tmpvmf5afa_.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b74a8338c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b74a802fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b74a802f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b74a802e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvmf5afa_                        0x000055556e231512 <unavailable> + 5394

    5    libc.so.6                          0x00002b74a8524460 __libc_start_main +
    245

    6    tmpvmf5afa_                        0x000055556e231049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    return Int(rounded)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpth5ptwc1.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  guard let doubleValue = Double(value) else {\n        return 0\n    }\n   \
    \ return Int(doubleValue.rounded(.awayFromZero))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.w1CUsa/tmpx_xyaffz-1.o:tmpx_xyaffz-1.o:function $s11tmpx_xyaffz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.w1CUsa/tmpx_xyaffz-1.o:tmpx_xyaffz-1.o:function $s11tmpx_xyaffz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.w1CUsa/tmpx_xyaffz-1.o:tmpx_xyaffz-1.o:function $s11tmpx_xyaffz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.w1CUsa/tmpx_xyaffz-1.o:tmpx_xyaffz-1.o:function $s11tmpx_xyaffz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.w1CUsa/tmpx_xyaffz-1.o:tmpx_xyaffz-1.o:function $s11tmpx_xyaffz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.w1CUsa/tmpx_xyaffz-1.o:tmpx_xyaffz-1.o:function $s11tmpx_xyaffz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.w1CUsa/tmpx_xyaffz-1.o:tmpx_xyaffz-1.o:function $s11tmpx_xyaffz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value = Double(value)!\n    let floor = Int(floor(value))\n    let ceil\
    \ = Int(ceil(value))\n    if value - Double(floor) < Double(ceil) - value {\n\
    \        return floor\n    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp7yy15cxl.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(value))\n                    ^\n\
    /tmp/tmp7yy15cxl.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(value))\n\
    \        ^\n/tmp/tmp7yy15cxl.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(value))\n                  \
    \ ^\n/tmp/tmp7yy15cxl.swift:18:9: note: 'ceil' declared here\n    let ceil = Int(ceil(value))\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let integer = Int(number)\n    let decimal\
    \ = number - Double(integer)\n    if decimal >= 0.5 {\n        return integer\
    \ + 1\n    } else {\n        return integer\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpvmf5afa_/tmpvmf5afa_.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b74a8338c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b74a802fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b74a802f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b74a802e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvmf5afa_                        0x000055556e231512 <unavailable> + 5394

    5    libc.so.6                          0x00002b74a8524460 __libc_start_main +
    245

    6    tmpvmf5afa_                        0x000055556e231049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let integer = Int(number)\n    let decimal\
    \ = number - Double(integer)\n    if decimal >= 0.5 {\n        return integer\
    \ + 1\n    } else {\n        return integer\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpvmf5afa_/tmpvmf5afa_.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b74a8338c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b74a802fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b74a802f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b74a802e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvmf5afa_                        0x000055556e231512 <unavailable> + 5394

    5    libc.so.6                          0x00002b74a8524460 __libc_start_main +
    245

    6    tmpvmf5afa_                        0x000055556e231049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    return Int(number.rounded(.awayFromZero))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.TZ1nQa/tmp41jdwzwd-1.o:tmp41jdwzwd-1.o:function $s11tmp41jdwzwd15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.TZ1nQa/tmp41jdwzwd-1.o:tmp41jdwzwd-1.o:function $s11tmp41jdwzwd15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.TZ1nQa/tmp41jdwzwd-1.o:tmp41jdwzwd-1.o:function $s11tmp41jdwzwd15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.TZ1nQa/tmp41jdwzwd-1.o:tmp41jdwzwd-1.o:function $s11tmp41jdwzwd15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.TZ1nQa/tmp41jdwzwd-1.o:tmp41jdwzwd-1.o:function $s11tmp41jdwzwd15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.TZ1nQa/tmp41jdwzwd-1.o:tmp41jdwzwd-1.o:function $s11tmp41jdwzwd15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.TZ1nQa/tmp41jdwzwd-1.o:tmp41jdwzwd-1.o:function $s11tmp41jdwzwd15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    let decimal = num - Double(int)\n\
    \    if decimal < 0.5 {\n        return int\n    } else {\n        return int\
    \ + 1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmp3wwshpld/tmp3wwshpld.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab6a7b61c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab6a7858b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab6a7858988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab6a78577b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3wwshpld                        0x000055f1c250d512 <unavailable> + 5394

    5    libc.so.6                          0x00002ab6a7d4d460 __libc_start_main +
    245

    6    tmp3wwshpld                        0x000055f1c250d049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let floor\
    \ = Int(floor(number))\n    let ceil = Int(ceil(number))\n    if rounded - Double(floor)\
    \ == 0.5 {\n        return ceil\n    } else if rounded - Double(floor) == -0.5\
    \ {\n        return floor\n    } else {\n        return Int(rounded)\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpfylkqpj5.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n/tmp/tmpfylkqpj5.swift:18:21:\
    \ error: use of local variable 'floor' before its declaration\n    let floor =\
    \ Int(floor(number))\n                    ^\n/tmp/tmpfylkqpj5.swift:18:9: note:\
    \ 'floor' declared here\n    let floor = Int(floor(number))\n        ^\n/tmp/tmpfylkqpj5.swift:19:20:\
    \ error: use of local variable 'ceil' before its declaration\n    let ceil = Int(ceil(number))\n\
    \                   ^\n/tmp/tmpfylkqpj5.swift:19:9: note: 'ceil' declared here\n\
    \    let ceil = Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014043
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let int =\
    \ Int(rounded)\n    return int\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp9mnfnrq9.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let floatValue = Float(value) ?? 0\n    let intValue = Int(floatValue)\n  \
    \  let decimal = floatValue - Float(intValue)\n    if decimal >= 0.5 {\n     \
    \   return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmppo_86oxc/tmppo_86oxc.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab317218c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab316f0fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab316f0f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab316f0e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppo_86oxc                        0x00005624f296b512 <unavailable> + 5394

    5    libc.so.6                          0x00002ab317404460 __libc_start_main +
    245

    6    tmppo_86oxc                        0x00005624f296b049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceiling = Int(number.rounded(.up))\n\
    \    let floorDiff = abs(number - Double(floor))\n    let ceilingDiff = abs(number\
    \ - Double(ceiling))\n    if floorDiff == ceilingDiff {\n        return rounded\n\
    \    } else if floorDiff < ceilingDiff {\n        return floor\n    } else {\n\
    \        return ceiling\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.R6KKue/tmpvhqrv9zz-1.o:tmpvhqrv9zz-1.o:function $s11tmpvhqrv9zz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.R6KKue/tmpvhqrv9zz-1.o:tmpvhqrv9zz-1.o:function $s11tmpvhqrv9zz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.R6KKue/tmpvhqrv9zz-1.o:tmpvhqrv9zz-1.o:function $s11tmpvhqrv9zz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.R6KKue/tmpvhqrv9zz-1.o:tmpvhqrv9zz-1.o:function $s11tmpvhqrv9zz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.R6KKue/tmpvhqrv9zz-1.o:tmpvhqrv9zz-1.o:function $s11tmpvhqrv9zz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.R6KKue/tmpvhqrv9zz-1.o:tmpvhqrv9zz-1.o:function $s11tmpvhqrv9zz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.R6KKue/tmpvhqrv9zz-1.o:tmpvhqrv9zz-1.o:function $s11tmpvhqrv9zz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.R6KKue/tmpvhqrv9zz-1.o:tmpvhqrv9zz-1.o:function $s11tmpvhqrv9zz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.R6KKue/tmpvhqrv9zz-1.o:tmpvhqrv9zz-1.o:function $s11tmpvhqrv9zz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.R6KKue/tmpvhqrv9zz-1.o:tmpvhqrv9zz-1.o:function $s11tmpvhqrv9zz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.R6KKue/tmpvhqrv9zz-1.o:tmpvhqrv9zz-1.o:function $s11tmpvhqrv9zz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.R6KKue/tmpvhqrv9zz-1.o:tmpvhqrv9zz-1.o:function $s11tmpvhqrv9zz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.R6KKue/tmpvhqrv9zz-1.o:tmpvhqrv9zz-1.o:function $s11tmpvhqrv9zz15closest_i'
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    let decimal = num - Double(int)\n\
    \    if decimal >= 0.5 {\n        return int + 1\n    } else {\n        return\
    \ int\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpn5zuqzif/tmpn5zuqzif.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b42db182c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b42dae79b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b42dae79988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b42dae787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn5zuqzif                        0x0000561b266a5512 <unavailable> + 5394

    5    libc.so.6                          0x00002b42db36e460 __libc_start_main +
    245

    6    tmpn5zuqzif                        0x0000561b266a5049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    let decimal = num - Double(int)\n\
    \    if decimal >= 0.5 {\n        return int + 1\n    } else {\n        return\
    \ int\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpn5zuqzif/tmpn5zuqzif.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b42db182c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b42dae79b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b42dae79988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b42dae787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn5zuqzif                        0x0000561b266a5512 <unavailable> + 5394

    5    libc.so.6                          0x00002b42db36e460 __libc_start_main +
    245

    6    tmpn5zuqzif                        0x0000561b266a5049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimal = doubleValue - Double(intValue)\n    if decimal >= 0.5 {\n    \
    \    return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmphrztj8i1/tmphrztj8i1.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf8553fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf85236b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaf85236988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaf852357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphrztj8i1                        0x00005640fb238512 <unavailable> + 5394

    5    libc.so.6                          0x00002aaf8572b460 __libc_start_main +
    245

    6    tmphrztj8i1                        0x00005640fb238049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    let roundedInt = Int(roundedValue)\n    return roundedInt\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpjfe32e7o.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimal = doubleValue - Double(intValue)\n    if decimal >= 0.5 {\n    \
    \    return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmphrztj8i1/tmphrztj8i1.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf8553fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf85236b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaf85236988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaf852357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphrztj8i1                        0x00005640fb238512 <unavailable> + 5394

    5    libc.so.6                          0x00002aaf8572b460 __libc_start_main +
    245

    6    tmphrztj8i1                        0x00005640fb238049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimalValue = doubleValue - Double(intValue)\n    if decimalValue < 0.5\
    \ {\n        return intValue\n    } else {\n        return intValue + 1\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpb5j98g80/tmpb5j98g80.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6d8c27dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6d8bf74b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6d8bf74988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6d8bf737b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb5j98g80                        0x000056172b4eb512 <unavailable> + 5394

    5    libc.so.6                          0x00002b6d8c469460 __libc_start_main +
    245

    6    tmpb5j98g80                        0x000056172b4eb049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    let floor_diff = abs(number - Double(floor))\n    let ceil_diff = abs(number\
    \ - Double(ceil))\n    if floor_diff < ceil_diff {\n        return floor\n   \
    \ } else if ceil_diff < floor_diff {\n        return ceil\n    } else {\n    \
    \    return rounded\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.ssgBdd/tmpfz6uw34e-1.o:tmpfz6uw34e-1.o:function $s11tmpfz6uw34e15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.ssgBdd/tmpfz6uw34e-1.o:tmpfz6uw34e-1.o:function $s11tmpfz6uw34e15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.ssgBdd/tmpfz6uw34e-1.o:tmpfz6uw34e-1.o:function $s11tmpfz6uw34e15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.ssgBdd/tmpfz6uw34e-1.o:tmpfz6uw34e-1.o:function $s11tmpfz6uw34e15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.ssgBdd/tmpfz6uw34e-1.o:tmpfz6uw34e-1.o:function $s11tmpfz6uw34e15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.ssgBdd/tmpfz6uw34e-1.o:tmpfz6uw34e-1.o:function $s11tmpfz6uw34e15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.ssgBdd/tmpfz6uw34e-1.o:tmpfz6uw34e-1.o:function $s11tmpfz6uw34e15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.ssgBdd/tmpfz6uw34e-1.o:tmpfz6uw34e-1.o:function $s11tmpfz6uw34e15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.ssgBdd/tmpfz6uw34e-1.o:tmpfz6uw34e-1.o:function $s11tmpfz6uw34e15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.ssgBdd/tmpfz6uw34e-1.o:tmpfz6uw34e-1.o:function $s11tmpfz6uw34e15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.ssgBdd/tmpfz6uw34e-1.o:tmpfz6uw34e-1.o:function $s11tmpfz6uw34e15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.ssgBdd/tmpfz6uw34e-1.o:tmpfz6uw34e-1.o:function $s11tmpfz6uw34e15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.ssgBdd/tmpfz6uw34e-1.o:tmpfz6uw34e-1.o:function $s11tmpfz6uw34e15closest_i'
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < 0.5 {\n        return floor\n\
    \    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpz5m7rozs.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpz5m7rozs.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpz5m7rozs.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpz5m7rozs.swift:18:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ if doubleValue - Double(intValue) >= 0.5 {\n        return intValue + 1\n  \
    \  } else {\n        return intValue\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpa34m89b6/tmpa34m89b6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afbd3bdfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afbd38d6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afbd38d6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afbd38d57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa34m89b6                        0x00005643036d3512 <unavailable> + 5394

    5    libc.so.6                          0x00002afbd3dcb460 __libc_start_main +
    245

    6    tmpa34m89b6                        0x00005643036d3049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let integer = Int(number)\n    let decimal\
    \ = number - Double(integer)\n    if decimal >= 0.5 {\n        return integer\
    \ + 1\n    } else {\n        return integer\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpvmf5afa_/tmpvmf5afa_.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b74a8338c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b74a802fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b74a802f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b74a802e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvmf5afa_                        0x000055556e231512 <unavailable> + 5394

    5    libc.so.6                          0x00002b74a8524460 __libc_start_main +
    245

    6    tmpvmf5afa_                        0x000055556e231049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimalValue = doubleValue - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp51_hz_j6/tmp51_hz_j6.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae2a3878c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae2a356fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae2a356f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae2a356e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp51_hz_j6                        0x000056304faa4512 <unavailable> + 5394

    5    libc.so.6                          0x00002ae2a3a64460 __libc_start_main +
    245

    6    tmp51_hz_j6                        0x000056304faa4049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    return Int(rounded)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpth5ptwc1.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    return Int(rounded)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpth5ptwc1.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value = Double(value)!\n    let intValue = Int(value)\n    if value - Double(intValue)\
    \ < 0.5 {\n        return intValue\n    } else {\n        return intValue + 1\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmp1xu0qp0p/tmp1xu0qp0p.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab84b959c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab84b650b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab84b650988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab84b64f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1xu0qp0p                        0x000055e922ae5512 <unavailable> + 5394

    5    libc.so.6                          0x00002ab84bb45460 __libc_start_main +
    245

    6    tmp1xu0qp0p                        0x000055e922ae5049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimal = doubleValue - Double(intValue)\n    if decimal >= 0.5 {\n    \
    \    return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmphrztj8i1/tmphrztj8i1.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf8553fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf85236b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaf85236988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaf852357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphrztj8i1                        0x00005640fb238512 <unavailable> + 5394

    5    libc.so.6                          0x00002aaf8572b460 __libc_start_main +
    245

    6    tmphrztj8i1                        0x00005640fb238049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < 0.5 {\n        return floor\n\
    \    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpz5m7rozs.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpz5m7rozs.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpz5m7rozs.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpz5m7rozs.swift:18:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value = Double(value)!\n    let floor = Int(floor(value))\n    let ceil\
    \ = Int(ceil(value))\n    if value - Double(floor) < Double(ceil) - value {\n\
    \        return floor\n    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp7yy15cxl.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(value))\n                    ^\n\
    /tmp/tmp7yy15cxl.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(value))\n\
    \        ^\n/tmp/tmp7yy15cxl.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(value))\n                  \
    \ ^\n/tmp/tmp7yy15cxl.swift:18:9: note: 'ceil' declared here\n    let ceil = Int(ceil(value))\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimalValue = doubleValue - Double(intValue)\n    if decimalValue < 0.5\
    \ {\n        return intValue\n    } else {\n        return intValue + 1\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpb5j98g80/tmpb5j98g80.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6d8c27dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6d8bf74b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6d8bf74988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6d8bf737b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb5j98g80                        0x000056172b4eb512 <unavailable> + 5394

    5    libc.so.6                          0x00002b6d8c469460 __libc_start_main +
    245

    6    tmpb5j98g80                        0x000056172b4eb049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let roundedNumber = Int(number.rounded())\n\
    \    let decimal = number - Double(roundedNumber)\n    if decimal == 0 {\n   \
    \     return roundedNumber\n    } else if decimal > 0 {\n        return roundedNumber\
    \ + 1\n    } else {\n        return roundedNumber - 1\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.UnN7yg/tmpdzjcdf1g-1.o:tmpdzjcdf1g-1.o:function $s11tmpdzjcdf1g15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.UnN7yg/tmpdzjcdf1g-1.o:tmpdzjcdf1g-1.o:function $s11tmpdzjcdf1g15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.UnN7yg/tmpdzjcdf1g-1.o:tmpdzjcdf1g-1.o:function $s11tmpdzjcdf1g15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.UnN7yg/tmpdzjcdf1g-1.o:tmpdzjcdf1g-1.o:function $s11tmpdzjcdf1g15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.UnN7yg/tmpdzjcdf1g-1.o:tmpdzjcdf1g-1.o:function $s11tmpdzjcdf1g15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.UnN7yg/tmpdzjcdf1g-1.o:tmpdzjcdf1g-1.o:function $s11tmpdzjcdf1g15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.UnN7yg/tmpdzjcdf1g-1.o:tmpdzjcdf1g-1.o:function $s11tmpdzjcdf1g15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value = Double(value)!\n    let floor = Int(floor(value))\n    let ceil\
    \ = Int(ceil(value))\n    let diff_floor = abs(value - Double(floor))\n    let\
    \ diff_ceil = abs(value - Double(ceil))\n    if diff_floor == diff_ceil {\n  \
    \      return value > 0 ? ceil : floor\n    }\n    return diff_floor < diff_ceil\
    \ ? floor : ceil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpupb1h3lu.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(value))\n                    ^\n\
    /tmp/tmpupb1h3lu.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(value))\n\
    \        ^\n/tmp/tmpupb1h3lu.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(value))\n                  \
    \ ^\n/tmp/tmpupb1h3lu.swift:18:9: note: 'ceil' declared here\n    let ceil = Int(ceil(value))\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let integerValue = Int(doubleValue)\n\
    \    let decimalValue = doubleValue - Double(integerValue)\n    if decimalValue\
    \ >= 0.5 {\n        return integerValue + 1\n    } else {\n        return integerValue\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmponm97lpg/tmponm97lpg.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4e9b623c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4e9b31ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4e9b31a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4e9b3197b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmponm97lpg                        0x000055efe81b9512 <unavailable> + 5394

    5    libc.so.6                          0x00002b4e9b80f460 __libc_start_main +
    245

    6    tmponm97lpg                        0x000055efe81b9049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let floor\
    \ = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n    if\
    \ number - Double(floor) < 0.5 {\n        return floor\n    } else if Double(ceil)\
    \ - number < 0.5 {\n        return ceil\n    } else {\n        return Int(rounded)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpl5ddfhs2.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let ceiled\
    \ = number.rounded(.up)\n    let floored = number.rounded(.down)\n    let diff1\
    \ = abs(number - rounded)\n    let diff2 = abs(number - ceiled)\n    let diff3\
    \ = abs(number - floored)\n    if diff1 < diff2 && diff1 < diff3 {\n        return\
    \ Int(rounded)\n    } else if diff2 < diff1 && diff2 < diff3 {\n        return\
    \ Int(ceiled)\n    } else {\n        return Int(floored)\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.n6p6Pt/tmpg3obz09_-1.o:tmpg3obz09_-1.o:function $s11tmpg3obz09_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.n6p6Pt/tmpg3obz09_-1.o:tmpg3obz09_-1.o:function $s11tmpg3obz09_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.n6p6Pt/tmpg3obz09_-1.o:tmpg3obz09_-1.o:function $s11tmpg3obz09_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.n6p6Pt/tmpg3obz09_-1.o:tmpg3obz09_-1.o:function $s11tmpg3obz09_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.n6p6Pt/tmpg3obz09_-1.o:tmpg3obz09_-1.o:function $s11tmpg3obz09_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.n6p6Pt/tmpg3obz09_-1.o:tmpg3obz09_-1.o:function $s11tmpg3obz09_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.n6p6Pt/tmpg3obz09_-1.o:tmpg3obz09_-1.o:function $s11tmpg3obz09_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.n6p6Pt/tmpg3obz09_-1.o:tmpg3obz09_-1.o:function $s11tmpg3obz09_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.n6p6Pt/tmpg3obz09_-1.o:tmpg3obz09_-1.o:function $s11tmpg3obz09_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.n6p6Pt/tmpg3obz09_-1.o:tmpg3obz09_-1.o:function $s11tmpg3obz09_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.n6p6Pt/tmpg3obz09_-1.o:tmpg3obz09_-1.o:function $s11tmpg3obz09_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.n6p6Pt/tmpg3obz09_-1.o:tmpg3obz09_-1.o:function $s11tmpg3obz09_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.n6p6Pt/tmpg3obz09_-1.o:tmpg3obz09_-1.o:function $s11tmpg3obz09_15closest_i'
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimal = doubleValue - Double(intValue)\n    if decimal >= 0.5 {\n    \
    \    return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmphrztj8i1/tmphrztj8i1.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf8553fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf85236b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaf85236988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaf852357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphrztj8i1                        0x00005640fb238512 <unavailable> + 5394

    5    libc.so.6                          0x00002aaf8572b460 __libc_start_main +
    245

    6    tmphrztj8i1                        0x00005640fb238049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let integer = Int(number)\n    let decimal\
    \ = number - Double(integer)\n    if decimal >= 0.5 {\n        return integer\
    \ + 1\n    } else {\n        return integer\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpvmf5afa_/tmpvmf5afa_.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b74a8338c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b74a802fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b74a802f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b74a802e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvmf5afa_                        0x000055556e231512 <unavailable> + 5394

    5    libc.so.6                          0x00002b74a8524460 __libc_start_main +
    245

    6    tmpvmf5afa_                        0x000055556e231049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let roundedInt\
    \ = Int(rounded)\n    return roundedInt\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmplgrhlscs.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    return Int(rounded)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpth5ptwc1.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ ceiled = Int(number.rounded(.up))\n    let floored = Int(number.rounded(.down))\n\
    \    let distanceToRounded = abs(number - Double(rounded))\n    let distanceToCeiled\
    \ = abs(number - Double(ceiled))\n    let distanceToFloored = abs(number - Double(floored))\n\
    \    if distanceToRounded < distanceToCeiled && distanceToRounded < distanceToFloored\
    \ {\n        return rounded\n    } else if distanceToCeiled < distanceToFloored\
    \ {\n        return ceiled\n    } else {\n        return floored\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.wGLmwg/tmppa6qd9kr-1.o:tmppa6qd9kr-1.o:function $s11tmppa6qd9kr15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.wGLmwg/tmppa6qd9kr-1.o:tmppa6qd9kr-1.o:function $s11tmppa6qd9kr15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.wGLmwg/tmppa6qd9kr-1.o:tmppa6qd9kr-1.o:function $s11tmppa6qd9kr15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.wGLmwg/tmppa6qd9kr-1.o:tmppa6qd9kr-1.o:function $s11tmppa6qd9kr15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.wGLmwg/tmppa6qd9kr-1.o:tmppa6qd9kr-1.o:function $s11tmppa6qd9kr15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.wGLmwg/tmppa6qd9kr-1.o:tmppa6qd9kr-1.o:function $s11tmppa6qd9kr15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.wGLmwg/tmppa6qd9kr-1.o:tmppa6qd9kr-1.o:function $s11tmppa6qd9kr15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.wGLmwg/tmppa6qd9kr-1.o:tmppa6qd9kr-1.o:function $s11tmppa6qd9kr15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.wGLmwg/tmppa6qd9kr-1.o:tmppa6qd9kr-1.o:function $s11tmppa6qd9kr15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.wGLmwg/tmppa6qd9kr-1.o:tmppa6qd9kr-1.o:function $s11tmppa6qd9kr15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.wGLmwg/tmppa6qd9kr-1.o:tmppa6qd9kr-1.o:function $s11tmppa6qd9kr15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.wGLmwg/tmppa6qd9kr-1.o:tmppa6qd9kr-1.o:function $s11tmppa6qd9kr15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.wGLmwg/tmppa6qd9kr-1.o:tmppa6qd9kr-1.o:function $s11tmppa6qd9kr15closest_i'
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  var result = 0\n    let number = Double(value)\n    if number != nil {\n  \
    \      result = Int(number! + 0.5)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp0s12ugif/tmp0s12ugif.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2ccc4e8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2ccc1dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2ccc1df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2ccc1de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0s12ugif                        0x000055840b86d512 <unavailable> + 5394

    5    libc.so.6                          0x00002b2ccc6d4460 __libc_start_main +
    245

    6    tmp0s12ugif                        0x000055840b86d049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let integer\
    \ = Int(rounded)\n    return integer\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpqq1intpe.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let floor\
    \ = number.rounded(.down)\n    let ceil = number.rounded(.up)\n    let floorDiff\
    \ = abs(number - floor)\n    let ceilDiff = abs(number - ceil)\n    if floorDiff\
    \ == ceilDiff {\n        return rounded > 0 ? Int(ceil) : Int(floor)\n    }\n\
    \    return floorDiff < ceilDiff ? Int(floor) : Int(ceil)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.Owugwh/tmpvjgxoa3r-1.o:tmpvjgxoa3r-1.o:function $s11tmpvjgxoa3r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.Owugwh/tmpvjgxoa3r-1.o:tmpvjgxoa3r-1.o:function $s11tmpvjgxoa3r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.Owugwh/tmpvjgxoa3r-1.o:tmpvjgxoa3r-1.o:function $s11tmpvjgxoa3r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.Owugwh/tmpvjgxoa3r-1.o:tmpvjgxoa3r-1.o:function $s11tmpvjgxoa3r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.Owugwh/tmpvjgxoa3r-1.o:tmpvjgxoa3r-1.o:function $s11tmpvjgxoa3r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.Owugwh/tmpvjgxoa3r-1.o:tmpvjgxoa3r-1.o:function $s11tmpvjgxoa3r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.Owugwh/tmpvjgxoa3r-1.o:tmpvjgxoa3r-1.o:function $s11tmpvjgxoa3r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.Owugwh/tmpvjgxoa3r-1.o:tmpvjgxoa3r-1.o:function $s11tmpvjgxoa3r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.Owugwh/tmpvjgxoa3r-1.o:tmpvjgxoa3r-1.o:function $s11tmpvjgxoa3r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.Owugwh/tmpvjgxoa3r-1.o:tmpvjgxoa3r-1.o:function $s11tmpvjgxoa3r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.Owugwh/tmpvjgxoa3r-1.o:tmpvjgxoa3r-1.o:function $s11tmpvjgxoa3r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.Owugwh/tmpvjgxoa3r-1.o:tmpvjgxoa3r-1.o:function $s11tmpvjgxoa3r15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.Owugwh/tmpvjgxoa3r-1.o:tmpvjgxoa3r-1.o:function $s11tmpvjgxoa3r15closest_i'
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let floor = Int(num.rounded(.down))\n    let\
    \ ceil = Int(num.rounded(.up))\n    if num - Double(floor) < Double(ceil) - num\
    \ {\n        return floor\n    } else {\n        return ceil\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.R9mito/tmpix731zvk-1.o:tmpix731zvk-1.o:function $s11tmpix731zvk15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.R9mito/tmpix731zvk-1.o:tmpix731zvk-1.o:function $s11tmpix731zvk15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.R9mito/tmpix731zvk-1.o:tmpix731zvk-1.o:function $s11tmpix731zvk15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.R9mito/tmpix731zvk-1.o:tmpix731zvk-1.o:function $s11tmpix731zvk15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.R9mito/tmpix731zvk-1.o:tmpix731zvk-1.o:function $s11tmpix731zvk15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.R9mito/tmpix731zvk-1.o:tmpix731zvk-1.o:function $s11tmpix731zvk15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.R9mito/tmpix731zvk-1.o:tmpix731zvk-1.o:function $s11tmpix731zvk15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.R9mito/tmpix731zvk-1.o:tmpix731zvk-1.o:function $s11tmpix731zvk15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.R9mito/tmpix731zvk-1.o:tmpix731zvk-1.o:function $s11tmpix731zvk15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.R9mito/tmpix731zvk-1.o:tmpix731zvk-1.o:function $s11tmpix731zvk15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.R9mito/tmpix731zvk-1.o:tmpix731zvk-1.o:function $s11tmpix731zvk15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.R9mito/tmpix731zvk-1.o:tmpix731zvk-1.o:function $s11tmpix731zvk15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.R9mito/tmpix731zvk-1.o:tmpix731zvk-1.o:function $s11tmpix731zvk15closest_i'
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    if num - Double(int)\
    \ < 0.5 {\n        return int\n    } else {\n        return int + 1\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpgyq0f2sb/tmpgyq0f2sb.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b069d552c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b069d249b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b069d249988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b069d2487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgyq0f2sb                        0x000055a6f1720512 <unavailable> + 5394

    5    libc.so.6                          0x00002b069d73e460 __libc_start_main +
    245

    6    tmpgyq0f2sb                        0x000055a6f1720049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014043
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    let decimal = num - Double(int)\n\
    \    if decimal >= 0.5 {\n        return int + 1\n    } else {\n        return\
    \ int\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpn5zuqzif/tmpn5zuqzif.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b42db182c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b42dae79b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b42dae79988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b42dae787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn5zuqzif                        0x0000561b266a5512 <unavailable> + 5394

    5    libc.so.6                          0x00002b42db36e460 __libc_start_main +
    245

    6    tmpn5zuqzif                        0x0000561b266a5049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let integer\
    \ = Int(rounded)\n    return integer\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.KhlbcM/tmp_qkybqxu-1.o:tmp_qkybqxu-1.o:function $s11tmp_qkybqxu15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.KhlbcM/tmp_qkybqxu-1.o:tmp_qkybqxu-1.o:function $s11tmp_qkybqxu15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.KhlbcM/tmp_qkybqxu-1.o:tmp_qkybqxu-1.o:function $s11tmp_qkybqxu15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.KhlbcM/tmp_qkybqxu-1.o:tmp_qkybqxu-1.o:function $s11tmp_qkybqxu15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.KhlbcM/tmp_qkybqxu-1.o:tmp_qkybqxu-1.o:function $s11tmp_qkybqxu15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.KhlbcM/tmp_qkybqxu-1.o:tmp_qkybqxu-1.o:function $s11tmp_qkybqxu15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.KhlbcM/tmp_qkybqxu-1.o:tmp_qkybqxu-1.o:function $s11tmp_qkybqxu15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let rounded = round(num)\n    let int = Int(rounded)\n\
    \    return int\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp3llopbr0.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(num)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let diff\
    \ = number - rounded\n    if diff < 0 {\n        return Int(rounded)\n    } else\
    \ if diff > 0 {\n        return Int(rounded + 1)\n    } else {\n        return\
    \ Int(number)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmppljdlv8b.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let intNumber = Int(number)\n    let decimal\
    \ = number - Double(intNumber)\n    if decimal < 0.5 {\n        return intNumber\n\
    \    } else {\n        return intNumber + 1\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpe47ov1ny/tmpe47ov1ny.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae0a68bcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae0a65b3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae0a65b3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae0a65b27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe47ov1ny                        0x000056518f2db512 <unavailable> + 5394

    5    libc.so.6                          0x00002ae0a6aa8460 __libc_start_main +
    245

    6    tmpe47ov1ny                        0x000056518f2db049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014043
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimalValue = doubleValue - Double(intValue)\n    if decimalValue < 0.5\
    \ {\n        return intValue\n    } else {\n        return intValue + 1\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpb5j98g80/tmpb5j98g80.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6d8c27dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6d8bf74b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6d8bf74988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6d8bf737b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb5j98g80                        0x000056172b4eb512 <unavailable> + 5394

    5    libc.so.6                          0x00002b6d8c469460 __libc_start_main +
    245

    6    tmpb5j98g80                        0x000056172b4eb049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    return Int(rounded)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpth5ptwc1.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimal = doubleValue - Double(intValue)\n    if decimal >= 0.5 {\n    \
    \    return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmphrztj8i1/tmphrztj8i1.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf8553fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf85236b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaf85236988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaf852357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphrztj8i1                        0x00005640fb238512 <unavailable> + 5394

    5    libc.so.6                          0x00002aaf8572b460 __libc_start_main +
    245

    6    tmphrztj8i1                        0x00005640fb238049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    if number - Double(floor) == 0.5 {\n        return floor\n    } else if number\
    \ - Double(ceil) == -0.5 {\n        return ceil\n    } else {\n        return\
    \ rounded\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_i'
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    let diff_floor = abs(number - Double(floor))\n    let diff_ceil = abs(number\
    \ - Double(ceil))\n    if diff_floor == diff_ceil {\n        return number < 0\
    \ ? floor : ceil\n    }\n    return diff_floor < diff_ceil ? floor : ceil\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpdg88mob7.swift:17:9: warning: initialization of immutable value\
    \ 'rounded' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let rounded = Int(number.rounded())\n    ~~~~^~~~~~~\n    _\nerror:\
    \ link command failed with exit code 1 (use -v to see invocation)\n/tmp/TemporaryDirectory.K1j38u/tmpdg88mob7-1.o:tmpdg88mob7-1.o:function\
    \ $s11tmpdg88mob715closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.K1j38u/tmpdg88mob7-1.o:tmpdg88mob7-1.o:function\
    \ $s11tmpdg88mob715closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.K1j38u/tmpdg88mob7-1.o:tmpdg88mob7-1.o:function\
    \ $s11tmpdg88mob715closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.K1j38u/tmpdg88mob7-1.o:tmpdg88mob7-1.o:function\
    \ $s11tmpdg88mob715closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.K1j38u/tmpdg88mob7-1.o:tmpdg88mob7-1.o:function\
    \ $s11tmpdg88mob715closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.K1j38u/tmpdg88mob7-1.o:tmpdg88mob7-1.o:function\
    \ $s11tmpdg88mob715closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.K1j38u/tmpdg88mob7-1.o:tmpdg88mob7-1.o:function\
    \ $s11tmpdg88mob715closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.K1j38u/tmpdg88mob7-1.o:tmpdg88mob7-1.o:function\
    \ $s11tmpdg88mob715closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.K1j38u/tmpdg88mob7-1.o:tmpdg88mob7-1.o:function\
    \ $s11tmpdg88mob715closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.K1j38u/tmpdg88mob7-1.o:tmpdg88mob7-1.o:function\
    \ $s11tmpdg88mob715closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.K1j38u/tmpdg88mob7-1.o:tmpdg88mob7-1.o:function\
    \ $s11tmpdg88mob715closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.K1j38u/tmpdg88"
  stdout: ''
  timestamp: 1660014043
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < 0.5 {\n        return floor\n\
    \    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpz5m7rozs.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpz5m7rozs.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpz5m7rozs.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpz5m7rozs.swift:18:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimal = doubleValue - Double(intValue)\n    if decimal > 0.5 {\n     \
    \   return intValue + 1\n    } else if decimal < -0.5 {\n        return intValue\
    \ - 1\n    } else {\n        return intValue\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp1hsecz8x/tmp1hsecz8x.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6759af5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b67597ecb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b67597ec988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b67597eb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1hsecz8x                        0x000055bd4c79c46b <unavailable> + 5227

    5    libc.so.6                          0x00002b6759ce1460 __libc_start_main +
    245

    6    tmp1hsecz8x                        0x000055bd4c79c049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014043
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let rounded = round(doubleValue)\n  \
    \  return Int(rounded)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpghv4r0el.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(doubleValue)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    if number\
    \ - rounded > 0.5 {\n        return Int(rounded) + 1\n    } else {\n        return\
    \ Int(rounded)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp7f549hfs.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    if abs(number - Double(rounded)) == 0.5 {\n        if number > 0 {\n    \
    \        return ceil\n        } else {\n            return floor\n        }\n\
    \    } else {\n        return rounded\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_i'
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let int = Int(number)\n    if number - Double(int)\
    \ >= 0.5 {\n        return int + 1\n    } else {\n        return int\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpbm8e2kq7/tmpbm8e2kq7.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab76f814c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab76f50bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab76f50b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab76f50a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbm8e2kq7                        0x0000562631a3f512 <unavailable> + 5394

    5    libc.so.6                          0x00002ab76fa00460 __libc_start_main +
    245

    6    tmpbm8e2kq7                        0x0000562631a3f049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014043
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let rounded_int\
    \ = Int(rounded)\n    let rounded_double = Double(rounded_int)\n    if number\
    \ > rounded_double {\n        return rounded_int + 1\n    } else if number < rounded_double\
    \ {\n        return rounded_int - 1\n    } else {\n        return rounded_int\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.bYIQ6y/tmpwwwwx8jw-1.o:tmpwwwwx8jw-1.o:function $s11tmpwwwwx8jw15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.bYIQ6y/tmpwwwwx8jw-1.o:tmpwwwwx8jw-1.o:function $s11tmpwwwwx8jw15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.bYIQ6y/tmpwwwwx8jw-1.o:tmpwwwwx8jw-1.o:function $s11tmpwwwwx8jw15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.bYIQ6y/tmpwwwwx8jw-1.o:tmpwwwwx8jw-1.o:function $s11tmpwwwwx8jw15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.bYIQ6y/tmpwwwwx8jw-1.o:tmpwwwwx8jw-1.o:function $s11tmpwwwwx8jw15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.bYIQ6y/tmpwwwwx8jw-1.o:tmpwwwwx8jw-1.o:function $s11tmpwwwwx8jw15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.bYIQ6y/tmpwwwwx8jw-1.o:tmpwwwwx8jw-1.o:function $s11tmpwwwwx8jw15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014043
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimalValue = doubleValue - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp51_hz_j6/tmp51_hz_j6.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae2a3878c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae2a356fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae2a356f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae2a356e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp51_hz_j6                        0x000056304faa4512 <unavailable> + 5394

    5    libc.so.6                          0x00002ae2a3a64460 __libc_start_main +
    245

    6    tmp51_hz_j6                        0x000056304faa4049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimal = doubleValue - Double(intValue)\n    if decimal < 0.5 {\n     \
    \   return intValue\n    } else {\n        return intValue + 1\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp_s0_0td_/tmp_s0_0td_.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4a22c64c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4a2295bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4a2295b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4a2295a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_s0_0td_                        0x000055a56c6cf512 <unavailable> + 5394

    5    libc.so.6                          0x00002b4a22e50460 __libc_start_main +
    245

    6    tmp_s0_0td_                        0x000055a56c6cf049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014043
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(Double(value)!.rounded(.awayFromZero))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    return Int(rounded)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpth5ptwc1.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ decimal = number - Double(rounded)\n    if decimal > 0.5 {\n        return rounded\
    \ + 1\n    } else if decimal < -0.5 {\n        return rounded - 1\n    } else\
    \ {\n        return rounded\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.Xb8D6y/tmpbfejneo4-1.o:tmpbfejneo4-1.o:function $s11tmpbfejneo415closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.Xb8D6y/tmpbfejneo4-1.o:tmpbfejneo4-1.o:function $s11tmpbfejneo415closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.Xb8D6y/tmpbfejneo4-1.o:tmpbfejneo4-1.o:function $s11tmpbfejneo415closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.Xb8D6y/tmpbfejneo4-1.o:tmpbfejneo4-1.o:function $s11tmpbfejneo415closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.Xb8D6y/tmpbfejneo4-1.o:tmpbfejneo4-1.o:function $s11tmpbfejneo415closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.Xb8D6y/tmpbfejneo4-1.o:tmpbfejneo4-1.o:function $s11tmpbfejneo415closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.Xb8D6y/tmpbfejneo4-1.o:tmpbfejneo4-1.o:function $s11tmpbfejneo415closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014043
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(round(number))\n    return\
    \ rounded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp9xzctuen.swift:17:23: error: cannot find 'round' in scope\n   \
    \ let rounded = Int(round(number))\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
