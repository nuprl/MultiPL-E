language: swift
name: HumanEval_9_rolling_max
results:
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b887adb3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b887aaaa561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b887aaaa286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b887aaaa13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b887aaa9bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b887a8a9e83 <unavailable> + 188035

    6    tmpbndktfr7                        0x000055f1a4e95b58 <unavailable> + 7000

    7    tmpbndktfr7                        0x000055f1a4e9562d <unavailable> + 5677

    8    libc.so.6                          0x00002b887af9f460 __libc_start_main +
    245

    9    tmpbndktfr7                        0x000055f1a4e95339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1385adbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b13857d2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b13857d2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b13857d213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b13857d1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b13855d1e83 <unavailable> + 188035

    6    tmpburnh_0r                        0x000055614ce96ad8 <unavailable> + 6872

    7    tmpburnh_0r                        0x000055614ce965ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1385cc7460 __libc_start_main +
    245

    9    tmpburnh_0r                        0x000055614ce962b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1385adbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b13857d2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b13857d2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b13857d213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b13857d1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b13855d1e83 <unavailable> + 188035

    6    tmpburnh_0r                        0x000055614ce96ad8 <unavailable> + 6872

    7    tmpburnh_0r                        0x000055614ce965ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1385cc7460 __libc_start_main +
    245

    9    tmpburnh_0r                        0x000055614ce962b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ number in numbers {\n        max = max > number ? max : number\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b864c653c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b864c34a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b864c34a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b864c34a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b864c349bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b864c149e83 <unavailable> + 188035

    6    tmpimc4yzz7                        0x00005624a2b35a5f <unavailable> + 6751

    7    tmpimc4yzz7                        0x00005624a2b3552d <unavailable> + 5421

    8    libc.so.6                          0x00002b864c83f460 __libc_start_main +
    245

    9    tmpimc4yzz7                        0x00005624a2b35239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var current_max = numbers[0]\n\
    \    for number in numbers {\n        if number > current_max {\n            current_max\
    \ = number\n        }\n        result.append(current_max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b4c40b07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4c407fe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b4c407fe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b4c407fe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4c407fdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b4c405fde83 <unavailable> + 188035

    6    tmpdf9p27m8                        0x000055eef40f0a5f <unavailable> + 6751

    7    tmpdf9p27m8                        0x000055eef40f052d <unavailable> + 5421

    8    libc.so.6                          0x00002b4c40cf3460 __libc_start_main +
    245

    9    tmpdf9p27m8                        0x000055eef40f0239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = 0\n    var result = [Int]()\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max > number ? max : number\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = 0\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var current_max = 0\n    for\
    \ number in numbers {\n        if number > current_max {\n            current_max\
    \ = number\n        }\n        result.append(current_max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max > number ? max : number\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        max = max(max, numbers[i])\n      \
    \  result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmp8nfdi9bf.swift:11:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, numbers[i])\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1385adbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b13857d2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b13857d2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b13857d213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b13857d1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b13855d1e83 <unavailable> + 188035

    6    tmpburnh_0r                        0x000055614ce96ad8 <unavailable> + 6872

    7    tmpburnh_0r                        0x000055614ce965ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1385cc7460 __libc_start_main +
    245

    9    tmpburnh_0r                        0x000055614ce962b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1385adbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b13857d2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b13857d2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b13857d213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b13857d1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b13855d1e83 <unavailable> + 188035

    6    tmpburnh_0r                        0x000055614ce96ad8 <unavailable> + 6872

    7    tmpburnh_0r                        0x000055614ce965ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1385cc7460 __libc_start_main +
    245

    9    tmpburnh_0r                        0x000055614ce962b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1385adbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b13857d2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b13857d2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b13857d213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b13857d1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b13855d1e83 <unavailable> + 188035

    6    tmpburnh_0r                        0x000055614ce96ad8 <unavailable> + 6872

    7    tmpburnh_0r                        0x000055614ce965ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1385cc7460 __libc_start_main +
    245

    9    tmpburnh_0r                        0x000055614ce962b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        max = max(max, numbers[i])\n      \
    \  result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmp8nfdi9bf.swift:11:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, numbers[i])\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max > number ? max : number\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for number\
    \ in numbers {\n        max = max > number ? max : number\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        }\n\
    \        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b5a2296cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5a22663561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b5a22663286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b5a2266313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b5a22662bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b5a22462e83 <unavailable> + 188035

    6    tmpf5224ffh                        0x000055a73c59ab68 <unavailable> + 7016

    7    tmpf5224ffh                        0x000055a73c59a62d <unavailable> + 5677

    8    libc.so.6                          0x00002b5a22b58460 __libc_start_main +
    245

    9    tmpf5224ffh                        0x000055a73c59a339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_value = numbers[0]\n\
    \    result.append(max_value)\n    for i in 1..<numbers.count {\n        max_value\
    \ = max(max_value, numbers[i])\n        result.append(max_value)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad4fcc4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad4fc941561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad4fc941286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad4fc94113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad4fc940bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad4fc740e83 <unavailable> + 188035

    6    tmppz76rxxv                        0x000055dc9e8feb68 <unavailable> + 7016

    7    tmppz76rxxv                        0x000055dc9e8fe62d <unavailable> + 5677

    8    libc.so.6                          0x00002ad4fce36460 __libc_start_main +
    245

    9    tmppz76rxxv                        0x000055dc9e8fe339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1a31d56c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1a31a4d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1a31a4d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1a31a4d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1a31a4cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b1a3184ce83 <unavailable> + 188035

    6    tmpajcjyx79                        0x00005557113abae8 <unavailable> + 6888

    7    tmpajcjyx79                        0x00005557113ab5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1a31f42460 __libc_start_main +
    245

    9    tmpajcjyx79                        0x00005557113ab2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae8d202ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae8d1d25561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae8d1d25286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae8d1d2513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae8d1d24bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae8d1b24e83 <unavailable> + 188035

    6    tmpwrcrc0v8                        0x000055d19e210a5f <unavailable> + 6751

    7    tmpwrcrc0v8                        0x000055d19e21052d <unavailable> + 5421

    8    libc.so.6                          0x00002ae8d221a460 __libc_start_main +
    245

    9    tmpwrcrc0v8                        0x000055d19e210239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1a31d56c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1a31a4d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1a31a4d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1a31a4d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1a31a4cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b1a3184ce83 <unavailable> + 188035

    6    tmpajcjyx79                        0x00005557113abae8 <unavailable> + 6888

    7    tmpajcjyx79                        0x00005557113ab5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1a31f42460 __libc_start_main +
    245

    9    tmpajcjyx79                        0x00005557113ab2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae8d202ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae8d1d25561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae8d1d25286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae8d1d2513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae8d1d24bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae8d1b24e83 <unavailable> + 188035

    6    tmpwrcrc0v8                        0x000055d19e210a5f <unavailable> + 6751

    7    tmpwrcrc0v8                        0x000055d19e21052d <unavailable> + 5421

    8    libc.so.6                          0x00002ae8d221a460 __libc_start_main +
    245

    9    tmpwrcrc0v8                        0x000055d19e210239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b887adb3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b887aaaa561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b887aaaa286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b887aaaa13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b887aaa9bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b887a8a9e83 <unavailable> + 188035

    6    tmpbndktfr7                        0x000055f1a4e95b58 <unavailable> + 7000

    7    tmpbndktfr7                        0x000055f1a4e9562d <unavailable> + 5677

    8    libc.so.6                          0x00002b887af9f460 __libc_start_main +
    245

    9    tmpbndktfr7                        0x000055f1a4e95339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b5a2296cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5a22663561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b5a22663286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b5a2266313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b5a22662bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b5a22462e83 <unavailable> + 188035

    6    tmpf5224ffh                        0x000055a73c59ab68 <unavailable> + 7016

    7    tmpf5224ffh                        0x000055a73c59a62d <unavailable> + 5677

    8    libc.so.6                          0x00002b5a22b58460 __libc_start_main +
    245

    9    tmpf5224ffh                        0x000055a73c59a339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = 0\n    var result = [Int]()\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b887adb3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b887aaaa561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b887aaaa286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b887aaaa13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b887aaa9bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b887a8a9e83 <unavailable> + 188035

    6    tmpbndktfr7                        0x000055f1a4e95b58 <unavailable> + 7000

    7    tmpbndktfr7                        0x000055f1a4e9562d <unavailable> + 5677

    8    libc.so.6                          0x00002b887af9f460 __libc_start_main +
    245

    9    tmpbndktfr7                        0x000055f1a4e95339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ number in numbers {\n        max = max > number ? max : number\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b864c653c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b864c34a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b864c34a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b864c34a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b864c349bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b864c149e83 <unavailable> + 188035

    6    tmpimc4yzz7                        0x00005624a2b35a5f <unavailable> + 6751

    7    tmpimc4yzz7                        0x00005624a2b3552d <unavailable> + 5421

    8    libc.so.6                          0x00002b864c83f460 __libc_start_main +
    245

    9    tmpimc4yzz7                        0x00005624a2b35239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max > number ? max : number\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1a31d56c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1a31a4d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1a31a4d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1a31a4d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1a31a4cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b1a3184ce83 <unavailable> + 188035

    6    tmpajcjyx79                        0x00005557113abae8 <unavailable> + 6888

    7    tmpajcjyx79                        0x00005557113ab5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1a31f42460 __libc_start_main +
    245

    9    tmpajcjyx79                        0x00005557113ab2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b5a2296cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5a22663561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b5a22663286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b5a2266313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b5a22662bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b5a22462e83 <unavailable> + 188035

    6    tmpf5224ffh                        0x000055a73c59ab68 <unavailable> + 7016

    7    tmpf5224ffh                        0x000055a73c59a62d <unavailable> + 5677

    8    libc.so.6                          0x00002b5a22b58460 __libc_start_main +
    245

    9    tmpf5224ffh                        0x000055a73c59a339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpghs8rey0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b887adb3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b887aaaa561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b887aaaa286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b887aaaa13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b887aaa9bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b887a8a9e83 <unavailable> + 188035

    6    tmpbndktfr7                        0x000055f1a4e95b58 <unavailable> + 7000

    7    tmpbndktfr7                        0x000055f1a4e9562d <unavailable> + 5677

    8    libc.so.6                          0x00002b887af9f460 __libc_start_main +
    245

    9    tmpbndktfr7                        0x000055f1a4e95339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae8d202ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae8d1d25561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae8d1d25286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae8d1d2513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae8d1d24bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae8d1b24e83 <unavailable> + 188035

    6    tmpwrcrc0v8                        0x000055d19e210a5f <unavailable> + 6751

    7    tmpwrcrc0v8                        0x000055d19e21052d <unavailable> + 5421

    8    libc.so.6                          0x00002ae8d221a460 __libc_start_main +
    245

    9    tmpwrcrc0v8                        0x000055d19e210239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b887adb3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b887aaaa561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b887aaaa286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b887aaaa13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b887aaa9bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b887a8a9e83 <unavailable> + 188035

    6    tmpbndktfr7                        0x000055f1a4e95b58 <unavailable> + 7000

    7    tmpbndktfr7                        0x000055f1a4e9562d <unavailable> + 5677

    8    libc.so.6                          0x00002b887af9f460 __libc_start_main +
    245

    9    tmpbndktfr7                        0x000055f1a4e95339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1385adbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b13857d2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b13857d2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b13857d213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b13857d1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b13855d1e83 <unavailable> + 188035

    6    tmpburnh_0r                        0x000055614ce96ad8 <unavailable> + 6872

    7    tmpburnh_0r                        0x000055614ce965ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1385cc7460 __libc_start_main +
    245

    9    tmpburnh_0r                        0x000055614ce962b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b5a2296cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5a22663561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b5a22663286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b5a2266313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b5a22662bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b5a22462e83 <unavailable> + 188035

    6    tmpf5224ffh                        0x000055a73c59ab68 <unavailable> + 7016

    7    tmpf5224ffh                        0x000055a73c59a62d <unavailable> + 5677

    8    libc.so.6                          0x00002b5a22b58460 __libc_start_main +
    245

    9    tmpf5224ffh                        0x000055a73c59a339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max > number ? max : number\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for number\
    \ in numbers {\n        max = max > number ? max : number\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1385adbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b13857d2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b13857d2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b13857d213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b13857d1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b13855d1e83 <unavailable> + 188035

    6    tmpburnh_0r                        0x000055614ce96ad8 <unavailable> + 6872

    7    tmpburnh_0r                        0x000055614ce965ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1385cc7460 __libc_start_main +
    245

    9    tmpburnh_0r                        0x000055614ce962b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ number in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ba2849a6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba28469d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ba28469d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ba28469d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ba28469cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ba28449ce83 <unavailable> + 188035

    6    tmp1i3yyrcl                        0x000055c63c7a5af8 <unavailable> + 6904

    7    tmp1i3yyrcl                        0x000055c63c7a55bd <unavailable> + 5565

    8    libc.so.6                          0x00002ba284b92460 __libc_start_main +
    245

    9    tmp1i3yyrcl                        0x000055c63c7a52c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        max = max(max, numbers[i])\n      \
    \  result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmp8nfdi9bf.swift:11:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, numbers[i])\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b5a2296cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5a22663561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b5a22663286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b5a2266313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b5a22662bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b5a22462e83 <unavailable> + 188035

    6    tmpf5224ffh                        0x000055a73c59ab68 <unavailable> + 7016

    7    tmpf5224ffh                        0x000055a73c59a62d <unavailable> + 5677

    8    libc.so.6                          0x00002b5a22b58460 __libc_start_main +
    245

    9    tmpf5224ffh                        0x000055a73c59a339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1a31d56c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1a31a4d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1a31a4d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1a31a4d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1a31a4cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b1a3184ce83 <unavailable> + 188035

    6    tmpajcjyx79                        0x00005557113abae8 <unavailable> + 6888

    7    tmpajcjyx79                        0x00005557113ab5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1a31f42460 __libc_start_main +
    245

    9    tmpajcjyx79                        0x00005557113ab2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ i in 0..<numbers.count {\n        max = max(max, numbers[i])\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpiz_u164b.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, numbers[i])\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_value = Int.min\n \
    \   for number in numbers {\n        max_value = max(max_value, number)\n    \
    \    result.append(max_value)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max > number ? max : number\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max > number ? max : number\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1385adbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b13857d2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b13857d2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b13857d213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b13857d1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b13855d1e83 <unavailable> + 188035

    6    tmpburnh_0r                        0x000055614ce96ad8 <unavailable> + 6872

    7    tmpburnh_0r                        0x000055614ce965ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1385cc7460 __libc_start_main +
    245

    9    tmpburnh_0r                        0x000055614ce962b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpghs8rey0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1a31d56c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1a31a4d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1a31a4d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1a31a4d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1a31a4cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b1a3184ce83 <unavailable> + 188035

    6    tmpajcjyx79                        0x00005557113abae8 <unavailable> + 6888

    7    tmpajcjyx79                        0x00005557113ab5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1a31f42460 __libc_start_main +
    245

    9    tmpajcjyx79                        0x00005557113ab2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ i in 0..<numbers.count {\n        max = max(max, numbers[i])\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpiz_u164b.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, numbers[i])\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_elements = [Int]()\n    var max_element = numbers[0]\n\
    \    max_elements.append(max_element)\n    for i in 1..<numbers.count {\n    \
    \    if numbers[i] > max_element {\n            max_element = numbers[i]\n   \
    \     }\n        max_elements.append(max_element)\n    }\n    return max_elements\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b63d91cac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b63d8ec1561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b63d8ec1286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b63d8ec113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b63d8ec0bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b63d8cc0e83 <unavailable> + 188035

    6    tmpmovtpr7h                        0x0000556e2bd2eae8 <unavailable> + 6888

    7    tmpmovtpr7h                        0x0000556e2bd2e5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b63d93b6460 __libc_start_main +
    245

    9    tmpmovtpr7h                        0x0000556e2bd2e2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b5a2296cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5a22663561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b5a22663286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b5a2266313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b5a22662bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b5a22462e83 <unavailable> + 188035

    6    tmpf5224ffh                        0x000055a73c59ab68 <unavailable> + 7016

    7    tmpf5224ffh                        0x000055a73c59a62d <unavailable> + 5677

    8    libc.so.6                          0x00002b5a22b58460 __libc_start_main +
    245

    9    tmpf5224ffh                        0x000055a73c59a339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b887adb3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b887aaaa561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b887aaaa286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b887aaaa13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b887aaa9bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b887a8a9e83 <unavailable> + 188035

    6    tmpbndktfr7                        0x000055f1a4e95b58 <unavailable> + 7000

    7    tmpbndktfr7                        0x000055f1a4e9562d <unavailable> + 5677

    8    libc.so.6                          0x00002b887af9f460 __libc_start_main +
    245

    9    tmpbndktfr7                        0x000055f1a4e95339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1a31d56c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1a31a4d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1a31a4d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1a31a4d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1a31a4cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b1a3184ce83 <unavailable> + 188035

    6    tmpajcjyx79                        0x00005557113abae8 <unavailable> + 6888

    7    tmpajcjyx79                        0x00005557113ab5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1a31f42460 __libc_start_main +
    245

    9    tmpajcjyx79                        0x00005557113ab2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ number in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ba2849a6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba28469d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ba28469d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ba28469d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ba28469cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ba28449ce83 <unavailable> + 188035

    6    tmp1i3yyrcl                        0x000055c63c7a5af8 <unavailable> + 6904

    7    tmp1i3yyrcl                        0x000055c63c7a55bd <unavailable> + 5565

    8    libc.so.6                          0x00002ba284b92460 __libc_start_main +
    245

    9    tmp1i3yyrcl                        0x000055c63c7a52c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b887adb3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b887aaaa561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b887aaaa286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b887aaaa13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b887aaa9bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b887a8a9e83 <unavailable> + 188035

    6    tmpbndktfr7                        0x000055f1a4e95b58 <unavailable> + 7000

    7    tmpbndktfr7                        0x000055f1a4e9562d <unavailable> + 5677

    8    libc.so.6                          0x00002b887af9f460 __libc_start_main +
    245

    9    tmpbndktfr7                        0x000055f1a4e95339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ number in numbers {\n        max = max > number ? max : number\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b864c653c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b864c34a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b864c34a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b864c34a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b864c349bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b864c149e83 <unavailable> + 188035

    6    tmpimc4yzz7                        0x00005624a2b35a5f <unavailable> + 6751

    7    tmpimc4yzz7                        0x00005624a2b3552d <unavailable> + 5421

    8    libc.so.6                          0x00002b864c83f460 __libc_start_main +
    245

    9    tmpimc4yzz7                        0x00005624a2b35239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae8d202ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae8d1d25561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae8d1d25286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae8d1d2513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae8d1d24bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae8d1b24e83 <unavailable> + 188035

    6    tmpwrcrc0v8                        0x000055d19e210a5f <unavailable> + 6751

    7    tmpwrcrc0v8                        0x000055d19e21052d <unavailable> + 5421

    8    libc.so.6                          0x00002ae8d221a460 __libc_start_main +
    245

    9    tmpwrcrc0v8                        0x000055d19e210239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b5a2296cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5a22663561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b5a22663286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b5a2266313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b5a22662bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b5a22462e83 <unavailable> + 188035

    6    tmpf5224ffh                        0x000055a73c59ab68 <unavailable> + 7016

    7    tmpf5224ffh                        0x000055a73c59a62d <unavailable> + 5677

    8    libc.so.6                          0x00002b5a22b58460 __libc_start_main +
    245

    9    tmpf5224ffh                        0x000055a73c59a339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1385adbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b13857d2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b13857d2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b13857d213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b13857d1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b13855d1e83 <unavailable> + 188035

    6    tmpburnh_0r                        0x000055614ce96ad8 <unavailable> + 6872

    7    tmpburnh_0r                        0x000055614ce965ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1385cc7460 __libc_start_main +
    245

    9    tmpburnh_0r                        0x000055614ce962b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1385adbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b13857d2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b13857d2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b13857d213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b13857d1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b13855d1e83 <unavailable> + 188035

    6    tmpburnh_0r                        0x000055614ce96ad8 <unavailable> + 6872

    7    tmpburnh_0r                        0x000055614ce965ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1385cc7460 __libc_start_main +
    245

    9    tmpburnh_0r                        0x000055614ce962b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1a31d56c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1a31a4d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1a31a4d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1a31a4d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1a31a4cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b1a3184ce83 <unavailable> + 188035

    6    tmpajcjyx79                        0x00005557113abae8 <unavailable> + 6888

    7    tmpajcjyx79                        0x00005557113ab5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1a31f42460 __libc_start_main +
    245

    9    tmpajcjyx79                        0x00005557113ab2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1385adbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b13857d2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b13857d2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b13857d213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b13857d1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b13855d1e83 <unavailable> + 188035

    6    tmpburnh_0r                        0x000055614ce96ad8 <unavailable> + 6872

    7    tmpburnh_0r                        0x000055614ce965ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1385cc7460 __libc_start_main +
    245

    9    tmpburnh_0r                        0x000055614ce962b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b887adb3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b887aaaa561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b887aaaa286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b887aaaa13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b887aaa9bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b887a8a9e83 <unavailable> + 188035

    6    tmpbndktfr7                        0x000055f1a4e95b58 <unavailable> + 7000

    7    tmpbndktfr7                        0x000055f1a4e9562d <unavailable> + 5677

    8    libc.so.6                          0x00002b887af9f460 __libc_start_main +
    245

    9    tmpbndktfr7                        0x000055f1a4e95339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpghs8rey0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b5a2296cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5a22663561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b5a22663286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b5a2266313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b5a22662bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b5a22462e83 <unavailable> + 188035

    6    tmpf5224ffh                        0x000055a73c59ab68 <unavailable> + 7016

    7    tmpf5224ffh                        0x000055a73c59a62d <unavailable> + 5677

    8    libc.so.6                          0x00002b5a22b58460 __libc_start_main +
    245

    9    tmpf5224ffh                        0x000055a73c59a339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_value = numbers[0]\n\
    \    for i in 0..<numbers.count {\n        max_value = max(max_value, numbers[i])\n\
    \        result.append(max_value)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b369053cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3690233561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3690233286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b369023313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3690232bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3690034e83 <unavailable> + 188035

    6    tmp92mjqsb4                        0x000056428af87b68 <unavailable> + 7016

    7    tmp92mjqsb4                        0x000056428af8762d <unavailable> + 5677

    8    libc.so.6                          0x00002b3690728460 __libc_start_main +
    245

    9    tmp92mjqsb4                        0x000056428af87339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b887adb3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b887aaaa561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b887aaaa286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b887aaaa13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b887aaa9bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b887a8a9e83 <unavailable> + 188035

    6    tmpbndktfr7                        0x000055f1a4e95b58 <unavailable> + 7000

    7    tmpbndktfr7                        0x000055f1a4e9562d <unavailable> + 5677

    8    libc.so.6                          0x00002b887af9f460 __libc_start_main +
    245

    9    tmpbndktfr7                        0x000055f1a4e95339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var current_max = numbers[0]\n\
    \    result.append(current_max)\n    for i in 1..<numbers.count {\n        current_max\
    \ = max(current_max, numbers[i])\n        result.append(current_max)\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ac302de9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac302ae0561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac302ae0286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac302ae013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac302adfbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ac3028dfe83 <unavailable> + 188035

    6    tmpedc3tx66                        0x0000562e7e25ab68 <unavailable> + 7016

    7    tmpedc3tx66                        0x0000562e7e25a62d <unavailable> + 5677

    8    libc.so.6                          0x00002ac302fd5460 __libc_start_main +
    245

    9    tmpedc3tx66                        0x0000562e7e25a339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        }\n\
    \        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1385adbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b13857d2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b13857d2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b13857d213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b13857d1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b13855d1e83 <unavailable> + 188035

    6    tmpburnh_0r                        0x000055614ce96ad8 <unavailable> + 6872

    7    tmpburnh_0r                        0x000055614ce965ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1385cc7460 __libc_start_main +
    245

    9    tmpburnh_0r                        0x000055614ce962b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1a31d56c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1a31a4d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1a31a4d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1a31a4d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1a31a4cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b1a3184ce83 <unavailable> + 188035

    6    tmpajcjyx79                        0x00005557113abae8 <unavailable> + 6888

    7    tmpajcjyx79                        0x00005557113ab5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1a31f42460 __libc_start_main +
    245

    9    tmpajcjyx79                        0x00005557113ab2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max > number ? max : number\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rolling_max_array = [Int]()\n    var max_value =\
    \ 0\n    for number in numbers {\n        max_value = max(max_value, number)\n\
    \        rolling_max_array.append(max_value)\n    }\n    return rolling_max_array\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b887adb3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b887aaaa561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b887aaaa286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b887aaaa13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b887aaa9bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b887a8a9e83 <unavailable> + 188035

    6    tmpbndktfr7                        0x000055f1a4e95b58 <unavailable> + 7000

    7    tmpbndktfr7                        0x000055f1a4e9562d <unavailable> + 5677

    8    libc.so.6                          0x00002b887af9f460 __libc_start_main +
    245

    9    tmpbndktfr7                        0x000055f1a4e95339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpghs8rey0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1a31d56c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1a31a4d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1a31a4d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1a31a4d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1a31a4cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b1a3184ce83 <unavailable> + 188035

    6    tmpajcjyx79                        0x00005557113abae8 <unavailable> + 6888

    7    tmpajcjyx79                        0x00005557113ab5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1a31f42460 __libc_start_main +
    245

    9    tmpajcjyx79                        0x00005557113ab2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = 0\n    var result = [Int]()\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for number in numbers[1..<numbers.count] {\n\
    \        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a9df2fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a9dc26561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8a9dc26286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8a9dc2613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8a9dc25bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8a9da25e83 <unavailable> + 188035

    6    tmpfjtnts9a                        0x000055f58ecdec9b <unavailable> + 7323

    7    tmpfjtnts9a                        0x000055f58ecde75d <unavailable> + 5981

    8    libc.so.6                          0x00002b8a9e11b460 __libc_start_main +
    245

    9    tmpfjtnts9a                        0x000055f58ecde469 <unavailable> + 5225

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1a31d56c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1a31a4d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1a31a4d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1a31a4d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1a31a4cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b1a3184ce83 <unavailable> + 188035

    6    tmpajcjyx79                        0x00005557113abae8 <unavailable> + 6888

    7    tmpajcjyx79                        0x00005557113ab5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1a31f42460 __libc_start_main +
    245

    9    tmpajcjyx79                        0x00005557113ab2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpghs8rey0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1a31d56c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1a31a4d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1a31a4d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1a31a4d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1a31a4cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b1a3184ce83 <unavailable> + 188035

    6    tmpajcjyx79                        0x00005557113abae8 <unavailable> + 6888

    7    tmpajcjyx79                        0x00005557113ab5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1a31f42460 __libc_start_main +
    245

    9    tmpajcjyx79                        0x00005557113ab2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae8d202ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae8d1d25561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae8d1d25286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae8d1d2513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae8d1d24bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae8d1b24e83 <unavailable> + 188035

    6    tmpwrcrc0v8                        0x000055d19e210a5f <unavailable> + 6751

    7    tmpwrcrc0v8                        0x000055d19e21052d <unavailable> + 5421

    8    libc.so.6                          0x00002ae8d221a460 __libc_start_main +
    245

    9    tmpwrcrc0v8                        0x000055d19e210239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpghs8rey0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        }\n\
    \        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var current_max = numbers[0]\n\
    \    result.append(current_max)\n    for i in 1..<numbers.count {\n        current_max\
    \ = max(current_max, numbers[i])\n        result.append(current_max)\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ac302de9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac302ae0561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac302ae0286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac302ae013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac302adfbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ac3028dfe83 <unavailable> + 188035

    6    tmpedc3tx66                        0x0000562e7e25ab68 <unavailable> + 7016

    7    tmpedc3tx66                        0x0000562e7e25a62d <unavailable> + 5677

    8    libc.so.6                          0x00002ac302fd5460 __libc_start_main +
    245

    9    tmpedc3tx66                        0x0000562e7e25a339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max > number ? max : number\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b887adb3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b887aaaa561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b887aaaa286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b887aaaa13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b887aaa9bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b887a8a9e83 <unavailable> + 188035

    6    tmpbndktfr7                        0x000055f1a4e95b58 <unavailable> + 7000

    7    tmpbndktfr7                        0x000055f1a4e9562d <unavailable> + 5677

    8    libc.so.6                          0x00002b887af9f460 __libc_start_main +
    245

    9    tmpbndktfr7                        0x000055f1a4e95339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b6265e0ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6265b05561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b6265b05286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b6265b0513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b6265b04bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b6265904e83 <unavailable> + 188035

    6    tmp53h8pqtf                        0x000055a85c822ae8 <unavailable> + 6888

    7    tmp53h8pqtf                        0x000055a85c8225ad <unavailable> + 5549

    8    libc.so.6                          0x00002b6265ffa460 __libc_start_main +
    245

    9    tmp53h8pqtf                        0x000055a85c8222b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b887adb3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b887aaaa561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b887aaaa286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b887aaaa13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b887aaa9bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b887a8a9e83 <unavailable> + 188035

    6    tmpbndktfr7                        0x000055f1a4e95b58 <unavailable> + 7000

    7    tmpbndktfr7                        0x000055f1a4e9562d <unavailable> + 5677

    8    libc.so.6                          0x00002b887af9f460 __libc_start_main +
    245

    9    tmpbndktfr7                        0x000055f1a4e95339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max > number ? max : number\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        max = max(max, numbers[i])\n      \
    \  result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmp8nfdi9bf.swift:11:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, numbers[i])\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1a31d56c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1a31a4d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1a31a4d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1a31a4d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1a31a4cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b1a3184ce83 <unavailable> + 188035

    6    tmpajcjyx79                        0x00005557113abae8 <unavailable> + 6888

    7    tmpajcjyx79                        0x00005557113ab5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1a31f42460 __libc_start_main +
    245

    9    tmpajcjyx79                        0x00005557113ab2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1a31d56c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1a31a4d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1a31a4d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1a31a4d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1a31a4cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b1a3184ce83 <unavailable> + 188035

    6    tmpajcjyx79                        0x00005557113abae8 <unavailable> + 6888

    7    tmpajcjyx79                        0x00005557113ab5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1a31f42460 __libc_start_main +
    245

    9    tmpajcjyx79                        0x00005557113ab2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ i in 0..<numbers.count {\n        max = max(max, numbers[i])\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpiz_u164b.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, numbers[i])\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b887adb3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b887aaaa561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b887aaaa286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b887aaaa13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b887aaa9bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b887a8a9e83 <unavailable> + 188035

    6    tmpbndktfr7                        0x000055f1a4e95b58 <unavailable> + 7000

    7    tmpbndktfr7                        0x000055f1a4e9562d <unavailable> + 5677

    8    libc.so.6                          0x00002b887af9f460 __libc_start_main +
    245

    9    tmpbndktfr7                        0x000055f1a4e95339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1385adbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b13857d2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b13857d2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b13857d213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b13857d1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b13855d1e83 <unavailable> + 188035

    6    tmpburnh_0r                        0x000055614ce96ad8 <unavailable> + 6872

    7    tmpburnh_0r                        0x000055614ce965ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1385cc7460 __libc_start_main +
    245

    9    tmpburnh_0r                        0x000055614ce962b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_element = Int.min\n\
    \    for number in numbers {\n        max_element = max(max_element, number)\n\
    \        result.append(max_element)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1a31d56c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1a31a4d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1a31a4d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1a31a4d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1a31a4cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b1a3184ce83 <unavailable> + 188035

    6    tmpajcjyx79                        0x00005557113abae8 <unavailable> + 6888

    7    tmpajcjyx79                        0x00005557113ab5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1a31f42460 __libc_start_main +
    245

    9    tmpajcjyx79                        0x00005557113ab2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b5a2296cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5a22663561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b5a22663286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b5a2266313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b5a22662bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b5a22462e83 <unavailable> + 188035

    6    tmpf5224ffh                        0x000055a73c59ab68 <unavailable> + 7016

    7    tmpf5224ffh                        0x000055a73c59a62d <unavailable> + 5677

    8    libc.so.6                          0x00002b5a22b58460 __libc_start_main +
    245

    9    tmpf5224ffh                        0x000055a73c59a339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1a31d56c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1a31a4d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1a31a4d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1a31a4d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1a31a4cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b1a3184ce83 <unavailable> + 188035

    6    tmpajcjyx79                        0x00005557113abae8 <unavailable> + 6888

    7    tmpajcjyx79                        0x00005557113ab5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1a31f42460 __libc_start_main +
    245

    9    tmpajcjyx79                        0x00005557113ab2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b5a2296cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5a22663561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b5a22663286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b5a2266313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b5a22662bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b5a22462e83 <unavailable> + 188035

    6    tmpf5224ffh                        0x000055a73c59ab68 <unavailable> + 7016

    7    tmpf5224ffh                        0x000055a73c59a62d <unavailable> + 5677

    8    libc.so.6                          0x00002b5a22b58460 __libc_start_main +
    245

    9    tmpf5224ffh                        0x000055a73c59a339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b887adb3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b887aaaa561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b887aaaa286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b887aaaa13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b887aaa9bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b887a8a9e83 <unavailable> + 188035

    6    tmpbndktfr7                        0x000055f1a4e95b58 <unavailable> + 7000

    7    tmpbndktfr7                        0x000055f1a4e9562d <unavailable> + 5677

    8    libc.so.6                          0x00002b887af9f460 __libc_start_main +
    245

    9    tmpbndktfr7                        0x000055f1a4e95339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b5a2296cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5a22663561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b5a22663286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b5a2266313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b5a22662bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b5a22462e83 <unavailable> + 188035

    6    tmpf5224ffh                        0x000055a73c59ab68 <unavailable> + 7016

    7    tmpf5224ffh                        0x000055a73c59a62d <unavailable> + 5677

    8    libc.so.6                          0x00002b5a22b58460 __libc_start_main +
    245

    9    tmpf5224ffh                        0x000055a73c59a339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ number in numbers {\n        max = max > number ? max : number\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b864c653c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b864c34a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b864c34a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b864c34a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b864c349bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b864c149e83 <unavailable> + 188035

    6    tmpimc4yzz7                        0x00005624a2b35a5f <unavailable> + 6751

    7    tmpimc4yzz7                        0x00005624a2b3552d <unavailable> + 5421

    8    libc.so.6                          0x00002b864c83f460 __libc_start_main +
    245

    9    tmpimc4yzz7                        0x00005624a2b35239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        max = max(max, numbers[i])\n      \
    \  result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmp8nfdi9bf.swift:11:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, numbers[i])\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1a31d56c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1a31a4d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1a31a4d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1a31a4d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1a31a4cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b1a3184ce83 <unavailable> + 188035

    6    tmpajcjyx79                        0x00005557113abae8 <unavailable> + 6888

    7    tmpajcjyx79                        0x00005557113ab5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1a31f42460 __libc_start_main +
    245

    9    tmpajcjyx79                        0x00005557113ab2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        max = max(max, numbers[i])\n      \
    \  result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmp8nfdi9bf.swift:11:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, numbers[i])\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae8d202ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae8d1d25561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae8d1d25286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae8d1d2513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae8d1d24bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae8d1b24e83 <unavailable> + 188035

    6    tmpwrcrc0v8                        0x000055d19e210a5f <unavailable> + 6751

    7    tmpwrcrc0v8                        0x000055d19e21052d <unavailable> + 5421

    8    libc.so.6                          0x00002ae8d221a460 __libc_start_main +
    245

    9    tmpwrcrc0v8                        0x000055d19e210239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ number in numbers {\n        max = max > number ? max : number\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b864c653c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b864c34a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b864c34a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b864c34a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b864c349bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b864c149e83 <unavailable> + 188035

    6    tmpimc4yzz7                        0x00005624a2b35a5f <unavailable> + 6751

    7    tmpimc4yzz7                        0x00005624a2b3552d <unavailable> + 5421

    8    libc.so.6                          0x00002b864c83f460 __libc_start_main +
    245

    9    tmpimc4yzz7                        0x00005624a2b35239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        max = max(max, numbers[i])\n      \
    \  result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmp8nfdi9bf.swift:11:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, numbers[i])\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpghs8rey0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ number in numbers {\n        max = max > number ? max : number\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b864c653c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b864c34a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b864c34a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b864c34a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b864c349bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b864c149e83 <unavailable> + 188035

    6    tmpimc4yzz7                        0x00005624a2b35a5f <unavailable> + 6751

    7    tmpimc4yzz7                        0x00005624a2b3552d <unavailable> + 5421

    8    libc.so.6                          0x00002b864c83f460 __libc_start_main +
    245

    9    tmpimc4yzz7                        0x00005624a2b35239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b887adb3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b887aaaa561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b887aaaa286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b887aaaa13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b887aaa9bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b887a8a9e83 <unavailable> + 188035

    6    tmpbndktfr7                        0x000055f1a4e95b58 <unavailable> + 7000

    7    tmpbndktfr7                        0x000055f1a4e9562d <unavailable> + 5677

    8    libc.so.6                          0x00002b887af9f460 __libc_start_main +
    245

    9    tmpbndktfr7                        0x000055f1a4e95339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1385adbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b13857d2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b13857d2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b13857d213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b13857d1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b13855d1e83 <unavailable> + 188035

    6    tmpburnh_0r                        0x000055614ce96ad8 <unavailable> + 6872

    7    tmpburnh_0r                        0x000055614ce965ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1385cc7460 __libc_start_main +
    245

    9    tmpburnh_0r                        0x000055614ce962b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1385adbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b13857d2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b13857d2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b13857d213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b13857d1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b13855d1e83 <unavailable> + 188035

    6    tmpburnh_0r                        0x000055614ce96ad8 <unavailable> + 6872

    7    tmpburnh_0r                        0x000055614ce965ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1385cc7460 __libc_start_main +
    245

    9    tmpburnh_0r                        0x000055614ce962b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ i in 0..<numbers.count {\n        max = max > numbers[i] ? max : numbers[i]\n\
    \        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b504562bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5045322561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b5045322286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b504532213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b5045321bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b5045121e83 <unavailable> + 188035

    6    tmp3c2ots5w                        0x000056465a096ae8 <unavailable> + 6888

    7    tmp3c2ots5w                        0x000056465a0965ad <unavailable> + 5549

    8    libc.so.6                          0x00002b5045817460 __libc_start_main +
    245

    9    tmp3c2ots5w                        0x000056465a0962b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1a31d56c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1a31a4d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1a31a4d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1a31a4d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1a31a4cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b1a3184ce83 <unavailable> + 188035

    6    tmpajcjyx79                        0x00005557113abae8 <unavailable> + 6888

    7    tmpajcjyx79                        0x00005557113ab5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1a31f42460 __libc_start_main +
    245

    9    tmpajcjyx79                        0x00005557113ab2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1a31d56c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1a31a4d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1a31a4d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1a31a4d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1a31a4cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b1a3184ce83 <unavailable> + 188035

    6    tmpajcjyx79                        0x00005557113abae8 <unavailable> + 6888

    7    tmpajcjyx79                        0x00005557113ab5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1a31f42460 __libc_start_main +
    245

    9    tmpajcjyx79                        0x00005557113ab2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1385adbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b13857d2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b13857d2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b13857d213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b13857d1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b13855d1e83 <unavailable> + 188035

    6    tmpburnh_0r                        0x000055614ce96ad8 <unavailable> + 6872

    7    tmpburnh_0r                        0x000055614ce965ad <unavailable> + 5549

    8    libc.so.6                          0x00002b1385cc7460 __libc_start_main +
    245

    9    tmpburnh_0r                        0x000055614ce962b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae8d202ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae8d1d25561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae8d1d25286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae8d1d2513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae8d1d24bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae8d1b24e83 <unavailable> + 188035

    6    tmpwrcrc0v8                        0x000055d19e210a5f <unavailable> + 6751

    7    tmpwrcrc0v8                        0x000055d19e21052d <unavailable> + 5421

    8    libc.so.6                          0x00002ae8d221a460 __libc_start_main +
    245

    9    tmpwrcrc0v8                        0x000055d19e210239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ number in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ba2849a6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba28469d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ba28469d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ba28469d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ba28469cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ba28449ce83 <unavailable> + 188035

    6    tmp1i3yyrcl                        0x000055c63c7a5af8 <unavailable> + 6904

    7    tmp1i3yyrcl                        0x000055c63c7a55bd <unavailable> + 5565

    8    libc.so.6                          0x00002ba284b92460 __libc_start_main +
    245

    9    tmp1i3yyrcl                        0x000055c63c7a52c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824726
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824726
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7sfvb8p0.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824726
