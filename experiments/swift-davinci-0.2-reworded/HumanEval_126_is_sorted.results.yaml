language: swift
name: HumanEval_126_is_sorted
results:
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ i in 1..<lst.count {\n        if lst[i] < prev {\n            return false\n\
    \        }\n        prev = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aeb63431c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeb63128561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aeb63128286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aeb6312813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aeb63127bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aeb62f27e83 <unavailable> + 188035

    6    tmpfg_mhb9h                        0x000055cbfebc0042 <unavailable> + 8258

    7    tmpfg_mhb9h                        0x000055cbfebbf9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002aeb6361d460 __libc_start_main +
    245

    9    tmpfg_mhb9h                        0x000055cbfebbf1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ i in 1..<lst.count {\n        if lst[i] <= prev {\n            return false\n\
    \        }\n        prev = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b6a7acdec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6a7a9d5561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b6a7a9d5286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b6a7a9d513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b6a7a9d4bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b6a7a7d4e83 <unavailable> + 188035

    6    tmpqddor0o8                        0x000056074bcd7042 <unavailable> + 8258

    7    tmpqddor0o8                        0x000056074bcd69d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b6a7aeca460 __libc_start_main +
    245

    9    tmpqddor0o8                        0x000056074bcd61a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ i in 1..<lst.count {\n        if lst[i] < prev {\n            return false\n\
    \        }\n        prev = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aeb63431c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeb63128561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aeb63128286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aeb6312813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aeb63127bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aeb62f27e83 <unavailable> + 188035

    6    tmpfg_mhb9h                        0x000055cbfebc0042 <unavailable> + 8258

    7    tmpfg_mhb9h                        0x000055cbfebbf9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002aeb6361d460 __libc_start_main +
    245

    9    tmpfg_mhb9h                        0x000055cbfebbf1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    var prev = lst[0]\n    for i in 1..<lst.count {\n\
    \        if lst[i] < prev {\n            return false\n        }\n        prev\
    \ = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b4f8b798c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4f8b48f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b4f8b48f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b4f8b48f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4f8b48ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b4f8b28ee83 <unavailable> + 188035

    6    tmpvnxjb_eu                        0x0000564a1439405b <unavailable> + 8283

    7    tmpvnxjb_eu                        0x0000564a143939d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b4f8b984460 __libc_start_main +
    245

    9    tmpvnxjb_eu                        0x0000564a143931a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002afa980dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa97dd2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afa97dd2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afa97dd213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afa97dd1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpxxxyn5qn                        0x000055ab352f20f3 <unavailable> + 8435

    6    tmpxxxyn5qn                        0x000055ab352f19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002afa982c7460 __libc_start_main +
    245

    8    tmpxxxyn5qn                        0x000055ab352f11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    for\
    \ i in 0..<lst.count - 1 {\n        if lst[i] > lst[i + 1] {\n            sorted\
    \ = false\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ace6c854c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace6c54b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ace6c54b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ace6c54b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ace6c54abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3lv57n76                        0x000055e2934a20ee <unavailable> + 8430

    6    tmp3lv57n76                        0x000055e2934a19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002ace6ca40460 __libc_start_main +
    245

    8    tmp3lv57n76                        0x000055e2934a11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for num in lst {\n        if num == prev {\n            return\
    \ false\n        }\n        if num < prev {\n            sorted = false\n    \
    \    }\n        prev = num\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpay6a2zw7/tmpay6a2zw7.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b694230ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6942001b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6942001988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b69420007b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpay6a2zw7                        0x00005571525d34aa <unavailable> + 5290

    5    libc.so.6                          0x00002b69424f6460 __libc_start_main +
    245

    6    tmpay6a2zw7                        0x00005571525d3129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    } else {\n        for i in 0..<lst.count - 1 {\n      \
    \      if lst[i] > lst[i + 1] {\n                return false\n            }\n\
    \        }\n        return true\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ae24429dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae243f94561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae243f94286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae243f9413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae243f93bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpc3deegt7                        0x00005608264610f3 <unavailable> + 8435

    6    tmpc3deegt7                        0x00005608264609d4 <unavailable> + 6612

    7    libc.so.6                          0x00002ae244489460 __libc_start_main +
    245

    8    tmpc3deegt7                        0x00005608264601a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    if\
    \ lst.count > 1 {\n        for i in 0..<lst.count-1 {\n            if lst[i] >\
    \ lst[i+1] {\n                sorted = false\n            }\n        }\n    }\n\
    \    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmphvzp8ioo/tmphvzp8ioo.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab0fa8d2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab0fa5c9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab0fa5c9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab0fa5c87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphvzp8ioo                        0x00005575dc6f6cfb <unavailable> + 7419

    5    libc.so.6                          0x00002ab0faabe460 __libc_start_main +
    245

    6    tmphvzp8ioo                        0x00005575dc6f61a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002afa980dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa97dd2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afa97dd2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afa97dd213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afa97dd1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpxxxyn5qn                        0x000055ab352f20f3 <unavailable> + 8435

    6    tmpxxxyn5qn                        0x000055ab352f19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002afa982c7460 __libc_start_main +
    245

    8    tmpxxxyn5qn                        0x000055ab352f11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002afa980dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa97dd2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afa97dd2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afa97dd213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afa97dd1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpxxxyn5qn                        0x000055ab352f20f3 <unavailable> + 8435

    6    tmpxxxyn5qn                        0x000055ab352f19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002afa982c7460 __libc_start_main +
    245

    8    tmpxxxyn5qn                        0x000055ab352f11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    for\
    \ i in 0..<lst.count - 1 {\n        if lst[i] > lst[i + 1] {\n            sorted\
    \ = false\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ace6c854c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace6c54b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ace6c54b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ace6c54b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ace6c54abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3lv57n76                        0x000055e2934a20ee <unavailable> + 8430

    6    tmp3lv57n76                        0x000055e2934a19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002ace6ca40460 __libc_start_main +
    245

    8    tmp3lv57n76                        0x000055e2934a11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    // TODO: Implement me!\n\
    \    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmps3xhvubr/tmps3xhvubr.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b40db5c1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b40db2b8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b40db2b8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b40db2b77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps3xhvubr                        0x0000555b71fd42ea <unavailable> + 4842

    5    libc.so.6                          0x00002b40db7ad460 __libc_start_main +
    245

    6    tmps3xhvubr                        0x0000555b71fd3f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ previous = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < previous\
    \ {\n            sorted = false\n        }\n        previous = lst[i]\n    }\n\
    \    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acdd8845c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acdd853c561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acdd853c286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acdd853c13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acdd853bbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acdd833be83 <unavailable> + 188035

    6    tmp0vt2toem                        0x0000557c8c9b9056 <unavailable> + 8278

    7    tmp0vt2toem                        0x0000557c8c9b89d4 <unavailable> + 6612

    8    libc.so.6                          0x00002acdd8a31460 __libc_start_main +
    245

    9    tmp0vt2toem                        0x0000557c8c9b81a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    for\
    \ i in 0..<lst.count - 1 {\n        if lst[i] > lst[i + 1] {\n            sorted\
    \ = false\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ace6c854c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace6c54b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ace6c54b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ace6c54b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ace6c54abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3lv57n76                        0x000055e2934a20ee <unavailable> + 8430

    6    tmp3lv57n76                        0x000055e2934a19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002ace6ca40460 __libc_start_main +
    245

    8    tmp3lv57n76                        0x000055e2934a11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count-1 {\n        if lst[i] >=\
    \ lst[i+1] {\n            return false\n        }\n    }\n    return true\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b14457bbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b14454b2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b14454b2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b14454b213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b14454b1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpguhrs5vj                        0x000055fe5bf430f3 <unavailable> + 8435

    6    tmpguhrs5vj                        0x000055fe5bf429d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b14459a7460 __libc_start_main +
    245

    8    tmpguhrs5vj                        0x000055fe5bf421a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002afa980dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa97dd2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afa97dd2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afa97dd213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afa97dd1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpxxxyn5qn                        0x000055ab352f20f3 <unavailable> + 8435

    6    tmpxxxyn5qn                        0x000055ab352f19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002afa982c7460 __libc_start_main +
    245

    8    tmpxxxyn5qn                        0x000055ab352f11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002afa980dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa97dd2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afa97dd2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afa97dd213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afa97dd1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpxxxyn5qn                        0x000055ab352f20f3 <unavailable> + 8435

    6    tmpxxxyn5qn                        0x000055ab352f19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002afa982c7460 __libc_start_main +
    245

    8    tmpxxxyn5qn                        0x000055ab352f11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    for\
    \ i in 0..<lst.count - 1 {\n        if lst[i] > lst[i + 1] {\n            sorted\
    \ = false\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ace6c854c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace6c54b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ace6c54b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ace6c54b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ace6c54abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3lv57n76                        0x000055e2934a20ee <unavailable> + 8430

    6    tmp3lv57n76                        0x000055e2934a19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002ace6ca40460 __libc_start_main +
    245

    8    tmp3lv57n76                        0x000055e2934a11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    for\
    \ i in 0..<lst.count - 1 {\n        if lst[i] > lst[i + 1] {\n            sorted\
    \ = false\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ace6c854c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace6c54b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ace6c54b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ace6c54b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ace6c54abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3lv57n76                        0x000055e2934a20ee <unavailable> + 8430

    6    tmp3lv57n76                        0x000055e2934a19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002ace6ca40460 __libc_start_main +
    245

    8    tmp3lv57n76                        0x000055e2934a11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002afa980dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa97dd2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afa97dd2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afa97dd213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afa97dd1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpxxxyn5qn                        0x000055ab352f20f3 <unavailable> + 8435

    6    tmpxxxyn5qn                        0x000055ab352f19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002afa982c7460 __libc_start_main +
    245

    8    tmpxxxyn5qn                        0x000055ab352f11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    for\
    \ i in 0..<lst.count - 1 {\n        if lst[i] > lst[i + 1] {\n            sorted\
    \ = false\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ace6c854c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace6c54b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ace6c54b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ace6c54b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ace6c54abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3lv57n76                        0x000055e2934a20ee <unavailable> + 8430

    6    tmp3lv57n76                        0x000055e2934a19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002ace6ca40460 __libc_start_main +
    245

    8    tmp3lv57n76                        0x000055e2934a11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = lst.sorted()\n\
    \    return sorted == lst\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp1pbgptgw/tmp1pbgptgw.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abd509fac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abd506f1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abd506f1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abd506f07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1pbgptgw                        0x000056523bab6bcb <unavailable> + 7115

    5    libc.so.6                          0x00002abd50be6460 __libc_start_main +
    245

    6    tmp1pbgptgw                        0x000056523bab6079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count-1 {\n        if lst[i] >\
    \ lst[i+1] {\n            return false\n        }\n    }\n    return true\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b195974bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1959442561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1959442286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b195944213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1959441bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpw4zb28ar                        0x0000555c65cf50f3 <unavailable> + 8435

    6    tmpw4zb28ar                        0x0000555c65cf49d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b1959937460 __libc_start_main +
    245

    8    tmpw4zb28ar                        0x0000555c65cf41a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ i in 1..<lst.count {\n        if lst[i] < prev {\n            return false\n\
    \        }\n        prev = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aeb63431c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeb63128561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aeb63128286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aeb6312813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aeb63127bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aeb62f27e83 <unavailable> + 188035

    6    tmpfg_mhb9h                        0x000055cbfebc0042 <unavailable> + 8258

    7    tmpfg_mhb9h                        0x000055cbfebbf9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002aeb6361d460 __libc_start_main +
    245

    9    tmpfg_mhb9h                        0x000055cbfebbf1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    for i in 0..<lst.count -\
    \ 1 {\n        if lst[i] > lst[i + 1] {\n            return false\n        }\n\
    \    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3e6d03c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3e69fa561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac3e69fa286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac3e69fa13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac3e69f9bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpjh6ev8mf                        0x000055b71e3840da <unavailable> + 8410

    6    tmpjh6ev8mf                        0x000055b71e3839d4 <unavailable> + 6612

    7    libc.so.6                          0x00002ac3e6eef460 __libc_start_main +
    245

    8    tmpjh6ev8mf                        0x000055b71e3831a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002afa980dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa97dd2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afa97dd2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afa97dd213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afa97dd1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpxxxyn5qn                        0x000055ab352f20f3 <unavailable> + 8435

    6    tmpxxxyn5qn                        0x000055ab352f19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002afa982c7460 __libc_start_main +
    245

    8    tmpxxxyn5qn                        0x000055ab352f11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002afa980dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa97dd2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afa97dd2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afa97dd213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afa97dd1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpxxxyn5qn                        0x000055ab352f20f3 <unavailable> + 8435

    6    tmpxxxyn5qn                        0x000055ab352f19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002afa982c7460 __libc_start_main +
    245

    8    tmpxxxyn5qn                        0x000055ab352f11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if prev > lst[i] {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aca9179cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aca91493561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aca91493286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aca9149313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aca91492bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aca91292e83 <unavailable> + 188035

    6    tmp8gblldz4                        0x000055eb0b244056 <unavailable> + 8278

    7    tmp8gblldz4                        0x000055eb0b2439d4 <unavailable> + 6612

    8    libc.so.6                          0x00002aca91988460 __libc_start_main +
    245

    9    tmp8gblldz4                        0x000055eb0b2431a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    var prev = lst[0]\n    for i in 1..<lst.count {\n\
    \        if lst[i] == prev {\n            return false\n        }\n        if\
    \ lst[i] < prev {\n            return false\n        }\n        prev = lst[i]\n\
    \    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae233096c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae232d8d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae232d8d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae232d8d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae232d8cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae232b8ce83 <unavailable> + 188035

    6    tmpu6wlv5u8                        0x000055cb5e6c605b <unavailable> + 8283

    7    tmpu6wlv5u8                        0x000055cb5e6c59d4 <unavailable> + 6612

    8    libc.so.6                          0x00002ae233282460 __libc_start_main +
    245

    9    tmpu6wlv5u8                        0x000055cb5e6c51a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    for\
    \ i in 0..<lst.count - 1 {\n        if lst[i] > lst[i + 1] {\n            sorted\
    \ = false\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ace6c854c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace6c54b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ace6c54b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ace6c54b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ace6c54abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3lv57n76                        0x000055e2934a20ee <unavailable> + 8430

    6    tmp3lv57n76                        0x000055e2934a19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002ace6ca40460 __libc_start_main +
    245

    8    tmp3lv57n76                        0x000055e2934a11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    var prev = lst[0]\n    for i in 1..<lst.count {\n\
    \        if lst[i] < prev {\n            return false\n        }\n        prev\
    \ = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b4f8b798c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4f8b48f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b4f8b48f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b4f8b48f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4f8b48ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b4f8b28ee83 <unavailable> + 188035

    6    tmpvnxjb_eu                        0x0000564a1439405b <unavailable> + 8283

    7    tmpvnxjb_eu                        0x0000564a143939d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b4f8b984460 __libc_start_main +
    245

    9    tmpvnxjb_eu                        0x0000564a143931a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] <= prev {\n \
    \           sorted = false\n            break\n        }\n        prev = lst[i]\n\
    \    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aee6a3a7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aee6a09e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aee6a09e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aee6a09e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aee6a09dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aee69e9de83 <unavailable> + 188035

    6    tmp91h05hug                        0x00005647a5845056 <unavailable> + 8278

    7    tmp91h05hug                        0x00005647a58449d4 <unavailable> + 6612

    8    libc.so.6                          0x00002aee6a593460 __libc_start_main +
    245

    9    tmp91h05hug                        0x00005647a58441a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ last = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < last {\n  \
    \          sorted = false\n        }\n        last = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b4a68dc6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4a68abd561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b4a68abd286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b4a68abd13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4a68abcbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b4a688bce83 <unavailable> + 188035

    6    tmpnynbpdx3                        0x0000562f219ad056 <unavailable> + 8278

    7    tmpnynbpdx3                        0x0000562f219ac9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b4a68fb2460 __libc_start_main +
    245

    9    tmpnynbpdx3                        0x0000562f219ac1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for num in lst {\n        if num < prev {\n            sorted\
    \ = false\n        }\n        prev = num\n    }\n    return sorted\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b36f732bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b36f7022561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b36f7022286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b36f702213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b36f7021bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b36f6e21e83 <unavailable> + 188035

    6    tmpbhyastnx                        0x000055dd3b875fd6 <unavailable> + 8150

    7    tmpbhyastnx                        0x000055dd3b875954 <unavailable> + 6484

    8    libc.so.6                          0x00002b36f7517460 __libc_start_main +
    245

    9    tmpbhyastnx                        0x000055dd3b875129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002afa980dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa97dd2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afa97dd2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afa97dd213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afa97dd1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpxxxyn5qn                        0x000055ab352f20f3 <unavailable> + 8435

    6    tmpxxxyn5qn                        0x000055ab352f19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002afa982c7460 __libc_start_main +
    245

    8    tmpxxxyn5qn                        0x000055ab352f11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002afa980dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa97dd2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afa97dd2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afa97dd213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afa97dd1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpxxxyn5qn                        0x000055ab352f20f3 <unavailable> + 8435

    6    tmpxxxyn5qn                        0x000055ab352f19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002afa982c7460 __libc_start_main +
    245

    8    tmpxxxyn5qn                        0x000055ab352f11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ last = lst[0]\n    for num in lst {\n        if num < last {\n            sorted\
    \ = false\n        }\n        last = num\n    }\n    return sorted\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b578739ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5787095561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b5787095286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b578709513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b5787094bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b5786e94e83 <unavailable> + 188035

    6    tmp7t53bnqc                        0x000055fb3f657fd6 <unavailable> + 8150

    7    tmp7t53bnqc                        0x000055fb3f657954 <unavailable> + 6484

    8    libc.so.6                          0x00002b578758a460 __libc_start_main +
    245

    9    tmp7t53bnqc                        0x000055fb3f657129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002afa980dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa97dd2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afa97dd2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afa97dd213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afa97dd1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpxxxyn5qn                        0x000055ab352f20f3 <unavailable> + 8435

    6    tmpxxxyn5qn                        0x000055ab352f19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002afa982c7460 __libc_start_main +
    245

    8    tmpxxxyn5qn                        0x000055ab352f11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ >= lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ba585a28c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba58571f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ba58571f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ba58571f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ba58571ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpjkima892                        0x0000563f460b90f3 <unavailable> + 8435

    6    tmpjkima892                        0x0000563f460b89d4 <unavailable> + 6612

    7    libc.so.6                          0x00002ba585c14460 __libc_start_main +
    245

    8    tmpjkima892                        0x0000563f460b81a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpxlqia1kp/tmpxlqia1kp.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b42557c3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b42554bab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b42554ba988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b42554b97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxlqia1kp                        0x00005616796e12ea <unavailable> + 4842

    5    libc.so.6                          0x00002b42559af460 __libc_start_main +
    245

    6    tmpxlqia1kp                        0x00005616796e0f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ i = 0\n    while i < lst.count - 1 {\n        if lst[i] > lst[i + 1] {\n   \
    \         sorted = false\n        }\n        i += 1\n    }\n    return sorted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp56li8_ay/tmp56li8_ay.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b01f1ef3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b01f1beab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b01f1bea988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b01f1be97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp56li8_ay                        0x000055b92cbbab6b <unavailable> + 7019

    5    libc.so.6                          0x00002b01f20df460 __libc_start_main +
    245

    6    tmp56li8_ay                        0x000055b92cbba019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ >= lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ba585a28c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba58571f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ba58571f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ba58571f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ba58571ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpjkima892                        0x0000563f460b90f3 <unavailable> + 8435

    6    tmpjkima892                        0x0000563f460b89d4 <unavailable> + 6612

    7    libc.so.6                          0x00002ba585c14460 __libc_start_main +
    245

    8    tmpjkima892                        0x0000563f460b81a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002afa980dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa97dd2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afa97dd2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afa97dd213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afa97dd1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpxxxyn5qn                        0x000055ab352f20f3 <unavailable> + 8435

    6    tmpxxxyn5qn                        0x000055ab352f19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002afa982c7460 __libc_start_main +
    245

    8    tmpxxxyn5qn                        0x000055ab352f11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for num in lst {\n        if num < prev {\n            sorted\
    \ = false\n        }\n        prev = num\n    }\n    return sorted\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b36f732bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b36f7022561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b36f7022286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b36f702213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b36f7021bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b36f6e21e83 <unavailable> + 188035

    6    tmpbhyastnx                        0x000055dd3b875fd6 <unavailable> + 8150

    7    tmpbhyastnx                        0x000055dd3b875954 <unavailable> + 6484

    8    libc.so.6                          0x00002b36f7517460 __libc_start_main +
    245

    9    tmpbhyastnx                        0x000055dd3b875129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    var count = 1\n    for i in 1..<lst.count {\n        if lst[i]\
    \ == prev {\n            count += 1\n        } else {\n            count = 1\n\
    \        }\n        if count > 1 {\n            return false\n        }\n    \
    \    if lst[i] < prev {\n            sorted = false\n        }\n        prev =\
    \ lst[i]\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad8f305ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad8f2d55561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad8f2d55286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad8f2d5513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad8f2d54bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad8f2b54e83 <unavailable> + 188035

    6    tmprqnjmoat                        0x000055d0fc1b406c <unavailable> + 8300

    7    tmprqnjmoat                        0x000055d0fc1b39d4 <unavailable> + 6612

    8    libc.so.6                          0x00002ad8f324a460 __libc_start_main +
    245

    9    tmprqnjmoat                        0x000055d0fc1b31a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002afa980dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa97dd2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afa97dd2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afa97dd213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afa97dd1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpxxxyn5qn                        0x000055ab352f20f3 <unavailable> + 8435

    6    tmpxxxyn5qn                        0x000055ab352f19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002afa982c7460 __libc_start_main +
    245

    8    tmpxxxyn5qn                        0x000055ab352f11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ i in 1..<lst.count {\n        if lst[i] < prev {\n            return false\n\
    \        }\n        prev = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aeb63431c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeb63128561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aeb63128286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aeb6312813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aeb63127bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aeb62f27e83 <unavailable> + 188035

    6    tmpfg_mhb9h                        0x000055cbfebc0042 <unavailable> + 8258

    7    tmpfg_mhb9h                        0x000055cbfebbf9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002aeb6361d460 __libc_start_main +
    245

    9    tmpfg_mhb9h                        0x000055cbfebbf1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    for\
    \ i in 0..<lst.count - 1 {\n        if lst[i] > lst[i + 1] {\n            sorted\
    \ = false\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ace6c854c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace6c54b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ace6c54b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ace6c54b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ace6c54abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3lv57n76                        0x000055e2934a20ee <unavailable> + 8430

    6    tmp3lv57n76                        0x000055e2934a19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002ace6ca40460 __libc_start_main +
    245

    8    tmp3lv57n76                        0x000055e2934a11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    var current = lst[0]\n    for i in 1..<lst.count\
    \ {\n        if lst[i] < current {\n            return false\n        }\n    \
    \    current = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad7fc3f9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad7fc0f0561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad7fc0f0286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad7fc0f013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad7fc0efbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad7fbeefe83 <unavailable> + 188035

    6    tmprmp9durr                        0x000055e024a5205b <unavailable> + 8283

    7    tmprmp9durr                        0x000055e024a519d4 <unavailable> + 6612

    8    libc.so.6                          0x00002ad7fc5e5460 __libc_start_main +
    245

    9    tmprmp9durr                        0x000055e024a511a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    var prev = lst[0]\n    for i in 1..<lst.count {\n\
    \        if lst[i] < prev {\n            return false\n        }\n        prev\
    \ = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b4f8b798c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4f8b48f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b4f8b48f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b4f8b48f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4f8b48ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b4f8b28ee83 <unavailable> + 188035

    6    tmpvnxjb_eu                        0x0000564a1439405b <unavailable> + 8283

    7    tmpvnxjb_eu                        0x0000564a143939d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b4f8b984460 __libc_start_main +
    245

    9    tmpvnxjb_eu                        0x0000564a143931a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    for\
    \ i in 0..<lst.count - 1 {\n        if lst[i] > lst[i + 1] {\n            sorted\
    \ = false\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ace6c854c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace6c54b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ace6c54b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ace6c54b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ace6c54abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3lv57n76                        0x000055e2934a20ee <unavailable> + 8430

    6    tmp3lv57n76                        0x000055e2934a19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002ace6ca40460 __libc_start_main +
    245

    8    tmp3lv57n76                        0x000055e2934a11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    var prev = lst[0]\n    for i in 1..<lst.count {\n\
    \        if lst[i] < prev {\n            return false\n        }\n        prev\
    \ = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b4f8b798c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4f8b48f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b4f8b48f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b4f8b48f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4f8b48ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b4f8b28ee83 <unavailable> + 188035

    6    tmpvnxjb_eu                        0x0000564a1439405b <unavailable> + 8283

    7    tmpvnxjb_eu                        0x0000564a143939d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b4f8b984460 __libc_start_main +
    245

    9    tmpvnxjb_eu                        0x0000564a143931a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    for\
    \ i in 0..<lst.count-1 {\n        if lst[i] > lst[i+1] {\n            sorted =\
    \ false\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b87e2e48c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b87e2b3f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b87e2b3f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b87e2b3f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b87e2b3ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp2j1tn8nz                        0x000055c54ff9a0ee <unavailable> + 8430

    6    tmp2j1tn8nz                        0x000055c54ff999d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b87e3034460 __libc_start_main +
    245

    8    tmp2j1tn8nz                        0x000055c54ff991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = 0\n    var count = 0\n    for i in lst {\n        if i < prev {\n   \
    \         sorted = false\n        }\n        if i == prev {\n            count\
    \ += 1\n        }\n        prev = i\n    }\n    if count > 1 {\n        sorted\
    \ = false\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpjap8yi7i/tmpjap8yi7i.swift:65: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b32dda86c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b32dd77db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b32dd77d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b32dd77c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjap8yi7i                        0x000055cdf6f56e13 <unavailable> + 7699

    5    libc.so.6                          0x00002b32ddc72460 __libc_start_main +
    245

    6    tmpjap8yi7i                        0x000055cdf6f560d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = 0\n    for i in lst {\n        if i < prev {\n            sorted = false\n\
    \        }\n        prev = i\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp4_o1bawe/tmp4_o1bawe.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b40e816ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b40e7e65b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b40e7e65988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b40e7e647b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4_o1bawe                        0x000055ed75736c2b <unavailable> + 7211

    5    libc.so.6                          0x00002b40e835a460 __libc_start_main +
    245

    6    tmp4_o1bawe                        0x000055ed757360d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002afa980dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa97dd2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afa97dd2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afa97dd213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afa97dd1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpxxxyn5qn                        0x000055ab352f20f3 <unavailable> + 8435

    6    tmpxxxyn5qn                        0x000055ab352f19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002afa982c7460 __libc_start_main +
    245

    8    tmpxxxyn5qn                        0x000055ab352f11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = lst.sorted()\n\
    \    if sorted == lst {\n        return true\n    } else {\n        return false\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpex10_n0k/tmpex10_n0k.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b16630bfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1662db6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1662db6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1662db57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpex10_n0k                        0x0000556437dc8bcb <unavailable> + 7115

    5    libc.so.6                          0x00002b16632ab460 __libc_start_main +
    245

    6    tmpex10_n0k                        0x0000556437dc8079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = lst.sorted()\n\
    \    if sorted == lst {\n        return true\n    } else {\n        return false\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpex10_n0k/tmpex10_n0k.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b16630bfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1662db6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1662db6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1662db57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpex10_n0k                        0x0000556437dc8bcb <unavailable> + 7115

    5    libc.so.6                          0x00002b16632ab460 __libc_start_main +
    245

    6    tmpex10_n0k                        0x0000556437dc8079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ num in lst {\n        if num < prev {\n            return false\n        }\n\
    \        prev = num\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7af8891c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7af8588561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b7af8588286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b7af858813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b7af8587bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b7af8387e83 <unavailable> + 188035

    6    tmp0a55xqsr                        0x000055984cb16fc2 <unavailable> + 8130

    7    tmp0a55xqsr                        0x000055984cb16954 <unavailable> + 6484

    8    libc.so.6                          0x00002b7af8a7d460 __libc_start_main +
    245

    9    tmp0a55xqsr                        0x000055984cb16129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count-1 {\n        if lst[i] >\
    \ lst[i+1] {\n            return false\n        }\n    }\n    return true\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b195974bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1959442561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1959442286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b195944213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1959441bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpw4zb28ar                        0x0000555c65cf50f3 <unavailable> + 8435

    6    tmpw4zb28ar                        0x0000555c65cf49d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b1959937460 __libc_start_main +
    245

    8    tmpw4zb28ar                        0x0000555c65cf41a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002afa980dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa97dd2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afa97dd2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afa97dd213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afa97dd1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpxxxyn5qn                        0x000055ab352f20f3 <unavailable> + 8435

    6    tmpxxxyn5qn                        0x000055ab352f19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002afa982c7460 __libc_start_main +
    245

    8    tmpxxxyn5qn                        0x000055ab352f11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002afa980dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa97dd2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afa97dd2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afa97dd213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afa97dd1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpxxxyn5qn                        0x000055ab352f20f3 <unavailable> + 8435

    6    tmpxxxyn5qn                        0x000055ab352f19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002afa982c7460 __libc_start_main +
    245

    8    tmpxxxyn5qn                        0x000055ab352f11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    for\
    \ i in 0..<lst.count-1 {\n        if lst[i] > lst[i+1] {\n            sorted =\
    \ false\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b87e2e48c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b87e2b3f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b87e2b3f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b87e2b3f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b87e2b3ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp2j1tn8nz                        0x000055c54ff9a0ee <unavailable> + 8430

    6    tmp2j1tn8nz                        0x000055c54ff999d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b87e3034460 __libc_start_main +
    245

    8    tmp2j1tn8nz                        0x000055c54ff991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ i in 1..<lst.count {\n        if lst[i] < prev {\n            return false\n\
    \        }\n        prev = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aeb63431c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeb63128561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aeb63128286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aeb6312813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aeb63127bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aeb62f27e83 <unavailable> + 188035

    6    tmpfg_mhb9h                        0x000055cbfebc0042 <unavailable> + 8258

    7    tmpfg_mhb9h                        0x000055cbfebbf9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002aeb6361d460 __libc_start_main +
    245

    9    tmpfg_mhb9h                        0x000055cbfebbf1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002afa980dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa97dd2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afa97dd2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afa97dd213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afa97dd1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpxxxyn5qn                        0x000055ab352f20f3 <unavailable> + 8435

    6    tmpxxxyn5qn                        0x000055ab352f19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002afa982c7460 __libc_start_main +
    245

    8    tmpxxxyn5qn                        0x000055ab352f11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    for\
    \ i in 0..<lst.count - 1 {\n        if lst[i] > lst[i + 1] {\n            sorted\
    \ = false\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ace6c854c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace6c54b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ace6c54b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ace6c54b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ace6c54abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3lv57n76                        0x000055e2934a20ee <unavailable> + 8430

    6    tmp3lv57n76                        0x000055e2934a19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002ace6ca40460 __libc_start_main +
    245

    8    tmp3lv57n76                        0x000055e2934a11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    for\
    \ i in 0..<lst.count-1 {\n        if lst[i] > lst[i+1] {\n            sorted =\
    \ false\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b87e2e48c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b87e2b3f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b87e2b3f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b87e2b3f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b87e2b3ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp2j1tn8nz                        0x000055c54ff9a0ee <unavailable> + 8430

    6    tmp2j1tn8nz                        0x000055c54ff999d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b87e3034460 __libc_start_main +
    245

    8    tmp2j1tn8nz                        0x000055c54ff991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    for\
    \ i in 0..<lst.count-1 {\n        if lst[i] > lst[i+1] {\n            sorted =\
    \ false\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b87e2e48c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b87e2b3f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b87e2b3f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b87e2b3f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b87e2b3ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp2j1tn8nz                        0x000055c54ff9a0ee <unavailable> + 8430

    6    tmp2j1tn8nz                        0x000055c54ff999d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b87e3034460 __libc_start_main +
    245

    8    tmp2j1tn8nz                        0x000055c54ff991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    for\
    \ i in 0..<lst.count - 1 {\n        if lst[i] > lst[i + 1] {\n            sorted\
    \ = false\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ace6c854c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace6c54b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ace6c54b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ace6c54b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ace6c54abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3lv57n76                        0x000055e2934a20ee <unavailable> + 8430

    6    tmp3lv57n76                        0x000055e2934a19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002ace6ca40460 __libc_start_main +
    245

    8    tmp3lv57n76                        0x000055e2934a11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002afa980dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa97dd2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afa97dd2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afa97dd213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afa97dd1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpxxxyn5qn                        0x000055ab352f20f3 <unavailable> + 8435

    6    tmpxxxyn5qn                        0x000055ab352f19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002afa982c7460 __libc_start_main +
    245

    8    tmpxxxyn5qn                        0x000055ab352f11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    for\
    \ i in 0..<lst.count - 1 {\n        if lst[i] > lst[i + 1] {\n            sorted\
    \ = false\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ace6c854c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace6c54b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ace6c54b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ace6c54b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ace6c54abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3lv57n76                        0x000055e2934a20ee <unavailable> + 8430

    6    tmp3lv57n76                        0x000055e2934a19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002ace6ca40460 __libc_start_main +
    245

    8    tmp3lv57n76                        0x000055e2934a11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ i in 1..<lst.count {\n        if lst[i] < prev {\n            return false\n\
    \        }\n        prev = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aeb63431c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeb63128561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aeb63128286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aeb6312813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aeb63127bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aeb62f27e83 <unavailable> + 188035

    6    tmpfg_mhb9h                        0x000055cbfebc0042 <unavailable> + 8258

    7    tmpfg_mhb9h                        0x000055cbfebbf9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002aeb6361d460 __libc_start_main +
    245

    9    tmpfg_mhb9h                        0x000055cbfebbf1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    for\
    \ i in 0..<lst.count - 1 {\n        if lst[i] > lst[i + 1] {\n            sorted\
    \ = false\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ace6c854c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace6c54b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ace6c54b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ace6c54b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ace6c54abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3lv57n76                        0x000055e2934a20ee <unavailable> + 8430

    6    tmp3lv57n76                        0x000055e2934a19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002ace6ca40460 __libc_start_main +
    245

    8    tmp3lv57n76                        0x000055e2934a11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    // TODO: Implement me!\n\
    \    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmps3xhvubr/tmps3xhvubr.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b40db5c1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b40db2b8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b40db2b8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b40db2b77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps3xhvubr                        0x0000555b71fd42ea <unavailable> + 4842

    5    libc.so.6                          0x00002b40db7ad460 __libc_start_main +
    245

    6    tmps3xhvubr                        0x0000555b71fd3f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count <= 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpfykehlno/tmpfykehlno.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1fb9b12c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1fb9809b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1fb9809988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1fb98087b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfykehlno                        0x000055e0c01e4cfb <unavailable> + 7419

    5    libc.so.6                          0x00002b1fb9cfe460 __libc_start_main +
    245

    6    tmpfykehlno                        0x000055e0c01e41a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    for\
    \ i in 0..<lst.count - 1 {\n        if lst[i] > lst[i + 1] {\n            sorted\
    \ = false\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ace6c854c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace6c54b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ace6c54b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ace6c54b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ace6c54abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3lv57n76                        0x000055e2934a20ee <unavailable> + 8430

    6    tmp3lv57n76                        0x000055e2934a19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002ace6ca40460 __libc_start_main +
    245

    8    tmp3lv57n76                        0x000055e2934a11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count-1 {\n        if lst[i] >\
    \ lst[i+1] {\n            return false\n        }\n    }\n    return true\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b195974bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1959442561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1959442286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b195944213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1959441bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpw4zb28ar                        0x0000555c65cf50f3 <unavailable> + 8435

    6    tmpw4zb28ar                        0x0000555c65cf49d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b1959937460 __libc_start_main +
    245

    8    tmpw4zb28ar                        0x0000555c65cf41a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] <= prev {\n \
    \           sorted = false\n            break\n        }\n        prev = lst[i]\n\
    \    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aee6a3a7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aee6a09e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aee6a09e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aee6a09e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aee6a09dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aee69e9de83 <unavailable> + 188035

    6    tmp91h05hug                        0x00005647a5845056 <unavailable> + 8278

    7    tmp91h05hug                        0x00005647a58449d4 <unavailable> + 6612

    8    libc.so.6                          0x00002aee6a593460 __libc_start_main +
    245

    9    tmp91h05hug                        0x00005647a58441a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002afa980dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa97dd2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afa97dd2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afa97dd213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afa97dd1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpxxxyn5qn                        0x000055ab352f20f3 <unavailable> + 8435

    6    tmpxxxyn5qn                        0x000055ab352f19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002afa982c7460 __libc_start_main +
    245

    8    tmpxxxyn5qn                        0x000055ab352f11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ i in 1..<lst.count {\n        if lst[i] < prev {\n            return false\n\
    \        }\n        prev = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aeb63431c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeb63128561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aeb63128286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aeb6312813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aeb63127bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aeb62f27e83 <unavailable> + 188035

    6    tmpfg_mhb9h                        0x000055cbfebc0042 <unavailable> + 8258

    7    tmpfg_mhb9h                        0x000055cbfebbf9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002aeb6361d460 __libc_start_main +
    245

    9    tmpfg_mhb9h                        0x000055cbfebbf1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ >= lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ba585a28c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba58571f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ba58571f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ba58571f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ba58571ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpjkima892                        0x0000563f460b90f3 <unavailable> + 8435

    6    tmpjkima892                        0x0000563f460b89d4 <unavailable> + 6612

    7    libc.so.6                          0x00002ba585c14460 __libc_start_main +
    245

    8    tmpjkima892                        0x0000563f460b81a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for num in lst {\n        if num < prev {\n            sorted\
    \ = false\n        }\n        prev = num\n    }\n    return sorted\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b36f732bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b36f7022561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b36f7022286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b36f702213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b36f7021bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b36f6e21e83 <unavailable> + 188035

    6    tmpbhyastnx                        0x000055dd3b875fd6 <unavailable> + 8150

    7    tmpbhyastnx                        0x000055dd3b875954 <unavailable> + 6484

    8    libc.so.6                          0x00002b36f7517460 __libc_start_main +
    245

    9    tmpbhyastnx                        0x000055dd3b875129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ i in 1..<lst.count {\n        if lst[i] < prev {\n            return false\n\
    \        }\n        prev = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aeb63431c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeb63128561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aeb63128286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aeb6312813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aeb63127bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aeb62f27e83 <unavailable> + 188035

    6    tmpfg_mhb9h                        0x000055cbfebc0042 <unavailable> + 8258

    7    tmpfg_mhb9h                        0x000055cbfebbf9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002aeb6361d460 __libc_start_main +
    245

    9    tmpfg_mhb9h                        0x000055cbfebbf1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ previous = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < previous\
    \ {\n            sorted = false\n        }\n        previous = lst[i]\n    }\n\
    \    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acdd8845c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acdd853c561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acdd853c286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acdd853c13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acdd853bbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acdd833be83 <unavailable> + 188035

    6    tmp0vt2toem                        0x0000557c8c9b9056 <unavailable> + 8278

    7    tmp0vt2toem                        0x0000557c8c9b89d4 <unavailable> + 6612

    8    libc.so.6                          0x00002acdd8a31460 __libc_start_main +
    245

    9    tmp0vt2toem                        0x0000557c8c9b81a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    var i = 0\n    while i < lst.count - 1 {\n     \
    \   if lst[i] > lst[i + 1] {\n            return false\n        }\n        i +=\
    \ 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp7v3kyu80/tmp7v3kyu80.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d13598c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d1328fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9d1328f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9d1328e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7v3kyu80                        0x000055bd54059b6b <unavailable> + 7019

    5    libc.so.6                          0x00002b9d13784460 __libc_start_main +
    245

    6    tmp7v3kyu80                        0x000055bd54059019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002afa980dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa97dd2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afa97dd2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afa97dd213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afa97dd1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpxxxyn5qn                        0x000055ab352f20f3 <unavailable> + 8435

    6    tmpxxxyn5qn                        0x000055ab352f19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002afa982c7460 __libc_start_main +
    245

    8    tmpxxxyn5qn                        0x000055ab352f11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002afa980dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa97dd2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afa97dd2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afa97dd213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afa97dd1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpxxxyn5qn                        0x000055ab352f20f3 <unavailable> + 8435

    6    tmpxxxyn5qn                        0x000055ab352f19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002afa982c7460 __libc_start_main +
    245

    8    tmpxxxyn5qn                        0x000055ab352f11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002afa980dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa97dd2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afa97dd2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afa97dd213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afa97dd1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpxxxyn5qn                        0x000055ab352f20f3 <unavailable> + 8435

    6    tmpxxxyn5qn                        0x000055ab352f19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002afa982c7460 __libc_start_main +
    245

    8    tmpxxxyn5qn                        0x000055ab352f11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002afa980dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa97dd2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afa97dd2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afa97dd213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afa97dd1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpxxxyn5qn                        0x000055ab352f20f3 <unavailable> + 8435

    6    tmpxxxyn5qn                        0x000055ab352f19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002afa982c7460 __libc_start_main +
    245

    8    tmpxxxyn5qn                        0x000055ab352f11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ i = 0\n    while i < lst.count - 1 {\n        if lst[i] > lst[i + 1] {\n   \
    \         sorted = false\n        }\n        i += 1\n    }\n    return sorted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp56li8_ay/tmp56li8_ay.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b01f1ef3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b01f1beab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b01f1bea988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b01f1be97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp56li8_ay                        0x000055b92cbbab6b <unavailable> + 7019

    5    libc.so.6                          0x00002b01f20df460 __libc_start_main +
    245

    6    tmp56li8_ay                        0x000055b92cbba019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    for\
    \ i in 0..<lst.count-1 {\n        if lst[i] > lst[i+1] {\n            sorted =\
    \ false\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b87e2e48c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b87e2b3f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b87e2b3f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b87e2b3f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b87e2b3ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp2j1tn8nz                        0x000055c54ff9a0ee <unavailable> + 8430

    6    tmp2j1tn8nz                        0x000055c54ff999d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b87e3034460 __libc_start_main +
    245

    8    tmp2j1tn8nz                        0x000055c54ff991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ i = 0\n    while i < lst.count - 1 {\n        if lst[i] > lst[i + 1] {\n   \
    \         sorted = false\n        }\n        i += 1\n    }\n    return sorted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp56li8_ay/tmp56li8_ay.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b01f1ef3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b01f1beab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b01f1bea988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b01f1be97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp56li8_ay                        0x000055b92cbbab6b <unavailable> + 7019

    5    libc.so.6                          0x00002b01f20df460 __libc_start_main +
    245

    6    tmp56li8_ay                        0x000055b92cbba019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002afa980dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa97dd2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afa97dd2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afa97dd213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afa97dd1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpxxxyn5qn                        0x000055ab352f20f3 <unavailable> + 8435

    6    tmpxxxyn5qn                        0x000055ab352f19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002afa982c7460 __libc_start_main +
    245

    8    tmpxxxyn5qn                        0x000055ab352f11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002afa980dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa97dd2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afa97dd2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afa97dd213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afa97dd1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpxxxyn5qn                        0x000055ab352f20f3 <unavailable> + 8435

    6    tmpxxxyn5qn                        0x000055ab352f19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002afa982c7460 __libc_start_main +
    245

    8    tmpxxxyn5qn                        0x000055ab352f11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    var count = 0\n    for i in lst {\n        if i < prev {\n\
    \            sorted = false\n        }\n        if i == prev {\n            count\
    \ += 1\n        }\n        prev = i\n    }\n    if count > 1 {\n        sorted\
    \ = false\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b98d4136c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b98d3e2d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b98d3e2d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b98d3e2d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b98d3e2cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b98d3c2ce83 <unavailable> + 188035

    6    tmpj58558tf                        0x000055c93df0ffe6 <unavailable> + 8166

    7    tmpj58558tf                        0x000055c93df0f954 <unavailable> + 6484

    8    libc.so.6                          0x00002b98d4322460 __libc_start_main +
    245

    9    tmpj58558tf                        0x000055c93df0f129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002afa980dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa97dd2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afa97dd2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afa97dd213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afa97dd1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpxxxyn5qn                        0x000055ab352f20f3 <unavailable> + 8435

    6    tmpxxxyn5qn                        0x000055ab352f19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002afa982c7460 __libc_start_main +
    245

    8    tmpxxxyn5qn                        0x000055ab352f11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    for\
    \ i in 0..<lst.count - 1 {\n        if lst[i] > lst[i + 1] {\n            sorted\
    \ = false\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ace6c854c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace6c54b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ace6c54b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ace6c54b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ace6c54abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3lv57n76                        0x000055e2934a20ee <unavailable> + 8430

    6    tmp3lv57n76                        0x000055e2934a19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002ace6ca40460 __libc_start_main +
    245

    8    tmp3lv57n76                        0x000055e2934a11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count-1 {\n        if lst[i] >\
    \ lst[i+1] {\n            return false\n        }\n    }\n    return true\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b195974bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1959442561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1959442286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b195944213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1959441bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpw4zb28ar                        0x0000555c65cf50f3 <unavailable> + 8435

    6    tmpw4zb28ar                        0x0000555c65cf49d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b1959937460 __libc_start_main +
    245

    8    tmpw4zb28ar                        0x0000555c65cf41a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = lst.sorted()\n\
    \    return sorted == lst\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp1pbgptgw/tmp1pbgptgw.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abd509fac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abd506f1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abd506f1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abd506f07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1pbgptgw                        0x000056523bab6bcb <unavailable> + 7115

    5    libc.so.6                          0x00002abd50be6460 __libc_start_main +
    245

    6    tmp1pbgptgw                        0x000056523bab6079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    for\
    \ i in 0..<lst.count - 1 {\n        if lst[i] > lst[i + 1] {\n            sorted\
    \ = false\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ace6c854c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace6c54b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ace6c54b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ace6c54b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ace6c54abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3lv57n76                        0x000055e2934a20ee <unavailable> + 8430

    6    tmp3lv57n76                        0x000055e2934a19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002ace6ca40460 __libc_start_main +
    245

    8    tmp3lv57n76                        0x000055e2934a11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    var prev = lst[0]\n    for i in 1..<lst.count {\n\
    \        if lst[i] < prev {\n            return false\n        }\n        prev\
    \ = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b4f8b798c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4f8b48f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b4f8b48f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b4f8b48f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4f8b48ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b4f8b28ee83 <unavailable> + 188035

    6    tmpvnxjb_eu                        0x0000564a1439405b <unavailable> + 8283

    7    tmpvnxjb_eu                        0x0000564a143939d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b4f8b984460 __libc_start_main +
    245

    9    tmpvnxjb_eu                        0x0000564a143931a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count <= 1 {\n   \
    \     return true\n    }\n    var prev = lst[0]\n    for i in 1..<lst.count {\n\
    \        if lst[i] < prev {\n            return false\n        }\n        prev\
    \ = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpe2wtl3d8/tmpe2wtl3d8.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6c27dc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6c27ab9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6c27ab9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6c27ab87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe2wtl3d8                        0x0000560d35fd5cfb <unavailable> + 7419

    5    libc.so.6                          0x00002b6c27fae460 __libc_start_main +
    245

    6    tmpe2wtl3d8                        0x0000560d35fd51a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002afa980dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa97dd2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afa97dd2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afa97dd213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afa97dd1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpxxxyn5qn                        0x000055ab352f20f3 <unavailable> + 8435

    6    tmpxxxyn5qn                        0x000055ab352f19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002afa982c7460 __libc_start_main +
    245

    8    tmpxxxyn5qn                        0x000055ab352f11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    for\
    \ i in 0..<lst.count - 1 {\n        if lst[i] > lst[i + 1] {\n            sorted\
    \ = false\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ace6c854c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace6c54b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ace6c54b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ace6c54b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ace6c54abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3lv57n76                        0x000055e2934a20ee <unavailable> + 8430

    6    tmp3lv57n76                        0x000055e2934a19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002ace6ca40460 __libc_start_main +
    245

    8    tmp3lv57n76                        0x000055e2934a11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    var prev = lst[0]\n    for i in 1..<lst.count {\n\
    \        if lst[i] < prev {\n            return false\n        }\n        prev\
    \ = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b4f8b798c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4f8b48f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b4f8b48f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b4f8b48f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4f8b48ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b4f8b28ee83 <unavailable> + 188035

    6    tmpvnxjb_eu                        0x0000564a1439405b <unavailable> + 8283

    7    tmpvnxjb_eu                        0x0000564a143939d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b4f8b984460 __libc_start_main +
    245

    9    tmpvnxjb_eu                        0x0000564a143931a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    var prev = lst[0]\n    for i in 1..<lst.count {\n\
    \        if lst[i] < prev {\n            return false\n        }\n        prev\
    \ = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b4f8b798c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4f8b48f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b4f8b48f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b4f8b48f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4f8b48ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b4f8b28ee83 <unavailable> + 188035

    6    tmpvnxjb_eu                        0x0000564a1439405b <unavailable> + 8283

    7    tmpvnxjb_eu                        0x0000564a143939d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b4f8b984460 __libc_start_main +
    245

    9    tmpvnxjb_eu                        0x0000564a143931a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    for\
    \ i in 0..<lst.count - 1 {\n        if lst[i] > lst[i + 1] {\n            sorted\
    \ = false\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ace6c854c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace6c54b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ace6c54b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ace6c54b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ace6c54abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3lv57n76                        0x000055e2934a20ee <unavailable> + 8430

    6    tmp3lv57n76                        0x000055e2934a19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002ace6ca40460 __libc_start_main +
    245

    8    tmp3lv57n76                        0x000055e2934a11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ last = lst[0]\n    for num in lst {\n        if num < last {\n            sorted\
    \ = false\n        }\n        last = num\n    }\n    return sorted\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b578739ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5787095561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b5787095286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b578709513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b5787094bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b5786e94e83 <unavailable> + 188035

    6    tmp7t53bnqc                        0x000055fb3f657fd6 <unavailable> + 8150

    7    tmp7t53bnqc                        0x000055fb3f657954 <unavailable> + 6484

    8    libc.so.6                          0x00002b578758a460 __libc_start_main +
    245

    9    tmp7t53bnqc                        0x000055fb3f657129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f53e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f53b95561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f53b95286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f53b9513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f53b94bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f53994e83 <unavailable> + 188035

    6    tmpxw1it7dp                        0x000055d47d69a056 <unavailable> + 8278

    7    tmpxw1it7dp                        0x000055d47d6999d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b0f5408a460 __libc_start_main +
    245

    9    tmpxw1it7dp                        0x000055d47d6991a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = lst.sorted()\n\
    \    return sorted == lst\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp1pbgptgw/tmp1pbgptgw.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abd509fac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abd506f1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abd506f1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abd506f07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1pbgptgw                        0x000056523bab6bcb <unavailable> + 7115

    5    libc.so.6                          0x00002abd50be6460 __libc_start_main +
    245

    6    tmp1pbgptgw                        0x000056523bab6079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660013650
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    for\
    \ i in 0..<lst.count - 1 {\n        if lst[i] > lst[i + 1] {\n            sorted\
    \ = false\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ace6c854c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace6c54b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ace6c54b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ace6c54b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ace6c54abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3lv57n76                        0x000055e2934a20ee <unavailable> + 8430

    6    tmp3lv57n76                        0x000055e2934a19d4 <unavailable> + 6612

    7    libc.so.6                          0x00002ace6ca40460 __libc_start_main +
    245

    8    tmp3lv57n76                        0x000055e2934a11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013650
