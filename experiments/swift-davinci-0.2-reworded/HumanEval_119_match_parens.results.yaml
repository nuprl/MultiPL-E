language: swift
name: HumanEval_119_match_parens
results:
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var s = \"\"\n    for i in 0..<lst.count {\n        s += lst[i]\n    }\n\
    \    var cnt = 0\n    for c in s {\n        if c == \"(\" {\n            cnt +=\
    \ 1\n        } else {\n            cnt -= 1\n        }\n        if cnt < 0 {\n\
    \            return \"No\"\n        }\n    }\n    return cnt == 0 ? \"Yes\" :\
    \ \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpsluypozg/tmpsluypozg.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e7c5c5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e7c2bcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9e7c2bc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9e7c2bb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsluypozg                        0x000055687acc1d56 <unavailable> + 7510

    5    libc.so.6                          0x00002b9e7c7b1460 __libc_start_main +
    245

    6    tmpsluypozg                        0x000055687acc14b9 <unavailable> + 5305

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst.joined()\n\
    \    var count = 0\n    for char in lst {\n        if char == \"(\" {\n      \
    \      count += 1\n        } else {\n            count -= 1\n        }\n     \
    \   if count < 0 {\n            return \"No\"\n        }\n    }\n    return count\
    \ == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp9n1fcpmz/tmp9n1fcpmz.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad8eaba1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad8ea898b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad8ea898988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad8ea8977b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9n1fcpmz                        0x000055be50c19b76 <unavailable> + 7030

    5    libc.so.6                          0x00002ad8ead8d460 __libc_start_main +
    245

    6    tmp9n1fcpmz                        0x000055be50c192d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = lst[0]\
    \ + lst[1]\n    var count = 0\n    for char in str {\n        if char == \"(\"\
    \ {\n            count += 1\n        } else {\n            count -= 1\n      \
    \  }\n        if count < 0 {\n            return \"No\"\n        }\n    }\n  \
    \  return count == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpxyafuqqj/tmpxyafuqqj.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae4e0dccc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae4e0ac3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae4e0ac3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae4e0ac27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxyafuqqj                        0x0000560234617b76 <unavailable> + 7030

    5    libc.so.6                          0x00002ae4e0fb8460 __libc_start_main +
    245

    6    tmpxyafuqqj                        0x00005602346172d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var lst1 = lst[0]\n    var lst2 = lst[1]\n    var lst3 = lst1 + lst2\n  \
    \  var lst4 = lst2 + lst1\n    var lst5 = lst3.replacingOccurrences(of: \"()\"\
    , with: \"\")\n    var lst6 = lst4.replacingOccurrences(of: \"()\", with: \"\"\
    )\n    if lst5 == \"\" {\n        return \"Yes\"\n    } else if lst6 == \"\" {\n\
    \        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp9bzvi33p.swift:21:21: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n    var lst5 = lst3.replacingOccurrences(of: \"()\"\
    , with: \"\")\n               ~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp9bzvi33p.swift:22:21:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n    var\
    \ lst6 = lst4.replacingOccurrences(of: \"()\", with: \"\")\n               ~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var lst1 = lst[0]\n    var lst2 = lst[1]\n    var lst3 = lst1 + lst2\n  \
    \  var lst4 = lst2 + lst1\n    var lst5 = lst1 + lst1\n    var lst6 = lst2 + lst2\n\
    \    var lst7 = lst1 + lst2 + lst1\n    var lst8 = lst2 + lst1 + lst2\n    var\
    \ lst9 = lst1 + lst2 + lst2\n    var lst10 = lst2 + lst1 + lst1\n    var lst11\
    \ = lst1 + lst1 + lst2\n    var lst12 = lst2 + lst2 + lst1\n    var lst13 = lst1\
    \ + lst2 + lst1 + lst2\n    var lst14 = lst2 + lst1 + lst2 + lst1\n    var lst15\
    \ = lst1 + lst2 + lst2 + lst1\n    var lst16 = lst2 + lst1 + lst1 + lst2\n   \
    \ var lst17 = lst1 + lst1 + lst2 + lst2\n    var lst18 = lst2 + lst2 + lst1 +\
    \ lst1\n    var lst19 = lst1 + lst1 + lst1 + lst2\n    var lst20 = lst2 + lst2\
    \ + lst2 + lst1\n    var lst21 = lst1 + lst2 + lst1 + lst1\n    var lst22 = lst2\
    \ + lst1 + lst2 + lst2\n    var lst23 = lst1 + lst2 + lst2 + lst2\n    var lst24\
    \ = lst2 + lst1 + lst1 + lst1\n    var lst25 = lst1 + lst1 + lst2 + lst1\n   \
    \ var lst26 = lst2 + lst2 + lst1 + lst2\n    var lst27 = l\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpwz1nm3rp.swift:43:17: error: cannot find 'l' in scope\n    var\
    \ lst27 = l\n                ^\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var count = 0\n    for i in 0..<lst.count {\n       \
    \ str += lst[i]\n    }\n    for i in 0..<str.count {\n        if str[i] == \"\
    (\" {\n            count += 1\n        } else {\n            count -= 1\n    \
    \    }\n        if count < 0 {\n            return \"No\"\n        }\n    }\n\
    \    if count == 0 {\n        return \"Yes\"\n    } else {\n        return \"\
    No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmplkxfsp_6.swift:23:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if str[i]\
    \ == \"(\" {\n           ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmplkxfsp_6.swift:16:9: warning: variable 'lst'\
    \ was never mutated; consider changing to 'let' constant\n    var lst = lst\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = lst[0]\
    \ + lst[1]\n    var count = 0\n    for c in str {\n        if c == \"(\" {\n \
    \           count += 1\n        } else {\n            count -= 1\n        }\n\
    \        if count < 0 {\n            return \"No\"\n        }\n    }\n    return\
    \ count == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpc9g02w8d/tmpc9g02w8d.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b89356d4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b89353cbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b89353cb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b89353ca7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc9g02w8d                        0x0000563f0c606b76 <unavailable> + 7030

    5    libc.so.6                          0x00002b89358c0460 __libc_start_main +
    245

    6    tmpc9g02w8d                        0x0000563f0c6062d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    for i in 0..<lst.count {\n        str += lst[i]\n   \
    \ }\n    var count = 0\n    for i in 0..<str.count {\n        if str[i] == \"\
    (\" {\n            count += 1\n        } else {\n            count -= 1\n    \
    \    }\n        if count < 0 {\n            return \"No\"\n        }\n    }\n\
    \    if count == 0 {\n        return \"Yes\"\n    } else {\n        return \"\
    No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpqjsyulbz.swift:23:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if str[i]\
    \ == \"(\" {\n           ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpqjsyulbz.swift:16:9: warning: variable 'lst'\
    \ was never mutated; consider changing to 'let' constant\n    var lst = lst\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack<Character>()\n\
    \    for char in lst[0] {\n        if char == \"(\" {\n            stack.push(char)\n\
    \        } else {\n            if stack.isEmpty() {\n                return \"\
    No\"\n            }\n            stack.pop()\n        }\n    }\n    for char in\
    \ lst[1] {\n        if char == \"(\" {\n            if stack.isEmpty() {\n   \
    \             return \"No\"\n            }\n            stack.pop()\n        }\
    \ else {\n            stack.push(char)\n        }\n    }\n    return stack.isEmpty()\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpv72ksz2x.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    for i in 0..<lst.count {\n        str += lst[i]\n   \
    \ }\n    var count = 0\n    for i in 0..<str.count {\n        if str[i] == \"\
    (\" {\n            count += 1\n        } else {\n            count -= 1\n    \
    \    }\n        if count < 0 {\n            return \"No\"\n        }\n    }\n\
    \    if count == 0 {\n        return \"Yes\"\n    } else {\n        return \"\
    No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpqjsyulbz.swift:23:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if str[i]\
    \ == \"(\" {\n           ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpqjsyulbz.swift:16:9: warning: variable 'lst'\
    \ was never mutated; consider changing to 'let' constant\n    var lst = lst\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = lst[0] +\
    \ lst[1]\n    var cnt = 0\n    for c in s {\n        if c == \"(\" {\n       \
    \     cnt += 1\n        } else {\n            cnt -= 1\n        }\n        if\
    \ cnt < 0 {\n            return \"No\"\n        }\n    }\n    return cnt == 0\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpnr682cc7/tmpnr682cc7.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acd153c5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acd150bcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acd150bc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acd150bb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnr682cc7                        0x0000560142999b76 <unavailable> + 7030

    5    libc.so.6                          0x00002acd155b1460 __libc_start_main +
    245

    6    tmpnr682cc7                        0x00005601429992d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = lst[0]\
    \ + lst[1]\n    var count = 0\n    for char in str {\n        if char == \"(\"\
    \ {\n            count += 1\n        } else {\n            count -= 1\n      \
    \  }\n        if count < 0 {\n            return \"No\"\n        }\n    }\n  \
    \  return count == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpxyafuqqj/tmpxyafuqqj.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae4e0dccc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae4e0ac3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae4e0ac3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae4e0ac27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxyafuqqj                        0x0000560234617b76 <unavailable> + 7030

    5    libc.so.6                          0x00002ae4e0fb8460 __libc_start_main +
    245

    6    tmpxyafuqqj                        0x00005602346172d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    while lst.count > 0 {\n        str += lst.removeFirst()\n\
    \        if !is_good(str: str) {\n            str = \"\"\n        }\n    }\n \
    \   return is_good(str: str) ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpekc4_1hq.swift:20:13: error: cannot find 'is_good' in scope\n \
    \       if !is_good(str: str) {\n            ^~~~~~~\n/tmp/tmpekc4_1hq.swift:24:12:\
    \ error: cannot find 'is_good' in scope\n    return is_good(str: str) ? \"Yes\"\
    \ : \"No\"\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack<Character>()\n\
    \    for char in lst[0] {\n        if char == \"(\" {\n            stack.push(char)\n\
    \        } else {\n            if stack.isEmpty() {\n                return \"\
    No\"\n            }\n            stack.pop()\n        }\n    }\n    for char in\
    \ lst[1] {\n        if char == \"(\" {\n            if stack.isEmpty() {\n   \
    \             return \"No\"\n            }\n            stack.pop()\n        }\
    \ else {\n            stack.push(char)\n        }\n    }\n    return stack.isEmpty()\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpv72ksz2x.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var lst1 = lst[0]\n    var lst2 = lst[1]\n    var lst3 = lst1 + lst2\n  \
    \  var lst4 = lst2 + lst1\n    var lst5 = lst3.replacingOccurrences(of: \"()\"\
    , with: \"\")\n    var lst6 = lst4.replacingOccurrences(of: \"()\", with: \"\"\
    )\n    if lst5 == \"\" {\n        return \"Yes\"\n    } else if lst6 == \"\" {\n\
    \        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp9bzvi33p.swift:21:21: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n    var lst5 = lst3.replacingOccurrences(of: \"()\"\
    , with: \"\")\n               ~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp9bzvi33p.swift:22:21:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n    var\
    \ lst6 = lst4.replacingOccurrences(of: \"()\", with: \"\")\n               ~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack<Character>()\n\
    \    for char in lst[0] {\n        if char == \"(\" {\n            stack.push(char)\n\
    \        } else {\n            if stack.isEmpty() {\n                return \"\
    No\"\n            }\n            stack.pop()\n        }\n    }\n    for char in\
    \ lst[1] {\n        if char == \"(\" {\n            if stack.isEmpty() {\n   \
    \             return \"No\"\n            }\n            stack.pop()\n        }\
    \ else {\n            stack.push(char)\n        }\n    }\n    return stack.isEmpty()\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpv72ksz2x.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0]\n\
    \    let str2 = lst[1]\n    let str = str1 + str2\n    var count = 0\n    for\
    \ char in str {\n        if char == \"(\" {\n            count += 1\n        }\
    \ else {\n            count -= 1\n        }\n        if count < 0 {\n        \
    \    return \"No\"\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp_veymc37/tmp_veymc37.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad1d84fcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad1d81f3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad1d81f3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad1d81f27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_veymc37                        0x000055922289cb76 <unavailable> + 7030

    5    libc.so.6                          0x00002ad1d86e8460 __libc_start_main +
    245

    6    tmp_veymc37                        0x000055922289c2d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    while lst.count > 0 {\n        str += lst.removeFirst()\n\
    \        if !is_good(str: str) {\n            str = \"\"\n        }\n    }\n \
    \   return is_good(str: str) ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpekc4_1hq.swift:20:13: error: cannot find 'is_good' in scope\n \
    \       if !is_good(str: str) {\n            ^~~~~~~\n/tmp/tmpekc4_1hq.swift:24:12:\
    \ error: cannot find 'is_good' in scope\n    return is_good(str: str) ? \"Yes\"\
    \ : \"No\"\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    for i in 0..<lst.count {\n        if i == 0 {\n     \
    \       str = lst[i]\n        } else {\n            str += lst[i]\n        }\n\
    \    }\n    var count = 0\n    for char in str {\n        if char == \"(\" {\n\
    \            count += 1\n        } else if char == \")\" {\n            count\
    \ -= 1\n        }\n        if count < 0 {\n            return \"No\"\n       \
    \ }\n    }\n    if count == 0 {\n        return \"Yes\"\n    } else {\n      \
    \  return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmple6zv70i/tmple6zv70i.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002affcfa4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002affcf741b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002affcf741988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002affcf7407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmple6zv70i                        0x000056028ed38d56 <unavailable> + 7510

    5    libc.so.6                          0x00002affcfc36460 __libc_start_main +
    245

    6    tmple6zv70i                        0x000056028ed384b9 <unavailable> + 5305

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for str in lst {\n        s += str\n    }\n    var count = 0\n    for c in\
    \ s {\n        if c == \"(\" {\n            count += 1\n        } else {\n   \
    \         count -= 1\n        }\n        if count < 0 {\n            return \"\
    No\"\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpux5pawhz/tmpux5pawhz.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b41ed8f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b41ed5eeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b41ed5ee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b41ed5ed7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpux5pawhz                        0x000055dc7a75cc96 <unavailable> + 7318

    5    libc.so.6                          0x00002b41edae3460 __libc_start_main +
    245

    6    tmpux5pawhz                        0x000055dc7a75c3f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var count = 0\n    while lst.count > 0 {\n        str\
    \ += lst.removeFirst()\n        for char in str {\n            if char == \"(\"\
    \ {\n                count += 1\n            } else {\n                count -=\
    \ 1\n            }\n            if count < 0 {\n                return \"No\"\n\
    \            }\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpgeai9_pn/tmpgeai9_pn.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3dc93ebc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3dc90e2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3dc90e2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3dc90e17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgeai9_pn                        0x0000561230e007a6 <unavailable> + 6054

    5    libc.so.6                          0x00002b3dc95d7460 __libc_start_main +
    245

    6    tmpgeai9_pn                        0x0000561230e00389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var count = 0\n    for i in 0..<lst.count {\n       \
    \ str += lst[i]\n    }\n    for i in 0..<str.count {\n        if str[i] == \"\
    (\" {\n            count += 1\n        } else {\n            count -= 1\n    \
    \    }\n        if count < 0 {\n            return \"No\"\n        }\n    }\n\
    \    if count == 0 {\n        return \"Yes\"\n    } else {\n        return \"\
    No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmplkxfsp_6.swift:23:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if str[i]\
    \ == \"(\" {\n           ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmplkxfsp_6.swift:16:9: warning: variable 'lst'\
    \ was never mutated; consider changing to 'let' constant\n    var lst = lst\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var count = 0\n    while lst.count > 0 {\n        str\
    \ += lst.removeFirst()\n        for char in str {\n            if char == \"(\"\
    \ {\n                count += 1\n            } else {\n                count -=\
    \ 1\n            }\n            if count < 0 {\n                return \"No\"\n\
    \            }\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpgeai9_pn/tmpgeai9_pn.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3dc93ebc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3dc90e2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3dc90e2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3dc90e17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgeai9_pn                        0x0000561230e007a6 <unavailable> + 6054

    5    libc.so.6                          0x00002b3dc95d7460 __libc_start_main +
    245

    6    tmpgeai9_pn                        0x0000561230e00389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    for i in 0..<lst.count {\n        str += lst[i]\n   \
    \ }\n    var stack = [Character]()\n    for c in str {\n        if c == \"(\"\
    \ {\n            stack.append(c)\n        } else {\n            if stack.isEmpty\
    \ {\n                return \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    if stack.isEmpty {\n        return \"Yes\"\
    \n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpr8k9hr4h/tmpr8k9hr4h.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b05f5ddcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b05f5ad3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b05f5ad3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b05f5ad27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr8k9hr4h                        0x000055794367ef86 <unavailable> + 8070

    5    libc.so.6                          0x00002b05f5fc8460 __libc_start_main +
    245

    6    tmpr8k9hr4h                        0x000055794367e6e9 <unavailable> + 5865

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [Character]()\n\
    \    var str = \"\"\n    for s in lst {\n        str += s\n    }\n    for c in\
    \ str {\n        if c == \"(\" {\n            stack.append(c)\n        } else\
    \ {\n            if stack.count == 0 {\n                return \"No\"\n      \
    \      }\n            stack.removeLast()\n        }\n    }\n    if stack.count\
    \ == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp_aejk04g/tmp_aejk04g.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b876487bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8764572b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8764572988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b87645717b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_aejk04g                        0x000055de426f5e76 <unavailable> + 7798

    5    libc.so.6                          0x00002b8764a67460 __libc_start_main +
    245

    6    tmp_aejk04g                        0x000055de426f55d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    for i in 0..<lst.count {\n        str += lst[i]\n   \
    \ }\n    var stack = [Character]()\n    for c in str {\n        if c == \"(\"\
    \ {\n            stack.append(c)\n        } else {\n            if stack.count\
    \ == 0 {\n                return \"No\"\n            } else {\n              \
    \  stack.removeLast()\n            }\n        }\n    }\n    if stack.count ==\
    \ 0 {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpgq4kl0f2/tmpgq4kl0f2.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1de64f2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1de61e9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1de61e9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1de61e87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgq4kl0f2                        0x000055980c8adf46 <unavailable> + 8006

    5    libc.so.6                          0x00002b1de66de460 __libc_start_main +
    245

    6    tmpgq4kl0f2                        0x000055980c8ad6a9 <unavailable> + 5801

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = lst[0]\
    \ + lst[1]\n    var stack = [Character]()\n    for char in str {\n        if char\
    \ == \"(\" {\n            stack.append(char)\n        } else {\n            if\
    \ stack.count == 0 {\n                return \"No\"\n            }\n         \
    \   stack.removeLast()\n        }\n    }\n    return stack.count == 0 ? \"Yes\"\
    \ : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpkpbdsobc/tmpkpbdsobc.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae5a8392c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae5a8089b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae5a8089988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae5a80887b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkpbdsobc                        0x0000564f11cc3d66 <unavailable> + 7526

    5    libc.so.6                          0x00002ae5a857e460 __libc_start_main +
    245

    6    tmpkpbdsobc                        0x0000564f11cc34c9 <unavailable> + 5321

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let s1 = lst[0]\n\
    \    let s2 = lst[1]\n    let s = s1 + s2\n    var stack = Stack<Character>()\n\
    \    for c in s {\n        if c == \"(\" {\n            stack.push(c)\n      \
    \  } else {\n            if stack.isEmpty() {\n                return \"No\"\n\
    \            }\n            stack.pop()\n        }\n    }\n    return stack.isEmpty()\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpqa310eg8.swift:19:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var open = 0\n \
    \   var close = 0\n    for char in lst[0] {\n        if char == \"(\" {\n    \
    \        open += 1\n        } else {\n            close += 1\n        }\n    }\n\
    \    for char in lst[1] {\n        if char == \"(\" {\n            open += 1\n\
    \        } else {\n            close += 1\n        }\n    }\n    if open == close\
    \ {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpyyy95a03/tmpyyy95a03.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4c56d49c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4c56a40b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4c56a40988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4c56a3f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyyy95a03                        0x000055e056c94468 <unavailable> + 9320

    5    libc.so.6                          0x00002b4c56f35460 __libc_start_main +
    245

    6    tmpyyy95a03                        0x000055e056c93289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = lst[0]\
    \ + lst[1]\n    var count = 0\n    for c in str {\n        if c == \"(\" {\n \
    \           count += 1\n        } else {\n            count -= 1\n        }\n\
    \        if count < 0 {\n            return \"No\"\n        }\n    }\n    return\
    \ count == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpc9g02w8d/tmpc9g02w8d.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b89356d4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b89353cbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b89353cb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b89353ca7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc9g02w8d                        0x0000563f0c606b76 <unavailable> + 7030

    5    libc.so.6                          0x00002b89358c0460 __libc_start_main +
    245

    6    tmpc9g02w8d                        0x0000563f0c6062d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lhs = lst[0]\n\
    \    var rhs = lst[1]\n    var lhs_open = 0\n    var rhs_open = 0\n    for c in\
    \ lhs {\n        if c == \"(\" {\n            lhs_open += 1\n        } else {\n\
    \            lhs_open -= 1\n        }\n    }\n    for c in rhs {\n        if c\
    \ == \"(\" {\n            rhs_open += 1\n        } else {\n            rhs_open\
    \ -= 1\n        }\n    }\n    if lhs_open == 0 && rhs_open == 0 {\n        return\
    \ \"Yes\"\n    }\n    if lhs_open == 0 && rhs_open != 0 {\n        return \"No\"\
    \n    }\n    if lhs_open != 0 && rhs_open == 0 {\n        return \"No\"\n    }\n\
    \    if lhs_open > 0 && rhs_open < 0 {\n        return \"No\"\n    }\n    if lhs_open\
    \ < 0 && rhs_open > 0 {\n        return \"No\"\n    }\n    if lhs_open > 0 &&\
    \ rhs_open > 0 {\n        return \"Yes\"\n    }\n    if lhs_open < 0 && rhs_open\
    \ < 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpgkd_3513/tmpgkd_3513.swift:71: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7e014cfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7e011c6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7e011c6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7e011c57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgkd_3513                        0x0000562dd035a6a6 <unavailable> + 5798

    5    libc.so.6                          0x00002b7e016bb460 __libc_start_main +
    245

    6    tmpgkd_3513                        0x0000562dd035a289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var left = 0\n \
    \   var right = 0\n    for char in lst[0] {\n        if char == \"(\" {\n    \
    \        left += 1\n        } else {\n            right += 1\n        }\n    }\n\
    \    for char in lst[1] {\n        if char == \"(\" {\n            left -= 1\n\
    \        } else {\n            right -= 1\n        }\n    }\n    if left == 0\
    \ && right == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpswf759wy/tmpswf759wy.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b860cb40c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b860c837b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b860c837988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b860c8367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpswf759wy                        0x00005627041096a6 <unavailable> + 5798

    5    libc.so.6                          0x00002b860cd2c460 __libc_start_main +
    245

    6    tmpswf759wy                        0x0000562704109289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = lst[0] +\
    \ lst[1]\n    var stack = [Character]()\n    for c in s {\n        if c == \"\
    (\" {\n            stack.append(c)\n        } else {\n            if stack.isEmpty\
    \ {\n                return \"No\"\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpkjt35zbe/tmpkjt35zbe.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b773ea49c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b773e740b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b773e740988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b773e73f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkjt35zbe                        0x00005607a169dda6 <unavailable> + 7590

    5    libc.so.6                          0x00002b773ec35460 __libc_start_main +
    245

    6    tmpkjt35zbe                        0x00005607a169d509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = lst[0]\
    \ + lst[1]\n    var count = 0\n    for char in str {\n        if char == \"(\"\
    \ {\n            count += 1\n        } else {\n            count -= 1\n      \
    \  }\n        if count < 0 {\n            return \"No\"\n        }\n    }\n  \
    \  return count == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpxyafuqqj/tmpxyafuqqj.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae4e0dccc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae4e0ac3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae4e0ac3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae4e0ac27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxyafuqqj                        0x0000560234617b76 <unavailable> + 7030

    5    libc.so.6                          0x00002ae4e0fb8460 __libc_start_main +
    245

    6    tmpxyafuqqj                        0x00005602346172d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var s = lst.removeFirst()\n    for c in lst.removeFirst() {\n        if c\
    \ == \"(\" {\n            s.append(c)\n        } else {\n            if s.isEmpty\
    \ {\n                return \"No\"\n            }\n            s.removeLast()\n\
    \        }\n    }\n    return s.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp8nkm3d0g/tmp8nkm3d0g.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b26c5418c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b26c510fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b26c510f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b26c510e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8nkm3d0g                        0x000055d94bf7e876 <unavailable> + 6262

    5    libc.so.6                          0x00002b26c5604460 __libc_start_main +
    245

    6    tmp8nkm3d0g                        0x000055d94bf7e459 <unavailable> + 5209

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var open = 0\n \
    \   var close = 0\n    for char in lst[0] {\n        if char == \"(\" {\n    \
    \        open += 1\n        } else {\n            close += 1\n        }\n    }\n\
    \    for char in lst[1] {\n        if char == \"(\" {\n            open += 1\n\
    \        } else {\n            close += 1\n        }\n    }\n    if open == close\
    \ {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpyyy95a03/tmpyyy95a03.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4c56d49c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4c56a40b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4c56a40988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4c56a3f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyyy95a03                        0x000055e056c94468 <unavailable> + 9320

    5    libc.so.6                          0x00002b4c56f35460 __libc_start_main +
    245

    6    tmpyyy95a03                        0x000055e056c93289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var open = 0\n \
    \   var close = 0\n    for char in lst[0] {\n        if char == \"(\" {\n    \
    \        open += 1\n        } else {\n            close += 1\n        }\n    }\n\
    \    for char in lst[1] {\n        if char == \"(\" {\n            open += 1\n\
    \        } else {\n            close += 1\n        }\n    }\n    if open == close\
    \ {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpyyy95a03/tmpyyy95a03.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4c56d49c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4c56a40b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4c56a40988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4c56a3f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyyy95a03                        0x000055e056c94468 <unavailable> + 9320

    5    libc.so.6                          0x00002b4c56f35460 __libc_start_main +
    245

    6    tmpyyy95a03                        0x000055e056c93289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for str in lst {\n        s += str\n    }\n    var stack = [Character]()\n\
    \    for c in s {\n        if c == \"(\" {\n            stack.append(c)\n    \
    \    } else {\n            if stack.isEmpty {\n                return \"No\"\n\
    \            }\n            stack.removeLast()\n        }\n    }\n    return stack.isEmpty\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpi_hnpb9q/tmpi_hnpb9q.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b65e3891c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b65e3588b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b65e3588988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b65e35877b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi_hnpb9q                        0x000055cb9ef3de76 <unavailable> + 7798

    5    libc.so.6                          0x00002b65e3a7d460 __libc_start_main +
    245

    6    tmpi_hnpb9q                        0x000055cb9ef3d5d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0]\n\
    \    let str2 = lst[1]\n    let str1_count = str1.filter { $0 == \"(\" }.count\n\
    \    let str2_count = str2.filter { $0 == \"(\" }.count\n    let str1_close =\
    \ str1.filter { $0 == \")\" }.count\n    let str2_close = str2.filter { $0 ==\
    \ \")\" }.count\n    let str1_open = str1.filter { $0 == \"(\" }.count\n    let\
    \ str2_open = str2.filter { $0 == \"(\" }.count\n    if str1_count == str2_close\
    \ && str2_count == str1_close {\n        return \"Yes\"\n    } else if str1_open\
    \ == str2_close && str2_open == str1_close {\n        return \"Yes\"\n    } else\
    \ {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmptvnpvs_p/tmptvnpvs_p.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abbc4fd0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abbc4cc7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abbc4cc7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abbc4cc67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptvnpvs_p                        0x00005604bf0936d6 <unavailable> + 5846

    5    libc.so.6                          0x00002abbc51bc460 __libc_start_main +
    245

    6    tmptvnpvs_p                        0x00005604bf0932b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    let str1 = lst.removeFirst()\n    let str2 = lst.removeFirst()\n    let str\
    \ = str1 + str2\n    var stack = [Character]()\n    for char in str {\n      \
    \  if char == \"(\" {\n            stack.append(char)\n        } else {\n    \
    \        if stack.isEmpty {\n                return \"No\"\n            } else\
    \ {\n                stack.removeLast()\n            }\n        }\n    }\n   \
    \ return stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpe64wyqlw/tmpe64wyqlw.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba90fb0ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba90f801b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba90f801988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba90f8007b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe64wyqlw                        0x0000563c5f988da6 <unavailable> + 7590

    5    libc.so.6                          0x00002ba90fcf6460 __libc_start_main +
    245

    6    tmpe64wyqlw                        0x0000563c5f988509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    let str1 = lst.removeFirst()\n    let str2 = lst.removeFirst()\n    let str\
    \ = str1 + str2\n    var stack = [Character]()\n    for char in str {\n      \
    \  if char == \"(\" {\n            stack.append(char)\n        } else {\n    \
    \        if stack.isEmpty {\n                return \"No\"\n            } else\
    \ {\n                stack.removeLast()\n            }\n        }\n    }\n   \
    \ return stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpe64wyqlw/tmpe64wyqlw.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba90fb0ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba90f801b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba90f801988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba90f8007b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe64wyqlw                        0x0000563c5f988da6 <unavailable> + 7590

    5    libc.so.6                          0x00002ba90fcf6460 __libc_start_main +
    245

    6    tmpe64wyqlw                        0x0000563c5f988509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for i in lst {\n        s += i\n    }\n    var count = 0\n    for i in s {\n\
    \        if i == \"(\" {\n            count += 1\n        } else {\n         \
    \   count -= 1\n        }\n        if count < 0 {\n            return \"No\"\n\
    \        }\n    }\n    if count == 0 {\n        return \"Yes\"\n    } else {\n\
    \        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpy08bjsqz/tmpy08bjsqz.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1709aebc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b17097e2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b17097e2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b17097e17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy08bjsqz                        0x000055f2ce1a7c96 <unavailable> + 7318

    5    libc.so.6                          0x00002b1709cd7460 __libc_start_main +
    245

    6    tmpy08bjsqz                        0x000055f2ce1a73f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for i in lst {\n        s += i\n    }\n    var count = 0\n    for i in s {\n\
    \        if i == \"(\" {\n            count += 1\n        } else {\n         \
    \   count -= 1\n        }\n        if count < 0 {\n            return \"No\"\n\
    \        }\n    }\n    if count == 0 {\n        return \"Yes\"\n    } else {\n\
    \        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpy08bjsqz/tmpy08bjsqz.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1709aebc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b17097e2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b17097e2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b17097e17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy08bjsqz                        0x000055f2ce1a7c96 <unavailable> + 7318

    5    libc.so.6                          0x00002b1709cd7460 __libc_start_main +
    245

    6    tmpy08bjsqz                        0x000055f2ce1a73f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s1 = lst[0]\n\
    \    var s2 = lst[1]\n    var s3 = \"\"\n    var s4 = \"\"\n    var s5 = \"\"\n\
    \    var s6 = \"\"\n    var s7 = \"\"\n    var s8 = \"\"\n    var s9 = \"\"\n\
    \    var s10 = \"\"\n    var s11 = \"\"\n    var s12 = \"\"\n    var s13 = \"\"\
    \n    var s14 = \"\"\n    var s15 = \"\"\n    var s16 = \"\"\n    var s17 = \"\
    \"\n    var s18 = \"\"\n    var s19 = \"\"\n    var s20 = \"\"\n    var s21 =\
    \ \"\"\n    var s22 = \"\"\n    var s23 = \"\"\n    var s24 = \"\"\n    var s25\
    \ = \"\"\n    var s26 = \"\"\n    var s27 = \"\"\n    var s28 = \"\"\n    var\
    \ s29 = \"\"\n    var s30 = \"\"\n    var s31 = \"\"\n    var s32 = \"\"\n   \
    \ var s33 = \"\"\n    var s34 = \"\"\n    var s35 = \"\"\n    var s36 = \"\"\n\
    \    var s37 = \"\"\n    var s38 = \"\"\n    var s39 = \"\"\n    var s40 = \"\"\
    \n    var s41 = \"\"\n    var s42 = \"\"\n    var s43 = \"\"\n    var s44 = \"\
    \"\n    var s45 = \"\"\n    var s46 = \"\"\n    var s47 = \"\"\n    var s48 =\
    \ \"\"\n    var s49 = \"\"\n    var s50 = \"\"\n    var s51 = \"\"\n    var s52\
    \ = \"\"\n    var s53 = \"\"\n    var s54 = \"\"\n    var s55 = \"\"\n    var\
    \ s56 = \"\"\n    var s57 = \"\"\n    var s58 = \"\"\n    var s59 = \"\"\n   \
    \ var s60 = \"\"\n    var s61 = \"\"\n    var s62 = \"\"\n    var s63 = \"\"\n\
    \    var s64 = \"\"\n    var s65 = \"\"\n    var s66 = \"\"\n    var s67 = \"\"\
    \n    var s68 = \"\"\n    var s69 = \"\"\n    var s70 = \"\"\n    var s71 = \"\
    \"\n    var s72 = \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp28g79cg5.swift:16:9: warning: initialization of variable 's1' was\
    \ never used; consider replacing with assignment to '_' or removing it\n    var\
    \ s1 = lst[0]\n    ~~~~^~\n    _\n/tmp/tmp28g79cg5.swift:17:9: warning: initialization\
    \ of variable 's2' was never used; consider replacing with assignment to '_' or\
    \ removing it\n    var s2 = lst[1]\n    ~~~~^~\n    _\n/tmp/tmp28g79cg5.swift:18:9:\
    \ warning: initialization of variable 's3' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var s3 = \"\"\n    ~~~~^~\n    _\n\
    /tmp/tmp28g79cg5.swift:19:9: warning: initialization of variable 's4' was never\
    \ used; consider replacing with assignment to '_' or removing it\n    var s4 =\
    \ \"\"\n    ~~~~^~\n    _\n/tmp/tmp28g79cg5.swift:20:9: warning: initialization\
    \ of variable 's5' was never used; consider replacing with assignment to '_' or\
    \ removing it\n    var s5 = \"\"\n    ~~~~^~\n    _\n/tmp/tmp28g79cg5.swift:21:9:\
    \ warning: initialization of variable 's6' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var s6 = \"\"\n    ~~~~^~\n    _\n\
    /tmp/tmp28g79cg5.swift:22:9: warning: initialization of variable 's7' was never\
    \ used; consider replacing with assignment to '_' or removing it\n    var s7 =\
    \ \"\"\n    ~~~~^~\n    _\n/tmp/tmp28g79cg5.swift:23:9: warning: initialization\
    \ of variable 's8' was never used; consider replacing with assignment to '_' or\
    \ removing it\n    var s8 = \"\"\n    ~~~~^~\n    _\n/tmp/tmp28g79cg5.swift:24:9:\
    \ warning: initialization of variable 's9' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var s9 = \"\"\n    ~~~~^~\n    _\n\
    /tmp/tmp28g79cg5.swift:25:9: warning: initialization of variable 's10' was never\
    \ used; consider replacing with assignment to '_' or removing it\n    var s10\
    \ = \"\"\n    ~~~~^~~\n    _\n/tmp/tmp28g79cg5.swift:26:9: warning: initialization\
    \ of variable 's11' was never used; consider replacing with assignment to '_'\
    \ or removing it\n    var s11 = \"\"\n    ~~~~^~~\n    _\n/tmp/tmp28g79cg5.swift:27:9:\
    \ warning: initialization of variable 's12' was never used; consider re"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let s1 = lst[0]\n\
    \    let s2 = lst[1]\n    var s = \"\"\n    var cnt = 0\n    for c in s1 {\n \
    \       s.append(c)\n        if c == \"(\" {\n            cnt += 1\n        }\
    \ else {\n            cnt -= 1\n        }\n        if cnt < 0 {\n            break\n\
    \        }\n    }\n    if cnt < 0 {\n        return \"No\"\n    }\n    for c in\
    \ s2 {\n        s.append(c)\n        if c == \"(\" {\n            cnt += 1\n \
    \       } else {\n            cnt -= 1\n        }\n        if cnt < 0 {\n    \
    \        break\n        }\n    }\n    if cnt == 0 {\n        return \"Yes\"\n\
    \    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp5p3a5ssq/tmp5p3a5ssq.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b225d641c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b225d338b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b225d338988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b225d3377b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5p3a5ssq                        0x0000561e873f0b76 <unavailable> + 7030

    5    libc.so.6                          0x00002b225d82d460 __libc_start_main +
    245

    6    tmp5p3a5ssq                        0x0000561e873f02d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let s = lst[0] +\
    \ lst[1]\n    var stack = [Character]()\n    for c in s {\n        if c == \"\
    (\" {\n            stack.append(c)\n        } else {\n            if stack.isEmpty\
    \ {\n                return \"No\"\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpsev5u88k/tmpsev5u88k.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002accef6f8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002accef3efb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002accef3ef988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002accef3ee7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsev5u88k                        0x000055e6b9065da6 <unavailable> + 7590

    5    libc.so.6                          0x00002accef8e4460 __libc_start_main +
    245

    6    tmpsev5u88k                        0x000055e6b9065509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var open = 0\n \
    \   var close = 0\n    for char in lst[0] {\n        if char == \"(\" {\n    \
    \        open += 1\n        } else {\n            close += 1\n        }\n    }\n\
    \    for char in lst[1] {\n        if char == \"(\" {\n            open += 1\n\
    \        } else {\n            close += 1\n        }\n    }\n    if open == close\
    \ {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpyyy95a03/tmpyyy95a03.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4c56d49c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4c56a40b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4c56a40988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4c56a3f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyyy95a03                        0x000055e056c94468 <unavailable> + 9320

    5    libc.so.6                          0x00002b4c56f35460 __libc_start_main +
    245

    6    tmpyyy95a03                        0x000055e056c93289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var count = 0\n\
    \    for s in lst {\n        for c in s {\n            if c == \"(\" {\n     \
    \           count += 1\n            } else {\n                count -= 1\n   \
    \         }\n            if count < 0 {\n                return \"No\"\n     \
    \       }\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpgysr0kje/tmpgysr0kje.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abfa126fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abfa0f66b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abfa0f66988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abfa0f657b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgysr0kje                        0x000055b40bc60c36 <unavailable> + 7222

    5    libc.so.6                          0x00002abfa145b460 __libc_start_main +
    245

    6    tmpgysr0kje                        0x000055b40bc60399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0]\n\
    \    let str2 = lst[1]\n    let str = str1 + str2\n    var stack = [Character]()\n\
    \    for char in str {\n        if char == \"(\" {\n            stack.append(char)\n\
    \        } else {\n            if stack.count == 0 {\n                return \"\
    No\"\n            } else {\n                stack.removeLast()\n            }\n\
    \        }\n    }\n    return stack.count == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpn1ke1ohj/tmpn1ke1ohj.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad390763c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad39045ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad39045a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad3904597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn1ke1ohj                        0x000055703246ed66 <unavailable> + 7526

    5    libc.so.6                          0x00002ad39094f460 __libc_start_main +
    245

    6    tmpn1ke1ohj                        0x000055703246e4c9 <unavailable> + 5321

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var open = 0\n \
    \   var close = 0\n    for char in lst[0] {\n        if char == \"(\" {\n    \
    \        open += 1\n        } else {\n            close += 1\n        }\n    }\n\
    \    for char in lst[1] {\n        if char == \"(\" {\n            open += 1\n\
    \        } else {\n            close += 1\n        }\n    }\n    if open == close\
    \ {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpyyy95a03/tmpyyy95a03.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4c56d49c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4c56a40b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4c56a40988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4c56a3f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyyy95a03                        0x000055e056c94468 <unavailable> + 9320

    5    libc.so.6                          0x00002b4c56f35460 __libc_start_main +
    245

    6    tmpyyy95a03                        0x000055e056c93289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = lst[0] +\
    \ lst[1]\n    var count = 0\n    for c in s {\n        if c == \"(\" {\n     \
    \       count += 1\n        } else {\n            count -= 1\n        }\n    \
    \    if count < 0 {\n            return \"No\"\n        }\n    }\n    return count\
    \ == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpf1k5bpgp/tmpf1k5bpgp.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad1c3fe6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad1c3cddb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad1c3cdd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad1c3cdc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf1k5bpgp                        0x0000564535cb9b76 <unavailable> + 7030

    5    libc.so.6                          0x00002ad1c41d2460 __libc_start_main +
    245

    6    tmpf1k5bpgp                        0x0000564535cb92d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let s1 = lst[0]\n\
    \    let s2 = lst[1]\n    let s1_count = s1.filter { $0 == \"(\" }.count\n   \
    \ let s2_count = s2.filter { $0 == \"(\" }.count\n    let s1_count_close = s1.filter\
    \ { $0 == \")\" }.count\n    let s2_count_close = s2.filter { $0 == \")\" }.count\n\
    \    if s1_count == s1_count_close && s2_count == s2_count_close {\n        return\
    \ \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpaf021gkr/tmpaf021gkr.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b77d295dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b77d2654b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b77d2654988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b77d26537b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpaf021gkr                        0x000055835b5b16d6 <unavailable> + 5846

    5    libc.so.6                          0x00002b77d2b49460 __libc_start_main +
    245

    6    tmpaf021gkr                        0x000055835b5b12b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var open = 0\n \
    \   var close = 0\n    for char in lst[0] {\n        if char == \"(\" {\n    \
    \        open += 1\n        } else {\n            close += 1\n        }\n    }\n\
    \    for char in lst[1] {\n        if char == \"(\" {\n            open += 1\n\
    \        } else {\n            close += 1\n        }\n    }\n    if open == close\
    \ {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpyyy95a03/tmpyyy95a03.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4c56d49c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4c56a40b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4c56a40988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4c56a3f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyyy95a03                        0x000055e056c94468 <unavailable> + 9320

    5    libc.so.6                          0x00002b4c56f35460 __libc_start_main +
    245

    6    tmpyyy95a03                        0x000055e056c93289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var count = 0\n    for i in 0..<lst.count {\n       \
    \ str += lst[i]\n    }\n    for i in 0..<str.count {\n        if str[i] == \"\
    (\" {\n            count += 1\n        } else {\n            count -= 1\n    \
    \    }\n        if count < 0 {\n            return \"No\"\n        }\n    }\n\
    \    if count == 0 {\n        return \"Yes\"\n    } else {\n        return \"\
    No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmplkxfsp_6.swift:23:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if str[i]\
    \ == \"(\" {\n           ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmplkxfsp_6.swift:16:9: warning: variable 'lst'\
    \ was never mutated; consider changing to 'let' constant\n    var lst = lst\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    var count = 0\n    for c in\
    \ str {\n        if c == \"(\" {\n            count += 1\n        } else {\n \
    \           count -= 1\n        }\n        if count < 0 {\n            return\
    \ \"No\"\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmptan6oan_/tmptan6oan_.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f38400c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f380f7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8f380f7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8f380f67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptan6oan_                        0x000055a83b5e4c96 <unavailable> + 7318

    5    libc.so.6                          0x00002b8f385ec460 __libc_start_main +
    245

    6    tmptan6oan_                        0x000055a83b5e43f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = lst[0] +\
    \ lst[1]\n    var count = 0\n    for c in s {\n        if c == \"(\" {\n     \
    \       count += 1\n        } else {\n            count -= 1\n        }\n    \
    \    if count < 0 {\n            return \"No\"\n        }\n    }\n    return count\
    \ == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpf1k5bpgp/tmpf1k5bpgp.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad1c3fe6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad1c3cddb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad1c3cdd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad1c3cdc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf1k5bpgp                        0x0000564535cb9b76 <unavailable> + 7030

    5    libc.so.6                          0x00002ad1c41d2460 __libc_start_main +
    245

    6    tmpf1k5bpgp                        0x0000564535cb92d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let s1 = lst[0]\n\
    \    let s2 = lst[1]\n    let s = s1 + s2\n    var stack = [Character]()\n   \
    \ for c in s {\n        if c == \"(\" {\n            stack.append(c)\n       \
    \ } else {\n            if stack.isEmpty {\n                return \"No\"\n  \
    \          }\n            stack.removeLast()\n        }\n    }\n    return stack.isEmpty\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp6_9g33ml/tmp6_9g33ml.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8bc86c7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8bc83beb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8bc83be988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8bc83bd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6_9g33ml                        0x000055ce77488da6 <unavailable> + 7590

    5    libc.so.6                          0x00002b8bc88b3460 __libc_start_main +
    245

    6    tmp6_9g33ml                        0x000055ce77488509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    var count = 0\n    for c in\
    \ str {\n        if c == \"(\" {\n            count += 1\n        } else {\n \
    \           count -= 1\n        }\n        if count < 0 {\n            return\
    \ \"No\"\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmptan6oan_/tmptan6oan_.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f38400c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f380f7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8f380f7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8f380f67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptan6oan_                        0x000055a83b5e4c96 <unavailable> + 7318

    5    libc.so.6                          0x00002b8f385ec460 __libc_start_main +
    245

    6    tmptan6oan_                        0x000055a83b5e43f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    for i in 0..<lst.count {\n        str += lst[i]\n   \
    \ }\n    var stack = Stack<Character>()\n    for char in str {\n        if char\
    \ == \"(\" {\n            stack.push(char)\n        } else {\n            if stack.isEmpty\
    \ {\n                return \"No\"\n            } else {\n                stack.pop()\n\
    \            }\n        }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpe5djj9_f.swift:21:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let s1 = lst[0]\n\
    \    let s2 = lst[1]\n    let s = s1 + s2\n    var stack = [Character]()\n   \
    \ for c in s {\n        if c == \"(\" {\n            stack.append(c)\n       \
    \ } else {\n            if stack.isEmpty {\n                return \"No\"\n  \
    \          }\n            stack.removeLast()\n        }\n    }\n    return stack.isEmpty\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp6_9g33ml/tmp6_9g33ml.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8bc86c7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8bc83beb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8bc83be988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8bc83bd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6_9g33ml                        0x000055ce77488da6 <unavailable> + 7590

    5    libc.so.6                          0x00002b8bc88b3460 __libc_start_main +
    245

    6    tmp6_9g33ml                        0x000055ce77488509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var open = 0\n    var close = 0\n    var result = \"Yes\"\n    for i in 0..<lst.count\
    \ {\n        for j in 0..<lst[i].count {\n            if lst[i][j] == \"(\" {\n\
    \                open += 1\n            } else {\n                close += 1\n\
    \            }\n        }\n    }\n    if open != close {\n        result = \"\
    No\"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp14nzgi1j.swift:22:16: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n            if lst[i][j]\
    \ == \"(\" {\n               ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp14nzgi1j.swift:16:9: warning: variable\
    \ 'lst' was never mutated; consider changing to 'let' constant\n    var lst =\
    \ lst\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = lst[0]\
    \ + lst[1]\n    var count = 0\n    for char in str {\n        if char == \"(\"\
    \ {\n            count += 1\n        } else {\n            count -= 1\n      \
    \  }\n        if count < 0 {\n            return \"No\"\n        }\n    }\n  \
    \  return count == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpxyafuqqj/tmpxyafuqqj.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae4e0dccc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae4e0ac3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae4e0ac3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae4e0ac27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxyafuqqj                        0x0000560234617b76 <unavailable> + 7030

    5    libc.so.6                          0x00002ae4e0fb8460 __libc_start_main +
    245

    6    tmpxyafuqqj                        0x00005602346172d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str1 = lst[0]\n\
    \    var str2 = lst[1]\n    var count1 = 0\n    var count2 = 0\n    for char in\
    \ str1 {\n        if char == \"(\" {\n            count1 += 1\n        } else\
    \ {\n            count1 -= 1\n        }\n    }\n    for char in str2 {\n     \
    \   if char == \"(\" {\n            count2 += 1\n        } else {\n          \
    \  count2 -= 1\n        }\n    }\n    if count1 == 0 && count2 == 0 {\n      \
    \  return \"Yes\"\n    } else if count1 < 0 && count2 > 0 {\n        return \"\
    Yes\"\n    } else if count1 > 0 && count2 < 0 {\n        return \"Yes\"\n    }\
    \ else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpewh5e5nf/tmpewh5e5nf.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3141ab0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b31417a7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b31417a7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b31417a67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpewh5e5nf                        0x000055eb8d41699b <unavailable> + 6555

    5    libc.so.6                          0x00002b3141c9c460 __libc_start_main +
    245

    6    tmpewh5e5nf                        0x000055eb8d416289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0]\n\
    \    let str2 = lst[1]\n    var str = str1 + str2\n    var open = 0\n    var close\
    \ = 0\n    for char in str {\n        if char == \"(\" {\n            open +=\
    \ 1\n        } else {\n            close += 1\n        }\n        if close > open\
    \ {\n            return \"No\"\n        }\n    }\n    if open == close {\n   \
    \     return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp7kxa9d2x/tmp7kxa9d2x.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b77fd7eec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b77fd4e5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b77fd4e5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b77fd4e47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7kxa9d2x                        0x0000556eb7ea4b76 <unavailable> + 7030

    5    libc.so.6                          0x00002b77fd9da460 __libc_start_main +
    245

    6    tmp7kxa9d2x                        0x0000556eb7ea42d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = lst[0] +\
    \ lst[1]\n    var count = 0\n    for c in s {\n        if c == \"(\" {\n     \
    \       count += 1\n        } else {\n            count -= 1\n        }\n    \
    \    if count < 0 {\n            return \"No\"\n        }\n    }\n    return count\
    \ == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpf1k5bpgp/tmpf1k5bpgp.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad1c3fe6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad1c3cddb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad1c3cdd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad1c3cdc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf1k5bpgp                        0x0000564535cb9b76 <unavailable> + 7030

    5    libc.so.6                          0x00002ad1c41d2460 __libc_start_main +
    245

    6    tmpf1k5bpgp                        0x0000564535cb92d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0]\n\
    \    let str2 = lst[1]\n    let str3 = str1 + str2\n    let str4 = str2 + str1\n\
    \    if is_good(str: str3) {\n        return \"Yes\"\n    } else if is_good(str:\
    \ str4) {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp_90rzr4c.swift:20:8: error: cannot find 'is_good' in scope\n  \
    \  if is_good(str: str3) {\n       ^~~~~~~\n/tmp/tmp_90rzr4c.swift:22:15: error:\
    \ cannot find 'is_good' in scope\n    } else if is_good(str: str4) {\n       \
    \       ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var count = 0\n    for i in 0..<lst.count {\n       \
    \ str += lst[i]\n    }\n    for i in 0..<str.count {\n        if str[i] == \"\
    (\" {\n            count += 1\n        } else {\n            count -= 1\n    \
    \    }\n        if count < 0 {\n            return \"No\"\n        }\n    }\n\
    \    if count == 0 {\n        return \"Yes\"\n    } else {\n        return \"\
    No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmplkxfsp_6.swift:23:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if str[i]\
    \ == \"(\" {\n           ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmplkxfsp_6.swift:16:9: warning: variable 'lst'\
    \ was never mutated; consider changing to 'let' constant\n    var lst = lst\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [Character]()\n\
    \    var str = lst[0] + lst[1]\n    for char in str {\n        if char == \"(\"\
    \ {\n            stack.append(char)\n        } else {\n            if stack.isEmpty\
    \ {\n                return \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpx6o5iz72/tmpx6o5iz72.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6f65218c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6f64f0fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6f64f0f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6f64f0e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx6o5iz72                        0x000055e11b07eda6 <unavailable> + 7590

    5    libc.so.6                          0x00002b6f65404460 __libc_start_main +
    245

    6    tmpx6o5iz72                        0x000055e11b07e509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    var stack = [Character]()\n\
    \    for c in str {\n        if c == \"(\" {\n            stack.append(c)\n  \
    \      } else {\n            if stack.isEmpty {\n                return \"No\"\
    \n            } else {\n                stack.removeLast()\n            }\n  \
    \      }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpg5wbuesr/tmpg5wbuesr.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b46e418ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b46e3e85b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b46e3e85988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b46e3e847b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg5wbuesr                        0x000055ceac939e76 <unavailable> + 7798

    5    libc.so.6                          0x00002b46e437a460 __libc_start_main +
    245

    6    tmpg5wbuesr                        0x000055ceac9395d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = lst[0] +\
    \ lst[1]\n    var count = 0\n    for c in s {\n        if c == \"(\" {\n     \
    \       count += 1\n        } else {\n            count -= 1\n        }\n    \
    \    if count < 0 {\n            return \"No\"\n        }\n    }\n    return count\
    \ == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpf1k5bpgp/tmpf1k5bpgp.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad1c3fe6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad1c3cddb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad1c3cdd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad1c3cdc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf1k5bpgp                        0x0000564535cb9b76 <unavailable> + 7030

    5    libc.so.6                          0x00002ad1c41d2460 __libc_start_main +
    245

    6    tmpf1k5bpgp                        0x0000564535cb92d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    for i in 0..<lst.count {\n        str += lst[i]\n   \
    \ }\n    var count = 0\n    for i in 0..<str.count {\n        if str[i] == \"\
    (\" {\n            count += 1\n        } else {\n            count -= 1\n    \
    \    }\n        if count < 0 {\n            return \"No\"\n        }\n    }\n\
    \    if count == 0 {\n        return \"Yes\"\n    } else {\n        return \"\
    No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpqjsyulbz.swift:23:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if str[i]\
    \ == \"(\" {\n           ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpqjsyulbz.swift:16:9: warning: variable 'lst'\
    \ was never mutated; consider changing to 'let' constant\n    var lst = lst\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    while lst.count > 0 {\n        str += lst.removeFirst()\n\
    \        if !is_good(str: str) {\n            str = \"\"\n        }\n    }\n \
    \   return is_good(str: str) ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpekc4_1hq.swift:20:13: error: cannot find 'is_good' in scope\n \
    \       if !is_good(str: str) {\n            ^~~~~~~\n/tmp/tmpekc4_1hq.swift:24:12:\
    \ error: cannot find 'is_good' in scope\n    return is_good(str: str) ? \"Yes\"\
    \ : \"No\"\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var result = \"\
    Yes\"\n    var num_open = 0\n    var num_close = 0\n    for str in lst {\n   \
    \     for char in str {\n            if char == \"(\" {\n                num_open\
    \ += 1\n            } else {\n                num_close += 1\n            }\n\
    \        }\n    }\n    if num_open != num_close {\n        result = \"No\"\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpii3_uu31/tmpii3_uu31.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b884e554c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b884e24bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b884e24b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b884e24a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpii3_uu31                        0x000055f10a429578 <unavailable> + 9592

    5    libc.so.6                          0x00002b884e740460 __libc_start_main +
    245

    6    tmpii3_uu31                        0x000055f10a428399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = lst[0] +\
    \ lst[1]\n    var cnt = 0\n    for c in s {\n        if c == \"(\" {\n       \
    \     cnt += 1\n        } else {\n            cnt -= 1\n        }\n        if\
    \ cnt < 0 {\n            return \"No\"\n        }\n    }\n    return cnt == 0\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpnr682cc7/tmpnr682cc7.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acd153c5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acd150bcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acd150bc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acd150bb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnr682cc7                        0x0000560142999b76 <unavailable> + 7030

    5    libc.so.6                          0x00002acd155b1460 __libc_start_main +
    245

    6    tmpnr682cc7                        0x00005601429992d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0]\n\
    \    let str2 = lst[1]\n    let str3 = str1 + str2\n    var stack = [Character]()\n\
    \    for char in str3 {\n        if char == \"(\" {\n            stack.append(char)\n\
    \        } else {\n            if stack.count == 0 {\n                return \"\
    No\"\n            } else {\n                stack.removeLast()\n            }\n\
    \        }\n    }\n    return stack.count == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpr3t0bdqi/tmpr3t0bdqi.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4d437c5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4d434bcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4d434bc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4d434bb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr3t0bdqi                        0x000055b267770d66 <unavailable> + 7526

    5    libc.so.6                          0x00002b4d439b1460 __libc_start_main +
    245

    6    tmpr3t0bdqi                        0x000055b2677704c9 <unavailable> + 5321

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    var stack = [Character]()\n\
    \    for c in str {\n        if c == \"(\" {\n            stack.append(c)\n  \
    \      } else {\n            if stack.isEmpty {\n                return \"No\"\
    \n            } else {\n                stack.removeLast()\n            }\n  \
    \      }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpg5wbuesr/tmpg5wbuesr.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b46e418ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b46e3e85b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b46e3e85988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b46e3e847b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg5wbuesr                        0x000055ceac939e76 <unavailable> + 7798

    5    libc.so.6                          0x00002b46e437a460 __libc_start_main +
    245

    6    tmpg5wbuesr                        0x000055ceac9395d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var left = 0\n \
    \   var right = 0\n    for char in lst[0] {\n        if char == \"(\" {\n    \
    \        left += 1\n        } else {\n            right += 1\n        }\n    }\n\
    \    for char in lst[1] {\n        if char == \"(\" {\n            left -= 1\n\
    \        } else {\n            right -= 1\n        }\n    }\n    if left == 0\
    \ && right == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpswf759wy/tmpswf759wy.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b860cb40c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b860c837b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b860c837988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b860c8367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpswf759wy                        0x00005627041096a6 <unavailable> + 5798

    5    libc.so.6                          0x00002b860cd2c460 __libc_start_main +
    245

    6    tmpswf759wy                        0x0000562704109289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = lst[0]\
    \ + lst[1]\n    var stack = [Character]()\n    for c in str {\n        if c ==\
    \ \"(\" {\n            stack.append(c)\n        } else {\n            if stack.isEmpty\
    \ {\n                return \"No\"\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpxmur0gu4/tmpxmur0gu4.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b48e819ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48e7e91b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b48e7e91988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b48e7e907b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxmur0gu4                        0x000055dd7e935da6 <unavailable> + 7590

    5    libc.so.6                          0x00002b48e8386460 __libc_start_main +
    245

    6    tmpxmur0gu4                        0x000055dd7e935509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var open = 0\n    var close = 0\n    var i = 0\n    while i < lst.count {\n\
    \        var j = 0\n        while j < lst[i].count {\n            if lst[i][j]\
    \ == \"(\" {\n                open += 1\n            } else {\n              \
    \  close += 1\n            }\n            j += 1\n        }\n        i += 1\n\
    \    }\n    if open == close {\n        return \"Yes\"\n    }\n    return \"No\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpu8fk7hv2.swift:23:16: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n            if lst[i][j]\
    \ == \"(\" {\n               ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpu8fk7hv2.swift:16:9: warning: variable\
    \ 'lst' was never mutated; consider changing to 'let' constant\n    var lst =\
    \ lst\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var left = 0\n \
    \   var right = 0\n    for char in lst[0] {\n        if char == \"(\" {\n    \
    \        left += 1\n        } else {\n            right += 1\n        }\n    }\n\
    \    for char in lst[1] {\n        if char == \"(\" {\n            left -= 1\n\
    \        } else {\n            right -= 1\n        }\n    }\n    if left == 0\
    \ && right == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpswf759wy/tmpswf759wy.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b860cb40c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b860c837b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b860c837988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b860c8367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpswf759wy                        0x00005627041096a6 <unavailable> + 5798

    5    libc.so.6                          0x00002b860cd2c460 __libc_start_main +
    245

    6    tmpswf759wy                        0x0000562704109289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0]\n\
    \    let str2 = lst[1]\n    let str1_count = str1.count\n    let str2_count =\
    \ str2.count\n    let str1_open = str1.filter { $0 == \"(\" }.count\n    let str1_close\
    \ = str1.filter { $0 == \")\" }.count\n    let str2_open = str2.filter { $0 ==\
    \ \"(\" }.count\n    let str2_close = str2.filter { $0 == \")\" }.count\n    if\
    \ str1_count == str1_open && str2_count == str2_close {\n        return \"Yes\"\
    \n    } else if str1_count == str1_close && str2_count == str2_open {\n      \
    \  return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmphx0jxa7e/tmphx0jxa7e.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b18bcb98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b18bc88fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b18bc88f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b18bc88e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphx0jxa7e                        0x000055e8365fe6d6 <unavailable> + 5846

    5    libc.so.6                          0x00002b18bcd84460 __libc_start_main +
    245

    6    tmphx0jxa7e                        0x000055e8365fe2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = lst[0] +\
    \ lst[1]\n    var count = 0\n    for c in s {\n        if c == \"(\" {\n     \
    \       count += 1\n        } else {\n            count -= 1\n        }\n    \
    \    if count < 0 {\n            return \"No\"\n        }\n    }\n    return count\
    \ == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpf1k5bpgp/tmpf1k5bpgp.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad1c3fe6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad1c3cddb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad1c3cdd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad1c3cdc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf1k5bpgp                        0x0000564535cb9b76 <unavailable> + 7030

    5    libc.so.6                          0x00002ad1c41d2460 __libc_start_main +
    245

    6    tmpf1k5bpgp                        0x0000564535cb92d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack<Character>()\n\
    \    for char in lst[0] {\n        if char == \"(\" {\n            stack.push(char)\n\
    \        } else {\n            if stack.isEmpty() {\n                return \"\
    No\"\n            }\n            stack.pop()\n        }\n    }\n    for char in\
    \ lst[1] {\n        if char == \"(\" {\n            if stack.isEmpty() {\n   \
    \             return \"No\"\n            }\n            stack.pop()\n        }\
    \ else {\n            stack.push(char)\n        }\n    }\n    return stack.isEmpty()\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpv72ksz2x.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for i in lst {\n        s += i\n    }\n    var count = 0\n    for i in s {\n\
    \        if i == \"(\" {\n            count += 1\n        } else {\n         \
    \   count -= 1\n        }\n        if count < 0 {\n            return \"No\"\n\
    \        }\n    }\n    if count == 0 {\n        return \"Yes\"\n    } else {\n\
    \        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpy08bjsqz/tmpy08bjsqz.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1709aebc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b17097e2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b17097e2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b17097e17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy08bjsqz                        0x000055f2ce1a7c96 <unavailable> + 7318

    5    libc.so.6                          0x00002b1709cd7460 __libc_start_main +
    245

    6    tmpy08bjsqz                        0x000055f2ce1a73f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    var count = 0\n    for i in 0..<lst.count {\n        str += lst[i]\n    }\n\
    \    for i in 0..<str.count {\n        if str[i] == \"(\" {\n            count\
    \ += 1\n        } else {\n            count -= 1\n        }\n        if count\
    \ < 0 {\n            return \"No\"\n        }\n    }\n    if count == 0 {\n  \
    \      return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpyiy3lpqc.swift:22:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if str[i]\
    \ == \"(\" {\n           ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var balance = 0\n\
    \    for char in lst[0] {\n        if char == \"(\" {\n            balance +=\
    \ 1\n        } else {\n            balance -= 1\n        }\n    }\n    for char\
    \ in lst[1] {\n        if char == \"(\" {\n            balance += 1\n        }\
    \ else {\n            balance -= 1\n        }\n    }\n    if balance == 0 {\n\
    \        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpks2ell1m/tmpks2ell1m.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b995d6eec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b995d3e5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b995d3e5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b995d3e47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpks2ell1m                        0x00005618b8b79468 <unavailable> + 9320

    5    libc.so.6                          0x00002b995d8da460 __libc_start_main +
    245

    6    tmpks2ell1m                        0x00005618b8b78289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack<Character>()\n\
    \    var str = lst[0] + lst[1]\n    for char in str {\n        if char == \"(\"\
    \ {\n            stack.push(char)\n        } else {\n            if stack.isEmpty()\
    \ {\n                return \"No\"\n            } else {\n                stack.pop()\n\
    \            }\n        }\n    }\n    return stack.isEmpty() ? \"Yes\" : \"No\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpzwylv_md.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = lst[0] +\
    \ lst[1]\n    var count = 0\n    for c in s {\n        if c == \"(\" {\n     \
    \       count += 1\n        } else {\n            count -= 1\n        }\n    \
    \    if count < 0 {\n            return \"No\"\n        }\n    }\n    return count\
    \ == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpf1k5bpgp/tmpf1k5bpgp.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad1c3fe6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad1c3cddb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad1c3cdd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad1c3cdc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf1k5bpgp                        0x0000564535cb9b76 <unavailable> + 7030

    5    libc.so.6                          0x00002ad1c41d2460 __libc_start_main +
    245

    6    tmpf1k5bpgp                        0x0000564535cb92d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    while !lst.isEmpty {\n        str += lst.removeFirst()\n\
    \        if str.contains(\"()\") {\n            str = str.replacingOccurrences(of:\
    \ \"()\", with: \"\")\n        }\n    }\n    return str.isEmpty ? \"Yes\" : \"\
    No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \"\
    )\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpm2s1lbkg.swift:21:23: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n            str = str.replacingOccurrences(of: \"()\"\
    , with: \"\")\n                  ~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    let str1 = lst.removeFirst()\n    let str2 = lst.removeFirst()\n    let str\
    \ = str1 + str2\n    var stack = [Character]()\n    for c in str {\n        if\
    \ c == \"(\" {\n            stack.append(c)\n        } else {\n            if\
    \ stack.isEmpty {\n                return \"No\"\n            } else {\n     \
    \           stack.removeLast()\n            }\n        }\n    }\n    return stack.isEmpty\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmplga9icn0/tmplga9icn0.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af2af0d7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af2aedceb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af2aedce988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af2aedcd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplga9icn0                        0x000055cc6c240da6 <unavailable> + 7590

    5    libc.so.6                          0x00002af2af2c3460 __libc_start_main +
    245

    6    tmplga9icn0                        0x000055cc6c240509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var cnt = 0\n    for i in 0..<lst.count {\n        for j in 0..<lst[i].count\
    \ {\n            if lst[i][j] == \"(\" {\n                cnt += 1\n         \
    \   } else {\n                cnt -= 1\n            }\n            if cnt < 0\
    \ {\n                return \"No\"\n            }\n        }\n    }\n    if cnt\
    \ == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpiyt303fp.swift:20:16: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n            if lst[i][j]\
    \ == \"(\" {\n               ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpiyt303fp.swift:16:9: warning: variable\
    \ 'lst' was never mutated; consider changing to 'let' constant\n    var lst =\
    \ lst\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var left = 0\n \
    \   var right = 0\n    for char in lst[0] {\n        if char == \"(\" {\n    \
    \        left += 1\n        } else {\n            right += 1\n        }\n    }\n\
    \    for char in lst[1] {\n        if char == \"(\" {\n            left -= 1\n\
    \        } else {\n            right -= 1\n        }\n    }\n    if left == 0\
    \ && right == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpswf759wy/tmpswf759wy.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b860cb40c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b860c837b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b860c837988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b860c8367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpswf759wy                        0x00005627041096a6 <unavailable> + 5798

    5    libc.so.6                          0x00002b860cd2c460 __libc_start_main +
    245

    6    tmpswf759wy                        0x0000562704109289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var count = 0\n    for i in 0...1 {\n        for j in\
    \ 0..<lst[i].count {\n            if lst[i][j] == \"(\" {\n                count\
    \ += 1\n            } else {\n                count -= 1\n            }\n    \
    \        if count < 0 {\n                return \"No\"\n            }\n      \
    \  }\n        str += lst[i]\n    }\n    if count == 0 {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpbkzsxwms.swift:21:16: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n            if lst[i][j]\
    \ == \"(\" {\n               ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpbkzsxwms.swift:16:9: warning: variable\
    \ 'lst' was never mutated; consider changing to 'let' constant\n    var lst =\
    \ lst\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var open = 0\n \
    \   var close = 0\n    for c in lst[0] {\n        if c == \"(\" {\n          \
    \  open += 1\n        } else {\n            close += 1\n        }\n    }\n   \
    \ for c in lst[1] {\n        if c == \"(\" {\n            open += 1\n        }\
    \ else {\n            close += 1\n        }\n    }\n    if open == close {\n \
    \       return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp1plf6uq4/tmp1plf6uq4.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b626ffe9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b626fce0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b626fce0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b626fcdf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1plf6uq4                        0x000055b467b95468 <unavailable> + 9320

    5    libc.so.6                          0x00002b62701d5460 __libc_start_main +
    245

    6    tmp1plf6uq4                        0x000055b467b94289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var count = 0\n    for i in 0..<lst.count {\n       \
    \ if lst[i].count == 0 {\n            lst.remove(at: i)\n        }\n    }\n  \
    \  if lst.count == 1 {\n        str = lst[0]\n    } else {\n        str = lst[0]\
    \ + lst[1]\n    }\n    for i in 0..<str.count {\n        if str[i] == \"(\" {\n\
    \            count += 1\n        } else {\n            count -= 1\n        }\n\
    \        if count < 0 {\n            return \"No\"\n        }\n    }\n    if count\
    \ == 0 {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpf0vjq7p9.swift:30:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if str[i]\
    \ == \"(\" {\n           ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str = lst[0]\
    \ + lst[1]\n    var stack = [Character]()\n    for char in str {\n        if char\
    \ == \"(\" {\n            stack.append(char)\n        } else {\n            if\
    \ stack.isEmpty {\n                return \"No\"\n            } else {\n     \
    \           stack.removeLast()\n            }\n        }\n    }\n    return stack.isEmpty\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp18nm9wmm/tmp18nm9wmm.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c13e6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c10ddb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b48c10dd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b48c10dc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp18nm9wmm                        0x00005652dda47da6 <unavailable> + 7590

    5    libc.so.6                          0x00002b48c15d2460 __libc_start_main +
    245

    6    tmp18nm9wmm                        0x00005652dda47509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    var stack = [Character]()\n\
    \    for c in str {\n        if c == \"(\" {\n            stack.append(c)\n  \
    \      } else {\n            if stack.count == 0 {\n                return \"\
    No\"\n            }\n            stack.removeLast()\n        }\n    }\n    return\
    \ stack.count == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpcg07odb7/tmpcg07odb7.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba8ae222c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba8adf19b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba8adf19988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba8adf187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcg07odb7                        0x00005579e4ac4e76 <unavailable> + 7798

    5    libc.so.6                          0x00002ba8ae40e460 __libc_start_main +
    245

    6    tmpcg07odb7                        0x00005579e4ac45d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = lst[0] +\
    \ lst[1]\n    var stack = Stack<Character>()\n    for c in s {\n        if c ==\
    \ \"(\" {\n            stack.push(c)\n        } else {\n            if stack.isEmpty()\
    \ {\n                return \"No\"\n            }\n            stack.pop()\n \
    \       }\n    }\n    return stack.isEmpty() ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpwtj9zbqn.swift:17:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0]\n\
    \    let str2 = lst[1]\n    let str1_count = str1.filter { $0 == \"(\" }.count\n\
    \    let str2_count = str2.filter { $0 == \"(\" }.count\n    let str1_rev_count\
    \ = str1.filter { $0 == \")\" }.count\n    let str2_rev_count = str2.filter {\
    \ $0 == \")\" }.count\n    let str1_rev = String(str1.reversed())\n    let str2_rev\
    \ = String(str2.reversed())\n    if str1_count == str2_rev_count && str2_count\
    \ == str1_rev_count {\n        return \"Yes\"\n    } else if str1_rev_count ==\
    \ str2_count && str2_rev_count == str1_count {\n        return \"Yes\"\n    }\
    \ else if str1_count == str2_count && str1_rev_count == str2_rev_count {\n   \
    \     return \"Yes\"\n    } else if str1_rev_count == str2_rev_count && str1_count\
    \ == str2_count {\n        return \"Yes\"\n    } else if str1_count == str2_count\
    \ && str1_rev_count == str2_rev_count {\n        return \"Yes\"\n    } else if\
    \ str1_rev_count == str2_rev_count && str1_count == str2_count {\n        return\
    \ \"Yes\"\n    } else if str1_count == str2_rev_count && str2_count == str1_rev_count\
    \ {\n        return \"Yes\"\n    } else if str1_rev_count == str2_count && str2_rev_count\
    \ == str1_count {\n        return \"Yes\"\n    } else if str1_count == str2_rev_count\
    \ && str2_count == str1_rev_count {\n        return \"Yes\"\n    } else if str1_rev_count\
    \ == str2_count && str2_rev_count == str1_count {\n        return \"Yes\"\n  \
    \  } else if str1_count == str2_count && str1_rev_\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp2dnqc6k1.swift:44:52: error: expected '{' after 'if' condition\n\
    \    } else if str1_count == str2_count && str1_rev_\n                       \
    \                            ^\n/tmp/tmp2dnqc6k1.swift:44:43: error: cannot find\
    \ 'str1_rev_' in scope\n    } else if str1_count == str2_count && str1_rev_\n\
    \                                          ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var left = 0\n \
    \   var right = 0\n    for char in lst[0] {\n        if char == \"(\" {\n    \
    \        left += 1\n        } else {\n            right += 1\n        }\n    }\n\
    \    for char in lst[1] {\n        if char == \"(\" {\n            left -= 1\n\
    \        } else {\n            right -= 1\n        }\n    }\n    if left == 0\
    \ && right == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpswf759wy/tmpswf759wy.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b860cb40c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b860c837b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b860c837988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b860c8367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpswf759wy                        0x00005627041096a6 <unavailable> + 5798

    5    libc.so.6                          0x00002b860cd2c460 __libc_start_main +
    245

    6    tmpswf759wy                        0x0000562704109289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var open = 0\n \
    \   var close = 0\n    for c in lst[0] {\n        if c == \"(\" {\n          \
    \  open += 1\n        } else {\n            close += 1\n        }\n    }\n   \
    \ for c in lst[1] {\n        if c == \"(\" {\n            open += 1\n        }\
    \ else {\n            close += 1\n        }\n    }\n    if open == close {\n \
    \       return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp1plf6uq4/tmp1plf6uq4.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b626ffe9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b626fce0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b626fce0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b626fcdf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1plf6uq4                        0x000055b467b95468 <unavailable> + 9320

    5    libc.so.6                          0x00002b62701d5460 __libc_start_main +
    245

    6    tmp1plf6uq4                        0x000055b467b94289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for i in lst {\n        s += i\n    }\n    var count = 0\n    for i in s {\n\
    \        if i == \"(\" {\n            count += 1\n        } else {\n         \
    \   count -= 1\n        }\n        if count < 0 {\n            return \"No\"\n\
    \        }\n    }\n    if count == 0 {\n        return \"Yes\"\n    } else {\n\
    \        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpy08bjsqz/tmpy08bjsqz.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1709aebc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b17097e2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b17097e2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b17097e17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy08bjsqz                        0x000055f2ce1a7c96 <unavailable> + 7318

    5    libc.so.6                          0x00002b1709cd7460 __libc_start_main +
    245

    6    tmpy08bjsqz                        0x000055f2ce1a73f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    var stack = [Character]()\n\
    \    for c in str {\n        if c == \"(\" {\n            stack.append(c)\n  \
    \      } else {\n            if stack.count > 0 {\n                stack.removeLast()\n\
    \            } else {\n                return \"No\"\n            }\n        }\n\
    \    }\n    return stack.count == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp26mspzz3/tmp26mspzz3.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1216c68c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b121695fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b121695f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b121695e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp26mspzz3                        0x0000558aa8b29e76 <unavailable> + 7798

    5    libc.so.6                          0x00002b1216e54460 __libc_start_main +
    245

    6    tmp26mspzz3                        0x0000558aa8b295d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for i in lst {\n        s += i\n    }\n    var c = 0\n    for i in s {\n \
    \       if i == \"(\" {\n            c += 1\n        } else {\n            c -=\
    \ 1\n        }\n        if c < 0 {\n            return \"No\"\n        }\n   \
    \ }\n    return c == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpoxlqpg06/tmpoxlqpg06.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3ece6bfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3ece3b6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3ece3b6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3ece3b57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoxlqpg06                        0x0000564ae660fc96 <unavailable> + 7318

    5    libc.so.6                          0x00002b3ece8ab460 __libc_start_main +
    245

    6    tmpoxlqpg06                        0x0000564ae660f3f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var open = 0\n \
    \   var close = 0\n    for char in lst[0] {\n        if char == \"(\" {\n    \
    \        open += 1\n        } else {\n            close += 1\n        }\n    }\n\
    \    for char in lst[1] {\n        if char == \"(\" {\n            open += 1\n\
    \        } else {\n            close += 1\n        }\n    }\n    if open == close\
    \ {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpyyy95a03/tmpyyy95a03.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4c56d49c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4c56a40b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4c56a40988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4c56a3f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyyy95a03                        0x000055e056c94468 <unavailable> + 9320

    5    libc.so.6                          0x00002b4c56f35460 __libc_start_main +
    245

    6    tmpyyy95a03                        0x000055e056c93289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack<Character>()\n\
    \    for char in lst[0] {\n        if char == \"(\" {\n            stack.push(char)\n\
    \        } else {\n            if stack.isEmpty() {\n                return \"\
    No\"\n            }\n            stack.pop()\n        }\n    }\n    for char in\
    \ lst[1] {\n        if char == \"(\" {\n            if stack.isEmpty() {\n   \
    \             return \"No\"\n            }\n            stack.pop()\n        }\
    \ else {\n            stack.push(char)\n        }\n    }\n    return stack.isEmpty()\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpv72ksz2x.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    while lst.count > 0 {\n        str += lst.removeFirst()\n\
    \        if str.count > 0 {\n            if str.last == \")\" {\n            \
    \    str.removeLast()\n            } else {\n                str.append(\")\"\
    )\n            }\n        }\n    }\n    return str.count == 0 ? \"Yes\" : \"No\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpwg6rzcfm/tmpwg6rzcfm.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acb814b0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acb811a7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acb811a7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acb811a67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwg6rzcfm                        0x00005584964b78c6 <unavailable> + 6342

    5    libc.so.6                          0x00002acb8169c460 __libc_start_main +
    245

    6    tmpwg6rzcfm                        0x00005584964b74a9 <unavailable> + 5289

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var count = 0\n    for i in 0..<lst.count {\n       \
    \ str += lst[i]\n    }\n    for i in 0..<str.count {\n        if str[str.index(str.startIndex,\
    \ offsetBy: i)] == \"(\" {\n            count += 1\n        } else {\n       \
    \     count -= 1\n        }\n        if count < 0 {\n            return \"No\"\
    \n        }\n    }\n    if count == 0 {\n        return \"Yes\"\n    } else {\n\
    \        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp3dmm3t3p/tmp3dmm3t3p.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6922201c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6921ef8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6921ef8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6921ef77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3dmm3t3p                        0x000056147a797e06 <unavailable> + 7686

    5    libc.so.6                          0x00002b69223ed460 __libc_start_main +
    245

    6    tmp3dmm3t3p                        0x000056147a797569 <unavailable> + 5481

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var lst_str = \"\"\n    for i in 0..<lst.count {\n        lst_str += lst[i]\n\
    \    }\n    var stack = Stack<Character>()\n    for i in 0..<lst_str.count {\n\
    \        let char = lst_str[lst_str.index(lst_str.startIndex, offsetBy: i)]\n\
    \        if char == \"(\" {\n            stack.push(char)\n        } else if char\
    \ == \")\" {\n            if stack.isEmpty() {\n                return \"No\"\n\
    \            } else {\n                stack.pop()\n            }\n        }\n\
    \    }\n    if stack.isEmpty() {\n        return \"Yes\"\n    } else {\n     \
    \   return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpjd6bettg.swift:21:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    var stack = [Character]()\n\
    \    for c in str {\n        if c == \"(\" {\n            stack.append(c)\n  \
    \      } else {\n            if stack.count == 0 {\n                return \"\
    No\"\n            }\n            stack.removeLast()\n        }\n    }\n    return\
    \ stack.count == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpcg07odb7/tmpcg07odb7.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba8ae222c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba8adf19b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba8adf19988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba8adf187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcg07odb7                        0x00005579e4ac4e76 <unavailable> + 7798

    5    libc.so.6                          0x00002ba8ae40e460 __libc_start_main +
    245

    6    tmpcg07odb7                        0x00005579e4ac45d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    while lst.count > 0 {\n        if lst[0].count > lst[1].count\
    \ {\n            str += lst[0]\n            lst.remove(at: 0)\n        } else\
    \ {\n            str += lst[1]\n            lst.remove(at: 1)\n        }\n   \
    \ }\n    var count = 0\n    for c in str {\n        if c == \"(\" {\n        \
    \    count += 1\n        } else {\n            count -= 1\n        }\n       \
    \ if count < 0 {\n            return \"No\"\n        }\n    }\n    return \"Yes\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8ec984dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8ec9544561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8ec9544286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8ec954413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8ec9543bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8ec9343fc3 <unavailable> + 188355

    6    tmpm1vg7uc3                        0x000055c159d1fa17 <unavailable> + 10775

    7    tmpm1vg7uc3                        0x000055c159d1e735 <unavailable> + 5941

    8    libc.so.6                          0x00002b8ec9a39460 __libc_start_main +
    245

    9    tmpm1vg7uc3                        0x000055c159d1e3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var count = 0\n    for i in 0..<lst.count {\n       \
    \ if lst[i].count == 0 {\n            lst.remove(at: i)\n        }\n    }\n  \
    \  if lst.count == 0 {\n        return \"Yes\"\n    }\n    for i in 0..<lst.count\
    \ {\n        for j in 0..<lst[i].count {\n            if lst[i][j] == \"(\" {\n\
    \                count += 1\n            } else {\n                count -= 1\n\
    \            }\n            if count < 0 {\n                return \"No\"\n  \
    \          }\n        }\n    }\n    if count == 0 {\n        return \"Yes\"\n\
    \    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmppe1uju50.swift:29:16: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n            if lst[i][j]\
    \ == \"(\" {\n               ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmppe1uju50.swift:17:9: warning: initialization\
    \ of variable 'str' was never used; consider replacing with assignment to '_'\
    \ or removing it\n    var str = \"\"\n    ~~~~^~~\n    _\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [Character]()\n\
    \    var str = \"\"\n    for i in 0..<lst.count {\n        str += lst[i]\n   \
    \ }\n    for char in str {\n        if char == \"(\" {\n            stack.append(char)\n\
    \        } else {\n            if stack.count == 0 {\n                return \"\
    No\"\n            } else {\n                stack.removeLast()\n            }\n\
    \        }\n    }\n    if stack.count == 0 {\n        return \"Yes\"\n    } else\
    \ {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpklafjtyy/tmpklafjtyy.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6916654c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b691634bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b691634b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b691634a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpklafjtyy                        0x0000564edb268f46 <unavailable> + 8006

    5    libc.so.6                          0x00002b6916840460 __libc_start_main +
    245

    6    tmpklafjtyy                        0x0000564edb2686a9 <unavailable> + 5801

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var count = 0\n\
    \    for char in lst[0] {\n        if char == \"(\" {\n            count += 1\n\
    \        } else {\n            count -= 1\n        }\n    }\n    for char in lst[1]\
    \ {\n        if char == \"(\" {\n            count += 1\n        } else {\n  \
    \          count -= 1\n        }\n    }\n    if count == 0 {\n        return \"\
    Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpv0cfakhs/tmpv0cfakhs.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b817fddec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b817fad5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b817fad5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b817fad47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv0cfakhs                        0x00005594bc5fe468 <unavailable> + 9320

    5    libc.so.6                          0x00002b817ffca460 __libc_start_main +
    245

    6    tmpv0cfakhs                        0x00005594bc5fd289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let s1 = lst[0]\n\
    \    let s2 = lst[1]\n    let s1_count = s1.count\n    let s2_count = s2.count\n\
    \    var s1_open = 0\n    var s2_open = 0\n    var s1_close = 0\n    var s2_close\
    \ = 0\n    for i in 0..<s1_count {\n        if s1[i] == \"(\" {\n            s1_open\
    \ += 1\n        } else {\n            s1_close += 1\n        }\n    }\n    for\
    \ i in 0..<s2_count {\n        if s2[i] == \"(\" {\n            s2_open += 1\n\
    \        } else {\n            s2_close += 1\n        }\n    }\n    if s1_open\
    \ == s1_close && s2_open == s2_close {\n        return \"Yes\"\n    }\n    if\
    \ s1_open > s1_close && s2_open > s2_close {\n        return \"Yes\"\n    }\n\
    \    if s1_open < s1_close && s2_open < s2_close {\n        return \"Yes\"\n \
    \   }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp9gzeo6d_.swift:25:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if s1[i]\
    \ == \"(\" {\n           ^~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp9gzeo6d_.swift:32:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if s2[i] == \"(\" {\n           ^~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    var count = 0\n    for c in\
    \ str {\n        if c == \"(\" {\n            count += 1\n        } else {\n \
    \           count -= 1\n        }\n        if count < 0 {\n            return\
    \ \"No\"\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmptan6oan_/tmptan6oan_.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f38400c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f380f7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8f380f7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8f380f67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptan6oan_                        0x000055a83b5e4c96 <unavailable> + 7318

    5    libc.so.6                          0x00002b8f385ec460 __libc_start_main +
    245

    6    tmptan6oan_                        0x000055a83b5e43f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    var count = 0\n    for c in\
    \ str {\n        if c == \"(\" {\n            count += 1\n        } else {\n \
    \           count -= 1\n        }\n        if count < 0 {\n            return\
    \ \"No\"\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmptan6oan_/tmptan6oan_.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f38400c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f380f7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8f380f7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8f380f67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptan6oan_                        0x000055a83b5e4c96 <unavailable> + 7318

    5    libc.so.6                          0x00002b8f385ec460 __libc_start_main +
    245

    6    tmptan6oan_                        0x000055a83b5e43f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for i in lst {\n        s += i\n    }\n    var c = 0\n    for i in s {\n \
    \       if i == \"(\" {\n            c += 1\n        } else {\n            c -=\
    \ 1\n        }\n        if c < 0 {\n            return \"No\"\n        }\n   \
    \ }\n    return c == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpoxlqpg06/tmpoxlqpg06.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3ece6bfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3ece3b6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3ece3b6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3ece3b57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoxlqpg06                        0x0000564ae660fc96 <unavailable> + 7318

    5    libc.so.6                          0x00002b3ece8ab460 __libc_start_main +
    245

    6    tmpoxlqpg06                        0x0000564ae660f3f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for str in lst {\n        s += str\n    }\n    var stack = Stack<Character>()\n\
    \    for c in s {\n        if c == \"(\" {\n            stack.push(c)\n      \
    \  } else {\n            if stack.isEmpty() {\n                return \"No\"\n\
    \            }\n            stack.pop()\n        }\n    }\n    return stack.isEmpty()\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp7jd0p3qt.swift:20:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for i in lst {\n        s += i\n    }\n    var stack = [Character]()\n   \
    \ for c in s {\n        if c == \"(\" {\n            stack.append(c)\n       \
    \ } else {\n            if stack.isEmpty {\n                return \"No\"\n  \
    \          } else {\n                stack.removeLast()\n            }\n     \
    \   }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp562j7amu/tmp562j7amu.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afd00dd2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afd00ac9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afd00ac9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afd00ac87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp562j7amu                        0x000056476c43be76 <unavailable> + 7798

    5    libc.so.6                          0x00002afd00fbe460 __libc_start_main +
    245

    6    tmp562j7amu                        0x000056476c43b5d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = lst[0] +\
    \ lst[1]\n    var count = 0\n    for c in s {\n        if c == \"(\" {\n     \
    \       count += 1\n        } else {\n            count -= 1\n        }\n    \
    \    if count < 0 {\n            return \"No\"\n        }\n    }\n    return count\
    \ == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpf1k5bpgp/tmpf1k5bpgp.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad1c3fe6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad1c3cddb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad1c3cdd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad1c3cdc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf1k5bpgp                        0x0000564535cb9b76 <unavailable> + 7030

    5    libc.so.6                          0x00002ad1c41d2460 __libc_start_main +
    245

    6    tmpf1k5bpgp                        0x0000564535cb92d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0]\n\
    \    let str2 = lst[1]\n    let str1_good = is_good(str: str1)\n    let str2_good\
    \ = is_good(str: str2)\n    if str1_good && str2_good {\n        return \"Yes\"\
    \n    }\n    if str1_good && !str2_good {\n        return \"Yes\"\n    }\n   \
    \ if !str1_good && str2_good {\n        return \"Yes\"\n    }\n    return \"No\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp2zwto15g.swift:18:21: error: cannot find 'is_good' in scope\n \
    \   let str1_good = is_good(str: str1)\n                    ^~~~~~~\n/tmp/tmp2zwto15g.swift:19:21:\
    \ error: cannot find 'is_good' in scope\n    let str2_good = is_good(str: str2)\n\
    \                    ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    let str1 = lst.removeFirst()\n    let str2 = lst.removeFirst()\n    let str\
    \ = str1 + str2\n    var stack = [Character]()\n    for char in str {\n      \
    \  if char == \"(\" {\n            stack.append(char)\n        } else {\n    \
    \        if stack.isEmpty {\n                return \"No\"\n            } else\
    \ {\n                stack.removeLast()\n            }\n        }\n    }\n   \
    \ return stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpe64wyqlw/tmpe64wyqlw.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba90fb0ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba90f801b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba90f801988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba90f8007b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe64wyqlw                        0x0000563c5f988da6 <unavailable> + 7590

    5    libc.so.6                          0x00002ba90fcf6460 __libc_start_main +
    245

    6    tmpe64wyqlw                        0x0000563c5f988509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var count = 0\n    for i in 0..<lst.count {\n       \
    \ str += lst[i]\n    }\n    for i in 0..<str.count {\n        if str[i] == \"\
    (\" {\n            count += 1\n        } else {\n            count -= 1\n    \
    \    }\n        if count < 0 {\n            return \"No\"\n        }\n    }\n\
    \    if count == 0 {\n        return \"Yes\"\n    } else {\n        return \"\
    No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmplkxfsp_6.swift:23:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if str[i]\
    \ == \"(\" {\n           ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmplkxfsp_6.swift:16:9: warning: variable 'lst'\
    \ was never mutated; consider changing to 'let' constant\n    var lst = lst\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    for i in 0..<lst.count {\n        str += lst[i]\n   \
    \ }\n    var stack = Stack<Character>()\n    for char in str {\n        if char\
    \ == \"(\" {\n            stack.push(char)\n        } else {\n            if stack.isEmpty()\
    \ {\n                return \"No\"\n            } else {\n                stack.pop()\n\
    \            }\n        }\n    }\n    if stack.isEmpty() {\n        return \"\
    Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmptlu9parg.swift:21:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s1 = lst[0]\n\
    \    var s2 = lst[1]\n    var count = 0\n    for c in s1 {\n        if c == \"\
    (\" {\n            count += 1\n        } else {\n            count -= 1\n    \
    \    }\n    }\n    for c in s2 {\n        if c == \"(\" {\n            count +=\
    \ 1\n        } else {\n            count -= 1\n        }\n    }\n    if count\
    \ == 0 {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpqc2jy115/tmpqc2jy115.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5fe5e49c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5fe5b40b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5fe5b40988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5fe5b3f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqc2jy115                        0x000055ce92dca468 <unavailable> + 9320

    5    libc.so.6                          0x00002b5fe6035460 __libc_start_main +
    245

    6    tmpqc2jy115                        0x000055ce92dc9289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var result = \"Yes\"\n    var stack = [Character]()\n    for i in 0..<lst.count\
    \ {\n        for char in lst[i] {\n            if char == \"(\" {\n          \
    \      stack.append(char)\n            } else {\n                if stack.count\
    \ == 0 {\n                    result = \"No\"\n                    break\n   \
    \             } else {\n                    stack.removeLast()\n             \
    \   }\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpxmu7_kyd/tmpxmu7_kyd.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0effac0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0eff7b7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0eff7b7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0eff7b67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxmu7_kyd                        0x000055a46d4e9ee6 <unavailable> + 7910

    5    libc.so.6                          0x00002b0effcac460 __libc_start_main +
    245

    6    tmpxmu7_kyd                        0x000055a46d4e9649 <unavailable> + 5705

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = lst[0] +\
    \ lst[1]\n    var count = 0\n    for c in s {\n        if c == \"(\" {\n     \
    \       count += 1\n        } else {\n            count -= 1\n        }\n    \
    \    if count < 0 {\n            return \"No\"\n        }\n    }\n    return count\
    \ == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpf1k5bpgp/tmpf1k5bpgp.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad1c3fe6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad1c3cddb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad1c3cdd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad1c3cdc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf1k5bpgp                        0x0000564535cb9b76 <unavailable> + 7030

    5    libc.so.6                          0x00002ad1c41d2460 __libc_start_main +
    245

    6    tmpf1k5bpgp                        0x0000564535cb92d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0]\n\
    \    let str2 = lst[1]\n    let str = str1 + str2\n    var stack = [Character]()\n\
    \    for c in str {\n        if c == \"(\" {\n            stack.append(c)\n  \
    \      } else {\n            if stack.isEmpty {\n                return \"No\"\
    \n            } else {\n                stack.removeLast()\n            }\n  \
    \      }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp0wbld0z1/tmp0wbld0z1.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6be964ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6be9341b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6be9341988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6be93407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0wbld0z1                        0x0000563ec3cceda6 <unavailable> + 7590

    5    libc.so.6                          0x00002b6be9836460 __libc_start_main +
    245

    6    tmp0wbld0z1                        0x0000563ec3cce509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var lst_str = lst.joined()\n    var count = 0\n    for char in lst_str {\n\
    \        if char == \"(\" {\n            count += 1\n        } else {\n      \
    \      count -= 1\n        }\n        if count < 0 {\n            return \"No\"\
    \n        }\n    }\n    if count == 0 {\n        return \"Yes\"\n    } else {\n\
    \        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpgk6d006r/tmpgk6d006r.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae7bbac3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae7bb7bab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae7bb7ba988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae7bb7b97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgk6d006r                        0x00005579478b2b76 <unavailable> + 7030

    5    libc.so.6                          0x00002ae7bbcaf460 __libc_start_main +
    245

    6    tmpgk6d006r                        0x00005579478b22d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824580
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = lst[0] +\
    \ lst[1]\n    var c = 0\n    for ch in s {\n        if ch == \"(\" {\n       \
    \     c += 1\n        } else {\n            c -= 1\n        }\n        if c <\
    \ 0 {\n            return \"No\"\n        }\n    }\n    return c == 0 ? \"Yes\"\
    \ : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp_tqimsco/tmp_tqimsco.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4969fddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4969cd4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4969cd4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4969cd37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_tqimsco                        0x0000562a1f1f9b76 <unavailable> + 7030

    5    libc.so.6                          0x00002b496a1c9460 __libc_start_main +
    245

    6    tmp_tqimsco                        0x0000562a1f1f92d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824580
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var lst_str = \"\"\n    for i in 0..<lst.count {\n        lst_str += lst[i]\n\
    \    }\n    var stack = Stack<Character>()\n    for char in lst_str {\n      \
    \  if char == \"(\" {\n            stack.push(char)\n        } else if char ==\
    \ \")\" {\n            if stack.isEmpty {\n                return \"No\"\n   \
    \         } else {\n                stack.pop()\n            }\n        }\n  \
    \  }\n    if stack.isEmpty {\n        return \"Yes\"\n    } else {\n        return\
    \ \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmphydo62vp.swift:21:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var count = 0\n    for i in 0..<lst.count {\n       \
    \ str += lst[i]\n    }\n    for i in 0..<str.count {\n        if str[i] == \"\
    (\" {\n            count += 1\n        } else {\n            count -= 1\n    \
    \    }\n        if count < 0 {\n            return \"No\"\n        }\n    }\n\
    \    if count == 0 {\n        return \"Yes\"\n    } else {\n        return \"\
    No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmplkxfsp_6.swift:23:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if str[i]\
    \ == \"(\" {\n           ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmplkxfsp_6.swift:16:9: warning: variable 'lst'\
    \ was never mutated; consider changing to 'let' constant\n    var lst = lst\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s1 = lst[0]\n\
    \    var s2 = lst[1]\n    var count = 0\n    for c in s1 {\n        if c == \"\
    (\" {\n            count += 1\n        } else {\n            count -= 1\n    \
    \    }\n    }\n    for c in s2 {\n        if c == \"(\" {\n            count +=\
    \ 1\n        } else {\n            count -= 1\n        }\n    }\n    if count\
    \ == 0 {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpqc2jy115/tmpqc2jy115.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5fe5e49c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5fe5b40b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5fe5b40988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5fe5b3f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqc2jy115                        0x000055ce92dca468 <unavailable> + 9320

    5    libc.so.6                          0x00002b5fe6035460 __libc_start_main +
    245

    6    tmpqc2jy115                        0x000055ce92dc9289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var left = 0\n    var right = 0\n    for i in 0..<lst.count {\n        for\
    \ j in 0..<lst[i].count {\n            if lst[i][j] == \"(\" {\n             \
    \   left += 1\n            } else {\n                right += 1\n            }\n\
    \        }\n    }\n    if left == right {\n        return \"Yes\"\n    }\n   \
    \ return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpu277wgj2.swift:21:16: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n            if lst[i][j]\
    \ == \"(\" {\n               ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpu277wgj2.swift:16:9: warning: variable\
    \ 'lst' was never mutated; consider changing to 'let' constant\n    var lst =\
    \ lst\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0]\n\
    \    let str2 = lst[1]\n    let str1_count = str1.count\n    let str2_count =\
    \ str2.count\n    let str1_open = str1.filter { $0 == \"(\" }.count\n    let str1_close\
    \ = str1.filter { $0 == \")\" }.count\n    let str2_open = str2.filter { $0 ==\
    \ \"(\" }.count\n    let str2_close = str2.filter { $0 == \")\" }.count\n    let\
    \ str1_open_close = str1_open - str1_close\n    let str2_open_close = str2_open\
    \ - str2_close\n    let str1_open_close_abs = abs(str1_open_close)\n    let str2_open_close_abs\
    \ = abs(str2_open_close)\n    let str1_open_close_abs_even = str1_open_close_abs\
    \ % 2 == 0\n    let str2_open_close_abs_even = str2_open_close_abs % 2 == 0\n\
    \    let str1_open_close_even = str1_open_close % 2 == 0\n    let str2_open_close_even\
    \ = str2_open_close % 2 == 0\n    let str1_open_close_even_str2_open_close_even\
    \ = str1_open_close_even && str2_open_close_even\n    let str1_open_close_even_str2_open_close_abs_even\
    \ = str1_open_close_even && str2_open_close_abs_even\n    let str1_open_close_abs_even_str2_open_close_even\
    \ = str1_open_close_abs_even && str2_open_close_even\n    let str1_open_close_abs_even_str2_open_close_abs_even\
    \ = str1_open_close_abs_even && str2_open_close_abs_even\n    let str1_open_close_even_str2_open_close_even_str1_open_close_abs_even_str2_open_close\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpeiiyomc5.swift:36:9: error: type annotation missing in pattern\n\
    \    let str1_open_close_even_str2_open_close_even_str1_open_close_abs_even_str2_open_close\n\
    \        ^\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0]\n\
    \    let str2 = lst[1]\n    let str1_count = str1.count\n    let str2_count =\
    \ str2.count\n    var str1_open = 0\n    var str1_close = 0\n    var str2_open\
    \ = 0\n    var str2_close = 0\n    var str1_open_arr = [Int]()\n    var str1_close_arr\
    \ = [Int]()\n    var str2_open_arr = [Int]()\n    var str2_close_arr = [Int]()\n\
    \    var str1_open_arr_count = 0\n    var str1_close_arr_count = 0\n    var str2_open_arr_count\
    \ = 0\n    var str2_close_arr_count = 0\n    var str1_open_arr_index = 0\n   \
    \ var str1_close_arr_index = 0\n    var str2_open_arr_index = 0\n    var str2_close_arr_index\
    \ = 0\n    var str1_open_arr_index_count = 0\n    var str1_close_arr_index_count\
    \ = 0\n    var str2_open_arr_index_count = 0\n    var str2_close_arr_index_count\
    \ = 0\n    var str1_open_arr_index_count_count = 0\n    var str1_close_arr_index_count_count\
    \ = 0\n    var str2_open_arr_index_count_count = 0\n    var str2_close_arr_index_count_count\
    \ = 0\n    var str1_open_arr_index_count_count_count = 0\n    var str1_close_arr_index_count_count_count\
    \ = 0\n    var str2_open_arr_index_count_count_count = 0\n    var str2_close_arr_index_count_count_count\
    \ = 0\n    var str1_open_arr_index_count_count_count_count = 0\n    var str1_close_arr_index_count_count_count_count\
    \ = 0\n    var str2_open_arr_index_count_count_count_count = 0\n    var\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp75a06rah.swift:51:8: error: expected pattern\n    var\n       ^\n\
    /tmp/tmp75a06rah.swift:18:9: warning: initialization of immutable value 'str1_count'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   let str1_count = str1.count\n    ~~~~^~~~~~~~~~\n    _\n/tmp/tmp75a06rah.swift:19:9:\
    \ warning: initialization of immutable value 'str2_count' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    let str2_count = str2.count\n\
    \    ~~~~^~~~~~~~~~\n    _\n/tmp/tmp75a06rah.swift:20:9: warning: initialization\
    \ of variable 'str1_open' was never used; consider replacing with assignment to\
    \ '_' or removing it\n    var str1_open = 0\n    ~~~~^~~~~~~~~\n    _\n/tmp/tmp75a06rah.swift:21:9:\
    \ warning: initialization of variable 'str1_close' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var str1_close = 0\n    ~~~~^~~~~~~~~~\n\
    \    _\n/tmp/tmp75a06rah.swift:22:9: warning: initialization of variable 'str2_open'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var str2_open = 0\n    ~~~~^~~~~~~~~\n    _\n/tmp/tmp75a06rah.swift:23:9:\
    \ warning: initialization of variable 'str2_close' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var str2_close = 0\n    ~~~~^~~~~~~~~~\n\
    \    _\n/tmp/tmp75a06rah.swift:24:9: warning: initialization of variable 'str1_open_arr'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var str1_open_arr = [Int]()\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmp75a06rah.swift:25:9:\
    \ warning: initialization of variable 'str1_close_arr' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var str1_close_arr = [Int]()\n\
    \    ~~~~^~~~~~~~~~~~~~\n    _\n/tmp/tmp75a06rah.swift:26:9: warning: initialization\
    \ of variable 'str2_open_arr' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var str2_open_arr = [Int]()\n    ~~~~^~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp75a06rah.swift:27:9: warning: initialization of variable 'str2_close_arr'\
    \ was never used; consider replac"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    while lst.count > 0 {\n        str += lst.removeFirst()\n\
    \        if str.count > 0 {\n            if str.last == \")\" {\n            \
    \    str.removeLast()\n            } else {\n                str.append(\")\"\
    )\n            }\n        }\n    }\n    return str.count == 0 ? \"Yes\" : \"No\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpwg6rzcfm/tmpwg6rzcfm.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acb814b0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acb811a7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acb811a7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acb811a67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwg6rzcfm                        0x00005584964b78c6 <unavailable> + 6342

    5    libc.so.6                          0x00002acb8169c460 __libc_start_main +
    245

    6    tmpwg6rzcfm                        0x00005584964b74a9 <unavailable> + 5289

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = lst[0]\
    \ + lst[1]\n    var stack = [Character]()\n    for c in str {\n        if c ==\
    \ \"(\" {\n            stack.append(c)\n        } else {\n            if stack.isEmpty\
    \ {\n                return \"No\"\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpxmur0gu4/tmpxmur0gu4.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b48e819ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48e7e91b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b48e7e91988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b48e7e907b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxmur0gu4                        0x000055dd7e935da6 <unavailable> + 7590

    5    libc.so.6                          0x00002b48e8386460 __libc_start_main +
    245

    6    tmpxmur0gu4                        0x000055dd7e935509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let s1 = lst[0]\n\
    \    let s2 = lst[1]\n    let s3 = s1 + s2\n    let s4 = s2 + s1\n    if is_balanced(s:\
    \ s3) {\n        return \"Yes\"\n    } else if is_balanced(s: s4) {\n        return\
    \ \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp2w3y94mh.swift:20:8: error: cannot find 'is_balanced' in scope\n\
    \    if is_balanced(s: s3) {\n       ^~~~~~~~~~~\n/tmp/tmp2w3y94mh.swift:22:15:\
    \ error: cannot find 'is_balanced' in scope\n    } else if is_balanced(s: s4)\
    \ {\n              ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var count = 0\n    for i in 0..<lst.count {\n       \
    \ if lst[i].count == 0 {\n            lst.remove(at: i)\n        }\n    }\n  \
    \  if lst.count == 1 {\n        return \"Yes\"\n    }\n    for i in 0..<lst.count\
    \ {\n        str += lst[i]\n    }\n    for i in 0..<str.count {\n        if str[i]\
    \ == \"(\" {\n            count += 1\n        } else {\n            count -= 1\n\
    \        }\n        if count < 0 {\n            return \"No\"\n        }\n   \
    \ }\n    if count == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpt2m95zu3.swift:31:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if str[i]\
    \ == \"(\" {\n           ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var count = 0\n    for i in 0..<lst.count {\n       \
    \ str += lst[i]\n    }\n    for i in 0..<str.count {\n        if str[i] == \"\
    (\" {\n            count += 1\n        } else {\n            count -= 1\n    \
    \    }\n        if count < 0 {\n            return \"No\"\n        }\n    }\n\
    \    if count == 0 {\n        return \"Yes\"\n    } else {\n        return \"\
    No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmplkxfsp_6.swift:23:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if str[i]\
    \ == \"(\" {\n           ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmplkxfsp_6.swift:16:9: warning: variable 'lst'\
    \ was never mutated; consider changing to 'let' constant\n    var lst = lst\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var left = 0\n \
    \   var right = 0\n    for c in lst[0] {\n        if c == \"(\" {\n          \
    \  left += 1\n        } else {\n            right += 1\n        }\n    }\n   \
    \ for c in lst[1] {\n        if c == \"(\" {\n            left -= 1\n        }\
    \ else {\n            right -= 1\n        }\n    }\n    if left < 0 || right <\
    \ 0 {\n        return \"No\"\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpy7ttljxw/tmpy7ttljxw.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b05ed6d2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b05ed3c9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b05ed3c9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b05ed3c87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy7ttljxw                        0x000055b1de5c4810 <unavailable> + 6160

    5    libc.so.6                          0x00002b05ed8be460 __libc_start_main +
    245

    6    tmpy7ttljxw                        0x000055b1de5c4289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824580
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    var count = 0\n    for c in\
    \ str {\n        if c == \"(\" {\n            count += 1\n        } else {\n \
    \           count -= 1\n        }\n        if count < 0 {\n            return\
    \ \"No\"\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmptan6oan_/tmptan6oan_.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f38400c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f380f7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8f380f7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8f380f67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptan6oan_                        0x000055a83b5e4c96 <unavailable> + 7318

    5    libc.so.6                          0x00002b8f385ec460 __libc_start_main +
    245

    6    tmptan6oan_                        0x000055a83b5e43f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack<Character>()\n\
    \    for c in lst[0] {\n        if c == \"(\" {\n            stack.push(c)\n \
    \       } else {\n            if stack.isEmpty() {\n                return \"\
    No\"\n            }\n            stack.pop()\n        }\n    }\n    for c in lst[1]\
    \ {\n        if c == \"(\" {\n            if stack.isEmpty() {\n             \
    \   return \"No\"\n            }\n            stack.pop()\n        } else {\n\
    \            stack.push(c)\n        }\n    }\n    return stack.isEmpty() ? \"\
    Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpy8snl3vg.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    for i in 0..<lst.count {\n        if i == 0 {\n     \
    \       str += lst[i]\n        } else {\n            str += lst[i]\n         \
    \   if str.count > 1 {\n                if str[str.index(before: str.endIndex)]\
    \ == \"(\" && str[str.index(after: str.startIndex)] == \")\" {\n             \
    \       str.remove(at: str.index(before: str.endIndex))\n                    str.remove(at:\
    \ str.index(after: str.startIndex))\n                }\n            }\n      \
    \  }\n    }\n    if str.count == 0 {\n        return \"Yes\"\n    } else {\n \
    \       return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmppdiwk9d6/tmppdiwk9d6.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b843e81dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b843e514b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b843e514988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b843e5137b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppdiwk9d6                        0x000055d224da6a96 <unavailable> + 6806

    5    libc.so.6                          0x00002b843ea09460 __libc_start_main +
    245

    6    tmppdiwk9d6                        0x000055d224da6679 <unavailable> + 5753

    '
  stdout: ''
  timestamp: 1659824580
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var count = 0\n    var flag = false\n    for i in 0..<lst.count\
    \ {\n        str += lst[i]\n    }\n    for i in 0..<str.count {\n        if str[i]\
    \ == \"(\" {\n            count += 1\n        } else {\n            count -= 1\n\
    \        }\n        if count < 0 {\n            flag = true\n            break\n\
    \        }\n    }\n    if flag || count != 0 {\n        return \"No\"\n    }\n\
    \    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp5irzsiga.swift:24:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if str[i]\
    \ == \"(\" {\n           ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp5irzsiga.swift:16:9: warning: variable 'lst'\
    \ was never mutated; consider changing to 'let' constant\n    var lst = lst\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var count = 0\n    for i in 0..<lst.count {\n       \
    \ if lst[i].count == 0 {\n            lst.remove(at: i)\n        }\n    }\n  \
    \  if lst.count == 0 {\n        return \"Yes\"\n    }\n    if lst.count == 1 {\n\
    \        for char in lst[0] {\n            if char == \"(\" {\n              \
    \  count += 1\n            } else {\n                count -= 1\n            }\n\
    \            if count < 0 {\n                return \"No\"\n            }\n  \
    \      }\n        if count == 0 {\n            return \"Yes\"\n        } else\
    \ {\n            return \"No\"\n        }\n    }\n    for i in 0..<lst.count {\n\
    \        str += lst[i]\n    }\n    for char in str {\n        if char == \"(\"\
    \ {\n            count += 1\n        } else {\n            count -= 1\n      \
    \  }\n        if count < 0 {\n            return \"No\"\n        }\n    }\n  \
    \  if count == 0 {\n        return \"Yes\"\n    } else {\n        return \"No\"\
    \n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\"\
    , \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpyb21ge01/tmpyb21ge01.swift:80: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab68f643c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab68f33ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab68f33a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab68f3397b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyb21ge01                        0x00005567f360de06 <unavailable> + 7686

    5    libc.so.6                          0x00002ab68f82f460 __libc_start_main +
    245

    6    tmpyb21ge01                        0x00005567f360d569 <unavailable> + 5481

    '
  stdout: ''
  timestamp: 1659824580
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    for i in 0..<lst.count {\n        str += lst[i]\n   \
    \ }\n    var stack = [Character]()\n    for char in str {\n        if char ==\
    \ \"(\" {\n            stack.append(char)\n        } else {\n            if stack.isEmpty\
    \ {\n                return \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpqrw5klky/tmpqrw5klky.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1b3507cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1b34d73b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1b34d73988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1b34d727b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqrw5klky                        0x000055d0a4c76f86 <unavailable> + 8070

    5    libc.so.6                          0x00002b1b35268460 __libc_start_main +
    245

    6    tmpqrw5klky                        0x000055d0a4c766e9 <unavailable> + 5865

    '
  stdout: ''
  timestamp: 1659824580
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    for i in 0..<lst.count {\n        if i == 0 {\n     \
    \       str = lst[i]\n        } else {\n            str += lst[i]\n        }\n\
    \    }\n    var count = 0\n    for char in str {\n        if char == \"(\" {\n\
    \            count += 1\n        } else if char == \")\" {\n            count\
    \ -= 1\n        }\n        if count < 0 {\n            return \"No\"\n       \
    \ }\n    }\n    if count == 0 {\n        return \"Yes\"\n    } else {\n      \
    \  return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmple6zv70i/tmple6zv70i.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002affcfa4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002affcf741b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002affcf741988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002affcf7407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmple6zv70i                        0x000056028ed38d56 <unavailable> + 7510

    5    libc.so.6                          0x00002affcfc36460 __libc_start_main +
    245

    6    tmple6zv70i                        0x000056028ed384b9 <unavailable> + 5305

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var parens = \"\"\n    for i in 0..<lst.count {\n        parens += lst[i]\n\
    \    }\n    var count = 0\n    for i in 0..<parens.count {\n        if parens[i]\
    \ == \"(\" {\n            count += 1\n        } else {\n            count -= 1\n\
    \        }\n        if count < 0 {\n            return \"No\"\n        }\n   \
    \ }\n    if count == 0 {\n        return \"Yes\"\n    } else {\n        return\
    \ \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp3yirvp8f.swift:23:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if parens[i]\
    \ == \"(\" {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp3yirvp8f.swift:16:9: warning: variable 'lst'\
    \ was never mutated; consider changing to 'let' constant\n    var lst = lst\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824580
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = lst[0]\
    \ + lst[1]\n    var count = 0\n    for c in str {\n        if c == \"(\" {\n \
    \           count += 1\n        } else {\n            count -= 1\n        }\n\
    \        if count < 0 {\n            return \"No\"\n        }\n    }\n    return\
    \ count == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpc9g02w8d/tmpc9g02w8d.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b89356d4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b89353cbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b89353cb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b89353ca7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc9g02w8d                        0x0000563f0c606b76 <unavailable> + 7030

    5    libc.so.6                          0x00002b89358c0460 __libc_start_main +
    245

    6    tmpc9g02w8d                        0x0000563f0c6062d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var count = 0\n    var i = 0\n    while i < lst.count\
    \ {\n        if lst[i] == \")\" {\n            count -= 1\n            if count\
    \ < 0 {\n                return \"No\"\n            }\n        } else {\n    \
    \        count += 1\n        }\n        str += lst[i]\n        i += 1\n    }\n\
    \    if count == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmptby91bic/tmptby91bic.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aadc8381c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aadc8078b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aadc8078988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aadc80777b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptby91bic                        0x000055d40bf02a26 <unavailable> + 6694

    5    libc.so.6                          0x00002aadc856d460 __libc_start_main +
    245

    6    tmptby91bic                        0x000055d40bf02189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824580
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var open = 0\n \
    \   var close = 0\n    for c in lst[0] {\n        if c == \"(\" {\n          \
    \  open += 1\n        } else {\n            close += 1\n        }\n    }\n   \
    \ for c in lst[1] {\n        if c == \"(\" {\n            open += 1\n        }\
    \ else {\n            close += 1\n        }\n    }\n    if open == close {\n \
    \       return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp1plf6uq4/tmp1plf6uq4.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b626ffe9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b626fce0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b626fce0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b626fcdf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1plf6uq4                        0x000055b467b95468 <unavailable> + 9320

    5    libc.so.6                          0x00002b62701d5460 __libc_start_main +
    245

    6    tmp1plf6uq4                        0x000055b467b94289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var count = 0\n    for i in 0..<lst.count {\n       \
    \ str += lst[i]\n    }\n    for i in 0..<str.count {\n        if str[i] == \"\
    (\" {\n            count += 1\n        } else {\n            count -= 1\n    \
    \    }\n        if count < 0 {\n            return \"No\"\n        }\n    }\n\
    \    if count == 0 {\n        return \"Yes\"\n    } else {\n        return \"\
    No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmplkxfsp_6.swift:23:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if str[i]\
    \ == \"(\" {\n           ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmplkxfsp_6.swift:16:9: warning: variable 'lst'\
    \ was never mutated; consider changing to 'let' constant\n    var lst = lst\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var count = 0\n\
    \    for char in lst[0] {\n        if char == \"(\" {\n            count += 1\n\
    \        } else {\n            count -= 1\n        }\n    }\n    for char in lst[1]\
    \ {\n        if char == \"(\" {\n            count += 1\n        } else {\n  \
    \          count -= 1\n        }\n    }\n    if count == 0 {\n        return \"\
    Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpv0cfakhs/tmpv0cfakhs.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b817fddec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b817fad5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b817fad5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b817fad47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv0cfakhs                        0x00005594bc5fe468 <unavailable> + 9320

    5    libc.so.6                          0x00002b817ffca460 __libc_start_main +
    245

    6    tmpv0cfakhs                        0x00005594bc5fd289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = lst[0] +\
    \ lst[1]\n    var count = 0\n    for c in s {\n        if c == \"(\" {\n     \
    \       count += 1\n        } else {\n            count -= 1\n        }\n    \
    \    if count < 0 {\n            return \"No\"\n        }\n    }\n    return count\
    \ == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpf1k5bpgp/tmpf1k5bpgp.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad1c3fe6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad1c3cddb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad1c3cdd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad1c3cdc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf1k5bpgp                        0x0000564535cb9b76 <unavailable> + 7030

    5    libc.so.6                          0x00002ad1c41d2460 __libc_start_main +
    245

    6    tmpf1k5bpgp                        0x0000564535cb92d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = lst[0]\
    \ + lst[1]\n    var stack = [Character]()\n    for char in str {\n        if char\
    \ == \"(\" {\n            stack.append(char)\n        } else {\n            if\
    \ stack.isEmpty {\n                return \"No\"\n            } else {\n     \
    \           stack.removeLast()\n            }\n        }\n    }\n    return stack.isEmpty\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpqdqgg85h/tmpqdqgg85h.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1ba9a9fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1ba9796b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1ba9796988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1ba97957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqdqgg85h                        0x0000562bae016da6 <unavailable> + 7590

    5    libc.so.6                          0x00002b1ba9c8b460 __libc_start_main +
    245

    6    tmpqdqgg85h                        0x0000562bae016509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659824580
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var count = 0\n    for i in 0..<lst.count {\n       \
    \ if lst[i] == \")\" {\n            count -= 1\n        } else {\n           \
    \ count += 1\n        }\n        if count < 0 {\n            str = lst[i] + lst[0]\n\
    \            lst[0] = str\n            lst[i] = \"\"\n            count = 0\n\
    \        }\n    }\n    if count == 0 {\n        return \"Yes\"\n    } else {\n\
    \        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpm2vmvq2r/tmpm2vmvq2r.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b77f10aec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b77f0da5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b77f0da5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b77f0da47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm2vmvq2r                        0x0000561066c858e0 <unavailable> + 6368

    5    libc.so.6                          0x00002b77f129a460 __libc_start_main +
    245

    6    tmpm2vmvq2r                        0x0000561066c85359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1659824580
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    while lst.count > 0 {\n        if lst[0].count > lst[1].count\
    \ {\n            str += lst[0]\n            lst.remove(at: 0)\n        } else\
    \ {\n            str += lst[1]\n            lst.remove(at: 1)\n        }\n   \
    \ }\n    var count = 0\n    for c in str {\n        if c == \"(\" {\n        \
    \    count += 1\n        } else {\n            count -= 1\n        }\n       \
    \ if count < 0 {\n            return \"No\"\n        }\n    }\n    return \"Yes\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8ec984dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8ec9544561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8ec9544286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8ec954413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8ec9543bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8ec9343fc3 <unavailable> + 188355

    6    tmpm1vg7uc3                        0x000055c159d1fa17 <unavailable> + 10775

    7    tmpm1vg7uc3                        0x000055c159d1e735 <unavailable> + 5941

    8    libc.so.6                          0x00002b8ec9a39460 __libc_start_main +
    245

    9    tmpm1vg7uc3                        0x000055c159d1e3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = lst[0] +\
    \ lst[1]\n    var count = 0\n    for c in s {\n        if c == \"(\" {\n     \
    \       count += 1\n        } else {\n            count -= 1\n        }\n    \
    \    if count < 0 {\n            return \"No\"\n        }\n    }\n    return count\
    \ == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpf1k5bpgp/tmpf1k5bpgp.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad1c3fe6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad1c3cddb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad1c3cdd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad1c3cdc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf1k5bpgp                        0x0000564535cb9b76 <unavailable> + 7030

    5    libc.so.6                          0x00002ad1c41d2460 __libc_start_main +
    245

    6    tmpf1k5bpgp                        0x0000564535cb92d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    for i in 0..<lst.count {\n        str += lst[i]\n   \
    \ }\n    var stack = [Character]()\n    for char in str {\n        if char ==\
    \ \"(\" {\n            stack.append(char)\n        } else {\n            if stack.isEmpty\
    \ {\n                return \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpqrw5klky/tmpqrw5klky.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1b3507cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1b34d73b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1b34d73988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1b34d727b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqrw5klky                        0x000055d0a4c76f86 <unavailable> + 8070

    5    libc.so.6                          0x00002b1b35268460 __libc_start_main +
    245

    6    tmpqrw5klky                        0x000055d0a4c766e9 <unavailable> + 5865

    '
  stdout: ''
  timestamp: 1659824580
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    var count = 0\n    for c in\
    \ str {\n        if c == \"(\" {\n            count += 1\n        } else {\n \
    \           count -= 1\n        }\n        if count < 0 {\n            return\
    \ \"No\"\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmptan6oan_/tmptan6oan_.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f38400c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f380f7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8f380f7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8f380f67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptan6oan_                        0x000055a83b5e4c96 <unavailable> + 7318

    5    libc.so.6                          0x00002b8f385ec460 __libc_start_main +
    245

    6    tmptan6oan_                        0x000055a83b5e43f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var left = 0\n \
    \   var right = 0\n    for c in lst[0] {\n        if c == \"(\" {\n          \
    \  left += 1\n        } else {\n            right += 1\n        }\n    }\n   \
    \ for c in lst[1] {\n        if c == \"(\" {\n            left -= 1\n        }\
    \ else {\n            right -= 1\n        }\n    }\n    if left == 0 && right\
    \ == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpyhprekc1/tmpyhprekc1.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4e1f227c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4e1ef1eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4e1ef1e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4e1ef1d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyhprekc1                        0x00005630f663c6a6 <unavailable> + 5798

    5    libc.so.6                          0x00002b4e1f413460 __libc_start_main +
    245

    6    tmpyhprekc1                        0x00005630f663c289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824580
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var count = 0\n\
    \    for char in lst[0] {\n        if char == \"(\" {\n            count += 1\n\
    \        } else {\n            count -= 1\n        }\n    }\n    for char in lst[1]\
    \ {\n        if char == \"(\" {\n            count += 1\n        } else {\n  \
    \          count -= 1\n        }\n    }\n    if count == 0 {\n        return \"\
    Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpv0cfakhs/tmpv0cfakhs.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b817fddec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b817fad5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b817fad5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b817fad47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv0cfakhs                        0x00005594bc5fe468 <unavailable> + 9320

    5    libc.so.6                          0x00002b817ffca460 __libc_start_main +
    245

    6    tmpv0cfakhs                        0x00005594bc5fd289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    // your code here\n\
    \    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpdwmezyh3/tmpdwmezyh3.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b97f00e8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b97efddfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b97efddf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b97efdde7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdwmezyh3                        0x0000556b37c554a6 <unavailable> + 5286

    5    libc.so.6                          0x00002b97f02d4460 __libc_start_main +
    245

    6    tmpdwmezyh3                        0x0000556b37c55089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1659824580
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack<Character>()\n\
    \    var str = lst[0] + lst[1]\n    for char in str {\n        if char == \"(\"\
    \ {\n            stack.push(char)\n        } else {\n            if stack.isEmpty()\
    \ {\n                return \"No\"\n            } else {\n                stack.pop()\n\
    \            }\n        }\n    }\n    return stack.isEmpty() ? \"Yes\" : \"No\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpzwylv_md.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var count = 0\n    for i in 0..<lst.count {\n       \
    \ str += lst[i]\n    }\n    for i in 0..<str.count {\n        if str[i] == \"\
    (\" {\n            count += 1\n        } else {\n            count -= 1\n    \
    \    }\n        if count < 0 {\n            return \"No\"\n        }\n    }\n\
    \    if count == 0 {\n        return \"Yes\"\n    } else {\n        return \"\
    No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmplkxfsp_6.swift:23:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if str[i]\
    \ == \"(\" {\n           ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmplkxfsp_6.swift:16:9: warning: variable 'lst'\
    \ was never mutated; consider changing to 'let' constant\n    var lst = lst\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    while lst.count > 0 {\n        if lst[0].count > lst[1].count\
    \ {\n            str += lst[0]\n            lst.remove(at: 0)\n        } else\
    \ {\n            str += lst[1]\n            lst.remove(at: 1)\n        }\n   \
    \ }\n    var count = 0\n    for c in str {\n        if c == \"(\" {\n        \
    \    count += 1\n        } else {\n            count -= 1\n        }\n       \
    \ if count < 0 {\n            return \"No\"\n        }\n    }\n    return count\
    \ == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7e86023c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7e85d1a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b7e85d1a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b7e85d1a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b7e85d19bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b7e85b19fc3 <unavailable> + 188355

    6    tmpmuf_byst                        0x0000556879bd2a17 <unavailable> + 10775

    7    tmpmuf_byst                        0x0000556879bd1735 <unavailable> + 5941

    8    libc.so.6                          0x00002b7e8620f460 __libc_start_main +
    245

    9    tmpmuf_byst                        0x0000556879bd13d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824580
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var lst1 = lst[0]\n    var lst2 = lst[1]\n    var lst3 = lst1 + lst2\n  \
    \  var lst4 = lst2 + lst1\n    var lst5 = lst3.replacingOccurrences(of: \"()\"\
    , with: \"\")\n    var lst6 = lst4.replacingOccurrences(of: \"()\", with: \"\"\
    )\n    if lst5 == \"\" {\n        return \"Yes\"\n    } else if lst6 == \"\" {\n\
    \        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp9bzvi33p.swift:21:21: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n    var lst5 = lst3.replacingOccurrences(of: \"()\"\
    , with: \"\")\n               ~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp9bzvi33p.swift:22:21:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n    var\
    \ lst6 = lst4.replacingOccurrences(of: \"()\", with: \"\")\n               ~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for str in lst {\n        s += str\n    }\n    var stack = [Character]()\n\
    \    for c in s {\n        if c == \"(\" {\n            stack.append(c)\n    \
    \    } else {\n            if stack.isEmpty {\n                return \"No\"\n\
    \            }\n            stack.removeLast()\n        }\n    }\n    return stack.isEmpty\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpi_hnpb9q/tmpi_hnpb9q.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b65e3891c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b65e3588b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b65e3588988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b65e35877b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi_hnpb9q                        0x000055cb9ef3de76 <unavailable> + 7798

    5    libc.so.6                          0x00002b65e3a7d460 __libc_start_main +
    245

    6    tmpi_hnpb9q                        0x000055cb9ef3d5d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack<Character>()\n\
    \    for char in lst[0] {\n        if char == \"(\" {\n            stack.push(char)\n\
    \        } else {\n            if stack.isEmpty() {\n                return \"\
    No\"\n            }\n            stack.pop()\n        }\n    }\n    for char in\
    \ lst[1] {\n        if char == \"(\" {\n            if stack.isEmpty() {\n   \
    \             return \"No\"\n            }\n            stack.pop()\n        }\
    \ else {\n            stack.push(char)\n        }\n    }\n    return stack.isEmpty()\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpv72ksz2x.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0]\n\
    \    let str2 = lst[1]\n    var stack = Stack<Character>()\n    for char in str1\
    \ {\n        if char == \"(\" {\n            stack.push(char)\n        } else\
    \ {\n            if stack.isEmpty() {\n                return \"No\"\n       \
    \     }\n            stack.pop()\n        }\n    }\n    for char in str2 {\n \
    \       if char == \"(\" {\n            stack.push(char)\n        } else {\n \
    \           if stack.isEmpty() {\n                return \"No\"\n            }\n\
    \            stack.pop()\n        }\n    }\n    return stack.isEmpty() ? \"Yes\"\
    \ : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpnh18nb62.swift:18:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824580
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s1 = lst[0]\n\
    \    var s2 = lst[1]\n    var s = s1 + s2\n    var count = 0\n    for c in s {\n\
    \        if c == \"(\" {\n            count += 1\n        } else {\n         \
    \   count -= 1\n        }\n        if count < 0 {\n            return \"No\"\n\
    \        }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp30d0t1je/tmp30d0t1je.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ada70c6ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ada70965b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ada70965988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ada709647b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp30d0t1je                        0x00005575de58cb76 <unavailable> + 7030

    5    libc.so.6                          0x00002ada70e5a460 __libc_start_main +
    245

    6    tmp30d0t1je                        0x00005575de58c2d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824580
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var result = \"\"\n    var count = 0\n    while lst.count > 0 {\n       \
    \ let str = lst.removeFirst()\n        for char in str {\n            if char\
    \ == \"(\" {\n                count += 1\n            } else {\n             \
    \   count -= 1\n            }\n            if count < 0 {\n                return\
    \ \"No\"\n            }\n        }\n        result += str\n    }\n    return count\
    \ == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpgis7sxjp/tmpgis7sxjp.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b72ca145c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b72c9e3cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b72c9e3c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b72c9e3b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgis7sxjp                        0x000055d7083cac26 <unavailable> + 7206

    5    libc.so.6                          0x00002b72ca331460 __libc_start_main +
    245

    6    tmpgis7sxjp                        0x000055d7083ca389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1659824580
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    for i in 0..<lst.count {\n        str += lst[i]\n   \
    \ }\n    var stack = [Character]()\n    for char in str {\n        if char ==\
    \ \"(\" {\n            stack.append(char)\n        } else {\n            if stack.count\
    \ == 0 {\n                return \"No\"\n            } else {\n              \
    \  stack.removeLast()\n            }\n        }\n    }\n    if stack.count ==\
    \ 0 {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpcy2xuzo3/tmpcy2xuzo3.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b099dde2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b099dad9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b099dad9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b099dad87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcy2xuzo3                        0x00005555f0cdef46 <unavailable> + 8006

    5    libc.so.6                          0x00002b099dfce460 __libc_start_main +
    245

    6    tmpcy2xuzo3                        0x00005555f0cde6a9 <unavailable> + 5801

    '
  stdout: ''
  timestamp: 1659824580
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var s = \"\"\n    var c = 0\n    while lst.count > 0 {\n        if lst[0].count\
    \ > 0 {\n            s += lst[0][0]\n            lst[0].remove(at: lst[0].startIndex)\n\
    \        } else {\n            lst.remove(at: 0)\n        }\n        if s.count\
    \ > 0 {\n            if s[s.count - 1] == \"(\" {\n                c += 1\n  \
    \          } else {\n                c -= 1\n            }\n        }\n      \
    \  if c < 0 {\n            return \"No\"\n        }\n    }\n    if c == 0 {\n\
    \        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpe1dnpuk_.swift:21:25: error: cannot convert value of type 'Int'\
    \ to expected argument type 'Range<String.Index>'\n            s += lst[0][0]\n\
    \                        ^\n/tmp/tmpe1dnpuk_.swift:27:16: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            if s[s.count - 1] == \"(\" {\n               ^~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824580
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    while lst.count > 0 {\n        str += lst.removeFirst()\n\
    \        if str.count > 0 {\n            let last = str.last!\n            if\
    \ last == \"(\" {\n                if lst.count > 0 {\n                    let\
    \ first = lst.first!\n                    if first == \")\" {\n              \
    \          lst.removeFirst()\n                        str.removeLast()\n     \
    \               }\n                }\n            }\n        }\n    }\n    if\
    \ str.count == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpzxnvv6th/tmpzxnvv6th.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9640119c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b963fe10b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b963fe10988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b963fe0f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzxnvv6th                        0x000055853d0269a6 <unavailable> + 6566

    5    libc.so.6                          0x00002b9640305460 __libc_start_main +
    245

    6    tmpzxnvv6th                        0x000055853d026589 <unavailable> + 5513

    '
  stdout: ''
  timestamp: 1659824580
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0]\n\
    \    let str2 = lst[1]\n    var str = \"\"\n    var count = 0\n    for char in\
    \ str1 {\n        if char == \"(\" {\n            count += 1\n        } else {\n\
    \            count -= 1\n        }\n        if count < 0 {\n            return\
    \ \"No\"\n        }\n    }\n    for char in str2 {\n        if char == \"(\" {\n\
    \            count += 1\n        } else {\n            count -= 1\n        }\n\
    \        if count < 0 {\n            return \"No\"\n        }\n    }\n    if count\
    \ == 0 {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpn6rc8yel/tmpn6rc8yel.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad3480cbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad347dc2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad347dc2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad347dc17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn6rc8yel                        0x0000563232f78b26 <unavailable> + 6950

    5    libc.so.6                          0x00002ad3482b7460 __libc_start_main +
    245

    6    tmpn6rc8yel                        0x0000563232f78289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824580
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack<Character>()\n\
    \    var str = lst[0] + lst[1]\n    for c in str {\n        if c == \"(\" {\n\
    \            stack.push(c)\n        } else {\n            if stack.isEmpty {\n\
    \                return \"No\"\n            }\n            stack.pop()\n     \
    \   }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpk5e57jnv.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824580
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var count = 0\n    for i in 0..<lst.count {\n       \
    \ str += lst[i]\n    }\n    for i in 0..<str.count {\n        if str[i] == \"\
    (\" {\n            count += 1\n        } else {\n            count -= 1\n    \
    \    }\n        if count < 0 {\n            return \"No\"\n        }\n    }\n\
    \    if count == 0 {\n        return \"Yes\"\n    } else {\n        return \"\
    No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmplkxfsp_6.swift:23:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if str[i]\
    \ == \"(\" {\n           ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmplkxfsp_6.swift:16:9: warning: variable 'lst'\
    \ was never mutated; consider changing to 'let' constant\n    var lst = lst\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = lst[0] +\
    \ lst[1]\n    var count = 0\n    for c in s {\n        if c == \"(\" {\n     \
    \       count += 1\n        } else {\n            count -= 1\n        }\n    \
    \    if count < 0 {\n            return \"No\"\n        }\n    }\n    return count\
    \ == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpf1k5bpgp/tmpf1k5bpgp.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad1c3fe6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad1c3cddb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad1c3cdd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad1c3cdc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf1k5bpgp                        0x0000564535cb9b76 <unavailable> + 7030

    5    libc.so.6                          0x00002ad1c41d2460 __libc_start_main +
    245

    6    tmpf1k5bpgp                        0x0000564535cb92d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    var stack = [Character]()\n\
    \    for c in str {\n        if c == \"(\" {\n            stack.append(c)\n  \
    \      } else {\n            if stack.isEmpty {\n                return \"No\"\
    \n            } else {\n                stack.removeLast()\n            }\n  \
    \      }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpg5wbuesr/tmpg5wbuesr.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b46e418ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b46e3e85b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b46e3e85988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b46e3e847b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg5wbuesr                        0x000055ceac939e76 <unavailable> + 7798

    5    libc.so.6                          0x00002b46e437a460 __libc_start_main +
    245

    6    tmpg5wbuesr                        0x000055ceac9395d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = lst[0] +\
    \ lst[1]\n    var count = 0\n    for c in s {\n        if c == \"(\" {\n     \
    \       count += 1\n        } else {\n            count -= 1\n        }\n    \
    \    if count < 0 {\n            return \"No\"\n        }\n    }\n    return count\
    \ == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpf1k5bpgp/tmpf1k5bpgp.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad1c3fe6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad1c3cddb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad1c3cdd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad1c3cdc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf1k5bpgp                        0x0000564535cb9b76 <unavailable> + 7030

    5    libc.so.6                          0x00002ad1c41d2460 __libc_start_main +
    245

    6    tmpf1k5bpgp                        0x0000564535cb92d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for i in lst {\n        s += i\n    }\n    var count = 0\n    for i in s {\n\
    \        if i == \"(\" {\n            count += 1\n        } else {\n         \
    \   count -= 1\n        }\n        if count < 0 {\n            return \"No\"\n\
    \        }\n    }\n    if count == 0 {\n        return \"Yes\"\n    } else {\n\
    \        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpy08bjsqz/tmpy08bjsqz.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1709aebc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b17097e2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b17097e2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b17097e17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy08bjsqz                        0x000055f2ce1a7c96 <unavailable> + 7318

    5    libc.so.6                          0x00002b1709cd7460 __libc_start_main +
    245

    6    tmpy08bjsqz                        0x000055f2ce1a73f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = lst[0] +\
    \ lst[1]\n    var count = 0\n    for c in s {\n        if c == \"(\" {\n     \
    \       count += 1\n        } else {\n            count -= 1\n        }\n    \
    \    if count < 0 {\n            return \"No\"\n        }\n    }\n    return count\
    \ == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpf1k5bpgp/tmpf1k5bpgp.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad1c3fe6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad1c3cddb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad1c3cdd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad1c3cdc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf1k5bpgp                        0x0000564535cb9b76 <unavailable> + 7030

    5    libc.so.6                          0x00002ad1c41d2460 __libc_start_main +
    245

    6    tmpf1k5bpgp                        0x0000564535cb92d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack<Character>()\n\
    \    for char in lst[0] {\n        if char == \"(\" {\n            stack.push(char)\n\
    \        } else {\n            if stack.isEmpty() {\n                return \"\
    No\"\n            }\n            stack.pop()\n        }\n    }\n    for char in\
    \ lst[1] {\n        if char == \"(\" {\n            if stack.isEmpty() {\n   \
    \             return \"No\"\n            }\n            stack.pop()\n        }\
    \ else {\n            stack.push(char)\n        }\n    }\n    return stack.isEmpty()\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpv72ksz2x.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var count = 0\n    while lst.count > 0 {\n        if\
    \ lst[0].count > 0 {\n            str += lst[0]\n            lst[0].removeFirst()\n\
    \        } else {\n            lst.removeFirst()\n        }\n    }\n    for char\
    \ in str {\n        if char == \"(\" {\n            count += 1\n        } else\
    \ {\n            count -= 1\n        }\n        if count < 0 {\n            return\
    \ \"No\"\n        }\n    }\n    if count == 0 {\n        return \"Yes\"\n    }\
    \ else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp88ifntda/tmp88ifntda.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aecd8180c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aecd7e77b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aecd7e77988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aecd7e767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp88ifntda                        0x000055c82d1928d6 <unavailable> + 6358

    5    libc.so.6                          0x00002aecd836c460 __libc_start_main +
    245

    6    tmp88ifntda                        0x000055c82d1924b9 <unavailable> + 5305

    '
  stdout: ''
  timestamp: 1659824580
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = lst[0]\
    \ + lst[1]\n    var stack = [Character]()\n    for char in str {\n        if char\
    \ == \"(\" {\n            stack.append(char)\n        } else {\n            if\
    \ stack.isEmpty {\n                return \"No\"\n            } else {\n     \
    \           stack.removeLast()\n            }\n        }\n    }\n    return stack.isEmpty\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpqdqgg85h/tmpqdqgg85h.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1ba9a9fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1ba9796b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1ba9796988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1ba97957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqdqgg85h                        0x0000562bae016da6 <unavailable> + 7590

    5    libc.so.6                          0x00002b1ba9c8b460 __libc_start_main +
    245

    6    tmpqdqgg85h                        0x0000562bae016509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659824580
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = lst.removeFirst()\n    while !lst.isEmpty {\n        str += lst.removeFirst()\n\
    \        if str.count % 2 == 0 {\n            let half = str.count / 2\n     \
    \       if str[0..<half] == String(str[half..<str.count].reversed()) {\n     \
    \           return \"Yes\"\n            }\n        }\n    }\n    return \"No\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpym9vbnwu.swift:22:16: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an integer range, use a String.Index range instead.\n\
    \            if str[0..<half] == String(str[half..<str.count].reversed()) {\n\
    \               ^~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmpym9vbnwu.swift:22:40:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an integer\
    \ range, use a String.Index range instead.\n            if str[0..<half] == String(str[half..<str.count].reversed())\
    \ {\n                                       ^~~~~~~~~~~~~~~~~~~~~\nSwift.String:5:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript<R>(bounds: R) -> String where R : RangeExpression, R.Bound == Int\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824580
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var s = \"\"\n    while lst.count > 0 {\n        s += lst.removeFirst()\n\
    \        if s.count > 0 && s.last! == \")\" {\n            s.removeLast()\n  \
    \          if s.count > 0 && s.last! == \"(\" {\n                s.removeLast()\n\
    \            } else {\n                return \"No\"\n            }\n        }\n\
    \    }\n    return s.count == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpphlc8uai/tmpphlc8uai.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba85b972c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba85b669b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba85b669988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba85b6687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpphlc8uai                        0x00005649e9b55906 <unavailable> + 6406

    5    libc.so.6                          0x00002ba85bb5e460 __libc_start_main +
    245

    6    tmpphlc8uai                        0x00005649e9b554e9 <unavailable> + 5353

    '
  stdout: ''
  timestamp: 1659824580
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var open = 0\n \
    \   var close = 0\n    for char in lst[0] {\n        if char == \"(\" {\n    \
    \        open += 1\n        } else {\n            close += 1\n        }\n    }\n\
    \    for char in lst[1] {\n        if char == \"(\" {\n            open += 1\n\
    \        } else {\n            close += 1\n        }\n    }\n    if open == close\
    \ {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpyyy95a03/tmpyyy95a03.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4c56d49c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4c56a40b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4c56a40988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4c56a3f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyyy95a03                        0x000055e056c94468 <unavailable> + 9320

    5    libc.so.6                          0x00002b4c56f35460 __libc_start_main +
    245

    6    tmpyyy95a03                        0x000055e056c93289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824579
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var lst1 = lst[0]\n    var lst2 = lst[1]\n    var lst3 = lst1 + lst2\n  \
    \  var count = 0\n    for i in lst3 {\n        if i == \"(\" {\n            count\
    \ += 1\n        } else {\n            count -= 1\n        }\n        if count\
    \ < 0 {\n            return \"No\"\n        }\n    }\n    if count == 0 {\n  \
    \      return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp5yeign0a/tmp5yeign0a.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac44eedfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac44ebd6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac44ebd6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac44ebd57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5yeign0a                        0x000055da29d2cb76 <unavailable> + 7030

    5    libc.so.6                          0x00002ac44f0cb460 __libc_start_main +
    245

    6    tmp5yeign0a                        0x000055da29d2c2d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824580
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    while lst.count > 0 {\n        let s = lst.removeFirst()\n\
    \        if s.count > 0 {\n            str += s\n        }\n    }\n    var count\
    \ = 0\n    for c in str {\n        if c == \"(\" {\n            count += 1\n \
    \       } else {\n            count -= 1\n        }\n        if count < 0 {\n\
    \            return \"No\"\n        }\n    }\n    return count == 0 ? \"Yes\"\
    \ : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmptke9arqy/tmptke9arqy.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1f66de9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1f66ae0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1f66ae0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1f66adf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptke9arqy                        0x0000560ef5203c66 <unavailable> + 7270

    5    libc.so.6                          0x00002b1f66fd5460 __libc_start_main +
    245

    6    tmptke9arqy                        0x0000560ef52033c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1659824580
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var s = \"\"\n    var count = 0\n    for i in 0..<lst.count {\n        for\
    \ j in 0..<lst[i].count {\n            if lst[i][j] == \"(\" {\n             \
    \   count += 1\n            } else {\n                count -= 1\n           \
    \ }\n            if count < 0 {\n                return \"No\"\n            }\n\
    \        }\n        s += lst[i]\n    }\n    if count == 0 {\n        return \"\
    Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp19ioqnm4.swift:21:16: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n            if lst[i][j]\
    \ == \"(\" {\n               ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp19ioqnm4.swift:16:9: warning: variable\
    \ 'lst' was never mutated; consider changing to 'let' constant\n    var lst =\
    \ lst\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824580
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lhs = lst[0]\n\
    \    var rhs = lst[1]\n    var lhs_count = 0\n    var rhs_count = 0\n    for char\
    \ in lhs {\n        if char == \"(\" {\n            lhs_count += 1\n        }\
    \ else {\n            lhs_count -= 1\n        }\n    }\n    for char in rhs {\n\
    \        if char == \"(\" {\n            rhs_count += 1\n        } else {\n  \
    \          rhs_count -= 1\n        }\n    }\n    if lhs_count == 0 && rhs_count\
    \ == 0 {\n        return \"Yes\"\n    } else if lhs_count == 0 && rhs_count <\
    \ 0 {\n        return \"Yes\"\n    } else if lhs_count > 0 && rhs_count == 0 {\n\
    \        return \"Yes\"\n    } else if lhs_count > 0 && rhs_count < 0 {\n    \
    \    return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp5t6cyxtw/tmp5t6cyxtw.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b93cbbd5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b93cb8ccb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b93cb8cc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b93cb8cb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5t6cyxtw                        0x0000563e2961d99b <unavailable> + 6555

    5    libc.so.6                          0x00002b93cbdc1460 __libc_start_main +
    245

    6    tmp5t6cyxtw                        0x0000563e2961d289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824580
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var count = 0\n    for i in 0..<lst.count {\n       \
    \ str += lst[i]\n    }\n    for i in 0..<str.count {\n        if str[i] == \"\
    (\" {\n            count += 1\n        } else {\n            count -= 1\n    \
    \    }\n        if count < 0 {\n            return \"No\"\n        }\n    }\n\
    \    if count == 0 {\n        return \"Yes\"\n    } else {\n        return \"\
    No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmplkxfsp_6.swift:23:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if str[i]\
    \ == \"(\" {\n           ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmplkxfsp_6.swift:16:9: warning: variable 'lst'\
    \ was never mutated; consider changing to 'let' constant\n    var lst = lst\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for i in lst {\n        str += i\n    }\n    var stack = [Character]()\n\
    \    for i in str {\n        if i == \"(\" {\n            stack.append(i)\n  \
    \      } else {\n            if stack.count > 0 {\n                stack.removeLast()\n\
    \            } else {\n                return \"No\"\n            }\n        }\n\
    \    }\n    if stack.count == 0 {\n        return \"Yes\"\n    } else {\n    \
    \    return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmppunj2ecz/tmppunj2ecz.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6c03df4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6c03aebb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6c03aeb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6c03aea7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppunj2ecz                        0x00005576bb594e76 <unavailable> + 7798

    5    libc.so.6                          0x00002b6c03fe0460 __libc_start_main +
    245

    6    tmppunj2ecz                        0x00005576bb5945d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824580
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var left = 0\n \
    \   var right = 0\n    for c in lst[0] {\n        if c == \"(\" {\n          \
    \  left += 1\n        } else {\n            right += 1\n        }\n    }\n   \
    \ for c in lst[1] {\n        if c == \"(\" {\n            left -= 1\n        }\
    \ else {\n            right -= 1\n        }\n    }\n    if left == 0 && right\
    \ == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpyhprekc1/tmpyhprekc1.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4e1f227c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4e1ef1eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4e1ef1e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4e1ef1d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyhprekc1                        0x00005630f663c6a6 <unavailable> + 5798

    5    libc.so.6                          0x00002b4e1f413460 __libc_start_main +
    245

    6    tmpyhprekc1                        0x00005630f663c289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824580
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var left = 0\n \
    \   var right = 0\n    for char in lst[0] {\n        if char == \"(\" {\n    \
    \        left += 1\n        } else {\n            right += 1\n        }\n    }\n\
    \    for char in lst[1] {\n        if char == \"(\" {\n            left -= 1\n\
    \        } else {\n            right -= 1\n        }\n    }\n    if left == 0\
    \ && right == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpswf759wy/tmpswf759wy.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b860cb40c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b860c837b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b860c837988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b860c8367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpswf759wy                        0x00005627041096a6 <unavailable> + 5798

    5    libc.so.6                          0x00002b860cd2c460 __libc_start_main +
    245

    6    tmpswf759wy                        0x0000562704109289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824579
