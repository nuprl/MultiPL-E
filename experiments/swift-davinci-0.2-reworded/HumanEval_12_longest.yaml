name: HumanEval_12_longest
language: swift
prompt: "\n/// Out of array of strings, return the longest one. Return the first one\
  \ in case of multiple\n/// strings of the same length. Return nil in case the input\
  \ array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n/// >>> longest(strings:\
  \ [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings: [\"a\", \"bb\", \"\
  ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String? {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\n\
  assert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings:\
  \ [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
completions: ["    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString",
  "    var longestString: String?\n    for string in strings {\n        if longestString\
    \ == nil || string.count > longestString!.count {\n            longestString =\
    \ string\n        }\n    }\n    return longestString", "    var longestString:\
    \ String?\n    for string in strings {\n        if longestString == nil || string.count\
    \ > longestString!.count {\n            longestString = string\n        }\n  \
    \  }\n    return longestString", "    if strings.isEmpty {\n        return nil\n\
    \    }\n    var longestString = strings[0]\n    for string in strings {\n    \
    \    if string.count > longestString.count {\n            longestString = string\n\
    \        }\n    }\n    return longestString", "    var longestString: String?\n\
    \    for string in strings {\n        if longestString == nil || string.count\
    \ > longestString!.count {\n            longestString = string\n        }\n  \
    \  }\n    return longestString", "    guard !strings.isEmpty else { return nil\
    \ }\n    return strings.reduce(strings[0]) { $1.count > $0.count ? $1 : $0 }",
  '    return nil', '    return strings.max { $0.count < $1.count }', "    if strings.isEmpty\
    \ {\n        return nil\n    }\n    var longest = strings[0]\n    for string in\
    \ strings {\n        if string.count > longest.count {\n            longest =\
    \ string\n        }\n    }\n    return longest", "    if strings.isEmpty {\n \
    \       return nil\n    }\n    var longestString = strings[0]\n    for string\
    \ in strings {\n        if string.count > longestString.count {\n            longestString\
    \ = string\n        }\n    }\n    return longestString", '    return strings.sorted
    { $0.count > $1.count }.first', "    guard !strings.isEmpty else { return nil\
    \ }\n    var longestString = strings[0]\n    for string in strings {\n       \
    \ if string.count > longestString.count {\n            longestString = string\n\
    \        }\n    }\n    return longestString", "    var longestString: String?\n\
    \    for string in strings {\n        if longestString == nil || string.count\
    \ > longestString!.count {\n            longestString = string\n        }\n  \
    \  }\n    return longestString", "    guard !strings.isEmpty else { return nil\
    \ }\n    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest", '    return strings.max { $0.count < $1.count }', '    return strings.max(by:
    { $0.count < $1.count })', "    guard !strings.isEmpty else { return nil }\n \
    \   return strings.reduce(strings[0]) { $1.count > $0.count ? $1 : $0 }", "  \
    \  guard strings.count > 0 else {\n        return nil\n    }\n    var longest\
    \ = strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest", "  \
    \  if strings.isEmpty {\n        return nil\n    }\n    return strings.max { $0.count\
    \ < $1.count }", "    if strings.isEmpty {\n        return nil\n    }\n    var\
    \ longest = strings[0]\n    for string in strings {\n        if string.count >\
    \ longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest"]
stop_tokens:
- "\n}"
