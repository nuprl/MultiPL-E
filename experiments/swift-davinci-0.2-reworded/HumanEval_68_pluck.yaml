name: HumanEval_68_pluck
language: swift
prompt: "\n/// \"Given an array representing a branch of a tree that has non-negative\
  \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
  \ The plucked node should be the node with the smallest even value.\n/// If multiple\
  \ nodes with the same smallest even value are found return the node that has smallest\
  \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
  \ its index ],\n/// If there are no even values or the given array is empty, return\
  \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
  \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
  /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest even\
  \ value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr: [] as\
  \ [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3, 0, 4, 2])\n\
  /// [0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
  /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
  /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfunc pluck(arr: [Int])\
  \ -> [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
  \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
  \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
  assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) ==\
  \ [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
completions: ['    return arr.enumerated().filter { $0.element % 2 == 0 }.min { $0.element
    < $1.element }?.reversed() ?? []', "    var smallestEvenValue = Int.max\n    var\
    \ smallestEvenValueIndex = Int.max\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 && value < smallestEvenValue {\n            smallestEvenValue\
    \ = value\n            smallestEvenValueIndex = index\n        }\n    }\n    return\
    \ smallestEvenValue == Int.max ? [] : [smallestEvenValue, smallestEvenValueIndex]",
  "    var evens = [Int]()\n    var evensIndex = [Int]()\n    for (index, value) in\
    \ arr.enumerated() {\n        if value % 2 == 0 {\n            evens.append(value)\n\
    \            evensIndex.append(index)\n        }\n    }\n    if evens.count ==\
    \ 0 {\n        return []\n    }\n    var min = evens[0]\n    var minIndex = evensIndex[0]\n\
    \    for (index, value) in evens.enumerated() {\n        if value < min {\n  \
    \          min = value\n            minIndex = evensIndex[index]\n        }\n\
    \    }\n    return [min, minIndex]", "    guard !arr.isEmpty else { return []\
    \ }\n    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else\
    \ { return [] }\n    let smallestEven = evens.min()!\n    let index = arr.firstIndex(of:\
    \ smallestEven)!\n    return [smallestEven, index]", "    var result = [Int]()\n\
    \    var minEven = Int.max\n    var minEvenIndex = Int.max\n    for (index, value)\
    \ in arr.enumerated() {\n        if value % 2 == 0 && value < minEven {\n    \
    \        minEven = value\n            minEvenIndex = index\n        }\n    }\n\
    \    if minEven != Int.max {\n        result.append(minEven)\n        result.append(minEvenIndex)\n\
    \    }\n    return result", "    guard arr.count > 0 else { return [] }\n    var\
    \ evens: [Int] = []\n    var evensIndex: [Int] = []\n    for (index, value) in\
    \ arr.enumerated() {\n        if value % 2 == 0 {\n            evens.append(value)\n\
    \            evensIndex.append(index)\n        }\n    }\n    guard evens.count\
    \ > 0 else { return [] }\n    let minEven = evens.min()!\n    let minEvenIndex\
    \ = evensIndex[evens.firstIndex(of: minEven)!]\n    return [minEven, minEvenIndex]",
  "    let evens = arr.filter { $0 % 2 == 0 }\n    guard let min = evens.min() else\
    \ { return [] }\n    let index = arr.firstIndex(of: min) ?? 0\n    return [min,\
    \ index]", "    let evens = arr.filter { $0 % 2 == 0 }\n    guard let min = evens.min()\
    \ else { return [] }\n    let index = arr.firstIndex(of: min) ?? 0\n    return\
    \ [min, index]", "    guard !arr.isEmpty else { return [] }\n    let evens = arr.filter\
    \ { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return [] }\n    let minEven\
    \ = evens.min()!\n    let index = arr.firstIndex(of: minEven)!\n    return [minEven,\
    \ index]", "    var evens = [Int]()\n    var evensIndex = [Int]()\n    for (index,\
    \ value) in arr.enumerated() {\n        if value % 2 == 0 {\n            evens.append(value)\n\
    \            evensIndex.append(index)\n        }\n    }\n    if evens.count ==\
    \ 0 {\n        return []\n    }\n    var min = evens[0]\n    var minIndex = evensIndex[0]\n\
    \    for (index, value) in evens.enumerated() {\n        if value < min {\n  \
    \          min = value\n            minIndex = evensIndex[index]\n        }\n\
    \    }\n    return [min, minIndex]", "    guard arr.count > 0 else { return []\
    \ }\n    let evens = arr.filter { $0 % 2 == 0 }\n    guard evens.count > 0 else\
    \ { return [] }\n    let minEven = evens.min()!\n    let minEvenIndex = arr.firstIndex(of:\
    \ minEven)!\n    return [minEven, minEvenIndex]", '    return arr.enumerated().filter
    { $0.element % 2 == 0 }.min { $0.element < $1.element }?.reversed() ?? []', " \
    \   let evens = arr.filter { $0 % 2 == 0 }\n    guard let smallestEven = evens.min()\
    \ else { return [] }\n    guard let index = arr.firstIndex(of: smallestEven) else\
    \ { return [] }\n    return [smallestEven, index]", "    guard !arr.isEmpty else\
    \ { return [] }\n    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty\
    \ else { return [] }\n    let smallestEven = evens.min()!\n    let index = arr.firstIndex(of:\
    \ smallestEven)!\n    return [smallestEven, index]", "    guard !arr.isEmpty else\
    \ { return [] }\n    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty\
    \ else { return [] }\n    let minEven = evens.min()!\n    let idx = arr.firstIndex(of:\
    \ minEven)!\n    return [minEven, idx]", "    guard !arr.isEmpty else { return\
    \ [] }\n    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else\
    \ { return [] }\n    let minEven = evens.min()!\n    let minEvenIndex = arr.firstIndex(of:\
    \ minEven)!\n    return [minEven, minEvenIndex]", "    guard !arr.isEmpty else\
    \ { return [] }\n    guard let minEven = arr.filter({ $0 % 2 == 0 }).min() else\
    \ { return [] }\n    return [minEven, arr.firstIndex(of: minEven)!]", "    var\
    \ smallestEven = Int.max\n    var smallestEvenIndex = Int.max\n    for (index,\
    \ value) in arr.enumerated() {\n        if value % 2 == 0 {\n            if value\
    \ < smallestEven {\n                smallestEven = value\n                smallestEvenIndex\
    \ = index\n            }\n        }\n    }\n    if smallestEven == Int.max {\n\
    \        return []\n    }\n    return [smallestEven, smallestEvenIndex]", "  \
    \  var result = [Int]()\n    var minEven = Int.max\n    var minEvenIndex = Int.max\n\
    \    for (index, value) in arr.enumerated() {\n        if value % 2 == 0 {\n \
    \           if value < minEven {\n                minEven = value\n          \
    \      minEvenIndex = index\n            }\n        }\n    }\n    if minEven !=\
    \ Int.max {\n        result.append(minEven)\n        result.append(minEvenIndex)\n\
    \    }\n    return result", "    var smallestEven: Int?\n    var smallestEvenIndex:\
    \ Int?\n    for (index, value) in arr.enumerated() {\n        if value % 2 ==\
    \ 0 {\n            if smallestEven == nil || value < smallestEven! {\n       \
    \         smallestEven = value\n                smallestEvenIndex = index\n  \
    \          }\n        }\n    }\n    if let smallestEven = smallestEven, let smallestEvenIndex\
    \ = smallestEvenIndex {\n        return [smallestEven, smallestEvenIndex]\n  \
    \  }\n    return []"]
stop_tokens:
- "\n}"
