language: swift
name: HumanEval_87_get_row
results:
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, value) in row.enumerated() {\n            if value == x\
    \ {\n                result.append((index, index2))\n            }\n        }\n\
    \    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp_ahoplu_/tmp_ahoplu_.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b996ab8fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b996a886b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b996a886988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b996a8857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_ahoplu_                        0x000055d50709977f <unavailable> + 6015

    5    libc.so.6                          0x00002b996ad7b460 __libc_start_main +
    245

    6    tmp_ahoplu_                        0x000055d507099249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (row, row_lst) in lst.enumerated()\
    \ {\n        for (column, value) in row_lst.enumerated() {\n            if value\
    \ == x {\n                result.append((row, column))\n            }\n      \
    \  }\n    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 >\
    \ $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp8s8y30j3/tmp8s8y30j3.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b30deda0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b30dea97b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b30dea97988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b30dea967b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8s8y30j3                        0x0000555f7db1377f <unavailable> + 6015

    5    libc.so.6                          0x00002b30def8c460 __libc_start_main +
    245

    6    tmp8s8y30j3                        0x0000555f7db13249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (row, rowArray) in lst.enumerated()\
    \ {\n        for (column, value) in rowArray.enumerated() {\n            if value\
    \ == x {\n                result.append((row, column))\n            }\n      \
    \  }\n    }\n    return result.sorted(by: { (first, second) -> Bool in\n     \
    \   if first.0 == second.0 {\n            return first.1 > second.1\n        }\n\
    \        return first.0 < second.0\n    })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, element) in row.enumerated() {\n            if element ==\
    \ x {\n                result.append((index, index2))\n            }\n       \
    \ }\n    }\n    return result.sorted(by: { (a, b) -> Bool in\n        if a.0 ==\
    \ b.0 {\n            return a.1 > b.1\n        }\n        return a.0 < b.0\n \
    \   })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmph7nt3y9u/tmph7nt3y9u.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08b0796c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08b048db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08b048d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08b048c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph7nt3y9u                        0x0000562444e0777f <unavailable> + 6015

    5    libc.so.6                          0x00002b08b0982460 __libc_start_main +
    245

    6    tmph7nt3y9u                        0x0000562444e07249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, value) in row.enumerated() {\n            if value == x\
    \ {\n                result.append((index, index2))\n            }\n        }\n\
    \    }\n    return result.sorted(by: { $0.0 < $1.0 })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,\
    \ 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpzme71o05/tmpzme71o05.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b63aef39c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b63aec30b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b63aec30988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b63aec2f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzme71o05                        0x000055d7efd6277f <unavailable> + 6015

    5    libc.so.6                          0x00002b63af125460 __libc_start_main +
    245

    6    tmpzme71o05                        0x000055d7efd62249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, value) in row.enumerated() {\n            if value == x\
    \ {\n                result.append((index, index2))\n            }\n        }\n\
    \    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp_ahoplu_/tmp_ahoplu_.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b996ab8fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b996a886b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b996a886988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b996a8857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_ahoplu_                        0x000055d50709977f <unavailable> + 6015

    5    libc.so.6                          0x00002b996ad7b460 __libc_start_main +
    245

    6    tmp_ahoplu_                        0x000055d507099249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { (a, b) -> Bool in\n        if a.0 != b.0 {\n           \
    \ return a.0 < b.0\n        } else {\n            return a.1 > b.1\n        }\n\
    \    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted { (a, b) -> Bool in\n        if a.0 == b.0 {\n            return\
    \ a.1 > b.1\n        }\n        return a.0 < b.0\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, element) in row.enumerated() {\n            if element ==\
    \ x {\n                result.append((index, index2))\n            }\n       \
    \ }\n    }\n    return result.sorted(by: {$0.0 < $1.0}).sorted(by: {$0.1 > $1.1})\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpgs7jn0h6/tmpgs7jn0h6.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b592e6d5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b592e3ccb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b592e3cc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b592e3cb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgs7jn0h6                        0x0000563775d4577f <unavailable> + 6015

    5    libc.so.6                          0x00002b592e8c1460 __libc_start_main +
    245

    6    tmpgs7jn0h6                        0x0000563775d45249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmph7nt3y9u/tmph7nt3y9u.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08b0796c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08b048db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08b048d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08b048c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph7nt3y9u                        0x0000562444e0777f <unavailable> + 6015

    5    libc.so.6                          0x00002b08b0982460 __libc_start_main +
    245

    6    tmph7nt3y9u                        0x0000562444e07249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    result.sort\
    \ { (a, b) -> Bool in\n        if a.0 == b.0 {\n            return a.1 > b.1\n\
    \        }\n        return a.0 < b.0\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, element) in row.enumerated() {\n            if element ==\
    \ x {\n                result.append((index, index2))\n            }\n       \
    \ }\n    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 >\
    \ $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp9n_86dvt/tmp9n_86dvt.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b402a55cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b402a253b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b402a253988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b402a2527b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9n_86dvt                        0x000055f66253977f <unavailable> + 6015

    5    libc.so.6                          0x00002b402a748460 __libc_start_main +
    245

    6    tmp9n_86dvt                        0x000055f662539249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (row, row_lst) in lst.enumerated()\
    \ {\n        for (col, item) in row_lst.enumerated() {\n            if item ==\
    \ x {\n                result.append((row, col))\n            }\n        }\n \
    \   }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpkgtn4u4g/tmpkgtn4u4g.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aebb3bd1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aebb38c8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aebb38c8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aebb38c77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkgtn4u4g                        0x000055a0ab8c977f <unavailable> + 6015

    5    libc.so.6                          0x00002aebb3dbd460 __libc_start_main +
    245

    6    tmpkgtn4u4g                        0x000055a0ab8c9249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmph7nt3y9u/tmph7nt3y9u.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08b0796c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08b048db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08b048d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08b048c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph7nt3y9u                        0x0000562444e0777f <unavailable> + 6015

    5    libc.so.6                          0x00002b08b0982460 __libc_start_main +
    245

    6    tmph7nt3y9u                        0x0000562444e07249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (row, row_lst) in lst.enumerated()\
    \ {\n        for (col, elem) in row_lst.enumerated() {\n            if elem ==\
    \ x {\n                result.append((row, col))\n            }\n        }\n \
    \   }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmphqnq3ikz/tmphqnq3ikz.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3e0870cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3e08403b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3e08403988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3e084027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphqnq3ikz                        0x000055b60961477f <unavailable> + 6015

    5    libc.so.6                          0x00002b3e088f8460 __libc_start_main +
    245

    6    tmphqnq3ikz                        0x000055b609614249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, col) in row.enumerated() {\n            if col == x {\n      \
    \          result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { (a, b) -> Bool in\n        if a.0 == b.0 {\n           \
    \ return a.1 > b.1\n        }\n        return a.0 < b.0\n    })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted { (t1, t2) -> Bool in\n        if t1.0 == t2.0 {\n           \
    \ return t1.1 > t2.1\n        }\n        return t1.0 < t2.0\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (row, row_lst) in lst.enumerated()\
    \ {\n        for (col, val) in row_lst.enumerated() {\n            if val == x\
    \ {\n                result.append((row, col))\n            }\n        }\n   \
    \ }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmprwhl97_3/tmprwhl97_3.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac1e815ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac1e7e51b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac1e7e51988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac1e7e507b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprwhl97_3                        0x00005566d17b677f <unavailable> + 6015

    5    libc.so.6                          0x00002ac1e8346460 __libc_start_main +
    245

    6    tmprwhl97_3                        0x00005566d17b6249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, num) in row.enumerated() {\n            if num == x {\n      \
    \          result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { (a, b) -> Bool in\n        if a.0 == b.0 {\n           \
    \ return a.1 > b.1\n        }\n        return a.0 < b.0\n    })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, value) in row.enumerated() {\n            if value == x\
    \ {\n                result.append((index, index2))\n            }\n        }\n\
    \    }\n    return result.sorted {\n        if $0.0 == $1.0 {\n            return\
    \ $0.1 > $1.1\n        }\n        return $0.0 < $1.0\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, element) in row.enumerated() {\n            if element ==\
    \ x {\n                result.append((index, index2))\n            }\n       \
    \ }\n    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 >\
    \ $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp9n_86dvt/tmp9n_86dvt.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b402a55cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b402a253b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b402a253988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b402a2527b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9n_86dvt                        0x000055f66253977f <unavailable> + 6015

    5    libc.so.6                          0x00002b402a748460 __libc_start_main +
    245

    6    tmp9n_86dvt                        0x000055f662539249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, array) in lst.enumerated()\
    \ {\n        for (index2, value) in array.enumerated() {\n            if value\
    \ == x {\n                result.append((index, index2))\n            }\n    \
    \    }\n    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1\
    \ > $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpjg1ypur4/tmpjg1ypur4.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adf074e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adf071dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adf071da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adf071d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjg1ypur4                        0x00005609e69f377f <unavailable> + 6015

    5    libc.so.6                          0x00002adf076cf460 __libc_start_main +
    245

    6    tmpjg1ypur4                        0x00005609e69f3249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for i in 0..<lst.count {\n        for\
    \ j in 0..<lst[i].count {\n            if lst[i][j] == x {\n                result.append((i,\
    \ j))\n            }\n        }\n    }\n    return result.sorted(by: { $0.0 <\
    \ $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3,\
    \ 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3,\
    \ 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp2u0dqtn8/tmp2u0dqtn8.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1020257c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b101ff4eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b101ff4e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b101ff4d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2u0dqtn8                        0x00005636c511c7ef <unavailable> + 6127

    5    libc.so.6                          0x00002b1020443460 __libc_start_main +
    245

    6    tmp2u0dqtn8                        0x00005636c511c2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result = [(Int, Int)]()\n    for (i, row) in lst.enumerated() {\n   \
    \     for (j, item) in row.enumerated() {\n            if item == x {\n      \
    \          result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted {\n        if $0.0 == $1.0 {\n            return $0.1 > $1.1\n\
    \        }\n        return $0.0 < $1.0\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, value) in row.enumerated() {\n            if value == x\
    \ {\n                result.append((index, index2))\n            }\n        }\n\
    \    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp_ahoplu_/tmp_ahoplu_.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b996ab8fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b996a886b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b996a886988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b996a8857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_ahoplu_                        0x000055d50709977f <unavailable> + 6015

    5    libc.so.6                          0x00002b996ad7b460 __libc_start_main +
    245

    6    tmp_ahoplu_                        0x000055d507099249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, element) in row.enumerated() {\n            if element ==\
    \ x {\n                result.append((index, index2))\n            }\n       \
    \ }\n    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 >\
    \ $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp9n_86dvt/tmp9n_86dvt.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b402a55cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b402a253b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b402a253988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b402a2527b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9n_86dvt                        0x000055f66253977f <unavailable> + 6015

    5    libc.so.6                          0x00002b402a748460 __libc_start_main +
    245

    6    tmp9n_86dvt                        0x000055f662539249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, item) in row.enumerated() {\n            if item == x {\n\
    \                result.append((index, index2))\n            }\n        }\n  \
    \  }\n    return result.sorted { (first, second) -> Bool in\n        if first.0\
    \ == second.0 {\n            return first.1 > second.1\n        }\n        return\
    \ first.0 < second.0\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5,\
    \ 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3,\
    \ 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4,\
    \ 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]],\
    \ x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int,\
    \ Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmph7nt3y9u/tmph7nt3y9u.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08b0796c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08b048db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08b048d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08b048c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph7nt3y9u                        0x0000562444e0777f <unavailable> + 6015

    5    libc.so.6                          0x00002b08b0982460 __libc_start_main +
    245

    6    tmph7nt3y9u                        0x0000562444e07249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, col) in row.enumerated() {\n            if col == x {\n      \
    \          result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted { (a, b) -> Bool in\n        if a.0 == b.0 {\n            return\
    \ a.1 > b.1\n        }\n        return a.0 < b.0\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { (a, b) -> Bool in\n        if a.0 == b.0 {\n           \
    \ return a.1 > b.1\n        }\n        return a.0 < b.0\n    })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted { (a, b) -> Bool in\n        if a.0 == b.0 {\n            return\
    \ a.1 > b.1\n        }\n        return a.0 < b.0\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, item) in row.enumerated() {\n            if item == x {\n\
    \                result.append((index, index2))\n            }\n        }\n  \
    \  }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpbku9cpm_/tmpbku9cpm_.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4d74c33c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4d7492ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4d7492a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4d749297b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbku9cpm_                        0x000055f9ded2d77f <unavailable> + 6015

    5    libc.so.6                          0x00002b4d74e1f460 __libc_start_main +
    245

    6    tmpbku9cpm_                        0x000055f9ded2d249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, col) in row.enumerated() {\n            if col == x {\n      \
    \          result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp7ol0y9pf/tmp7ol0y9pf.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96995fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac969656b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac969656988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9696557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7ol0y9pf                        0x000056020399e77f <unavailable> + 6015

    5    libc.so.6                          0x00002ac969b4b460 __libc_start_main +
    245

    6    tmp7ol0y9pf                        0x000056020399e249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, value) in row.enumerated() {\n            if value == x\
    \ {\n                result.append((index, index2))\n            }\n        }\n\
    \    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp_ahoplu_/tmp_ahoplu_.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b996ab8fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b996a886b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b996a886988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b996a8857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_ahoplu_                        0x000055d50709977f <unavailable> + 6015

    5    libc.so.6                          0x00002b996ad7b460 __libc_start_main +
    245

    6    tmp_ahoplu_                        0x000055d507099249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmph7nt3y9u/tmph7nt3y9u.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08b0796c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08b048db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08b048d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08b048c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph7nt3y9u                        0x0000562444e0777f <unavailable> + 6015

    5    libc.so.6                          0x00002b08b0982460 __libc_start_main +
    245

    6    tmph7nt3y9u                        0x0000562444e07249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, element) in row.enumerated() {\n            if element ==\
    \ x {\n                result.append((index, index2))\n            }\n       \
    \ }\n    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 >\
    \ $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp9n_86dvt/tmp9n_86dvt.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b402a55cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b402a253b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b402a253988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b402a2527b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9n_86dvt                        0x000055f66253977f <unavailable> + 6015

    5    libc.so.6                          0x00002b402a748460 __libc_start_main +
    245

    6    tmp9n_86dvt                        0x000055f662539249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (row, row_lst) in lst.enumerated()\
    \ {\n        for (column, value) in row_lst.enumerated() {\n            if value\
    \ == x {\n                result.append((row, column))\n            }\n      \
    \  }\n    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 >\
    \ $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp8s8y30j3/tmp8s8y30j3.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b30deda0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b30dea97b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b30dea97988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b30dea967b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8s8y30j3                        0x0000555f7db1377f <unavailable> + 6015

    5    libc.so.6                          0x00002b30def8c460 __libc_start_main +
    245

    6    tmp8s8y30j3                        0x0000555f7db13249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { (a, b) -> Bool in\n        if a.0 == b.0 {\n           \
    \ return a.1 > b.1\n        }\n        return a.0 < b.0\n    })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result = [(Int, Int)]()\n    for (i, row) in lst.enumerated() {\n   \
    \     for (j, element) in row.enumerated() {\n            if element == x {\n\
    \                result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted { $0.0 < $1.0 }.sorted { $0.1 > $1.1 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,\
    \ 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpye614ty6/tmpye614ty6.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4500f44c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4500c3bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4500c3b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4500c3a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpye614ty6                        0x0000558a8d8f67cf <unavailable> + 6095

    5    libc.so.6                          0x00002b4501130460 __libc_start_main +
    245

    6    tmpye614ty6                        0x0000558a8d8f6299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, element) in row.enumerated() {\n            if element ==\
    \ x {\n                result.append((index, index2))\n            }\n       \
    \ }\n    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 >\
    \ $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp9n_86dvt/tmp9n_86dvt.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b402a55cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b402a253b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b402a253988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b402a2527b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9n_86dvt                        0x000055f66253977f <unavailable> + 6015

    5    libc.so.6                          0x00002b402a748460 __libc_start_main +
    245

    6    tmp9n_86dvt                        0x000055f662539249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmph7nt3y9u/tmph7nt3y9u.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08b0796c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08b048db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08b048d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08b048c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph7nt3y9u                        0x0000562444e0777f <unavailable> + 6015

    5    libc.so.6                          0x00002b08b0982460 __libc_start_main +
    245

    6    tmph7nt3y9u                        0x0000562444e07249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmph7nt3y9u/tmph7nt3y9u.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08b0796c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08b048db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08b048d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08b048c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph7nt3y9u                        0x0000562444e0777f <unavailable> + 6015

    5    libc.so.6                          0x00002b08b0982460 __libc_start_main +
    245

    6    tmph7nt3y9u                        0x0000562444e07249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, num) in row.enumerated() {\n            if num == x {\n      \
    \          result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted {\n        if $0.0 != $1.0 {\n            return $0.0 < $1.0\n\
    \        } else {\n            return $0.1 > $1.1\n        }\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013890
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted { (a, b) -> Bool in\n        if a.0 == b.0 {\n            return\
    \ a.1 > b.1\n        }\n        return a.0 < b.0\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (row, row_arr) in lst.enumerated()\
    \ {\n        for (col, val) in row_arr.enumerated() {\n            if val == x\
    \ {\n                result.append((row, col))\n            }\n        }\n   \
    \ }\n    return result.sorted(by: { (a, b) -> Bool in\n        if a.0 == b.0 {\n\
    \            return a.1 > b.1\n        }\n        return a.0 < b.0\n    })\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013890
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted { $0.0 < $1.0 }.sorted { $0.1 > $1.1 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,\
    \ 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp99d7uohn/tmp99d7uohn.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0b7f95ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0b7f651b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0b7f651988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0b7f6507b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp99d7uohn                        0x0000558eb93b177f <unavailable> + 6015

    5    libc.so.6                          0x00002b0b7fb46460 __libc_start_main +
    245

    6    tmp99d7uohn                        0x0000558eb93b1249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013890
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { (a, b) -> Bool in\n        if a.0 == b.0 {\n           \
    \ return a.1 > b.1\n        }\n        return a.0 < b.0\n    })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { (a, b) -> Bool in\n        if a.0 == b.0 {\n           \
    \ return a.1 > b.1\n        }\n        return a.0 < b.0\n    })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, value) in row.enumerated() {\n            if value == x\
    \ {\n                result.append((index, index2))\n            }\n        }\n\
    \    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp_ahoplu_/tmp_ahoplu_.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b996ab8fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b996a886b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b996a886988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b996a8857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_ahoplu_                        0x000055d50709977f <unavailable> + 6015

    5    libc.so.6                          0x00002b996ad7b460 __libc_start_main +
    245

    6    tmp_ahoplu_                        0x000055d507099249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, element) in row.enumerated() {\n            if element ==\
    \ x {\n                result.append((index, index2))\n            }\n       \
    \ }\n    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 >\
    \ $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp9n_86dvt/tmp9n_86dvt.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b402a55cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b402a253b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b402a253988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b402a2527b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9n_86dvt                        0x000055f66253977f <unavailable> + 6015

    5    libc.so.6                          0x00002b402a748460 __libc_start_main +
    245

    6    tmp9n_86dvt                        0x000055f662539249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmph7nt3y9u/tmph7nt3y9u.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08b0796c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08b048db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08b048d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08b048c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph7nt3y9u                        0x0000562444e0777f <unavailable> + 6015

    5    libc.so.6                          0x00002b08b0982460 __libc_start_main +
    245

    6    tmph7nt3y9u                        0x0000562444e07249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, value) in row.enumerated() {\n            if value == x\
    \ {\n                result.append((index, index2))\n            }\n        }\n\
    \    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp_ahoplu_/tmp_ahoplu_.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b996ab8fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b996a886b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b996a886988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b996a8857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_ahoplu_                        0x000055d50709977f <unavailable> + 6015

    5    libc.so.6                          0x00002b996ad7b460 __libc_start_main +
    245

    6    tmp_ahoplu_                        0x000055d507099249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, element) in row.enumerated() {\n            if element == x {\n\
    \                result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpatbjx30l/tmpatbjx30l.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab5a79bec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab5a76b5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab5a76b5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab5a76b47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpatbjx30l                        0x000056348f72777f <unavailable> + 6015

    5    libc.so.6                          0x00002ab5a7baa460 __libc_start_main +
    245

    6    tmpatbjx30l                        0x000056348f727249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013890
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, col) in row.enumerated() {\n            if col == x {\n      \
    \          result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp7ol0y9pf/tmp7ol0y9pf.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96995fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac969656b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac969656988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9696557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7ol0y9pf                        0x000056020399e77f <unavailable> + 6015

    5    libc.so.6                          0x00002ac969b4b460 __libc_start_main +
    245

    6    tmp7ol0y9pf                        0x000056020399e249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (row, row_lst) in lst.enumerated()\
    \ {\n        for (col, num) in row_lst.enumerated() {\n            if num == x\
    \ {\n                result.append((row, col))\n            }\n        }\n   \
    \ }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpz2qe9wi8/tmpz2qe9wi8.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af6f9ed6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af6f9bcdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af6f9bcd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af6f9bcc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz2qe9wi8                        0x00005591f6f1977f <unavailable> + 6015

    5    libc.so.6                          0x00002af6fa0c2460 __libc_start_main +
    245

    6    tmpz2qe9wi8                        0x00005591f6f19249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013890
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, item) in row.enumerated() {\n            if item == x {\n\
    \                result.append((index, index2))\n            }\n        }\n  \
    \  }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpbku9cpm_/tmpbku9cpm_.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4d74c33c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4d7492ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4d7492a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4d749297b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbku9cpm_                        0x000055f9ded2d77f <unavailable> + 6015

    5    libc.so.6                          0x00002b4d74e1f460 __libc_start_main +
    245

    6    tmpbku9cpm_                        0x000055f9ded2d249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, value) in row.enumerated() {\n            if value == x\
    \ {\n                result.append((index, index2))\n            }\n        }\n\
    \    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp_ahoplu_/tmp_ahoplu_.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b996ab8fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b996a886b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b996a886988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b996a8857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_ahoplu_                        0x000055d50709977f <unavailable> + 6015

    5    libc.so.6                          0x00002b996ad7b460 __libc_start_main +
    245

    6    tmp_ahoplu_                        0x000055d507099249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, element) in lst.enumerated()\
    \ {\n        for (index2, element2) in element.enumerated() {\n            if\
    \ element2 == x {\n                result.append((index, index2))\n          \
    \  }\n        }\n    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by:\
    \ { $0.1 > $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp02n50sku/tmp02n50sku.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b46e37e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b46e34dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b46e34da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b46e34d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp02n50sku                        0x000056372af8577f <unavailable> + 6015

    5    libc.so.6                          0x00002b46e39cf460 __libc_start_main +
    245

    6    tmp02n50sku                        0x000056372af85249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (row, rowArr) in lst.enumerated()\
    \ {\n        for (col, val) in rowArr.enumerated() {\n            if val == x\
    \ {\n                result.append((row, col))\n            }\n        }\n   \
    \ }\n    return result.sorted(by: { (a, b) -> Bool in\n        if a.0 == b.0 {\n\
    \            return a.1 > b.1\n        }\n        return a.0 < b.0\n    })\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013890
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, element) in row.enumerated() {\n            if element == x {\n\
    \                result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { (a, b) -> Bool in\n        if a.0 == b.0 {\n           \
    \ return a.1 > b.1\n        }\n        return a.0 < b.0\n    })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013890
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { (a, b) -> Bool in\n        if a.0 == b.0 {\n           \
    \ return a.1 > b.1\n        }\n        return a.0 < b.0\n    })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, element) in row.enumerated() {\n            if element ==\
    \ x {\n                result.append((index, index2))\n            }\n       \
    \ }\n    }\n    return result.sorted(by: {$0.0 < $1.0}).sorted(by: {$0.1 > $1.1})\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpgs7jn0h6/tmpgs7jn0h6.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b592e6d5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b592e3ccb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b592e3cc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b592e3cb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgs7jn0h6                        0x0000563775d4577f <unavailable> + 6015

    5    libc.so.6                          0x00002b592e8c1460 __libc_start_main +
    245

    6    tmpgs7jn0h6                        0x0000563775d45249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmph7nt3y9u/tmph7nt3y9u.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08b0796c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08b048db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08b048d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08b048c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph7nt3y9u                        0x0000562444e0777f <unavailable> + 6015

    5    libc.so.6                          0x00002b08b0982460 __libc_start_main +
    245

    6    tmph7nt3y9u                        0x0000562444e07249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted { (a, b) -> Bool in\n        if a.0 == b.0 {\n            return\
    \ a.1 > b.1\n        }\n        return a.0 < b.0\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, element) in row.enumerated() {\n            if element ==\
    \ x {\n                result.append((index, index2))\n            }\n       \
    \ }\n    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 >\
    \ $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp9n_86dvt/tmp9n_86dvt.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b402a55cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b402a253b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b402a253988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b402a2527b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9n_86dvt                        0x000055f66253977f <unavailable> + 6015

    5    libc.so.6                          0x00002b402a748460 __libc_start_main +
    245

    6    tmp9n_86dvt                        0x000055f662539249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, value) in row.enumerated() {\n            if value == x\
    \ {\n                result.append((index, index2))\n            }\n        }\n\
    \    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp_ahoplu_/tmp_ahoplu_.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b996ab8fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b996a886b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b996a886988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b996a8857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_ahoplu_                        0x000055d50709977f <unavailable> + 6015

    5    libc.so.6                          0x00002b996ad7b460 __libc_start_main +
    245

    6    tmp_ahoplu_                        0x000055d507099249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, value) in row.enumerated() {\n            if value == x\
    \ {\n                result.append((index, index2))\n            }\n        }\n\
    \    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp_ahoplu_/tmp_ahoplu_.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b996ab8fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b996a886b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b996a886988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b996a8857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_ahoplu_                        0x000055d50709977f <unavailable> + 6015

    5    libc.so.6                          0x00002b996ad7b460 __libc_start_main +
    245

    6    tmp_ahoplu_                        0x000055d507099249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted { (a, b) -> Bool in\n        if a.0 == b.0 {\n            return\
    \ a.1 > b.1\n        }\n        return a.0 < b.0\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, value) in row.enumerated() {\n            if value == x\
    \ {\n                result.append((index, index2))\n            }\n        }\n\
    \    }\n    return result.sorted(by: { (a, b) -> Bool in\n        if a.0 == b.0\
    \ {\n            return a.1 > b.1\n        }\n        return a.0 < b.0\n    })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, num) in row.enumerated() {\n            if num == x {\n      \
    \          result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: {\n        if $0.0 == $1.0 {\n            return $0.1 > $1.1\n\
    \        }\n        return $0.0 < $1.0\n    })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (row, row_lst) in lst.enumerated()\
    \ {\n        for (column, element) in row_lst.enumerated() {\n            if element\
    \ == x {\n                result.append((row, column))\n            }\n      \
    \  }\n    }\n    return result.sorted(by: { (a, b) -> Bool in\n        if a.0\
    \ == b.0 {\n            return a.1 > b.1\n        }\n        return a.0 < b.0\n\
    \    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013890
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, element) in row.enumerated() {\n            if element ==\
    \ x {\n                result.append((index, index2))\n            }\n       \
    \ }\n    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 >\
    \ $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp9n_86dvt/tmp9n_86dvt.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b402a55cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b402a253b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b402a253988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b402a2527b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9n_86dvt                        0x000055f66253977f <unavailable> + 6015

    5    libc.so.6                          0x00002b402a748460 __libc_start_main +
    245

    6    tmp9n_86dvt                        0x000055f662539249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted { (a, b) -> Bool in\n        if a.0 == b.0 {\n            return\
    \ a.1 > b.1\n        }\n        return a.0 < b.0\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, element) in row.enumerated() {\n            if element ==\
    \ x {\n                result.append((index, index2))\n            }\n       \
    \ }\n    }\n    return result.sorted(by: {\n        if $0.0 == $1.0 {\n      \
    \      return $0.1 > $1.1\n        }\n        return $0.0 < $1.0\n    })\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013890
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (row, row_lst) in lst.enumerated()\
    \ {\n        for (col, item) in row_lst.enumerated() {\n            if item ==\
    \ x {\n                result.append((row, col))\n            }\n        }\n \
    \   }\n    return result.sorted(by: { (a, b) -> Bool in\n        if a.0 < b.0\
    \ {\n            return true\n        } else if a.0 == b.0 {\n            return\
    \ a.1 > b.1\n        } else {\n            return false\n        }\n    })\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, value) in row.enumerated() {\n            if value == x\
    \ {\n                result.append((index, index2))\n            }\n        }\n\
    \    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp_ahoplu_/tmp_ahoplu_.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b996ab8fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b996a886b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b996a886988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b996a8857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_ahoplu_                        0x000055d50709977f <unavailable> + 6015

    5    libc.so.6                          0x00002b996ad7b460 __libc_start_main +
    245

    6    tmp_ahoplu_                        0x000055d507099249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, item) in row.enumerated() {\n            if item == x {\n\
    \                result.append((index, index2))\n            }\n        }\n  \
    \  }\n    return result.sorted(by: { (a, b) -> Bool in\n        if a.0 == b.0\
    \ {\n            return a.1 > b.1\n        }\n        return a.0 < b.0\n    })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013890
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted { (a, b) -> Bool in\n        if a.0 == b.0 {\n            return\
    \ a.1 > b.1\n        }\n        return a.0 < b.0\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (row, row_lst) in lst.enumerated()\
    \ {\n        for (col, item) in row_lst.enumerated() {\n            if item ==\
    \ x {\n                result.append((row, col))\n            }\n        }\n \
    \   }\n    return result.sorted(by: { (a, b) -> Bool in\n        if a.0 < b.0\
    \ {\n            return true\n        } else if a.0 == b.0 {\n            return\
    \ a.1 > b.1\n        } else {\n            return false\n        }\n    })\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, value) in row.enumerated() {\n            if value == x\
    \ {\n                result.append((index, index2))\n            }\n        }\n\
    \    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp_ahoplu_/tmp_ahoplu_.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b996ab8fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b996a886b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b996a886988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b996a8857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_ahoplu_                        0x000055d50709977f <unavailable> + 6015

    5    libc.so.6                          0x00002b996ad7b460 __libc_start_main +
    245

    6    tmp_ahoplu_                        0x000055d507099249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, element) in row.enumerated() {\n            if element ==\
    \ x {\n                result.append((index, index2))\n            }\n       \
    \ }\n    }\n    return result.sorted(by: {$0.0 < $1.0}).sorted(by: {$0.1 > $1.1})\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpgs7jn0h6/tmpgs7jn0h6.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b592e6d5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b592e3ccb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b592e3cc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b592e3cb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgs7jn0h6                        0x0000563775d4577f <unavailable> + 6015

    5    libc.so.6                          0x00002b592e8c1460 __libc_start_main +
    245

    6    tmpgs7jn0h6                        0x0000563775d45249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, element) in row.enumerated() {\n            if element ==\
    \ x {\n                result.append((index, index2))\n            }\n       \
    \ }\n    }\n    return result.sorted(by: {$0.0 < $1.0})\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpkmtcuzvg/tmpkmtcuzvg.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad0f2be5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad0f28dcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad0f28dc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad0f28db7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkmtcuzvg                        0x0000556bc8d5b77f <unavailable> + 6015

    5    libc.so.6                          0x00002ad0f2dd1460 __libc_start_main +
    245

    6    tmpkmtcuzvg                        0x0000556bc8d5b249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013890
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (row, row_lst) in lst.enumerated()\
    \ {\n        for (col, num) in row_lst.enumerated() {\n            if num == x\
    \ {\n                result.append((row, col))\n            }\n        }\n   \
    \ }\n    return result.sorted(by: {\n        if $0.0 == $1.0 {\n            return\
    \ $0.1 > $1.1\n        }\n        return $0.0 < $1.0\n    })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013890
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, value) in row.enumerated() {\n            if value == x\
    \ {\n                result.append((index, index2))\n            }\n        }\n\
    \    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp_ahoplu_/tmp_ahoplu_.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b996ab8fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b996a886b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b996a886988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b996a8857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_ahoplu_                        0x000055d50709977f <unavailable> + 6015

    5    libc.so.6                          0x00002b996ad7b460 __libc_start_main +
    245

    6    tmp_ahoplu_                        0x000055d507099249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, array) in lst.enumerated()\
    \ {\n        for (index2, value) in array.enumerated() {\n            if value\
    \ == x {\n                result.append((index, index2))\n            }\n    \
    \    }\n    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1\
    \ > $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpjg1ypur4/tmpjg1ypur4.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adf074e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adf071dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adf071da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adf071d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjg1ypur4                        0x00005609e69f377f <unavailable> + 6015

    5    libc.so.6                          0x00002adf076cf460 __libc_start_main +
    245

    6    tmpjg1ypur4                        0x00005609e69f3249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted {\n        if $0.0 == $1.0 {\n            return $0.1 > $1.1\n\
    \        }\n        return $0.0 < $1.0\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013890
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted {\n        if $0.0 == $1.0 {\n            return $0.1 > $1.1\n\
    \        }\n        return $0.0 < $1.0\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013890
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { (a, b) -> Bool in\n        if a.0 == b.0 {\n           \
    \ return a.1 > b.1\n        }\n        return a.0 < b.0\n    })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted { (a, b) -> Bool in\n        if a.0 == b.0 {\n            return\
    \ a.1 > b.1\n        }\n        return a.0 < b.0\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (row, row_lst) in lst.enumerated()\
    \ {\n        for (col, val) in row_lst.enumerated() {\n            if val == x\
    \ {\n                result.append((row, col))\n            }\n        }\n   \
    \ }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmprwhl97_3/tmprwhl97_3.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac1e815ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac1e7e51b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac1e7e51988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac1e7e507b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprwhl97_3                        0x00005566d17b677f <unavailable> + 6015

    5    libc.so.6                          0x00002ac1e8346460 __libc_start_main +
    245

    6    tmprwhl97_3                        0x00005566d17b6249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted {\n        if $0.0 == $1.0 {\n            return $0.1 > $1.1\n\
    \        }\n        return $0.0 < $1.0\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013890
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmph7nt3y9u/tmph7nt3y9u.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08b0796c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08b048db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08b048d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08b048c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph7nt3y9u                        0x0000562444e0777f <unavailable> + 6015

    5    libc.so.6                          0x00002b08b0982460 __libc_start_main +
    245

    6    tmph7nt3y9u                        0x0000562444e07249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, item) in row.enumerated() {\n            if item == x {\n\
    \                result.append((index, index2))\n            }\n        }\n  \
    \  }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpbku9cpm_/tmpbku9cpm_.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4d74c33c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4d7492ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4d7492a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4d749297b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbku9cpm_                        0x000055f9ded2d77f <unavailable> + 6015

    5    libc.so.6                          0x00002b4d74e1f460 __libc_start_main +
    245

    6    tmpbku9cpm_                        0x000055f9ded2d249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, item) in row.enumerated() {\n            if item == x {\n\
    \                result.append((index, index2))\n            }\n        }\n  \
    \  }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpbku9cpm_/tmpbku9cpm_.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4d74c33c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4d7492ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4d7492a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4d749297b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbku9cpm_                        0x000055f9ded2d77f <unavailable> + 6015

    5    libc.so.6                          0x00002b4d74e1f460 __libc_start_main +
    245

    6    tmpbku9cpm_                        0x000055f9ded2d249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (row, row_list) in lst.enumerated()\
    \ {\n        for (column, element) in row_list.enumerated() {\n            if\
    \ element == x {\n                result.append((row, column))\n            }\n\
    \        }\n    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: {\
    \ $0.1 > $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpui__b6gz/tmpui__b6gz.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8ac19c7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8ac16beb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8ac16be988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8ac16bd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpui__b6gz                        0x0000561a5614c77f <unavailable> + 6015

    5    libc.so.6                          0x00002b8ac1bb3460 __libc_start_main +
    245

    6    tmpui__b6gz                        0x0000561a5614c249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013890
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, value) in row.enumerated() {\n            if value == x\
    \ {\n                result.append((index, index2))\n            }\n        }\n\
    \    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp_ahoplu_/tmp_ahoplu_.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b996ab8fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b996a886b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b996a886988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b996a8857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_ahoplu_                        0x000055d50709977f <unavailable> + 6015

    5    libc.so.6                          0x00002b996ad7b460 __libc_start_main +
    245

    6    tmp_ahoplu_                        0x000055d507099249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, column) in row.enumerated() {\n            if column == x {\n\
    \                result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpqxb9vx_y/tmpqxb9vx_y.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3f083dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3f0534b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac3f0534988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac3f05337b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqxb9vx_y                        0x0000564f943da77f <unavailable> + 6015

    5    libc.so.6                          0x00002ac3f0a29460 __libc_start_main +
    245

    6    tmpqxb9vx_y                        0x0000564f943da249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013890
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmph7nt3y9u/tmph7nt3y9u.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08b0796c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08b048db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08b048d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08b048c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph7nt3y9u                        0x0000562444e0777f <unavailable> + 6015

    5    libc.so.6                          0x00002b08b0982460 __libc_start_main +
    245

    6    tmph7nt3y9u                        0x0000562444e07249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, array) in lst.enumerated()\
    \ {\n        for (index2, element) in array.enumerated() {\n            if element\
    \ == x {\n                result.append((index, index2))\n            }\n    \
    \    }\n    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1\
    \ > $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpujgpuh3e/tmpujgpuh3e.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3476c9cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3476993b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3476993988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b34769927b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpujgpuh3e                        0x0000565498ae177f <unavailable> + 6015

    5    libc.so.6                          0x00002b3476e88460 __libc_start_main +
    245

    6    tmpujgpuh3e                        0x0000565498ae1249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013890
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, value) in row.enumerated() {\n            if value == x {\n  \
    \              result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp9rnjd05v/tmp9rnjd05v.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b97418d8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b97415cfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b97415cf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b97415ce7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9rnjd05v                        0x000055cf5149c77f <unavailable> + 6015

    5    libc.so.6                          0x00002b9741ac4460 __libc_start_main +
    245

    6    tmp9rnjd05v                        0x000055cf5149c249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013890
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { (a, b) -> Bool in\n        if a.0 == b.0 {\n           \
    \ return a.1 > b.1\n        }\n        return a.0 < b.0\n    })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, num) in row.enumerated() {\n            if num == x {\n      \
    \          result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted { (a, b) -> Bool in\n        if a.0 == b.0 {\n            return\
    \ a.1 > b.1\n        }\n        return a.0 < b.0\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013890
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { (a, b) -> Bool in\n        if a.0 == b.0 {\n           \
    \ return a.1 > b.1\n        }\n        return a.0 < b.0\n    })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, elem) in row.enumerated() {\n            if elem == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { (a, b) -> Bool in\n        if a.0 == b.0 {\n           \
    \ return a.1 > b.1\n        }\n        return a.0 < b.0\n    })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013890
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmph7nt3y9u/tmph7nt3y9u.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08b0796c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08b048db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08b048d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08b048c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph7nt3y9u                        0x0000562444e0777f <unavailable> + 6015

    5    libc.so.6                          0x00002b08b0982460 __libc_start_main +
    245

    6    tmph7nt3y9u                        0x0000562444e07249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmph7nt3y9u/tmph7nt3y9u.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08b0796c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08b048db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08b048d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08b048c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph7nt3y9u                        0x0000562444e0777f <unavailable> + 6015

    5    libc.so.6                          0x00002b08b0982460 __libc_start_main +
    245

    6    tmph7nt3y9u                        0x0000562444e07249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (row, rowArray) in lst.enumerated()\
    \ {\n        for (column, element) in rowArray.enumerated() {\n            if\
    \ element == x {\n                result.append((row, column))\n            }\n\
    \        }\n    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: {\
    \ $0.1 > $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpm8zz8fjb/tmpm8zz8fjb.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afaf3881c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afaf3578b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afaf3578988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afaf35777b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm8zz8fjb                        0x000056214c2dd77f <unavailable> + 6015

    5    libc.so.6                          0x00002afaf3a6d460 __libc_start_main +
    245

    6    tmpm8zz8fjb                        0x000056214c2dd249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013890
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (row, row_lst) in lst.enumerated()\
    \ {\n        for (col, val) in row_lst.enumerated() {\n            if val == x\
    \ {\n                result.append((row, col))\n            }\n        }\n   \
    \ }\n    return result.sorted {\n        if $0.0 == $1.0 {\n            return\
    \ $0.1 > $1.1\n        }\n        return $0.0 < $1.0\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013890
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmph7nt3y9u/tmph7nt3y9u.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08b0796c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08b048db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08b048d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08b048c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph7nt3y9u                        0x0000562444e0777f <unavailable> + 6015

    5    libc.so.6                          0x00002b08b0982460 __libc_start_main +
    245

    6    tmph7nt3y9u                        0x0000562444e07249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, element) in row.enumerated() {\n            if element ==\
    \ x {\n                result.append((index, index2))\n            }\n       \
    \ }\n    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 >\
    \ $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp9n_86dvt/tmp9n_86dvt.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b402a55cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b402a253b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b402a253988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b402a2527b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9n_86dvt                        0x000055f66253977f <unavailable> + 6015

    5    libc.so.6                          0x00002b402a748460 __libc_start_main +
    245

    6    tmp9n_86dvt                        0x000055f662539249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, value) in row.enumerated() {\n            if value == x\
    \ {\n                result.append((index, index2))\n            }\n        }\n\
    \    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp_ahoplu_/tmp_ahoplu_.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b996ab8fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b996a886b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b996a886988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b996a8857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_ahoplu_                        0x000055d50709977f <unavailable> + 6015

    5    libc.so.6                          0x00002b996ad7b460 __libc_start_main +
    245

    6    tmp_ahoplu_                        0x000055d507099249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, value) in row.enumerated() {\n            if value == x\
    \ {\n                result.append((index, index2))\n            }\n        }\n\
    \    }\n    return result.sorted(by: { (a, b) -> Bool in\n        if a.0 == b.0\
    \ {\n            return a.1 > b.1\n        }\n        return a.0 < b.0\n    })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, element) in row.enumerated() {\n            if element ==\
    \ x {\n                result.append((index, index2))\n            }\n       \
    \ }\n    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 >\
    \ $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp9n_86dvt/tmp9n_86dvt.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b402a55cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b402a253b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b402a253988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b402a2527b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9n_86dvt                        0x000055f66253977f <unavailable> + 6015

    5    libc.so.6                          0x00002b402a748460 __libc_start_main +
    245

    6    tmp9n_86dvt                        0x000055f662539249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (row, row_list) in lst.enumerated()\
    \ {\n        for (column, value) in row_list.enumerated() {\n            if value\
    \ == x {\n                result.append((row, column))\n            }\n      \
    \  }\n    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 >\
    \ $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp78l5mowo/tmp78l5mowo.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1bf2d91c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1bf2a88b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1bf2a88988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1bf2a877b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp78l5mowo                        0x00005590e0c5f77f <unavailable> + 6015

    5    libc.so.6                          0x00002b1bf2f7d460 __libc_start_main +
    245

    6    tmp78l5mowo                        0x00005590e0c5f249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013890
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, value) in row.enumerated() {\n            if value == x\
    \ {\n                result.append((index, index2))\n            }\n        }\n\
    \    }\n    return result.sorted { (a, b) -> Bool in\n        if a.0 == b.0 {\n\
    \            return a.1 > b.1\n        }\n        return a.0 < b.0\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013890
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, element) in row.enumerated() {\n            if element == x {\n\
    \                result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpatbjx30l/tmpatbjx30l.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab5a79bec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab5a76b5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab5a76b5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab5a76b47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpatbjx30l                        0x000056348f72777f <unavailable> + 6015

    5    libc.so.6                          0x00002ab5a7baa460 __libc_start_main +
    245

    6    tmpatbjx30l                        0x000056348f727249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013890
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (row, rowArray) in lst.enumerated()\
    \ {\n        for (column, value) in rowArray.enumerated() {\n            if value\
    \ == x {\n                result.append((row, column))\n            }\n      \
    \  }\n    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 >\
    \ $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmppo49w2ea/tmppo49w2ea.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92d766fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b92d7366b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b92d7366988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92d73657b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppo49w2ea                        0x000055bfb8d2c77f <unavailable> + 6015

    5    libc.so.6                          0x00002b92d785b460 __libc_start_main +
    245

    6    tmppo49w2ea                        0x000055bfb8d2c249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013890
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, col) in row.enumerated() {\n            if col == x {\n      \
    \          result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp7ol0y9pf/tmp7ol0y9pf.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96995fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac969656b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac969656988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9696557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7ol0y9pf                        0x000056020399e77f <unavailable> + 6015

    5    libc.so.6                          0x00002ac969b4b460 __libc_start_main +
    245

    6    tmp7ol0y9pf                        0x000056020399e249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmph7nt3y9u/tmph7nt3y9u.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08b0796c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08b048db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08b048d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08b048c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph7nt3y9u                        0x0000562444e0777f <unavailable> + 6015

    5    libc.so.6                          0x00002b08b0982460 __libc_start_main +
    245

    6    tmph7nt3y9u                        0x0000562444e07249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result = [(Int, Int)]()\n    for (i, row) in lst.enumerated() {\n   \
    \     for (j, item) in row.enumerated() {\n            if item == x {\n      \
    \          result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted { (a, b) -> Bool in\n        if a.0 == b.0 {\n            return\
    \ a.1 > b.1\n        }\n        return a.0 < b.0\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013890
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, value) in row.enumerated() {\n            if value == x\
    \ {\n                result.append((index, index2))\n            }\n        }\n\
    \    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp_ahoplu_/tmp_ahoplu_.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b996ab8fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b996a886b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b996a886988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b996a8857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_ahoplu_                        0x000055d50709977f <unavailable> + 6015

    5    libc.so.6                          0x00002b996ad7b460 __libc_start_main +
    245

    6    tmp_ahoplu_                        0x000055d507099249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmph7nt3y9u/tmph7nt3y9u.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08b0796c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08b048db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08b048d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08b048c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph7nt3y9u                        0x0000562444e0777f <unavailable> + 6015

    5    libc.so.6                          0x00002b08b0982460 __libc_start_main +
    245

    6    tmph7nt3y9u                        0x0000562444e07249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmph7nt3y9u/tmph7nt3y9u.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08b0796c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08b048db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08b048d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08b048c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph7nt3y9u                        0x0000562444e0777f <unavailable> + 6015

    5    libc.so.6                          0x00002b08b0982460 __libc_start_main +
    245

    6    tmph7nt3y9u                        0x0000562444e07249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (row, row_list) in lst.enumerated()\
    \ {\n        for (col, item) in row_list.enumerated() {\n            if item ==\
    \ x {\n                result.append((row, col))\n            }\n        }\n \
    \   }\n    return result.sorted(by: { (a, b) -> Bool in\n        if a.0 < b.0\
    \ {\n            return true\n        } else if a.0 == b.0 {\n            return\
    \ a.1 > b.1\n        } else {\n            return false\n        }\n    })\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013890
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (row, row_lst) in lst.enumerated()\
    \ {\n        for (col, num) in row_lst.enumerated() {\n            if num == x\
    \ {\n                result.append((row, col))\n            }\n        }\n   \
    \ }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpz2qe9wi8/tmpz2qe9wi8.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af6f9ed6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af6f9bcdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af6f9bcd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af6f9bcc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz2qe9wi8                        0x00005591f6f1977f <unavailable> + 6015

    5    libc.so.6                          0x00002af6fa0c2460 __libc_start_main +
    245

    6    tmpz2qe9wi8                        0x00005591f6f19249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013890
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, element) in row.enumerated() {\n            if element ==\
    \ x {\n                result.append((index, index2))\n            }\n       \
    \ }\n    }\n    return result.sorted { (a, b) -> Bool in\n        if a.0 == b.0\
    \ {\n            return a.1 > b.1\n        }\n        return a.0 < b.0\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013890
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (row, row_lst) in lst.enumerated()\
    \ {\n        for (col, val) in row_lst.enumerated() {\n            if val == x\
    \ {\n                result.append((row, col))\n            }\n        }\n   \
    \ }\n    return result.sorted(by: { (t1, t2) -> Bool in\n        if t1.0 == t2.0\
    \ {\n            return t1.1 > t2.1\n        }\n        return t1.0 < t2.0\n \
    \   })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013890
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (row, row_lst) in lst.enumerated()\
    \ {\n        for (column, element) in row_lst.enumerated() {\n            if element\
    \ == x {\n                result.append((row, column))\n            }\n      \
    \  }\n    }\n    return result.sorted { (a, b) -> Bool in\n        if a.0 == b.0\
    \ {\n            return a.1 > b.1\n        }\n        return a.0 < b.0\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013890
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { (a, b) -> Bool in\n        if a.0 == b.0 {\n           \
    \ return a.1 > b.1\n        }\n        return a.0 < b.0\n    })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmph7nt3y9u/tmph7nt3y9u.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08b0796c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08b048db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08b048d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08b048c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph7nt3y9u                        0x0000562444e0777f <unavailable> + 6015

    5    libc.so.6                          0x00002b08b0982460 __libc_start_main +
    245

    6    tmph7nt3y9u                        0x0000562444e07249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmph7nt3y9u/tmph7nt3y9u.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08b0796c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08b048db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08b048d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08b048c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph7nt3y9u                        0x0000562444e0777f <unavailable> + 6015

    5    libc.so.6                          0x00002b08b0982460 __libc_start_main +
    245

    6    tmph7nt3y9u                        0x0000562444e07249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, col) in row.enumerated() {\n            if col == x {\n      \
    \          result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp7ol0y9pf/tmp7ol0y9pf.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96995fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac969656b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac969656988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9696557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7ol0y9pf                        0x000056020399e77f <unavailable> + 6015

    5    libc.so.6                          0x00002ac969b4b460 __libc_start_main +
    245

    6    tmp7ol0y9pf                        0x000056020399e249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, elem) in row.enumerated() {\n            if elem == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { (t1, t2) -> Bool in\n        if t1.0 != t2.0 {\n       \
    \     return t1.0 < t2.0\n        } else {\n            return t1.1 > t2.1\n \
    \       }\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013890
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmph7nt3y9u/tmph7nt3y9u.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08b0796c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08b048db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08b048d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08b048c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph7nt3y9u                        0x0000562444e0777f <unavailable> + 6015

    5    libc.so.6                          0x00002b08b0982460 __libc_start_main +
    245

    6    tmph7nt3y9u                        0x0000562444e07249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmph7nt3y9u/tmph7nt3y9u.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08b0796c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08b048db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08b048d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08b048c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph7nt3y9u                        0x0000562444e0777f <unavailable> + 6015

    5    libc.so.6                          0x00002b08b0982460 __libc_start_main +
    245

    6    tmph7nt3y9u                        0x0000562444e07249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted { (a, b) -> Bool in\n        if a.0 == b.0 {\n            return\
    \ a.1 > b.1\n        }\n        return a.0 < b.0\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (row, row_lst) in lst.enumerated()\
    \ {\n        for (col, val) in row_lst.enumerated() {\n            if val == x\
    \ {\n                result.append((row, col))\n            }\n        }\n   \
    \ }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmprwhl97_3/tmprwhl97_3.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac1e815ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac1e7e51b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac1e7e51988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac1e7e507b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprwhl97_3                        0x00005566d17b677f <unavailable> + 6015

    5    libc.so.6                          0x00002ac1e8346460 __libc_start_main +
    245

    6    tmprwhl97_3                        0x00005566d17b6249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted { (a, b) -> Bool in\n        if a.0 == b.0 {\n            return\
    \ a.1 > b.1\n        }\n        return a.0 < b.0\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, value) in row.enumerated() {\n            if value == x\
    \ {\n                result.append((index, index2))\n            }\n        }\n\
    \    }\n    return result.sorted {\n        if $0.0 == $1.0 {\n            return\
    \ $0.1 > $1.1\n        }\n        return $0.0 < $1.0\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted { (a, b) -> Bool in\n        if a.0 == b.0 {\n            return\
    \ a.1 > b.1\n        }\n        return a.0 < b.0\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, value) in row.enumerated() {\n            if value == x\
    \ {\n                result.append((index, index2))\n            }\n        }\n\
    \    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp_ahoplu_/tmp_ahoplu_.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b996ab8fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b996a886b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b996a886988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b996a8857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_ahoplu_                        0x000055d50709977f <unavailable> + 6015

    5    libc.so.6                          0x00002b996ad7b460 __libc_start_main +
    245

    6    tmp_ahoplu_                        0x000055d507099249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, value) in row.enumerated() {\n            if value == x\
    \ {\n                result.append((index, index2))\n            }\n        }\n\
    \    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp_ahoplu_/tmp_ahoplu_.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b996ab8fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b996a886b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b996a886988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b996a8857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_ahoplu_                        0x000055d50709977f <unavailable> + 6015

    5    libc.so.6                          0x00002b996ad7b460 __libc_start_main +
    245

    6    tmp_ahoplu_                        0x000055d507099249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, value) in row.enumerated() {\n            if value == x\
    \ {\n                result.append((index, index2))\n            }\n        }\n\
    \    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp_ahoplu_/tmp_ahoplu_.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b996ab8fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b996a886b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b996a886988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b996a8857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_ahoplu_                        0x000055d50709977f <unavailable> + 6015

    5    libc.so.6                          0x00002b996ad7b460 __libc_start_main +
    245

    6    tmp_ahoplu_                        0x000055d507099249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, element) in row.enumerated() {\n            if element == x {\n\
    \                result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpatbjx30l/tmpatbjx30l.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab5a79bec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab5a76b5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab5a76b5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab5a76b47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpatbjx30l                        0x000056348f72777f <unavailable> + 6015

    5    libc.so.6                          0x00002ab5a7baa460 __libc_start_main +
    245

    6    tmpatbjx30l                        0x000056348f727249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013890
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmph7nt3y9u/tmph7nt3y9u.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08b0796c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08b048db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08b048d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08b048c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph7nt3y9u                        0x0000562444e0777f <unavailable> + 6015

    5    libc.so.6                          0x00002b08b0982460 __libc_start_main +
    245

    6    tmph7nt3y9u                        0x0000562444e07249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, value) in row.enumerated() {\n            if value == x {\n  \
    \              result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { (a, b) -> Bool in\n        if a.0 == b.0 {\n           \
    \ return a.1 > b.1\n        }\n        return a.0 < b.0\n    })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013890
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmph7nt3y9u/tmph7nt3y9u.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08b0796c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08b048db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08b048d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08b048c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph7nt3y9u                        0x0000562444e0777f <unavailable> + 6015

    5    libc.so.6                          0x00002b08b0982460 __libc_start_main +
    245

    6    tmph7nt3y9u                        0x0000562444e07249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmph7nt3y9u/tmph7nt3y9u.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08b0796c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08b048db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08b048d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08b048c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph7nt3y9u                        0x0000562444e0777f <unavailable> + 6015

    5    libc.so.6                          0x00002b08b0982460 __libc_start_main +
    245

    6    tmph7nt3y9u                        0x0000562444e07249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, col) in row.enumerated() {\n            if col == x {\n      \
    \          result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted { (a, b) -> Bool in\n        if a.0 == b.0 {\n            return\
    \ a.1 > b.1\n        }\n        return a.0 < b.0\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmph7nt3y9u/tmph7nt3y9u.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08b0796c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08b048db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08b048d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08b048c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph7nt3y9u                        0x0000562444e0777f <unavailable> + 6015

    5    libc.so.6                          0x00002b08b0982460 __libc_start_main +
    245

    6    tmph7nt3y9u                        0x0000562444e07249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, col) in row.enumerated() {\n            if col == x {\n      \
    \          result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp7ol0y9pf/tmp7ol0y9pf.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96995fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac969656b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac969656988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9696557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7ol0y9pf                        0x000056020399e77f <unavailable> + 6015

    5    libc.so.6                          0x00002ac969b4b460 __libc_start_main +
    245

    6    tmp7ol0y9pf                        0x000056020399e249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, col) in row.enumerated() {\n            if col == x {\n      \
    \          result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp7ol0y9pf/tmp7ol0y9pf.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96995fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac969656b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac969656988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9696557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7ol0y9pf                        0x000056020399e77f <unavailable> + 6015

    5    libc.so.6                          0x00002ac969b4b460 __libc_start_main +
    245

    6    tmp7ol0y9pf                        0x000056020399e249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (row, row_values) in lst.enumerated()\
    \ {\n        for (column, value) in row_values.enumerated() {\n            if\
    \ value == x {\n                result.append((row, column))\n            }\n\
    \        }\n    }\n    return result.sorted(by: { (first, second) -> Bool in\n\
    \        if first.0 == second.0 {\n            return first.1 > second.1\n   \
    \     }\n        return first.0 < second.0\n    })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,\
    \ 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013890
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmph7nt3y9u/tmph7nt3y9u.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08b0796c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08b048db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08b048d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08b048c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph7nt3y9u                        0x0000562444e0777f <unavailable> + 6015

    5    libc.so.6                          0x00002b08b0982460 __libc_start_main +
    245

    6    tmph7nt3y9u                        0x0000562444e07249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { (a, b) -> Bool in\n        if a.0 == b.0 {\n           \
    \ return a.1 > b.1\n        }\n        return a.0 < b.0\n    })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, value) in row.enumerated() {\n            if value == x {\n  \
    \              result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: {\n        if $0.0 == $1.0 {\n            return $0.1 > $1.1\n\
    \        }\n        return $0.0 < $1.0\n    })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013890
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, item) in row.enumerated() {\n            if item == x {\n\
    \                result.append((index, index2))\n            }\n        }\n  \
    \  }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpbku9cpm_/tmpbku9cpm_.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4d74c33c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4d7492ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4d7492a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4d749297b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbku9cpm_                        0x000055f9ded2d77f <unavailable> + 6015

    5    libc.so.6                          0x00002b4d74e1f460 __libc_start_main +
    245

    6    tmpbku9cpm_                        0x000055f9ded2d249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (row, rowArray) in lst.enumerated()\
    \ {\n        for (column, element) in rowArray.enumerated() {\n            if\
    \ element == x {\n                result.append((row, column))\n            }\n\
    \        }\n    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: {\
    \ $0.1 > $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpm8zz8fjb/tmpm8zz8fjb.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afaf3881c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afaf3578b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afaf3578988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afaf35777b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm8zz8fjb                        0x000056214c2dd77f <unavailable> + 6015

    5    libc.so.6                          0x00002afaf3a6d460 __libc_start_main +
    245

    6    tmpm8zz8fjb                        0x000056214c2dd249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013890
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, element) in row.enumerated() {\n            if element == x {\n\
    \                result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { (a, b) -> Bool in\n        if a.0 == b.0 {\n           \
    \ return a.1 > b.1\n        }\n        return a.0 < b.0\n    })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013890
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted { (a, b) -> Bool in\n        if a.0 == b.0 {\n            return\
    \ a.1 > b.1\n        }\n        return a.0 < b.0\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { (a, b) -> Bool in\n        if a.0 < b.0 {\n            return\
    \ true\n        } else if a.0 == b.0 {\n            return a.1 > b.1\n       \
    \ } else {\n            return false\n        }\n    })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013890
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: {\n        if $0.0 == $1.0 {\n            return $0.1 > $1.1\n\
    \        }\n        return $0.0 < $1.0\n    })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013890
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted { (a, b) -> Bool in\n        if a.0 == b.0 {\n            return\
    \ a.1 > b.1\n        }\n        return a.0 < b.0\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmph7nt3y9u/tmph7nt3y9u.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08b0796c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08b048db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08b048d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08b048c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph7nt3y9u                        0x0000562444e0777f <unavailable> + 6015

    5    libc.so.6                          0x00002b08b0982460 __libc_start_main +
    245

    6    tmph7nt3y9u                        0x0000562444e07249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted { $0.0 < $1.0 }.sorted { $0.1 > $1.1 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,\
    \ 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp99d7uohn/tmp99d7uohn.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0b7f95ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0b7f651b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0b7f651988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0b7f6507b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp99d7uohn                        0x0000558eb93b177f <unavailable> + 6015

    5    libc.so.6                          0x00002b0b7fb46460 __libc_start_main +
    245

    6    tmp99d7uohn                        0x0000558eb93b1249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013890
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (row, row_lst) in lst.enumerated()\
    \ {\n        for (column, element) in row_lst.enumerated() {\n            if element\
    \ == x {\n                result.append((row, column))\n            }\n      \
    \  }\n    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 >\
    \ $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpkdfc6ze7/tmpkdfc6ze7.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b49871e5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4986edcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4986edc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4986edb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkdfc6ze7                        0x000056021d51b77f <unavailable> + 6015

    5    libc.so.6                          0x00002b49873d1460 __libc_start_main +
    245

    6    tmpkdfc6ze7                        0x000056021d51b249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013890
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, value) in row.enumerated() {\n            if value == x\
    \ {\n                result.append((index, index2))\n            }\n        }\n\
    \    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp_ahoplu_/tmp_ahoplu_.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b996ab8fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b996a886b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b996a886988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b996a8857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_ahoplu_                        0x000055d50709977f <unavailable> + 6015

    5    libc.so.6                          0x00002b996ad7b460 __libc_start_main +
    245

    6    tmp_ahoplu_                        0x000055d507099249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (row, row_data) in lst.enumerated()\
    \ {\n        for (col, col_data) in row_data.enumerated() {\n            if col_data\
    \ == x {\n                result.append((row, col))\n            }\n        }\n\
    \    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpxx1em9hp/tmpxx1em9hp.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4f50ceac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4f509e1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4f509e1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4f509e07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxx1em9hp                        0x000056013017c77f <unavailable> + 6015

    5    libc.so.6                          0x00002b4f50ed6460 __libc_start_main +
    245

    6    tmpxx1em9hp                        0x000056013017c249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013890
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, element) in row.enumerated() {\n            if element ==\
    \ x {\n                result.append((index, index2))\n            }\n       \
    \ }\n    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 >\
    \ $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp9n_86dvt/tmp9n_86dvt.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b402a55cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b402a253b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b402a253988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b402a2527b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9n_86dvt                        0x000055f66253977f <unavailable> + 6015

    5    libc.so.6                          0x00002b402a748460 __libc_start_main +
    245

    6    tmp9n_86dvt                        0x000055f662539249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, element) in row.enumerated() {\n            if element ==\
    \ x {\n                result.append((index, index2))\n            }\n       \
    \ }\n    }\n    return result.sorted { (a, b) -> Bool in\n        if a.0 == b.0\
    \ {\n            return a.1 > b.1\n        }\n        return a.0 < b.0\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013890
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { (a, b) -> Bool in\n        if a.0 == b.0 {\n           \
    \ return a.1 > b.1\n        }\n        return a.0 < b.0\n    })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for i in 0..<lst.count {\n        for\
    \ j in 0..<lst[i].count {\n            if lst[i][j] == x {\n                result.append((i,\
    \ j))\n            }\n        }\n    }\n    return result.sorted {\n        if\
    \ $0.0 == $1.0 {\n            return $0.1 > $1.1\n        }\n        return $0.0\
    \ < $1.0\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013890
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, col) in row.enumerated() {\n            if col == x {\n\
    \                result.append((index, index2))\n            }\n        }\n  \
    \  }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp_rtr_fty/tmp_rtr_fty.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b05c548ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b05c5185b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b05c5185988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b05c51847b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_rtr_fty                        0x0000564a5e2da77f <unavailable> + 6015

    5    libc.so.6                          0x00002b05c567a460 __libc_start_main +
    245

    6    tmp_rtr_fty                        0x0000564a5e2da249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013890
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmph7nt3y9u/tmph7nt3y9u.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08b0796c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08b048db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08b048d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08b048c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph7nt3y9u                        0x0000562444e0777f <unavailable> + 6015

    5    libc.so.6                          0x00002b08b0982460 __libc_start_main +
    245

    6    tmph7nt3y9u                        0x0000562444e07249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result = [(Int, Int)]()\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, value) in row.enumerated() {\n            if value == x\
    \ {\n                result.append((index, index2))\n            }\n        }\n\
    \    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpt8phttfi/tmpt8phttfi.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acae7a87c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acae777eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acae777e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acae777d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt8phttfi                        0x00005606934857cf <unavailable> + 6095

    5    libc.so.6                          0x00002acae7c73460 __libc_start_main +
    245

    6    tmpt8phttfi                        0x0000560693485299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013890
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted { (a, b) -> Bool in\n        if a.0 == b.0 {\n            return\
    \ a.1 > b.1\n        }\n        return a.0 < b.0\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted { (a, b) -> Bool in\n        if a.0 == b.0 {\n            return\
    \ a.1 > b.1\n        }\n        return a.0 < b.0\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, value) in row.enumerated() {\n            if value == x {\n  \
    \              result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp9rnjd05v/tmp9rnjd05v.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b97418d8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b97415cfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b97415cf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b97415ce7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9rnjd05v                        0x000055cf5149c77f <unavailable> + 6015

    5    libc.so.6                          0x00002b9741ac4460 __libc_start_main +
    245

    6    tmp9rnjd05v                        0x000055cf5149c249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013890
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, element) in row.enumerated() {\n            if element ==\
    \ x {\n                result.append((index, index2))\n            }\n       \
    \ }\n    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 >\
    \ $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp9n_86dvt/tmp9n_86dvt.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b402a55cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b402a253b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b402a253988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b402a2527b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9n_86dvt                        0x000055f66253977f <unavailable> + 6015

    5    libc.so.6                          0x00002b402a748460 __libc_start_main +
    245

    6    tmp9n_86dvt                        0x000055f662539249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, element) in row.enumerated() {\n            if element == x {\n\
    \                result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpatbjx30l/tmpatbjx30l.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab5a79bec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab5a76b5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab5a76b5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab5a76b47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpatbjx30l                        0x000056348f72777f <unavailable> + 6015

    5    libc.so.6                          0x00002ab5a7baa460 __libc_start_main +
    245

    6    tmpatbjx30l                        0x000056348f727249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013890
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted { (a, b) -> Bool in\n        if a.0 == b.0 {\n            return\
    \ a.1 > b.1\n        }\n        return a.0 < b.0\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted { (a, b) -> Bool in\n        if a.0 == b.0 {\n            return\
    \ a.1 > b.1\n        }\n        return a.0 < b.0\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, value) in row.enumerated() {\n            if value == x {\n  \
    \              result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp9rnjd05v/tmp9rnjd05v.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b97418d8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b97415cfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b97415cf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b97415ce7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9rnjd05v                        0x000055cf5149c77f <unavailable> + 6015

    5    libc.so.6                          0x00002b9741ac4460 __libc_start_main +
    245

    6    tmp9rnjd05v                        0x000055cf5149c249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013890
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, item) in row.enumerated() {\n            if item == x {\n\
    \                result.append((index, index2))\n            }\n        }\n  \
    \  }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpbku9cpm_/tmpbku9cpm_.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4d74c33c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4d7492ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4d7492a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4d749297b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbku9cpm_                        0x000055f9ded2d77f <unavailable> + 6015

    5    libc.so.6                          0x00002b4d74e1f460 __libc_start_main +
    245

    6    tmpbku9cpm_                        0x000055f9ded2d249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, element) in row.enumerated() {\n            if element ==\
    \ x {\n                result.append((index, index2))\n            }\n       \
    \ }\n    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 >\
    \ $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp9n_86dvt/tmp9n_86dvt.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b402a55cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b402a253b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b402a253988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b402a2527b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9n_86dvt                        0x000055f66253977f <unavailable> + 6015

    5    libc.so.6                          0x00002b402a748460 __libc_start_main +
    245

    6    tmp9n_86dvt                        0x000055f662539249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, element) in row.enumerated() {\n            if element ==\
    \ x {\n                result.append((index, index2))\n            }\n       \
    \ }\n    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 >\
    \ $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp9n_86dvt/tmp9n_86dvt.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b402a55cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b402a253b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b402a253988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b402a2527b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9n_86dvt                        0x000055f66253977f <unavailable> + 6015

    5    libc.so.6                          0x00002b402a748460 __libc_start_main +
    245

    6    tmp9n_86dvt                        0x000055f662539249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, value) in row.enumerated() {\n            if value == x\
    \ {\n                result.append((index, index2))\n            }\n        }\n\
    \    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp_ahoplu_/tmp_ahoplu_.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b996ab8fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b996a886b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b996a886988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b996a8857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_ahoplu_                        0x000055d50709977f <unavailable> + 6015

    5    libc.so.6                          0x00002b996ad7b460 __libc_start_main +
    245

    6    tmp_ahoplu_                        0x000055d507099249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, element) in row.enumerated() {\n            if element ==\
    \ x {\n                result.append((index, index2))\n            }\n       \
    \ }\n    }\n    return result.sorted(by: { $0.0 < $1.0 })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpd4mogtiz/tmpd4mogtiz.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae5895e0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae5892d7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae5892d7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae5892d67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd4mogtiz                        0x000055685816b77f <unavailable> + 6015

    5    libc.so.6                          0x00002ae5897cc460 __libc_start_main +
    245

    6    tmpd4mogtiz                        0x000055685816b249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013890
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, value) in row.enumerated() {\n            if value == x\
    \ {\n                result.append((index, index2))\n            }\n        }\n\
    \    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp_ahoplu_/tmp_ahoplu_.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b996ab8fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b996a886b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b996a886988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b996a8857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_ahoplu_                        0x000055d50709977f <unavailable> + 6015

    5    libc.so.6                          0x00002b996ad7b460 __libc_start_main +
    245

    6    tmp_ahoplu_                        0x000055d507099249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (row, row_lst) in lst.enumerated()\
    \ {\n        for (col, val) in row_lst.enumerated() {\n            if val == x\
    \ {\n                result.append((row, col))\n            }\n        }\n   \
    \ }\n    return result.sorted(by: { (a, b) -> Bool in\n        if a.0 != b.0 {\n\
    \            return a.0 < b.0\n        } else {\n            return a.1 > b.1\n\
    \        }\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013890
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, value) in row.enumerated() {\n            if value == x\
    \ {\n                result.append((index, index2))\n            }\n        }\n\
    \    }\n    return result.sorted {\n        if $0.0 == $1.0 {\n            return\
    \ $0.1 > $1.1\n        }\n        return $0.0 < $1.0\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for i in 0..<lst.count {\n        for\
    \ j in 0..<lst[i].count {\n            if lst[i][j] == x {\n                result.append((i,\
    \ j))\n            }\n        }\n    }\n    return result.sorted(by: { (a, b)\
    \ -> Bool in\n        if a.0 == b.0 {\n            return a.1 > b.1\n        }\n\
    \        return a.0 < b.0\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5,\
    \ 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3,\
    \ 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4,\
    \ 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]],\
    \ x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int,\
    \ Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013890
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmph7nt3y9u/tmph7nt3y9u.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08b0796c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08b048db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08b048d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08b048c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph7nt3y9u                        0x0000562444e0777f <unavailable> + 6015

    5    libc.so.6                          0x00002b08b0982460 __libc_start_main +
    245

    6    tmph7nt3y9u                        0x0000562444e07249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var res: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n    \
    \    for (j, item) in row.enumerated() {\n            if item == x {\n       \
    \         res.append((i, j))\n            }\n        }\n    }\n    return res.sorted\
    \ {\n        if $0.0 == $1.0 {\n            return $0.1 > $1.1\n        }\n  \
    \      return $0.0 < $1.0\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5,\
    \ 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3,\
    \ 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4,\
    \ 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]],\
    \ x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int,\
    \ Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013890
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, item) in row.enumerated() {\n            if item == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted {\n        if $0.0 == $1.0 {\n            return $0.1 > $1.1\n\
    \        }\n        return $0.0 < $1.0\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013890
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, element) in row.enumerated() {\n            if element ==\
    \ x {\n                result.append((index, index2))\n            }\n       \
    \ }\n    }\n    return result.sorted(by: { (a, b) -> Bool in\n        if a.0 ==\
    \ b.0 {\n            return a.1 > b.1\n        }\n        return a.0 < b.0\n \
    \   })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013889
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, value) in row.enumerated() {\n            if value == x {\n  \
    \              result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted { (a, b) -> Bool in\n        if a.0 == b.0 {\n            return\
    \ a.1 > b.1\n        }\n        return a.0 < b.0\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013890
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (i, item) in row.enumerated() {\n            if item == x {\n   \
    \             result.append((index, i))\n            }\n        }\n    }\n   \
    \ return result.sorted { (t1, t2) -> Bool in\n        if t1.0 == t2.0 {\n    \
    \        return t1.1 > t2.1\n        }\n        return t1.0 < t2.0\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013890
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, element) in row.enumerated() {\n            if element ==\
    \ x {\n                result.append((index, index2))\n            }\n       \
    \ }\n    }\n    return result.sorted { $0.0 < $1.0 }.sorted { $0.1 > $1.1 }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmprfyxgiis/tmprfyxgiis.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3e57c70c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3e57967b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3e57967988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3e579667b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprfyxgiis                        0x000056419288677f <unavailable> + 6015

    5    libc.so.6                          0x00002b3e57e5c460 __libc_start_main +
    245

    6    tmprfyxgiis                        0x0000564192886249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013890
