language: swift
name: HumanEval_115_max_fill
results:
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    var filled = 0\n    var\
    \ i = 0\n    while i < grid.count {\n        var j = 0\n        while j < grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                filled += 1\n         \
    \       grid[i][j] = 0\n            }\n            j += 1\n        }\n       \
    \ if filled == capacity {\n            filled = 0\n            count += 1\n  \
    \      }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmprlpvexhw/tmprlpvexhw.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad968a09c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad968700b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad968700988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad9686ff7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprlpvexhw                        0x0000555d48fc7576 <unavailable> + 5494

    5    libc.so.6                          0x00002ad968bf5460 __libc_start_main +
    245

    6    tmprlpvexhw                        0x0000555d48fc7109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1659824404
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    while true {\n       \
    \ var isEmpty = true\n        for i in 0..<grid.count {\n            for j in\
    \ 0..<grid[i].count {\n                if grid[i][j] == 1 {\n                \
    \    isEmpty = false\n                    grid[i][j] = 0\n                   \
    \ count += 1\n                }\n            }\n        }\n        if isEmpty\
    \ {\n            break\n        }\n        for i in 0..<grid.count {\n       \
    \     for j in 0..<grid[i].count {\n                if grid[i][j] == 0 {\n   \
    \                 grid[i][j] = 1\n                }\n            }\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, i: i, j: j, capacity:\
    \ capacity)\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmporchcpto.swift:30:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    var row = 0\n    while\
    \ row < grid.count {\n        var col = 0\n        while col < grid[row].count\
    \ {\n            if grid[row][col] == 1 {\n                count += 1\n      \
    \          var bucket = capacity\n                while bucket > 0 {\n       \
    \             if row < grid.count && grid[row][col] == 1 {\n                 \
    \       grid[row][col] = 0\n                        bucket -= 1\n            \
    \        }\n                    row += 1\n                }\n                row\
    \ -= 1\n            }\n            col += 1\n        }\n        row += 1\n   \
    \ }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp478afdoq/tmp478afdoq.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3ab3dffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3ab3af6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3ab3af6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3ab3af57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp478afdoq                        0x0000556fe7731747 <unavailable> + 5959

    5    libc.so.6                          0x00002b3ab3feb460 __libc_start_main +
    245

    6    tmp478afdoq                        0x0000556fe7731109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1659824404
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, i: i, j: j, capacity:\
    \ capacity)\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmporchcpto.swift:30:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, i: i, j: j, capacity:\
    \ capacity)\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmporchcpto.swift:30:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var buckets = [Int](repeating: 0, count: grid[0].count)\n    var\
    \ count = 0\n    for row in grid {\n        for (i, well) in row.enumerated()\
    \ {\n            if well == 1 {\n                if buckets[i] < capacity {\n\
    \                    buckets[i] += 1\n                    count += 1\n       \
    \         }\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpq03d8gh4/tmpq03d8gh4.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b33f184ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b33f1541b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b33f1541988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b33f15407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq03d8gh4                        0x0000564074f92916 <unavailable> + 6422

    5    libc.so.6                          0x00002b33f1a36460 __libc_start_main +
    245

    6    tmpq03d8gh4                        0x0000564074f924a9 <unavailable> + 5289

    '
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                for k in i..<grid.count {\n     \
    \               if grid[k][j] == 1 {\n                        grid[k][j] = 0\n\
    \                    } else {\n                        break\n               \
    \     }\n                }\n            }\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpk4znrc_3/tmpk4znrc_3.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6d242eac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6d23fe1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6d23fe1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6d23fe07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk4znrc_3                        0x000056453bdf0706 <unavailable> + 5894

    5    libc.so.6                          0x00002b6d244d6460 __libc_start_main +
    245

    6    tmpk4znrc_3                        0x000056453bdf0299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    var max = 0\n    for row in grid {\n      \
    \  for cell in row {\n            if cell == 1 {\n                max += 1\n \
    \           }\n        }\n    }\n    while count < max {\n        for row in grid\
    \ {\n            for cell in row {\n                if cell == 1 {\n         \
    \           count += 1\n                }\n            }\n        }\n    }\n \
    \   return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp2pt89w34/tmp2pt89w34.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b59ffd57c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b59ffa4eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b59ffa4e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b59ffa4d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2pt89w34                        0x0000560c634d7717 <unavailable> + 5911

    5    libc.so.6                          0x00002b59fff43460 __libc_start_main +
    245

    6    tmp2pt89w34                        0x0000560c634d70d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824404
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    while true {\n       \
    \ var filled = false\n        for i in 0..<grid.count {\n            for j in\
    \ 0..<grid[i].count {\n                if grid[i][j] == 1 {\n                \
    \    filled = true\n                    grid[i][j] = 0\n                    count\
    \ += 1\n                }\n            }\n        }\n        if !filled {\n  \
    \          break\n        }\n        for i in 0..<grid.count {\n            for\
    \ j in 0..<grid[i].count {\n                if grid[i][j] == 0 {\n           \
    \         grid[i][j] = 1\n                }\n            }\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var buckets = [Int](repeating: 0, count: grid[0].count)\n    var\
    \ count = 0\n    for row in grid {\n        for (index, well) in row.enumerated()\
    \ {\n            if well == 1 {\n                buckets[index] += 1\n       \
    \     }\n        }\n        count += fill_buckets(buckets: &buckets, capacity:\
    \ capacity)\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpv12g2p4t.swift:32:18: error: cannot find 'fill_buckets' in scope\n\
    \        count += fill_buckets(buckets: &buckets, capacity: capacity)\n      \
    \           ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                grid[i][j] = 0\n                count += 1\n                var\
    \ k = i\n                while k < grid.count && capacity > 0 {\n            \
    \        if grid[k][j] == 1 {\n                        grid[k][j] = 0\n      \
    \                  capacity -= 1\n                    }\n                    k\
    \ += 1\n                }\n            }\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmphyuu5ah6.swift:35:34: error: left side of mutating operator isn't\
    \ mutable: 'capacity' is a 'let' constant\n                        capacity -=\
    \ 1\n                        ~~~~~~~~ ^\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                for k in 0..<capacity {\n       \
    \             if i+k < grid.count {\n                        grid[i+k][j] = 0\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpt2dcp1by/tmpt2dcp1by.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b47050edc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4704de4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4704de4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4704de37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt2dcp1by                        0x000055b6cd0c68d7 <unavailable> + 6359

    5    libc.so.6                          0x00002b47052d9460 __libc_start_main +
    245

    6    tmpt2dcp1by                        0x000055b6cd0c6299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824404
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max_fill = 0\n    var buckets = [Int](repeating: 0, count:\
    \ grid[0].count)\n    for row in grid {\n        for (i, well) in row.enumerated()\
    \ {\n            if well == 1 {\n                buckets[i] += 1\n           \
    \ }\n        }\n        max_fill += fill_buckets(buckets: &buckets, capacity:\
    \ capacity)\n    }\n    return max_fill\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmp8xo7717u.swift:32:21: error: cannot find 'fill_buckets' in scope\n\
    \        max_fill += fill_buckets(buckets: &buckets, capacity: capacity)\n   \
    \                 ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, i: i, j: j, capacity:\
    \ capacity)\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmporchcpto.swift:30:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var depth = 0\n    var buckets = 0\n    for row in grid {\n  \
    \      for cell in row {\n            if cell == 1 {\n                depth +=\
    \ 1\n            }\n        }\n    }\n    buckets = depth / capacity\n    if depth\
    \ % capacity != 0 {\n        buckets += 1\n    }\n    return buckets\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp_rppdjki/tmp_rppdjki.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abcc525ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abcc4f51b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abcc4f51988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abcc4f507b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_rppdjki                        0x0000560c9f091bd4 <unavailable> + 7124

    5    libc.so.6                          0x00002abcc5446460 __libc_start_main +
    245

    6    tmp_rppdjki                        0x0000560c9f091169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659824404
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    while true {\n       \
    \ var filled = false\n        for i in 0..<grid.count {\n            for j in\
    \ 0..<grid[i].count {\n                if grid[i][j] == 1 {\n                \
    \    filled = true\n                    grid[i][j] = 0\n                    if\
    \ i > 0 {\n                        grid[i - 1][j] = min(grid[i - 1][j] + 1, capacity)\n\
    \                    }\n                    if i < grid.count - 1 {\n        \
    \                grid[i + 1][j] = min(grid[i + 1][j] + 1, capacity)\n        \
    \            }\n                    if j > 0 {\n                        grid[i][j\
    \ - 1] = min(grid[i][j - 1] + 1, capacity)\n                    }\n          \
    \          if j < grid[i].count - 1 {\n                        grid[i][j + 1]\
    \ = min(grid[i][j + 1] + 1, capacity)\n                    }\n               \
    \ }\n            }\n        }\n        if !filled {\n            break\n     \
    \   }\n        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var currentCapacity = capacity\n    for i\
    \ in 0..<grid.count {\n        for j in 0..<grid[i].count {\n            if grid[i][j]\
    \ == 1 {\n                if currentCapacity == 0 {\n                    currentCapacity\
    \ = capacity\n                    result += 1\n                }\n           \
    \     currentCapacity -= 1\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpo7bmv6so/tmpo7bmv6so.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7615706c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b76153fdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b76153fd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76153fc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo7bmv6so                        0x0000556b84180656 <unavailable> + 5718

    5    libc.so.6                          0x00002b76158f2460 __libc_start_main +
    245

    6    tmpo7bmv6so                        0x0000556b841801e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    var max = 0\n    for row in grid {\n      \
    \  for item in row {\n            if item == 1 {\n                count += 1\n\
    \            }\n        }\n        if count > max {\n            max = count\n\
    \        }\n        count = 0\n    }\n    return max * capacity\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmphp0a3a48/tmphp0a3a48.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac26d99dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac26d694b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac26d694988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac26d6937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphp0a3a48                        0x0000561093f0d546 <unavailable> + 5446

    5    libc.so.6                          0x00002ac26db89460 __libc_start_main +
    245

    6    tmphp0a3a48                        0x0000561093f0d0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824404
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, i: i, j: j, capacity:\
    \ capacity)\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmporchcpto.swift:30:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    var i = 0\n    while i\
    \ < grid.count {\n        var j = 0\n        while j < grid[i].count {\n     \
    \       if grid[i][j] == 1 {\n                grid[i][j] = 0\n               \
    \ count += 1\n                var k = i + 1\n                while k < grid.count\
    \ && capacity > 0 {\n                    if grid[k][j] == 1 {\n              \
    \          grid[k][j] = 0\n                        capacity -= 1\n           \
    \         }\n                    k += 1\n                }\n            }\n  \
    \          j += 1\n        }\n        i += 1\n    }\n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp4bt5j2nd.swift:37:34: error: left side of mutating operator isn't\
    \ mutable: 'capacity' is a 'let' constant\n                        capacity -=\
    \ 1\n                        ~~~~~~~~ ^\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    while true {\n       \
    \ var found = false\n        for i in 0..<grid.count {\n            for j in 0..<grid[i].count\
    \ {\n                if grid[i][j] == 1 {\n                    found = true\n\
    \                    grid[i][j] = 0\n                    count += 1\n        \
    \        }\n            }\n        }\n        if !found {\n            break\n\
    \        }\n        for i in 0..<grid.count {\n            for j in 0..<grid[i].count\
    \ {\n                if grid[i][j] == 0 {\n                    grid[i][j] = 1\n\
    \                }\n            }\n        }\n    }\n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    var row = 0\n    while\
    \ row < grid.count {\n        var col = 0\n        while col < grid[row].count\
    \ {\n            if grid[row][col] == 1 {\n                count += 1\n      \
    \          var bucket = capacity\n                while bucket > 0 {\n       \
    \             if row < grid.count && grid[row][col] == 1 {\n                 \
    \       grid[row][col] = 0\n                        bucket -= 1\n            \
    \        }\n                    row += 1\n                }\n                row\
    \ -= 1\n            }\n            col += 1\n        }\n        row += 1\n   \
    \ }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp478afdoq/tmp478afdoq.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3ab3dffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3ab3af6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3ab3af6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3ab3af57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp478afdoq                        0x0000556fe7731747 <unavailable> + 5959

    5    libc.so.6                          0x00002b3ab3feb460 __libc_start_main +
    245

    6    tmp478afdoq                        0x0000556fe7731109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    while true {\n       \
    \ var max = 0\n        var max_i = 0\n        for i in 0..<grid.count {\n    \
    \        var sum = 0\n            for j in 0..<grid[i].count {\n             \
    \   sum += grid[i][j]\n            }\n            if sum > max {\n           \
    \     max = sum\n                max_i = i\n            }\n        }\n       \
    \ if max == 0 {\n            break\n        }\n        for j in 0..<grid[max_i].count\
    \ {\n            if grid[max_i][j] == 1 {\n                grid[max_i][j] = 0\n\
    \                count += 1\n            }\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpdkqs5wgk/tmpdkqs5wgk.swift:66: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ada5b591c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ada5b288b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ada5b288988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ada5b2877b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdkqs5wgk                        0x000055f6cc0708d7 <unavailable> + 6359

    5    libc.so.6                          0x00002ada5b77d460 __libc_start_main +
    245

    6    tmpdkqs5wgk                        0x000055f6cc070299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        var current_capacity\
    \ = capacity\n        for well in row {\n            if well == 1 {\n        \
    \        if current_capacity == 0 {\n                    result += 1\n       \
    \             current_capacity = capacity\n                }\n               \
    \ current_capacity -= 1\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp8n23888c/tmp8n23888c.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b11480f2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1147de9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1147de9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1147de87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8n23888c                        0x00005609742aa546 <unavailable> + 5446

    5    libc.so.6                          0x00002b11482de460 __libc_start_main +
    245

    6    tmp8n23888c                        0x00005609742aa0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    while !grid.isEmpty {\n\
    \        var max = 0\n        var maxIndex = 0\n        for i in 0..<grid.count\
    \ {\n            let sum = grid[i].reduce(0, +)\n            if sum > max {\n\
    \                max = sum\n                maxIndex = i\n            }\n    \
    \    }\n        if max > capacity {\n            for i in 0..<grid[maxIndex].count\
    \ {\n                if grid[maxIndex][i] == 1 {\n                    grid[maxIndex][i]\
    \ = 0\n                    count += 1\n                }\n            }\n    \
    \    } else {\n            grid.remove(at: maxIndex)\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpk08ubii_/tmpk08ubii_.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae49d222c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae49cf19b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae49cf19988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae49cf187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk08ubii_                        0x0000556e8e536866 <unavailable> + 6246

    5    libc.so.6                          0x00002ae49d40e460 __libc_start_main +
    245

    6    tmpk08ubii_                        0x0000556e8e5363f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824404
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var grid = grid\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                result += 1\n                grid = fill(grid: grid, i: i, j:\
    \ j, capacity: capacity)\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpelpmd3eo.swift:30:24: error: cannot find 'fill' in scope\n    \
    \            grid = fill(grid: grid, i: i, j: j, capacity: capacity)\n       \
    \                ^~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var row = 0\n    var col = 0\n    while row\
    \ < grid.count {\n        while col < grid[row].count {\n            if grid[row][col]\
    \ == 1 {\n                result += 1\n                col += capacity\n     \
    \       } else {\n                col += 1\n            }\n        }\n       \
    \ row += 1\n        col = 0\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    var row = 0\n    var col\
    \ = 0\n    while row < grid.count {\n        while col < grid[row].count {\n \
    \           if grid[row][col] == 1 {\n                grid[row][col] = 0\n   \
    \             count += 1\n                var i = row\n                while i\
    \ < row + capacity {\n                    if i < grid.count {\n              \
    \          grid[i][col] = 0\n                    }\n                    i += 1\n\
    \                }\n            }\n            col += 1\n        }\n        col\
    \ = 0\n        row += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpy90uoetv/tmpy90uoetv.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9da6a8cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9da6783b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9da6783988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9da67827b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy90uoetv                        0x0000558e820af747 <unavailable> + 5959

    5    libc.so.6                          0x00002b9da6c78460 __libc_start_main +
    245

    6    tmpy90uoetv                        0x0000558e820af109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                for k in 0..<capacity {\n       \
    \             if i + k < grid.count {\n                        grid[i + k][j]\
    \ = 0\n                    }\n                }\n            }\n        }\n  \
    \  }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpkh5kfsyv/tmpkh5kfsyv.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6df9ec1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6df9bb8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6df9bb8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6df9bb77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkh5kfsyv                        0x000055645e2828d7 <unavailable> + 6359

    5    libc.so.6                          0x00002b6dfa0ad460 __libc_start_main +
    245

    6    tmpkh5kfsyv                        0x000055645e282299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    var max = 0\n    for i\
    \ in 0..<grid.count {\n        for j in 0..<grid[i].count {\n            if grid[i][j]\
    \ == 1 {\n                count += 1\n            }\n        }\n        if count\
    \ > max {\n            max = count\n        }\n        count = 0\n    }\n    return\
    \ max * capacity\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmppnus6ccf/tmppnus6ccf.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaabb12bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaabae22b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaabae22988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaabae217b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppnus6ccf                        0x000055ca2edea656 <unavailable> + 5718

    5    libc.so.6                          0x00002aaabb317460 __libc_start_main +
    245

    6    tmppnus6ccf                        0x000055ca2edea1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    var row = 0\n    var col\
    \ = 0\n    while row < grid.count {\n        while col < grid[row].count {\n \
    \           if grid[row][col] == 1 {\n                grid[row][col] = 0\n   \
    \             count += 1\n                if row + 1 < grid.count {\n        \
    \            grid[row + 1][col] = 1\n                }\n            }\n      \
    \      col += 1\n        }\n        col = 0\n        row += 1\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpfsqz6zdb/tmpfsqz6zdb.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1cd0520c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1cd0217b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1cd0217988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1cd02167b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfsqz6zdb                        0x000055cb69210576 <unavailable> + 5494

    5    libc.so.6                          0x00002b1cd070c460 __libc_start_main +
    245

    6    tmpfsqz6zdb                        0x000055cb69210109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    var row = 0\n    var col\
    \ = 0\n    while row < grid.count {\n        if grid[row][col] == 1 {\n      \
    \      grid[row][col] = 0\n            count += 1\n        }\n        if col ==\
    \ grid[row].count - 1 {\n            row += 1\n            col = 0\n        }\
    \ else {\n            col += 1\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpjl1p59es/tmpjl1p59es.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af3908dfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af3905d6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af3905d6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af3905d57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjl1p59es                        0x000055901dbce747 <unavailable> + 5959

    5    libc.so.6                          0x00002af390acb460 __libc_start_main +
    245

    6    tmpjl1p59es                        0x000055901dbce109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    while true {\n       \
    \ var max = 0\n        var max_i = 0\n        for i in 0..<grid.count {\n    \
    \        var sum = 0\n            for j in 0..<grid[i].count {\n             \
    \   sum += grid[i][j]\n            }\n            if sum > max {\n           \
    \     max = sum\n                max_i = i\n            }\n        }\n       \
    \ if max == 0 {\n            break\n        }\n        for j in 0..<grid[max_i].count\
    \ {\n            if grid[max_i][j] == 1 {\n                grid[max_i][j] = 0\n\
    \                count += 1\n            }\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpdkqs5wgk/tmpdkqs5wgk.swift:66: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ada5b591c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ada5b288b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ada5b288988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ada5b2877b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdkqs5wgk                        0x000055f6cc0708d7 <unavailable> + 6359

    5    libc.so.6                          0x00002ada5b77d460 __libc_start_main +
    245

    6    tmpdkqs5wgk                        0x000055f6cc070299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824404
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, capacity: capacity,\
    \ i: i, j: j)\n            }\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpxfpjdn12.swift:30:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, capacity: capacity, i: i, j: j)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    var grid = grid\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, capacity: capacity,\
    \ i: i, j: j)\n            }\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp8y2acbof.swift:30:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, capacity: capacity, i: i, j: j)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, i: i, j: j, capacity:\
    \ capacity)\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmporchcpto.swift:30:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    var grid = grid\n    for row in grid {\n  \
    \      for col in row {\n            if col == 1 {\n                count += 1\n\
    \            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpdnrdo_oc/tmpdnrdo_oc.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b018abf2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b018a8e9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b018a8e9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b018a8e87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdnrdo_oc                        0x000055ba8d680717 <unavailable> + 5911

    5    libc.so.6                          0x00002b018adde460 __libc_start_main +
    245

    6    tmpdnrdo_oc                        0x000055ba8d6800d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824404
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, i: i, j: j, capacity:\
    \ capacity)\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmporchcpto.swift:30:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    var grid = grid\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, i: i, j: j, capacity:\
    \ capacity)\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpu14c4sfm.swift:30:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                grid[i][j] = 0\n                if\
    \ i + 1 < grid.count {\n                    grid[i + 1][j] = 1\n             \
    \   }\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsvpfcxs8/tmpsvpfcxs8.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac54b3bec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac54b0b5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac54b0b5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac54b0b47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsvpfcxs8                        0x000056114a116706 <unavailable> + 5894

    5    libc.so.6                          0x00002ac54b5aa460 __libc_start_main +
    245

    6    tmpsvpfcxs8                        0x000056114a116299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    var row = 0\n    var col\
    \ = 0\n    while row < grid.count {\n        while col < grid[row].count {\n \
    \           if grid[row][col] == 1 {\n                grid[row][col] = 0\n   \
    \             count += 1\n                if capacity > 1 {\n                \
    \    for i in row..<row+capacity {\n                        if i < grid.count\
    \ {\n                            for j in col..<col+capacity {\n             \
    \                   if j < grid[i].count {\n                                 \
    \   grid[i][j] = 0\n                                }\n                      \
    \      }\n                        }\n                    }\n                }\n\
    \            }\n            col += 1\n        }\n        col = 0\n        row\
    \ += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp0oe9oldo/tmp0oe9oldo.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5a39782c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5a39479b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5a39479988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5a394787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0oe9oldo                        0x000055f92cbb98d7 <unavailable> + 6359

    5    libc.so.6                          0x00002b5a3996e460 __libc_start_main +
    245

    6    tmp0oe9oldo                        0x000055f92cbb9299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var max_well = 0\n    for row in grid {\n\
    \        max_well = max(max_well, row.reduce(0, +))\n    }\n    var current_fill\
    \ = 0\n    while current_fill < max_well {\n        for row in grid {\n      \
    \      var current_row_fill = 0\n            for well in row {\n             \
    \   if well == 1 {\n                    current_row_fill += 1\n              \
    \  } else {\n                    if current_row_fill > 0 {\n                 \
    \       result += 1\n                        current_row_fill = 0\n          \
    \          }\n                }\n            }\n            if current_row_fill\
    \ > 0 {\n                result += 1\n            }\n        }\n        current_fill\
    \ += capacity\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmp_wvsolv2/tmp_wvsolv2.swift:65: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b23988fec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b23985f5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b23985f5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b23985f47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_wvsolv2                        0x000055ce3a1bc656 <unavailable> + 5718

    5    libc.so.6                          0x00002b2398aea460 __libc_start_main +
    245

    6    tmp_wvsolv2                        0x000055ce3a1bc1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var max = 0\n    var min = 0\n    for i in\
    \ 0..<grid.count {\n        for j in 0..<grid[i].count {\n            if grid[i][j]\
    \ == 1 {\n                max += 1\n            }\n        }\n    }\n    while\
    \ min <= max {\n        let mid = (min + max) / 2\n        if is_possible(grid:\
    \ grid, capacity: capacity, mid) {\n            result = mid\n            min\
    \ = mid + 1\n        } else {\n            max = mid - 1\n        }\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpyh2s2b2j.swift:36:12: error: cannot find 'is_possible' in scope\n\
    \        if is_possible(grid: grid, capacity: capacity, mid) {\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    var grid = grid\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, i: i, j: j, capacity:\
    \ capacity)\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpu14c4sfm.swift:30:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    while true {\n       \
    \ var isEmpty = true\n        for i in 0..<grid.count {\n            for j in\
    \ 0..<grid[i].count {\n                if grid[i][j] == 1 {\n                \
    \    isEmpty = false\n                    grid[i][j] = 0\n                   \
    \ count += 1\n                }\n            }\n        }\n        if isEmpty\
    \ {\n            break\n        }\n        for i in 0..<grid.count {\n       \
    \     for j in 0..<grid[i].count {\n                if grid[i][j] == 0 {\n   \
    \                 grid[i][j] = 1\n                }\n            }\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var max_row = 0\n    var max_col = 0\n   \
    \ for row in grid {\n        max_row = max(max_row, row.reduce(0, +))\n    }\n\
    \    for col in 0..<grid[0].count {\n        max_col = max(max_col, grid.map{\
    \ $0[col] }.reduce(0, +))\n    }\n    result = max(max_row, max_col)\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpj0yfdmlk/tmpj0yfdmlk.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b37bf035c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b37bed2cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b37bed2c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b37bed2b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj0yfdmlk                        0x0000558612be9936 <unavailable> + 6454

    5    libc.so.6                          0x00002b37bf221460 __libc_start_main +
    245

    6    tmpj0yfdmlk                        0x0000558612be94c9 <unavailable> + 5321

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    var i = 0\n    while i\
    \ < grid.count {\n        var j = 0\n        while j < grid[i].count {\n     \
    \       if grid[i][j] == 1 {\n                grid[i][j] = 0\n               \
    \ count += 1\n                var k = i + 1\n                while k < grid.count\
    \ && capacity > 0 {\n                    if grid[k][j] == 1 {\n              \
    \          grid[k][j] = 0\n                        capacity -= 1\n           \
    \         }\n                    k += 1\n                }\n            }\n  \
    \          j += 1\n        }\n        i += 1\n    }\n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp4bt5j2nd.swift:37:34: error: left side of mutating operator isn't\
    \ mutable: 'capacity' is a 'let' constant\n                        capacity -=\
    \ 1\n                        ~~~~~~~~ ^\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max_fill = 0\n    for row in grid {\n        max_fill += row.reduce(0,\
    \ +)\n    }\n    return max_fill / capacity\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpv6wya4du/tmpv6wya4du.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5f7ddd5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5f7daccb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5f7dacc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5f7dacb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv6wya4du                        0x000055dc5a182817 <unavailable> + 6167

    5    libc.so.6                          0x00002b5f7dfc1460 __libc_start_main +
    245

    6    tmpv6wya4du                        0x000055dc5a1821d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    while true {\n       \
    \ var allZero = true\n        for i in 0..<grid.count {\n            for j in\
    \ 0..<grid[i].count {\n                if grid[i][j] == 1 {\n                \
    \    allZero = false\n                    grid[i][j] = 0\n                   \
    \ count += 1\n                }\n            }\n        }\n        if allZero\
    \ {\n            break\n        }\n        for i in 0..<grid.count {\n       \
    \     for j in 0..<grid[i].count {\n                if grid[i][j] == 0 {\n   \
    \                 grid[i][j] = 1\n                }\n            }\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824410
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                for k in 0..<capacity {\n       \
    \             if i + k < grid.count {\n                        grid[i + k][j]\
    \ = 0\n                    }\n                }\n            }\n        }\n  \
    \  }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpkh5kfsyv/tmpkh5kfsyv.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6df9ec1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6df9bb8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6df9bb8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6df9bb77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkh5kfsyv                        0x000055645e2828d7 <unavailable> + 6359

    5    libc.so.6                          0x00002b6dfa0ad460 __libc_start_main +
    245

    6    tmpkh5kfsyv                        0x000055645e282299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for i in 0..<grid.count {\n        for j in\
    \ 0..<grid[i].count {\n            if grid[i][j] == 1 {\n                result\
    \ += 1\n            }\n        }\n    }\n    return result * capacity\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpkse7cgr5/tmpkse7cgr5.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b50b4cc5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b50b49bcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b50b49bc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b50b49bb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkse7cgr5                        0x00005590db3d5827 <unavailable> + 6183

    5    libc.so.6                          0x00002b50b4eb1460 __libc_start_main +
    245

    6    tmpkse7cgr5                        0x00005590db3d51e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    while !grid.isEmpty {\n\
    \        var row = grid.removeFirst()\n        while !row.isEmpty {\n        \
    \    let bucket = row.removeFirst()\n            if bucket == 1 {\n          \
    \      count += 1\n            }\n        }\n    }\n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmps8o3tpm0/tmps8o3tpm0.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1704838c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b170452fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b170452f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b170452e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps8o3tpm0                        0x0000557f806f56e7 <unavailable> + 5863

    5    libc.so.6                          0x00002b1704a24460 __libc_start_main +
    245

    6    tmps8o3tpm0                        0x0000557f806f50a9 <unavailable> + 4265

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    let rowCount = grid.count\n    let columnCount\
    \ = grid[0].count\n    for i in 0..<rowCount {\n        for j in 0..<columnCount\
    \ {\n            if grid[i][j] == 1 {\n                result += capacity\n  \
    \          }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpbc9kmdmo/tmpbc9kmdmo.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adf1ef6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adf1ec62b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adf1ec62988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adf1ec617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbc9kmdmo                        0x000055dc8de81827 <unavailable> + 6183

    5    libc.so.6                          0x00002adf1f157460 __libc_start_main +
    245

    6    tmpbc9kmdmo                        0x000055dc8de811e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                grid[i][j] = 0\n                var\
    \ k = i\n                while k > 0 && grid[k - 1][j] == 1 {\n              \
    \      grid[k - 1][j] = 0\n                    k -= 1\n                }\n   \
    \         }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpftcq59ka/tmpftcq59ka.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8d9f085c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8d9ed7cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8d9ed7c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8d9ed7b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpftcq59ka                        0x000056410e91b8d7 <unavailable> + 6359

    5    libc.so.6                          0x00002b8d9f271460 __libc_start_main +
    245

    6    tmpftcq59ka                        0x000056410e91b299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var max_height = 0\n    for row in grid {\n\
    \        max_height = max(max_height, row.reduce(0, +))\n    }\n    for height\
    \ in 1...max_height {\n        for row in grid {\n            var row_result =\
    \ 0\n            for well in row {\n                if well >= height {\n    \
    \                row_result += 1\n                }\n            }\n         \
    \   result += row_result / capacity\n            if row_result % capacity != 0\
    \ {\n                result += 1\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'Swift/ClosedRange.swift:347: Fatal error: Range requires lowerBound <=
    upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b6a7c3d7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6a7c0ce561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b6a7c0ce286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b6a7c0ce13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b6a7c0cdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp16ngcshh                        0x000056101f792171 <unavailable> + 8561

    6    tmp16ngcshh                        0x000056101f791a6b <unavailable> + 6763

    7    libc.so.6                          0x00002b6a7c5c3460 __libc_start_main +
    245

    8    tmp16ngcshh                        0x000056101f791369 <unavailable> + 4969

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    while true {\n       \
    \ var isEmpty = true\n        for i in 0..<grid.count {\n            if grid[i].contains(1)\
    \ {\n                isEmpty = false\n                for j in 0..<grid[i].count\
    \ {\n                    if grid[i][j] == 1 {\n                        grid[i][j]\
    \ = 0\n                        if i + 1 < grid.count {\n                     \
    \       grid[i + 1][j] = 1\n                        }\n                    }\n\
    \                }\n            }\n        }\n        if isEmpty {\n         \
    \   break\n        }\n        count += 1\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpjbjykkvc/tmpjbjykkvc.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b37814ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b37811d4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b37811d4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b37811d37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjbjykkvc                        0x0000556f07c3c766 <unavailable> + 5990

    5    libc.so.6                          0x00002b37816c9460 __libc_start_main +
    245

    6    tmpjbjykkvc                        0x0000556f07c3c2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                grid[i][j] = 0\n                count += 1\n                if\
    \ i > 0 && grid[i - 1][j] == 1 {\n                    grid[i - 1][j] = 0\n   \
    \                 count += 1\n                }\n                if j > 0 && grid[i][j\
    \ - 1] == 1 {\n                    grid[i][j - 1] = 0\n                    count\
    \ += 1\n                }\n            }\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp8a_7atuj/tmp8a_7atuj.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b31b0a29c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b31b0720b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b31b0720988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b31b071f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8a_7atuj                        0x00005572d25308d7 <unavailable> + 6359

    5    libc.so.6                          0x00002b31b0c15460 __libc_start_main +
    245

    6    tmp8a_7atuj                        0x00005572d2530299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    while true {\n       \
    \ var is_full = true\n        for i in 0..<grid.count {\n            for j in\
    \ 0..<grid[i].count {\n                if grid[i][j] == 1 {\n                \
    \    grid[i][j] = 0\n                    count += 1\n                    is_full\
    \ = false\n                }\n            }\n        }\n        if is_full {\n\
    \            break\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmplgma5rlc/tmplgma5rlc.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b546f670c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b546f367b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b546f367988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b546f3667b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplgma5rlc                        0x0000564cdf23f8d7 <unavailable> + 6359

    5    libc.so.6                          0x00002b546f85c460 __libc_start_main +
    245

    6    tmplgma5rlc                        0x0000564cdf23f299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    // your code here\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpvzw2by4m/tmpvzw2by4m.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad5ad623c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad5ad31ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad5ad31a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad5ad3197b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvzw2by4m                        0x000055777c9193d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ad5ad80f460 __libc_start_main +
    245

    6    tmpvzw2by4m                        0x000055777c918f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    // your code here\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpvzw2by4m/tmpvzw2by4m.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad5ad623c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad5ad31ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad5ad31a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad5ad3197b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvzw2by4m                        0x000055777c9193d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ad5ad80f460 __libc_start_main +
    245

    6    tmpvzw2by4m                        0x000055777c918f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                for k in i..<grid.count {\n     \
    \               if grid[k][j] == 1 {\n                        grid[k][j] = 0\n\
    \                    } else {\n                        break\n               \
    \     }\n                }\n            }\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpk4znrc_3/tmpk4znrc_3.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6d242eac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6d23fe1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6d23fe1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6d23fe07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk4znrc_3                        0x000056453bdf0706 <unavailable> + 5894

    5    libc.so.6                          0x00002b6d244d6460 __libc_start_main +
    245

    6    tmpk4znrc_3                        0x000056453bdf0299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824404
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    var grid = grid\n    var wells = grid.map {\
    \ $0.reduce(0, +) }\n    while wells.reduce(0, +) > 0 {\n        for i in 0..<wells.count\
    \ {\n            if wells[i] > 0 {\n                wells[i] -= capacity\n   \
    \             count += 1\n            }\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                grid[i][j] = 0\n                if\
    \ i + 1 < grid.count {\n                    grid[i + 1][j] = 0\n             \
    \   }\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpplcel19y/tmpplcel19y.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b93f5683c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b93f537ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b93f537a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b93f53797b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpplcel19y                        0x000055e3c599e706 <unavailable> + 5894

    5    libc.so.6                          0x00002b93f586f460 __libc_start_main +
    245

    6    tmpplcel19y                        0x000055e3c599e299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var buckets = [Int](repeating: 0, count: grid[0].count)\n    var\
    \ count = 0\n    for row in grid {\n        for (index, value) in row.enumerated()\
    \ {\n            if value == 1 {\n                buckets[index] += 1\n      \
    \      }\n        }\n        for (index, value) in buckets.enumerated() {\n  \
    \          if value > capacity {\n                buckets[index] = capacity\n\
    \                count += 1\n            }\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp9k3wtbp0/tmp9k3wtbp0.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae5f6114c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae5f5e0bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae5f5e0b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae5f5e0a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9k3wtbp0                        0x0000560b9b61a8b6 <unavailable> + 6326

    5    libc.so.6                          0x00002ae5f6300460 __libc_start_main +
    245

    6    tmp9k3wtbp0                        0x0000560b9b61a449 <unavailable> + 5193

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpvzai82yo/tmpvzai82yo.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab59b057c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab59ad4eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab59ad4e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab59ad4d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvzai82yo                        0x000055f88bb683d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ab59b243460 __libc_start_main +
    245

    6    tmpvzai82yo                        0x000055f88bb67f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max_fill = 0\n    for row in grid {\n        for column in\
    \ row {\n            if column == 1 {\n                max_fill += 1\n       \
    \     }\n        }\n    }\n    return max_fill / capacity\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpf7fdh3ud/tmpf7fdh3ud.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abe70fa6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abe70c9db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abe70c9d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abe70c9c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf7fdh3ud                        0x0000556d35a197a7 <unavailable> + 6055

    5    libc.so.6                          0x00002abe71192460 __libc_start_main +
    245

    6    tmpf7fdh3ud                        0x0000556d35a19169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    var i = 0\n    while i\
    \ < grid.count {\n        var j = 0\n        while j < grid[i].count {\n     \
    \       if grid[i][j] == 1 {\n                count += 1\n                var\
    \ k = i\n                while k < grid.count && k < i + capacity {\n        \
    \            grid[k][j] = 0\n                    k += 1\n                }\n \
    \           }\n            j += 1\n        }\n        i += 1\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpuwilmrm4/tmpuwilmrm4.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4bd562bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4bd5322b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4bd5322988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4bd53217b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuwilmrm4                        0x000055e034fe0747 <unavailable> + 5959

    5    libc.so.6                          0x00002b4bd5817460 __libc_start_main +
    245

    6    tmpuwilmrm4                        0x000055e034fe0109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    var i = 0\n    while i\
    \ < grid.count {\n        var j = 0\n        while j < grid[i].count {\n     \
    \       if grid[i][j] == 1 {\n                count += 1\n                var\
    \ k = 0\n                while k < capacity {\n                    if i + k <\
    \ grid.count {\n                        grid[i + k][j] = 0\n                 \
    \   }\n                    k += 1\n                }\n            }\n        \
    \    j += 1\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp6dr846y7/tmp6dr846y7.swift:61: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8bf349fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8bf3196b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8bf3196988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8bf31957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6dr846y7                        0x000055b90e50d747 <unavailable> + 5959

    5    libc.so.6                          0x00002b8bf368b460 __libc_start_main +
    245

    6    tmp6dr846y7                        0x000055b90e50d109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var max = 0\n    for i in 0..<grid.count {\n\
    \        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n    \
    \            max += 1\n            }\n        }\n    }\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                result += 1\n                var k = i\n                var l\
    \ = j\n                while k < grid.count && l < grid[i].count {\n         \
    \           if grid[k][l] == 1 {\n                        grid[k][l] = 0\n   \
    \                     max -= 1\n                    }\n                    if\
    \ max == 0 {\n                        return result\n                    }\n \
    \                   k += 1\n                    l += 1\n                }\n  \
    \          }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpf6wmc35y.swift:41:32: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                        grid[k][l] = 0\n              \
    \          ~~~~   ^\n"
  stdout: ''
  timestamp: 1659824405
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var grid = grid\n    var row = 0\n    while\
    \ row < grid.count {\n        var col = 0\n        while col < grid[row].count\
    \ {\n            if grid[row][col] == 1 {\n                result += 1\n     \
    \           var bucket = capacity\n                while bucket > 0 {\n      \
    \              if row > 0 && grid[row - 1][col] == 1 {\n                     \
    \   grid[row - 1][col] = 0\n                        bucket -= 1\n            \
    \        }\n                    if row < grid.count - 1 && grid[row + 1][col]\
    \ == 1 {\n                        grid[row + 1][col] = 0\n                   \
    \     bucket -= 1\n                    }\n                    if col > 0 && grid[row][col\
    \ - 1] == 1 {\n                        grid[row][col - 1] = 0\n              \
    \          bucket -= 1\n                    }\n                    if col < grid[row].count\
    \ - 1 && grid[row][col + 1] == 1 {\n                        grid[row][col + 1]\
    \ = 0\n                        bucket -= 1\n                    }\n          \
    \      }\n            }\n            col += 1\n        }\n        row += 1\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824410
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    let rows = grid.count\n    let cols = grid[0].count\n    var grid\
    \ = grid\n    var count = 0\n    for _ in 0..<rows {\n        for j in 0..<cols\
    \ {\n            if grid[0][j] == 1 {\n                count += 1\n          \
    \      grid[0][j] = 0\n                for i in 1..<rows {\n                 \
    \   if grid[i][j] == 1 {\n                        grid[i][j] = 0\n           \
    \             break\n                    }\n                }\n            }\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpnul0hgqv/tmpnul0hgqv.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac9f77a7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac9f749eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac9f749e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9f749d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnul0hgqv                        0x000055821c758706 <unavailable> + 5894

    5    libc.so.6                          0x00002ac9f7993460 __libc_start_main +
    245

    6    tmpnul0hgqv                        0x000055821c758299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max_fill = 0\n    var current_fill = 0\n    for row in grid\
    \ {\n        for well in row {\n            if well == 1 {\n                current_fill\
    \ += 1\n            }\n        }\n        if current_fill > capacity {\n     \
    \       max_fill += capacity\n        } else {\n            max_fill += current_fill\n\
    \        }\n        current_fill = 0\n    }\n    return max_fill\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4d6r9jbm/tmp4d6r9jbm.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6f5460fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6f54306b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6f54306988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6f543057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4d6r9jbm                        0x0000556eadb8d546 <unavailable> + 5446

    5    libc.so.6                          0x00002b6f547fb460 __libc_start_main +
    245

    6    tmp4d6r9jbm                        0x0000556eadb8d0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                let row = i\n                let\
    \ col = j\n                var row_count = 0\n                var col_count =\
    \ 0\n                while row_count < capacity && row + row_count < grid.count\
    \ {\n                    if grid[row + row_count][col] == 1 {\n              \
    \          grid[row + row_count][col] = 0\n                    }\n           \
    \         row_count += 1\n                }\n                while col_count <\
    \ capacity && col + col_count < grid[i].count {\n                    if grid[row][col\
    \ + col_count] == 1 {\n                        grid[row][col + col_count] = 0\n\
    \                    }\n                    col_count += 1\n                }\n\
    \            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        var current_capacity\
    \ = capacity\n        for well in row {\n            if well == 1 {\n        \
    \        if current_capacity > 0 {\n                    current_capacity -= 1\n\
    \                } else {\n                    result += 1\n                 \
    \   current_capacity = capacity - 1\n                }\n            }\n      \
    \  }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpovqteh3a/tmpovqteh3a.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae0c81dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae0c7ed2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae0c7ed2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae0c7ed17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpovqteh3a                        0x0000558f3e829546 <unavailable> + 5446

    5    libc.so.6                          0x00002ae0c83c7460 __libc_start_main +
    245

    6    tmpovqteh3a                        0x0000558f3e8290d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    var grid = grid\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                grid = fill(grid: grid, i: i, j:\
    \ j, capacity: capacity)\n            }\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpn8lnfq16.swift:30:24: error: cannot find 'fill' in scope\n    \
    \            grid = fill(grid: grid, i: i, j: j, capacity: capacity)\n       \
    \                ^~~~\n"
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var max_row = 0\n    var max_col = 0\n   \
    \ var max_sum = 0\n    for row in grid {\n        max_row = max(max_row, row.reduce(0,\
    \ +))\n        for (index, col) in row.enumerated() {\n            max_col = max(max_col,\
    \ col)\n            max_sum = max(max_sum, grid.reduce(0, { $0 + $1[index] }))\n\
    \        }\n    }\n    result = max(max_row, max_col, max_sum)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpzreiigqz/tmpzreiigqz.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af19de2bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af19db22b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af19db22988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af19db217b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzreiigqz                        0x0000561b99651906 <unavailable> + 6406

    5    libc.so.6                          0x00002af19e017460 __libc_start_main +
    245

    6    tmpzreiigqz                        0x0000561b99651499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, capacity: capacity,\
    \ i: i, j: j)\n            }\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpxfpjdn12.swift:30:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, capacity: capacity, i: i, j: j)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    while !grid.isEmpty {\n\
    \        let max = grid.map { $0.max() ?? 0 }.max() ?? 0\n        if max == 0\
    \ {\n            break\n        }\n        grid = grid.map { $0.map { $0 - max\
    \ } }\n        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpjoqcyhyi/tmpjoqcyhyi.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b86d53ebc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b86d50e2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b86d50e2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b86d50e17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjoqcyhyi                        0x0000559754b91576 <unavailable> + 5494

    5    libc.so.6                          0x00002b86d55d7460 __libc_start_main +
    245

    6    tmpjoqcyhyi                        0x0000559754b91109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var max_row = 0\n    var max_col = 0\n   \
    \ var max_value = 0\n    for row in grid {\n        for col in row {\n       \
    \     if col > max_value {\n                max_value = col\n                max_row\
    \ = grid.firstIndex(of: row)!\n                max_col = row.firstIndex(of: col)!\n\
    \            }\n        }\n    }\n    while max_value > 0 {\n        for row in\
    \ grid {\n            for col in row {\n                if col > 0 {\n       \
    \             result += 1\n                }\n            }\n        }\n     \
    \   for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n    \
    \            if grid[i][j] > 0 {\n                    grid[i][j] -= 1\n      \
    \          }\n            }\n        }\n        max_value = 0\n        for row\
    \ in grid {\n            for col in row {\n                if col > max_value\
    \ {\n                    max_value = col\n                    max_row = grid.firstIndex(of:\
    \ row)!\n                    max_col = row.firstIndex(of: col)!\n            \
    \    }\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpaw72i86y.swift:48:32: error: left side of mutating operator isn't\
    \ mutable: 'grid' is a 'let' constant\n                    grid[i][j] -= 1\n \
    \                   ~~~~       ^\n"
  stdout: ''
  timestamp: 1659824405
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for i in 0..<grid.count {\n        var sum\
    \ = 0\n        for j in 0..<grid[i].count {\n            sum += grid[i][j]\n \
    \       }\n        result += sum / capacity\n        if sum % capacity != 0 {\n\
    \            result += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824405
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for row in 0..<grid.count\
    \ {\n        for col in 0..<grid[row].count {\n            if grid[row][col] ==\
    \ 1 {\n                count += 1\n                fill(grid: &grid, row: row,\
    \ col: col, capacity: capacity)\n            }\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpl007bnik.swift:30:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, row: row, col: col, capacity: capacity)\n     \
    \           ^~~~\n"
  stdout: ''
  timestamp: 1659824405
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var total = 0\n    for row in grid {\n        var row_total =\
    \ 0\n        for well in row {\n            if well == 1 {\n                row_total\
    \ += 1\n            }\n        }\n        total += row_total / capacity\n    \
    \    if row_total % capacity != 0 {\n            total += 1\n        }\n    }\n\
    \    return total\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824405
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    var grid = grid\n    var buckets = [Int](repeating:\
    \ 0, count: grid[0].count)\n    while true {\n        var filled = false\n   \
    \     for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n  \
    \              if grid[i][j] == 1 {\n                    filled = true\n     \
    \               if buckets[j] < capacity {\n                        buckets[j]\
    \ += 1\n                        grid[i][j] = 0\n                    }\n      \
    \          }\n            }\n        }\n        if !filled {\n            break\n\
    \        }\n        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824410
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    for row in grid {\n        var bucket = capacity\n\
    \        for well in row {\n            if well == 1 {\n                bucket\
    \ -= 1\n            }\n            if bucket == 0 {\n                count +=\
    \ 1\n                bucket = capacity\n            }\n        }\n        if bucket\
    \ < capacity {\n            count += 1\n        }\n    }\n    return count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                for k in 0..<capacity {\n       \
    \             if i + k < grid.count {\n                        grid[i + k][j]\
    \ = 0\n                    }\n                }\n            }\n        }\n  \
    \  }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpkh5kfsyv/tmpkh5kfsyv.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6df9ec1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6df9bb8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6df9bb8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6df9bb77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkh5kfsyv                        0x000055645e2828d7 <unavailable> + 6359

    5    libc.so.6                          0x00002b6dfa0ad460 __libc_start_main +
    245

    6    tmpkh5kfsyv                        0x000055645e282299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    var row = 0\n    var col\
    \ = 0\n    while row < grid.count {\n        if grid[row][col] == 1 {\n      \
    \      grid[row][col] = 0\n            count += 1\n        }\n        row += 1\n\
    \        if row == grid.count {\n            row = 0\n            col += 1\n \
    \           if col == grid[0].count {\n                break\n            }\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmplpv2hf07/tmplpv2hf07.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92ed35ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b92ed051b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b92ed051988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92ed0507b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplpv2hf07                        0x000055c0b2b7c747 <unavailable> + 5959

    5    libc.so.6                          0x00002b92ed546460 __libc_start_main +
    245

    6    tmplpv2hf07                        0x000055c0b2b7c109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, i: i, j: j, capacity:\
    \ capacity)\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmporchcpto.swift:30:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, capacity: capacity,\
    \ i: i, j: j)\n            }\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpxfpjdn12.swift:30:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, capacity: capacity, i: i, j: j)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, i: i, j: j, capacity:\
    \ capacity)\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmporchcpto.swift:30:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, i: i, j: j, capacity:\
    \ capacity)\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmporchcpto.swift:30:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    while !grid.isEmpty {\n\
    \        var row = grid.removeFirst()\n        while !row.isEmpty {\n        \
    \    let max = row.max()!\n            if max > capacity {\n                row\
    \ = row.map { $0 - capacity }\n            } else {\n                row = row.map\
    \ { $0 - max }\n            }\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824410
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    var i = 0\n    while i\
    \ < grid.count {\n        var j = 0\n        while j < grid[i].count {\n     \
    \       if grid[i][j] == 1 {\n                count += 1\n                var\
    \ k = i\n                while k < grid.count && k < i + capacity {\n        \
    \            grid[k][j] = 0\n                    k += 1\n                }\n \
    \           }\n            j += 1\n        }\n        i += 1\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpuwilmrm4/tmpuwilmrm4.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4bd562bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4bd5322b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4bd5322988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4bd53217b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuwilmrm4                        0x000055e034fe0747 <unavailable> + 5959

    5    libc.so.6                          0x00002b4bd5817460 __libc_start_main +
    245

    6    tmpuwilmrm4                        0x000055e034fe0109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, i: i, j: j, capacity:\
    \ capacity)\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmporchcpto.swift:30:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var max_height = 0\n    for row in grid {\n\
    \        var height = 0\n        for column in row {\n            if column ==\
    \ 1 {\n                height += 1\n            }\n        }\n        max_height\
    \ = max(max_height, height)\n    }\n    for row in grid {\n        var height\
    \ = 0\n        for column in row {\n            if column == 1 {\n           \
    \     height += 1\n            }\n        }\n        if height < max_height {\n\
    \            result += max_height - height\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpvtulspd3/tmpvtulspd3.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6cca065c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6cc9d5cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6cc9d5c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6cc9d5b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvtulspd3                        0x0000564f8822b7a7 <unavailable> + 6055

    5    libc.so.6                          0x00002b6cca251460 __libc_start_main +
    245

    6    tmpvtulspd3                        0x0000564f8822b169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    var grid = grid\n    var i = 0\n    while i\
    \ < grid.count {\n        var j = 0\n        while j < grid[i].count {\n     \
    \       if grid[i][j] == 1 {\n                count += 1\n                var\
    \ k = i\n                while k < grid.count && k < i + capacity {\n        \
    \            grid[k][j] = 0\n                    k += 1\n                }\n \
    \           }\n            j += 1\n        }\n        i += 1\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmplyc37282/tmplyc37282.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aad65b6fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aad65866b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aad65866988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aad658657b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplyc37282                        0x0000564cfc5a1747 <unavailable> + 5959

    5    libc.so.6                          0x00002aad65d5b460 __libc_start_main +
    245

    6    tmplyc37282                        0x0000564cfc5a1109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                grid[i][j] = 0\n                count += 1\n                var\
    \ k = i\n                while k < grid.count && capacity > 0 {\n            \
    \        if grid[k][j] == 1 {\n                        grid[k][j] = 0\n      \
    \                  capacity -= 1\n                    }\n                    k\
    \ += 1\n                }\n            }\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmphyuu5ah6.swift:35:34: error: left side of mutating operator isn't\
    \ mutable: 'capacity' is a 'let' constant\n                        capacity -=\
    \ 1\n                        ~~~~~~~~ ^\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    for i in 0..<grid.count {\n        var sum\
    \ = 0\n        for j in 0..<grid[i].count {\n            sum += grid[i][j]\n \
    \       }\n        if sum > capacity {\n            count += sum - capacity\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpof3yaavu/tmpof3yaavu.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adde4146c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adde3e3db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adde3e3d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adde3e3c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpof3yaavu                        0x000055e93463a656 <unavailable> + 5718

    5    libc.so.6                          0x00002adde4332460 __libc_start_main +
    245

    6    tmpof3yaavu                        0x000055e93463a1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var water = 0\n    var count = 0\n    for row in grid {\n    \
    \    for col in row {\n            if col == 1 {\n                water += 1\n\
    \            }\n        }\n    }\n    while water > 0 {\n        for row in grid\
    \ {\n            for col in row {\n                if col == 1 {\n           \
    \         water -= capacity\n                    count += 1\n                }\n\
    \            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp65r4c6gq/tmp65r4c6gq.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba8cd97dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba8cd674b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba8cd674988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba8cd6737b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp65r4c6gq                        0x000056347afc5717 <unavailable> + 5911

    5    libc.so.6                          0x00002ba8cdb69460 __libc_start_main +
    245

    6    tmp65r4c6gq                        0x000056347afc50d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max_fill = 0\n    for row in grid {\n        var bucket =\
    \ capacity\n        for well in row {\n            bucket -= well\n          \
    \  if bucket < 0 {\n                max_fill += 1\n                bucket = capacity\
    \ - well\n            }\n        }\n    }\n    return max_fill\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpgt1q7rpz/tmpgt1q7rpz.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2b49752c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2b49449b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2b49449988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2b494487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgt1q7rpz                        0x0000559c2af7f546 <unavailable> + 5446

    5    libc.so.6                          0x00002b2b4993e460 __libc_start_main +
    245

    6    tmpgt1q7rpz                        0x0000559c2af7f0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var max_row = 0\n    var max_col = 0\n   \
    \ for row in grid {\n        max_row = max(max_row, row.reduce(0, +))\n    }\n\
    \    for col in 0..<grid[0].count {\n        var sum = 0\n        for row in 0..<grid.count\
    \ {\n            sum += grid[row][col]\n        }\n        max_col = max(max_col,\
    \ sum)\n    }\n    result = max(max_row, max_col)\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpdpvopa9r/tmpdpvopa9r.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7631f1fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7631c16b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7631c16988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7631c157b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdpvopa9r                        0x000055b84ca0e8c6 <unavailable> + 6342

    5    libc.so.6                          0x00002b763210b460 __libc_start_main +
    245

    6    tmpdpvopa9r                        0x000055b84ca0e459 <unavailable> + 5209

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                grid[i][j] = 0\n                if\
    \ i + 1 < grid.count {\n                    grid[i + 1][j] = 1\n             \
    \   }\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsvpfcxs8/tmpsvpfcxs8.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac54b3bec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac54b0b5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac54b0b5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac54b0b47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsvpfcxs8                        0x000056114a116706 <unavailable> + 5894

    5    libc.so.6                          0x00002ac54b5aa460 __libc_start_main +
    245

    6    tmpsvpfcxs8                        0x000056114a116299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpvzai82yo/tmpvzai82yo.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab59b057c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab59ad4eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab59ad4e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab59ad4d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvzai82yo                        0x000055f88bb683d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ab59b243460 __libc_start_main +
    245

    6    tmpvzai82yo                        0x000055f88bb67f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var wells = grid\n    let well_length = wells[0].count\n\
    \    var well_index = 0\n    var bucket = capacity\n    while well_index < wells.count\
    \ {\n        var well = wells[well_index]\n        var water_index = 0\n     \
    \   while water_index < well.count {\n            if well[water_index] == 1 {\n\
    \                if bucket == 0 {\n                    bucket = capacity\n   \
    \                 result += 1\n                }\n                well[water_index]\
    \ = 0\n                bucket -= 1\n            }\n            water_index +=\
    \ 1\n        }\n        wells[well_index] = well\n        well_index += 1\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmps40liy_j/tmps40liy_j.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acb1031fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acb10016b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acb10016988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acb100157b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps40liy_j                        0x0000558c58f66576 <unavailable> + 5494

    5    libc.so.6                          0x00002acb1050b460 __libc_start_main +
    245

    6    tmps40liy_j                        0x0000558c58f66109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    var row = 0\n    while\
    \ row < grid.count {\n        var column = 0\n        while column < grid[row].count\
    \ {\n            if grid[row][column] == 1 {\n                count += 1\n   \
    \             var bucket = capacity\n                while bucket > 0 {\n    \
    \                if row < grid.count && grid[row][column] == 1 {\n           \
    \             grid[row][column] = 0\n                        bucket -= 1\n   \
    \                 }\n                    row += 1\n                }\n       \
    \         row -= 1\n            }\n            column += 1\n        }\n      \
    \  row += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpramfbmi4/tmpramfbmi4.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af175f58c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af175c4fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af175c4f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af175c4e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpramfbmi4                        0x000055b3a1d1c747 <unavailable> + 5959

    5    libc.so.6                          0x00002af176144460 __libc_start_main +
    245

    6    tmpramfbmi4                        0x000055b3a1d1c109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    var row = 0\n    while\
    \ row < grid.count {\n        var col = 0\n        while col < grid[row].count\
    \ {\n            if grid[row][col] == 1 {\n                grid[row][col] = 0\n\
    \                count += 1\n                var bucket = capacity\n         \
    \       while bucket > 0 {\n                    if row + 1 < grid.count && grid[row\
    \ + 1][col] == 1 {\n                        grid[row + 1][col] = 0\n         \
    \               bucket -= 1\n                    } else if col + 1 < grid[row].count\
    \ && grid[row][col + 1] == 1 {\n                        grid[row][col + 1] = 0\n\
    \                        bucket -= 1\n                    } else {\n         \
    \               break\n                    }\n                }\n            }\n\
    \            col += 1\n        }\n        row += 1\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp3z113eq4/tmp3z113eq4.swift:66: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad3af9dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad3af6d2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad3af6d2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad3af6d17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3z113eq4                        0x000055e7a4e3c576 <unavailable> + 5494

    5    libc.so.6                          0x00002ad3afbc7460 __libc_start_main +
    245

    6    tmp3z113eq4                        0x000055e7a4e3c109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    var grid = grid\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                if capacity > 1 {\n             \
    \       for k in 1..<capacity {\n                        if i + k < grid.count\
    \ {\n                            grid[i + k][j] = 0\n                        }\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpgq67o594/tmpgq67o594.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002add2ff39c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002add2fc30b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002add2fc30988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002add2fc2f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgq67o594                        0x0000558b226ae8d7 <unavailable> + 6359

    5    libc.so.6                          0x00002add30125460 __libc_start_main +
    245

    6    tmpgq67o594                        0x0000558b226ae299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    var grid = grid\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                var k = i\n                while\
    \ k < grid.count && grid[k][j] == 1 {\n                    grid[k][j] = 0\n  \
    \                  k += 1\n                }\n            }\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpgjacb22a/tmpgjacb22a.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aec55f22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aec55c19b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aec55c19988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aec55c187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgjacb22a                        0x00005631b13c5706 <unavailable> + 5894

    5    libc.so.6                          0x00002aec5610e460 __libc_start_main +
    245

    6    tmpgjacb22a                        0x00005631b13c5299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var water = 0\n    var max_water = 0\n    for row in grid {\n\
    \        for col in row {\n            if col == 1 {\n                water +=\
    \ 1\n            }\n        }\n        max_water = max(max_water, water)\n   \
    \     water = 0\n    }\n    return max_water / capacity\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpxamld0mh/tmpxamld0mh.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab94235bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab942052b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab942052988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab9420517b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxamld0mh                        0x0000561ce8d50676 <unavailable> + 5750

    5    libc.so.6                          0x00002ab942547460 __libc_start_main +
    245

    6    tmpxamld0mh                        0x0000561ce8d50209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpvzai82yo/tmpvzai82yo.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab59b057c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab59ad4eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab59ad4e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab59ad4d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvzai82yo                        0x000055f88bb683d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ab59b243460 __libc_start_main +
    245

    6    tmpvzai82yo                        0x000055f88bb67f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    var i = 0\n    while i\
    \ < grid.count {\n        var j = 0\n        while j < grid[i].count {\n     \
    \       if grid[i][j] == 1 {\n                var k = i\n                while\
    \ k < grid.count && grid[k][j] == 1 {\n                    grid[k][j] = 0\n  \
    \                  k += 1\n                }\n                count += 1\n   \
    \         }\n            j += 1\n        }\n        i += 1\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpe9p1kyts/tmpe9p1kyts.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac1a14b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac1a11acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac1a11ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac1a11ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe9p1kyts                        0x00005619d003d576 <unavailable> + 5494

    5    libc.so.6                          0x00002ac1a16a1460 __libc_start_main +
    245

    6    tmpe9p1kyts                        0x00005619d003d109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                grid[i][j] = 0\n                var\
    \ k = i\n                while k < grid.count && grid[k][j] == 0 {\n         \
    \           grid[k][j] = 1\n                    k += 1\n                }\n  \
    \          }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmprw50xyjt/tmprw50xyjt.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab8eb0d6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab8eadcdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab8eadcd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab8eadcc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprw50xyjt                        0x0000558a808b9706 <unavailable> + 5894

    5    libc.so.6                          0x00002ab8eb2c2460 __libc_start_main +
    245

    6    tmprw50xyjt                        0x0000558a808b9299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, i: i, j: j, capacity:\
    \ capacity)\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmporchcpto.swift:30:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                grid[i][j] = 0\n                if\
    \ i + 1 < grid.count {\n                    grid[i + 1][j] = 0\n             \
    \   }\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpplcel19y/tmpplcel19y.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b93f5683c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b93f537ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b93f537a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b93f53797b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpplcel19y                        0x000055e3c599e706 <unavailable> + 5894

    5    libc.so.6                          0x00002b93f586f460 __libc_start_main +
    245

    6    tmpplcel19y                        0x000055e3c599e299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    for i in 0..<grid.count {\n        for j in\
    \ 0..<grid[i].count {\n            if grid[i][j] == 1 {\n                count\
    \ += 1\n            }\n        }\n    }\n    return count / capacity + (count\
    \ % capacity > 0 ? 1 : 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmps1one60g/tmps1one60g.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac51ce74c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac51cb6bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac51cb6b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac51cb6a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps1one60g                        0x00005598321fbc54 <unavailable> + 7252

    5    libc.so.6                          0x00002ac51d060460 __libc_start_main +
    245

    6    tmps1one60g                        0x00005598321fb1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    var i = 0\n    while i\
    \ < grid.count {\n        var j = 0\n        while j < grid[i].count {\n     \
    \       if grid[i][j] == 1 {\n                count += 1\n                var\
    \ k = i\n                while k < grid.count && k < i + capacity {\n        \
    \            grid[k][j] = 0\n                    k += 1\n                }\n \
    \           }\n            j += 1\n        }\n        i += 1\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpuwilmrm4/tmpuwilmrm4.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4bd562bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4bd5322b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4bd5322988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4bd53217b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuwilmrm4                        0x000055e034fe0747 <unavailable> + 5959

    5    libc.so.6                          0x00002b4bd5817460 __libc_start_main +
    245

    6    tmpuwilmrm4                        0x000055e034fe0109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var max_value = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                max_value += 1\n            }\n        }\n    }\n    var current_value\
    \ = 0\n    var i = 0\n    while current_value < max_value {\n        for j in\
    \ 0..<grid[i].count {\n            if grid[i][j] == 1 {\n                current_value\
    \ += 1\n                grid[i][j] = 0\n            }\n        }\n        result\
    \ += 1\n        i += 1\n        if i == grid.count {\n            i = 0\n    \
    \    }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpvpjsbtaf.swift:39:24: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                grid[i][j] = 0\n                ~~~~  \
    \ ^\n"
  stdout: ''
  timestamp: 1659824405
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    let rows = grid.count\n    let cols = grid[0].count\n    var count\
    \ = 0\n    var grid = grid\n    for row in 0..<rows {\n        for col in 0..<cols\
    \ {\n            if grid[row][col] == 1 {\n                count += 1\n      \
    \          fill(grid: &grid, row: row, col: col, capacity: capacity)\n       \
    \     }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpwe8q0n2b.swift:32:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, row: row, col: col, capacity: capacity)\n     \
    \           ^~~~\n"
  stdout: ''
  timestamp: 1659824405
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        var rowSum = 0\n\
    \        for well in row {\n            rowSum += well\n        }\n        result\
    \ += rowSum / capacity\n        if rowSum % capacity != 0 {\n            result\
    \ += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824405
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, i: i, j: j, capacity:\
    \ capacity)\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmporchcpto.swift:30:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    var max = 0\n    for row in grid {\n      \
    \  for item in row {\n            if item == 1 {\n                count += 1\n\
    \            }\n        }\n        if count > max {\n            max = count\n\
    \        }\n        count = 0\n    }\n    return max * capacity\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmphp0a3a48/tmphp0a3a48.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac26d99dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac26d694b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac26d694988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac26d6937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphp0a3a48                        0x0000561093f0d546 <unavailable> + 5446

    5    libc.so.6                          0x00002ac26db89460 __libc_start_main +
    245

    6    tmphp0a3a48                        0x0000561093f0d0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824404
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    while !grid.isEmpty {\n\
    \        let row = grid.removeFirst()\n        let row_count = row.reduce(0, +)\n\
    \        if row_count == 0 {\n            continue\n        }\n        count +=\
    \ row_count / capacity\n        if row_count % capacity != 0 {\n            count\
    \ += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824405
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                grid[i][j] = 0\n                count += 1\n                var\
    \ k = i\n                while k < grid.count && capacity > 0 {\n            \
    \        if grid[k][j] == 1 {\n                        grid[k][j] = 0\n      \
    \                  capacity -= 1\n                    }\n                    k\
    \ += 1\n                }\n                capacity = capacity + 1\n         \
    \   }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpcg2yv925.swift:35:34: error: left side of mutating operator isn't\
    \ mutable: 'capacity' is a 'let' constant\n                        capacity -=\
    \ 1\n                        ~~~~~~~~ ^\n/tmp/tmpcg2yv925.swift:39:17: error:\
    \ cannot assign to value: 'capacity' is a 'let' constant\n                capacity\
    \ = capacity + 1\n                ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    while true {\n       \
    \ var found = false\n        for i in 0..<grid.count {\n            for j in 0..<grid[i].count\
    \ {\n                if grid[i][j] == 1 {\n                    found = true\n\
    \                    grid[i][j] = 0\n                    for k in 0..<capacity\
    \ {\n                        if i + k < grid.count {\n                       \
    \     grid[i + k][j] = 0\n                        }\n                    }\n \
    \               }\n            }\n        }\n        if !found {\n           \
    \ break\n        }\n        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpf6x1pe_o/tmpf6x1pe_o.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b77d08e6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b77d05ddb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b77d05dd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b77d05dc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf6x1pe_o                        0x000055611f22c706 <unavailable> + 5894

    5    libc.so.6                          0x00002b77d0ad2460 __libc_start_main +
    245

    6    tmpf6x1pe_o                        0x000055611f22c299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                grid[i][j] = 0\n                var\
    \ bucket = capacity\n                var k = i\n                while bucket >\
    \ 0 && k < grid.count {\n                    if grid[k][j] == 1 {\n          \
    \              grid[k][j] = 0\n                        bucket -= 1\n         \
    \           }\n                    k += 1\n                }\n            }\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpresq8z9e/tmpresq8z9e.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7fba7bdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7fba4b4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7fba4b4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7fba4b37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpresq8z9e                        0x0000561095f00706 <unavailable> + 5894

    5    libc.so.6                          0x00002b7fba9a9460 __libc_start_main +
    245

    6    tmpresq8z9e                        0x0000561095f00299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, i: i, j: j, capacity:\
    \ capacity)\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmporchcpto.swift:30:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, i: i, j: j, capacity:\
    \ capacity)\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmporchcpto.swift:30:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    var i = 0\n    while i\
    \ < grid.count {\n        var j = 0\n        while j < grid[i].count {\n     \
    \       if grid[i][j] == 1 {\n                var k = 0\n                while\
    \ k < capacity {\n                    if i + k < grid.count {\n              \
    \          grid[i + k][j] = 0\n                    }\n                    k +=\
    \ 1\n                }\n                count += 1\n            }\n          \
    \  j += 1\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpbh__31a8/tmpbh__31a8.swift:61: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3394130c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3393e27b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3393e27988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3393e267b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbh__31a8                        0x000055d486226747 <unavailable> + 5959

    5    libc.so.6                          0x00002b339431c460 __libc_start_main +
    245

    6    tmpbh__31a8                        0x000055d486226109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var total = 0\n    for row in grid {\n        total += row.reduce(0,\
    \ +)\n    }\n    return total / capacity\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpbpmbrp54/tmpbpmbrp54.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56c0e9ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56c0b91b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56c0b91988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56c0b907b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbpmbrp54                        0x0000564beaba4817 <unavailable> + 6167

    5    libc.so.6                          0x00002b56c1086460 __libc_start_main +
    245

    6    tmpbpmbrp54                        0x0000564beaba41d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, capacity: capacity,\
    \ i: i, j: j)\n            }\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpxfpjdn12.swift:30:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, capacity: capacity, i: i, j: j)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var wells = grid\n    var count = 0\n    for i in 0..<wells.count\
    \ {\n        for j in 0..<wells[i].count {\n            if wells[i][j] == 1 {\n\
    \                count += 1\n                wells[i][j] = 0\n               \
    \ var bucket = capacity\n                var k = i\n                while bucket\
    \ > 0 && k < wells.count {\n                    if wells[k][j] == 1 {\n      \
    \                  wells[k][j] = 0\n                        bucket -= 1\n    \
    \                }\n                    k += 1\n                }\n          \
    \  }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmp0mrg1kpc/tmp0mrg1kpc.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b11b4b3bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b11b4832b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b11b4832988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b11b48317b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0mrg1kpc                        0x0000561ea70ee706 <unavailable> + 5894

    5    libc.so.6                          0x00002b11b4d27460 __libc_start_main +
    245

    6    tmp0mrg1kpc                        0x0000561ea70ee299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    while true {\n       \
    \ var min = Int.max\n        var min_i = 0\n        for i in 0..<grid.count {\n\
    \            let row = grid[i]\n            let sum = row.reduce(0, +)\n     \
    \       if sum < min {\n                min = sum\n                min_i = i\n\
    \            }\n        }\n        if min == 0 {\n            break\n        }\n\
    \        for i in 0..<grid[min_i].count {\n            if grid[min_i][i] == 1\
    \ {\n                grid[min_i][i] = 0\n                count += 1\n        \
    \    }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmphvs0ljxi/tmphvs0ljxi.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1e0ea71c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1e0e768b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1e0e768988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1e0e7677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphvs0ljxi                        0x00005599ac135776 <unavailable> + 6006

    5    libc.so.6                          0x00002b1e0ec5d460 __libc_start_main +
    245

    6    tmphvs0ljxi                        0x00005599ac135309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1659824406
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    while true {\n       \
    \ var max = 0\n        var max_index = 0\n        for (index, row) in grid.enumerated()\
    \ {\n            let sum = row.reduce(0, +)\n            if sum > max {\n    \
    \            max = sum\n                max_index = index\n            }\n   \
    \     }\n        if max == 0 {\n            break\n        }\n        count +=\
    \ 1\n        for i in 0..<grid[max_index].count {\n            if grid[max_index][i]\
    \ == 1 {\n                grid[max_index][i] = 0\n            } else {\n     \
    \           break\n            }\n        }\n    }\n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824410
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    for row in grid {\n        var bucket = capacity\n\
    \        for well in row {\n            if well == 1 {\n                if bucket\
    \ > 0 {\n                    bucket -= 1\n                } else {\n         \
    \           count += 1\n                    bucket = capacity - 1\n          \
    \      }\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp69e31nnv/tmp69e31nnv.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae9ef34dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae9ef044b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae9ef044988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae9ef0437b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp69e31nnv                        0x000055e68a69c546 <unavailable> + 5446

    5    libc.so.6                          0x00002ae9ef539460 __libc_start_main +
    245

    6    tmp69e31nnv                        0x000055e68a69c0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for row in grid {\n  \
    \      for col in row {\n            if col == 1 {\n                count += 1\n\
    \            }\n        }\n    }\n    return count / capacity\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpy683jbd6/tmpy683jbd6.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0b866e2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0b863d9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0b863d9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0b863d87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy683jbd6                        0x00005604b95277a7 <unavailable> + 6055

    5    libc.so.6                          0x00002b0b868ce460 __libc_start_main +
    245

    6    tmpy683jbd6                        0x00005604b9527169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max_fill = 0\n    for row in grid {\n        var fill = 0\n\
    \        for well in row {\n            fill += well\n            if fill == capacity\
    \ {\n                max_fill += 1\n                fill = 0\n            }\n\
    \        }\n        max_fill += fill\n    }\n    return max_fill\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp30ed9i3p/tmp30ed9i3p.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b432a108c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4329dffb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4329dff988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4329dfe7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp30ed9i3p                        0x00005608d6a90b44 <unavailable> + 6980

    5    libc.so.6                          0x00002b432a2f4460 __libc_start_main +
    245

    6    tmp30ed9i3p                        0x00005608d6a900d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824406
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, i: i, j: j, capacity:\
    \ capacity)\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmporchcpto.swift:30:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    while true {\n       \
    \ var filled = false\n        for i in 0..<grid.count {\n            for j in\
    \ 0..<grid[i].count {\n                if grid[i][j] == 1 {\n                \
    \    filled = true\n                    grid[i][j] = 0\n                    if\
    \ i > 0 {\n                        grid[i - 1][j] = min(grid[i - 1][j] + 1, capacity)\n\
    \                    }\n                    if i < grid.count - 1 {\n        \
    \                grid[i + 1][j] = min(grid[i + 1][j] + 1, capacity)\n        \
    \            }\n                    if j > 0 {\n                        grid[i][j\
    \ - 1] = min(grid[i][j - 1] + 1, capacity)\n                    }\n          \
    \          if j < grid[i].count - 1 {\n                        grid[i][j + 1]\
    \ = min(grid[i][j + 1] + 1, capacity)\n                    }\n               \
    \ }\n            }\n        }\n        if !filled {\n            break\n     \
    \   }\n        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var water = 0\n    var count = 0\n    for row in grid {\n    \
    \    for col in row {\n            if col == 1 {\n                water += 1\n\
    \            }\n        }\n    }\n    while water > 0 {\n        count += 1\n\
    \        water -= capacity\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpco7ygi9t/tmpco7ygi9t.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba48b610c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba48b307b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba48b307988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba48b3067b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpco7ygi9t                        0x000056403cfe2b44 <unavailable> + 6980

    5    libc.so.6                          0x00002ba48b7fc460 __libc_start_main +
    245

    6    tmpco7ygi9t                        0x000056403cfe20d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824406
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    while !grid.isEmpty {\n\
    \        var row = grid.removeFirst()\n        while !row.isEmpty {\n        \
    \    let _ = row.removeFirst()\n            count += 1\n        }\n    }\n   \
    \ return count / capacity\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpkvbe5ay4/tmpkvbe5ay4.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5efe76bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5efe462b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5efe462988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5efe4617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkvbe5ay4                        0x000056026e2465a6 <unavailable> + 5542

    5    libc.so.6                          0x00002b5efe957460 __libc_start_main +
    245

    6    tmpkvbe5ay4                        0x000056026e246139 <unavailable> + 4409

    '
  stdout: ''
  timestamp: 1659824406
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    while !grid.isEmpty {\n\
    \        let max = grid.map { $0.reduce(0, +) }.max()!\n        if max == 0 {\n\
    \            grid.removeFirst()\n            continue\n        }\n        let\
    \ row = grid.firstIndex(where: { $0.reduce(0, +) == max })!\n        let col =\
    \ grid[row].firstIndex(of: 1)!\n        grid[row][col] = 0\n        count += 1\n\
    \        for i in 0..<grid.count {\n            if grid[i][col] == 1 {\n     \
    \           grid[i][col] = 0\n            }\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4tvtepdh/tmp4tvtepdh.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b66a6c87c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b66a697eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b66a697e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b66a697d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4tvtepdh                        0x00005565905b4a46 <unavailable> + 6726

    5    libc.so.6                          0x00002b66a6e73460 __libc_start_main +
    245

    6    tmp4tvtepdh                        0x00005565905b45d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824406
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                for k in 0..<grid.count {\n     \
    \               if grid[k][j] == 1 {\n                        grid[k][j] = 0\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpmtu487_a/tmpmtu487_a.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac1c3d5cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac1c3a53b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac1c3a53988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac1c3a527b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmtu487_a                        0x0000565249a9d706 <unavailable> + 5894

    5    libc.so.6                          0x00002ac1c3f48460 __libc_start_main +
    245

    6    tmpmtu487_a                        0x0000565249a9d299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824406
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, i: i, j: j, capacity:\
    \ capacity)\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmporchcpto.swift:30:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    var row = 0\n    var col\
    \ = 0\n    while row < grid.count {\n        if grid[row][col] == 1 {\n      \
    \      grid[row][col] = 0\n            count += 1\n        }\n        if col ==\
    \ grid[row].count - 1 {\n            row += 1\n            col = 0\n        }\
    \ else {\n            col += 1\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpjl1p59es/tmpjl1p59es.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af3908dfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af3905d6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af3905d6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af3905d57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjl1p59es                        0x000055901dbce747 <unavailable> + 5959

    5    libc.so.6                          0x00002af390acb460 __libc_start_main +
    245

    6    tmpjl1p59es                        0x000055901dbce109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    var row = 0\n    while\
    \ row < grid.count {\n        var col = 0\n        while col < grid[row].count\
    \ {\n            if grid[row][col] == 1 {\n                count += 1\n      \
    \          var row_ = row\n                while row_ < grid.count && grid[row_][col]\
    \ == 1 {\n                    grid[row_][col] = 0\n                    row_ +=\
    \ 1\n                }\n            }\n            col += 1\n        }\n     \
    \   row += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmp9jtfb_w3/tmp9jtfb_w3.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b57c93e5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b57c90dcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b57c90dc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b57c90db7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9jtfb_w3                        0x000055657537e576 <unavailable> + 5494

    5    libc.so.6                          0x00002b57c95d1460 __libc_start_main +
    245

    6    tmp9jtfb_w3                        0x000055657537e109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1659824406
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var max = 0\n    for row in grid {\n     \
    \   for column in row {\n            if column == 1 {\n                max +=\
    \ 1\n            }\n        }\n    }\n    var current = 0\n    for row in grid\
    \ {\n        for column in row {\n            if column == 1 {\n             \
    \   current += 1\n            }\n        }\n        if current == max {\n    \
    \        break\n        }\n        result += 1\n        current = 0\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpjh24gpqs/tmpjh24gpqs.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b310a193c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3109e8ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3109e8a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3109e897b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjh24gpqs                        0x00005639e43bd546 <unavailable> + 5446

    5    libc.so.6                          0x00002b310a37f460 __libc_start_main +
    245

    6    tmpjh24gpqs                        0x00005639e43bd0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824406
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    while grid.contains(where:\
    \ { $0.contains(1) }) {\n        for i in 0..<grid.count {\n            for j\
    \ in 0..<grid[i].count {\n                if grid[i][j] == 1 {\n             \
    \       grid[i][j] = 0\n                    count += 1\n                }\n  \
    \          }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp5g3fg12x/tmp5g3fg12x.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b37656bfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b37653b6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b37653b6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b37653b57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5g3fg12x                        0x00005644489189a7 <unavailable> + 6567

    5    libc.so.6                          0x00002b37658ab460 __libc_start_main +
    245

    6    tmp5g3fg12x                        0x0000564448918369 <unavailable> + 4969

    '
  stdout: ''
  timestamp: 1659824406
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    while true {\n       \
    \ var is_empty = true\n        for i in 0..<grid.count {\n            for j in\
    \ 0..<grid[i].count {\n                if grid[i][j] == 1 {\n                \
    \    is_empty = false\n                    grid[i][j] = 0\n                  \
    \  count += 1\n                }\n            }\n        }\n        if is_empty\
    \ {\n            break\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpw1mg4ciz/tmpw1mg4ciz.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3d1271dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3d12414b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3d12414988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3d124137b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw1mg4ciz                        0x000055f6f730d8d7 <unavailable> + 6359

    5    libc.so.6                          0x00002b3d12909460 __libc_start_main +
    245

    6    tmpw1mg4ciz                        0x000055f6f730d299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824406
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    while true {\n       \
    \ var filled = false\n        for i in 0..<grid.count {\n            for j in\
    \ 0..<grid[i].count {\n                if grid[i][j] == 1 {\n                \
    \    filled = true\n                    grid[i][j] = 0\n                    if\
    \ i > 0 {\n                        grid[i - 1][j] = min(grid[i - 1][j] + 1, capacity)\n\
    \                    }\n                    if i < grid.count - 1 {\n        \
    \                grid[i + 1][j] = min(grid[i + 1][j] + 1, capacity)\n        \
    \            }\n                    if j > 0 {\n                        grid[i][j\
    \ - 1] = min(grid[i][j - 1] + 1, capacity)\n                    }\n          \
    \          if j < grid[i].count - 1 {\n                        grid[i][j + 1]\
    \ = min(grid[i][j + 1] + 1, capacity)\n                    }\n               \
    \ }\n            }\n        }\n        if !filled {\n            break\n     \
    \   }\n        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, i: i, j: j, capacity:\
    \ capacity)\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmporchcpto.swift:30:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                grid[i][j] = 0\n                var\
    \ k = i\n                while k < grid.count && capacity > 0 {\n            \
    \        if grid[k][j] == 1 {\n                        count += 1\n          \
    \              grid[k][j] = 0\n                        capacity -= 1\n       \
    \             }\n                    k += 1\n                }\n            }\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmphflw8263.swift:36:34: error: left side of mutating operator isn't\
    \ mutable: 'capacity' is a 'let' constant\n                        capacity -=\
    \ 1\n                        ~~~~~~~~ ^\n"
  stdout: ''
  timestamp: 1659824406
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    while !grid.isEmpty {\n\
    \        var max = 0\n        var maxIndex = 0\n        for i in 0..<grid.count\
    \ {\n            let sum = grid[i].reduce(0, +)\n            if sum > max {\n\
    \                max = sum\n                maxIndex = i\n            }\n    \
    \    }\n        count += max / capacity\n        if max % capacity != 0 {\n  \
    \          count += 1\n        }\n        grid.remove(at: maxIndex)\n    }\n \
    \   return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824406
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    var max = 0\n    for i\
    \ in 0..<grid.count {\n        for j in 0..<grid[i].count {\n            if grid[i][j]\
    \ == 1 {\n                max = i\n            }\n        }\n    }\n    for i\
    \ in 0...max {\n        for j in 0..<grid[i].count {\n            if grid[i][j]\
    \ == 1 {\n                count += 1\n                for k in i..<grid.count\
    \ {\n                    if grid[k][j] == 1 {\n                        grid[k][j]\
    \ = 0\n                    }\n                }\n            }\n        }\n  \
    \  }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp3xi0744k/tmp3xi0744k.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae3bc9f9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae3bc6f0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae3bc6f0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae3bc6ef7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3xi0744k                        0x00005577d14237f6 <unavailable> + 6134

    5    libc.so.6                          0x00002ae3bcbe5460 __libc_start_main +
    245

    6    tmp3xi0744k                        0x00005577d1423389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1659824406
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var max_depth = 0\n    for row in grid {\n\
    \        max_depth = max(max_depth, row.reduce(0, +))\n    }\n    for depth in\
    \ 0..<max_depth {\n        for row in grid {\n            for column in row {\n\
    \                if column > depth {\n                    result += 1\n      \
    \          }\n            }\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpe9dnulay/tmpe9dnulay.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afd94085c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afd93d7cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afd93d7c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afd93d7b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe9dnulay                        0x00005617cf8f89a7 <unavailable> + 6567

    5    libc.so.6                          0x00002afd94271460 __libc_start_main +
    245

    6    tmpe9dnulay                        0x00005617cf8f8369 <unavailable> + 4969

    '
  stdout: ''
  timestamp: 1659824406
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var max_row = 0\n    for row in grid {\n \
    \       max_row = max(max_row, row.reduce(0, +))\n    }\n    for _ in 0..<max_row\
    \ {\n        for row in grid {\n            for i in 0..<row.count {\n       \
    \         if row[i] > 0 {\n                    row[i] -= 1\n                 \
    \   result += 1\n                }\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp1_g3ucyj.swift:33:28: error: left side of mutating operator isn't\
    \ mutable: 'row' is a 'let' constant\n                    row[i] -= 1\n      \
    \              ~~~    ^\n"
  stdout: ''
  timestamp: 1659824406
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    var wells = grid\n    var buckets = Array(repeating:\
    \ capacity, count: grid[0].count)\n    while true {\n        var is_empty = true\n\
    \        for i in 0..<wells.count {\n            for j in 0..<wells[i].count {\n\
    \                if wells[i][j] == 1 {\n                    is_empty = false\n\
    \                    if buckets[j] > 0 {\n                        buckets[j] -=\
    \ 1\n                        wells[i][j] = 0\n                    }\n        \
    \        }\n            }\n        }\n        if is_empty {\n            break\n\
    \        }\n        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824411
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var max = 0\n    for i in 0..<grid.count {\n\
    \        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n    \
    \            max += 1\n            }\n        }\n    }\n    var current = 0\n\
    \    while current < max {\n        for i in 0..<grid.count {\n            for\
    \ j in 0..<grid[i].count {\n                if grid[i][j] == 1 {\n           \
    \         current += 1\n                    grid[i][j] = 0\n                 \
    \   result += 1\n                }\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp0ko7l2va.swift:39:28: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                    grid[i][j] = 0\n                  \
    \  ~~~~   ^\n"
  stdout: ''
  timestamp: 1659824406
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                for k in 0..<capacity {\n       \
    \             if i + k < grid.count {\n                        grid[i + k][j]\
    \ = 0\n                    }\n                }\n            }\n        }\n  \
    \  }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpkh5kfsyv/tmpkh5kfsyv.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6df9ec1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6df9bb8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6df9bb8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6df9bb77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkh5kfsyv                        0x000055645e2828d7 <unavailable> + 6359

    5    libc.so.6                          0x00002b6dfa0ad460 __libc_start_main +
    245

    6    tmpkh5kfsyv                        0x000055645e282299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824404
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, i: i, j: j, capacity:\
    \ capacity)\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmporchcpto.swift:30:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    while true {\n       \
    \ var is_empty = true\n        for i in 0..<grid.count {\n            for j in\
    \ 0..<grid[i].count {\n                if grid[i][j] == 1 {\n                \
    \    is_empty = false\n                    grid[i][j] = 0\n                  \
    \  count += 1\n                }\n            }\n        }\n        if is_empty\
    \ {\n            break\n        }\n        for i in 0..<grid.count {\n       \
    \     for j in 0..<grid[i].count {\n                if grid[i][j] == -1 {\n  \
    \                  grid[i][j] = 1\n                }\n            }\n        }\n\
    \        for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n\
    \                if grid[i][j] == 0 {\n                    grid[i][j] = -1\n \
    \               }\n            }\n        }\n    }\n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4bie8hdk/tmp4bie8hdk.swift:72: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4667c21c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4667918b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4667918988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b46679177b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4bie8hdk                        0x000055900f19b8d7 <unavailable> + 6359

    5    libc.so.6                          0x00002b4667e0d460 __libc_start_main +
    245

    6    tmp4bie8hdk                        0x000055900f19b299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824406
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    while grid.contains(where:\
    \ { $0.contains(1) }) {\n        for i in 0..<grid.count {\n            for j\
    \ in 0..<grid[i].count {\n                if grid[i][j] == 1 {\n             \
    \       grid[i][j] = 0\n                    if i + 1 < grid.count && grid[i +\
    \ 1][j] == 1 {\n                        grid[i + 1][j] = 0\n                 \
    \   }\n                    if j + 1 < grid[i].count && grid[i][j + 1] == 1 {\n\
    \                        grid[i][j + 1] = 0\n                    }\n         \
    \           count += 1\n                }\n            }\n        }\n    }\n \
    \   return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp2h7vd9bt/tmp2h7vd9bt.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b40ff18fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b40fee86b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b40fee86988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b40fee857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2h7vd9bt                        0x000055db3c23e7d6 <unavailable> + 6102

    5    libc.so.6                          0x00002b40ff37b460 __libc_start_main +
    245

    6    tmp2h7vd9bt                        0x000055db3c23e369 <unavailable> + 4969

    '
  stdout: ''
  timestamp: 1659824406
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max_fill = 0\n    for row in grid {\n        var fill = 0\n\
    \        for well in row {\n            fill += well\n            if fill == capacity\
    \ {\n                max_fill += 1\n                fill = 0\n            }\n\
    \        }\n        if fill > 0 {\n            max_fill += 1\n        }\n    }\n\
    \    return max_fill\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824406
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    var grid = grid\n    var capacity = capacity\n\
    \    for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n       \
    \     if grid[i][j] == 1 {\n                grid[i][j] = 0\n                count\
    \ += 1\n                capacity -= 1\n                if capacity == 0 {\n  \
    \                  count += 1\n                    capacity = capacity + 1\n \
    \               }\n            }\n        }\n    }\n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmphiqfio08/tmphiqfio08.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0131aedc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b01317e4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b01317e4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b01317e37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphiqfio08                        0x0000563a153f9706 <unavailable> + 5894

    5    libc.so.6                          0x00002b0131cd9460 __libc_start_main +
    245

    6    tmphiqfio08                        0x0000563a153f9299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824406
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    let rows = grid.count\n    let cols = grid[0].count\n    var max_fill\
    \ = 0\n    for row in 0..<rows {\n        for col in 0..<cols {\n            if\
    \ grid[row][col] == 1 {\n                max_fill += 1\n            }\n      \
    \  }\n    }\n    return max_fill * capacity\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmptyhwxz92/tmptyhwxz92.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9eab7edc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9eab4e4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9eab4e4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9eab4e37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptyhwxz92                        0x000055d146211827 <unavailable> + 6183

    5    libc.so.6                          0x00002b9eab9d9460 __libc_start_main +
    245

    6    tmptyhwxz92                        0x000055d1462111e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824406
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    var grid = grid\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, i: i, j: j, capacity:\
    \ capacity)\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpu14c4sfm.swift:30:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    while true {\n       \
    \ var max = 0\n        var maxIndex = 0\n        for i in 0..<grid.count {\n \
    \           var sum = 0\n            for j in 0..<grid[i].count {\n          \
    \      sum += grid[i][j]\n            }\n            if sum > max {\n        \
    \        max = sum\n                maxIndex = i\n            }\n        }\n \
    \       if max == 0 {\n            break\n        }\n        for i in 0..<grid[maxIndex].count\
    \ {\n            if grid[maxIndex][i] == 1 {\n                grid[maxIndex][i]\
    \ = 0\n                count += 1\n            }\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpjjqzpgf8/tmpjjqzpgf8.swift:66: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4dcb063c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4dcad5ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4dcad5a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4dcad597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjjqzpgf8                        0x000055c970a938d7 <unavailable> + 6359

    5    libc.so.6                          0x00002b4dcb24f460 __libc_start_main +
    245

    6    tmpjjqzpgf8                        0x000055c970a93299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824406
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, i: i, j: j, capacity:\
    \ capacity)\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmporchcpto.swift:30:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, i: i, j: j, capacity:\
    \ capacity)\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmporchcpto.swift:30:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    var max = 0\n    for i\
    \ in 0..<grid.count {\n        for j in 0..<grid[i].count {\n            if grid[i][j]\
    \ == 1 {\n                max = max + 1\n            }\n        }\n    }\n   \
    \ while count < max {\n        for i in 0..<grid.count {\n            for j in\
    \ 0..<grid[i].count {\n                if grid[i][j] == 1 {\n                \
    \    grid[i][j] = 0\n                    count = count + 1\n                 \
    \   if count == max {\n                        return count\n                \
    \    }\n                }\n            }\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpd1ci56lc/tmpd1ci56lc.swift:64: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96fdb9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac96fab0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac96fab0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac96faaf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd1ci56lc                        0x000055e683b158d7 <unavailable> + 6359

    5    libc.so.6                          0x00002ac96ffa5460 __libc_start_main +
    245

    6    tmpd1ci56lc                        0x000055e683b15299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824406
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, capacity: capacity,\
    \ i: i, j: j)\n            }\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpxfpjdn12.swift:30:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, capacity: capacity, i: i, j: j)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                if i > 0 {\n                    grid[i-1][j]\
    \ = 1\n                }\n                if i < grid.count - 1 {\n          \
    \          grid[i+1][j] = 1\n                }\n                if j > 0 {\n \
    \                   grid[i][j-1] = 1\n                }\n                if j\
    \ < grid[i].count - 1 {\n                    grid[i][j+1] = 1\n              \
    \  }\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp5vcapv_b/tmp5vcapv_b.swift:61: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b963652fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9636226b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9636226988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b96362257b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5vcapv_b                        0x0000555e39462706 <unavailable> + 5894

    5    libc.so.6                          0x00002b963671b460 __libc_start_main +
    245

    6    tmp5vcapv_b                        0x0000555e39462299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824406
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, i: i, j: j, capacity:\
    \ capacity)\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmporchcpto.swift:30:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                grid[i][j] = 0\n                for\
    \ k in i+1..<grid.count {\n                    if grid[k][j] == 1 {\n        \
    \                grid[k][j] = 0\n                        count += 1\n        \
    \            }\n                }\n            }\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp3nvtk80m/tmp3nvtk80m.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad987e3fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad987b36b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad987b36988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad987b357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3nvtk80m                        0x0000563ed4b168d7 <unavailable> + 6359

    5    libc.so.6                          0x00002ad98802b460 __libc_start_main +
    245

    6    tmp3nvtk80m                        0x0000563ed4b16299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824406
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max_fill = 0\n    for row in grid {\n        var fill = 0\n\
    \        for well in row {\n            if well == 1 {\n                fill +=\
    \ 1\n            }\n        }\n        if fill > max_fill {\n            max_fill\
    \ = fill\n        }\n    }\n    return max_fill * capacity\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmphj81hsat/tmphj81hsat.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abf2c332c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abf2c029b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abf2c029988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abf2c0287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphj81hsat                        0x000055bfee3e5546 <unavailable> + 5446

    5    libc.so.6                          0x00002abf2c51e460 __libc_start_main +
    245

    6    tmphj81hsat                        0x000055bfee3e50d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824406
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    var row = 0\n    var col\
    \ = 0\n    while row < grid.count {\n        while col < grid[row].count {\n \
    \           if grid[row][col] == 1 {\n                count += 1\n           \
    \     grid[row][col] = 0\n                for i in 0..<capacity {\n          \
    \          if col + i < grid[row].count {\n                        grid[row][col\
    \ + i] = 0\n                    }\n                }\n            }\n        \
    \    col += 1\n        }\n        col = 0\n        row += 1\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824406
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                grid[i][j] = 0\n                var\
    \ k = i\n                while k > 0 && grid[k - 1][j] == 1 {\n              \
    \      grid[k - 1][j] = 0\n                    k -= 1\n                }\n   \
    \         }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpftcq59ka/tmpftcq59ka.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8d9f085c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8d9ed7cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8d9ed7c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8d9ed7b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpftcq59ka                        0x000056410e91b8d7 <unavailable> + 6359

    5    libc.so.6                          0x00002b8d9f271460 __libc_start_main +
    245

    6    tmpftcq59ka                        0x000056410e91b299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    var row = 0\n    var col\
    \ = 0\n    while row < grid.count {\n        while col < grid[row].count {\n \
    \           if grid[row][col] == 1 {\n                count += 1\n           \
    \     grid[row][col] = 0\n                var i = 1\n                while i <=\
    \ capacity && row + i < grid.count {\n                    grid[row + i][col] =\
    \ 0\n                    i += 1\n                }\n            }\n          \
    \  col += 1\n        }\n        col = 0\n        row += 1\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpp4lcybmp/tmpp4lcybmp.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af059667c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af05935eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af05935e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af05935d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp4lcybmp                        0x000055d5425e0576 <unavailable> + 5494

    5    libc.so.6                          0x00002af059853460 __libc_start_main +
    245

    6    tmpp4lcybmp                        0x000055d5425e0109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1659824406
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                let row = min(i + capacity, grid.count)\n\
    \                let col = min(j + capacity, grid[i].count)\n                for\
    \ k in i..<row {\n                    for l in j..<col {\n                   \
    \     grid[k][l] = 0\n                    }\n                }\n            }\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpu86k98gd/tmpu86k98gd.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9134c7bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9134972b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9134972988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b91349717b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu86k98gd                        0x0000555eda391967 <unavailable> + 6503

    5    libc.so.6                          0x00002b9134e67460 __libc_start_main +
    245

    6    tmpu86k98gd                        0x0000555eda391329 <unavailable> + 4905

    '
  stdout: ''
  timestamp: 1659824406
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    while true {\n       \
    \ var filled = false\n        for i in 0..<grid.count {\n            for j in\
    \ 0..<grid[i].count {\n                if grid[i][j] == 1 {\n                \
    \    filled = true\n                    grid[i][j] = 0\n                    if\
    \ i > 0 {\n                        grid[i - 1][j] = 1\n                    }\n\
    \                    if i < grid.count - 1 {\n                        grid[i +\
    \ 1][j] = 1\n                    }\n                    if j > 0 {\n         \
    \               grid[i][j - 1] = 1\n                    }\n                  \
    \  if j < grid[i].count - 1 {\n                        grid[i][j + 1] = 1\n  \
    \                  }\n                }\n            }\n        }\n        if\
    \ filled {\n            count += 1\n        } else {\n            break\n    \
    \    }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824411
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    // your code here\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpvzw2by4m/tmpvzw2by4m.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad5ad623c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad5ad31ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad5ad31a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad5ad3197b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvzw2by4m                        0x000055777c9193d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ad5ad80f460 __libc_start_main +
    245

    6    tmpvzw2by4m                        0x000055777c918f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824405
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    var grid = grid\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                for k in 0..<capacity {\n       \
    \             if i + k < grid.count {\n                        grid[i + k][j]\
    \ = 0\n                    }\n                }\n            }\n        }\n  \
    \  }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpky9qg9w6/tmpky9qg9w6.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5ee944fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5ee9146b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5ee9146988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5ee91457b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpky9qg9w6                        0x0000556a69a598d7 <unavailable> + 6359

    5    libc.so.6                          0x00002b5ee963b460 __libc_start_main +
    245

    6    tmpky9qg9w6                        0x0000556a69a59299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824406
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, i: i, j: j, capacity:\
    \ capacity)\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmporchcpto.swift:30:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, i: i, j: j, capacity:\
    \ capacity)\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmporchcpto.swift:30:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, i: i, j: j, capacity:\
    \ capacity)\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmporchcpto.swift:30:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    var row = 0\n    while\
    \ row < grid.count {\n        var col = 0\n        while col < grid[row].count\
    \ {\n            if grid[row][col] == 1 {\n                count += 1\n      \
    \          var bucket = capacity\n                while bucket > 0 && row < grid.count\
    \ {\n                    if grid[row][col] == 1 {\n                        grid[row][col]\
    \ = 0\n                        bucket -= 1\n                    }\n          \
    \          row += 1\n                }\n                row -= 1\n           \
    \ }\n            col += 1\n        }\n        row += 1\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp8iml7uu3/tmp8iml7uu3.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b09dc7b2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b09dc4a9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b09dc4a9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b09dc4a87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8iml7uu3                        0x0000558c80f12747 <unavailable> + 5959

    5    libc.so.6                          0x00002b09dc99e460 __libc_start_main +
    245

    6    tmp8iml7uu3                        0x0000558c80f12109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1659824406
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    while true {\n       \
    \ var full = true\n        for i in 0..<grid.count {\n            for j in 0..<grid[i].count\
    \ {\n                if grid[i][j] == 1 {\n                    full = false\n\
    \                    break\n                }\n            }\n        }\n    \
    \    if full {\n            break\n        }\n        for i in 0..<grid.count\
    \ {\n            for j in 0..<grid[i].count {\n                if grid[i][j] ==\
    \ 1 {\n                    grid[i][j] = 0\n                    if i - 1 >= 0 {\n\
    \                        grid[i - 1][j] = min(grid[i - 1][j] + 1, capacity)\n\
    \                    }\n                    if i + 1 < grid.count {\n        \
    \                grid[i + 1][j] = min(grid[i + 1][j] + 1, capacity)\n        \
    \            }\n                    if j - 1 >= 0 {\n                        grid[i][j\
    \ - 1] = min(grid[i][j - 1] + 1, capacity)\n                    }\n          \
    \          if j + 1 < grid[i].count {\n                        grid[i][j + 1]\
    \ = min(grid[i][j + 1] + 1, capacity)\n                    }\n               \
    \ }\n            }\n        }\n        count += 1\n    }\n    return count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824411
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    let rows = grid.count\n    let cols = grid[0].count\n    var result\
    \ = 0\n    var wells = grid\n    for _ in 0..<rows {\n        for col in 0..<cols\
    \ {\n            if wells[0][col] == 1 {\n                wells[0][col] = 0\n\
    \                result += 1\n            }\n        }\n        wells = wells.dropFirst().map\
    \ { $0 }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpw4is69aa/tmpw4is69aa.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adec55e1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adec52d8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adec52d8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adec52d77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw4is69aa                        0x000055da66e6ba67 <unavailable> + 6759

    5    libc.so.6                          0x00002adec57cd460 __libc_start_main +
    245

    6    tmpw4is69aa                        0x000055da66e6b429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1659824406
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    while !grid.isEmpty {\n\
    \        var row = grid.removeFirst()\n        while !row.isEmpty {\n        \
    \    var bucket = capacity\n            while bucket > 0 && !row.isEmpty {\n \
    \               let water = row.removeFirst()\n                if water == 1 {\n\
    \                    bucket -= 1\n                }\n            }\n         \
    \   count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpo1ieer3q/tmpo1ieer3q.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac842662c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac842359b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac842359988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac8423587b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo1ieer3q                        0x00005594ff982516 <unavailable> + 5398

    5    libc.so.6                          0x00002ac84284e460 __libc_start_main +
    245

    6    tmpo1ieer3q                        0x00005594ff9820a9 <unavailable> + 4265

    '
  stdout: ''
  timestamp: 1659824406
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    var row = 0\n    while\
    \ row < grid.count {\n        var col = 0\n        while col < grid[row].count\
    \ {\n            if grid[row][col] == 1 {\n                count += 1\n      \
    \          fill(grid: &grid, row: row, col: col, capacity: capacity)\n       \
    \     }\n            col += 1\n        }\n        row += 1\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpjs9d0k2x.swift:32:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, row: row, col: col, capacity: capacity)\n     \
    \           ^~~~\n"
  stdout: ''
  timestamp: 1659824406
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    // TODO: Implement\n    return 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpc95390ld/tmpc95390ld.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b264a9d7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b264a6ceb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b264a6ce988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b264a6cd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc95390ld                        0x0000559c117783d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b264abc3460 __libc_start_main +
    245

    6    tmpc95390ld                        0x0000559c11777f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824406
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, i: i, j: j, capacity:\
    \ capacity)\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmporchcpto.swift:30:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824404
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    while true {\n       \
    \ var has_water = false\n        for i in 0..<grid.count {\n            for j\
    \ in 0..<grid[i].count {\n                if grid[i][j] == 1 {\n             \
    \       has_water = true\n                    break\n                }\n     \
    \       }\n            if has_water {\n                break\n            }\n\
    \        }\n        if !has_water {\n            break\n        }\n        for\
    \ i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n          \
    \      if grid[i][j] == 1 {\n                    grid[i][j] = 0\n            \
    \        if i > 0 {\n                        grid[i - 1][j] = 1\n            \
    \        }\n                    if i < grid.count - 1 {\n                    \
    \    grid[i + 1][j] = 1\n                    }\n                    if j > 0 {\n\
    \                        grid[i][j - 1] = 1\n                    }\n         \
    \           if j < grid[i].count - 1 {\n                        grid[i][j + 1]\
    \ = 1\n                    }\n                }\n            }\n        }\n  \
    \      count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824411
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    let rows = grid.count\n    let cols = grid[0].count\n    var buckets\
    \ = Array(repeating: 0, count: cols)\n    var count = 0\n    for i in 0..<rows\
    \ {\n        for j in 0..<cols {\n            if grid[i][j] == 1 {\n         \
    \       if buckets[j] < capacity {\n                    buckets[j] += 1\n    \
    \                count += 1\n                }\n            }\n        }\n   \
    \ }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp0dubf3w5/tmp0dubf3w5.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3addf74c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3addc6bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3addc6b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3addc6a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0dubf3w5                        0x0000561972bf4716 <unavailable> + 5910

    5    libc.so.6                          0x00002b3ade160460 __libc_start_main +
    245

    6    tmp0dubf3w5                        0x0000561972bf42a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824406
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var water = 0\n    var count = 0\n    for row in grid {\n    \
    \    for cell in row {\n            if cell == 1 {\n                water += 1\n\
    \            }\n        }\n    }\n    while water > 0 {\n        water -= capacity\n\
    \        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpmbhfb1cd/tmpmbhfb1cd.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b875abb2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b875a8a9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b875a8a9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b875a8a87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmbhfb1cd                        0x000055d63d10fb44 <unavailable> + 6980

    5    libc.so.6                          0x00002b875ad9e460 __libc_start_main +
    245

    6    tmpmbhfb1cd                        0x000055d63d10f0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824406
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    while true {\n       \
    \ var max = 0\n        var max_i = 0\n        for i in 0..<grid.count {\n    \
    \        let sum = grid[i].reduce(0, +)\n            if sum > max {\n        \
    \        max = sum\n                max_i = i\n            }\n        }\n    \
    \    if max == 0 {\n            break\n        }\n        for j in 0..<grid[max_i].count\
    \ {\n            if grid[max_i][j] == 1 {\n                grid[max_i][j] = 0\n\
    \                count += 1\n            }\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpz67trv7n/tmpz67trv7n.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8b6f9abc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8b6f6a2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8b6f6a2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8b6f6a17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz67trv7n                        0x000055acf6063947 <unavailable> + 6471

    5    libc.so.6                          0x00002b8b6fb97460 __libc_start_main +
    245

    6    tmpz67trv7n                        0x000055acf6063309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1659824406
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                for k in i..<grid.count {\n     \
    \               if grid[k][j] == 1 {\n                        grid[k][j] = 0\n\
    \                    } else {\n                        break\n               \
    \     }\n                }\n            }\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpk4znrc_3/tmpk4znrc_3.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6d242eac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6d23fe1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6d23fe1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6d23fe07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk4znrc_3                        0x000056453bdf0706 <unavailable> + 5894

    5    libc.so.6                          0x00002b6d244d6460 __libc_start_main +
    245

    6    tmpk4znrc_3                        0x000056453bdf0299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824404
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    let rows = grid.count\n    let cols = grid[0].count\n    var maxFill\
    \ = 0\n    for i in 0..<rows {\n        for j in 0..<cols {\n            if grid[i][j]\
    \ == 1 {\n                maxFill += capacity\n            }\n        }\n    }\n\
    \    return maxFill\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp_rvwe8bh/tmp_rvwe8bh.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aff93c63c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aff9395ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aff9395a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aff939597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_rvwe8bh                        0x0000558e0a0d3827 <unavailable> + 6183

    5    libc.so.6                          0x00002aff93e4f460 __libc_start_main +
    245

    6    tmp_rvwe8bh                        0x0000558e0a0d31e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824406
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    while true {\n       \
    \ var filled = false\n        for i in 0..<grid.count {\n            for j in\
    \ 0..<grid[i].count {\n                if grid[i][j] == 1 {\n                \
    \    filled = true\n                    grid[i][j] = 0\n                    if\
    \ i > 0 {\n                        grid[i - 1][j] = min(grid[i - 1][j] + 1, capacity)\n\
    \                    }\n                    if i < grid.count - 1 {\n        \
    \                grid[i + 1][j] = min(grid[i + 1][j] + 1, capacity)\n        \
    \            }\n                    if j > 0 {\n                        grid[i][j\
    \ - 1] = min(grid[i][j - 1] + 1, capacity)\n                    }\n          \
    \          if j < grid[i].count - 1 {\n                        grid[i][j + 1]\
    \ = min(grid[i][j + 1] + 1, capacity)\n                    }\n               \
    \ }\n            }\n        }\n        if !filled {\n            break\n     \
    \   }\n        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var max_water = 0\n    for row in grid {\n\
    \        max_water = 0\n        for well in row {\n            if well == 1 {\n\
    \                max_water += 1\n            }\n        }\n        result += max_water\
    \ / capacity\n        if max_water % capacity != 0 {\n            result += 1\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824406
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                grid[i][j] = 0\n                count += 1\n                for\
    \ k in 0..<capacity {\n                    if i + k < grid.count && grid[i + k][j]\
    \ == 1 {\n                        grid[i + k][j] = 0\n                    }\n\
    \                }\n            }\n        }\n    }\n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpqq7jit3d/tmpqq7jit3d.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af98c80cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af98c503b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af98c503988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af98c5027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqq7jit3d                        0x000055dff986d8d7 <unavailable> + 6359

    5    libc.so.6                          0x00002af98c9f8460 __libc_start_main +
    245

    6    tmpqq7jit3d                        0x000055dff986d299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824407
