language: swift
name: HumanEval_123_get_odd_collatz
results:
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var odd_collatz\
    \ = [Int]()\n    while collatz.last != 1 {\n        if collatz.last! % 2 == 0\
    \ {\n            collatz.append(collatz.last! / 2)\n        } else {\n       \
    \     collatz.append(collatz.last! * 3 + 1)\n        }\n    }\n    for i in collatz\
    \ {\n        if i % 2 != 0 {\n            odd_collatz.append(i)\n        }\n \
    \   }\n    return odd_collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp56htrhkz/tmp56htrhkz.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab5074a7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab50719eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab50719e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab50719d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp56htrhkz                        0x00005653310736ea <unavailable> + 5866

    5    libc.so.6                          0x00002ab507693460 __libc_start_main +
    245

    6    tmp56htrhkz                        0x0000565331073319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num > 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : 3 * num + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpo4e2c071/tmpo4e2c071.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2e8515fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2e84e56b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2e84e56988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2e84e557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo4e2c071                        0x000055fe499dd4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b2e8534b460 __libc_start_main +
    245

    6    tmpo4e2c071                        0x000055fe499dd119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var n = n\n \
    \   while n != 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else\
    \ {\n            n = 3 * n + 1\n        }\n        collatz.append(n)\n    }\n\
    \    return collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: Exception
  stderr: 'tmp9bz1ze3x/tmp9bz1ze3x.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2b45676c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2b4536db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2b4536d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2b4536c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9bz1ze3x                        0x000055804a18155a <unavailable> + 5466

    5    libc.so.6                          0x00002b2b45862460 __libc_start_main +
    245

    6    tmp9bz1ze3x                        0x000055804a181189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var odd = [Int]()\n\
    \    var i = 0\n    while i < collatz.count {\n        if collatz[i] == 1 {\n\
    \            break\n        }\n        if collatz[i] % 2 == 1 {\n            odd.append(collatz[i])\n\
    \        }\n        if collatz[i] % 2 == 0 {\n            collatz.append(collatz[i]\
    \ / 2)\n        } else {\n            collatz.append(collatz[i] * 3 + 1)\n   \
    \     }\n        i += 1\n    }\n    odd.append(1)\n    return odd\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpebc5t2sj/tmpebc5t2sj.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2057109c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2056e00b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2056e00988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2056dff7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpebc5t2sj                        0x0000561cbb05858a <unavailable> + 5514

    5    libc.so.6                          0x00002b20572f5460 __libc_start_main +
    245

    6    tmpebc5t2sj                        0x0000561cbb0581b9 <unavailable> + 4537

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var current =\
    \ n\n    while current != 1 {\n        if current % 2 == 0 {\n            current\
    \ /= 2\n        } else {\n            current = current * 3 + 1\n        }\n \
    \       collatz.append(current)\n    }\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmplfekvsnc/tmplfekvsnc.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3c425c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3c422bdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3c422bd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3c422bc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplfekvsnc                        0x00005634d86fd55a <unavailable> + 5466

    5    libc.so.6                          0x00002b3c427b2460 __libc_start_main +
    245

    6    tmplfekvsnc                        0x00005634d86fd189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num > 1 {\n        collatz.append(num)\n        if num % 2 == 0\
    \ {\n            num /= 2\n        } else {\n            num = num * 3 + 1\n \
    \       }\n    }\n    collatz.append(1)\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmptigafa5w/tmptigafa5w.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afd98055c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afd97d4cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afd97d4c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afd97d4b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptigafa5w                        0x000055cb2c5565aa <unavailable> + 5546

    5    libc.so.6                          0x00002afd98241460 __libc_start_main +
    245

    6    tmptigafa5w                        0x000055cb2c5561d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            result.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpc4m35vih/tmpc4m35vih.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b403a505c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b403a1fcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b403a1fc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b403a1fb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc4m35vih                        0x0000560e16ed24ea <unavailable> + 5354

    5    libc.so.6                          0x00002b403a6f1460 __libc_start_main +
    245

    6    tmpc4m35vih                        0x0000560e16ed2119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var odd_collatz\
    \ = [Int]()\n    var i = 0\n    while collatz[i] != 1 {\n        if collatz[i]\
    \ % 2 == 0 {\n            collatz.append(collatz[i] / 2)\n        } else {\n \
    \           collatz.append(collatz[i] * 3 + 1)\n        }\n        i += 1\n  \
    \  }\n    for i in collatz {\n        if i % 2 != 0 {\n            odd_collatz.append(i)\n\
    \        }\n    }\n    return odd_collatz\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: Exception
  stderr: 'tmpa6vieng1/tmpa6vieng1.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aea7a421c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aea7a118b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aea7a118988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aea7a1177b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa6vieng1                        0x0000558fba10a69a <unavailable> + 5786

    5    libc.so.6                          0x00002aea7a60d460 __libc_start_main +
    245

    6    tmpa6vieng1                        0x0000558fba10a2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var n = n\n\
    \    while n > 1 {\n        if n % 2 == 1 {\n            collatz.append(n)\n \
    \       }\n        n = n % 2 == 0 ? n / 2 : 3 * n + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp7m32toad/tmp7m32toad.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af99d782c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af99d479b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af99d479988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af99d4787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7m32toad                        0x000055b96ee0c4ea <unavailable> + 5354

    5    libc.so.6                          0x00002af99d96e460 __libc_start_main +
    245

    6    tmp7m32toad                        0x000055b96ee0c119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num > 1 {\n        collatz.append(num)\n        if num % 2 == 0\
    \ {\n            num /= 2\n        } else {\n            num = num * 3 + 1\n \
    \       }\n    }\n    collatz.append(1)\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmptigafa5w/tmptigafa5w.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afd98055c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afd97d4cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afd97d4c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afd97d4b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptigafa5w                        0x000055cb2c5565aa <unavailable> + 5546

    5    libc.so.6                          0x00002afd98241460 __libc_start_main +
    245

    6    tmptigafa5w                        0x000055cb2c5561d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz_sequence: [Int] = [n]\n\
    \    var current_number = n\n    while current_number != 1 {\n        if current_number\
    \ % 2 == 0 {\n            current_number /= 2\n        } else {\n            current_number\
    \ = current_number * 3 + 1\n        }\n        collatz_sequence.append(current_number)\n\
    \    }\n    return collatz_sequence.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: Exception
  stderr: 'tmpq4a1q5fr/tmpq4a1q5fr.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adffa3c8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adffa0bfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adffa0bf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adffa0be7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq4a1q5fr                        0x00005564ab02c55a <unavailable> + 5466

    5    libc.so.6                          0x00002adffa5b4460 __libc_start_main +
    245

    6    tmpq4a1q5fr                        0x00005564ab02c189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var num = n\n\
    \    while num != 1 {\n        if num % 2 == 0 {\n            num /= 2\n     \
    \   } else {\n            num = num * 3 + 1\n        }\n        collatz.append(num)\n\
    \    }\n    return collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: Exception
  stderr: 'tmpdvtmwzmf/tmpdvtmwzmf.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2ebf95ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2ebf651b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2ebf651988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2ebf6507b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdvtmwzmf                        0x0000563db608155a <unavailable> + 5466

    5    libc.so.6                          0x00002b2ebfb46460 __libc_start_main +
    245

    6    tmpdvtmwzmf                        0x0000563db6081189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num > 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp8hm81tj5/tmp8hm81tj5.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b589e748c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b589e43fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b589e43f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b589e43e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8hm81tj5                        0x000055b2fdfe54ea <unavailable> + 5354

    5    libc.so.6                          0x00002b589e934460 __libc_start_main +
    245

    6    tmp8hm81tj5                        0x000055b2fdfe5119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        collatz.append(num)\n        if num % 2 ==\
    \ 0 {\n            num /= 2\n        } else {\n            num = 3 * num + 1\n\
    \        }\n    }\n    collatz.append(1)\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl1dd2fg3/tmpl1dd2fg3.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afed79e7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afed76deb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afed76de988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afed76dd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl1dd2fg3                        0x0000559dc185d5aa <unavailable> + 5546

    5    libc.so.6                          0x00002afed7bd3460 __libc_start_main +
    245

    6    tmpl1dd2fg3                        0x0000559dc185d1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            result.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpc4m35vih/tmpc4m35vih.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b403a505c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b403a1fcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b403a1fc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b403a1fb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc4m35vih                        0x0000560e16ed24ea <unavailable> + 5354

    5    libc.so.6                          0x00002b403a6f1460 __libc_start_main +
    245

    6    tmpc4m35vih                        0x0000560e16ed2119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num > 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp8hm81tj5/tmp8hm81tj5.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b589e748c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b589e43fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b589e43f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b589e43e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8hm81tj5                        0x000055b2fdfe54ea <unavailable> + 5354

    5    libc.so.6                          0x00002b589e934460 __libc_start_main +
    245

    6    tmp8hm81tj5                        0x000055b2fdfe5119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            result.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpc4m35vih/tmpc4m35vih.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b403a505c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b403a1fcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b403a1fc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b403a1fb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc4m35vih                        0x0000560e16ed24ea <unavailable> + 5354

    5    libc.so.6                          0x00002b403a6f1460 __libc_start_main +
    245

    6    tmpc4m35vih                        0x0000560e16ed2119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            result.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpc4m35vih/tmpc4m35vih.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b403a505c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b403a1fcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b403a1fc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b403a1fb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc4m35vih                        0x0000560e16ed24ea <unavailable> + 5354

    5    libc.so.6                          0x00002b403a6f1460 __libc_start_main +
    245

    6    tmpc4m35vih                        0x0000560e16ed2119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var odd_collatz\
    \ = [Int]()\n    while collatz.last != 1 {\n        if collatz.last! % 2 == 0\
    \ {\n            collatz.append(collatz.last! / 2)\n        } else {\n       \
    \     collatz.append(collatz.last! * 3 + 1)\n        }\n    }\n    for i in collatz\
    \ {\n        if i % 2 != 0 {\n            odd_collatz.append(i)\n        }\n \
    \   }\n    return odd_collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp56htrhkz/tmp56htrhkz.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab5074a7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab50719eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab50719e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab50719d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp56htrhkz                        0x00005653310736ea <unavailable> + 5866

    5    libc.so.6                          0x00002ab507693460 __libc_start_main +
    245

    6    tmp56htrhkz                        0x0000565331073319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var current\
    \ = n\n    while current != 1 {\n        if current % 2 == 1 {\n            collatz.append(current)\n\
    \        }\n        current = current % 2 == 0 ? current / 2 : current * 3 + 1\n\
    \    }\n    collatz.append(1)\n    return collatz\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: Exception
  stderr: 'tmprw51356p/tmprw51356p.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4d8c191c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4d8be88b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4d8be88988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4d8be877b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprw51356p                        0x00005654a7f8d4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b4d8c37d460 __libc_start_main +
    245

    6    tmprw51356p                        0x00005654a7f8d119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        collatz.append(num)\n        if num % 2 ==\
    \ 0 {\n            num /= 2\n        } else {\n            num = 3 * num + 1\n\
    \        }\n    }\n    collatz.append(1)\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl1dd2fg3/tmpl1dd2fg3.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afed79e7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afed76deb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afed76de988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afed76dd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl1dd2fg3                        0x0000559dc185d5aa <unavailable> + 5546

    5    libc.so.6                          0x00002afed7bd3460 __libc_start_main +
    245

    6    tmpl1dd2fg3                        0x0000559dc185d1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var number\
    \ = n\n    while number != 1 {\n        collatz.append(number)\n        if number\
    \ % 2 == 0 {\n            number /= 2\n        } else {\n            number =\
    \ 3 * number + 1\n        }\n    }\n    collatz.append(1)\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp_prf0650/tmp_prf0650.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b39d9b00c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b39d97f7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b39d97f7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b39d97f67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_prf0650                        0x00005558c8df95aa <unavailable> + 5546

    5    libc.so.6                          0x00002b39d9cec460 __libc_start_main +
    245

    6    tmp_prf0650                        0x00005558c8df91d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            result.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpc4m35vih/tmpc4m35vih.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b403a505c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b403a1fcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b403a1fc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b403a1fb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc4m35vih                        0x0000560e16ed24ea <unavailable> + 5354

    5    libc.so.6                          0x00002b403a6f1460 __libc_start_main +
    245

    6    tmpc4m35vih                        0x0000560e16ed2119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var current\
    \ = n\n    while current != 1 {\n        if current % 2 == 1 {\n            collatz.append(current)\n\
    \        }\n        current = current % 2 == 0 ? current / 2 : current * 3 + 1\n\
    \    }\n    collatz.append(1)\n    return collatz\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: Exception
  stderr: 'tmprw51356p/tmprw51356p.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4d8c191c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4d8be88b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4d8be88988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4d8be877b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprw51356p                        0x00005654a7f8d4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b4d8c37d460 __libc_start_main +
    245

    6    tmprw51356p                        0x00005654a7f8d119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var num =\
    \ n\n    while num > 1 {\n        if num % 2 == 1 {\n            result.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp684un4ro/tmp684un4ro.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5127920c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5127617b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5127617988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b51276167b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp684un4ro                        0x000055b3adcad4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b5127b0c460 __libc_start_main +
    245

    6    tmp684un4ro                        0x000055b3adcad119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result: [Int] = []\n    var current:\
    \ Int = n\n    while current > 1 {\n        if current % 2 == 1 {\n          \
    \  result.append(current)\n        }\n        current = current % 2 == 0 ? current\
    \ / 2 : current * 3 + 1\n    }\n    result.append(1)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpj1085wwu/tmpj1085wwu.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002add827fbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002add824f2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002add824f2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002add824f17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj1085wwu                        0x0000561c4fcce48a <unavailable> + 5258

    5    libc.so.6                          0x00002add829e7460 __libc_start_main +
    245

    6    tmpj1085wwu                        0x0000561c4fcce0b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        collatz.append(num)\n        if num % 2 ==\
    \ 0 {\n            num /= 2\n        } else {\n            num = num * 3 + 1\n\
    \        }\n    }\n    collatz.append(1)\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl41rv_yw/tmpl41rv_yw.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0e51caec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0e519a5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0e519a5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0e519a47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl41rv_yw                        0x000055eeb4c475aa <unavailable> + 5546

    5    libc.so.6                          0x00002b0e51e9a460 __libc_start_main +
    245

    6    tmpl41rv_yw                        0x000055eeb4c471d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: 1
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    while n != 1\
    \ {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n         \
    \   n = 3 * n + 1\n        }\n        collatz.append(n)\n    }\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: SyntaxError
  stderr: "/tmp/tmpuzuxmb3e.swift:19:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= 2\n            ~ ^\n/tmp/tmpuzuxmb3e.swift:21:13:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n            n = 3 *\
    \ n + 1\n            ^\n"
  stdout: ''
  timestamp: 1659824746
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz_sequence = [n]\n    var\
    \ current_number = n\n    while current_number != 1 {\n        if current_number\
    \ % 2 == 0 {\n            current_number /= 2\n        } else {\n            current_number\
    \ = 3 * current_number + 1\n        }\n        collatz_sequence.append(current_number)\n\
    \    }\n    return collatz_sequence.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: Exception
  stderr: 'tmpx9aq4yek/tmpx9aq4yek.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9da2660c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9da2357b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9da2357988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9da23567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx9aq4yek                        0x000055aa5cffc55a <unavailable> + 5466

    5    libc.so.6                          0x00002b9da284c460 __libc_start_main +
    245

    6    tmpx9aq4yek                        0x000055aa5cffc189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        collatz.append(num)\n        if num % 2 ==\
    \ 0 {\n            num /= 2\n        } else {\n            num = num * 3 + 1\n\
    \        }\n    }\n    collatz.append(1)\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl41rv_yw/tmpl41rv_yw.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0e51caec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0e519a5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0e519a5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0e519a47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl41rv_yw                        0x000055eeb4c475aa <unavailable> + 5546

    5    libc.so.6                          0x00002b0e51e9a460 __libc_start_main +
    245

    6    tmpl41rv_yw                        0x000055eeb4c471d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        collatz.append(num)\n        if num % 2 ==\
    \ 0 {\n            num /= 2\n        } else {\n            num = num * 3 + 1\n\
    \        }\n    }\n    collatz.append(1)\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl41rv_yw/tmpl41rv_yw.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0e51caec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0e519a5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0e519a5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0e519a47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl41rv_yw                        0x000055eeb4c475aa <unavailable> + 5546

    5    libc.so.6                          0x00002b0e51e9a460 __libc_start_main +
    245

    6    tmpl41rv_yw                        0x000055eeb4c471d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: 1
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    while n != 1\
    \ {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n         \
    \   n = 3 * n + 1\n        }\n        collatz.append(n)\n    }\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: SyntaxError
  stderr: "/tmp/tmpuzuxmb3e.swift:19:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= 2\n            ~ ^\n/tmp/tmpuzuxmb3e.swift:21:13:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n            n = 3 *\
    \ n + 1\n            ^\n"
  stdout: ''
  timestamp: 1659824746
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var current =\
    \ n\n    while current != 1 {\n        if current % 2 == 0 {\n            current\
    \ /= 2\n        } else {\n            current = current * 3 + 1\n        }\n \
    \       collatz.append(current)\n    }\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmplfekvsnc/tmplfekvsnc.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3c425c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3c422bdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3c422bd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3c422bc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplfekvsnc                        0x00005634d86fd55a <unavailable> + 5466

    5    libc.so.6                          0x00002b3c427b2460 __libc_start_main +
    245

    6    tmplfekvsnc                        0x00005634d86fd189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var current =\
    \ n\n    while current != 1 {\n        if current % 2 == 0 {\n            current\
    \ /= 2\n        } else {\n            current = current * 3 + 1\n        }\n \
    \       collatz.append(current)\n    }\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmplfekvsnc/tmplfekvsnc.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3c425c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3c422bdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3c422bd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3c422bc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplfekvsnc                        0x00005634d86fd55a <unavailable> + 5466

    5    libc.so.6                          0x00002b3c427b2460 __libc_start_main +
    245

    6    tmplfekvsnc                        0x00005634d86fd189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num > 1 {\n        collatz.append(num)\n        if num % 2 == 0\
    \ {\n            num /= 2\n        } else {\n            num = 3 * num + 1\n \
    \       }\n    }\n    collatz.append(1)\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpcuh__53b/tmpcuh__53b.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad632492c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad632189b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad632189988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad6321887b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcuh__53b                        0x000056146ad7c5aa <unavailable> + 5546

    5    libc.so.6                          0x00002ad63267e460 __libc_start_main +
    245

    6    tmpcuh__53b                        0x000056146ad7c1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var num =\
    \ n\n    while num > 1 {\n        if num % 2 == 1 {\n            result.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp684un4ro/tmp684un4ro.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5127920c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5127617b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5127617988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b51276167b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp684un4ro                        0x000055b3adcad4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b5127b0c460 __libc_start_main +
    245

    6    tmp684un4ro                        0x000055b3adcad119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num > 1 {\n        collatz.append(num)\n        if num % 2 == 0\
    \ {\n            num /= 2\n        } else {\n            num = num * 3 + 1\n \
    \       }\n    }\n    collatz.append(1)\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmptigafa5w/tmptigafa5w.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afd98055c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afd97d4cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afd97d4c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afd97d4b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptigafa5w                        0x000055cb2c5565aa <unavailable> + 5546

    5    libc.so.6                          0x00002afd98241460 __libc_start_main +
    245

    6    tmptigafa5w                        0x000055cb2c5561d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var n = n\n \
    \   while n != 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else\
    \ {\n            n = 3 * n + 1\n        }\n        collatz.append(n)\n    }\n\
    \    return collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: Exception
  stderr: 'tmp9bz1ze3x/tmp9bz1ze3x.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2b45676c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2b4536db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2b4536d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2b4536c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9bz1ze3x                        0x000055804a18155a <unavailable> + 5466

    5    libc.so.6                          0x00002b2b45862460 __libc_start_main +
    245

    6    tmp9bz1ze3x                        0x000055804a181189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            result.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpc4m35vih/tmpc4m35vih.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b403a505c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b403a1fcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b403a1fc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b403a1fb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc4m35vih                        0x0000560e16ed24ea <unavailable> + 5354

    5    libc.so.6                          0x00002b403a6f1460 __libc_start_main +
    245

    6    tmpc4m35vih                        0x0000560e16ed2119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var i = n\n\
    \    while i != 1 {\n        if i % 2 != 0 {\n            collatz.append(i)\n\
    \        }\n        i = i % 2 == 0 ? i / 2 : 3 * i + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpf2tip3c8/tmpf2tip3c8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acbe573cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acbe5433b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acbe5433988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acbe54327b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf2tip3c8                        0x00005587a5cea4ea <unavailable> + 5354

    5    libc.so.6                          0x00002acbe5928460 __libc_start_main +
    245

    6    tmpf2tip3c8                        0x00005587a5cea119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result: [Int] = []\n    var num\
    \ = n\n    while num != 1 {\n        if num % 2 == 1 {\n            result.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpa3ghmxoq/tmpa3ghmxoq.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9ba6c22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9ba6919b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9ba6919988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9ba69187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa3ghmxoq                        0x0000555a0761a48a <unavailable> + 5258

    5    libc.so.6                          0x00002b9ba6e0e460 __libc_start_main +
    245

    6    tmpa3ghmxoq                        0x0000555a0761a0b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result: [Int] = []\n    var num\
    \ = n\n    while num != 1 {\n        if num % 2 == 1 {\n            result.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpa3ghmxoq/tmpa3ghmxoq.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9ba6c22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9ba6919b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9ba6919988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9ba69187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa3ghmxoq                        0x0000555a0761a48a <unavailable> + 5258

    5    libc.so.6                          0x00002b9ba6e0e460 __libc_start_main +
    245

    6    tmpa3ghmxoq                        0x0000555a0761a0b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        collatz.append(num)\n        if num % 2 ==\
    \ 0 {\n            num /= 2\n        } else {\n            num = 3 * num + 1\n\
    \        }\n    }\n    collatz.append(1)\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl1dd2fg3/tmpl1dd2fg3.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afed79e7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afed76deb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afed76de988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afed76dd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl1dd2fg3                        0x0000559dc185d5aa <unavailable> + 5546

    5    libc.so.6                          0x00002afed7bd3460 __libc_start_main +
    245

    6    tmpl1dd2fg3                        0x0000559dc185d1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            result.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpc4m35vih/tmpc4m35vih.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b403a505c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b403a1fcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b403a1fc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b403a1fb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc4m35vih                        0x0000560e16ed24ea <unavailable> + 5354

    5    libc.so.6                          0x00002b403a6f1460 __libc_start_main +
    245

    6    tmpc4m35vih                        0x0000560e16ed2119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            result.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpc4m35vih/tmpc4m35vih.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b403a505c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b403a1fcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b403a1fc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b403a1fb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc4m35vih                        0x0000560e16ed24ea <unavailable> + 5354

    5    libc.so.6                          0x00002b403a6f1460 __libc_start_main +
    245

    6    tmpc4m35vih                        0x0000560e16ed2119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var i = n\n \
    \   while i != 1 {\n        if i % 2 == 0 {\n            i /= 2\n        } else\
    \ {\n            i = 3 * i + 1\n        }\n        collatz.append(i)\n    }\n\
    \    return collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: Exception
  stderr: 'tmpxh971g2q/tmpxh971g2q.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0d0f30fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0d0f006b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0d0f006988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0d0f0057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxh971g2q                        0x0000561e375db55a <unavailable> + 5466

    5    libc.so.6                          0x00002b0d0f4fb460 __libc_start_main +
    245

    6    tmpxh971g2q                        0x0000561e375db189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var odd = [Int]()\n\
    \    var current = n\n    while current != 1 {\n        if current % 2 == 0 {\n\
    \            current /= 2\n        } else {\n            current = 3 * current\
    \ + 1\n        }\n        collatz.append(current)\n    }\n    for i in collatz\
    \ {\n        if i % 2 != 0 {\n            odd.append(i)\n        }\n    }\n  \
    \  return odd\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp3rzxulur/tmp3rzxulur.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b41f0bc8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b41f08bfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b41f08bf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b41f08be7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3rzxulur                        0x0000560dbcc1464a <unavailable> + 5706

    5    libc.so.6                          0x00002b41f0db4460 __libc_start_main +
    245

    6    tmp3rzxulur                        0x0000560dbcc14279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        collatz.append(num)\n        if num % 2 ==\
    \ 0 {\n            num /= 2\n        } else {\n            num = num * 3 + 1\n\
    \        }\n    }\n    collatz.append(1)\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl41rv_yw/tmpl41rv_yw.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0e51caec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0e519a5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0e519a5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0e519a47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl41rv_yw                        0x000055eeb4c475aa <unavailable> + 5546

    5    libc.so.6                          0x00002b0e51e9a460 __libc_start_main +
    245

    6    tmpl41rv_yw                        0x000055eeb4c471d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num > 1 {\n        collatz.append(num)\n        if num % 2 == 0\
    \ {\n            num /= 2\n        } else {\n            num = 3 * num + 1\n \
    \       }\n    }\n    collatz.append(1)\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpcuh__53b/tmpcuh__53b.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad632492c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad632189b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad632189988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad6321887b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcuh__53b                        0x000056146ad7c5aa <unavailable> + 5546

    5    libc.so.6                          0x00002ad63267e460 __libc_start_main +
    245

    6    tmpcuh__53b                        0x000056146ad7c1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var current =\
    \ n\n    while current != 1 {\n        if current % 2 == 0 {\n            current\
    \ /= 2\n        } else {\n            current = current * 3 + 1\n        }\n \
    \       collatz.append(current)\n    }\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmplfekvsnc/tmplfekvsnc.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3c425c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3c422bdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3c422bd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3c422bc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplfekvsnc                        0x00005634d86fd55a <unavailable> + 5466

    5    libc.so.6                          0x00002b3c427b2460 __libc_start_main +
    245

    6    tmplfekvsnc                        0x00005634d86fd189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: 1
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    while n != 1\
    \ {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n         \
    \   n = 3 * n + 1\n        }\n        collatz.append(n)\n    }\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: SyntaxError
  stderr: "/tmp/tmpuzuxmb3e.swift:19:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= 2\n            ~ ^\n/tmp/tmpuzuxmb3e.swift:21:13:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n            n = 3 *\
    \ n + 1\n            ^\n"
  stdout: ''
  timestamp: 1659824746
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var i = n\n\
    \    while i > 1 {\n        if i % 2 == 1 {\n            result.append(i)\n  \
    \      }\n        i = i % 2 == 0 ? i / 2 : 3 * i + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp35bd9jvs/tmp35bd9jvs.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b344cc99c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b344c990b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b344c990988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b344c98f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp35bd9jvs                        0x00005605a3d7e4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b344ce85460 __libc_start_main +
    245

    6    tmp35bd9jvs                        0x00005605a3d7e119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var current =\
    \ n\n    while current != 1 {\n        if current % 2 == 0 {\n            current\
    \ /= 2\n        } else {\n            current = current * 3 + 1\n        }\n \
    \       collatz.append(current)\n    }\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmplfekvsnc/tmplfekvsnc.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3c425c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3c422bdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3c422bd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3c422bc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplfekvsnc                        0x00005634d86fd55a <unavailable> + 5466

    5    libc.so.6                          0x00002b3c427b2460 __libc_start_main +
    245

    6    tmplfekvsnc                        0x00005634d86fd189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var current\
    \ = n\n    while current != 1 {\n        if current % 2 == 1 {\n            collatz.append(current)\n\
    \        }\n        current = current % 2 == 0 ? current / 2 : current * 3 + 1\n\
    \    }\n    collatz.append(1)\n    return collatz\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: Exception
  stderr: 'tmprw51356p/tmprw51356p.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4d8c191c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4d8be88b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4d8be88988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4d8be877b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprw51356p                        0x00005654a7f8d4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b4d8c37d460 __libc_start_main +
    245

    6    tmprw51356p                        0x00005654a7f8d119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            result.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpc4m35vih/tmpc4m35vih.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b403a505c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b403a1fcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b403a1fc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b403a1fb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc4m35vih                        0x0000560e16ed24ea <unavailable> + 5354

    5    libc.so.6                          0x00002b403a6f1460 __libc_start_main +
    245

    6    tmpc4m35vih                        0x0000560e16ed2119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: 1
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    while n != 1\
    \ {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n         \
    \   n = n * 3 + 1\n        }\n        collatz.append(n)\n    }\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: SyntaxError
  stderr: "/tmp/tmp7snck1sp.swift:19:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= 2\n            ~ ^\n/tmp/tmp7snck1sp.swift:21:13:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n            n = n *\
    \ 3 + 1\n            ^\n"
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        collatz.append(num)\n        if num % 2 ==\
    \ 0 {\n            num /= 2\n        } else {\n            num = 3 * num + 1\n\
    \        }\n    }\n    collatz.append(1)\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl1dd2fg3/tmpl1dd2fg3.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afed79e7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afed76deb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afed76de988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afed76dd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl1dd2fg3                        0x0000559dc185d5aa <unavailable> + 5546

    5    libc.so.6                          0x00002afed7bd3460 __libc_start_main +
    245

    6    tmpl1dd2fg3                        0x0000559dc185d1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var odd_collatz\
    \ = [Int]()\n    while collatz.last != 1 {\n        if collatz.last! % 2 == 0\
    \ {\n            collatz.append(collatz.last! / 2)\n        } else {\n       \
    \     collatz.append(collatz.last! * 3 + 1)\n        }\n    }\n    for i in collatz\
    \ {\n        if i % 2 != 0 {\n            odd_collatz.append(i)\n        }\n \
    \   }\n    return odd_collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp56htrhkz/tmp56htrhkz.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab5074a7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab50719eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab50719e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab50719d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp56htrhkz                        0x00005653310736ea <unavailable> + 5866

    5    libc.so.6                          0x00002ab507693460 __libc_start_main +
    245

    6    tmp56htrhkz                        0x0000565331073319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            result.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpc4m35vih/tmpc4m35vih.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b403a505c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b403a1fcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b403a1fc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b403a1fb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc4m35vih                        0x0000560e16ed24ea <unavailable> + 5354

    5    libc.so.6                          0x00002b403a6f1460 __libc_start_main +
    245

    6    tmpc4m35vih                        0x0000560e16ed2119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            result.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpc4m35vih/tmpc4m35vih.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b403a505c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b403a1fcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b403a1fc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b403a1fb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc4m35vih                        0x0000560e16ed24ea <unavailable> + 5354

    5    libc.so.6                          0x00002b403a6f1460 __libc_start_main +
    245

    6    tmpc4m35vih                        0x0000560e16ed2119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var current\
    \ = n\n    while current > 1 {\n        if current % 2 == 1 {\n            result.append(current)\n\
    \        }\n        current = current % 2 == 0 ? current / 2 : current * 3 + 1\n\
    \    }\n    result.append(1)\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: Exception
  stderr: 'tmpadxjgr39/tmpadxjgr39.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b57b3533c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b57b322ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b57b322a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b57b32297b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpadxjgr39                        0x000055665430a4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b57b371f460 __libc_start_main +
    245

    6    tmpadxjgr39                        0x000055665430a119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var i = n\n \
    \   while i != 1 {\n        if i % 2 == 0 {\n            i /= 2\n        } else\
    \ {\n            i = 3 * i + 1\n        }\n        collatz.append(i)\n    }\n\
    \    return collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: Exception
  stderr: 'tmpxh971g2q/tmpxh971g2q.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0d0f30fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0d0f006b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0d0f006988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0d0f0057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxh971g2q                        0x0000561e375db55a <unavailable> + 5466

    5    libc.so.6                          0x00002b0d0f4fb460 __libc_start_main +
    245

    6    tmpxh971g2q                        0x0000561e375db189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            result.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpc4m35vih/tmpc4m35vih.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b403a505c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b403a1fcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b403a1fc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b403a1fb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc4m35vih                        0x0000560e16ed24ea <unavailable> + 5354

    5    libc.so.6                          0x00002b403a6f1460 __libc_start_main +
    245

    6    tmpc4m35vih                        0x0000560e16ed2119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: 1
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    while n != 1\
    \ {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n         \
    \   n = 3 * n + 1\n        }\n        collatz.append(n)\n    }\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: SyntaxError
  stderr: "/tmp/tmpuzuxmb3e.swift:19:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= 2\n            ~ ^\n/tmp/tmpuzuxmb3e.swift:21:13:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n            n = 3 *\
    \ n + 1\n            ^\n"
  stdout: ''
  timestamp: 1659824746
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            result.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpc4m35vih/tmpc4m35vih.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b403a505c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b403a1fcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b403a1fc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b403a1fb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc4m35vih                        0x0000560e16ed24ea <unavailable> + 5354

    5    libc.so.6                          0x00002b403a6f1460 __libc_start_main +
    245

    6    tmpc4m35vih                        0x0000560e16ed2119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var odd_collatz\
    \ = [Int]()\n    var i = 0\n    while collatz[i] != 1 {\n        if collatz[i]\
    \ % 2 == 0 {\n            collatz.append(collatz[i] / 2)\n        } else {\n \
    \           collatz.append(collatz[i] * 3 + 1)\n        }\n        i += 1\n  \
    \  }\n    for num in collatz {\n        if num % 2 != 0 {\n            odd_collatz.append(num)\n\
    \        }\n    }\n    return odd_collatz\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: Exception
  stderr: 'tmpnc1g5mgu/tmpnc1g5mgu.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7e97d65c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7e97a5cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7e97a5c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7e97a5b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnc1g5mgu                        0x000055cae8cda69a <unavailable> + 5786

    5    libc.so.6                          0x00002b7e97f51460 __libc_start_main +
    245

    6    tmpnc1g5mgu                        0x000055cae8cda2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num > 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : 3 * num + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpo4e2c071/tmpo4e2c071.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2e8515fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2e84e56b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2e84e56988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2e84e557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo4e2c071                        0x000055fe499dd4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b2e8534b460 __libc_start_main +
    245

    6    tmpo4e2c071                        0x000055fe499dd119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var current\
    \ = n\n    while current != 1 {\n        if current % 2 != 0 {\n            result.append(current)\n\
    \        }\n        current = current % 2 == 0 ? current / 2 : current * 3 + 1\n\
    \    }\n    result.append(1)\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: Exception
  stderr: 'tmpadmtlih9/tmpadmtlih9.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4fd447bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4fd4172b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4fd4172988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4fd41717b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpadmtlih9                        0x00005565000424ea <unavailable> + 5354

    5    libc.so.6                          0x00002b4fd4667460 __libc_start_main +
    245

    6    tmpadmtlih9                        0x0000556500042119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            result.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpc4m35vih/tmpc4m35vih.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b403a505c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b403a1fcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b403a1fc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b403a1fb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc4m35vih                        0x0000560e16ed24ea <unavailable> + 5354

    5    libc.so.6                          0x00002b403a6f1460 __libc_start_main +
    245

    6    tmpc4m35vih                        0x0000560e16ed2119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var current =\
    \ n\n    while current != 1 {\n        if current % 2 == 0 {\n            current\
    \ /= 2\n        } else {\n            current = current * 3 + 1\n        }\n \
    \       collatz.append(current)\n    }\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmplfekvsnc/tmplfekvsnc.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3c425c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3c422bdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3c422bd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3c422bc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplfekvsnc                        0x00005634d86fd55a <unavailable> + 5466

    5    libc.so.6                          0x00002b3c427b2460 __libc_start_main +
    245

    6    tmplfekvsnc                        0x00005634d86fd189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var result =\
    \ [Int]()\n    var i = 0\n    while collatz[i] != 1 {\n        if collatz[i] %\
    \ 2 == 1 {\n            result.append(collatz[i])\n        }\n        collatz.append(collatz[i]\
    \ % 2 == 0 ? collatz[i] / 2 : collatz[i] * 3 + 1)\n        i += 1\n    }\n   \
    \ result.append(1)\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: Exception
  stderr: 'tmplolwumu5/tmplolwumu5.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aefc36eec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aefc33e5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aefc33e5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aefc33e47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplolwumu5                        0x0000557c7d55553a <unavailable> + 5434

    5    libc.so.6                          0x00002aefc38da460 __libc_start_main +
    245

    6    tmplolwumu5                        0x0000557c7d555169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var current\
    \ = n\n    while current > 1 {\n        if current % 2 == 1 {\n            result.append(current)\n\
    \        }\n        current = current % 2 == 0 ? current / 2 : current * 3 + 1\n\
    \    }\n    result.append(1)\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: Exception
  stderr: 'tmpadxjgr39/tmpadxjgr39.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b57b3533c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b57b322ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b57b322a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b57b32297b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpadxjgr39                        0x000055665430a4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b57b371f460 __libc_start_main +
    245

    6    tmpadxjgr39                        0x000055665430a119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num > 1 {\n        collatz.append(num)\n        if num % 2 == 0\
    \ {\n            num /= 2\n        } else {\n            num = 3 * num + 1\n \
    \       }\n    }\n    collatz.append(1)\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpcuh__53b/tmpcuh__53b.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad632492c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad632189b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad632189988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad6321887b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcuh__53b                        0x000056146ad7c5aa <unavailable> + 5546

    5    libc.so.6                          0x00002ad63267e460 __libc_start_main +
    245

    6    tmpcuh__53b                        0x000056146ad7c1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num > 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp8hm81tj5/tmp8hm81tj5.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b589e748c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b589e43fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b589e43f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b589e43e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8hm81tj5                        0x000055b2fdfe54ea <unavailable> + 5354

    5    libc.so.6                          0x00002b589e934460 __libc_start_main +
    245

    6    tmp8hm81tj5                        0x000055b2fdfe5119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var oddCollatz\
    \ = [Int]()\n    var current = n\n    while current != 1 {\n        if current\
    \ % 2 == 0 {\n            current /= 2\n        } else {\n            current\
    \ = current * 3 + 1\n        }\n        collatz.append(current)\n    }\n    for\
    \ num in collatz {\n        if num % 2 != 0 {\n            oddCollatz.append(num)\n\
    \        }\n    }\n    return oddCollatz\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: Exception
  stderr: 'tmpufluhcl2/tmpufluhcl2.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afd13be0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afd138d7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afd138d7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afd138d67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpufluhcl2                        0x000055b2afc0e64a <unavailable> + 5706

    5    libc.so.6                          0x00002afd13dcc460 __libc_start_main +
    245

    6    tmpufluhcl2                        0x000055b2afc0e279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            result.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpc4m35vih/tmpc4m35vih.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b403a505c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b403a1fcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b403a1fc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b403a1fb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc4m35vih                        0x0000560e16ed24ea <unavailable> + 5354

    5    libc.so.6                          0x00002b403a6f1460 __libc_start_main +
    245

    6    tmpc4m35vih                        0x0000560e16ed2119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        collatz.append(num)\n        if num % 2 ==\
    \ 0 {\n            num /= 2\n        } else {\n            num = num * 3 + 1\n\
    \        }\n    }\n    collatz.append(1)\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl41rv_yw/tmpl41rv_yw.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0e51caec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0e519a5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0e519a5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0e519a47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl41rv_yw                        0x000055eeb4c475aa <unavailable> + 5546

    5    libc.so.6                          0x00002b0e51e9a460 __libc_start_main +
    245

    6    tmpl41rv_yw                        0x000055eeb4c471d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var current =\
    \ n\n    while current != 1 {\n        if current % 2 == 0 {\n            current\
    \ /= 2\n        } else {\n            current = current * 3 + 1\n        }\n \
    \       collatz.append(current)\n    }\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmplfekvsnc/tmplfekvsnc.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3c425c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3c422bdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3c422bd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3c422bc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplfekvsnc                        0x00005634d86fd55a <unavailable> + 5466

    5    libc.so.6                          0x00002b3c427b2460 __libc_start_main +
    245

    6    tmplfekvsnc                        0x00005634d86fd189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: 1
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    while n != 1\
    \ {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n         \
    \   n = 3 * n + 1\n        }\n        collatz.append(n)\n    }\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: SyntaxError
  stderr: "/tmp/tmpuzuxmb3e.swift:19:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= 2\n            ~ ^\n/tmp/tmpuzuxmb3e.swift:21:13:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n            n = 3 *\
    \ n + 1\n            ^\n"
  stdout: ''
  timestamp: 1659824746
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var odd = [Int]()\n\
    \    var i = 0\n    while collatz[i] != 1 {\n        if collatz[i] % 2 == 1 {\n\
    \            odd.append(collatz[i])\n        }\n        collatz.append(collatz[i]\
    \ % 2 == 0 ? collatz[i] / 2 : collatz[i] * 3 + 1)\n        i += 1\n    }\n   \
    \ return odd\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp_kcj4fec/tmp_kcj4fec.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b348c9bdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b348c6b4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b348c6b4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b348c6b37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_kcj4fec                        0x0000559a28ef553a <unavailable> + 5434

    5    libc.so.6                          0x00002b348cba9460 __libc_start_main +
    245

    6    tmp_kcj4fec                        0x0000559a28ef5169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: 1
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    while n != 1\
    \ {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n         \
    \   n = 3 * n + 1\n        }\n        collatz.append(n)\n    }\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: SyntaxError
  stderr: "/tmp/tmpuzuxmb3e.swift:19:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= 2\n            ~ ^\n/tmp/tmpuzuxmb3e.swift:21:13:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n            n = 3 *\
    \ n + 1\n            ^\n"
  stdout: ''
  timestamp: 1659824746
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var current =\
    \ n\n    while current != 1 {\n        if current % 2 == 0 {\n            current\
    \ /= 2\n        } else {\n            current = 3 * current + 1\n        }\n \
    \       collatz.append(current)\n    }\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpjc53zcpg/tmpjc53zcpg.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5a83ab6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5a837adb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5a837ad988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5a837ac7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjc53zcpg                        0x0000558716d4655a <unavailable> + 5466

    5    libc.so.6                          0x00002b5a83ca2460 __libc_start_main +
    245

    6    tmpjc53zcpg                        0x0000558716d46189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var odd_collatz\
    \ = [Int]()\n    var i = 0\n    while collatz[i] != 1 {\n        if collatz[i]\
    \ % 2 == 0 {\n            collatz.append(collatz[i] / 2)\n        } else {\n \
    \           collatz.append(collatz[i] * 3 + 1)\n        }\n        i += 1\n  \
    \  }\n    for num in collatz {\n        if num % 2 != 0 {\n            odd_collatz.append(num)\n\
    \        }\n    }\n    return odd_collatz\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: Exception
  stderr: 'tmpnc1g5mgu/tmpnc1g5mgu.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7e97d65c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7e97a5cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7e97a5c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7e97a5b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnc1g5mgu                        0x000055cae8cda69a <unavailable> + 5786

    5    libc.so.6                          0x00002b7e97f51460 __libc_start_main +
    245

    6    tmpnc1g5mgu                        0x000055cae8cda2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var odd_collatz\
    \ = [Int]()\n    while collatz.last != 1 {\n        if collatz.last! % 2 == 0\
    \ {\n            collatz.append(collatz.last! / 2)\n        } else {\n       \
    \     collatz.append(collatz.last! * 3 + 1)\n        }\n    }\n    for i in collatz\
    \ {\n        if i % 2 != 0 {\n            odd_collatz.append(i)\n        }\n \
    \   }\n    return odd_collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp56htrhkz/tmp56htrhkz.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab5074a7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab50719eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab50719e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab50719d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp56htrhkz                        0x00005653310736ea <unavailable> + 5866

    5    libc.so.6                          0x00002ab507693460 __libc_start_main +
    245

    6    tmp56htrhkz                        0x0000565331073319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var num =\
    \ n\n    while num > 1 {\n        if num % 2 == 1 {\n            result.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp684un4ro/tmp684un4ro.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5127920c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5127617b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5127617988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b51276167b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp684un4ro                        0x000055b3adcad4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b5127b0c460 __libc_start_main +
    245

    6    tmp684un4ro                        0x000055b3adcad119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var i = n\n\
    \    while i > 1 {\n        if i % 2 == 1 {\n            result.append(i)\n  \
    \      }\n        i = i % 2 == 0 ? i / 2 : i * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpc1qpgb3j/tmpc1qpgb3j.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b90198cac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b90195c1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b90195c1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b90195c07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc1qpgb3j                        0x0000559d625b14ea <unavailable> + 5354

    5    libc.so.6                          0x00002b9019ab6460 __libc_start_main +
    245

    6    tmpc1qpgb3j                        0x0000559d625b1119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            result.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpc4m35vih/tmpc4m35vih.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b403a505c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b403a1fcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b403a1fc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b403a1fb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc4m35vih                        0x0000560e16ed24ea <unavailable> + 5354

    5    libc.so.6                          0x00002b403a6f1460 __libc_start_main +
    245

    6    tmpc4m35vih                        0x0000560e16ed2119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        collatz.append(num)\n        if num % 2 ==\
    \ 0 {\n            num /= 2\n        } else {\n            num = 3 * num + 1\n\
    \        }\n    }\n    collatz.append(1)\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl1dd2fg3/tmpl1dd2fg3.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afed79e7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afed76deb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afed76de988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afed76dd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl1dd2fg3                        0x0000559dc185d5aa <unavailable> + 5546

    5    libc.so.6                          0x00002afed7bd3460 __libc_start_main +
    245

    6    tmpl1dd2fg3                        0x0000559dc185d1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var num = n\n\
    \    while num != 1 {\n        if num % 2 == 0 {\n            num /= 2\n     \
    \   } else {\n            num = num * 3 + 1\n        }\n        collatz.append(num)\n\
    \    }\n    return collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: Exception
  stderr: 'tmpdvtmwzmf/tmpdvtmwzmf.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2ebf95ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2ebf651b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2ebf651988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2ebf6507b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdvtmwzmf                        0x0000563db608155a <unavailable> + 5466

    5    libc.so.6                          0x00002b2ebfb46460 __libc_start_main +
    245

    6    tmpdvtmwzmf                        0x0000563db6081189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            result.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpc4m35vih/tmpc4m35vih.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b403a505c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b403a1fcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b403a1fc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b403a1fb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc4m35vih                        0x0000560e16ed24ea <unavailable> + 5354

    5    libc.so.6                          0x00002b403a6f1460 __libc_start_main +
    245

    6    tmpc4m35vih                        0x0000560e16ed2119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var i = n\n\
    \    while i > 1 {\n        if i % 2 == 1 {\n            result.append(i)\n  \
    \      }\n        i = i % 2 == 0 ? i / 2 : i * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpc1qpgb3j/tmpc1qpgb3j.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b90198cac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b90195c1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b90195c1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b90195c07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc1qpgb3j                        0x0000559d625b14ea <unavailable> + 5354

    5    libc.so.6                          0x00002b9019ab6460 __libc_start_main +
    245

    6    tmpc1qpgb3j                        0x0000559d625b1119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        collatz.append(num)\n        if num % 2 ==\
    \ 0 {\n            num /= 2\n        } else {\n            num = 3 * num + 1\n\
    \        }\n    }\n    collatz.append(1)\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl1dd2fg3/tmpl1dd2fg3.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afed79e7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afed76deb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afed76de988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afed76dd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl1dd2fg3                        0x0000559dc185d5aa <unavailable> + 5546

    5    libc.so.6                          0x00002afed7bd3460 __libc_start_main +
    245

    6    tmpl1dd2fg3                        0x0000559dc185d1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: 1
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    while n != 1\
    \ {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n         \
    \   n = 3 * n + 1\n        }\n        collatz.append(n)\n    }\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: SyntaxError
  stderr: "/tmp/tmpuzuxmb3e.swift:19:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= 2\n            ~ ^\n/tmp/tmpuzuxmb3e.swift:21:13:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n            n = 3 *\
    \ n + 1\n            ^\n"
  stdout: ''
  timestamp: 1659824746
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var num =\
    \ n\n    while num > 1 {\n        if num % 2 == 1 {\n            result.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp684un4ro/tmp684un4ro.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5127920c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5127617b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5127617988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b51276167b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp684un4ro                        0x000055b3adcad4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b5127b0c460 __libc_start_main +
    245

    6    tmp684un4ro                        0x000055b3adcad119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var current =\
    \ n\n    while current != 1 {\n        if current % 2 == 0 {\n            current\
    \ /= 2\n        } else {\n            current = 3 * current + 1\n        }\n \
    \       collatz.append(current)\n    }\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpjc53zcpg/tmpjc53zcpg.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5a83ab6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5a837adb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5a837ad988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5a837ac7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjc53zcpg                        0x0000558716d4655a <unavailable> + 5466

    5    libc.so.6                          0x00002b5a83ca2460 __libc_start_main +
    245

    6    tmpjc53zcpg                        0x0000558716d46189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var odd = [Int]()\n\
    \    while collatz.last != 1 {\n        if collatz.last! % 2 == 0 {\n        \
    \    collatz.append(collatz.last! / 2)\n        } else {\n            collatz.append(collatz.last!\
    \ * 3 + 1)\n            odd.append(collatz.last!)\n        }\n    }\n    odd.append(1)\n\
    \    return odd.sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp4d0eij0f/tmp4d0eij0f.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5a6fe34c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5a6fb2bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5a6fb2b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5a6fb2a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4d0eij0f                        0x000055d9f484b62a <unavailable> + 5674

    5    libc.so.6                          0x00002b5a70020460 __libc_start_main +
    245

    6    tmp4d0eij0f                        0x000055d9f484b259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var current =\
    \ n\n    while current != 1 {\n        if current % 2 == 0 {\n            current\
    \ /= 2\n        } else {\n            current = current * 3 + 1\n        }\n \
    \       collatz.append(current)\n    }\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmplfekvsnc/tmplfekvsnc.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3c425c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3c422bdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3c422bd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3c422bc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplfekvsnc                        0x00005634d86fd55a <unavailable> + 5466

    5    libc.so.6                          0x00002b3c427b2460 __libc_start_main +
    245

    6    tmplfekvsnc                        0x00005634d86fd189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        collatz.append(num)\n        if num % 2 ==\
    \ 0 {\n            num /= 2\n        } else {\n            num = num * 3 + 1\n\
    \        }\n    }\n    collatz.append(1)\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl41rv_yw/tmpl41rv_yw.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0e51caec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0e519a5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0e519a5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0e519a47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl41rv_yw                        0x000055eeb4c475aa <unavailable> + 5546

    5    libc.so.6                          0x00002b0e51e9a460 __libc_start_main +
    245

    6    tmpl41rv_yw                        0x000055eeb4c471d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var current =\
    \ n\n    while current != 1 {\n        if current % 2 == 0 {\n            current\
    \ /= 2\n        } else {\n            current = current * 3 + 1\n        }\n \
    \       collatz.append(current)\n    }\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmplfekvsnc/tmplfekvsnc.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3c425c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3c422bdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3c422bd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3c422bc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplfekvsnc                        0x00005634d86fd55a <unavailable> + 5466

    5    libc.so.6                          0x00002b3c427b2460 __libc_start_main +
    245

    6    tmplfekvsnc                        0x00005634d86fd189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num > 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp8hm81tj5/tmp8hm81tj5.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b589e748c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b589e43fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b589e43f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b589e43e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8hm81tj5                        0x000055b2fdfe54ea <unavailable> + 5354

    5    libc.so.6                          0x00002b589e934460 __libc_start_main +
    245

    6    tmp8hm81tj5                        0x000055b2fdfe5119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var current =\
    \ n\n    while current != 1 {\n        if current % 2 == 0 {\n            current\
    \ /= 2\n        } else {\n            current = current * 3 + 1\n        }\n \
    \       collatz.append(current)\n    }\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmplfekvsnc/tmplfekvsnc.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3c425c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3c422bdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3c422bd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3c422bc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplfekvsnc                        0x00005634d86fd55a <unavailable> + 5466

    5    libc.so.6                          0x00002b3c427b2460 __libc_start_main +
    245

    6    tmplfekvsnc                        0x00005634d86fd189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        collatz.append(num)\n        if num % 2 ==\
    \ 0 {\n            num /= 2\n        } else {\n            num = 3 * num + 1\n\
    \        }\n    }\n    collatz.append(1)\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl1dd2fg3/tmpl1dd2fg3.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afed79e7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afed76deb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afed76de988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afed76dd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl1dd2fg3                        0x0000559dc185d5aa <unavailable> + 5546

    5    libc.so.6                          0x00002afed7bd3460 __libc_start_main +
    245

    6    tmpl1dd2fg3                        0x0000559dc185d1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: 1
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    while n != 1\
    \ {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n         \
    \   n = 3 * n + 1\n        }\n        collatz.append(n)\n    }\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: SyntaxError
  stderr: "/tmp/tmpuzuxmb3e.swift:19:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= 2\n            ~ ^\n/tmp/tmpuzuxmb3e.swift:21:13:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n            n = 3 *\
    \ n + 1\n            ^\n"
  stdout: ''
  timestamp: 1659824746
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var current =\
    \ n\n    while current != 1 {\n        if current % 2 == 0 {\n            current\
    \ /= 2\n        } else {\n            current = current * 3 + 1\n        }\n \
    \       collatz.append(current)\n    }\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmplfekvsnc/tmplfekvsnc.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3c425c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3c422bdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3c422bd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3c422bc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplfekvsnc                        0x00005634d86fd55a <unavailable> + 5466

    5    libc.so.6                          0x00002b3c427b2460 __libc_start_main +
    245

    6    tmplfekvsnc                        0x00005634d86fd189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num > 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : 3 * num + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpo4e2c071/tmpo4e2c071.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2e8515fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2e84e56b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2e84e56988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2e84e557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo4e2c071                        0x000055fe499dd4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b2e8534b460 __libc_start_main +
    245

    6    tmpo4e2c071                        0x000055fe499dd119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            result.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpc4m35vih/tmpc4m35vih.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b403a505c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b403a1fcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b403a1fc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b403a1fb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc4m35vih                        0x0000560e16ed24ea <unavailable> + 5354

    5    libc.so.6                          0x00002b403a6f1460 __libc_start_main +
    245

    6    tmpc4m35vih                        0x0000560e16ed2119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var odd = [Int]()\n\
    \    var i = 0\n    while collatz[i] != 1 {\n        if collatz[i] % 2 == 1 {\n\
    \            odd.append(collatz[i])\n        }\n        if collatz[i] % 2 == 0\
    \ {\n            collatz.append(collatz[i] / 2)\n        } else {\n          \
    \  collatz.append(collatz[i] * 3 + 1)\n        }\n        i += 1\n    }\n    odd.append(1)\n\
    \    return odd\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpoxrdr78p/tmpoxrdr78p.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b63e8358c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b63e804fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b63e804f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b63e804e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoxrdr78p                        0x000055671f06d53a <unavailable> + 5434

    5    libc.so.6                          0x00002b63e8544460 __libc_start_main +
    245

    6    tmpoxrdr78p                        0x000055671f06d169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var current\
    \ = n\n    while current != 1 {\n        if current % 2 == 1 {\n            collatz.append(current)\n\
    \        }\n        current = current % 2 == 0 ? current / 2 : current * 3 + 1\n\
    \    }\n    collatz.append(1)\n    return collatz\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: Exception
  stderr: 'tmprw51356p/tmprw51356p.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4d8c191c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4d8be88b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4d8be88988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4d8be877b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprw51356p                        0x00005654a7f8d4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b4d8c37d460 __libc_start_main +
    245

    6    tmprw51356p                        0x00005654a7f8d119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num > 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp8hm81tj5/tmp8hm81tj5.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b589e748c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b589e43fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b589e43f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b589e43e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8hm81tj5                        0x000055b2fdfe54ea <unavailable> + 5354

    5    libc.so.6                          0x00002b589e934460 __libc_start_main +
    245

    6    tmp8hm81tj5                        0x000055b2fdfe5119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var odd = [Int]()\n\
    \    while collatz.last != 1 {\n        let last = collatz.last!\n        if last\
    \ % 2 == 0 {\n            collatz.append(last / 2)\n        } else {\n       \
    \     collatz.append(last * 3 + 1)\n            odd.append(last)\n        }\n\
    \    }\n    return odd\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpapt5r1a4/tmpapt5r1a4.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad27ecc3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad27e9bab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad27e9ba988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad27e9b97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpapt5r1a4                        0x0000559f12e1c57a <unavailable> + 5498

    5    libc.so.6                          0x00002ad27eeaf460 __libc_start_main +
    245

    6    tmpapt5r1a4                        0x0000559f12e1c1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            result.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpc4m35vih/tmpc4m35vih.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b403a505c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b403a1fcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b403a1fc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b403a1fb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc4m35vih                        0x0000560e16ed24ea <unavailable> + 5354

    5    libc.so.6                          0x00002b403a6f1460 __libc_start_main +
    245

    6    tmpc4m35vih                        0x0000560e16ed2119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            result.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpc4m35vih/tmpc4m35vih.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b403a505c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b403a1fcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b403a1fc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b403a1fb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc4m35vih                        0x0000560e16ed24ea <unavailable> + 5354

    5    libc.so.6                          0x00002b403a6f1460 __libc_start_main +
    245

    6    tmpc4m35vih                        0x0000560e16ed2119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            result.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : 3 * num + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp_yfshqe7/tmp_yfshqe7.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad58acedc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad58a9e4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad58a9e4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad58a9e37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_yfshqe7                        0x00005563bbecf4ea <unavailable> + 5354

    5    libc.so.6                          0x00002ad58aed9460 __libc_start_main +
    245

    6    tmp_yfshqe7                        0x00005563bbecf119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var current =\
    \ n\n    while current != 1 {\n        if current % 2 == 0 {\n            current\
    \ /= 2\n        } else {\n            current = current * 3 + 1\n        }\n \
    \       collatz.append(current)\n    }\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmplfekvsnc/tmplfekvsnc.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3c425c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3c422bdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3c422bd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3c422bc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplfekvsnc                        0x00005634d86fd55a <unavailable> + 5466

    5    libc.so.6                          0x00002b3c427b2460 __libc_start_main +
    245

    6    tmplfekvsnc                        0x00005634d86fd189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var current =\
    \ n\n    while current != 1 {\n        if current % 2 == 0 {\n            current\
    \ /= 2\n        } else {\n            current = current * 3 + 1\n        }\n \
    \       collatz.append(current)\n    }\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmplfekvsnc/tmplfekvsnc.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3c425c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3c422bdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3c422bd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3c422bc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplfekvsnc                        0x00005634d86fd55a <unavailable> + 5466

    5    libc.so.6                          0x00002b3c427b2460 __libc_start_main +
    245

    6    tmplfekvsnc                        0x00005634d86fd189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var odd_collatz\
    \ = [Int]()\n    while collatz.last != 1 {\n        if collatz.last! % 2 == 0\
    \ {\n            collatz.append(collatz.last! / 2)\n        } else {\n       \
    \     collatz.append(collatz.last! * 3 + 1)\n        }\n    }\n    for i in collatz\
    \ {\n        if i % 2 != 0 {\n            odd_collatz.append(i)\n        }\n \
    \   }\n    return odd_collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp56htrhkz/tmp56htrhkz.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab5074a7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab50719eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab50719e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab50719d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp56htrhkz                        0x00005653310736ea <unavailable> + 5866

    5    libc.so.6                          0x00002ab507693460 __libc_start_main +
    245

    6    tmp56htrhkz                        0x0000565331073319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num > 1 {\n        collatz.append(num)\n        if num % 2 == 0\
    \ {\n            num /= 2\n        } else {\n            num = num * 3 + 1\n \
    \       }\n    }\n    collatz.append(1)\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmptigafa5w/tmptigafa5w.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afd98055c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afd97d4cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afd97d4c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afd97d4b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptigafa5w                        0x000055cb2c5565aa <unavailable> + 5546

    5    libc.so.6                          0x00002afd98241460 __libc_start_main +
    245

    6    tmptigafa5w                        0x000055cb2c5561d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            result.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpc4m35vih/tmpc4m35vih.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b403a505c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b403a1fcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b403a1fc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b403a1fb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc4m35vih                        0x0000560e16ed24ea <unavailable> + 5354

    5    libc.so.6                          0x00002b403a6f1460 __libc_start_main +
    245

    6    tmpc4m35vih                        0x0000560e16ed2119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: 1
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    while n != 1\
    \ {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n         \
    \   n = 3 * n + 1\n        }\n        collatz.append(n)\n    }\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: SyntaxError
  stderr: "/tmp/tmpuzuxmb3e.swift:19:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= 2\n            ~ ^\n/tmp/tmpuzuxmb3e.swift:21:13:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n            n = 3 *\
    \ n + 1\n            ^\n"
  stdout: ''
  timestamp: 1659824746
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var current =\
    \ n\n    while current != 1 {\n        if current % 2 == 0 {\n            current\
    \ /= 2\n        } else {\n            current = current * 3 + 1\n        }\n \
    \       collatz.append(current)\n    }\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmplfekvsnc/tmplfekvsnc.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3c425c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3c422bdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3c422bd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3c422bc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplfekvsnc                        0x00005634d86fd55a <unavailable> + 5466

    5    libc.so.6                          0x00002b3c427b2460 __libc_start_main +
    245

    6    tmplfekvsnc                        0x00005634d86fd189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var current =\
    \ n\n    while current != 1 {\n        if current % 2 == 0 {\n            current\
    \ /= 2\n        } else {\n            current = 3 * current + 1\n        }\n \
    \       collatz.append(current)\n    }\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpjc53zcpg/tmpjc53zcpg.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5a83ab6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5a837adb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5a837ad988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5a837ac7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjc53zcpg                        0x0000558716d4655a <unavailable> + 5466

    5    libc.so.6                          0x00002b5a83ca2460 __libc_start_main +
    245

    6    tmpjc53zcpg                        0x0000558716d46189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var n = n\n\
    \    while n > 1 {\n        if n % 2 == 1 {\n            result.append(n)\n  \
    \      }\n        n = n % 2 == 0 ? n / 2 : 3 * n + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpj8qls9w_/tmpj8qls9w_.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b413fb95c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b413f88cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b413f88c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b413f88b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj8qls9w_                        0x0000560dba5bc4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b413fd81460 __libc_start_main +
    245

    6    tmpj8qls9w_                        0x0000560dba5bc119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var i = n\n\
    \    while i > 1 {\n        if i % 2 == 1 {\n            collatz.append(i)\n \
    \       }\n        i = i % 2 == 0 ? i / 2 : i * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpz55apbwt/tmpz55apbwt.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae977e94c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae977b8bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae977b8b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae977b8a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz55apbwt                        0x00005566747324ea <unavailable> + 5354

    5    libc.so.6                          0x00002ae978080460 __libc_start_main +
    245

    6    tmpz55apbwt                        0x0000556674732119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: 1
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz_sequence: [Int] = [n]\n\
    \    while n != 1 {\n        if n % 2 == 0 {\n            n = n / 2\n        }\
    \ else {\n            n = 3 * n + 1\n        }\n        collatz_sequence.append(n)\n\
    \    }\n    var odd_collatz_sequence: [Int] = []\n    for i in collatz_sequence\
    \ {\n        if i % 2 != 0 {\n            odd_collatz_sequence.append(i)\n   \
    \     }\n    }\n    return odd_collatz_sequence\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: SyntaxError
  stderr: "/tmp/tmpfl16tjuw.swift:19:13: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n            n = n / 2\n            ^\n/tmp/tmpfl16tjuw.swift:21:13:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n            n = 3 *\
    \ n + 1\n            ^\n"
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz: [Int] = []\n    var num\
    \ = n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpkaevxczq/tmpkaevxczq.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b19b3faec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b19b3ca5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b19b3ca5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b19b3ca47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkaevxczq                        0x0000564f9431248a <unavailable> + 5258

    5    libc.so.6                          0x00002b19b419a460 __libc_start_main +
    245

    6    tmpkaevxczq                        0x0000564f943120b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            result.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpc4m35vih/tmpc4m35vih.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b403a505c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b403a1fcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b403a1fc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b403a1fb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc4m35vih                        0x0000560e16ed24ea <unavailable> + 5354

    5    libc.so.6                          0x00002b403a6f1460 __libc_start_main +
    245

    6    tmpc4m35vih                        0x0000560e16ed2119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var num =\
    \ n\n    while num > 1 {\n        if num % 2 == 1 {\n            result.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp684un4ro/tmp684un4ro.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5127920c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5127617b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5127617988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b51276167b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp684un4ro                        0x000055b3adcad4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b5127b0c460 __libc_start_main +
    245

    6    tmp684un4ro                        0x000055b3adcad119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var odd = [Int]()\n\
    \    var i = 0\n    while collatz[i] != 1 {\n        if collatz[i] % 2 == 1 {\n\
    \            odd.append(collatz[i])\n        }\n        if collatz[i] % 2 == 0\
    \ {\n            collatz.append(collatz[i] / 2)\n        } else {\n          \
    \  collatz.append(collatz[i] * 3 + 1)\n        }\n        i += 1\n    }\n    odd.append(1)\n\
    \    return odd\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpoxrdr78p/tmpoxrdr78p.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b63e8358c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b63e804fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b63e804f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b63e804e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoxrdr78p                        0x000055671f06d53a <unavailable> + 5434

    5    libc.so.6                          0x00002b63e8544460 __libc_start_main +
    245

    6    tmpoxrdr78p                        0x000055671f06d169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num > 1 {\n        collatz.append(num)\n        if num % 2 == 0\
    \ {\n            num /= 2\n        } else {\n            num = 3 * num + 1\n \
    \       }\n    }\n    collatz.append(1)\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpcuh__53b/tmpcuh__53b.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad632492c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad632189b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad632189988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad6321887b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcuh__53b                        0x000056146ad7c5aa <unavailable> + 5546

    5    libc.so.6                          0x00002ad63267e460 __libc_start_main +
    245

    6    tmpcuh__53b                        0x000056146ad7c1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            result.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : 3 * num + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp_yfshqe7/tmp_yfshqe7.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad58acedc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad58a9e4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad58a9e4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad58a9e37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_yfshqe7                        0x00005563bbecf4ea <unavailable> + 5354

    5    libc.so.6                          0x00002ad58aed9460 __libc_start_main +
    245

    6    tmp_yfshqe7                        0x00005563bbecf119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var num =\
    \ n\n    while num > 1 {\n        if num % 2 == 1 {\n            result.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp684un4ro/tmp684un4ro.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5127920c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5127617b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5127617988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b51276167b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp684un4ro                        0x000055b3adcad4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b5127b0c460 __libc_start_main +
    245

    6    tmp684un4ro                        0x000055b3adcad119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: 1
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    while n != 1\
    \ {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n         \
    \   n = 3 * n + 1\n        }\n        collatz.append(n)\n    }\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: SyntaxError
  stderr: "/tmp/tmpuzuxmb3e.swift:19:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= 2\n            ~ ^\n/tmp/tmpuzuxmb3e.swift:21:13:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n            n = 3 *\
    \ n + 1\n            ^\n"
  stdout: ''
  timestamp: 1659824746
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        collatz.append(num)\n        if num % 2 ==\
    \ 0 {\n            num /= 2\n        } else {\n            num = num * 3 + 1\n\
    \        }\n    }\n    collatz.append(1)\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl41rv_yw/tmpl41rv_yw.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0e51caec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0e519a5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0e519a5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0e519a47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl41rv_yw                        0x000055eeb4c475aa <unavailable> + 5546

    5    libc.so.6                          0x00002b0e51e9a460 __libc_start_main +
    245

    6    tmpl41rv_yw                        0x000055eeb4c471d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : 3 * num + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpiamawe5a/tmpiamawe5a.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba3dd2ebc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba3dcfe2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba3dcfe2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba3dcfe17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiamawe5a                        0x00005576918b74ea <unavailable> + 5354

    5    libc.so.6                          0x00002ba3dd4d7460 __libc_start_main +
    245

    6    tmpiamawe5a                        0x00005576918b7119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var num =\
    \ n\n    while num > 1 {\n        if num % 2 == 1 {\n            result.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp684un4ro/tmp684un4ro.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5127920c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5127617b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5127617988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b51276167b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp684un4ro                        0x000055b3adcad4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b5127b0c460 __libc_start_main +
    245

    6    tmp684un4ro                        0x000055b3adcad119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result: [Int] = []\n    var current\
    \ = n\n    while current != 1 {\n        if current % 2 != 0 {\n            result.append(current)\n\
    \        }\n        current = current % 2 == 0 ? current / 2 : current * 3 + 1\n\
    \    }\n    result.append(1)\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: Exception
  stderr: 'tmpr_yudne0/tmpr_yudne0.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8406b78c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b840686fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b840686f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b840686e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr_yudne0                        0x0000558439a6a48a <unavailable> + 5258

    5    libc.so.6                          0x00002b8406d64460 __libc_start_main +
    245

    6    tmpr_yudne0                        0x0000558439a6a0b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result: [Int] = []\n    var num\
    \ = n\n    while num != 1 {\n        if num % 2 == 1 {\n            result.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpa3ghmxoq/tmpa3ghmxoq.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9ba6c22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9ba6919b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9ba6919988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9ba69187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa3ghmxoq                        0x0000555a0761a48a <unavailable> + 5258

    5    libc.so.6                          0x00002b9ba6e0e460 __libc_start_main +
    245

    6    tmpa3ghmxoq                        0x0000555a0761a0b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num > 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp8hm81tj5/tmp8hm81tj5.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b589e748c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b589e43fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b589e43f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b589e43e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8hm81tj5                        0x000055b2fdfe54ea <unavailable> + 5354

    5    libc.so.6                          0x00002b589e934460 __libc_start_main +
    245

    6    tmp8hm81tj5                        0x000055b2fdfe5119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var current =\
    \ n\n    while current != 1 {\n        if current % 2 == 0 {\n            current\
    \ /= 2\n        } else {\n            current = current * 3 + 1\n        }\n \
    \       collatz.append(current)\n    }\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmplfekvsnc/tmplfekvsnc.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3c425c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3c422bdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3c422bd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3c422bc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplfekvsnc                        0x00005634d86fd55a <unavailable> + 5466

    5    libc.so.6                          0x00002b3c427b2460 __libc_start_main +
    245

    6    tmplfekvsnc                        0x00005634d86fd189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result: [Int] = []\n    var num\
    \ = n\n    while num != 1 {\n        if num % 2 == 1 {\n            result.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpa3ghmxoq/tmpa3ghmxoq.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9ba6c22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9ba6919b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9ba6919988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9ba69187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa3ghmxoq                        0x0000555a0761a48a <unavailable> + 5258

    5    libc.so.6                          0x00002b9ba6e0e460 __libc_start_main +
    245

    6    tmpa3ghmxoq                        0x0000555a0761a0b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var odd_collatz\
    \ = [Int]()\n    while collatz.last != 1 {\n        if collatz.last! % 2 == 0\
    \ {\n            collatz.append(collatz.last! / 2)\n        } else {\n       \
    \     collatz.append(collatz.last! * 3 + 1)\n        }\n    }\n    for num in\
    \ collatz {\n        if num % 2 != 0 {\n            odd_collatz.append(num)\n\
    \        }\n    }\n    return odd_collatz\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: Exception
  stderr: 'tmpsztesh2y/tmpsztesh2y.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b74a82f4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b74a7febb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b74a7feb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b74a7fea7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsztesh2y                        0x0000565213abe6ea <unavailable> + 5866

    5    libc.so.6                          0x00002b74a84e0460 __libc_start_main +
    245

    6    tmpsztesh2y                        0x0000565213abe319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var odd = [Int]()\n\
    \    while collatz.last != 1 {\n        if collatz.last! % 2 == 0 {\n        \
    \    collatz.append(collatz.last! / 2)\n        } else {\n            collatz.append(collatz.last!\
    \ * 3 + 1)\n            odd.append(collatz.last!)\n        }\n    }\n    odd.sort()\n\
    \    return odd\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpjz05nm7_/tmpjz05nm7_.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afe21c9fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afe21996b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afe21996988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afe219957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjz05nm7_                        0x00005625ce7c669a <unavailable> + 5786

    5    libc.so.6                          0x00002afe21e8b460 __libc_start_main +
    245

    6    tmpjz05nm7_                        0x00005625ce7c62c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var odd = [Int]()\n\
    \    var i = 0\n    while collatz[i] != 1 {\n        if collatz[i] % 2 == 1 {\n\
    \            odd.append(collatz[i])\n        }\n        if collatz[i] % 2 == 0\
    \ {\n            collatz.append(collatz[i] / 2)\n        } else {\n          \
    \  collatz.append(collatz[i] * 3 + 1)\n        }\n        i += 1\n    }\n    odd.append(1)\n\
    \    return odd\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpoxrdr78p/tmpoxrdr78p.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b63e8358c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b63e804fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b63e804f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b63e804e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoxrdr78p                        0x000055671f06d53a <unavailable> + 5434

    5    libc.so.6                          0x00002b63e8544460 __libc_start_main +
    245

    6    tmpoxrdr78p                        0x000055671f06d169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        collatz.append(num)\n        if num % 2 ==\
    \ 0 {\n            num /= 2\n        } else {\n            num = 3 * num + 1\n\
    \        }\n    }\n    collatz.append(1)\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl1dd2fg3/tmpl1dd2fg3.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afed79e7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afed76deb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afed76de988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afed76dd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl1dd2fg3                        0x0000559dc185d5aa <unavailable> + 5546

    5    libc.so.6                          0x00002afed7bd3460 __libc_start_main +
    245

    6    tmpl1dd2fg3                        0x0000559dc185d1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var current =\
    \ n\n    while current != 1 {\n        if current % 2 == 0 {\n            current\
    \ /= 2\n        } else {\n            current = current * 3 + 1\n        }\n \
    \       collatz.append(current)\n    }\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmplfekvsnc/tmplfekvsnc.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3c425c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3c422bdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3c422bd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3c422bc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplfekvsnc                        0x00005634d86fd55a <unavailable> + 5466

    5    libc.so.6                          0x00002b3c427b2460 __libc_start_main +
    245

    6    tmplfekvsnc                        0x00005634d86fd189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num > 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp8hm81tj5/tmp8hm81tj5.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b589e748c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b589e43fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b589e43f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b589e43e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8hm81tj5                        0x000055b2fdfe54ea <unavailable> + 5354

    5    libc.so.6                          0x00002b589e934460 __libc_start_main +
    245

    6    tmp8hm81tj5                        0x000055b2fdfe5119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num > 1 {\n        collatz.append(num)\n        if num % 2 == 0\
    \ {\n            num /= 2\n        } else {\n            num = num * 3 + 1\n \
    \       }\n    }\n    collatz.append(1)\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmptigafa5w/tmptigafa5w.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afd98055c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afd97d4cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afd97d4c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afd97d4b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptigafa5w                        0x000055cb2c5565aa <unavailable> + 5546

    5    libc.so.6                          0x00002afd98241460 __libc_start_main +
    245

    6    tmptigafa5w                        0x000055cb2c5561d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var current =\
    \ n\n    while current != 1 {\n        if current % 2 == 0 {\n            current\
    \ /= 2\n        } else {\n            current = current * 3 + 1\n        }\n \
    \       collatz.append(current)\n    }\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmplfekvsnc/tmplfekvsnc.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3c425c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3c422bdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3c422bd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3c422bc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplfekvsnc                        0x00005634d86fd55a <unavailable> + 5466

    5    libc.so.6                          0x00002b3c427b2460 __libc_start_main +
    245

    6    tmplfekvsnc                        0x00005634d86fd189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [n]\n    var current =\
    \ n\n    while current != 1 {\n        if current % 2 == 0 {\n            current\
    \ /= 2\n        } else {\n            current = current * 3 + 1\n        }\n \
    \       collatz.append(current)\n    }\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmplfekvsnc/tmplfekvsnc.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3c425c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3c422bdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3c422bd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3c422bc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplfekvsnc                        0x00005634d86fd55a <unavailable> + 5466

    5    libc.so.6                          0x00002b3c427b2460 __libc_start_main +
    245

    6    tmplfekvsnc                        0x00005634d86fd189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num > 1 {\n        collatz.append(num)\n        if num % 2 == 0\
    \ {\n            num /= 2\n        } else {\n            num = num * 3 + 1\n \
    \       }\n    }\n    collatz.append(1)\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmptigafa5w/tmptigafa5w.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afd98055c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afd97d4cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afd97d4c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afd97d4b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptigafa5w                        0x000055cb2c5565aa <unavailable> + 5546

    5    libc.so.6                          0x00002afd98241460 __libc_start_main +
    245

    6    tmptigafa5w                        0x000055cb2c5561d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        collatz.append(num)\n        if num % 2 ==\
    \ 0 {\n            num /= 2\n        } else {\n            num = num * 3 + 1\n\
    \        }\n    }\n    collatz.append(1)\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl41rv_yw/tmpl41rv_yw.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0e51caec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0e519a5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0e519a5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0e519a47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl41rv_yw                        0x000055eeb4c475aa <unavailable> + 5546

    5    libc.so.6                          0x00002b0e51e9a460 __libc_start_main +
    245

    6    tmpl41rv_yw                        0x000055eeb4c471d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var result = [Int]()\n    var num =\
    \ n\n    while num > 1 {\n        if num % 2 == 1 {\n            result.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp684un4ro/tmp684un4ro.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5127920c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5127617b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5127617988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b51276167b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp684un4ro                        0x000055b3adcad4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b5127b0c460 __libc_start_main +
    245

    6    tmp684un4ro                        0x000055b3adcad119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        collatz.append(num)\n        if num % 2 ==\
    \ 0 {\n            num /= 2\n        } else {\n            num = 3 * num + 1\n\
    \        }\n    }\n    collatz.append(1)\n    return collatz.filter { $0 % 2 !=\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14)\
    \ == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl1dd2fg3/tmpl1dd2fg3.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afed79e7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afed76deb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afed76de988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afed76dd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl1dd2fg3                        0x0000559dc185d5aa <unavailable> + 5546

    5    libc.so.6                          0x00002afed7bd3460 __libc_start_main +
    245

    6    tmpl1dd2fg3                        0x0000559dc185d1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted array that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned array sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n/// >>> get_odd_collatz(n: 5)\n/// [1, 5]\nfunc\
    \ get_odd_collatz(n: Int) -> [Int] {\n    var collatz = [Int]()\n    var num =\
    \ n\n    while num != 1 {\n        if num % 2 == 1 {\n            collatz.append(num)\n\
    \        }\n        num = num % 2 == 0 ? num / 2 : num * 3 + 1\n    }\n    collatz.append(1)\n\
    \    return collatz\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpmhxwavh8/tmpmhxwavh8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057bbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057b8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057b8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057b8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhxwavh8                        0x000055684a08f4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b057bdd0460 __libc_start_main +
    245

    6    tmpmhxwavh8                        0x000055684a08f119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824747
