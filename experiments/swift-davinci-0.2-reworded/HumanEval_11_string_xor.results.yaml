language: swift
name: HumanEval_11_string_xor
results:
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        result += String(Int(String(a_char))!\
    \ ^ Int(String(b_char))!)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for (index, char) in a.enumerated()\
    \ {\n        let a = char == \"1\"\n        let b = b[b.index(b.startIndex, offsetBy:\
    \ index)] == \"1\"\n        result += a != b ? \"1\" : \"0\"\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        result += String(Int(String(a_char))!\
    \ ^ Int(String(b_char))!)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a = a.utf8.map { UInt8(bitPattern: $0) }\n \
    \   let b = b.utf8.map { UInt8(bitPattern: $0) }\n    let xor = zip(a, b).map\
    \ { $0 ^ $1 }\n    return xor.map { String(UnicodeScalar(UInt8(bitPattern: $0)))\
    \ }.joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpmqgnj2ws.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element'\
    \ (aka 'UInt8') to expected argument type 'Int8'\n    let a = a.utf8.map { UInt8(bitPattern:\
    \ $0) }\n                                           ^\n                      \
    \                     Int8( )\n/tmp/tmpmqgnj2ws.swift:8:44: error: cannot convert\
    \ value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type\
    \ 'Int8'\n    let b = b.utf8.map { UInt8(bitPattern: $0) }\n                 \
    \                          ^\n                                           Int8(\
    \ )\n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a_bytes = a.utf8.map { UInt8($0) }\n    let\
    \ b_bytes = b.utf8.map { UInt8($0) }\n    let result = zip(a_bytes, b_bytes).map\
    \ { $0 ^ $1 }\n    return result.map { String($0, radix: 2) }.joined()\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a = a.utf8.map { UInt8(bitPattern: $0) }\n \
    \   let b = b.utf8.map { UInt8(bitPattern: $0) }\n    let c = zip(a, b).map {\
    \ $0 ^ $1 }\n    return c.map { String(UnicodeScalar(UInt8(bitPattern: $0))) }.joined()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpzp7rk339.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element'\
    \ (aka 'UInt8') to expected argument type 'Int8'\n    let a = a.utf8.map { UInt8(bitPattern:\
    \ $0) }\n                                           ^\n                      \
    \                     Int8( )\n/tmp/tmpzp7rk339.swift:8:44: error: cannot convert\
    \ value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type\
    \ 'Int8'\n    let b = b.utf8.map { UInt8(bitPattern: $0) }\n                 \
    \                          ^\n                                           Int8(\
    \ )\n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let aa = a.utf8.map { $0 - 48 }\n    let bb = b.utf8.map\
    \ { $0 - 48 }\n    let cc = zip(aa, bb).map { $0 ^ $1 }\n    return String(cc.map\
    \ { $0 + 48 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpjlp_cmcz.swift:10:12: error: no exact matches in call to initializer\
    \ \n    return String(cc.map { $0 + 48 })\n           ^\nSwift.String:4:12: note:\
    \ candidate requires that the types 'UInt8' and 'Character' be equivalent (requirement\
    \ specified as 'S.Element' == 'Character')\n    public init<S>(_ characters: S)\
    \ where S : Sequence, S.Element == Character\n           ^\nSwift.RangeReplaceableCollection:3:23:\
    \ note: candidate requires that the types 'String.Element' (aka 'Character') and\
    \ 'UInt8' be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n\
    \    @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element\
    \ == S.Element\n                      ^\nSwift.String:7:23: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(cString:)')\n    @inlinable public\
    \ init(cString nullTerminatedUTF8: [UInt8])\n                      ^\nSwift.String:2:12:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n\
    \    public init<Subject>(describing instance: Subject)\n           ^\nSwift.String:3:23:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n\
    \    @inlinable public init<Subject>(describing instance: Subject) where Subject\
    \ : CustomStringConvertible\n                      ^\nSwift.String:6:12: note:\
    \ incorrect labels for candidate (have: '(_:)', expected: '(reflecting:)')\n \
    \   public init<Subject>(reflecting subject: Subject)\n           ^\n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a_bytes = a.utf8.map { UInt8($0) }\n    let\
    \ b_bytes = b.utf8.map { UInt8($0) }\n    let xor_bytes = zip(a_bytes, b_bytes).map\
    \ { $0 ^ $1 }\n    return String(bytes: xor_bytes, encoding: .utf8)!\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpx1vpjue_.swift:10:12: error: no exact matches in call to initializer\
    \ \n    return String(bytes: xor_bytes, encoding: .utf8)!\n           ^\n/tmp/tmpx1vpjue_.swift:10:12:\
    \ note: found candidate with type '(Array<_>, _.Type) -> String'\n    return String(bytes:\
    \ xor_bytes, encoding: .utf8)!\n           ^\n/tmp/tmpx1vpjue_.swift:10:12: note:\
    \ found candidate with type '([UInt8]) -> String'\n    return String(bytes: xor_bytes,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmpx1vpjue_.swift:10:12: note: found candidate\
    \ with type '(Substring.UTF8View) -> String?'\n    return String(bytes: xor_bytes,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmpx1vpjue_.swift:10:12: note: found candidate\
    \ with type '(Substring.UTF16View) -> String?'\n    return String(bytes: xor_bytes,\
    \ encoding: .utf8)!\n           ^\n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a = a.utf8.map { $0 - 48 }\n    let b = b.utf8.map\
    \ { $0 - 48 }\n    let c = zip(a, b).map { $0 ^ $1 }\n    return String(c.map\
    \ { $0 + 48 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmplh81fjbk.swift:10:12: error: no exact matches in call to initializer\
    \ \n    return String(c.map { $0 + 48 })\n           ^\nSwift.String:4:12: note:\
    \ candidate requires that the types 'UInt8' and 'Character' be equivalent (requirement\
    \ specified as 'S.Element' == 'Character')\n    public init<S>(_ characters: S)\
    \ where S : Sequence, S.Element == Character\n           ^\nSwift.RangeReplaceableCollection:3:23:\
    \ note: candidate requires that the types 'String.Element' (aka 'Character') and\
    \ 'UInt8' be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n\
    \    @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element\
    \ == S.Element\n                      ^\nSwift.String:7:23: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(cString:)')\n    @inlinable public\
    \ init(cString nullTerminatedUTF8: [UInt8])\n                      ^\nSwift.String:2:12:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n\
    \    public init<Subject>(describing instance: Subject)\n           ^\nSwift.String:3:23:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n\
    \    @inlinable public init<Subject>(describing instance: Subject) where Subject\
    \ : CustomStringConvertible\n                      ^\nSwift.String:6:12: note:\
    \ incorrect labels for candidate (have: '(_:)', expected: '(reflecting:)')\n \
    \   public init<Subject>(reflecting subject: Subject)\n           ^\n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a_bytes = a.utf8.map { UInt8($0) }\n    let\
    \ b_bytes = b.utf8.map { UInt8($0) }\n    let result = zip(a_bytes, b_bytes).map\
    \ { $0 ^ $1 }\n    return result.map { String($0, radix: 2) }.joined()\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[i]\n        let b_char = b[i]\n        if a_char == b_char\
    \ {\n            result += \"0\"\n        } else {\n            result += \"1\"\
    \n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp5_nbdvis.swift:9:22: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let a_char\
    \ = a[i]\n                     ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp5_nbdvis.swift:10:22: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let b_char = b[i]\n                     ^~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    return a.xor(b)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpsjaplbuk.swift:7:14: error: value of type 'String' has no member\
    \ 'xor'\n    return a.xor(b)\n           ~ ^~~\n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a = a.utf8.map { UInt8(bitPattern: $0) }\n \
    \   let b = b.utf8.map { UInt8(bitPattern: $0) }\n    let xor = zip(a, b).map\
    \ { $0 ^ $1 }\n    return xor.map { String(UnicodeScalar(UInt8(bitPattern: $0)))\
    \ }.joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpmqgnj2ws.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element'\
    \ (aka 'UInt8') to expected argument type 'Int8'\n    let a = a.utf8.map { UInt8(bitPattern:\
    \ $0) }\n                                           ^\n                      \
    \                     Int8( )\n/tmp/tmpmqgnj2ws.swift:8:44: error: cannot convert\
    \ value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type\
    \ 'Int8'\n    let b = b.utf8.map { UInt8(bitPattern: $0) }\n                 \
    \                          ^\n                                           Int8(\
    \ )\n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let aChar = a[a.index(a.startIndex, offsetBy: i)]\n        let bChar\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if aChar == bChar {\n     \
    \       result += \"0\"\n        } else {\n            result += \"1\"\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a = a.utf8.map { UInt8(bitPattern: $0) }\n \
    \   let b = b.utf8.map { UInt8(bitPattern: $0) }\n    let xor = zip(a, b).map\
    \ { $0 ^ $1 }\n    return xor.map { String(UnicodeScalar(UInt8(bitPattern: $0)))\
    \ }.joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpmqgnj2ws.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element'\
    \ (aka 'UInt8') to expected argument type 'Int8'\n    let a = a.utf8.map { UInt8(bitPattern:\
    \ $0) }\n                                           ^\n                      \
    \                     Int8( )\n/tmp/tmpmqgnj2ws.swift:8:44: error: cannot convert\
    \ value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type\
    \ 'Int8'\n    let b = b.utf8.map { UInt8(bitPattern: $0) }\n                 \
    \                          ^\n                                           Int8(\
    \ )\n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        let a_int = Int(String(a_char))!\n\
    \        let b_int = Int(String(b_char))!\n        result += String(a_int ^ b_int)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a_bytes = a.utf8.map { UInt8($0) }\n    let\
    \ b_bytes = b.utf8.map { UInt8($0) }\n    let xor_bytes = zip(a_bytes, b_bytes).map\
    \ { $0 ^ $1 }\n    return xor_bytes.map { String($0, radix: 2) }.joined()\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a = a.utf8.map { Int($0) - 48 }\n    let b =\
    \ b.utf8.map { Int($0) - 48 }\n    var result = \"\"\n    for i in 0..<a.count\
    \ {\n        result += String(a[i] ^ b[i])\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        result += String(Int(String(a_char))!\
    \ ^ Int(String(b_char))!)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a = a.utf8.map { UInt8(bitPattern: $0) }\n \
    \   let b = b.utf8.map { UInt8(bitPattern: $0) }\n    let result = zip(a, b).map\
    \ { $0 ^ $1 }\n    return result.reduce(\"\") { $0 + String(format: \"%02x\",\
    \ $1) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp7la11_c1.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element'\
    \ (aka 'UInt8') to expected argument type 'Int8'\n    let a = a.utf8.map { UInt8(bitPattern:\
    \ $0) }\n                                           ^\n                      \
    \                     Int8( )\n/tmp/tmp7la11_c1.swift:8:44: error: cannot convert\
    \ value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type\
    \ 'Int8'\n    let b = b.utf8.map { UInt8(bitPattern: $0) }\n                 \
    \                          ^\n                                           Int8(\
    \ )\n/tmp/tmp7la11_c1.swift:10:43: error: incorrect argument labels in call (have\
    \ 'format:_:', expected 'repeating:count:')\n    return result.reduce(\"\") {\
    \ $0 + String(format: \"%02x\", $1) }\n                                      \
    \    ^~~~~~~\n                                           repeating       count:\
    \ \n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a = a.utf8.map { UInt8(bitPattern: $0) }\n \
    \   let b = b.utf8.map { UInt8(bitPattern: $0) }\n    let result = zip(a, b).map\
    \ { $0 ^ $1 }\n    return result.reduce(\"\") { $0 + String(format: \"%02x\",\
    \ $1) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp7la11_c1.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element'\
    \ (aka 'UInt8') to expected argument type 'Int8'\n    let a = a.utf8.map { UInt8(bitPattern:\
    \ $0) }\n                                           ^\n                      \
    \                     Int8( )\n/tmp/tmp7la11_c1.swift:8:44: error: cannot convert\
    \ value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type\
    \ 'Int8'\n    let b = b.utf8.map { UInt8(bitPattern: $0) }\n                 \
    \                          ^\n                                           Int8(\
    \ )\n/tmp/tmp7la11_c1.swift:10:43: error: incorrect argument labels in call (have\
    \ 'format:_:', expected 'repeating:count:')\n    return result.reduce(\"\") {\
    \ $0 + String(format: \"%02x\", $1) }\n                                      \
    \    ^~~~~~~\n                                           repeating       count:\
    \ \n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for (index, char) in a.characters.enumerated()\
    \ {\n        let a = char == \"0\" ? false : true\n        let b = b[index] ==\
    \ \"0\" ? false : true\n        result += a != b ? \"1\" : \"0\"\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp06andbm0.swift:8:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for (index, char) in a.characters.enumerated() {\n\
    \                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp06andbm0.swift:10:17: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        let\
    \ b = b[index] == \"0\" ? false : true\n                ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for (i, j) in zip(a, b) {\n\
    \        result += String(Int(String(i))! ^ Int(String(j))!)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for (index, char) in a.enumerated()\
    \ {\n        let a = char == \"1\"\n        let b = b[b.index(b.startIndex, offsetBy:\
    \ index)] == \"1\"\n        result += a != b ? \"1\" : \"0\"\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for (index, char) in a.characters.enumerated()\
    \ {\n        let a = char == \"0\" ? false : true\n        let b = b[index] ==\
    \ \"0\" ? false : true\n        result += a ^ b ? \"1\" : \"0\"\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpcurtiigq.swift:8:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for (index, char) in a.characters.enumerated() {\n\
    \                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpcurtiigq.swift:10:17: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        let\
    \ b = b[index] == \"0\" ? false : true\n                ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpcurtiigq.swift:11:21:\
    \ error: binary operator '^' cannot be applied to two 'Bool' operands\n      \
    \  result += a ^ b ? \"1\" : \"0\"\n                    ^\nSwift.BinaryInteger:1:17:\
    \ note: candidate requires that 'Bool' conform to 'BinaryInteger' (requirement\
    \ specified as 'Self' : 'BinaryInteger')\npublic protocol BinaryInteger : CustomStringConvertible,\
    \ Hashable, Numeric, Strideable where Self.Magnitude : BinaryInteger, Self.Magnitude\
    \ == Self.Magnitude.Magnitude {\n                ^\n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        result += String(a_char ==\
    \ b_char ? \"0\" : \"1\")\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for (index, char) in a.characters.enumerated()\
    \ {\n        let a = char == \"0\" ? false : true\n        let b = b[index] ==\
    \ \"0\" ? false : true\n        result += a != b ? \"1\" : \"0\"\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp06andbm0.swift:8:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for (index, char) in a.characters.enumerated() {\n\
    \                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp06andbm0.swift:10:17: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        let\
    \ b = b[index] == \"0\" ? false : true\n                ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a = a.utf8.map { UInt8(bitPattern: $0) }\n \
    \   let b = b.utf8.map { UInt8(bitPattern: $0) }\n    let result = zip(a, b).map\
    \ { $0 ^ $1 }\n    return result.reduce(\"\") { $0 + String(format: \"%02x\",\
    \ $1) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp7la11_c1.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element'\
    \ (aka 'UInt8') to expected argument type 'Int8'\n    let a = a.utf8.map { UInt8(bitPattern:\
    \ $0) }\n                                           ^\n                      \
    \                     Int8( )\n/tmp/tmp7la11_c1.swift:8:44: error: cannot convert\
    \ value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type\
    \ 'Int8'\n    let b = b.utf8.map { UInt8(bitPattern: $0) }\n                 \
    \                          ^\n                                           Int8(\
    \ )\n/tmp/tmp7la11_c1.swift:10:43: error: incorrect argument labels in call (have\
    \ 'format:_:', expected 'repeating:count:')\n    return result.reduce(\"\") {\
    \ $0 + String(format: \"%02x\", $1) }\n                                      \
    \    ^~~~~~~\n                                           repeating       count:\
    \ \n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for (i, j) in zip(a, b) {\n\
    \        result += String(i ^ j)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp3t11h79y.swift:9:28: error: binary operator '^' cannot be applied\
    \ to two 'String.Element' (aka 'Character') operands\n        result += String(i\
    \ ^ j)\n                         ~ ^ ~\n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        result += \"\\(Int(String(a_char))!\
    \ ^ Int(String(b_char))!)\"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a = a.utf8.map { UInt8(bitPattern: $0) }\n \
    \   let b = b.utf8.map { UInt8(bitPattern: $0) }\n    let result = zip(a, b).map\
    \ { $0 ^ $1 }\n    return result.reduce(\"\") { $0 + String(format: \"%02x\",\
    \ $1) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp7la11_c1.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element'\
    \ (aka 'UInt8') to expected argument type 'Int8'\n    let a = a.utf8.map { UInt8(bitPattern:\
    \ $0) }\n                                           ^\n                      \
    \                     Int8( )\n/tmp/tmp7la11_c1.swift:8:44: error: cannot convert\
    \ value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type\
    \ 'Int8'\n    let b = b.utf8.map { UInt8(bitPattern: $0) }\n                 \
    \                          ^\n                                           Int8(\
    \ )\n/tmp/tmp7la11_c1.swift:10:43: error: incorrect argument labels in call (have\
    \ 'format:_:', expected 'repeating:count:')\n    return result.reduce(\"\") {\
    \ $0 + String(format: \"%02x\", $1) }\n                                      \
    \    ^~~~~~~\n                                           repeating       count:\
    \ \n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a = a.utf8.map { UInt8(bitPattern: $0) }\n \
    \   let b = b.utf8.map { UInt8(bitPattern: $0) }\n    let result = zip(a, b).map\
    \ { $0 ^ $1 }\n    return result.reduce(\"\") { $0 + String(UnicodeScalar(bitPattern:\
    \ $1)) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpew43g2r7.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element'\
    \ (aka 'UInt8') to expected argument type 'Int8'\n    let a = a.utf8.map { UInt8(bitPattern:\
    \ $0) }\n                                           ^\n                      \
    \                     Int8( )\n/tmp/tmpew43g2r7.swift:8:44: error: cannot convert\
    \ value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type\
    \ 'Int8'\n    let b = b.utf8.map { UInt8(bitPattern: $0) }\n                 \
    \                          ^\n                                           Int8(\
    \ )\n/tmp/tmpew43g2r7.swift:10:44: error: no exact matches in call to initializer\
    \ \n    return result.reduce(\"\") { $0 + String(UnicodeScalar(bitPattern: $1))\
    \ }\n                                           ^\n/tmp/tmpew43g2r7.swift:10:44:\
    \ note: found candidate with type '(UInt8) -> UnicodeScalar' (aka '(UInt8) ->\
    \ Unicode.Scalar')\n    return result.reduce(\"\") { $0 + String(UnicodeScalar(bitPattern:\
    \ $1)) }\n                                           ^\n/tmp/tmpew43g2r7.swift:10:44:\
    \ note: found candidate with type '(Unicode.Scalar) -> UnicodeScalar' (aka '(Unicode.Scalar)\
    \ -> Unicode.Scalar')\n    return result.reduce(\"\") { $0 + String(UnicodeScalar(bitPattern:\
    \ $1)) }\n                                           ^\n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        let a_int = Int(String(a_char))!\n\
    \        let b_int = Int(String(b_char))!\n        let xor = a_int ^ b_int\n \
    \       result += String(xor)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for (index, char) in a.characters.enumerated()\
    \ {\n        let a = char == \"0\" ? false : true\n        let b = b[index] ==\
    \ \"0\" ? false : true\n        result += a != b ? \"1\" : \"0\"\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp06andbm0.swift:8:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for (index, char) in a.characters.enumerated() {\n\
    \                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp06andbm0.swift:10:17: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        let\
    \ b = b[index] == \"0\" ? false : true\n                ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a_bytes = a.utf8.map { UInt8($0) }\n    let\
    \ b_bytes = b.utf8.map { UInt8($0) }\n    let xor_bytes = zip(a_bytes, b_bytes).map\
    \ { $0 ^ $1 }\n    let xor_string = xor_bytes.map { String($0, radix: 2) }.joined()\n\
    \    return xor_string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a = a.utf8.map { Int($0) - 48 }\n    let b =\
    \ b.utf8.map { Int($0) - 48 }\n    var result = \"\"\n    for i in 0..<a.count\
    \ {\n        result += String(a[i] ^ b[i])\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for (index, char) in a.characters.enumerated()\
    \ {\n        let a = Int(String(char))!\n        let b = Int(String(b[b.index(b.startIndex,\
    \ offsetBy: index)]))!\n        result += String(a ^ b)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp8ad6m02k.swift:8:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for (index, char) in a.characters.enumerated() {\n\
    \                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for (i, j) in zip(a, b) {\n\
    \        result += String(i != j ? \"1\" : \"0\")\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        result += String(a_char ==\
    \ b_char ? \"0\" : \"1\")\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        let a_int = Int(String(a_char))!\n\
    \        let b_int = Int(String(b_char))!\n        let xor = a_int ^ b_int\n \
    \       result.append(String(xor))\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        let a_int = Int(String(a_char))!\n\
    \        let b_int = Int(String(b_char))!\n        let xor = a_int ^ b_int\n \
    \       result.append(String(xor))\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        result += String(Int(String(a_char))!\
    \ ^ Int(String(b_char))!)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for (index, char) in a.characters.enumerated()\
    \ {\n        let a = char == \"0\" ? false : true\n        let b = b[index] ==\
    \ \"0\" ? false : true\n        result += a ^ b ? \"1\" : \"0\"\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpcurtiigq.swift:8:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for (index, char) in a.characters.enumerated() {\n\
    \                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpcurtiigq.swift:10:17: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        let\
    \ b = b[index] == \"0\" ? false : true\n                ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpcurtiigq.swift:11:21:\
    \ error: binary operator '^' cannot be applied to two 'Bool' operands\n      \
    \  result += a ^ b ? \"1\" : \"0\"\n                    ^\nSwift.BinaryInteger:1:17:\
    \ note: candidate requires that 'Bool' conform to 'BinaryInteger' (requirement\
    \ specified as 'Self' : 'BinaryInteger')\npublic protocol BinaryInteger : CustomStringConvertible,\
    \ Hashable, Numeric, Strideable where Self.Magnitude : BinaryInteger, Self.Magnitude\
    \ == Self.Magnitude.Magnitude {\n                ^\n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a_bytes = a.utf8.map { UInt8($0) }\n    let\
    \ b_bytes = b.utf8.map { UInt8($0) }\n    let xor_bytes = zip(a_bytes, b_bytes).map\
    \ { $0 ^ $1 }\n    return xor_bytes.map { String($0, radix: 2) }.joined()\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        let a_int = Int(String(a_char))!\n\
    \        let b_int = Int(String(b_char))!\n        result += String(a_int ^ b_int)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a_bytes = a.utf8.map { UInt8($0) }\n    let\
    \ b_bytes = b.utf8.map { UInt8($0) }\n    let xor_bytes = zip(a_bytes, b_bytes).map\
    \ { $0 ^ $1 }\n    return xor_bytes.map { String($0, radix: 2) }.joined()\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for (index, char) in a.characters.enumerated()\
    \ {\n        let a = char == \"0\" ? false : true\n        let b = b[index] ==\
    \ \"0\" ? false : true\n        result += a != b ? \"1\" : \"0\"\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp06andbm0.swift:8:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for (index, char) in a.characters.enumerated() {\n\
    \                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp06andbm0.swift:10:17: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        let\
    \ b = b[index] == \"0\" ? false : true\n                ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a_bytes = a.utf8.map { UInt8($0) }\n    let\
    \ b_bytes = b.utf8.map { UInt8($0) }\n    let xor_bytes = zip(a_bytes, b_bytes).map\
    \ { $0 ^ $1 }\n    return String(bytes: xor_bytes, encoding: .utf8)!\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpx1vpjue_.swift:10:12: error: no exact matches in call to initializer\
    \ \n    return String(bytes: xor_bytes, encoding: .utf8)!\n           ^\n/tmp/tmpx1vpjue_.swift:10:12:\
    \ note: found candidate with type '(Array<_>, _.Type) -> String'\n    return String(bytes:\
    \ xor_bytes, encoding: .utf8)!\n           ^\n/tmp/tmpx1vpjue_.swift:10:12: note:\
    \ found candidate with type '([UInt8]) -> String'\n    return String(bytes: xor_bytes,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmpx1vpjue_.swift:10:12: note: found candidate\
    \ with type '(Substring.UTF8View) -> String?'\n    return String(bytes: xor_bytes,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmpx1vpjue_.swift:10:12: note: found candidate\
    \ with type '(Substring.UTF16View) -> String?'\n    return String(bytes: xor_bytes,\
    \ encoding: .utf8)!\n           ^\n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a = a.utf8.map { UInt8(bitPattern: $0) }\n \
    \   let b = b.utf8.map { UInt8(bitPattern: $0) }\n    let result = zip(a, b).map\
    \ { $0 ^ $1 }\n    return result.reduce(\"\") { $0 + String(format: \"%02x\",\
    \ $1) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp7la11_c1.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element'\
    \ (aka 'UInt8') to expected argument type 'Int8'\n    let a = a.utf8.map { UInt8(bitPattern:\
    \ $0) }\n                                           ^\n                      \
    \                     Int8( )\n/tmp/tmp7la11_c1.swift:8:44: error: cannot convert\
    \ value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type\
    \ 'Int8'\n    let b = b.utf8.map { UInt8(bitPattern: $0) }\n                 \
    \                          ^\n                                           Int8(\
    \ )\n/tmp/tmp7la11_c1.swift:10:43: error: incorrect argument labels in call (have\
    \ 'format:_:', expected 'repeating:count:')\n    return result.reduce(\"\") {\
    \ $0 + String(format: \"%02x\", $1) }\n                                      \
    \    ^~~~~~~\n                                           repeating       count:\
    \ \n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        let a_int = Int(String(a_char))!\n\
    \        let b_int = Int(String(b_char))!\n        let c_int = a_int ^ b_int\n\
    \        result += String(c_int)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        let a_int = Int(String(a_char))!\n\
    \        let b_int = Int(String(b_char))!\n        let xor = a_int ^ b_int\n \
    \       result.append(String(xor))\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a = a.utf8.map { UInt8(bitPattern: $0) }\n \
    \   let b = b.utf8.map { UInt8(bitPattern: $0) }\n    let result = zip(a, b).map\
    \ { $0 ^ $1 }\n    return result.reduce(\"\") { $0 + String(format: \"%02x\",\
    \ $1) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp7la11_c1.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element'\
    \ (aka 'UInt8') to expected argument type 'Int8'\n    let a = a.utf8.map { UInt8(bitPattern:\
    \ $0) }\n                                           ^\n                      \
    \                     Int8( )\n/tmp/tmp7la11_c1.swift:8:44: error: cannot convert\
    \ value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type\
    \ 'Int8'\n    let b = b.utf8.map { UInt8(bitPattern: $0) }\n                 \
    \                          ^\n                                           Int8(\
    \ )\n/tmp/tmp7la11_c1.swift:10:43: error: incorrect argument labels in call (have\
    \ 'format:_:', expected 'repeating:count:')\n    return result.reduce(\"\") {\
    \ $0 + String(format: \"%02x\", $1) }\n                                      \
    \    ^~~~~~~\n                                           repeating       count:\
    \ \n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a = a.utf8.map { UInt8(bitPattern: $0) }\n \
    \   let b = b.utf8.map { UInt8(bitPattern: $0) }\n    let xor = zip(a, b).map\
    \ { $0 ^ $1 }\n    return xor.map { String(UnicodeScalar(UInt8(bitPattern: $0)))\
    \ }.joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpmqgnj2ws.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element'\
    \ (aka 'UInt8') to expected argument type 'Int8'\n    let a = a.utf8.map { UInt8(bitPattern:\
    \ $0) }\n                                           ^\n                      \
    \                     Int8( )\n/tmp/tmpmqgnj2ws.swift:8:44: error: cannot convert\
    \ value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type\
    \ 'Int8'\n    let b = b.utf8.map { UInt8(bitPattern: $0) }\n                 \
    \                          ^\n                                           Int8(\
    \ )\n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        result += String(Int(String(a_char))!\
    \ ^ Int(String(b_char))!)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        let a_int = Int(String(a_char))!\n\
    \        let b_int = Int(String(b_char))!\n        result += String(a_int ^ b_int)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a = a.utf8.map { Int($0) - 48 }\n    let b =\
    \ b.utf8.map { Int($0) - 48 }\n    var result = \"\"\n    for i in 0..<a.count\
    \ {\n        result += String(a[i] ^ b[i])\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a_bin = a.utf8.map { Int($0) - 48 }\n    let\
    \ b_bin = b.utf8.map { Int($0) - 48 }\n    let xor_bin = zip(a_bin, b_bin).map\
    \ { $0 != $1 ? 1 : 0 }\n    return xor_bin.map { String($0) }.joined()\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        let a_int = Int(String(a_char))!\n\
    \        let b_int = Int(String(b_char))!\n        result += String(a_int ^ b_int)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        if a[i] == b[i] {\n            result += \"0\"\n        } else {\n  \
    \          result += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp24t9xf_1.swift:9:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] ==\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp24t9xf_1.swift:9:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] == b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        result += String(Int(String(a_char))!\
    \ ^ Int(String(b_char))!)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for (index, char) in a.enumerated()\
    \ {\n        let a = Int(String(char))!\n        let b = Int(String(b[b.index(b.startIndex,\
    \ offsetBy: index)]))!\n        result += String(a ^ b)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        result += String(Int(String(a_char))!\
    \ ^ Int(String(b_char))!)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_i = a[a.index(a.startIndex, offsetBy: i)]\n        let b_i = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_i == b_i {\n            result += \"0\"\n      \
    \  } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_index = a.index(a.startIndex, offsetBy: i)\n        let b_index\
    \ = b.index(b.startIndex, offsetBy: i)\n        let a_char = a[a_index]\n    \
    \    let b_char = b[b_index]\n        if a_char == b_char {\n            result\
    \ += \"0\"\n        } else {\n            result += \"1\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    return String(zip(a, b).map { $0 == $1 ? \"0\" :\
    \ \"1\" })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a = a.utf8.map { UInt8(bitPattern: $0) }\n \
    \   let b = b.utf8.map { UInt8(bitPattern: $0) }\n    let c = zip(a, b).map {\
    \ $0 ^ $1 }\n    return c.map { String(UnicodeScalar(UInt8(bitPattern: $0))) }.joined()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpzp7rk339.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element'\
    \ (aka 'UInt8') to expected argument type 'Int8'\n    let a = a.utf8.map { UInt8(bitPattern:\
    \ $0) }\n                                           ^\n                      \
    \                     Int8( )\n/tmp/tmpzp7rk339.swift:8:44: error: cannot convert\
    \ value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type\
    \ 'Int8'\n    let b = b.utf8.map { UInt8(bitPattern: $0) }\n                 \
    \                          ^\n                                           Int8(\
    \ )\n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        result += String(Int(String(a_char))!\
    \ ^ Int(String(b_char))!)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        result += String(a_char ==\
    \ b_char ? \"0\" : \"1\")\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a = a.utf8.map { UInt8(bitPattern: $0) }\n \
    \   let b = b.utf8.map { UInt8(bitPattern: $0) }\n    let result = zip(a, b).map\
    \ { $0 ^ $1 }\n    return result.reduce(\"\") { $0 + String(format: \"%02x\",\
    \ $1) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp7la11_c1.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element'\
    \ (aka 'UInt8') to expected argument type 'Int8'\n    let a = a.utf8.map { UInt8(bitPattern:\
    \ $0) }\n                                           ^\n                      \
    \                     Int8( )\n/tmp/tmp7la11_c1.swift:8:44: error: cannot convert\
    \ value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type\
    \ 'Int8'\n    let b = b.utf8.map { UInt8(bitPattern: $0) }\n                 \
    \                          ^\n                                           Int8(\
    \ )\n/tmp/tmp7la11_c1.swift:10:43: error: incorrect argument labels in call (have\
    \ 'format:_:', expected 'repeating:count:')\n    return result.reduce(\"\") {\
    \ $0 + String(format: \"%02x\", $1) }\n                                      \
    \    ^~~~~~~\n                                           repeating       count:\
    \ \n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for (index, char) in a.characters.enumerated()\
    \ {\n        let a_bit = char == \"1\" ? 1 : 0\n        let b_bit = b[b.index(b.startIndex,\
    \ offsetBy: index)] == \"1\" ? 1 : 0\n        result += String(a_bit ^ b_bit)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpuyzc1ccw.swift:8:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for (index, char) in a.characters.enumerated() {\n\
    \                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a_bytes = a.utf8.map { UInt8($0) }\n    let\
    \ b_bytes = b.utf8.map { UInt8($0) }\n    let result_bytes = zip(a_bytes, b_bytes).map\
    \ { $0 ^ $1 }\n    return result_bytes.map { String($0, radix: 2) }.joined()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for (i, j) in zip(a, b) {\n\
    \        result += String(Int(String(i))! ^ Int(String(j))!)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a_bytes = a.utf8.map { UInt8($0) }\n    let\
    \ b_bytes = b.utf8.map { UInt8($0) }\n    let xor_bytes = zip(a_bytes, b_bytes).map\
    \ { $0 ^ $1 }\n    return String(bytes: xor_bytes, encoding: .utf8)!\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpx1vpjue_.swift:10:12: error: no exact matches in call to initializer\
    \ \n    return String(bytes: xor_bytes, encoding: .utf8)!\n           ^\n/tmp/tmpx1vpjue_.swift:10:12:\
    \ note: found candidate with type '(Array<_>, _.Type) -> String'\n    return String(bytes:\
    \ xor_bytes, encoding: .utf8)!\n           ^\n/tmp/tmpx1vpjue_.swift:10:12: note:\
    \ found candidate with type '([UInt8]) -> String'\n    return String(bytes: xor_bytes,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmpx1vpjue_.swift:10:12: note: found candidate\
    \ with type '(Substring.UTF8View) -> String?'\n    return String(bytes: xor_bytes,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmpx1vpjue_.swift:10:12: note: found candidate\
    \ with type '(Substring.UTF16View) -> String?'\n    return String(bytes: xor_bytes,\
    \ encoding: .utf8)!\n           ^\n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a_bytes = a.utf8.map { $0 }\n    let b_bytes\
    \ = b.utf8.map { $0 }\n    let c_bytes = zip(a_bytes, b_bytes).map { $0 ^ $1 }\n\
    \    return String(bytes: c_bytes, encoding: .utf8)!\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp8mroa_mp.swift:10:12: error: no exact matches in call to initializer\
    \ \n    return String(bytes: c_bytes, encoding: .utf8)!\n           ^\n/tmp/tmp8mroa_mp.swift:10:12:\
    \ note: found candidate with type '(Array<_>, _.Type) -> String'\n    return String(bytes:\
    \ c_bytes, encoding: .utf8)!\n           ^\n/tmp/tmp8mroa_mp.swift:10:12: note:\
    \ found candidate with type '([UInt8]) -> String'\n    return String(bytes: c_bytes,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmp8mroa_mp.swift:10:12: note: found candidate\
    \ with type '(Substring.UTF8View) -> String?'\n    return String(bytes: c_bytes,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmp8mroa_mp.swift:10:12: note: found candidate\
    \ with type '(Substring.UTF16View) -> String?'\n    return String(bytes: c_bytes,\
    \ encoding: .utf8)!\n           ^\n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a = a.utf8.map { Int($0) - 48 }\n    let b =\
    \ b.utf8.map { Int($0) - 48 }\n    let result = zip(a, b).map { $0 ^ $1 }\n  \
    \  return result.map { String($0) }.joined()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a_bytes = a.utf8.map { UInt8($0) }\n    let\
    \ b_bytes = b.utf8.map { UInt8($0) }\n    let result = zip(a_bytes, b_bytes).map\
    \ { $0 ^ $1 }\n    return result.map { String($0, radix: 2) }.joined()\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a = a.utf8.map { UInt8(bitPattern: $0) }\n \
    \   let b = b.utf8.map { UInt8(bitPattern: $0) }\n    let result = zip(a, b).map\
    \ { $0 ^ $1 }\n    return result.reduce(\"\") { $0 + String(format: \"%02x\",\
    \ $1) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp7la11_c1.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element'\
    \ (aka 'UInt8') to expected argument type 'Int8'\n    let a = a.utf8.map { UInt8(bitPattern:\
    \ $0) }\n                                           ^\n                      \
    \                     Int8( )\n/tmp/tmp7la11_c1.swift:8:44: error: cannot convert\
    \ value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type\
    \ 'Int8'\n    let b = b.utf8.map { UInt8(bitPattern: $0) }\n                 \
    \                          ^\n                                           Int8(\
    \ )\n/tmp/tmp7la11_c1.swift:10:43: error: incorrect argument labels in call (have\
    \ 'format:_:', expected 'repeating:count:')\n    return result.reduce(\"\") {\
    \ $0 + String(format: \"%02x\", $1) }\n                                      \
    \    ^~~~~~~\n                                           repeating       count:\
    \ \n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for (i, j) in zip(a, b) {\n\
    \        if i == j {\n            result.append(\"0\")\n        } else {\n   \
    \         result.append(\"1\")\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        let a_int = Int(String(a_char))!\n\
    \        let b_int = Int(String(b_char))!\n        let res_int = a_int ^ b_int\n\
    \        result += String(res_int)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        result += a[i] == b[i] ? \"0\" : \"1\"\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp8x7lflaq.swift:9:19: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        result +=\
    \ a[i] == b[i] ? \"0\" : \"1\"\n                  ^~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmp8x7lflaq.swift:9:27: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        result += a[i] == b[i] ? \"0\" : \"1\"\n                 \
    \         ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked\
    \ unavailable here\n    public subscript(i: Int) -> Character { get }\n      \
    \     ^\n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        result += String(Int(String(a_char))!\
    \ ^ Int(String(b_char))!)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a = Array(a)\n    let b = Array(b)\n    let\
    \ result = zip(a, b).map { $0 == $1 ? \"0\" : \"1\" }\n    return String(result)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpuoq20ivy.swift:10:12: error: no exact matches in call to initializer\
    \ \n    return String(result)\n           ^\nSwift.String:4:12: note: candidate\
    \ requires that the types 'String' and 'Character' be equivalent (requirement\
    \ specified as 'S.Element' == 'Character')\n    public init<S>(_ characters: S)\
    \ where S : Sequence, S.Element == Character\n           ^\nSwift.RangeReplaceableCollection:3:23:\
    \ note: candidate requires that the types 'String.Element' (aka 'Character') and\
    \ 'String' be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n\
    \    @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element\
    \ == S.Element\n                      ^\nSwift.String:2:12: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(describing:)')\n    public init<Subject>(describing\
    \ instance: Subject)\n           ^\nSwift.String:3:23: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(describing:)')\n    @inlinable public\
    \ init<Subject>(describing instance: Subject) where Subject : CustomStringConvertible\n\
    \                      ^\nSwift.String:6:12: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(reflecting:)')\n    public init<Subject>(reflecting\
    \ subject: Subject)\n           ^\n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a = a[a.index(a.startIndex, offsetBy: i)]\n        let b = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        result += String(a ^ b)\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpe6f5xtei.swift:11:28: error: binary operator '^' cannot be applied\
    \ to two 'Character' operands\n        result += String(a ^ b)\n             \
    \            ~ ^ ~\n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        result += String(Int(String(a_char))!\
    \ ^ Int(String(b_char))!)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for (index, char) in a.characters.enumerated()\
    \ {\n        let a = Int(String(char))!\n        let b = Int(String(b[b.index(b.startIndex,\
    \ offsetBy: index)]))!\n        result += String(a ^ b)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp8ad6m02k.swift:8:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for (index, char) in a.characters.enumerated() {\n\
    \                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a_bytes = a.utf8.map { UInt8($0) }\n    let\
    \ b_bytes = b.utf8.map { UInt8($0) }\n    let xor_bytes = zip(a_bytes, b_bytes).map\
    \ { $0 ^ $1 }\n    return String(bytes: xor_bytes, encoding: .utf8)!\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpx1vpjue_.swift:10:12: error: no exact matches in call to initializer\
    \ \n    return String(bytes: xor_bytes, encoding: .utf8)!\n           ^\n/tmp/tmpx1vpjue_.swift:10:12:\
    \ note: found candidate with type '(Array<_>, _.Type) -> String'\n    return String(bytes:\
    \ xor_bytes, encoding: .utf8)!\n           ^\n/tmp/tmpx1vpjue_.swift:10:12: note:\
    \ found candidate with type '([UInt8]) -> String'\n    return String(bytes: xor_bytes,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmpx1vpjue_.swift:10:12: note: found candidate\
    \ with type '(Substring.UTF8View) -> String?'\n    return String(bytes: xor_bytes,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmpx1vpjue_.swift:10:12: note: found candidate\
    \ with type '(Substring.UTF16View) -> String?'\n    return String(bytes: xor_bytes,\
    \ encoding: .utf8)!\n           ^\n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        result += String(a_char ==\
    \ b_char ? \"0\" : \"1\")\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for (index, char) in a.enumerated()\
    \ {\n        if char == \"0\" {\n            if b[b.index(b.startIndex, offsetBy:\
    \ index)] == \"0\" {\n                result += \"0\"\n            } else {\n\
    \                result += \"1\"\n            }\n        } else {\n          \
    \  if b[b.index(b.startIndex, offsetBy: index)] == \"0\" {\n                result\
    \ += \"1\"\n            } else {\n                result += \"0\"\n          \
    \  }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        let a_int = Int(String(a_char))!\n\
    \        let b_int = Int(String(b_char))!\n        result += String(a_int ^ b_int)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        result += String(Int(String(a_char))!\
    \ ^ Int(String(b_char))!)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a_bytes = a.utf8.map { UInt8($0) }\n    let\
    \ b_bytes = b.utf8.map { UInt8($0) }\n    let xor_bytes = zip(a_bytes, b_bytes).map\
    \ { $0 ^ $1 }\n    return xor_bytes.map { String($0, radix: 2) }.joined()\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for (i, char) in a.characters.enumerated()\
    \ {\n        let a = char == \"1\"\n        let b = b[b.index(b.startIndex, offsetBy:\
    \ i)] == \"1\"\n        result += a != b ? \"1\" : \"0\"\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp3oy340kk.swift:8:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for (i, char) in a.characters.enumerated() {\n    \
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        let a_int = Int(String(a_char))!\n\
    \        let b_int = Int(String(b_char))!\n        result += String(a_int ^ b_int)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n   \
    \         result += \"0\"\n        } else {\n            result += \"1\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        result += String(a_char ==\
    \ b_char ? \"0\" : \"1\")\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824333
