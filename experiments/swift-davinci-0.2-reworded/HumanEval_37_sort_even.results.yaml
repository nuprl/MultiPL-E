language: swift
name: HumanEval_37_sort_even
results:
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    for\
    \ i in stride(from: 0, to: l.count, by: 2) {\n        l[i] = l[i..<l.count].sorted()[0]\n\
    \    }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l:\
    \ [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmp_gta00bc/tmp_gta00bc.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad808fb8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad808cafb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad808caf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad808cae7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_gta00bc                        0x000055aac95e6ab3 <unavailable> + 6835

    5    libc.so.6                          0x00002ad8091a4460 __libc_start_main +
    245

    6    tmp_gta00bc                        0x000055aac95e6509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n      \
    \  evens.append(l[i])\n    }\n    evens.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = evens[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_prime = l\n \
    \   var even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2\
    \ == 0 {\n            even_indicies.append(i)\n        }\n    }\n    var even_values\
    \ = [Int]()\n    for i in even_indicies {\n        even_values.append(l[i])\n\
    \    }\n    even_values.sort()\n    for i in 0..<even_indicies.count {\n     \
    \   l_prime[even_indicies[i]] = even_values[i]\n    }\n    return l_prime\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_even = [Int]()\n\
    \    var l_odd = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n\
    \            l_even.append(l[i])\n        } else {\n            l_odd.append(l[i])\n\
    \        }\n    }\n    l_even.sort()\n    var l_new = [Int]()\n    for i in 0..<l.count\
    \ {\n        if i % 2 == 0 {\n            l_new.append(l_even[i/2])\n        }\
    \ else {\n            l_new.append(l_odd[i/2])\n        }\n    }\n    return l_new\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ i = 0\n    while i < l.count {\n        if i % 2 == 0 {\n            var j =\
    \ i + 1\n            while j < l.count {\n                if l[j] < l[i] {\n \
    \                   let temp = l[i]\n                    l[i] = l[j]\n       \
    \             l[j] = temp\n                }\n                j += 1\n       \
    \     }\n        }\n        i += 1\n    }\n    return l\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmp_6a_cc4f/tmp_6a_cc4f.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b182e2aec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b182dfa5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b182dfa5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b182dfa47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_6a_cc4f                        0x000056382b25d713 <unavailable> + 5907

    5    libc.so.6                          0x00002b182e49a460 __libc_start_main +
    245

    6    tmp_6a_cc4f                        0x000056382b25d169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n\
    \            even_indicies.append(i)\n        }\n    }\n    for i in 0..<even_indicies.count\
    \ {\n        for j in 0..<even_indicies.count {\n            if l[even_indicies[i]]\
    \ < l[even_indicies[j]] {\n                let temp = l[even_indicies[i]]\n  \
    \              l[even_indicies[i]] = l[even_indicies[j]]\n                l[even_indicies[j]]\
    \ = temp\n            }\n        }\n    }\n    return l\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_even = [Int]()\n\
    \    var l_odd = [Int]()\n    for (index, value) in l.enumerated() {\n       \
    \ if index % 2 == 0 {\n            l_even.append(value)\n        } else {\n  \
    \          l_odd.append(value)\n        }\n    }\n    l_even.sort()\n    var l_new\
    \ = [Int]()\n    for (index, value) in l_even.enumerated() {\n        l_new.append(value)\n\
    \        if index < l_odd.count {\n            l_new.append(l_odd[index])\n  \
    \      }\n    }\n    return l_new\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l:\
    \ [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even_indicies: [Int] = []\n    for i in 0..<l.count {\n        if i % 2 == 0\
    \ {\n            even_indicies.append(i)\n        }\n    }\n    for i in 0..<even_indicies.count\
    \ {\n        for j in 0..<even_indicies.count - 1 {\n            if l[even_indicies[j]]\
    \ > l[even_indicies[j + 1]] {\n                let temp = l[even_indicies[j]]\n\
    \                l[even_indicies[j]] = l[even_indicies[j + 1]]\n             \
    \   l[even_indicies[j + 1]] = temp\n            }\n        }\n    }\n    return\
    \ l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1,\
    \ 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    for\
    \ i in stride(from: 0, to: l.count, by: 2) {\n        for j in stride(from: i\
    \ + 2, to: l.count, by: 2) {\n            if l[i] > l[j] {\n                let\
    \ temp = l[i]\n                l[i] = l[j]\n                l[j] = temp\n    \
    \        }\n        }\n    }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3,\
    \ -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    assert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var new_l = l\n   \
    \ var even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2 ==\
    \ 0 {\n            even_indicies.append(i)\n        }\n    }\n    for i in even_indicies\
    \ {\n        new_l[i] = l[i]\n    }\n    return new_l\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmp5c2xa2dd/tmp5c2xa2dd.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4af2d84c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4af2a7bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4af2a7b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4af2a7a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5c2xa2dd                        0x00005595cdfcea13 <unavailable> + 6675

    5    libc.so.6                          0x00002b4af2f70460 __libc_start_main +
    245

    6    tmp5c2xa2dd                        0x00005595cdfce469 <unavailable> + 5225

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n\
    \            even_indicies.append(i)\n        }\n    }\n    for i in 0..<even_indicies.count\
    \ {\n        for j in i..<even_indicies.count {\n            if l[even_indicies[i]]\
    \ > l[even_indicies[j]] {\n                l.swapAt(even_indicies[i], even_indicies[j])\n\
    \            }\n        }\n    }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3,\
    \ -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    assert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_prime = l\n \
    \   var even_indicies = [Int]()\n    for (index, value) in l.enumerated() {\n\
    \        if index % 2 == 0 {\n            even_indicies.append(value)\n      \
    \  }\n    }\n    even_indicies.sort()\n    for (index, value) in l.enumerated()\
    \ {\n        if index % 2 == 0 {\n            l_prime[index] = even_indicies[index/2]\n\
    \        }\n    }\n    return l_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2,\
    \ -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l:\
    \ [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n      \
    \  evens.append(l[i])\n    }\n    evens.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = evens[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_even = [Int]()\n\
    \    var l_odd = [Int]()\n    var l_sorted = [Int]()\n    for (index, value) in\
    \ l.enumerated() {\n        if index % 2 == 0 {\n            l_even.append(value)\n\
    \        } else {\n            l_odd.append(value)\n        }\n    }\n    l_even.sort()\n\
    \    for (index, value) in l_even.enumerated() {\n        l_sorted.append(value)\n\
    \        l_sorted.append(l_odd[index])\n    }\n    return l_sorted\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3ed8fa6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3ed8c9d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3ed8c9d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3ed8c9d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3ed8c9cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3ed8a9ce83 <unavailable> + 188035

    6    tmphckdnyhc                        0x000055f2a6285071 <unavailable> + 8305

    7    tmphckdnyhc                        0x000055f2a62847b4 <unavailable> + 6068

    8    libc.so.6                          0x00002b3ed9192460 __libc_start_main +
    245

    9    tmphckdnyhc                        0x000055f2a6284499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_prime = l\n \
    \   var even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2\
    \ == 0 {\n            even_indicies.append(i)\n        }\n    }\n    var even_values\
    \ = [Int]()\n    for i in even_indicies {\n        even_values.append(l[i])\n\
    \    }\n    even_values.sort()\n    for i in 0..<even_indicies.count {\n     \
    \   l_prime[even_indicies[i]] = even_values[i]\n    }\n    return l_prime\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_prime = l\n \
    \   var even_indicies: [Int] = []\n    for i in 0..<l.count {\n        if i %\
    \ 2 == 0 {\n            even_indicies.append(i)\n        }\n    }\n    for i in\
    \ even_indicies {\n        l_prime[i] = l[i]\n    }\n    return l_prime\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmp7ru85kry/tmp7ru85kry.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f0abd6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f0a8cdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8f0a8cd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8f0a8cc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7ru85kry                        0x000055fcb370b9c3 <unavailable> + 6595

    5    libc.so.6                          0x00002b8f0adc2460 __libc_start_main +
    245

    6    tmp7ru85kry                        0x000055fcb370b419 <unavailable> + 5145

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_even = [Int]()\n\
    \    var l_odd = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n\
    \            l_even.append(l[i])\n        } else {\n            l_odd.append(l[i])\n\
    \        }\n    }\n    l_even.sort()\n    var l_new = [Int]()\n    for i in 0..<l.count\
    \ {\n        if i % 2 == 0 {\n            l_new.append(l_even[i/2])\n        }\
    \ else {\n            l_new.append(l_odd[i/2])\n        }\n    }\n    return l_new\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_copy = l\n  \
    \  var even_indicies: [Int] = []\n    for i in 0..<l.count {\n        if i % 2\
    \ == 0 {\n            even_indicies.append(i)\n        }\n    }\n    for i in\
    \ 0..<even_indicies.count {\n        for j in 0..<even_indicies.count - 1 {\n\
    \            if l_copy[even_indicies[j]] > l_copy[even_indicies[j + 1]] {\n  \
    \              let temp = l_copy[even_indicies[j]]\n                l_copy[even_indicies[j]]\
    \ = l_copy[even_indicies[j + 1]]\n                l_copy[even_indicies[j + 1]]\
    \ = temp\n            }\n        }\n    }\n    return l_copy\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    var odds = [Int]()\n    var evens_sorted = [Int]()\n  \
    \  var l_prime = [Int]()\n    \n    for i in 0..<l.count {\n        if i % 2 ==\
    \ 0 {\n            odds.append(l[i])\n        } else {\n            evens.append(l[i])\n\
    \        }\n    }\n    \n    evens_sorted = evens.sorted()\n    \n    for i in\
    \ 0..<l.count {\n        if i % 2 == 0 {\n            l_prime.append(odds[i/2])\n\
    \        } else {\n            l_prime.append(evens_sorted[i/2])\n        }\n\
    \    }\n    \n    return l_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l:\
    \ [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmpq52fcjvm/tmpq52fcjvm.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5aaa548c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5aaa23fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5aaa23f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5aaa23e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq52fcjvm                        0x000055a9e2ff1903 <unavailable> + 6403

    5    libc.so.6                          0x00002b5aaa734460 __libc_start_main +
    245

    6    tmpq52fcjvm                        0x000055a9e2ff1359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n\
    \            even_indicies.append(i)\n        }\n    }\n    for i in 0..<even_indicies.count\
    \ {\n        for j in 0..<even_indicies.count - 1 {\n            if l[even_indicies[j]]\
    \ > l[even_indicies[j + 1]] {\n                let temp = l[even_indicies[j]]\n\
    \                l[even_indicies[j]] = l[even_indicies[j + 1]]\n             \
    \   l[even_indicies[j + 1]] = temp\n            }\n        }\n    }\n    return\
    \ l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1,\
    \ 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_copy = l\n  \
    \  var even_indicies: [Int] = []\n    var odd_indicies: [Int] = []\n    var even_values:\
    \ [Int] = []\n    var odd_values: [Int] = []\n    for i in 0..<l.count {\n   \
    \     if i % 2 == 0 {\n            even_indicies.append(i)\n            even_values.append(l[i])\n\
    \        } else {\n            odd_indicies.append(i)\n            odd_values.append(l[i])\n\
    \        }\n    }\n    even_values.sort()\n    for i in 0..<even_indicies.count\
    \ {\n        l_copy[even_indicies[i]] = even_values[i]\n    }\n    return l_copy\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    var odds = [Int]()\n    for (i, v) in l.enumerated() {\n\
    \        if i % 2 == 0 {\n            odds.append(v)\n        } else {\n     \
    \       evens.append(v)\n        }\n    }\n    evens.sort()\n    for (i, v) in\
    \ evens.enumerated() {\n        l[i * 2 + 1] = v\n    }\n    return l\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmpcjpg58dl/tmpcjpg58dl.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac32d0a5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac32cd9cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac32cd9c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac32cd9b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcjpg58dl                        0x000055892ae56a43 <unavailable> + 6723

    5    libc.so.6                          0x00002ac32d291460 __libc_start_main +
    245

    6    tmpcjpg58dl                        0x000055892ae56499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_prime = l\n \
    \   var evens = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n\
    \            evens.append(l[i])\n        }\n    }\n    evens.sort()\n    for i\
    \ in 0..<l.count {\n        if i % 2 == 0 {\n            l_prime[i] = evens[i/2]\n\
    \        }\n    }\n    return l_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2,\
    \ -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l:\
    \ [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    for\
    \ i in stride(from: 0, to: l.count, by: 2) {\n        for j in stride(from: i\
    \ + 2, to: l.count, by: 2) {\n            if l[i] > l[j] {\n                let\
    \ temp = l[i]\n                l[i] = l[j]\n                l[j] = temp\n    \
    \        }\n        }\n    }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3,\
    \ -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    assert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n      \
    \  evens.append(l[i])\n    }\n    evens.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = evens[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    for\
    \ i in stride(from: 0, to: l.count, by: 2) {\n        l[i] = l[i].sorted()\n \
    \   }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2,\
    \ 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: SyntaxError
  stderr: "/tmp/tmp8za9fac_.swift:12:21: error: value of type 'Int' has no member\
    \ 'sorted'\n        l[i] = l[i].sorted()\n               ~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_prime = l\n \
    \   let even_indicies = l.indices.filter { $0 % 2 == 0 }\n    for i in even_indicies\
    \ {\n        let even_slice = l[i...i+1]\n        l_prime[i...i+1] = even_slice.sorted()\n\
    \    }\n    return l_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l:\
    \ [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: SyntaxError
  stderr: "/tmp/tmpnqaz17i1.swift:14:39: error: cannot assign value of type '[Int]'\
    \ to subscript of type 'ArraySlice<Int>'\n        l_prime[i...i+1] = even_slice.sorted()\n\
    \                           ~~~~~~~~~~~^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens: [Int] = []\n    for (index, value) in l.enumerated() {\n        if index\
    \ % 2 == 0 {\n            evens.append(value)\n        }\n    }\n    evens.sort()\n\
    \    for (index, value) in l.enumerated() {\n        if index % 2 == 0 {\n   \
    \         l[index] = evens[0]\n            evens.remove(at: 0)\n        }\n  \
    \  }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2,\
    \ 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_even = [Int]()\n\
    \    var l_odd = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n\
    \            l_even.append(l[i])\n        } else {\n            l_odd.append(l[i])\n\
    \        }\n    }\n    l_even.sort()\n    var l_new = [Int]()\n    for i in 0..<l.count\
    \ {\n        if i % 2 == 0 {\n            l_new.append(l_even[i/2])\n        }\
    \ else {\n            l_new.append(l_odd[i/2])\n        }\n    }\n    return l_new\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n       \
    \ even.append(l[i])\n    }\n    even.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = even[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even_indicies = [Int]()\n    var even_values = [Int]()\n    for i in 0..<l.count\
    \ {\n        if i % 2 == 0 {\n            even_indicies.append(i)\n          \
    \  even_values.append(l[i])\n        }\n    }\n    even_values.sort()\n    for\
    \ i in 0..<even_indicies.count {\n        l[even_indicies[i]] = even_values[i]\n\
    \    }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l:\
    \ [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_prime = l\n \
    \   var even_indicies = [Int]()\n    var even_values = [Int]()\n    for i in 0..<l.count\
    \ {\n        if i % 2 == 0 {\n            even_indicies.append(i)\n          \
    \  even_values.append(l[i])\n        }\n    }\n    even_values.sort()\n    for\
    \ i in 0..<even_indicies.count {\n        l_prime[even_indicies[i]] = even_values[i]\n\
    \    }\n    return l_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l:\
    \ [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_prime = l\n \
    \   for i in stride(from: 0, to: l.count, by: 2) {\n        l_prime[i] = l[i]\n\
    \        l_prime[i+1] = l[i+1]\n        if l[i] > l[i+1] {\n            l_prime[i]\
    \ = l[i+1]\n            l_prime[i+1] = l[i]\n        }\n    }\n    return l_prime\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b4632e78c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4632b6f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b4632b6f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b4632b6f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4632b6ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b463296ee83 <unavailable> + 188035

    6    tmp47fcmsv8                        0x0000562ab3429c66 <unavailable> + 7270

    7    tmp47fcmsv8                        0x0000562ab34295f4 <unavailable> + 5620

    8    libc.so.6                          0x00002b4633064460 __libc_start_main +
    245

    9    tmp47fcmsv8                        0x0000562ab34292d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n      \
    \  evens.append(l[i])\n    }\n    evens.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = evens[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var evens = [Int]()\n\
    \    var odds = [Int]()\n    var result = [Int]()\n    for (index, value) in l.enumerated()\
    \ {\n        if index % 2 == 0 {\n            odds.append(value)\n        } else\
    \ {\n            evens.append(value)\n        }\n    }\n    evens.sort()\n   \
    \ for (index, value) in odds.enumerated() {\n        result.append(value)\n  \
    \      result.append(evens[index])\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7fb16a0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7fb1397561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b7fb1397286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b7fb139713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b7fb1396bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b7fb1196e83 <unavailable> + 188035

    6    tmpzmkc2ue1                        0x000055ce6e6e4071 <unavailable> + 8305

    7    tmpzmkc2ue1                        0x000055ce6e6e37b4 <unavailable> + 6068

    8    libc.so.6                          0x00002b7fb188c460 __libc_start_main +
    245

    9    tmpzmkc2ue1                        0x000055ce6e6e3499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even = [Int]()\n    var odd = [Int]()\n    for i in 0..<l.count {\n        if\
    \ i % 2 == 0 {\n            even.append(l[i])\n        } else {\n            odd.append(l[i])\n\
    \        }\n    }\n    even.sort()\n    for i in 0..<even.count {\n        l[2*i]\
    \ = even[i]\n    }\n    for i in 0..<odd.count {\n        l[2*i+1] = odd[i]\n\
    \    }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l:\
    \ [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n      \
    \  evens.append(l[i])\n    }\n    evens.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = evens[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n      \
    \  evens.append(l[i])\n    }\n    evens.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = evens[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    var odds = [Int]()\n    for (index, value) in l.enumerated()\
    \ {\n        if index % 2 == 0 {\n            odds.append(value)\n        } else\
    \ {\n            evens.append(value)\n        }\n    }\n    evens.sort()\n   \
    \ for (index, value) in evens.enumerated() {\n        l[index * 2 + 1] = value\n\
    \    }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l:\
    \ [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmpy8ajq6av/tmpy8ajq6av.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b677613ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6775e31b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6775e31988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6775e307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy8ajq6av                        0x0000562a3fd4ca43 <unavailable> + 6723

    5    libc.so.6                          0x00002b6776326460 __libc_start_main +
    245

    6    tmpy8ajq6av                        0x0000562a3fd4c499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n\
    \            even_indicies.append(i)\n        }\n    }\n    for i in even_indicies\
    \ {\n        for j in even_indicies {\n            if l[i] < l[j] {\n        \
    \        l.swapAt(i, j)\n            }\n        }\n    }\n    return l\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_prime = l\n \
    \   var even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2\
    \ == 0 {\n            even_indicies.append(i)\n        }\n    }\n    var even_values\
    \ = [Int]()\n    for i in even_indicies {\n        even_values.append(l[i])\n\
    \    }\n    even_values.sort()\n    for i in 0..<even_indicies.count {\n     \
    \   l_prime[even_indicies[i]] = even_values[i]\n    }\n    return l_prime\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_copy = l\n  \
    \  var even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2 ==\
    \ 0 {\n            even_indicies.append(i)\n        }\n    }\n    for i in 0..<even_indicies.count\
    \ {\n        for j in 0..<even_indicies.count - 1 {\n            if l_copy[even_indicies[j]]\
    \ > l_copy[even_indicies[j + 1]] {\n                let temp = l_copy[even_indicies[j]]\n\
    \                l_copy[even_indicies[j]] = l_copy[even_indicies[j + 1]]\n   \
    \             l_copy[even_indicies[j + 1]] = temp\n            }\n        }\n\
    \    }\n    return l_copy\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l:\
    \ [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_prime = l\n \
    \   var even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2\
    \ == 0 {\n            even_indicies.append(i)\n        }\n    }\n    var even_values\
    \ = [Int]()\n    for i in even_indicies {\n        even_values.append(l[i])\n\
    \    }\n    even_values.sort()\n    for i in 0..<even_indicies.count {\n     \
    \   l_prime[even_indicies[i]] = even_values[i]\n    }\n    return l_prime\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n     \
    \       evens.append(l[i])\n        }\n    }\n    evens.sort()\n    for i in 0..<l.count\
    \ {\n        if i % 2 == 0 {\n            l[i] = evens[i/2]\n        }\n    }\n\
    \    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2,\
    \ 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens: [Int] = []\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n   \
    \         evens.append(l[i])\n        }\n    }\n    evens.sort()\n    for i in\
    \ 0..<l.count {\n        if i % 2 == 0 {\n            l[i] = evens[i/2]\n    \
    \    }\n    }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l:\
    \ [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_copy = l\n  \
    \  var even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2 ==\
    \ 0 {\n            even_indicies.append(i)\n        }\n    }\n    for i in even_indicies\
    \ {\n        l_copy[i] = l[i].sorted()\n    }\n    return l_copy\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: SyntaxError
  stderr: "/tmp/tmpixixcyzs.swift:18:26: error: value of type 'Int' has no member\
    \ 'sorted'\n        l_copy[i] = l[i].sorted()\n                    ~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n       \
    \ even.append(l[i])\n    }\n    even.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = even[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    for\
    \ i in stride(from: 0, to: l.count, by: 2) {\n        l[i] = l[i...i+1].sorted()[0]\n\
    \    }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l:\
    \ [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'Swift/Array.swift:418: Fatal error: Array index is out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b628a3c1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b628a0b8561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b628a0b8286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b628a0b813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b628a0b7bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b628a0a1196 <unavailable> + 1339798

    6    libswiftCore.so                    0x00002b628a2f2457 <unavailable> + 3769431

    7    libswiftCore.so                    0x00002b628a0ed911 <unavailable> + 1653009

    8    libswiftCore.so                    0x00002b628a1b47c0 MutableCollection.subscript.getter
    + 212

    9    tmpcujutury                        0x0000559b8f5a2f9e <unavailable> + 8094

    10   tmpcujutury                        0x0000559b8f5a28b4 <unavailable> + 6324

    11   libc.so.6                          0x00002b628a5ad460 __libc_start_main +
    245

    12   tmpcujutury                        0x0000559b8f5a2599 <unavailable> + 5529

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens: [Int] = []\n    for i in stride(from: 0, to: l.count, by: 2) {\n    \
    \    evens.append(l[i])\n    }\n    evens.sort()\n    for i in stride(from: 0,\
    \ to: l.count, by: 2) {\n        l[i] = evens[i/2]\n    }\n    return l\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even = [Int]()\n    var odd = [Int]()\n    for (index, value) in l.enumerated()\
    \ {\n        if index % 2 == 0 {\n            even.append(value)\n        } else\
    \ {\n            odd.append(value)\n        }\n    }\n    even.sort()\n    for\
    \ (index, value) in even.enumerated() {\n        l[index * 2] = value\n    }\n\
    \    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2,\
    \ 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    for\
    \ i in stride(from: 0, to: l.count, by: 2) {\n        l[i] = l[i...i+1].sorted()[0]\n\
    \    }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l:\
    \ [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'Swift/Array.swift:418: Fatal error: Array index is out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b628a3c1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b628a0b8561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b628a0b8286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b628a0b813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b628a0b7bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b628a0a1196 <unavailable> + 1339798

    6    libswiftCore.so                    0x00002b628a2f2457 <unavailable> + 3769431

    7    libswiftCore.so                    0x00002b628a0ed911 <unavailable> + 1653009

    8    libswiftCore.so                    0x00002b628a1b47c0 MutableCollection.subscript.getter
    + 212

    9    tmpcujutury                        0x0000559b8f5a2f9e <unavailable> + 8094

    10   tmpcujutury                        0x0000559b8f5a28b4 <unavailable> + 6324

    11   libc.so.6                          0x00002b628a5ad460 __libc_start_main +
    245

    12   tmpcujutury                        0x0000559b8f5a2599 <unavailable> + 5529

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n      \
    \  evens.append(l[i])\n    }\n    evens.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = evens[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens: [Int] = []\n    for i in stride(from: 0, to: l.count, by: 2) {\n    \
    \    evens.append(l[i])\n    }\n    evens.sort()\n    for i in stride(from: 0,\
    \ to: l.count, by: 2) {\n        l[i] = evens[i/2]\n    }\n    return l\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    var odds = [Int]()\n    for (i, x) in l.enumerated() {\n\
    \        if i % 2 == 0 {\n            odds.append(x)\n        } else {\n     \
    \       evens.append(x)\n        }\n    }\n    evens.sort()\n    for (i, x) in\
    \ evens.enumerated() {\n        l[i * 2 + 1] = x\n    }\n    return l\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmpd7ewf6tw/tmpd7ewf6tw.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b195b003c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b195acfab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b195acfa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b195acf97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd7ewf6tw                        0x000055ba7dbd9a43 <unavailable> + 6723

    5    libc.so.6                          0x00002b195b1ef460 __libc_start_main +
    245

    6    tmpd7ewf6tw                        0x000055ba7dbd9499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_prime = l\n \
    \   var even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2\
    \ == 0 {\n            even_indicies.append(i)\n        }\n    }\n    var even_values\
    \ = [Int]()\n    for i in even_indicies {\n        even_values.append(l[i])\n\
    \    }\n    even_values.sort()\n    for i in 0..<even_indicies.count {\n     \
    \   l_prime[even_indicies[i]] = even_values[i]\n    }\n    return l_prime\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n      \
    \  evens.append(l[i])\n    }\n    evens.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = evens[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n\
    \            even_indicies.append(i)\n        }\n    }\n    even_indicies.sort\
    \ { l[$0] < l[$1] }\n    for i in 0..<even_indicies.count {\n        let temp\
    \ = l[even_indicies[i]]\n        l[even_indicies[i]] = l[i]\n        l[i] = temp\n\
    \    }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l:\
    \ [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmp4cmuzba2/tmp4cmuzba2.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aad6ca26c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aad6c71db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aad6c71d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aad6c71c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4cmuzba2                        0x000055f183063774 <unavailable> + 6004

    5    libc.so.6                          0x00002aad6cc12460 __libc_start_main +
    245

    6    tmp4cmuzba2                        0x000055f183063379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n       \
    \ even.append(l[i])\n    }\n    even.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = even[i / 2]\n    }\n    return l\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n      \
    \  evens.append(l[i])\n    }\n    evens.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = evens[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n\
    \            even_indicies.append(i)\n        }\n    }\n    for i in 0..<even_indicies.count\
    \ {\n        for j in 0..<even_indicies.count - 1 {\n            if l[even_indicies[j]]\
    \ > l[even_indicies[j + 1]] {\n                let temp = l[even_indicies[j]]\n\
    \                l[even_indicies[j]] = l[even_indicies[j + 1]]\n             \
    \   l[even_indicies[j + 1]] = temp\n            }\n        }\n    }\n    return\
    \ l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1,\
    \ 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n\
    \            even_indicies.append(i)\n        }\n    }\n    for i in 0..<even_indicies.count\
    \ {\n        for j in 0..<even_indicies.count - 1 {\n            if l[even_indicies[j]]\
    \ > l[even_indicies[j + 1]] {\n                l.swapAt(even_indicies[j], even_indicies[j\
    \ + 1])\n            }\n        }\n    }\n    return l\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_prime = l\n \
    \   var even_indicies = [Int]()\n    var even_values = [Int]()\n    for i in 0..<l.count\
    \ {\n        if i % 2 == 0 {\n            even_indicies.append(i)\n          \
    \  even_values.append(l[i])\n        }\n    }\n    even_values.sort()\n    for\
    \ i in 0..<even_indicies.count {\n        l_prime[even_indicies[i]] = even_values[i]\n\
    \    }\n    return l_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l:\
    \ [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n     \
    \       evens.append(l[i])\n        }\n    }\n    evens.sort()\n    for i in 0..<l.count\
    \ {\n        if i % 2 == 0 {\n            l[i] = evens[i/2]\n        }\n    }\n\
    \    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2,\
    \ 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_copy = l\n  \
    \  var even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2 ==\
    \ 0 {\n            even_indicies.append(i)\n        }\n    }\n    for i in 0..<even_indicies.count\
    \ {\n        for j in i..<even_indicies.count {\n            if l_copy[even_indicies[i]]\
    \ > l_copy[even_indicies[j]] {\n                let temp = l_copy[even_indicies[i]]\n\
    \                l_copy[even_indicies[i]] = l_copy[even_indicies[j]]\n       \
    \         l_copy[even_indicies[j]] = temp\n            }\n        }\n    }\n \
    \   return l_copy\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2,\
    \ 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n      \
    \  evens.append(l[i])\n    }\n    evens.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = evens[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_even = [Int]()\n\
    \    var l_odd = [Int]()\n    for (index, value) in l.enumerated() {\n       \
    \ if index % 2 == 0 {\n            l_even.append(value)\n        } else {\n  \
    \          l_odd.append(value)\n        }\n    }\n    l_even.sort()\n    var l_new\
    \ = [Int]()\n    for (index, value) in l_even.enumerated() {\n        l_new.append(value)\n\
    \        if index < l_odd.count {\n            l_new.append(l_odd[index])\n  \
    \      }\n    }\n    return l_new\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l:\
    \ [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens: [Int] = []\n    for i in stride(from: 0, to: l.count, by: 2) {\n    \
    \    evens.append(l[i])\n    }\n    evens.sort()\n    for i in stride(from: 0,\
    \ to: l.count, by: 2) {\n        l[i] = evens[i/2]\n    }\n    return l\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_even = l.enumerated().filter\
    \ { $0.offset % 2 == 0 }.map { $0.element }\n    l_even.sort()\n    var l_odd\
    \ = l.enumerated().filter { $0.offset % 2 == 1 }.map { $0.element }\n    var l_new\
    \ = [Int]()\n    for i in 0..<l_even.count {\n        l_new.append(l_even[i])\n\
    \        l_new.append(l_odd[i])\n    }\n    return l_new\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b2adc035c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2adbd2c561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b2adbd2c286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b2adbd2c13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b2adbd2bbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b2adbb2be83 <unavailable> + 188035

    6    tmp7oxceufx                        0x000055966f0d01f1 <unavailable> + 8689

    7    tmp7oxceufx                        0x000055966f0cf904 <unavailable> + 6404

    8    libc.so.6                          0x00002b2adc221460 __libc_start_main +
    245

    9    tmp7oxceufx                        0x000055966f0cf5e9 <unavailable> + 5609

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_prime = l\n \
    \   var even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2\
    \ == 0 {\n            even_indicies.append(i)\n        }\n    }\n    for i in\
    \ even_indicies {\n        l_prime[i] = l[i]\n    }\n    for i in 0..<even_indicies.count\
    \ {\n        for j in 0..<even_indicies.count {\n            if l_prime[even_indicies[i]]\
    \ < l_prime[even_indicies[j]] {\n                let temp = l_prime[even_indicies[i]]\n\
    \                l_prime[even_indicies[i]] = l_prime[even_indicies[j]]\n     \
    \           l_prime[even_indicies[j]] = temp\n            }\n        }\n    }\n\
    \    return l_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2,\
    \ 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_copy = l\n  \
    \  var even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2 ==\
    \ 0 {\n            even_indicies.append(i)\n        }\n    }\n    for i in even_indicies\
    \ {\n        var temp = l_copy[i]\n        var j = i\n        while j > 0 && l_copy[j\
    \ - 1] > temp {\n            l_copy[j] = l_copy[j - 1]\n            j -= 1\n \
    \       }\n        l_copy[j] = temp\n    }\n    return l_copy\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmp2_0ttpmt/tmp2_0ttpmt.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8ca933ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8ca9031b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8ca9031988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8ca90307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2_0ttpmt                        0x00005577703e0a13 <unavailable> + 6675

    5    libc.so.6                          0x00002b8ca9526460 __libc_start_main +
    245

    6    tmp2_0ttpmt                        0x00005577703e0469 <unavailable> + 5225

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n      \
    \  evens.append(l[i])\n    }\n    evens.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = evens[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    var odds = [Int]()\n    for (i, v) in l.enumerated() {\n\
    \        if i % 2 == 0 {\n            odds.append(v)\n        } else {\n     \
    \       evens.append(v)\n        }\n    }\n    evens.sort()\n    for (i, v) in\
    \ evens.enumerated() {\n        l[i * 2 + 1] = v\n    }\n    return l\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmpcjpg58dl/tmpcjpg58dl.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac32d0a5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac32cd9cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac32cd9c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac32cd9b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcjpg58dl                        0x000055892ae56a43 <unavailable> + 6723

    5    libc.so.6                          0x00002ac32d291460 __libc_start_main +
    245

    6    tmpcjpg58dl                        0x000055892ae56499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even_indicies = [Int]()\n    var odd_indicies = [Int]()\n    for i in 0..<l.count\
    \ {\n        if i % 2 == 0 {\n            even_indicies.append(i)\n        } else\
    \ {\n            odd_indicies.append(i)\n        }\n    }\n    let even_values\
    \ = l.enumerated().filter { even_indicies.contains($0.offset) }.map { $0.element\
    \ }.sorted()\n    let odd_values = l.enumerated().filter { odd_indicies.contains($0.offset)\
    \ }.map { $0.element }\n    for i in 0..<even_indicies.count {\n        l[even_indicies[i]]\
    \ = even_values[i]\n    }\n    for i in 0..<odd_indicies.count {\n        l[odd_indicies[i]]\
    \ = odd_values[i]\n    }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2,\
    \ -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l:\
    \ [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n\
    \            even_indicies.append(i)\n        }\n    }\n    for i in 0..<even_indicies.count\
    \ {\n        for j in 0..<even_indicies.count {\n            if l[even_indicies[i]]\
    \ < l[even_indicies[j]] {\n                let temp = l[even_indicies[i]]\n  \
    \              l[even_indicies[i]] = l[even_indicies[j]]\n                l[even_indicies[j]]\
    \ = temp\n            }\n        }\n    }\n    return l\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ i = 0\n    while i < l.count {\n        if i % 2 == 0 {\n            l[i] =\
    \ l[i]\n        } else {\n            l[i] = l[i]\n            var j = i - 1\n\
    \            while j >= 0 && l[j] > l[j + 1] {\n                l.swapAt(j, j\
    \ + 1)\n                j -= 1\n            }\n        }\n        i += 1\n   \
    \ }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2,\
    \ 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmpip_0s8h7/tmpip_0s8h7.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6b19772c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6b19469b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6b19469988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6b194687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpip_0s8h7                        0x000055b5a97847b3 <unavailable> + 6067

    5    libc.so.6                          0x00002b6b1995e460 __libc_start_main +
    245

    6    tmpip_0s8h7                        0x000055b5a9784209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var evens = [Int]()\n\
    \    var odds = [Int]()\n    var result = [Int]()\n    for (i, num) in l.enumerated()\
    \ {\n        if i % 2 == 0 {\n            odds.append(num)\n        } else {\n\
    \            evens.append(num)\n        }\n    }\n    evens.sort()\n    for (i,\
    \ num) in l.enumerated() {\n        if i % 2 == 0 {\n            result.append(num)\n\
    \        } else {\n            result.append(evens.removeFirst())\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l:\
    \ [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmp0ocjdafp/tmp0ocjdafp.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aca41fabc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aca41ca2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aca41ca2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aca41ca17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0ocjdafp                        0x0000557319564a93 <unavailable> + 6803

    5    libc.so.6                          0x00002aca42197460 __libc_start_main +
    245

    6    tmp0ocjdafp                        0x00005573195644e9 <unavailable> + 5353

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n\
    \            even_indicies.append(i)\n        }\n    }\n    for i in 0..<even_indicies.count\
    \ {\n        for j in 0..<even_indicies.count - 1 {\n            if l[even_indicies[j]]\
    \ > l[even_indicies[j + 1]] {\n                let temp = l[even_indicies[j]]\n\
    \                l[even_indicies[j]] = l[even_indicies[j + 1]]\n             \
    \   l[even_indicies[j + 1]] = temp\n            }\n        }\n    }\n    return\
    \ l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1,\
    \ 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n       \
    \ even.append(l[i])\n    }\n    even.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = even[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_prime = l\n \
    \   var even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2\
    \ == 0 {\n            even_indicies.append(i)\n        }\n    }\n    var even_values\
    \ = [Int]()\n    for i in even_indicies {\n        even_values.append(l[i])\n\
    \    }\n    even_values.sort()\n    for i in 0..<even_indicies.count {\n     \
    \   l_prime[even_indicies[i]] = even_values[i]\n    }\n    return l_prime\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n       \
    \ even.append(l[i])\n    }\n    even.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = even[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n\
    \            even_indicies.append(i)\n        }\n    }\n    let even_values =\
    \ even_indicies.map { l[$0] }\n    let sorted_even_values = even_values.sorted()\n\
    \    for i in 0..<even_indicies.count {\n        l[even_indicies[i]] = sorted_even_values[i]\n\
    \    }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l:\
    \ [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824676
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_even = [Int]()\n\
    \    var l_odd = [Int]()\n    for (i, v) in l.enumerated() {\n        if i % 2\
    \ == 0 {\n            l_even.append(v)\n        } else {\n            l_odd.append(v)\n\
    \        }\n    }\n    l_even.sort()\n    var l_new = [Int]()\n    for (i, v)\
    \ in l.enumerated() {\n        if i % 2 == 0 {\n            l_new.append(l_even[i/2])\n\
    \        } else {\n            l_new.append(l_odd[i/2])\n        }\n    }\n  \
    \  return l_new\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2,\
    \ 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824676
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n\
    \            even_indicies.append(i)\n        }\n    }\n    let even_values =\
    \ l.filter { (i) -> Bool in\n        return even_indicies.contains(l.index(of:\
    \ i)!)\n    }\n    even_values.sorted()\n    for i in 0..<even_values.count {\n\
    \        l[even_indicies[i]] = even_values[i]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmp2dvl7_mw/tmp2dvl7_mw.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b87777a7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b877749eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b877749e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b877749d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2dvl7_mw                        0x0000563aa6c71b33 <unavailable> + 6963

    5    libc.so.6                          0x00002b8777993460 __libc_start_main +
    245

    6    tmp2dvl7_mw                        0x0000563aa6c71589 <unavailable> + 5513

    '
  stdout: ''
  timestamp: 1659824676
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n      \
    \  evens.append(l[i])\n    }\n    evens.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = evens[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n       \
    \ even.append(l[i])\n    }\n    even.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = even[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n     \
    \       evens.append(l[i])\n        }\n    }\n    evens.sort()\n    for i in 0..<l.count\
    \ {\n        if i % 2 == 0 {\n            l[i] = evens[i/2]\n        }\n    }\n\
    \    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2,\
    \ 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    for\
    \ i in stride(from: 0, to: l.count, by: 2) {\n        l[i] = l[i...].sorted()[0]\n\
    \    }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l:\
    \ [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmpmqfl3m0x/tmpmqfl3m0x.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad7f0732c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad7f0429b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad7f0429988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad7f04287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmqfl3m0x                        0x00005575db600ba3 <unavailable> + 7075

    5    libc.so.6                          0x00002ad7f091e460 __libc_start_main +
    245

    6    tmpmqfl3m0x                        0x00005575db6005f9 <unavailable> + 5625

    '
  stdout: ''
  timestamp: 1659824676
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_copy = l\n  \
    \  for i in stride(from: 0, to: l.count, by: 2) {\n        l_copy[i] = l[i]\n\
    \    }\n    for i in stride(from: 1, to: l.count, by: 2) {\n        l_copy[i]\
    \ = l[i]\n    }\n    return l_copy\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2,\
    \ -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l:\
    \ [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmpyybih2fi/tmpyybih2fi.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b710f978c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b710f66fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b710f66f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b710f66e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyybih2fi                        0x000055cd99968883 <unavailable> + 6275

    5    libc.so.6                          0x00002b710fb64460 __libc_start_main +
    245

    6    tmpyybih2fi                        0x000055cd999682d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824676
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n      \
    \  evens.append(l[i])\n    }\n    evens.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = evens[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_prime = l\n \
    \   var even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2\
    \ == 0 {\n            even_indicies.append(i)\n        }\n    }\n    var even_values\
    \ = [Int]()\n    for i in even_indicies {\n        even_values.append(l[i])\n\
    \    }\n    even_values.sort()\n    for i in 0..<even_indicies.count {\n     \
    \   l_prime[even_indicies[i]] = even_values[i]\n    }\n    return l_prime\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var result: [Int] =\
    \ []\n    var evens: [Int] = []\n    for (index, value) in l.enumerated() {\n\
    \        if index % 2 == 0 {\n            result.append(value)\n        } else\
    \ {\n            evens.append(value)\n        }\n    }\n    evens.sort()\n   \
    \ for (index, value) in evens.enumerated() {\n        result.insert(value, at:\
    \ index * 2 + 1)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3,\
    \ -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    assert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmpq9ebzlx4/tmpq9ebzlx4.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aef7694fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aef76646b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aef76646988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aef766457b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq9ebzlx4                        0x0000557aa521e9f3 <unavailable> + 6643

    5    libc.so.6                          0x00002aef76b3b460 __libc_start_main +
    245

    6    tmpq9ebzlx4                        0x0000557aa521e449 <unavailable> + 5193

    '
  stdout: ''
  timestamp: 1659824676
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n\
    \            even_indicies.append(i)\n        }\n    }\n    for i in even_indicies\
    \ {\n        for j in even_indicies {\n            if l[i] < l[j] {\n        \
    \        let temp = l[i]\n                l[i] = l[j]\n                l[j] =\
    \ temp\n            }\n        }\n    }\n    return l\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824676
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_even: [Int] =\
    \ []\n    var l_odd: [Int] = []\n    var l_sorted: [Int] = []\n    for (index,\
    \ value) in l.enumerated() {\n        if index % 2 == 0 {\n            l_even.append(value)\n\
    \        } else {\n            l_odd.append(value)\n        }\n    }\n    l_even.sort()\n\
    \    for (index, value) in l_even.enumerated() {\n        l_sorted.append(value)\n\
    \        l_sorted.append(l_odd[index])\n    }\n    return l_sorted\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b473c537c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b473c22e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b473c22e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b473c22e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b473c22dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b473c02de83 <unavailable> + 188035

    6    tmpj8_83i5n                        0x00005574bb781042 <unavailable> + 8258

    7    tmpj8_83i5n                        0x00005574bb780764 <unavailable> + 5988

    8    libc.so.6                          0x00002b473c723460 __libc_start_main +
    245

    9    tmpj8_83i5n                        0x00005574bb780449 <unavailable> + 5193

    '
  stdout: ''
  timestamp: 1659824676
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens: [Int] = []\n    for (index, value) in l.enumerated() {\n        if index\
    \ % 2 == 0 {\n            evens.append(value)\n        }\n    }\n    evens.sort()\n\
    \    for (index, value) in l.enumerated() {\n        if index % 2 == 0 {\n   \
    \         l[index] = evens.removeFirst()\n        }\n    }\n    return l\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824676
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n      \
    \  evens.append(l[i])\n    }\n    evens.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = evens[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var evens = [Int]()\n\
    \    var odds = [Int]()\n    var result = [Int]()\n    for i in 0..<l.count {\n\
    \        if i % 2 == 0 {\n            odds.append(l[i])\n        } else {\n  \
    \          evens.append(l[i])\n        }\n    }\n    evens.sort()\n    for i in\
    \ 0..<l.count {\n        if i % 2 == 0 {\n            result.append(odds[i / 2])\n\
    \        } else {\n            result.append(evens[i / 2])\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2,\
    \ 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmpk2f6my5e/tmpk2f6my5e.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b399fc6ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b399f965b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b399f965988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b399f9647b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk2f6my5e                        0x00005609c246e983 <unavailable> + 6531

    5    libc.so.6                          0x00002b399fe5a460 __libc_start_main +
    245

    6    tmpk2f6my5e                        0x00005609c246e3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824676
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_prime = l\n \
    \   var even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2\
    \ == 0 {\n            even_indicies.append(i)\n        }\n    }\n    var even_values\
    \ = [Int]()\n    for i in even_indicies {\n        even_values.append(l[i])\n\
    \    }\n    even_values.sort()\n    for i in 0..<even_indicies.count {\n     \
    \   l_prime[even_indicies[i]] = even_values[i]\n    }\n    return l_prime\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n      \
    \  evens.append(l[i])\n    }\n    evens.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = evens[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_even = [Int]()\n\
    \    var l_odd = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n\
    \            l_even.append(l[i])\n        } else {\n            l_odd.append(l[i])\n\
    \        }\n    }\n    l_even.sort()\n    var l_new = [Int]()\n    for i in 0..<l.count\
    \ {\n        if i % 2 == 0 {\n            l_new.append(l_even[i/2])\n        }\
    \ else {\n            l_new.append(l_odd[i/2])\n        }\n    }\n    return l_new\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even_indices = [Int]()\n    for (index, _) in l.enumerated() {\n        if index\
    \ % 2 == 0 {\n            even_indices.append(index)\n        }\n    }\n    for\
    \ index in even_indices {\n        let sub_array = l[index...index + 1]\n    \
    \    let sorted_sub_array = sub_array.sorted()\n        l[index] = sorted_sub_array[0]\n\
    \        l[index + 1] = sorted_sub_array[1]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'Swift/Array.swift:418: Fatal error: Array index is out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b833b8efc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b833b5e6561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b833b5e6286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b833b5e613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b833b5e5bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b833b5cf196 <unavailable> + 1339798

    6    libswiftCore.so                    0x00002b833b820457 <unavailable> + 3769431

    7    libswiftCore.so                    0x00002b833b61b911 <unavailable> + 1653009

    8    libswiftCore.so                    0x00002b833b6e27c0 MutableCollection.subscript.getter
    + 212

    9    tmpl5juzqcu                        0x000055af87ca431f <unavailable> + 8991

    10   tmpl5juzqcu                        0x000055af87ca3a84 <unavailable> + 6788

    11   libc.so.6                          0x00002b833badb460 __libc_start_main +
    245

    12   tmpl5juzqcu                        0x000055af87ca3769 <unavailable> + 5993

    '
  stdout: ''
  timestamp: 1659824676
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens: [Int] = []\n    var odds: [Int] = []\n    for i in 0..<l.count {\n  \
    \      if i % 2 == 0 {\n            odds.append(l[i])\n        } else {\n    \
    \        evens.append(l[i])\n        }\n    }\n    evens.sort()\n    for i in\
    \ 0..<evens.count {\n        odds.insert(evens[i], at: i * 2 + 1)\n    }\n   \
    \ return odds\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2,\
    \ 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmp9jon5yg1/tmp9jon5yg1.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b46d9011c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b46d8d08b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b46d8d08988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b46d8d077b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9jon5yg1                        0x000056531fd73983 <unavailable> + 6531

    5    libc.so.6                          0x00002b46d91fd460 __libc_start_main +
    245

    6    tmp9jon5yg1                        0x000056531fd733d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824676
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_copy = l\n  \
    \  var even_indicies: [Int] = []\n    for i in 0..<l.count {\n        if i % 2\
    \ == 0 {\n            even_indicies.append(i)\n        }\n    }\n    for i in\
    \ even_indicies {\n        let sub_array = l[i..<l.count]\n        let sorted_sub_array\
    \ = sub_array.sorted()\n        for j in 0..<sub_array.count {\n            l_copy[i+j]\
    \ = sorted_sub_array[j]\n        }\n    }\n    return l_copy\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmpz2rvl7o3/tmpz2rvl7o3.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aed044fbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aed041f2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aed041f2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aed041f17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz2rvl7o3                        0x0000564fe9f87bb3 <unavailable> + 7091

    5    libc.so.6                          0x00002aed046e7460 __libc_start_main +
    245

    6    tmpz2rvl7o3                        0x0000564fe9f87609 <unavailable> + 5641

    '
  stdout: ''
  timestamp: 1659824676
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n      \
    \  evens.append(l[i])\n    }\n    evens.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = evens[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    for\
    \ i in stride(from: 0, to: l.count, by: 2) {\n        l[i] = l[i..<l.count].sorted()[0]\n\
    \    }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l:\
    \ [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmp_gta00bc/tmp_gta00bc.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad808fb8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad808cafb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad808caf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad808cae7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_gta00bc                        0x000055aac95e6ab3 <unavailable> + 6835

    5    libc.so.6                          0x00002ad8091a4460 __libc_start_main +
    245

    6    tmp_gta00bc                        0x000055aac95e6509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even_indicies: [Int] = []\n    var even_values: [Int] = []\n    for (index,\
    \ value) in l.enumerated() {\n        if index % 2 == 0 {\n            even_indicies.append(index)\n\
    \            even_values.append(value)\n        }\n    }\n    even_values.sort()\n\
    \    for (index, value) in even_indicies.enumerated() {\n        l[value] = even_values[index]\n\
    \    }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l:\
    \ [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824676
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_prime = l\n \
    \   var even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2\
    \ == 0 {\n            even_indicies.append(i)\n        }\n    }\n    var even_values\
    \ = [Int]()\n    for i in even_indicies {\n        even_values.append(l[i])\n\
    \    }\n    even_values.sort()\n    for i in 0..<even_indicies.count {\n     \
    \   l_prime[even_indicies[i]] = even_values[i]\n    }\n    return l_prime\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_prime = l\n \
    \   var even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2\
    \ == 0 {\n            even_indicies.append(i)\n        }\n    }\n    for i in\
    \ even_indicies {\n        l_prime[i] = l[i]\n    }\n    return l_prime\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmp4zbunfwy/tmp4zbunfwy.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c3b6dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c3b3d3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0c3b3d3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0c3b3d27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4zbunfwy                        0x00005574cd948a13 <unavailable> + 6675

    5    libc.so.6                          0x00002b0c3b8c8460 __libc_start_main +
    245

    6    tmp4zbunfwy                        0x00005574cd948469 <unavailable> + 5225

    '
  stdout: ''
  timestamp: 1659824676
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n      \
    \  evens.append(l[i])\n    }\n    evens.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = evens[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n      \
    \  evens.append(l[i])\n    }\n    evens.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = evens[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n\
    \            even_indicies.append(i)\n        }\n    }\n    for i in 0..<even_indicies.count\
    \ {\n        for j in i..<even_indicies.count {\n            if l[even_indicies[i]]\
    \ > l[even_indicies[j]] {\n                l.swapAt(even_indicies[i], even_indicies[j])\n\
    \            }\n        }\n    }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3,\
    \ -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    assert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n      \
    \  evens.append(l[i])\n    }\n    evens.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = evens[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n\
    \            even_indicies.append(i)\n        }\n    }\n    for i in 0..<even_indicies.count\
    \ {\n        for j in 0..<even_indicies.count - 1 {\n            if l[even_indicies[j]]\
    \ > l[even_indicies[j + 1]] {\n                let temp = l[even_indicies[j]]\n\
    \                l[even_indicies[j]] = l[even_indicies[j + 1]]\n             \
    \   l[even_indicies[j + 1]] = temp\n            }\n        }\n    }\n    return\
    \ l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1,\
    \ 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even_indicies: [Int] = []\n    for i in 0..<l.count {\n        if i % 2 == 0\
    \ {\n            even_indicies.append(i)\n        }\n    }\n    for i in 0..<even_indicies.count\
    \ {\n        for j in i..<even_indicies.count {\n            if l[even_indicies[i]]\
    \ > l[even_indicies[j]] {\n                let temp = l[even_indicies[i]]\n  \
    \              l[even_indicies[i]] = l[even_indicies[j]]\n                l[even_indicies[j]]\
    \ = temp\n            }\n        }\n    }\n    return l\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824676
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_prime = l\n \
    \   var even_indicies = [Int]()\n    for i in 0...l.count - 1 {\n        if i\
    \ % 2 == 0 {\n            even_indicies.append(i)\n        }\n    }\n    var even_values\
    \ = [Int]()\n    for i in even_indicies {\n        even_values.append(l[i])\n\
    \    }\n    even_values.sort()\n    for i in 0...even_indicies.count - 1 {\n \
    \       l_prime[even_indicies[i]] = even_values[i]\n    }\n    return l_prime\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824676
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_prime = l\n \
    \   var even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2\
    \ == 0 {\n            even_indicies.append(i)\n        }\n    }\n    for i in\
    \ even_indicies {\n        l_prime[i] = l[i]\n    }\n    return l_prime\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmp4zbunfwy/tmp4zbunfwy.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c3b6dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c3b3d3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0c3b3d3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0c3b3d27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4zbunfwy                        0x00005574cd948a13 <unavailable> + 6675

    5    libc.so.6                          0x00002b0c3b8c8460 __libc_start_main +
    245

    6    tmp4zbunfwy                        0x00005574cd948469 <unavailable> + 5225

    '
  stdout: ''
  timestamp: 1659824676
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n      \
    \  evens.append(l[i])\n    }\n    evens.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = evens[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    var odds = [Int]()\n    for (i, n) in l.enumerated() {\n\
    \        if i % 2 == 0 {\n            odds.append(n)\n        } else {\n     \
    \       evens.append(n)\n        }\n    }\n    evens.sort()\n    for (i, n) in\
    \ evens.enumerated() {\n        l[i * 2 + 1] = n\n    }\n    return l\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmpccvnm00e/tmpccvnm00e.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af65b7f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af65b4e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af65b4e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af65b4e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpccvnm00e                        0x00005567975cea43 <unavailable> + 6723

    5    libc.so.6                          0x00002af65b9dd460 __libc_start_main +
    245

    6    tmpccvnm00e                        0x00005567975ce499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824676
- exit_code: 1
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_prime = l\n \
    \   var even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2\
    \ == 0 {\n            even_indicies.append(i)\n        }\n    }\n    for i in\
    \ even_indicies {\n        l_prime[i] = l[i].sorted()\n    }\n    return l_prime\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: SyntaxError
  stderr: "/tmp/tmpaytrjtn7.swift:18:27: error: value of type 'Int' has no member\
    \ 'sorted'\n        l_prime[i] = l[i].sorted()\n                     ~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even_indicies: [Int] = []\n    var even_values: [Int] = []\n    for (i, v) in\
    \ l.enumerated() {\n        if i % 2 == 0 {\n            even_indicies.append(i)\n\
    \            even_values.append(v)\n        }\n    }\n    even_values.sort()\n\
    \    for (i, v) in even_indicies.enumerated() {\n        l[v] = even_values[i]\n\
    \    }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l:\
    \ [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824676
- exit_code: 1
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_prime = l\n \
    \   var even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2\
    \ == 0 {\n            even_indicies.append(i)\n        }\n    }\n    for i in\
    \ even_indicies {\n        l_prime[i] = l[i].sorted()\n    }\n    return l_prime\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: SyntaxError
  stderr: "/tmp/tmpaytrjtn7.swift:18:27: error: value of type 'Int' has no member\
    \ 'sorted'\n        l_prime[i] = l[i].sorted()\n                     ~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n       \
    \ even.append(l[i])\n    }\n    even.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = even[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_even = [Int]()\n\
    \    var l_odd = [Int]()\n    var l_sorted = [Int]()\n    for (i, e) in l.enumerated()\
    \ {\n        if i % 2 == 0 {\n            l_even.append(e)\n        } else {\n\
    \            l_odd.append(e)\n        }\n    }\n    l_even.sort()\n    for (i,\
    \ e) in l_even.enumerated() {\n        l_sorted.append(e)\n        l_sorted.append(l_odd[i])\n\
    \    }\n    return l_sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l:\
    \ [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002af520c30c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af520927561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002af520927286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002af52092713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002af520926bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002af520726e83 <unavailable> + 188035

    6    tmpphw9jif7                        0x0000563340367071 <unavailable> + 8305

    7    tmpphw9jif7                        0x00005633403667b4 <unavailable> + 6068

    8    libc.so.6                          0x00002af520e1c460 __libc_start_main +
    245

    9    tmpphw9jif7                        0x0000563340366499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824676
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_even = l.enumerated().filter\
    \ { $0.offset % 2 == 0 }.map { $0.element }\n    l_even.sort()\n    var l_odd\
    \ = l.enumerated().filter { $0.offset % 2 == 1 }.map { $0.element }\n    var l_new\
    \ = [Int]()\n    for i in 0..<l_even.count {\n        l_new.append(l_even[i])\n\
    \        l_new.append(l_odd[i])\n    }\n    return l_new\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b2adc035c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2adbd2c561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b2adbd2c286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b2adbd2c13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b2adbd2bbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b2adbb2be83 <unavailable> + 188035

    6    tmp7oxceufx                        0x000055966f0d01f1 <unavailable> + 8689

    7    tmp7oxceufx                        0x000055966f0cf904 <unavailable> + 6404

    8    libc.so.6                          0x00002b2adc221460 __libc_start_main +
    245

    9    tmp7oxceufx                        0x000055966f0cf5e9 <unavailable> + 5609

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_even = [Int]()\n\
    \    var l_odd = [Int]()\n    for (i, e) in l.enumerated() {\n        if i % 2\
    \ == 0 {\n            l_even.append(e)\n        } else {\n            l_odd.append(e)\n\
    \        }\n    }\n    l_even.sort()\n    var l_new = [Int]()\n    for (i, e)\
    \ in l.enumerated() {\n        if i % 2 == 0 {\n            l_new.append(l_even[i/2])\n\
    \        } else {\n            l_new.append(l_odd[i/2])\n        }\n    }\n  \
    \  return l_new\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2,\
    \ 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824676
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n\
    \            even_indicies.append(i)\n        }\n    }\n    var even_values =\
    \ [Int]()\n    for i in even_indicies {\n        even_values.append(l[i])\n  \
    \  }\n    even_values.sort()\n    for i in 0..<even_indicies.count {\n       \
    \ l[even_indicies[i]] = even_values[i]\n    }\n    return l\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824676
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    for\
    \ i in stride(from: 0, to: l.count, by: 2) {\n        l[i] = l[i..<l.count].sorted()[0]\n\
    \    }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l:\
    \ [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmp_gta00bc/tmp_gta00bc.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad808fb8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad808cafb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad808caf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad808cae7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_gta00bc                        0x000055aac95e6ab3 <unavailable> + 6835

    5    libc.so.6                          0x00002ad8091a4460 __libc_start_main +
    245

    6    tmp_gta00bc                        0x000055aac95e6509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n\
    \            even_indicies.append(i)\n        }\n    }\n    for i in 0..<even_indicies.count\
    \ {\n        for j in 0..<even_indicies.count - 1 {\n            if l[even_indicies[j]]\
    \ > l[even_indicies[j + 1]] {\n                let temp = l[even_indicies[j]]\n\
    \                l[even_indicies[j]] = l[even_indicies[j + 1]]\n             \
    \   l[even_indicies[j + 1]] = temp\n            }\n        }\n    }\n    return\
    \ l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1,\
    \ 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_even = [Int]()\n\
    \    var l_odd = [Int]()\n    for (index, value) in l.enumerated() {\n       \
    \ if index % 2 == 0 {\n            l_even.append(value)\n        } else {\n  \
    \          l_odd.append(value)\n        }\n    }\n    l_even.sort()\n    var l_new\
    \ = [Int]()\n    for (index, value) in l_even.enumerated() {\n        l_new.append(value)\n\
    \        l_new.append(l_odd[index])\n    }\n    return l_new\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b5d98b57c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5d9884e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b5d9884e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b5d9884e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b5d9884dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b5d9864de83 <unavailable> + 188035

    6    tmp9jybq8am                        0x000055a9d0507071 <unavailable> + 8305

    7    tmp9jybq8am                        0x000055a9d05067b4 <unavailable> + 6068

    8    libc.so.6                          0x00002b5d98d43460 __libc_start_main +
    245

    9    tmp9jybq8am                        0x000055a9d0506499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824676
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n\
    \            even_indicies.append(i)\n        }\n    }\n    for i in 0..<even_indicies.count\
    \ {\n        for j in 0..<even_indicies.count - 1 {\n            if l[even_indicies[j]]\
    \ > l[even_indicies[j + 1]] {\n                let temp = l[even_indicies[j]]\n\
    \                l[even_indicies[j]] = l[even_indicies[j + 1]]\n             \
    \   l[even_indicies[j + 1]] = temp\n            }\n        }\n    }\n    return\
    \ l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1,\
    \ 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_even = [Int]()\n\
    \    var l_odd = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n\
    \            l_even.append(l[i])\n        } else {\n            l_odd.append(l[i])\n\
    \        }\n    }\n    l_even.sort()\n    var l_new = [Int]()\n    for i in 0..<l.count\
    \ {\n        if i % 2 == 0 {\n            l_new.append(l_even[i/2])\n        }\
    \ else {\n            l_new.append(l_odd[i/2])\n        }\n    }\n    return l_new\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_prime = l\n \
    \   var even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2\
    \ == 0 {\n            even_indicies.append(i)\n        }\n    }\n    let even_values\
    \ = even_indicies.map { l[$0] }\n    let sorted_even_values = even_values.sorted()\n\
    \    for i in 0..<even_indicies.count {\n        l_prime[even_indicies[i]] = sorted_even_values[i]\n\
    \    }\n    return l_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l:\
    \ [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824676
- exit_code: 1
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    for\
    \ i in stride(from: 0, to: l.count, by: 2) {\n        l[i] = l[i].sort()\n   \
    \ }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2,\
    \ 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: SyntaxError
  stderr: "/tmp/tmp9cbedafo.swift:12:21: error: value of type 'Int' has no member\
    \ 'sort'\n        l[i] = l[i].sort()\n               ~~~~ ^~~~\n"
  stdout: ''
  timestamp: 1659824676
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_even = [Int]()\n\
    \    var l_odd = [Int]()\n    var l_sorted = [Int]()\n    for (index, value) in\
    \ l.enumerated() {\n        if index % 2 == 0 {\n            l_even.append(value)\n\
    \        } else {\n            l_odd.append(value)\n        }\n    }\n    l_even.sort()\n\
    \    for (index, value) in l_even.enumerated() {\n        l_sorted.append(value)\n\
    \        l_sorted.append(l_odd[index])\n    }\n    return l_sorted\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3ed8fa6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3ed8c9d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3ed8c9d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3ed8c9d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3ed8c9cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3ed8a9ce83 <unavailable> + 188035

    6    tmphckdnyhc                        0x000055f2a6285071 <unavailable> + 8305

    7    tmphckdnyhc                        0x000055f2a62847b4 <unavailable> + 6068

    8    libc.so.6                          0x00002b3ed9192460 __libc_start_main +
    245

    9    tmphckdnyhc                        0x000055f2a6284499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even_indicies: [Int] = []\n    for i in 0..<l.count {\n        if i % 2 == 0\
    \ {\n            even_indicies.append(i)\n        }\n    }\n    for i in 0..<even_indicies.count\
    \ {\n        for j in 0..<even_indicies.count - 1 {\n            if l[even_indicies[j]]\
    \ > l[even_indicies[j + 1]] {\n                let temp = l[even_indicies[j]]\n\
    \                l[even_indicies[j]] = l[even_indicies[j + 1]]\n             \
    \   l[even_indicies[j + 1]] = temp\n            }\n        }\n    }\n    return\
    \ l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1,\
    \ 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n     \
    \       evens.append(l[i])\n        }\n    }\n    evens.sort()\n    for i in 0..<l.count\
    \ {\n        if i % 2 == 0 {\n            l[i] = evens[i/2]\n        }\n    }\n\
    \    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2,\
    \ 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_even = [Int]()\n\
    \    var l_odd = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n\
    \            l_even.append(l[i])\n        } else {\n            l_odd.append(l[i])\n\
    \        }\n    }\n    l_even.sort()\n    var l_new = [Int]()\n    for i in 0..<l.count\
    \ {\n        if i % 2 == 0 {\n            l_new.append(l_even[i/2])\n        }\
    \ else {\n            l_new.append(l_odd[i/2])\n        }\n    }\n    return l_new\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n      \
    \  evens.append(l[i])\n    }\n    evens.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = evens[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    for\
    \ i in stride(from: 0, to: l.count, by: 2) {\n        l[i] = l[i..<l.count].sorted()[0]\n\
    \    }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l:\
    \ [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmp_gta00bc/tmp_gta00bc.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad808fb8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad808cafb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad808caf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad808cae7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_gta00bc                        0x000055aac95e6ab3 <unavailable> + 6835

    5    libc.so.6                          0x00002ad8091a4460 __libc_start_main +
    245

    6    tmp_gta00bc                        0x000055aac95e6509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_prime = l\n \
    \   var even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2\
    \ == 0 {\n            even_indicies.append(i)\n        }\n    }\n    for i in\
    \ even_indicies {\n        l_prime[i] = l[i]\n    }\n    return l_prime\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmp4zbunfwy/tmp4zbunfwy.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c3b6dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c3b3d3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0c3b3d3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0c3b3d27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4zbunfwy                        0x00005574cd948a13 <unavailable> + 6675

    5    libc.so.6                          0x00002b0c3b8c8460 __libc_start_main +
    245

    6    tmp4zbunfwy                        0x00005574cd948469 <unavailable> + 5225

    '
  stdout: ''
  timestamp: 1659824676
- exit_code: 1
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    for\
    \ i in stride(from: 0, to: l.count, by: 2) {\n        l[i] = l[i].sorted()\n \
    \   }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2,\
    \ 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: SyntaxError
  stderr: "/tmp/tmp8za9fac_.swift:12:21: error: value of type 'Int' has no member\
    \ 'sorted'\n        l[i] = l[i].sorted()\n               ~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_even = l.enumerated().filter\
    \ { $0.offset % 2 == 0 }.map { $0.element }\n    l_even.sort()\n    var l_odd\
    \ = l.enumerated().filter { $0.offset % 2 == 1 }.map { $0.element }\n    var l_new\
    \ = [Int]()\n    for i in 0..<l_even.count {\n        l_new.append(l_even[i])\n\
    \        l_new.append(l_odd[i])\n    }\n    return l_new\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b2adc035c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2adbd2c561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b2adbd2c286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b2adbd2c13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b2adbd2bbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b2adbb2be83 <unavailable> + 188035

    6    tmp7oxceufx                        0x000055966f0d01f1 <unavailable> + 8689

    7    tmp7oxceufx                        0x000055966f0cf904 <unavailable> + 6404

    8    libc.so.6                          0x00002b2adc221460 __libc_start_main +
    245

    9    tmp7oxceufx                        0x000055966f0cf5e9 <unavailable> + 5609

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens: [Int] = []\n    for i in stride(from: 0, to: l.count, by: 2) {\n    \
    \    evens.append(l[i])\n    }\n    evens.sort()\n    for i in stride(from: 0,\
    \ to: l.count, by: 2) {\n        l[i] = evens[i/2]\n    }\n    return l\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var evens = [Int]()\n\
    \    var odds = [Int]()\n    var result = [Int]()\n    for i in 0..<l.count {\n\
    \        if i % 2 == 0 {\n            odds.append(l[i])\n        } else {\n  \
    \          evens.append(l[i])\n        }\n    }\n    evens.sort()\n    for i in\
    \ 0..<l.count {\n        if i % 2 == 0 {\n            result.append(odds[i/2])\n\
    \        } else {\n            result.append(evens[i/2])\n        }\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2,\
    \ 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmpbmw1eja6/tmpbmw1eja6.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af3d7c60c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af3d7957b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af3d7957988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af3d79567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbmw1eja6                        0x000055e13bb14983 <unavailable> + 6531

    5    libc.so.6                          0x00002af3d7e4c460 __libc_start_main +
    245

    6    tmpbmw1eja6                        0x000055e13bb143d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824676
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n       \
    \ even.append(l[i])\n    }\n    even.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = even[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    for\
    \ i in stride(from: 0, to: l.count, by: 2) {\n        l[i] = l[i].sorted()\n \
    \   }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2,\
    \ 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: SyntaxError
  stderr: "/tmp/tmp8za9fac_.swift:12:21: error: value of type 'Int' has no member\
    \ 'sorted'\n        l[i] = l[i].sorted()\n               ~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n\
    \            even_indicies.append(i)\n        }\n    }\n    even_indicies.sort\
    \ { l[$0] < l[$1] }\n    var l_prime = [Int]()\n    for i in 0..<l.count {\n \
    \       if i % 2 == 0 {\n            l_prime.append(l[even_indicies[i/2]])\n \
    \       } else {\n            l_prime.append(l[i])\n        }\n    }\n    return\
    \ l_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2,\
    \ 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824676
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n\
    \            even_indicies.append(i)\n        }\n    }\n    for i in 0..<even_indicies.count\
    \ {\n        for j in 0..<even_indicies.count - 1 {\n            if l[even_indicies[j]]\
    \ > l[even_indicies[j + 1]] {\n                let temp = l[even_indicies[j]]\n\
    \                l[even_indicies[j]] = l[even_indicies[j + 1]]\n             \
    \   l[even_indicies[j + 1]] = temp\n            }\n        }\n    }\n    return\
    \ l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1,\
    \ 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_prime = l\n \
    \   var even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2\
    \ == 0 {\n            even_indicies.append(i)\n        }\n    }\n    var even_values\
    \ = [Int]()\n    for i in even_indicies {\n        even_values.append(l[i])\n\
    \    }\n    even_values.sort()\n    for i in 0..<even_indicies.count {\n     \
    \   l_prime[even_indicies[i]] = even_values[i]\n    }\n    return l_prime\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var result = l\n  \
    \  var evens = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n\
    \            evens.append(l[i])\n        }\n    }\n    evens.sort()\n    for i\
    \ in 0..<l.count {\n        if i % 2 == 0 {\n            result[i] = evens[i/2]\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2,\
    \ -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l:\
    \ [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824676
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n      \
    \  evens.append(l[i])\n    }\n    evens.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = evens[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_copy = l\n  \
    \  var even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2 ==\
    \ 0 {\n            even_indicies.append(i)\n        }\n    }\n    var even_values\
    \ = [Int]()\n    for i in even_indicies {\n        even_values.append(l[i])\n\
    \    }\n    even_values.sort()\n    for i in 0..<even_indicies.count {\n     \
    \   l_copy[even_indicies[i]] = even_values[i]\n    }\n    return l_copy\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824676
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_prime = l\n \
    \   var even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2\
    \ == 0 {\n            even_indicies.append(i)\n        }\n    }\n    var even_values\
    \ = [Int]()\n    for i in even_indicies {\n        even_values.append(l[i])\n\
    \    }\n    even_values.sort()\n    for i in 0..<even_indicies.count {\n     \
    \   l_prime[even_indicies[i]] = even_values[i]\n    }\n    return l_prime\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n\
    \            even_indicies.append(i)\n        }\n    }\n    for i in 0..<even_indicies.count\
    \ {\n        for j in 0..<even_indicies.count - 1 {\n            if l[even_indicies[j]]\
    \ > l[even_indicies[j + 1]] {\n                let temp = l[even_indicies[j]]\n\
    \                l[even_indicies[j]] = l[even_indicies[j + 1]]\n             \
    \   l[even_indicies[j + 1]] = temp\n            }\n        }\n    }\n    return\
    \ l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1,\
    \ 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_even = [Int]()\n\
    \    var l_odd = [Int]()\n    for (index, value) in l.enumerated() {\n       \
    \ if index % 2 == 0 {\n            l_even.append(value)\n        } else {\n  \
    \          l_odd.append(value)\n        }\n    }\n    l_even.sort()\n    var l_sorted\
    \ = [Int]()\n    for (index, value) in l_even.enumerated() {\n        l_sorted.append(value)\n\
    \        l_sorted.append(l_odd[index])\n    }\n    return l_sorted\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8662630c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8662327561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8662327286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b866232713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8662326bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8662126e83 <unavailable> + 188035

    6    tmpylv33sv3                        0x00005579c949c071 <unavailable> + 8305

    7    tmpylv33sv3                        0x00005579c949b7b4 <unavailable> + 6068

    8    libc.so.6                          0x00002b866281c460 __libc_start_main +
    245

    9    tmpylv33sv3                        0x00005579c949b499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824676
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_prime = l\n \
    \   var even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2\
    \ == 0 {\n            even_indicies.append(i)\n        }\n    }\n    let even_values\
    \ = even_indicies.map { l[$0] }\n    let sorted_even_values = even_values.sorted()\n\
    \    for i in 0..<even_indicies.count {\n        l_prime[even_indicies[i]] = sorted_even_values[i]\n\
    \    }\n    return l_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l:\
    \ [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824676
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_prime = l\n \
    \   var even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2\
    \ == 0 {\n            even_indicies.append(i)\n        }\n    }\n    var even_values\
    \ = [Int]()\n    for i in even_indicies {\n        even_values.append(l[i])\n\
    \    }\n    even_values.sort()\n    for i in 0..<even_indicies.count {\n     \
    \   l_prime[even_indicies[i]] = even_values[i]\n    }\n    return l_prime\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_prime = l\n \
    \   var even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2\
    \ == 0 {\n            even_indicies.append(i)\n        }\n    }\n    var even_values\
    \ = [Int]()\n    for i in even_indicies {\n        even_values.append(l[i])\n\
    \    }\n    even_values.sort()\n    for i in 0..<even_indicies.count {\n     \
    \   l_prime[even_indicies[i]] = even_values[i]\n    }\n    return l_prime\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n      \
    \  evens.append(l[i])\n    }\n    evens.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = evens[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n     \
    \       evens.append(l[i])\n        }\n    }\n    evens.sort()\n    for i in 0..<l.count\
    \ {\n        if i % 2 == 0 {\n            l[i] = evens[i/2]\n        }\n    }\n\
    \    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2,\
    \ 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n       \
    \ even.append(l[i])\n    }\n    even.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = even[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    var odds = [Int]()\n    for (index, value) in l.enumerated()\
    \ {\n        if index % 2 == 0 {\n            odds.append(value)\n        } else\
    \ {\n            evens.append(value)\n        }\n    }\n    evens.sort()\n   \
    \ for (index, value) in evens.enumerated() {\n        l[index * 2 + 1] = value\n\
    \    }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l:\
    \ [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmpy8ajq6av/tmpy8ajq6av.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b677613ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6775e31b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6775e31988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6775e307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy8ajq6av                        0x0000562a3fd4ca43 <unavailable> + 6723

    5    libc.so.6                          0x00002b6776326460 __libc_start_main +
    245

    6    tmpy8ajq6av                        0x0000562a3fd4c499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_prime = l\n \
    \   var even_indices = [Int]()\n    for i in 0..<l.count {\n        if i % 2 ==\
    \ 0 {\n            even_indices.append(i)\n        }\n    }\n    for i in even_indices\
    \ {\n        l_prime[i] = l[i]\n    }\n    return l_prime\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmp8bl9uftk/tmp8bl9uftk.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8726c4ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8726945b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8726945988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b87269447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8bl9uftk                        0x000055f38dc11a13 <unavailable> + 6675

    5    libc.so.6                          0x00002b8726e3a460 __libc_start_main +
    245

    6    tmp8bl9uftk                        0x000055f38dc11469 <unavailable> + 5225

    '
  stdout: ''
  timestamp: 1659824676
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    var odds = [Int]()\n    for i in 0..<l.count {\n      \
    \  if i % 2 == 0 {\n            odds.append(l[i])\n        } else {\n        \
    \    evens.append(l[i])\n        }\n    }\n    evens.sort()\n    for i in 0..<evens.count\
    \ {\n        l[2*i + 1] = evens[i]\n    }\n    return l\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmpkw8h5me_/tmpkw8h5me_.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abd30e7ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abd30b71b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abd30b71988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abd30b707b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkw8h5me_                        0x00005637bf24b9d3 <unavailable> + 6611

    5    libc.so.6                          0x00002abd31066460 __libc_start_main +
    245

    6    tmpkw8h5me_                        0x00005637bf24b429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1659824676
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n\
    \            even_indicies.append(i)\n        }\n    }\n    var even_values =\
    \ [Int]()\n    for i in even_indicies {\n        even_values.append(l[i])\n  \
    \  }\n    even_values.sort()\n    for i in 0..<even_indicies.count {\n       \
    \ l[even_indicies[i]] = even_values[i]\n    }\n    return l\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824676
- exit_code: 1
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    for\
    \ i in stride(from: 0, to: l.count, by: 2) {\n        l[i] = l[i].sorted()\n \
    \   }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2,\
    \ 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: SyntaxError
  stderr: "/tmp/tmp8za9fac_.swift:12:21: error: value of type 'Int' has no member\
    \ 'sorted'\n        l[i] = l[i].sorted()\n               ~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_even = [Int]()\n\
    \    var l_odd = [Int]()\n    var l_sorted = [Int]()\n    for (index, value) in\
    \ l.enumerated() {\n        if index % 2 == 0 {\n            l_even.append(value)\n\
    \        } else {\n            l_odd.append(value)\n        }\n    }\n    l_even.sort()\n\
    \    for (index, value) in l_even.enumerated() {\n        l_sorted.append(value)\n\
    \        l_sorted.append(l_odd[index])\n    }\n    return l_sorted\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3ed8fa6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3ed8c9d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3ed8c9d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3ed8c9d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3ed8c9cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3ed8a9ce83 <unavailable> + 188035

    6    tmphckdnyhc                        0x000055f2a6285071 <unavailable> + 8305

    7    tmphckdnyhc                        0x000055f2a62847b4 <unavailable> + 6068

    8    libc.so.6                          0x00002b3ed9192460 __libc_start_main +
    245

    9    tmphckdnyhc                        0x000055f2a6284499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_prime = l\n \
    \   var even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2\
    \ == 0 {\n            even_indicies.append(i)\n        }\n    }\n    let even_values\
    \ = even_indicies.map { l[$0] }\n    let sorted_even_values = even_values.sorted()\n\
    \    for i in 0..<even_indicies.count {\n        l_prime[even_indicies[i]] = sorted_even_values[i]\n\
    \    }\n    return l_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l:\
    \ [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824676
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    for\
    \ i in stride(from: 0, to: l.count, by: 2) {\n        for j in stride(from: i,\
    \ to: l.count, by: 2) {\n            if l[i] > l[j] {\n                let temp\
    \ = l[i]\n                l[i] = l[j]\n                l[j] = temp\n         \
    \   }\n        }\n    }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2,\
    \ -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l:\
    \ [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824676
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n      \
    \  evens.append(l[i])\n    }\n    evens.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = evens[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n      \
    \  evens.append(l[i])\n    }\n    evens.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = evens[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ i = 0\n    while i < l.count {\n        if i % 2 == 0 {\n            l[i] =\
    \ l[i]\n        } else {\n            var j = i\n            while j > 0 && l[j]\
    \ < l[j - 1] {\n                let temp = l[j]\n                l[j] = l[j -\
    \ 1]\n                l[j - 1] = temp\n                j -= 1\n            }\n\
    \        }\n        i += 1\n    }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3,\
    \ -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    assert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmpcj9tsz1_/tmpcj9tsz1_.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5d0ce32c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5d0cb29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5d0cb29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5d0cb287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcj9tsz1_                        0x00005611767d0713 <unavailable> + 5907

    5    libc.so.6                          0x00002b5d0d01e460 __libc_start_main +
    245

    6    tmpcj9tsz1_                        0x00005611767d0169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659824676
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ i = 0\n    while i < l.count {\n        if i % 2 == 0 {\n            l[i] =\
    \ l[i]\n        } else {\n            l[i] = l[i-1]\n        }\n        i += 1\n\
    \    }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l:\
    \ [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmpcspwaq62/tmpcspwaq62.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b070d158c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b070ce4fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b070ce4f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b070ce4e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcspwaq62                        0x0000565095d36564 <unavailable> + 5476

    5    libc.so.6                          0x00002b070d344460 __libc_start_main +
    245

    6    tmpcspwaq62                        0x0000565095d36169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659824676
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    let\
    \ evens = l.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element }\n  \
    \  let odds = l.enumerated().filter { $0.offset % 2 == 1 }.map { $0.element }\n\
    \    let sortedEvens = evens.sorted()\n    for (i, e) in sortedEvens.enumerated()\
    \ {\n        l[i * 2] = e\n    }\n    for (i, o) in odds.enumerated() {\n    \
    \    l[i * 2 + 1] = o\n    }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3,\
    \ -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    assert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824676
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_even = [Int]()\n\
    \    var l_odd = [Int]()\n    for (index, value) in l.enumerated() {\n       \
    \ if index % 2 == 0 {\n            l_even.append(value)\n        } else {\n  \
    \          l_odd.append(value)\n        }\n    }\n    l_even.sort()\n    var l_prime\
    \ = [Int]()\n    for (index, value) in l_even.enumerated() {\n        l_prime.append(value)\n\
    \        l_prime.append(l_odd[index])\n    }\n    return l_prime\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002afc4742dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afc47124561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afc47124286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afc4712413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afc47123bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002afc46f23e83 <unavailable> + 188035

    6    tmp0relinu6                        0x0000557acd78e071 <unavailable> + 8305

    7    tmp0relinu6                        0x0000557acd78d7b4 <unavailable> + 6068

    8    libc.so.6                          0x00002afc47619460 __libc_start_main +
    245

    9    tmp0relinu6                        0x0000557acd78d499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824676
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var result = l\n  \
    \  var even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2 ==\
    \ 0 {\n            even_indicies.append(i)\n        }\n    }\n    var even_values\
    \ = [Int]()\n    for i in even_indicies {\n        even_values.append(l[i])\n\
    \    }\n    even_values.sort()\n    for i in 0..<even_indicies.count {\n     \
    \   result[even_indicies[i]] = even_values[i]\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824676
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_prime = l\n \
    \   var even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2\
    \ == 0 {\n            even_indicies.append(i)\n        }\n    }\n    var even_values\
    \ = [Int]()\n    for i in even_indicies {\n        even_values.append(l[i])\n\
    \    }\n    even_values.sort()\n    for i in 0..<even_indicies.count {\n     \
    \   l_prime[even_indicies[i]] = even_values[i]\n    }\n    return l_prime\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n\
    \            even_indicies.append(i)\n        }\n    }\n    for i in 0..<even_indicies.count\
    \ {\n        for j in i..<even_indicies.count {\n            if l[even_indicies[i]]\
    \ > l[even_indicies[j]] {\n                let temp = l[even_indicies[i]]\n  \
    \              l[even_indicies[i]] = l[even_indicies[j]]\n                l[even_indicies[j]]\
    \ = temp\n            }\n        }\n    }\n    return l\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824676
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_prime = l\n \
    \   var evens = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n\
    \            evens.append(l[i])\n        }\n    }\n    evens.sort()\n    for i\
    \ in 0..<l.count {\n        if i % 2 == 0 {\n            l_prime[i] = evens[i/2]\n\
    \        }\n    }\n    return l_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2,\
    \ -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l:\
    \ [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even = [Int]()\n    var odd = [Int]()\n    for (index, value) in l.enumerated()\
    \ {\n        if index % 2 == 0 {\n            even.append(value)\n        } else\
    \ {\n            odd.append(value)\n        }\n    }\n    even.sort()\n    for\
    \ (index, value) in even.enumerated() {\n        l[index * 2] = value\n    }\n\
    \    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2,\
    \ 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n      \
    \  evens.append(l[i])\n    }\n    evens.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = evens[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n      \
    \  evens.append(l[i])\n    }\n    evens.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = evens[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var evens = [Int]()\n\
    \    var odds = [Int]()\n    var result = [Int]()\n    for (index, value) in l.enumerated()\
    \ {\n        if index % 2 == 0 {\n            odds.append(value)\n        } else\
    \ {\n            evens.append(value)\n        }\n    }\n    evens.sort()\n   \
    \ for (index, value) in odds.enumerated() {\n        result.append(value)\n  \
    \      result.append(evens[index])\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7fb16a0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7fb1397561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b7fb1397286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b7fb139713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b7fb1396bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b7fb1196e83 <unavailable> + 188035

    6    tmpzmkc2ue1                        0x000055ce6e6e4071 <unavailable> + 8305

    7    tmpzmkc2ue1                        0x000055ce6e6e37b4 <unavailable> + 6068

    8    libc.so.6                          0x00002b7fb188c460 __libc_start_main +
    245

    9    tmpzmkc2ue1                        0x000055ce6e6e3499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var result = l\n  \
    \  var evens = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n\
    \            evens.append(l[i])\n        }\n    }\n    evens.sort()\n    for i\
    \ in 0..<l.count {\n        if i % 2 == 0 {\n            result[i] = evens[i/2]\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2,\
    \ -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l:\
    \ [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824676
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n      \
    \  evens.append(l[i])\n    }\n    evens.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = evens[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_even = [Int]()\n\
    \    var l_odd = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n\
    \            l_even.append(l[i])\n        } else {\n            l_odd.append(l[i])\n\
    \        }\n    }\n    l_even.sort()\n    var l_sorted = [Int]()\n    for i in\
    \ 0..<l.count {\n        if i % 2 == 0 {\n            l_sorted.append(l_even[i/2])\n\
    \        } else {\n            l_sorted.append(l_odd[i/2])\n        }\n    }\n\
    \    return l_sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l:\
    \ [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824676
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n      \
    \  evens.append(l[i])\n    }\n    evens.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = evens[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    for\
    \ i in stride(from: 0, to: l.count, by: 2) {\n        l[i] = l[i]\n    }\n   \
    \ return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2,\
    \ 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmpvwskhwb2/tmpvwskhwb2.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad57c455c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad57c14cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad57c14c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad57c14b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvwskhwb2                        0x000055eb2965e883 <unavailable> + 6275

    5    libc.so.6                          0x00002ad57c641460 __libc_start_main +
    245

    6    tmpvwskhwb2                        0x000055eb2965e2d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824676
- exit_code: 1
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n\
    \            even_indicies.append(i)\n        }\n    }\n    let even_values =\
    \ l.filter { l.index(of: $0)! % 2 == 0 }\n    even_values.sort()\n    for i in\
    \ 0..<even_values.count {\n        l[even_indicies[i]] = even_values[i]\n    }\n\
    \    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2,\
    \ 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: SyntaxError
  stderr: "/tmp/tmpqlnvojq2.swift:17:36: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    let even_values = l.filter { l.index(of: $0)! % 2\
    \ == 0 }\n                                   ^\n/tmp/tmpqlnvojq2.swift:17:36:\
    \ note: use 'firstIndex(of:)' instead\n    let even_values = l.filter { l.index(of:\
    \ $0)! % 2 == 0 }\n                                   ^~~~~\n                \
    \                   firstIndex\n/tmp/tmpqlnvojq2.swift:18:17: error: cannot use\
    \ mutating member on immutable value: 'even_values' is a 'let' constant\n    even_values.sort()\n\
    \    ~~~~~~~~~~~ ^\n/tmp/tmpqlnvojq2.swift:17:5: note: change 'let' to 'var' to\
    \ make it mutable\n    let even_values = l.filter { l.index(of: $0)! % 2 == 0\
    \ }\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659824676
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_prime = l\n \
    \   var even_indicies = [Int]()\n    var even_values = [Int]()\n    for i in 0..<l.count\
    \ {\n        if i % 2 == 0 {\n            even_indicies.append(i)\n          \
    \  even_values.append(l[i])\n        }\n    }\n    even_values.sort()\n    for\
    \ i in 0..<even_indicies.count {\n        l_prime[even_indicies[i]] = even_values[i]\n\
    \    }\n    return l_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l:\
    \ [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even_indicies: [Int] = []\n    for i in 0..<l.count {\n        if i % 2 == 0\
    \ {\n            even_indicies.append(i)\n        }\n    }\n    for i in 0..<even_indicies.count\
    \ {\n        for j in 0..<even_indicies.count - 1 {\n            if l[even_indicies[j]]\
    \ > l[even_indicies[j + 1]] {\n                let temp = l[even_indicies[j]]\n\
    \                l[even_indicies[j]] = l[even_indicies[j + 1]]\n             \
    \   l[even_indicies[j + 1]] = temp\n            }\n        }\n    }\n    return\
    \ l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1,\
    \ 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_copy = l\n  \
    \  var even_indicies: [Int] = []\n    for i in 0..<l.count {\n        if i % 2\
    \ == 0 {\n            even_indicies.append(i)\n        }\n    }\n    for i in\
    \ even_indicies {\n        l_copy[i] = l[i]\n    }\n    return l_copy\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmpex_unbt5/tmpex_unbt5.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afa210e6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa20dddb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afa20ddd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afa20ddc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpex_unbt5                        0x0000557a94b8b9c3 <unavailable> + 6595

    5    libc.so.6                          0x00002afa212d2460 __libc_start_main +
    245

    6    tmpex_unbt5                        0x0000557a94b8b419 <unavailable> + 5145

    '
  stdout: ''
  timestamp: 1659824676
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    for\
    \ i in stride(from: 0, to: l.count, by: 2) {\n        for j in stride(from: i\
    \ + 2, to: l.count, by: 2) {\n            if l[i] > l[j] {\n                l.swapAt(i,\
    \ j)\n            }\n        }\n    }\n    return l\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824676
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_prime = l\n \
    \   var evens = [Int]()\n    for (index, value) in l.enumerated() {\n        if\
    \ index % 2 == 0 {\n            evens.append(value)\n        }\n    }\n    evens.sort()\n\
    \    for (index, value) in l.enumerated() {\n        if index % 2 == 0 {\n   \
    \         l_prime[index] = evens[index/2]\n        }\n    }\n    return l_prime\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824676
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var result = l\n  \
    \  for i in stride(from: 0, to: l.count, by: 2) {\n        result[i] = l[i]\n\
    \    }\n    for i in stride(from: 1, to: l.count, by: 2) {\n        result[i]\
    \ = l[i]\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2,\
    \ -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l:\
    \ [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmp81glibn3/tmp81glibn3.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b84e8891c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b84e8588b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b84e8588988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b84e85877b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp81glibn3                        0x00005585e4e7a883 <unavailable> + 6275

    5    libc.so.6                          0x00002b84e8a7d460 __libc_start_main +
    245

    6    tmp81glibn3                        0x00005585e4e7a2d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824676
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var evens = [Int]()\n\
    \    var odds = [Int]()\n    var result = [Int]()\n    for (index, value) in l.enumerated()\
    \ {\n        if index % 2 == 0 {\n            odds.append(value)\n        } else\
    \ {\n            evens.append(value)\n        }\n    }\n    evens.sort()\n   \
    \ for (index, value) in l.enumerated() {\n        if index % 2 == 0 {\n      \
    \      result.append(value)\n        } else {\n            result.append(evens.removeFirst())\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2,\
    \ -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l:\
    \ [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmpl4vh2r4i/tmpl4vh2r4i.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af21e299c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af21df90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af21df90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af21df8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl4vh2r4i                        0x000055c9d3f56a93 <unavailable> + 6803

    5    libc.so.6                          0x00002af21e485460 __libc_start_main +
    245

    6    tmpl4vh2r4i                        0x000055c9d3f564e9 <unavailable> + 5353

    '
  stdout: ''
  timestamp: 1659824676
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even_indicies = [Int]()\n    for i in 0..<l.count {\n        if i % 2 == 0 {\n\
    \            even_indicies.append(i)\n        }\n    }\n    for i in 0..<even_indicies.count\
    \ {\n        for j in 0..<even_indicies.count - 1 {\n            if l[even_indicies[j]]\
    \ > l[even_indicies[j + 1]] {\n                let temp = l[even_indicies[j]]\n\
    \                l[even_indicies[j]] = l[even_indicies[j + 1]]\n             \
    \   l[even_indicies[j + 1]] = temp\n            }\n        }\n    }\n    return\
    \ l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1,\
    \ 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: 0
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ even = [Int]()\n    for i in stride(from: 0, to: l.count, by: 2) {\n       \
    \ even.append(l[i])\n    }\n    even.sort()\n    for i in stride(from: 0, to:\
    \ l.count, by: 2) {\n        l[i] = even[i/2]\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l = l\n    var\
    \ evens = [Int]()\n    var odds = [Int]()\n    for i in 0..<l.count {\n      \
    \  if i % 2 == 0 {\n            odds.append(l[i])\n        } else {\n        \
    \    evens.append(l[i])\n        }\n    }\n    evens.sort()\n    for i in 0..<evens.count\
    \ {\n        l[i * 2 + 1] = evens[i]\n    }\n    return l\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9,\
    \ 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12,\
    \ 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmp_h8dd5m1/tmp_h8dd5m1.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae2edec2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae2edbb9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae2edbb9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae2edbb87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_h8dd5m1                        0x00005617ce3c09d3 <unavailable> + 6611

    5    libc.so.6                          0x00002ae2ee0ae460 __libc_start_main +
    245

    6    tmp_h8dd5m1                        0x00005617ce3c0429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1659824676
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var evens = [Int]()\n\
    \    var odds = [Int]()\n    var result = [Int]()\n    for (index, value) in l.enumerated()\
    \ {\n        if index % 2 == 0 {\n            odds.append(value)\n        } else\
    \ {\n            evens.append(value)\n        }\n    }\n    evens.sort()\n   \
    \ for (index, value) in l.enumerated() {\n        if index % 2 == 0 {\n      \
    \      result.append(value)\n        } else {\n            result.append(evens.removeFirst())\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2,\
    \ -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l:\
    \ [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmpl4vh2r4i/tmpl4vh2r4i.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af21e299c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af21df90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af21df90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af21df8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl4vh2r4i                        0x000055c9d3f56a93 <unavailable> + 6803

    5    libc.so.6                          0x00002af21e485460 __libc_start_main +
    245

    6    tmpl4vh2r4i                        0x000055c9d3f564e9 <unavailable> + 5353

    '
  stdout: ''
  timestamp: 1659824676
- exit_code: -4
  program: "\n/// This function takes an array l and returns an array l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(l: [1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even(l: [5, 6, 3, 4])\n\
    /// [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n    var l_copy = l\n  \
    \  for i in stride(from: 0, to: l.count, by: 2) {\n        l_copy[i] = l[i]\n\
    \    }\n    for i in stride(from: 1, to: l.count, by: 2) {\n        l_copy[i]\
    \ = l[i]\n    }\n    return l_copy\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2,\
    \ -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l:\
    \ [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
  status: Exception
  stderr: 'tmpyybih2fi/tmpyybih2fi.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b710f978c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b710f66fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b710f66f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b710f66e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyybih2fi                        0x000055cd99968883 <unavailable> + 6275

    5    libc.so.6                          0x00002b710fb64460 __libc_start_main +
    245

    6    tmpyybih2fi                        0x000055cd999682d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824676
