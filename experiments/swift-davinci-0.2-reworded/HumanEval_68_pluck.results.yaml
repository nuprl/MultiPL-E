language: swift
name: HumanEval_68_pluck
results:
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr.enumerated().filter { $0.element\
    \ % 2 == 0 }.min { $0.element < $1.element }?.reversed() ?? []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_s2yc6jv.swift:28:93: error: value of tuple type 'EnumeratedSequence<[Int]>.Iterator.Element'\
    \ (aka '(offset: Int, element: Int)') has no member 'reversed'\n    return arr.enumerated().filter\
    \ { $0.element % 2 == 0 }.min { $0.element < $1.element }?.reversed() ?? []\n\
    \           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var smallestEvenValue = Int.max\n    var\
    \ smallestEvenValueIndex = Int.max\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 && value < smallestEvenValue {\n            smallestEvenValue\
    \ = value\n            smallestEvenValueIndex = index\n        }\n    }\n    return\
    \ smallestEvenValue == Int.max ? [] : [smallestEvenValue, smallestEvenValueIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens = [Int]()\n    var evensIndex\
    \ = [Int]()\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 {\n            evens.append(value)\n            evensIndex.append(index)\n\
    \        }\n    }\n    if evens.count == 0 {\n        return []\n    }\n    var\
    \ min = evens[0]\n    var minIndex = evensIndex[0]\n    for (index, value) in\
    \ evens.enumerated() {\n        if value < min {\n            min = value\n  \
    \          minIndex = evensIndex[index]\n        }\n    }\n    return [min, minIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return\
    \ [] }\n    let smallestEven = evens.min()!\n    let index = arr.firstIndex(of:\
    \ smallestEven)!\n    return [smallestEven, index]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var minEven =\
    \ Int.max\n    var minEvenIndex = Int.max\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 && value < minEven {\n            minEven = value\n\
    \            minEvenIndex = index\n        }\n    }\n    if minEven != Int.max\
    \ {\n        result.append(minEven)\n        result.append(minEvenIndex)\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.count > 0 else { return [] }\n\
    \    var evens: [Int] = []\n    var evensIndex: [Int] = []\n    for (index, value)\
    \ in arr.enumerated() {\n        if value % 2 == 0 {\n            evens.append(value)\n\
    \            evensIndex.append(index)\n        }\n    }\n    guard evens.count\
    \ > 0 else { return [] }\n    let minEven = evens.min()!\n    let minEvenIndex\
    \ = evensIndex[evens.firstIndex(of: minEven)!]\n    return [minEven, minEvenIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let min = evens.min() else { return [] }\n    let index = arr.firstIndex(of:\
    \ min) ?? 0\n    return [min, index]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\n\
    assert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0,\
    \ 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr:\
    \ [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let min = evens.min() else { return [] }\n    let index = arr.firstIndex(of:\
    \ min) ?? 0\n    return [min, index]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\n\
    assert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0,\
    \ 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr:\
    \ [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return\
    \ [] }\n    let minEven = evens.min()!\n    let index = arr.firstIndex(of: minEven)!\n\
    \    return [minEven, index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens = [Int]()\n    var evensIndex\
    \ = [Int]()\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 {\n            evens.append(value)\n            evensIndex.append(index)\n\
    \        }\n    }\n    if evens.count == 0 {\n        return []\n    }\n    var\
    \ min = evens[0]\n    var minIndex = evensIndex[0]\n    for (index, value) in\
    \ evens.enumerated() {\n        if value < min {\n            min = value\n  \
    \          minIndex = evensIndex[index]\n        }\n    }\n    return [min, minIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.count > 0 else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard evens.count > 0 else {\
    \ return [] }\n    let minEven = evens.min()!\n    let minEvenIndex = arr.firstIndex(of:\
    \ minEven)!\n    return [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr.enumerated().filter { $0.element\
    \ % 2 == 0 }.min { $0.element < $1.element }?.reversed() ?? []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_s2yc6jv.swift:28:93: error: value of tuple type 'EnumeratedSequence<[Int]>.Iterator.Element'\
    \ (aka '(offset: Int, element: Int)') has no member 'reversed'\n    return arr.enumerated().filter\
    \ { $0.element % 2 == 0 }.min { $0.element < $1.element }?.reversed() ?? []\n\
    \           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let smallestEven = evens.min() else { return [] }\n    guard let index\
    \ = arr.firstIndex(of: smallestEven) else { return [] }\n    return [smallestEven,\
    \ index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3])\
    \ == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as\
    \ [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return\
    \ [] }\n    let smallestEven = evens.min()!\n    let index = arr.firstIndex(of:\
    \ smallestEven)!\n    return [smallestEven, index]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return\
    \ [] }\n    let minEven = evens.min()!\n    let idx = arr.firstIndex(of: minEven)!\n\
    \    return [minEven, idx]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return\
    \ [] }\n    let minEven = evens.min()!\n    let minEvenIndex = arr.firstIndex(of:\
    \ minEven)!\n    return [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    guard let minEven = arr.filter({ $0 % 2 == 0 }).min() else { return [] }\n\
    \    return [minEven, arr.firstIndex(of: minEven)!]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var smallestEven = Int.max\n    var smallestEvenIndex\
    \ = Int.max\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 {\n            if value < smallestEven {\n                smallestEven\
    \ = value\n                smallestEvenIndex = index\n            }\n        }\n\
    \    }\n    if smallestEven == Int.max {\n        return []\n    }\n    return\
    \ [smallestEven, smallestEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\n\
    assert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0,\
    \ 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr:\
    \ [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var minEven =\
    \ Int.max\n    var minEvenIndex = Int.max\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 {\n            if value < minEven {\n         \
    \       minEven = value\n                minEvenIndex = index\n            }\n\
    \        }\n    }\n    if minEven != Int.max {\n        result.append(minEven)\n\
    \        result.append(minEvenIndex)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var smallestEven: Int?\n    var smallestEvenIndex:\
    \ Int?\n    for (index, value) in arr.enumerated() {\n        if value % 2 ==\
    \ 0 {\n            if smallestEven == nil || value < smallestEven! {\n       \
    \         smallestEven = value\n                smallestEvenIndex = index\n  \
    \          }\n        }\n    }\n    if let smallestEven = smallestEven, let smallestEvenIndex\
    \ = smallestEvenIndex {\n        return [smallestEven, smallestEvenIndex]\n  \
    \  }\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var minEven =\
    \ Int.max\n    var minEvenIndex = Int.max\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 && value < minEven {\n            minEven = value\n\
    \            minEvenIndex = index\n        }\n    }\n    if minEven != Int.max\
    \ {\n        result.append(minEven)\n        result.append(minEvenIndex)\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let min = evens.min() else { return [] }\n    let index = arr.firstIndex(of:\
    \ min) ?? 0\n    return [min, index]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\n\
    assert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0,\
    \ 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr:\
    \ [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens = [Int]()\n    var evensIndex\
    \ = [Int]()\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 {\n            evens.append(value)\n            evensIndex.append(index)\n\
    \        }\n    }\n    if evens.count == 0 {\n        return []\n    }\n    var\
    \ minEven = evens[0]\n    var minEvenIndex = evensIndex[0]\n    for (index, value)\
    \ in evens.enumerated() {\n        if value < minEven {\n            minEven =\
    \ value\n            minEvenIndex = evensIndex[index]\n        }\n    }\n    return\
    \ [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var minEven =\
    \ Int.max\n    var minEvenIndex = Int.max\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 {\n            if value < minEven {\n         \
    \       minEven = value\n                minEvenIndex = index\n            }\n\
    \        }\n    }\n    if minEven != Int.max {\n        result.append(minEven)\n\
    \        result.append(minEvenIndex)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return\
    \ [] }\n    let minEven = evens.min()!\n    let index = arr.firstIndex(of: minEven)!\n\
    \    return [minEven, index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.count > 0 else { return [] }\n\
    \    var evens = [Int]()\n    for (index, value) in arr.enumerated() {\n     \
    \   if value % 2 == 0 {\n            evens.append(value)\n        }\n    }\n \
    \   guard evens.count > 0 else { return [] }\n    let min = evens.min()\n    for\
    \ (index, value) in arr.enumerated() {\n        if value == min {\n          \
    \  return [value, index]\n        }\n    }\n    return []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let min = evens.min() else { return [] }\n    let index = arr.firstIndex(of:\
    \ min) ?? 0\n    return [min, index]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\n\
    assert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0,\
    \ 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr:\
    \ [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard let minEven = evens.min()\
    \ else { return [] }\n    let minEvenIndex = arr.firstIndex(of: minEven)!\n  \
    \  return [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return\
    \ [] }\n    let minEven = evens.min()!\n    let minEvenIndex = arr.firstIndex(of:\
    \ minEven)!\n    return [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let smallestEven = evens.min() else { return [] }\n    guard let index\
    \ = arr.firstIndex(of: smallestEven) else { return [] }\n    return [smallestEven,\
    \ index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3])\
    \ == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as\
    \ [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var minEven = Int.max\n    var minEvenIndex\
    \ = Int.max\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 {\n            if value < minEven {\n                minEven = value\n\
    \                minEvenIndex = index\n            }\n        }\n    }\n    if\
    \ minEven == Int.max {\n        return []\n    }\n    return [minEven, minEvenIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var minEven =\
    \ Int.max\n    for (index, value) in arr.enumerated() {\n        if value % 2\
    \ == 0 && value < minEven {\n            minEven = value\n            result =\
    \ [value, index]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let min = evens.min() else { return [] }\n    let index = arr.firstIndex(of:\
    \ min) ?? 0\n    return [min, index]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\n\
    assert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0,\
    \ 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr:\
    \ [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens = [Int]()\n    var evensIndex\
    \ = [Int]()\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 {\n            evens.append(value)\n            evensIndex.append(index)\n\
    \        }\n    }\n    if evens.count == 0 {\n        return []\n    }\n    let\
    \ minEven = evens.min()!\n    let minEvenIndex = evensIndex[evens.firstIndex(of:\
    \ minEven)!]\n    return [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var min = Int.max\n\
    \    for (index, value) in arr.enumerated() {\n        if value % 2 == 0 && value\
    \ < min {\n            min = value\n            result = [value, index]\n    \
    \    }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var smallestEven = Int.max\n    var smallestEvenIndex\
    \ = Int.max\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 && value < smallestEven {\n            smallestEven = value\n       \
    \     smallestEvenIndex = index\n        }\n    }\n    return smallestEven ==\
    \ Int.max ? [] : [smallestEven, smallestEvenIndex]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr.enumerated().filter { $0.element\
    \ % 2 == 0 }.min { $0.element < $1.element }?.reversed() ?? []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_s2yc6jv.swift:28:93: error: value of tuple type 'EnumeratedSequence<[Int]>.Iterator.Element'\
    \ (aka '(offset: Int, element: Int)') has no member 'reversed'\n    return arr.enumerated().filter\
    \ { $0.element % 2 == 0 }.min { $0.element < $1.element }?.reversed() ?? []\n\
    \           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var smallestEven: Int?\n    var smallestEvenIndex:\
    \ Int?\n    for (index, value) in arr.enumerated() {\n        if value % 2 ==\
    \ 0 {\n            if smallestEven == nil || value < smallestEven! {\n       \
    \         smallestEven = value\n                smallestEvenIndex = index\n  \
    \          }\n        }\n    }\n    if let smallestEven = smallestEven, let smallestEvenIndex\
    \ = smallestEvenIndex {\n        return [smallestEven, smallestEvenIndex]\n  \
    \  }\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let min = evens.min() else { return [] }\n    return [min, arr.firstIndex(of:\
    \ min)!]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3])\
    \ == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as\
    \ [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.count > 0 else { return [] }\n\
    \    var evens = [Int]()\n    for (index, value) in arr.enumerated() {\n     \
    \   if value % 2 == 0 {\n            evens.append(value)\n        }\n    }\n \
    \   guard evens.count > 0 else { return [] }\n    let min = evens.min()!\n   \
    \ for (index, value) in arr.enumerated() {\n        if value == min {\n      \
    \      return [value, index]\n        }\n    }\n    return []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens = [Int]()\n    var evensIndex\
    \ = [Int]()\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 {\n            evens.append(value)\n            evensIndex.append(index)\n\
    \        }\n    }\n    if evens.count == 0 {\n        return []\n    }\n    var\
    \ min = evens[0]\n    var minIndex = evensIndex[0]\n    for (index, value) in\
    \ evens.enumerated() {\n        if value < min {\n            min = value\n  \
    \          minIndex = evensIndex[index]\n        }\n    }\n    return [min, minIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr.enumerated().filter { $0.element\
    \ % 2 == 0 }.min { $0.element < $1.element }?.reversed() ?? []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_s2yc6jv.swift:28:93: error: value of tuple type 'EnumeratedSequence<[Int]>.Iterator.Element'\
    \ (aka '(offset: Int, element: Int)') has no member 'reversed'\n    return arr.enumerated().filter\
    \ { $0.element % 2 == 0 }.min { $0.element < $1.element }?.reversed() ?? []\n\
    \           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013364
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr.enumerated().filter { $0.element\
    \ % 2 == 0 }.min { $0.element < $1.element }?.reversed() ?? []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_s2yc6jv.swift:28:93: error: value of tuple type 'EnumeratedSequence<[Int]>.Iterator.Element'\
    \ (aka '(offset: Int, element: Int)') has no member 'reversed'\n    return arr.enumerated().filter\
    \ { $0.element % 2 == 0 }.min { $0.element < $1.element }?.reversed() ?? []\n\
    \           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var minEven =\
    \ Int.max\n    var minEvenIndex = Int.max\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 && value < minEven {\n            minEven = value\n\
    \            minEvenIndex = index\n        }\n    }\n    if minEven != Int.max\
    \ {\n        result.append(minEven)\n        result.append(minEvenIndex)\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens = [Int]()\n    var evensIndex\
    \ = [Int]()\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 {\n            evens.append(value)\n            evensIndex.append(index)\n\
    \        }\n    }\n    if evens.count == 0 {\n        return []\n    }\n    var\
    \ min = evens[0]\n    var minIndex = evensIndex[0]\n    for (index, value) in\
    \ evens.enumerated() {\n        if value < min {\n            min = value\n  \
    \          minIndex = evensIndex[index]\n        }\n    }\n    return [min, minIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return\
    \ [] }\n    let minEven = evens.min()!\n    let minEvenIndex = arr.firstIndex(of:\
    \ minEven)!\n    return [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let min = evens.min() else { return [] }\n    let index = arr.firstIndex(of:\
    \ min) ?? 0\n    return [min, index]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\n\
    assert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0,\
    \ 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr:\
    \ [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let smallestEven = evens.min() else { return [] }\n    guard let index\
    \ = arr.firstIndex(of: smallestEven) else { return [] }\n    return [smallestEven,\
    \ index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3])\
    \ == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as\
    \ [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr.enumerated().filter { $0.element\
    \ % 2 == 0 }.min { $0.element < $1.element }?.reversed() ?? []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_s2yc6jv.swift:28:93: error: value of tuple type 'EnumeratedSequence<[Int]>.Iterator.Element'\
    \ (aka '(offset: Int, element: Int)') has no member 'reversed'\n    return arr.enumerated().filter\
    \ { $0.element % 2 == 0 }.min { $0.element < $1.element }?.reversed() ?? []\n\
    \           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var minEven =\
    \ Int.max\n    var minEvenIndex = Int.max\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 {\n            if value < minEven {\n         \
    \       minEven = value\n                minEvenIndex = index\n            }\n\
    \        }\n    }\n    if minEven != Int.max {\n        result.append(minEven)\n\
    \        result.append(minEvenIndex)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var minEven =\
    \ Int.max\n    var minEvenIndex = Int.max\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 {\n            if value < minEven {\n         \
    \       minEven = value\n                minEvenIndex = index\n            }\n\
    \        }\n    }\n    if minEven != Int.max {\n        result.append(minEven)\n\
    \        result.append(minEvenIndex)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.count > 0 else { return [] }\n\
    \    var evens = [Int]()\n    for (index, value) in arr.enumerated() {\n     \
    \   if value % 2 == 0 {\n            evens.append(value)\n        }\n    }\n \
    \   guard evens.count > 0 else { return [] }\n    let min = evens.min()!\n   \
    \ for (index, value) in arr.enumerated() {\n        if value == min {\n      \
    \      return [value, index]\n        }\n    }\n    return []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens: [Int] = []\n    var evensIndex:\
    \ [Int] = []\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 {\n            evens.append(value)\n            evensIndex.append(index)\n\
    \        }\n    }\n    if evens.count == 0 {\n        return []\n    }\n    let\
    \ minEven = evens.min()!\n    let minEvenIndex = evensIndex[evens.firstIndex(of:\
    \ minEven)!]\n    return [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var minEven = Int.max\n    var minEvenIndex\
    \ = Int.max\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 {\n            if value < minEven {\n                minEven = value\n\
    \                minEvenIndex = index\n            }\n        }\n    }\n    if\
    \ minEven == Int.max {\n        return []\n    }\n    return [minEven, minEvenIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens = [Int]()\n    var evenIndexes\
    \ = [Int]()\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 {\n            evens.append(value)\n            evenIndexes.append(index)\n\
    \        }\n    }\n    if evens.count == 0 {\n        return []\n    }\n    var\
    \ minEven = evens[0]\n    var minEvenIndex = evenIndexes[0]\n    for (index, value)\
    \ in evens.enumerated() {\n        if value < minEven {\n            minEven =\
    \ value\n            minEvenIndex = evenIndexes[index]\n        }\n    }\n   \
    \ return [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens = [Int]()\n    var evensIndex\
    \ = [Int]()\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 {\n            evens.append(value)\n            evensIndex.append(index)\n\
    \        }\n    }\n    if evens.count == 0 {\n        return []\n    }\n    var\
    \ min = evens[0]\n    var minIndex = evensIndex[0]\n    for (index, value) in\
    \ evens.enumerated() {\n        if value < min {\n            min = value\n  \
    \          minIndex = evensIndex[index]\n        }\n    }\n    return [min, minIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens = [Int]()\n    var evensIndex\
    \ = [Int]()\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 {\n            evens.append(value)\n            evensIndex.append(index)\n\
    \        }\n    }\n    if evens.count == 0 {\n        return []\n    }\n    var\
    \ min = evens[0]\n    var minIndex = evensIndex[0]\n    for i in 1..<evens.count\
    \ {\n        if evens[i] < min {\n            min = evens[i]\n            minIndex\
    \ = evensIndex[i]\n        }\n    }\n    return [min, minIndex]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let min = evens.min() else { return [] }\n    return [min, arr.firstIndex(of:\
    \ min)!]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3])\
    \ == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as\
    \ [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let min = evens.min() else { return [] }\n    let index = arr.firstIndex(of:\
    \ min) ?? 0\n    return [min, index]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\n\
    assert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0,\
    \ 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr:\
    \ [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens = [Int]()\n    var index = 0\n\
    \    for i in arr {\n        if i % 2 == 0 {\n            evens.append(i)\n  \
    \      }\n    }\n    if evens.count == 0 {\n        return []\n    }\n    var\
    \ min = evens[0]\n    for i in evens {\n        if i < min {\n            min\
    \ = i\n        }\n    }\n    for i in arr {\n        if i == min {\n         \
    \   return [i, index]\n        }\n        index += 1\n    }\n    return []\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let min = evens.min() else { return [] }\n    let index = arr.firstIndex(of:\
    \ min) ?? 0\n    return [min, index]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\n\
    assert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0,\
    \ 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr:\
    \ [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let min = evens.min() else { return [] }\n    guard let index = arr.firstIndex(of:\
    \ min) else { return [] }\n    return [min, index]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var minEven = Int.max\n    var minEvenIndex\
    \ = Int.max\n    var found = false\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 {\n            if value < minEven {\n         \
    \       minEven = value\n                minEvenIndex = index\n              \
    \  found = true\n            }\n        }\n    }\n    if found {\n        return\
    \ [minEven, minEvenIndex]\n    } else {\n        return []\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr.enumerated().filter { $0.element\
    \ % 2 == 0 }.min { $0.element < $1.element }?.reversed() ?? []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_s2yc6jv.swift:28:93: error: value of tuple type 'EnumeratedSequence<[Int]>.Iterator.Element'\
    \ (aka '(offset: Int, element: Int)') has no member 'reversed'\n    return arr.enumerated().filter\
    \ { $0.element % 2 == 0 }.min { $0.element < $1.element }?.reversed() ?? []\n\
    \           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens = [Int]()\n    var evensIndex\
    \ = [Int]()\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 {\n            evens.append(value)\n            evensIndex.append(index)\n\
    \        }\n    }\n    if evens.count == 0 {\n        return []\n    }\n    var\
    \ min = evens[0]\n    var minIndex = evensIndex[0]\n    for (index, value) in\
    \ evens.enumerated() {\n        if value < min {\n            min = value\n  \
    \          minIndex = evensIndex[index]\n        }\n    }\n    return [min, minIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr.enumerated().filter { $0.element\
    \ % 2 == 0 }.min { $0.element < $1.element }?.reversed() ?? []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_s2yc6jv.swift:28:93: error: value of tuple type 'EnumeratedSequence<[Int]>.Iterator.Element'\
    \ (aka '(offset: Int, element: Int)') has no member 'reversed'\n    return arr.enumerated().filter\
    \ { $0.element % 2 == 0 }.min { $0.element < $1.element }?.reversed() ?? []\n\
    \           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let smallestEven = evens.min() else { return [] }\n    guard let index\
    \ = arr.firstIndex(of: smallestEven) else { return [] }\n    return [smallestEven,\
    \ index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3])\
    \ == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as\
    \ [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.count > 0 else { return [] }\n\
    \    var evens = [Int]()\n    for i in 0..<arr.count {\n        if arr[i] % 2\
    \ == 0 {\n            evens.append(arr[i])\n        }\n    }\n    guard evens.count\
    \ > 0 else { return [] }\n    let min = evens.min()!\n    for i in 0..<arr.count\
    \ {\n        if arr[i] == min {\n            return [min, i]\n        }\n    }\n\
    \    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return\
    \ [] }\n    let smallestEven = evens.min()!\n    let smallestEvenIndex = arr.firstIndex(of:\
    \ smallestEven)!\n    return [smallestEven, smallestEvenIndex]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var smallestEvenValue = Int.max\n    var\
    \ smallestEvenValueIndex = -1\n    for (index, value) in arr.enumerated() {\n\
    \        if value % 2 == 0 && value < smallestEvenValue {\n            smallestEvenValue\
    \ = value\n            smallestEvenValueIndex = index\n        }\n    }\n    if\
    \ smallestEvenValueIndex == -1 {\n        return []\n    }\n    return [smallestEvenValue,\
    \ smallestEvenValueIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var minEven =\
    \ Int.max\n    var minEvenIndex = Int.max\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 {\n            if value < minEven {\n         \
    \       minEven = value\n                minEvenIndex = index\n            }\n\
    \        }\n    }\n    if minEven != Int.max {\n        result.append(minEven)\n\
    \        result.append(minEvenIndex)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens = [Int]()\n    var evensIndex\
    \ = [Int]()\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 {\n            evens.append(value)\n            evensIndex.append(index)\n\
    \        }\n    }\n    if evens.count == 0 {\n        return []\n    }\n    let\
    \ minEven = evens.min()!\n    let minEvenIndex = evensIndex[evens.firstIndex(of:\
    \ minEven)!]\n    return [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var smallestEven: Int?\n    var smallestEvenIndex:\
    \ Int?\n    for (index, value) in arr.enumerated() {\n        if value % 2 ==\
    \ 0 {\n            if smallestEven == nil || value < smallestEven! {\n       \
    \         smallestEven = value\n                smallestEvenIndex = index\n  \
    \          }\n        }\n    }\n    if let smallestEven = smallestEven, let smallestEvenIndex\
    \ = smallestEvenIndex {\n        return [smallestEven, smallestEvenIndex]\n  \
    \  }\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var smallestEven\
    \ = Int.max\n    var smallestEvenIndex = Int.max\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 && value < smallestEven {\n            smallestEven\
    \ = value\n            smallestEvenIndex = index\n        }\n    }\n    if smallestEven\
    \ != Int.max {\n        result.append(smallestEven)\n        result.append(smallestEvenIndex)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.count > 0 else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard evens.count > 0 else {\
    \ return [] }\n    let minEven = evens.min()!\n    let minEvenIndex = arr.firstIndex(of:\
    \ minEven)!\n    return [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let min = evens.min() else { return [] }\n    return [min, arr.firstIndex(of:\
    \ min)!]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3])\
    \ == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as\
    \ [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let minEven = evens.min() else { return [] }\n    let minEvenIndex\
    \ = arr.firstIndex(of: minEven)!\n    return [minEven, minEvenIndex]\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens = [Int]()\n    var evensIndex\
    \ = [Int]()\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 {\n            evens.append(value)\n            evensIndex.append(index)\n\
    \        }\n    }\n    if evens.count == 0 {\n        return []\n    }\n    var\
    \ min = evens[0]\n    var minIndex = evensIndex[0]\n    for (index, value) in\
    \ evens.enumerated() {\n        if value < min {\n            min = value\n  \
    \          minIndex = evensIndex[index]\n        }\n    }\n    return [min, minIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.contains(where: { $0 % 2 == 0\
    \ }) else { return [] }\n    let evens = arr.filter { $0 % 2 == 0 }\n    let min\
    \ = evens.min()!\n    let index = arr.firstIndex(of: min)!\n    return [min, index]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var minEven = Int.max\n    var minEvenIndex\
    \ = Int.max\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 && value < minEven {\n            minEven = value\n            minEvenIndex\
    \ = index\n        }\n    }\n    if minEven == Int.max {\n        return []\n\
    \    }\n    return [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let smallestEven = evens.min() else { return [] }\n    let smallestEvenIndex\
    \ = arr.firstIndex(of: smallestEven)!\n    return [smallestEven, smallestEvenIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return\
    \ [] }\n    let min = evens.min()!\n    let index = arr.firstIndex(of: min)!\n\
    \    return [min, index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.count > 0 else { return [] }\n\
    \    var evens = [Int]()\n    for (index, value) in arr.enumerated() {\n     \
    \   if value % 2 == 0 {\n            evens.append(value)\n        }\n    }\n \
    \   guard evens.count > 0 else { return [] }\n    let min = evens.min()!\n   \
    \ for (index, value) in arr.enumerated() {\n        if value == min {\n      \
    \      return [value, index]\n        }\n    }\n    return []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens = [Int]()\n    var evenIndexes\
    \ = [Int]()\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 {\n            evens.append(value)\n            evenIndexes.append(index)\n\
    \        }\n    }\n    if evens.count == 0 {\n        return []\n    }\n    let\
    \ minEven = evens.min()!\n    let minEvenIndex = evenIndexes[evens.firstIndex(of:\
    \ minEven)!]\n    return [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens = [Int]()\n    var evensIndex\
    \ = [Int]()\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 {\n            evens.append(value)\n            evensIndex.append(index)\n\
    \        }\n    }\n    if evens.count == 0 {\n        return []\n    }\n    let\
    \ minEven = evens.min()!\n    let minEvenIndex = evensIndex[evens.firstIndex(of:\
    \ minEven)!]\n    return [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var min = Int.max\n\
    \    var index = -1\n    for (i, item) in arr.enumerated() {\n        if item\
    \ % 2 == 0 && item < min {\n            min = item\n            index = i\n  \
    \      }\n    }\n    if index != -1 {\n        result.append(min)\n        result.append(index)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let minEven = evens.min() else { return [] }\n    let index = arr.firstIndex(of:\
    \ minEven)!\n    return [minEven, index]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\n\
    assert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0,\
    \ 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr:\
    \ [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return\
    \ [] }\n    let minEven = evens.min()!\n    let minEvenIndex = arr.firstIndex(of:\
    \ minEven)!\n    return [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr.enumerated().filter { $0.element\
    \ % 2 == 0 }.min { $0.element < $1.element }?.reversed() ?? []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_s2yc6jv.swift:28:93: error: value of tuple type 'EnumeratedSequence<[Int]>.Iterator.Element'\
    \ (aka '(offset: Int, element: Int)') has no member 'reversed'\n    return arr.enumerated().filter\
    \ { $0.element % 2 == 0 }.min { $0.element < $1.element }?.reversed() ?? []\n\
    \           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.count > 0 else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard evens.count > 0 else {\
    \ return [] }\n    let minEven = evens.min()!\n    let minEvenIndex = arr.firstIndex(of:\
    \ minEven)!\n    return [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var evens = [Int]()\n\
    \    for i in 0..<arr.count {\n        if arr[i] % 2 == 0 {\n            evens.append(arr[i])\n\
    \        }\n    }\n    if evens.count > 0 {\n        let min = evens.min()\n \
    \       for i in 0..<arr.count {\n            if arr[i] == min {\n           \
    \     result.append(arr[i])\n                result.append(i)\n              \
    \  break\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var minEven =\
    \ Int.max\n    var minEvenIndex = Int.max\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 {\n            if value < minEven {\n         \
    \       minEven = value\n                minEvenIndex = index\n            }\n\
    \        }\n    }\n    if minEven != Int.max {\n        result.append(minEven)\n\
    \        result.append(minEvenIndex)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    // your code here\n    return []\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmp1trbo8cb/tmp1trbo8cb.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e5afcbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e5acc2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9e5acc2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9e5acc17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1trbo8cb                        0x00005560d5b543bc <unavailable> + 5052

    5    libc.so.6                          0x00002b9e5b1b7460 __libc_start_main +
    245

    6    tmp1trbo8cb                        0x00005560d5b53fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let minEven = evens.min() else { return [] }\n    let minEvenIndex\
    \ = arr.firstIndex(of: minEven)!\n    return [minEven, minEvenIndex]\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var minEven =\
    \ Int.max\n    var minEvenIndex = Int.max\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 && value < minEven {\n            minEven = value\n\
    \            minEvenIndex = index\n        }\n    }\n    if minEven != Int.max\
    \ {\n        result.append(minEven)\n        result.append(minEvenIndex)\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr.enumerated().filter { $0.element\
    \ % 2 == 0 }.min { $0.element < $1.element }?.map { [$0.element, $0.offset] }\
    \ ?? []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int])\
    \ == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp1d9_hgv3.swift:28:93: error: value of tuple type 'EnumeratedSequence<[Int]>.Iterator.Element'\
    \ (aka '(offset: Int, element: Int)') has no member 'map'\n    return arr.enumerated().filter\
    \ { $0.element % 2 == 0 }.min { $0.element < $1.element }?.map { [$0.element,\
    \ $0.offset] } ?? []\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~\n"
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return\
    \ [] }\n    let minEven = evens.min()!\n    let index = arr.firstIndex(of: minEven)!\n\
    \    return [minEven, index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.count > 0 else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard evens.count > 0 else {\
    \ return [] }\n    let smallestEven = evens.min()!\n    let index = arr.firstIndex(of:\
    \ smallestEven)!\n    return [smallestEven, index]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.count > 0 else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard evens.count > 0 else {\
    \ return [] }\n    let minEven = evens.min()!\n    guard let index = arr.firstIndex(of:\
    \ minEven) else { return [] }\n    return [minEven, index]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr.enumerated().filter { $0.element\
    \ % 2 == 0 }.min { $0.element < $1.element }?.reversed() ?? []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_s2yc6jv.swift:28:93: error: value of tuple type 'EnumeratedSequence<[Int]>.Iterator.Element'\
    \ (aka '(offset: Int, element: Int)') has no member 'reversed'\n    return arr.enumerated().filter\
    \ { $0.element % 2 == 0 }.min { $0.element < $1.element }?.reversed() ?? []\n\
    \           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens = [Int]()\n    var index = 0\n\
    \    for i in arr {\n        if i % 2 == 0 {\n            evens.append(i)\n  \
    \      }\n    }\n    if evens.count == 0 {\n        return []\n    }\n    evens.sort()\n\
    \    for i in arr {\n        if i == evens[0] {\n            return [i, index]\n\
    \        }\n        index += 1\n    }\n    return []\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return\
    \ [] }\n    let minEven = evens.min()!\n    let minEvenIndex = arr.firstIndex(of:\
    \ minEven)!\n    return [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var minEven =\
    \ Int.max\n    for (index, value) in arr.enumerated() {\n        if value % 2\
    \ == 0 && value < minEven {\n            minEven = value\n            result =\
    \ [value, index]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var minEven =\
    \ Int.max\n    var minEvenIndex = Int.max\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 {\n            if value < minEven {\n         \
    \       minEven = value\n                minEvenIndex = index\n            }\n\
    \        }\n    }\n    if minEven != Int.max {\n        result.append(minEven)\n\
    \        result.append(minEvenIndex)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.count > 0 else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard evens.count > 0 else {\
    \ return [] }\n    let min = evens.min()!\n    let index = arr.firstIndex(of:\
    \ min)!\n    return [min, index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens = [Int]()\n    var evensIndex\
    \ = [Int]()\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 {\n            evens.append(value)\n            evensIndex.append(index)\n\
    \        }\n    }\n    if evens.count == 0 {\n        return []\n    }\n    let\
    \ minEven = evens.min()!\n    let minEvenIndex = evensIndex[evens.firstIndex(of:\
    \ minEven)!]\n    return [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let min = evens.min() else { return [] }\n    guard let index = arr.firstIndex(of:\
    \ min) else { return [] }\n    return [min, index]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let minEven = evens.min() else { return [] }\n    guard let index =\
    \ arr.firstIndex(of: minEven) else { return [] }\n    return [minEven, index]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr.enumerated().filter { $0.element\
    \ % 2 == 0 }.min { $0.element < $1.element }?.reversed() ?? []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_s2yc6jv.swift:28:93: error: value of tuple type 'EnumeratedSequence<[Int]>.Iterator.Element'\
    \ (aka '(offset: Int, element: Int)') has no member 'reversed'\n    return arr.enumerated().filter\
    \ { $0.element % 2 == 0 }.min { $0.element < $1.element }?.reversed() ?? []\n\
    \           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return\
    \ [] }\n    let min = evens.min()!\n    let index = arr.firstIndex(of: min)!\n\
    \    return [min, index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens = [Int]()\n    var evensIndex\
    \ = [Int]()\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 {\n            evens.append(value)\n            evensIndex.append(index)\n\
    \        }\n    }\n    if evens.count == 0 {\n        return []\n    }\n    let\
    \ minEven = evens.min()!\n    let minEvenIndex = evensIndex[evens.firstIndex(of:\
    \ minEven)!]\n    return [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let min = evens.min() else { return [] }\n    guard let index = arr.firstIndex(of:\
    \ min) else { return [] }\n    return [min, index]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.count > 0 else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard evens.count > 0 else {\
    \ return [] }\n    let smallestEven = evens.min()!\n    let smallestEvenIndex\
    \ = arr.firstIndex(of: smallestEven)!\n    return [smallestEven, smallestEvenIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let min = evens.min() else { return [] }\n    let index = arr.firstIndex(of:\
    \ min) ?? 0\n    return [min, index]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\n\
    assert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0,\
    \ 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr:\
    \ [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return\
    \ [] }\n    let minEven = evens.min()!\n    let minEvenIndex = arr.firstIndex(of:\
    \ minEven)!\n    return [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.count > 0 else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard evens.count > 0 else {\
    \ return [] }\n    let min = evens.min()!\n    let index = arr.firstIndex(of:\
    \ min)!\n    return [min, index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return\
    \ [] }\n    let minEven = evens.min()!\n    let minEvenIndex = arr.firstIndex(of:\
    \ minEven)!\n    return [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return\
    \ [] }\n    let minEven = evens.min()!\n    let minEvenIndex = arr.firstIndex(of:\
    \ minEven)!\n    return [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var smallestEvenValue: Int?\n    var smallestEvenValueIndex:\
    \ Int?\n    for (index, value) in arr.enumerated() {\n        if value % 2 ==\
    \ 0 {\n            if smallestEvenValue == nil {\n                smallestEvenValue\
    \ = value\n                smallestEvenValueIndex = index\n            } else\
    \ if value < smallestEvenValue! {\n                smallestEvenValue = value\n\
    \                smallestEvenValueIndex = index\n            }\n        }\n  \
    \  }\n    if smallestEvenValue == nil {\n        return []\n    }\n    return\
    \ [smallestEvenValue!, smallestEvenValueIndex!]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return\
    \ [] }\n    let minEven = evens.min()!\n    let minEvenIndex = arr.firstIndex(of:\
    \ minEven)!\n    return [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens = [Int]()\n    var evensIndex\
    \ = [Int]()\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 {\n            evens.append(value)\n            evensIndex.append(index)\n\
    \        }\n    }\n    if evens.count == 0 {\n        return []\n    }\n    let\
    \ minEven = evens.min()\n    let minEvenIndex = evensIndex[evens.firstIndex(of:\
    \ minEven!)!]\n    return [minEven!, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var smallestEvenValue = Int.max\n    var\
    \ smallestEvenValueIndex = -1\n    for (index, value) in arr.enumerated() {\n\
    \        if value % 2 == 0 && value < smallestEvenValue {\n            smallestEvenValue\
    \ = value\n            smallestEvenValueIndex = index\n        }\n    }\n    return\
    \ smallestEvenValueIndex == -1 ? [] : [smallestEvenValue, smallestEvenValueIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens = [Int]()\n    var evensIndex\
    \ = [Int]()\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 {\n            evens.append(value)\n            evensIndex.append(index)\n\
    \        }\n    }\n    if evens.count == 0 {\n        return []\n    }\n    var\
    \ min = evens[0]\n    var minIndex = evensIndex[0]\n    for (index, value) in\
    \ evens.enumerated() {\n        if value < min {\n            min = value\n  \
    \          minIndex = evensIndex[index]\n        }\n    }\n    return [min, minIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var smallestEven: Int?\n    var smallestEvenIndex:\
    \ Int?\n    for (index, value) in arr.enumerated() {\n        if value % 2 ==\
    \ 0 {\n            if smallestEven == nil || value < smallestEven! {\n       \
    \         smallestEven = value\n                smallestEvenIndex = index\n  \
    \          }\n        }\n    }\n    if let smallestEven = smallestEven, let smallestEvenIndex\
    \ = smallestEvenIndex {\n        return [smallestEven, smallestEvenIndex]\n  \
    \  }\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return\
    \ [] }\n    let minEven = evens.min()!\n    let minEvenIndex = arr.firstIndex(of:\
    \ minEven)!\n    return [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.count > 0 else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard evens.count > 0 else {\
    \ return [] }\n    let minEven = evens.min()!\n    guard let minEvenIndex = arr.firstIndex(of:\
    \ minEven) else { return [] }\n    return [minEven, minEvenIndex]\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let minEven = evens.min() else { return [] }\n    let index = arr.firstIndex(of:\
    \ minEven)!\n    return [minEven, index]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\n\
    assert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0,\
    \ 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr:\
    \ [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return\
    \ [] }\n    let minEven = evens.min()!\n    let minEvenIndex = arr.firstIndex(of:\
    \ minEven)!\n    return [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return\
    \ [] }\n    let minEven = evens.min()!\n    let minEvenIndex = arr.firstIndex(of:\
    \ minEven)!\n    return [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return\
    \ [] }\n    let minEven = evens.min()!\n    let minEvenIndex = arr.firstIndex(of:\
    \ minEven)!\n    return [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return\
    \ [] }\n    let minEven = evens.min()!\n    let minEvenIndex = arr.firstIndex(of:\
    \ minEven)!\n    return [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var minEven =\
    \ Int.max\n    var minEvenIndex = Int.max\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 && value < minEven {\n            minEven = value\n\
    \            minEvenIndex = index\n        }\n    }\n    if minEven != Int.max\
    \ {\n        result.append(minEven)\n        result.append(minEvenIndex)\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var evens = [Int]()\n\
    \    for (index, value) in arr.enumerated() {\n        if value % 2 == 0 {\n \
    \           evens.append(value)\n            if evens.count == 1 {\n         \
    \       result.append(value)\n                result.append(index)\n         \
    \   } else if value < result[0] {\n                result[0] = value\n       \
    \         result[1] = index\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var minEvenValue = Int.max\n    var minEvenValueIndex\
    \ = Int.max\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 && value < minEvenValue {\n            minEvenValue = value\n       \
    \     minEvenValueIndex = index\n        }\n    }\n    if minEvenValue == Int.max\
    \ {\n        return []\n    }\n    return [minEvenValue, minEvenValueIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens = [Int]()\n    var evensIndex\
    \ = [Int]()\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 {\n            evens.append(value)\n            evensIndex.append(index)\n\
    \        }\n    }\n    if evens.count == 0 {\n        return []\n    }\n    let\
    \ minEven = evens.min()!\n    let minEvenIndex = evensIndex[evens.firstIndex(of:\
    \ minEven)!]\n    return [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var evens = [Int]()\n\
    \    for (index, value) in arr.enumerated() {\n        if value % 2 == 0 {\n \
    \           evens.append(value)\n            result.append(index)\n        }\n\
    \    }\n    if evens.count == 0 {\n        return []\n    }\n    let min = evens.min()\n\
    \    let minIndex = evens.firstIndex(of: min!)\n    return [min!, result[minIndex!]]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let minEven = evens.min() else { return [] }\n    guard let minEvenIndex\
    \ = arr.firstIndex(of: minEven) else { return [] }\n    return [minEven, minEvenIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.count > 0 else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard evens.count > 0 else {\
    \ return [] }\n    let smallestEven = evens.min()!\n    let smallestEvenIndex\
    \ = arr.firstIndex(of: smallestEven)!\n    return [smallestEven, smallestEvenIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let smallestEven = evens.min() else { return [] }\n    guard let index\
    \ = arr.firstIndex(of: smallestEven) else { return [] }\n    return [smallestEven,\
    \ index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3])\
    \ == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as\
    \ [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return\
    \ [] }\n    let min = evens.min()!\n    let index = arr.firstIndex(of: min)!\n\
    \    return [min, index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var minEven =\
    \ Int.max\n    var minEvenIndex = Int.max\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 && value < minEven {\n            minEven = value\n\
    \            minEvenIndex = index\n        }\n    }\n    if minEven != Int.max\
    \ {\n        result.append(minEven)\n        result.append(minEvenIndex)\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var minEven =\
    \ Int.max\n    var minEvenIndex = -1\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 {\n            if value < minEven {\n         \
    \       minEven = value\n                minEvenIndex = index\n            }\n\
    \        }\n    }\n    if minEvenIndex != -1 {\n        result.append(minEven)\n\
    \        result.append(minEvenIndex)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var minEven =\
    \ Int.max\n    var minEvenIndex = Int.max\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 && value < minEven {\n            minEven = value\n\
    \            minEvenIndex = index\n        }\n    }\n    if minEven != Int.max\
    \ {\n        result.append(minEven)\n        result.append(minEvenIndex)\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var minEven = Int.max\n    var minEvenIndex\
    \ = Int.max\n    for (index, value) in arr.enumerated() {\n        if value.isEven\
    \ && value < minEven {\n            minEven = value\n            minEvenIndex\
    \ = index\n        }\n    }\n    return minEven == Int.max ? [] : [minEven, minEvenIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpko__qs43.swift:31:18: error: value of type 'Int' has no member\
    \ 'isEven'\n        if value.isEven && value < minEven {\n           ~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return\
    \ [] }\n    let minEven = evens.min()!\n    let minEvenIndex = arr.firstIndex(of:\
    \ minEven)!\n    return [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var evens = [Int]()\n\
    \    for (index, value) in arr.enumerated() {\n        if value % 2 == 0 {\n \
    \           evens.append(value)\n            result.append(index)\n        }\n\
    \    }\n    if evens.count == 0 {\n        return []\n    }\n    let min = evens.min()!\n\
    \    let index = evens.firstIndex(of: min)!\n    return [min, result[index]]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return\
    \ [] }\n    let minEven = evens.min()!\n    let minEvenIndex = arr.firstIndex(of:\
    \ minEven)!\n    return [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let minEven = evens.min() else { return [] }\n    return [minEven,\
    \ arr.firstIndex(of: minEven)!]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens = [Int]()\n    var evensIndex\
    \ = [Int]()\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 {\n            evens.append(value)\n            evensIndex.append(index)\n\
    \        }\n    }\n    if evens.count == 0 {\n        return []\n    }\n    var\
    \ min = evens[0]\n    var minIndex = evensIndex[0]\n    for (index, value) in\
    \ evens.enumerated() {\n        if value < min {\n            min = value\n  \
    \          minIndex = evensIndex[index]\n        }\n    }\n    return [min, minIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    // your code here\n    return []\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmp1trbo8cb/tmp1trbo8cb.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e5afcbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e5acc2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9e5acc2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9e5acc17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1trbo8cb                        0x00005560d5b543bc <unavailable> + 5052

    5    libc.so.6                          0x00002b9e5b1b7460 __libc_start_main +
    245

    6    tmp1trbo8cb                        0x00005560d5b53fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var smallestEvenValue\
    \ = Int.max\n    var smallestEvenValueIndex = Int.max\n    for (index, value)\
    \ in arr.enumerated() {\n        if value % 2 == 0 && value < smallestEvenValue\
    \ {\n            smallestEvenValue = value\n            smallestEvenValueIndex\
    \ = index\n        }\n    }\n    if smallestEvenValue < Int.max {\n        result.append(smallestEvenValue)\n\
    \        result.append(smallestEvenValueIndex)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let minEven = evens.min() else { return [] }\n    let index = arr.firstIndex(of:\
    \ minEven)!\n    return [minEven, index]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\n\
    assert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0,\
    \ 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr:\
    \ [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var smallestEven\
    \ = Int.max\n    var smallestEvenIndex = Int.max\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 {\n            if value < smallestEven {\n    \
    \            smallestEven = value\n                smallestEvenIndex = index\n\
    \            }\n        }\n    }\n    if smallestEven != Int.max {\n        result.append(smallestEven)\n\
    \        result.append(smallestEvenIndex)\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let minEven = evens.min() else { return [] }\n    let minEvenIndex\
    \ = arr.firstIndex(of: minEven)!\n    return [minEven, minEvenIndex]\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var minEven =\
    \ Int.max\n    var minEvenIndex = Int.max\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 {\n            if value < minEven {\n         \
    \       minEven = value\n                minEvenIndex = index\n            }\n\
    \        }\n    }\n    if minEven != Int.max {\n        result.append(minEven)\n\
    \        result.append(minEvenIndex)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return []\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpgh8dpvxh/tmpgh8dpvxh.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac906ec4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac906bbbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac906bbb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac906bba7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgh8dpvxh                        0x00005578e3d9c3bc <unavailable> + 5052

    5    libc.so.6                          0x00002ac9070b0460 __libc_start_main +
    245

    6    tmpgh8dpvxh                        0x00005578e3d9bfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let minEven = evens.min() else { return [] }\n    let minEvenIndex\
    \ = arr.firstIndex(of: minEven)!\n    return [minEven, minEvenIndex]\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return\
    \ [] }\n    let minEven = evens.min()!\n    let minEvenIndex = arr.firstIndex(of:\
    \ minEven)!\n    return [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let minEven = evens.min() else { return [] }\n    guard let index =\
    \ arr.firstIndex(of: minEven) else { return [] }\n    return [minEven, index]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let smallestEven = evens.min() else { return [] }\n    guard let index\
    \ = arr.firstIndex(of: smallestEven) else { return [] }\n    return [smallestEven,\
    \ index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3])\
    \ == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as\
    \ [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr.enumerated().filter { $0.element\
    \ % 2 == 0 }.min { $0.element < $1.element }?.reversed() ?? []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_s2yc6jv.swift:28:93: error: value of tuple type 'EnumeratedSequence<[Int]>.Iterator.Element'\
    \ (aka '(offset: Int, element: Int)') has no member 'reversed'\n    return arr.enumerated().filter\
    \ { $0.element % 2 == 0 }.min { $0.element < $1.element }?.reversed() ?? []\n\
    \           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.count > 0 else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard evens.count > 0 else {\
    \ return [] }\n    let minEven = evens.min()!\n    let index = arr.firstIndex(of:\
    \ minEven)!\n    return [minEven, index]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\n\
    assert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0,\
    \ 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr:\
    \ [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var smallestEven\
    \ = Int.max\n    var smallestEvenIndex = Int.max\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 && value < smallestEven {\n            smallestEven\
    \ = value\n            smallestEvenIndex = index\n        }\n    }\n    if smallestEven\
    \ != Int.max {\n        result.append(smallestEven)\n        result.append(smallestEvenIndex)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var minEven =\
    \ Int.max\n    var minEvenIndex = Int.max\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 {\n            if value < minEven {\n         \
    \       minEven = value\n                minEvenIndex = index\n            }\n\
    \        }\n    }\n    if minEven != Int.max {\n        result.append(minEven)\n\
    \        result.append(minEvenIndex)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let minEven = evens.min() else { return [] }\n    guard let index =\
    \ arr.firstIndex(of: minEven) else { return [] }\n    return [minEven, index]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return\
    \ [] }\n    let min = evens.min()!\n    let index = arr.firstIndex(of: min)!\n\
    \    return [min, index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return\
    \ [] }\n    let minEven = evens.min()!\n    let index = arr.firstIndex(of: minEven)!\n\
    \    return [minEven, index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens = [Int]()\n    var evensIndex\
    \ = [Int]()\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 {\n            evens.append(value)\n            evensIndex.append(index)\n\
    \        }\n    }\n    if evens.count == 0 {\n        return []\n    }\n    var\
    \ minEven = evens[0]\n    var minEvenIndex = evensIndex[0]\n    for (index, value)\
    \ in evens.enumerated() {\n        if value < minEven {\n            minEven =\
    \ value\n            minEvenIndex = evensIndex[index]\n        }\n    }\n    return\
    \ [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let min = evens.min() else { return [] }\n    let index = arr.firstIndex(of:\
    \ min) ?? 0\n    return [min, index]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\n\
    assert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0,\
    \ 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr:\
    \ [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens = [Int]()\n    var evensIndex\
    \ = [Int]()\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 {\n            evens.append(value)\n            evensIndex.append(index)\n\
    \        }\n    }\n    if evens.count == 0 {\n        return []\n    }\n    var\
    \ min = evens[0]\n    var minIndex = evensIndex[0]\n    for (index, value) in\
    \ evens.enumerated() {\n        if value < min {\n            min = value\n  \
    \          minIndex = evensIndex[index]\n        }\n    }\n    return [min, minIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens = [Int]()\n    var evensIndex\
    \ = [Int]()\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 {\n            evens.append(value)\n            evensIndex.append(index)\n\
    \        }\n    }\n    if evens.count == 0 {\n        return []\n    }\n    let\
    \ minEven = evens.min()!\n    let minEvenIndex = evensIndex[evens.firstIndex(of:\
    \ minEven)!]\n    return [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var smallestEven = Int.max\n    var smallestEvenIndex\
    \ = -1\n    for (index, value) in arr.enumerated() {\n        if value % 2 ==\
    \ 0 {\n            if value < smallestEven {\n                smallestEven = value\n\
    \                smallestEvenIndex = index\n            }\n        }\n    }\n\
    \    if smallestEvenIndex == -1 {\n        return []\n    }\n    return [smallestEven,\
    \ smallestEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let min = evens.min() else { return [] }\n    return [min, arr.firstIndex(of:\
    \ min)!]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3])\
    \ == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as\
    \ [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var smallestEvenValue = Int.max\n    var\
    \ smallestEvenValueIndex = Int.max\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 && value < smallestEvenValue {\n            smallestEvenValue\
    \ = value\n            smallestEvenValueIndex = index\n        }\n    }\n    if\
    \ smallestEvenValue == Int.max {\n        return []\n    }\n    return [smallestEvenValue,\
    \ smallestEvenValueIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var smallestEvenValue = Int.max\n    var\
    \ smallestEvenValueIndex = Int.max\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 {\n            if value < smallestEvenValue {\n\
    \                smallestEvenValue = value\n                smallestEvenValueIndex\
    \ = index\n            }\n        }\n    }\n    if smallestEvenValue == Int.max\
    \ {\n        return []\n    }\n    return [smallestEvenValue, smallestEvenValueIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens = [Int]()\n    var evenIndexes\
    \ = [Int]()\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 {\n            evens.append(value)\n            evenIndexes.append(index)\n\
    \        }\n    }\n    if evens.count == 0 {\n        return []\n    }\n    let\
    \ minEven = evens.min()!\n    let minEvenIndex = evenIndexes[evens.firstIndex(of:\
    \ minEven)!]\n    return [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var minEven =\
    \ Int.max\n    var minEvenIndex = Int.max\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 && value < minEven {\n            minEven = value\n\
    \            minEvenIndex = index\n        }\n    }\n    if minEven != Int.max\
    \ {\n        result.append(minEven)\n        result.append(minEvenIndex)\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return\
    \ [] }\n    let minEven = evens.min()!\n    let minEvenIndex = arr.firstIndex(of:\
    \ minEven)!\n    return [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var minEven =\
    \ Int.max\n    for (index, value) in arr.enumerated() {\n        if value % 2\
    \ == 0 && value < minEven {\n            minEven = value\n            result =\
    \ [value, index]\n        }\n    }\n    return result.isEmpty ? [] : result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr.enumerated().filter { $0.element\
    \ % 2 == 0 }.min { $0.element < $1.element }?.reversed() ?? []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_s2yc6jv.swift:28:93: error: value of tuple type 'EnumeratedSequence<[Int]>.Iterator.Element'\
    \ (aka '(offset: Int, element: Int)') has no member 'reversed'\n    return arr.enumerated().filter\
    \ { $0.element % 2 == 0 }.min { $0.element < $1.element }?.reversed() ?? []\n\
    \           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return\
    \ [] }\n    let minEven = evens.min()!\n    let minEvenIndex = arr.firstIndex(of:\
    \ minEven)!\n    return [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var minEven = Int.max\n    var minEvenIndex\
    \ = Int.max\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 {\n            if value < minEven {\n                minEven = value\n\
    \                minEvenIndex = index\n            }\n        }\n    }\n    if\
    \ minEven == Int.max {\n        return []\n    }\n    return [minEven, minEvenIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let smallestEven = evens.min() else { return [] }\n    guard let index\
    \ = arr.firstIndex(of: smallestEven) else { return [] }\n    return [smallestEven,\
    \ index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3])\
    \ == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as\
    \ [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var smallestEven\
    \ = Int.max\n    var smallestEvenIndex = Int.max\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 && value < smallestEven {\n            smallestEven\
    \ = value\n            smallestEvenIndex = index\n        }\n    }\n    if smallestEven\
    \ != Int.max {\n        result.append(smallestEven)\n        result.append(smallestEvenIndex)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let smallestEven = evens.min() else { return [] }\n    guard let index\
    \ = arr.firstIndex(of: smallestEven) else { return [] }\n    return [smallestEven,\
    \ index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3])\
    \ == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as\
    \ [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var minEven =\
    \ Int.max\n    for (index, value) in arr.enumerated() {\n        if value % 2\
    \ == 0 {\n            if value < minEven {\n                minEven = value\n\
    \                result = [value, index]\n            }\n        }\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens = [Int]()\n    var index = 0\n\
    \    for i in arr {\n        if i % 2 == 0 {\n            evens.append(i)\n  \
    \      }\n    }\n    if evens.count == 0 {\n        return []\n    }\n    var\
    \ min = evens[0]\n    for i in evens {\n        if i < min {\n            min\
    \ = i\n        }\n    }\n    for i in arr {\n        if i == min {\n         \
    \   break\n        }\n        index += 1\n    }\n    return [min, index]\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return []\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpgh8dpvxh/tmpgh8dpvxh.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac906ec4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac906bbbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac906bbb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac906bba7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgh8dpvxh                        0x00005578e3d9c3bc <unavailable> + 5052

    5    libc.so.6                          0x00002ac9070b0460 __libc_start_main +
    245

    6    tmpgh8dpvxh                        0x00005578e3d9bfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens = [Int]()\n    var evensIndex\
    \ = [Int]()\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 {\n            evens.append(value)\n            evensIndex.append(index)\n\
    \        }\n    }\n    if evens.count == 0 {\n        return []\n    }\n    var\
    \ min = evens[0]\n    var minIndex = evensIndex[0]\n    for (index, value) in\
    \ evens.enumerated() {\n        if value < min {\n            min = value\n  \
    \          minIndex = evensIndex[index]\n        }\n    }\n    return [min, minIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens: [Int] = []\n    for (index,\
    \ value) in arr.enumerated() {\n        if value % 2 == 0 {\n            evens.append(value)\n\
    \        }\n    }\n    if evens.count == 0 {\n        return []\n    }\n    let\
    \ min = evens.min()!\n    for (index, value) in arr.enumerated() {\n        if\
    \ value == min {\n            return [value, index]\n        }\n    }\n    return\
    \ []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2,\
    \ 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int])\
    \ == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens = [Int]()\n    var evensIndex\
    \ = [Int]()\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 {\n            evens.append(value)\n            evensIndex.append(index)\n\
    \        }\n    }\n    if evens.count == 0 {\n        return []\n    }\n    var\
    \ min = evens[0]\n    var minIndex = evensIndex[0]\n    for (index, value) in\
    \ evens.enumerated() {\n        if value < min {\n            min = value\n  \
    \          minIndex = evensIndex[index]\n        }\n    }\n    return [min, minIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens: [Int] = []\n    var evensIndex:\
    \ [Int] = []\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 {\n            evens.append(value)\n            evensIndex.append(index)\n\
    \        }\n    }\n    if evens.count == 0 {\n        return []\n    }\n    var\
    \ minEven = evens[0]\n    var minEvenIndex = evensIndex[0]\n    for (index, value)\
    \ in evens.enumerated() {\n        if value < minEven {\n            minEven =\
    \ value\n            minEvenIndex = evensIndex[index]\n        }\n    }\n    return\
    \ [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr.enumerated().filter { $0.element\
    \ % 2 == 0 }.min { $0.element < $1.element }?.map { [$0, $1] } ?? []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp3yz7vuhg.swift:28:93: error: value of tuple type 'EnumeratedSequence<[Int]>.Iterator.Element'\
    \ (aka '(offset: Int, element: Int)') has no member 'map'\n    return arr.enumerated().filter\
    \ { $0.element % 2 == 0 }.min { $0.element < $1.element }?.map { [$0, $1] } ??\
    \ []\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~\n"
  stdout: ''
  timestamp: 1660013365
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return []\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpgh8dpvxh/tmpgh8dpvxh.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac906ec4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac906bbbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac906bbb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac906bba7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgh8dpvxh                        0x00005578e3d9c3bc <unavailable> + 5052

    5    libc.so.6                          0x00002ac9070b0460 __libc_start_main +
    245

    6    tmpgh8dpvxh                        0x00005578e3d9bfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens: [Int] = []\n    var evensIndexes:\
    \ [Int] = []\n    for (index, element) in arr.enumerated() {\n        if element\
    \ % 2 == 0 {\n            evens.append(element)\n            evensIndexes.append(index)\n\
    \        }\n    }\n    if evens.count == 0 {\n        return []\n    }\n    var\
    \ min = evens[0]\n    var minIndex = evensIndexes[0]\n    for (index, element)\
    \ in evens.enumerated() {\n        if element < min {\n            min = element\n\
    \            minIndex = evensIndexes[index]\n        }\n    }\n    return [min,\
    \ minIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3])\
    \ == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as\
    \ [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let min = evens.min() else { return [] }\n    guard let index = arr.firstIndex(of:\
    \ min) else { return [] }\n    return [min, index]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var minEven =\
    \ Int.max\n    var minEvenIndex = Int.max\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 && value < minEven {\n            minEven = value\n\
    \            minEvenIndex = index\n        }\n    }\n    if minEven != Int.max\
    \ {\n        result.append(minEven)\n        result.append(minEvenIndex)\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return\
    \ [] }\n    let minEven = evens.min()!\n    let index = arr.firstIndex(of: minEven)!\n\
    \    return [minEven, index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var smallestEvenValue = Int.max\n    var\
    \ smallestEvenValueIndex = -1\n    for (index, value) in arr.enumerated() {\n\
    \        if value % 2 == 0 {\n            if value < smallestEvenValue {\n   \
    \             smallestEvenValue = value\n                smallestEvenValueIndex\
    \ = index\n            }\n        }\n    }\n    if smallestEvenValueIndex == -1\
    \ {\n        return []\n    }\n    return [smallestEvenValue, smallestEvenValueIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens = [Int]()\n    var evensIndex\
    \ = [Int]()\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 {\n            evens.append(value)\n            evensIndex.append(index)\n\
    \        }\n    }\n    guard let minEven = evens.min() else { return [] }\n  \
    \  let minEvenIndex = evensIndex[evens.firstIndex(of: minEven)!]\n    return [minEven,\
    \ minEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
