name: HumanEval_120_maximum
language: swift
prompt: "\n/// Given an array arr of integers and a positive integer k, return a sorted\
  \ array \n/// of length k with the maximum k numbers in arr.\n/// Example 1:\n///\
  \ >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n/// >>>\
  \ maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
  \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
  \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
  \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
  \ [Int], k: Int) -> [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4,\
  \ -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr:\
  \ [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0,\
  \ 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3],\
  \ k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7)\
  \ == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
  \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
  \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
  assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
completions: ["    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n  \
    \  for i in 0..<arr.count {\n        maxHeap.insert(arr[i])\n        if maxHeap.count\
    \ > k {\n            maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty\
    \ {\n        result.append(maxHeap.remove()!)\n    }\n    return result", "  \
    \  var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count\
    \ {\n        maxHeap.insert(arr[i])\n        if maxHeap.count > k {\n        \
    \    maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty {\n      \
    \  result.append(maxHeap.remove()!)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<arr.count {\n\
    \        heap.insert(arr[i])\n        if heap.count > k {\n            heap.remove()\n\
    \        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var maxHeap = MaxHeap<Int>()\n\
    \    for i in 0..<arr.count {\n        maxHeap.insert(arr[i])\n        if maxHeap.count\
    \ > k {\n            maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty\
    \ {\n        result.append(maxHeap.remove()!)\n    }\n    return result", "  \
    \  var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for num in arr\
    \ {\n        heap.insert(num)\n        if heap.count > k {\n            heap.remove()\n\
    \        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var minHeap = MinHeap<Int>()\n\
    \    for i in 0..<arr.count {\n        if i < k {\n            minHeap.insert(arr[i])\n\
    \        } else {\n            if arr[i] > minHeap.peek()! {\n               \
    \ minHeap.pop()\n                minHeap.insert(arr[i])\n            }\n     \
    \   }\n    }\n    while !minHeap.isEmpty() {\n        result.append(minHeap.pop()!)\n\
    \    }\n    return result.reversed()", "    var result = [Int]()\n    var maxHeap\
    \ = Heap<Int>(sort: >)\n    for num in arr {\n        maxHeap.insert(num)\n  \
    \      if maxHeap.count > k {\n            maxHeap.remove()\n        }\n    }\n\
    \    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n\
    \    return result", "    var result = [Int]()\n    var arr = arr\n    for _ in\
    \ 0..<k {\n        var max = Int.min\n        var index = 0\n        for i in\
    \ 0..<arr.count {\n            if arr[i] > max {\n                max = arr[i]\n\
    \                index = i\n            }\n        }\n        result.append(max)\n\
    \        arr.remove(at: index)\n    }\n    return result", "    var result = [Int]()\n\
    \    var maxHeap = Heap<Int>(sort: >)\n    for num in arr {\n        maxHeap.insert(num)\n\
    \        if maxHeap.count > k {\n            maxHeap.remove()\n        }\n   \
    \ }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    for num in arr {\n\
    \        if result.count < k {\n            result.append(num)\n            result.sort()\n\
    \        } else {\n            if num > result[0] {\n                result.remove(at:\
    \ 0)\n                result.append(num)\n                result.sort()\n    \
    \        }\n        }\n    }\n    return result", "    var result = [Int]()\n\
    \    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count {\n        maxHeap.insert(arr[i])\n\
    \        if maxHeap.count > k {\n            maxHeap.remove()\n        }\n   \
    \ }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    for i in 0..<k {\n\
    \        result.append(arr[i])\n    }\n    result.sort()\n    for i in k..<arr.count\
    \ {\n        if arr[i] > result[0] {\n            result[0] = arr[i]\n       \
    \     result.sort()\n        }\n    }\n    return result", "    var result = [Int]()\n\
    \    for i in 0..<k {\n        var max = Int.min\n        var maxIndex = 0\n \
    \       for j in i..<arr.count {\n            if arr[j] > max {\n            \
    \    max = arr[j]\n                maxIndex = j\n            }\n        }\n  \
    \      result.append(max)\n        arr.swapAt(i, maxIndex)\n    }\n    return\
    \ result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n \
    \   for i in 0..<arr.count {\n        maxHeap.insert(arr[i])\n        if maxHeap.count\
    \ > k {\n            maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty\
    \ {\n        result.append(maxHeap.remove()!)\n    }\n    return result", "  \
    \  var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count\
    \ {\n        maxHeap.insert(arr[i])\n        if maxHeap.count > k {\n        \
    \    maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty {\n      \
    \  result.append(maxHeap.remove()!)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var sortedArr = arr.sorted()\n    for i in 0..<k {\n        result.append(sortedArr[sortedArr.count\
    \ - 1 - i])\n    }\n    return result", "    var result = [Int]()\n    var maxHeap\
    \ = Heap<Int>(sort: >)\n    for i in 0..<arr.count {\n        maxHeap.insert(arr[i])\n\
    \        if maxHeap.count > k {\n            maxHeap.remove()\n        }\n   \
    \ }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    for i in 0..<k {\n\
    \        result.append(arr[i])\n    }\n    result.sort()\n    for i in k..<arr.count\
    \ {\n        if arr[i] > result[0] {\n            result[0] = arr[i]\n       \
    \     result.sort()\n        }\n    }\n    return result", "    var result = [Int]()\n\
    \    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count {\n        maxHeap.insert(arr[i])\n\
    \        if maxHeap.count > k {\n            maxHeap.remove()\n        }\n   \
    \ }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var k = k\n    for\
    \ i in 0..<arr.count {\n        while result.count > 0 && result.last! < arr[i]\
    \ && k < arr.count - i {\n            result.removeLast()\n            k += 1\n\
    \        }\n        if result.count < k {\n            result.append(arr[i])\n\
    \        }\n    }\n    return result"]
stop_tokens:
- "\n}"
